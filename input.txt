plugin_II\game_II\CCamera.cpp:
  11  void CCamera::WorldToScreen2D(int x, int y, int z, int* outX, int* outY) {
  12:     plugin::CallMethod<0x4B90E0>(this, x, y, z, outX, outY);
  13  }

plugin_II\game_II\CCar.cpp:
  10  void CCar::SetPosition(CEncodedVector pos) {
  11:     plugin::CallMethod<0x4207F0, CCar*, CEncodedVector>(this, pos);
  12  }

  14  void CCar::SetRemap(short remap) {
  15:     plugin::CallMethod<0x421FD0, CCar*>(this, remap);
  16  }

plugin_II\game_II\CChar.cpp:
  15  CPed* CChar::CreatePed(CEncodedVector pos, char remap, int rotation) {
  16:     return plugin::CallMethodAndReturn<CPed*, 0x43DB40, CChar*, CEncodedVector, char, int>(this, pos, remap, rotation);
  17  }

  19  CPed* CChar::FindPed(int id) {
  20:     return plugin::CallMethodAndReturn<CPed*, 0x43AE10, CChar*, int>(this, id);
  21  }

plugin_II\game_II\cDMAudio.cpp:
  14  char cDMAudio::GetEffectsMasterVolume() {
  15:     return plugin::CallMethodAndReturn<char, 0x4105F0, cDMAudio*>(this);
  16  }

  18  char cDMAudio::GetMusicMasterVolume() {
  19:     return plugin::CallMethodAndReturn<char, 0x410630, cDMAudio*>(this);
  20  }

  22  void cDMAudio::SetMusicMasterVolume(unsigned char volume) {
  23:     plugin::CallMethod<0x410600, cDMAudio*, unsigned char>(this, volume);
  24  }

  26  void cDMAudio::SetEffectsMasterVolume(unsigned char volume) {
  27:     plugin::CallMethod<0x4105C0, cDMAudio*, unsigned char>(this, volume);
  28  }

  30  void cDMAudio::SetCurrent3DProvider(unsigned char provider) {
  31:     plugin::CallMethod<0x410670, cDMAudio*, unsigned char>(this, provider);
  32  }

  34  void cDMAudio::PlayVocal(unsigned short id) {
  35:     plugin::CallMethod<0x4105B0, cDMAudio*>(this, id);
  36  }

  38  void cDMAudio::ReleaseDigitalHandle() {
  39:     plugin::CallMethod<0x410640, cDMAudio*>(this);
  40  }

  42  int cDMAudio::CreateEntity(void* e) {
  43:     return plugin::CallMethodAndReturn<int, 0x410530, cDMAudio*, void*>(this, e);
  44  }

  46  void cDMAudio::DestroyEntity(int audioEntity) {
  47:     plugin::CallMethod<0x410540, cDMAudio*, int>(this, audioEntity);
  48  }

plugin_II\game_II\CFileMgr.cpp:
  10  int CFileMgr::OpenFile(const char* name) {
  11:     return plugin::CallStdAndReturn<int, 0x403160, const char*>(name);
  12  }

  14  int CFileMgr::CloseFile() {
  15:     return plugin::CallStdAndReturn<int, 0x402EB0>();
  16  }

  18  size_t CFileMgr::Read(void* buff, int const& size) {
  19:     return plugin::CallStdAndReturn<size_t, 0x402FB0, void*, int const&>(buff, size);
  20  }

  22  bool CFileMgr::ReadLine(void* buff, int const& size) {
  23:     return plugin::CallStdAndReturn<bool, 0x403000, void*, int const&>(buff, size);
  24  }

  26  int CFileMgr::Seek(int const& size) {
  27:     return plugin::CallStdAndReturn<int, 0x402F60, int const&>(size);
  28  }

plugin_II\game_II\CFont.cpp:
   9  int CFont::GetStringWidth(const wchar_t* str, int style) {
  10:     return plugin::CallStdAndReturn<int, 0x4CB0C0, const wchar_t*, int>(str, style);
  11  }

  13  int CFont::GetNumberLines(const wchar_t* str, int style) {
  14:     return plugin::CallStdAndReturn<int, 0x4CC0C0, const wchar_t*, int>(str, style);
  15  }

  17  int CFont::GetCharHeight(wchar_t c) {
  18:     return plugin::CallStdAndReturn<int, 0x4539B0, wchar_t>(c);
  19  }

  21  void CFont::PrintString(const wchar_t* str, int x, int y, int style, int scale, int const& mode, int palette, bool enableAlpha, int alpha) {
  22:     plugin::CallStd<0x4CC100, const wchar_t*, int, int, int, int, int const&, int, bool, int>(str, x, y, style, scale, mode, palette, enableAlpha, alpha);
  23  }

plugin_II\game_II\CGame.cpp:
  17  CPlayerPed* CGame::FindPlayerPed(unsigned char index) {
  18:     return plugin::CallMethodAndReturn<CPlayerPed*, 0x4219E0, CGame*, unsigned char>(this, index);
  19  }

  21  void CGame::SwitchUserPause() {
  22:     plugin::CallMethod<0x45BAA0, CGame*>(this);
  23  }

  25  void CGame::Process() {
  26:     plugin::CallMethod<0x45C1F0, CGame*>(this);
  27  }

  29  void CGame::SetState(int unk, int state) {
  30:     plugin::CallMethod<0x45A4B0, CGame*, int, int>(this, unk, state);
  31  }

  33  bool CGame::GetIsUserPaused() {
  34:     return plugin::CallMethodAndReturn<bool, 0x416BC0, CGame*>(this);
  35  }

plugin_II\game_II\CGeneral.cpp:
  15  int CGeneral::GetCycle() {
  16:     return plugin::CallMethodAndReturn<int, 0x41CFE0, CGeneral*>(this);
  17  }

  19  int CGeneral::GetRandomNumber() {
  20:     return plugin::CallMethodAndReturn<int, 0x45F9E0, CGeneral*>(this);
  21  }

  23  void CGeneral::Update() {
  24:     plugin::CallMethod<0x44AA30, CGeneral*>(this);
  25  }

  27  void CGeneral::PrintCycle() {
  28:     plugin::CallMethod<0x44AA90, CGeneral*>(this);
  29  }

plugin_II\game_II\CHud.cpp:
  16  bool CHudArrow::AreBothArrowTracesUsed() {
  17:     return plugin::CallMethodAndReturn<bool, 0x4C6F80>(this);
  18  }

  20  bool CHudArrow::IsArrowVisible() {
  21:     return plugin::CallMethodAndReturn<bool, 0x4C7050>(this);
  22  }

  24  void CHudArrow::SetSpriteId(short id) {
  25:     plugin::CallMethod<0x4C6FE0>(this, id);
  26  }

  28  void CHud::DrawSprite(int id1, int id2, int x, int y, char style, int const& mode, int enableAlpha, int alpha, char unk) {
  29:     plugin::CallStd<0x4C71B0, int, int, int, int, char, int const&, int, int, char>(id1, id2, x, y, style, mode, enableAlpha, alpha, unk);
  30  }

  32  void CHudMessage::SetHudMessage(wchar_t* str, int priority) {
  33:     plugin::CallMethod<0x4C6060>(this, str, priority);
  34  }

  36  void CHudBrief::SetHudBrief(int priority, const char* str) {
  37:     plugin::CallMethod<0x4C6750>(this, priority, str);
  38  }

  40  void CHudBrief::Clear(int priority) {
  41:     plugin::CallMethod<0x4C6860>(this, priority);
  42  }

plugin_II\game_II\CKeybrd.cpp:
  16  bool CKeybrd::Keydown(unsigned short key) {
  17:     return plugin::CallMethodAndReturn<bool, 0x4611F0, CKeybrd*, unsigned short>(this, key);
  18  }

plugin_II\game_II\CMenuManager.cpp:
  17  void CMenuManager::LoadTexture(unsigned short id) {
  18:     plugin::CallStd<0x452D50, unsigned short>(id);
  19  }

  21  void CMenuManager::FindBackground(unsigned char screen, unsigned char* left, unsigned char* right) {
  22:     plugin::CallStd<0x452E80, unsigned char, unsigned char*, unsigned char*>(screen, left, right);
  23  }

  25  bool CMenuManager::GetKeyboardKeyStates() {
  26:     return plugin::CallMethodAndReturn<bool, 0x452000, CMenuManager*>(this);
  27  }

  33  void CMenuManager::SwitchToNewScreen(unsigned short page) {
  34:     plugin::CallMethod<0x4587B0, CMenuManager*, unsigned short>(this, page);
  35  }

  37  int CMenuManager::Process() {
  38:     return plugin::CallMethodAndReturn<int, 0x45A320, CMenuManager*>(this);
  39  }

  41  void CMenuManager::PopulateMenu() {
  42:     plugin::CallMethod<0x453E20, CMenuManager*>(this);
  43  }

plugin_II\game_II\CObject.cpp:
  10  int const& CObject::GetPositionX(int* x) {
  11:     return plugin::CallMethodAndReturn<int const&, 0x4339C0, CObject*, int*>(this, x);
  12  }

  14  int const& CObject::GetPositionY(int* y) {
  15:     return plugin::CallMethodAndReturn<int const&, 0x4339E0, CObject*, int*>(this, y);
  16  }

  18  int const& CObject::GetPositionZ(int* z) {
  19:     return plugin::CallMethodAndReturn<int const&, 0x433A00, CObject*, int*>(this, z);
  20  }

  22  short const& CObject::GetRotation(short* r) {
  23:     return plugin::CallMethodAndReturn<short const&, 0x433A40, CObject*, short*>(this, r);
  24  }

  26  void CObject::SetPosition(CEncodedVector pos) {
  27:     plugin::CallMethod<0x491E00, CObject*, CEncodedVector>(this, pos);
  28  }

  30  void CObject::SetRotation(short rot) {
  31:     plugin::CallMethod<0x433A30, CObject*, short>(this, rot);
  32  }

plugin_II\game_II\CPed.cpp:
   10  void CPed::GiveWeapon(int id, int ammo) {
   11:     plugin::CallMethod<0x43E4B0, CPed*, int, int>(this, id, ammo);
   12  }

   14  void CPed::SetWantedLevel(char level) {
   15:     plugin::CallMethod<0x434CD0, CPed*, char>(this, level);
   16  }

   18  void CPed::ClearWantedLevel() {
   19:     plugin::CallMethod<0x420B80, CPed*>(this);
   20  }

   22  unsigned int CPed::GetId() {
   23:     return plugin::CallMethodAndReturn<unsigned int, 0x420B60, CPed*>(this);
   24  }

   26  void CPed::SetHealth(short health) {
   27:     plugin::CallMethod<0x4039A0, CPed*>(this, health);
   28  }

   30  void CPed::Clear() {
   31:     plugin::CallMethod<0x435720, CPed*>(this);
   32  }

   34  void CPed::SetSearchType(eSearchType type) {
   35:     plugin::CallMethod<0x403920, CPed*>(this, type);
   36  }

   38  CSprite* CPed::GetSprite() {
   39:     return plugin::CallMethodAndReturn<CSprite*, 0x434B80, CPed*>(this);
   40  }

   42  CCar* CPed::GetCar() {
   43:     return plugin::CallMethodAndReturn<CCar*, 0x416B60, CPed*>(this);
   44  }

   46  int const& CPed::GetPositionX(int* x) {
   47:     return plugin::CallMethodAndReturn<int const&, 0x403A00, CPed*, int*>(this, x);
   48  }

   50  int const& CPed::GetPositionY(int* y) {
   51:     return plugin::CallMethodAndReturn<int const&, 0x403A10, CPed*, int*>(this, y);
   52  }

   54  int const& CPed::GetPositionZ(int* z) {
   55:     return plugin::CallMethodAndReturn<int const&, 0x416B50, CPed*, int*>(this, z);
   56  }

   75  short const& CPed::GetRotation(short* r) {
   76:     return plugin::CallMethodAndReturn<short const&, 0x4361B0, CPed*, short*>(this, r);
   77  }

   79  void CPed::SetPosition2D(CEncodedVector2D pos) {
   80:     plugin::CallMethod<0x435C80, CPed*, CEncodedVector2D>(this, pos);
   81  }

   83  void CPed::SetRotation(short rot) {
   84:     plugin::CallMethod<0x433C00, CPed*, short>(this, rot);
   85  }

   87  void CPed::SetOccupation(int occupation) {
   88:     plugin::CallMethod<0x403970, CPed*, int>(this, occupation);
   89  }

   91  void CPed::SetRemap(char remap) {
   92:     plugin::CallMethod<0x433B90, CPed*, char>(this, remap);
   93  }

   95  char CPed::GetRemap() {
   96:     return plugin::CallMethodAndReturn<char, 0x433BA0, CPed*>(this);
   97  }

   99  void CPed::EnterCarAsPassenger(CCar* target) {
  100:     plugin::CallMethod<0x43E350, CPed*, CCar*>(this, target);
  101  }

plugin_II\game_II\CPlayerPed.cpp:
  11  CPlayerPed::CPlayerPed(char index) {
  12:     plugin::CallMethod<0x4A83C0, CPlayerPed*, char>(this, index);
  13  }

  19  void CPlayerPed::SetInitialState() {
  20:     plugin::CallMethod<0x4A81E0, CPlayerPed*>(this);
  21  }

  23  void CPlayerPed::Teleport(int x, int y, int z) {
  24:     plugin::CallMethod<0x4A5AD0, CPlayerPed*>(this);
  25  }

  47  void CPlayerPed::ProcessKeyPresses(unsigned short key) {
  48:     plugin::CallMethod<0x4A7010, CPlayerPed*, unsigned short>(this, key);
  49  }

  51  void CPlayerPed::ProcessActions(char forward, char backward, char left, char right, char prevWeap, char nextWeap) {
  52:     plugin::CallMethod<0x41EA10, CPlayerPed*, char, char, char, char, char, char>(this, forward, backward, left, right, prevWeap, nextWeap);
  53  }

  55  void CPlayerPed::Process() {
  56:     plugin::CallMethod<0x4A7E80, CPlayerPed*>(this);
  57  }

  59  void CPlayerPed::SetPed(CPed* ped) {
  60:     plugin::CallMethod<0x4A5B40, CPlayerPed*, CPed*>(this, ped);
  61  }

  63  CPed* CPlayerPed::GetPed() {
  64:     return plugin::CallMethodAndReturn<CPed*, 0x4A5130, CPlayerPed*>(this);
  65  }

  67  void CPlayerPed::SetAllControlStatusOn() {
  68:     plugin::CallMethod<0x4A4E50, CPlayerPed*>(this);
  69  }

  71  void CPlayerPed::SetAllControlStatusOff() {
  72:     plugin::CallMethod<0x4A69A0, CPlayerPed*>(this);
  73  }

  75  void CPlayerPed::SetEnterControlStatusOn() {
  76:     plugin::CallMethod<0x4A4E90, CPlayerPed*>(this);
  77  }

  79  void CPlayerPed::SetEnterControlStatusOff() {
  80:     plugin::CallMethod<0x4A4E80, CPlayerPed*>(this);
  81  }

  83  CCamera* CPlayerPed::GetAuxCamera() {
  84:     return plugin::CallMethodAndReturn<CCamera*, 0x434900, CPlayerPed*>(this);
  85  }

plugin_II\game_II\CPopulation.cpp:
  15  CCar* CPopulation::SpawnCar(int x, int y, int z, short rot, int model) {
  16:     return plugin::CallMethodAndReturn<CCar*, 0x426E10, CPopulation*, int, int, int, short, int>(this, x, y, z, rot, model);
  17  }

plugin_II\game_II\CReplay.cpp:
  12  bool CReplay::IsPlayingBack() {
  13:     return plugin::CallMethodAndReturn<bool, 0x44AA60, CReplay*>(this);
  14  }

  16  void CReplay::SetButton(int button) {
  17:     return plugin::CallMethod<0x45ED10, CReplay*>(this, button);
  18  }

  20  void CReplay::ClearButton(int button) {
  21:     return plugin::CallMethod<0x45ED30, CReplay*>(this, button);
  22  }

  24  bool CReplay::GetButton(int button) {
  25:     return plugin::CallMethodAndReturn<bool, 0x44C050, CReplay*>(this, button);
  26  }

plugin_II\game_II\cSampleManager.cpp:
  12  void cSampleManager::PlayVocal(int stream, int vocal, bool append) {
  13:     plugin::CallMethod<0x4B70C0, cSampleManager*, int, int, bool>(this, stream, vocal, append);
  14  }

  16  void cSampleManager::CloseStream(int stream) {
  17:     plugin::CallMethod<0x4B6860, cSampleManager*, int>(this, stream);
  18  }

  20  void cSampleManager::SetStreamVolume(int stream, unsigned char volume) {
  21:     plugin::CallMethod<0x4B6890, cSampleManager*, int, unsigned char>(this, stream, volume);
  22  }

  24  void cSampleManager::PlaySample(int sample) {
  25:     plugin::CallMethod<0x4B69B0, cSampleManager*, int>(this, sample);
  26  }

  28  void cSampleManager::SetSampleVolume(unsigned char vol) {
  29:     plugin::CallMethod<0x4B6990, cSampleManager*, unsigned char>(this, vol);
  30  }

  32  void cSampleManager::PlayFrontendTrack(unsigned int id) {
  33:     plugin::CallMethod<0x4B6700, cSampleManager*, unsigned char>(this, id);
  34  }

  36  void cSampleManager::StopFrontendTrack() {
  37:     plugin::CallMethod<0x4B67B0, cSampleManager*>(this);
  38  }

  40  bool cSampleManager::IsFrontendTrackPlaying() {
  41:     return plugin::CallMethodAndReturn<bool, 0x4B66A0, cSampleManager*>(this);
  42  }

  44  bool cSampleManager::IsSampleNotPlaying() {
  45:     return plugin::CallMethodAndReturn<bool, 0x4B6A40, cSampleManager*>(this);
  46  }

plugin_II\game_II\CSprite.cpp:
  15  CObject* CSprite::GetObject() {
  16: 	return plugin::CallMethodAndReturn<CObject*, 0x40FEB0, CSprite*>(this);
  17  }

  19  void CSprite::SetPosition(CEncodedVector pos) {
  20: 	plugin::CallMethod<0x420600, CSprite*>(this, pos);
  21  }

  23  void CSprite::SetRotation(short rot) {
  24:     plugin::CallMethod<0x420690, CSprite*>(this, rot);
  25  }

  27  void CSprite::SetRemap(short remap) {
  28:     plugin::CallMethod<0x4B9B00, CSprite*>(this, remap);
  29  }

  31  void CSprite::Render() {
  32:     plugin::CallMethod<0x4BE060, CSprite*>(this);
  33  }

  35  void CSprite::DrawSprite(int id1, int id2, int x, int y, int angle, int scale, int const& mode, int enableAlpha, int alpha, int unk, int lightFlag) {
  36:     plugin::CallStd<0x4CBA50, int, int, int, int, int, int, int const&, int, int, int, int>(id1, id2, x, y, angle, scale, mode, enableAlpha, alpha, unk, lightFlag);
  37  }

plugin_II\game_II\CStyle.cpp:
  18  CStyle::CStyle() {
  19:     plugin::CallMethod<0x4C08D0, CStyle*>(this);
  20  }

  22  void CStyle::Load(const char* path) {
  23:     plugin::CallMethod<0x4C0820, CStyle*, const char*>(this, path);
  24  }

  26  void CStyle::Unload() {
  27:     plugin::CallMethod<0x4C0130, CStyle*>(this);
  28  }

  30  short CStyle::GetBaseIndex(int base, short texture) {
  31:     return plugin::CallMethodAndReturn<short, 0x4BF2A0, CStyle*, int, short>(this, base, texture);
  32  }

  34  int* CStyle::GetTileArray(unsigned short id) {
  35:     return plugin::CallMethodAndReturn<int*, 0x4C2EB0, CStyle*, unsigned short>(this, id);
  36  }

  38  unsigned short CStyle::GetPhysPalette(unsigned short id) {
  39:     return plugin::CallMethodAndReturn<short, 0x4BF530, CStyle*, unsigned short>(this, id);
  40  }

  42  void CStyle::SetFontStyles(int fonts) {
  43:     plugin::CallStd<0x4BFCC0, int>(fonts);
  44  }

plugin_II\game_II\CText.cpp:
  20  CText::CText() {
  21:     plugin::CallMethod<0x4C2620, CText*>(this);
  22  }

  30  wchar_t* CText::Get(const char* str) {
  31:     return plugin::CallMethodAndReturn<wchar_t*, 0x4C23A0, CText*>(this, str);
  32  }

  34  void CText::Load() {
  35:     plugin::CallMethod<0x4C2540, CText*>(this);
  36  }

  38  void CText::Unload() {
  39:     plugin::CallMethod<0x4C26C0, CText*>(this);
  40  }

  42  void CText::LoadChunk(const char* type, int size) {
  43:     plugin::CallMethod<0x4C2330, CText*, const char*, int>(this, type, size);
  44  }

  46  void CText::Update(wchar_t* chars) {
  47:     plugin::CallMethod<0x4C20B0, CText*, wchar_t*>(this, chars);
  48  }

plugin_II\game_II\CTextureManager.cpp:
  15  CTextureManager::CTextureManager() {
  16:     plugin::CallMethod<0x4C3190, CTextureManager*>(this);
  17  }

  19  void CTextureManager::Load() {
  20:     plugin::CallMethod<0x4C30A0, CTextureManager*>(this);
  21  }

  23  void CTextureManager::Unload() {
  24:     plugin::CallMethod<0x4C2D60, CTextureManager*>(this);
  25  }

  27  tTexture* CTextureManager::GetTexture(int id1, int id2, int const& mode, int enableAlpha) {
  28:     return plugin::CallMethodAndReturn<tTexture*, 0x4C2AC0, CTextureManager*, int, int, int, int>(this, id1, id2, mode, enableAlpha);
  29  }

plugin_II\game_II\CTheScripts.cpp:
  16  CTheScripts::CTheScripts() {
  17:     plugin::CallMethod<0x481960, CTheScripts*>(this);
  18  }

  20  void CTheScripts::Save(const char* saveName) {
  21:     plugin::CallMethod<0x47EF40, CTheScripts*, const char*>(this, saveName);
  22  }

plugin_II\game_II\CWorld.cpp:
  15  int CWorld::FindGroundZForCoord(int* z, int x, int y) {
  16:     return plugin::CallMethodAndReturn<int, 0x46A420, CWorld*, int*, int, int>(this, z, x, y);
  17  }

plugin_II\game_II\tVideo.cpp:
  39  void ResetVideoDevice() {
  40:     plugin::Call<0x4CC5C0>();
  41  }

plugin_III\game_III\C_PcSave.cpp:
  16  bool C_PcSave::DeleteSlot(int slot) {
  17:     return plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::DeleteSlot), this, slot);
  18  }

  23  bool C_PcSave::PcClassSaveRoutine(int file, unsigned char *data, unsigned int size) {
  24:     return plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int, unsigned char *, unsigned int>(gaddrof(C_PcSave::PcClassSaveRoutine), this, file, data, size);
  25  }

  30  void C_PcSave::PopulateSlotInfo() {
  31:     plugin::CallMethodDynGlobal<C_PcSave *>(gaddrof(C_PcSave::PopulateSlotInfo), this);
  32  }

  37  bool C_PcSave::SaveSlot(int slot) {
  38:     return plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::SaveSlot), this, slot);
  39  }

  44  void C_PcSave::SetSaveDirectory(char const *path) {
  45:     plugin::CallDynGlobal<char const *>(gaddrof(C_PcSave::SetSaveDirectory), path);
  46  }

plugin_III\game_III\C2dEffect.cpp:
  14  void C2dEffect::Shutdown() {
  15:     plugin::CallMethodDynGlobal<C2dEffect *>(gaddrof(C2dEffect::Shutdown), this);
  16  }

plugin_III\game_III\C3dMarker.cpp:
  20  void C3dMarker::AddMarker(unsigned int nId, unsigned short nType, float fSize, unsigned char bRed, unsigned char bGreen, unsigned char bBlue, unsigned char bAlpha, unsigned short nPulsePeriod, float fPulseFraction, short nRotateRate) {
  21:     plugin::CallMethodDynGlobal<C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarker::AddMarker), this, nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
  22  }

  27  void C3dMarker::DeleteMarkerObject() {
  28:     plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::DeleteMarkerObject), this);
  29  }

  34  void C3dMarker::Render() {
  35:     plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::Render), this);
  36  }

  41  RpAtomic *MarkerAtomicCB(RpAtomic *atomic, void *data) {
  42:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(MarkerAtomicCB), atomic, data);
  43  }

plugin_III\game_III\C3dMarkers.cpp:
  25  void C3dMarkers::PlaceMarker(unsigned int nId, unsigned short nType, CVector &point, float fSize, unsigned char bRed, unsigned char bGreen, unsigned char bBlue, unsigned char bAlpha, unsigned short nPulsePeriod, float fPulseFraction, short nRotateRate) {
  26:     plugin::CallDynGlobal<unsigned int, unsigned short, CVector &, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarkers::PlaceMarker), nId, nType, point, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
  27  }

  32  void C3dMarkers::PlaceMarkerSet(unsigned int nId, unsigned short nType, CVector &point, float fSize, unsigned char bRed, unsigned char bGreen, unsigned char bBlue, unsigned char bAlpha, unsigned short nPulsePeriod, float fPulseFraction, short nRotateRate) {
  33:     plugin::CallDynGlobal<unsigned int, unsigned short, CVector &, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarkers::PlaceMarkerSet), nId, nType, point, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
  34  }

plugin_III\game_III\CAccidentManager.cpp:
  19  unsigned short CAccidentManager::CountActiveAccidents() {
  20:     return plugin::CallMethodAndReturnDynGlobal<unsigned short, CAccidentManager *>(gaddrof(CAccidentManager::CountActiveAccidents), this);
  21  }

  26  CAccident *CAccidentManager::FindNearestAccident(CVector pos, float *distance) {
  27:     return plugin::CallMethodAndReturnDynGlobal<CAccident *, CAccidentManager *, CVector, float *>(gaddrof(CAccidentManager::FindNearestAccident), this, pos, distance);
  28  }

  33  CAccident *CAccidentManager::GetNextFreeAccident() {
  34:     return plugin::CallMethodAndReturnDynGlobal<CAccident *, CAccidentManager *>(gaddrof(CAccidentManager::GetNextFreeAccident), this);
  35  }

  40  void CAccidentManager::ReportAccident(CPed *ped) {
  41:     plugin::CallMethodDynGlobal<CAccidentManager *, CPed *>(gaddrof(CAccidentManager::ReportAccident), this, ped);
  42  }

  47  bool CAccidentManager::UnattendedAccidents() {
  48:     return plugin::CallMethodAndReturnDynGlobal<bool, CAccidentManager *>(gaddrof(CAccidentManager::UnattendedAccidents), this);
  49  }

  54  void CAccidentManager::Update() {
  55:     plugin::CallMethodDynGlobal<CAccidentManager *>(gaddrof(CAccidentManager::Update), this);
  56  }

  61  bool CAccidentManager::WorkToDoForMedics() {
  62:     return plugin::CallMethodAndReturnDynGlobal<bool, CAccidentManager *>(gaddrof(CAccidentManager::WorkToDoForMedics), this);
  63  }

plugin_III\game_III\CAnimBlendAssocGroup.cpp:
  20  CAnimBlendAssociation *CAnimBlendAssocGroup::CopyAnimation(char const *name) {
  21:     return plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::CopyAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(char const *)), this, name);
  22  }

  27  CAnimBlendAssociation *CAnimBlendAssocGroup::CopyAnimation(unsigned int id) {
  28:     return plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, unsigned int>(gaddrof_o(CAnimBlendAssocGroup::CopyAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(unsigned int)), this, id);
  29  }

  34  void CAnimBlendAssocGroup::CreateAssociations(char const *name) {
  35:     plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::CreateAssociations, void (CAnimBlendAssocGroup::*)(char const *)), this, name);
  36  }

  41  void CAnimBlendAssocGroup::CreateAssociations(char const *blockName, RpClump *clump, char **animNames, int numAssocs) {
  42:     plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *, char const *, RpClump *, char **, int>(gaddrof_o(CAnimBlendAssocGroup::CreateAssociations, void (CAnimBlendAssocGroup::*)(char const *, RpClump *, char **, int)), this, blockName, clump, animNames, numAssocs);
  43  }

  48  void CAnimBlendAssocGroup::DestroyAssociations() {
  49:     plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(gaddrof(CAnimBlendAssocGroup::DestroyAssociations), this);
  50  }

  55  CAnimBlendAssociation *CAnimBlendAssocGroup::GetAnimation(char const *name) {
  56:     return plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::GetAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(char const *)), this, name);
  57  }

  62  CAnimBlendAssociation *CAnimBlendAssocGroup::GetAnimation(unsigned int id) {
  63:     return plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, unsigned int>(gaddrof_o(CAnimBlendAssocGroup::GetAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(unsigned int)), this, id);
  64  }

  69  bool strcmpIgnoringDigits(char const *s1, char const *s2) {
  70:     return plugin::CallAndReturnDynGlobal<bool, char const *, char const *>(gaddrof(strcmpIgnoringDigits), s1, s2);
  71  }

  76  CBaseModelInfo *GetModelFromName(char const *name) {
  77:     return plugin::CallAndReturnDynGlobal<CBaseModelInfo *, char const *>(gaddrof(GetModelFromName), name);
  78  }

plugin_III\game_III\CAnimBlendAssociation.cpp:
   26  void CAnimBlendAssociation::AllocateAnimBlendNodeArray(int n) {
   27:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::AllocateAnimBlendNodeArray), this, n);
   28  }

   33  void CAnimBlendAssociation::FreeAnimBlendNodeArray() {
   34:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::FreeAnimBlendNodeArray), this);
   35  }

   40  CAnimBlendNode *CAnimBlendAssociation::GetNode(int index) {
   41:     return plugin::CallMethodAndReturnDynGlobal<CAnimBlendNode *, CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::GetNode), this, index);
   42  }

   47  void CAnimBlendAssociation::Init(RpClump *clump, CAnimBlendHierarchy *hier) {
   48:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(RpClump *, CAnimBlendHierarchy *)), this, clump, hier);
   49  }

   54  void CAnimBlendAssociation::Init(CAnimBlendAssociation &assoc) {
   55:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendAssociation &)), this, assoc);
   56  }

   61  void CAnimBlendAssociation::SetBlend(float amount, float delta) {
   62:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlend), this, amount, delta);
   63  }

   68  void CAnimBlendAssociation::SetCurrentTime(float time) {
   69:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::SetCurrentTime), this, time);
   70  }

   75  void CAnimBlendAssociation::SetDeleteCallback(void(*func)(CAnimBlendAssociation *, void *), void *data) {
   76:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetDeleteCallback), this, func, data);
   77  }

   82  void CAnimBlendAssociation::SetFinishCallback(void(*func)(CAnimBlendAssociation *, void *), void *data) {
   83:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetFinishCallback), this, func, data);
   84  }

   89  void CAnimBlendAssociation::Start(float time) {
   90:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::Start), this, time);
   91  }

   96  void CAnimBlendAssociation::SyncAnimation(CAnimBlendAssociation *other) {
   97:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::SyncAnimation), this, other);
   98  }

  103  bool CAnimBlendAssociation::UpdateBlend(float timeDelta) {
  104:     return plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::UpdateBlend), this, timeDelta);
  105  }

  110  void CAnimBlendAssociation::UpdateTime(float timeDelta, float relSpeed) {
  111:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTime), this, timeDelta, relSpeed);
  112  }

plugin_III\game_III\CAnimBlendClumpData.cpp:
  20  void CAnimBlendClumpData::ForAllFrames(void(*func)(AnimBlendFrameData *, void *), void *data) {
  21:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *>(gaddrof(CAnimBlendClumpData::ForAllFrames), this, func, data);
  22  }

  27  void CAnimBlendClumpData::SetNumberOfBones(int n) {
  28:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *, int>(gaddrof(CAnimBlendClumpData::SetNumberOfBones), this, n);
  29  }

plugin_III\game_III\CAnimBlendHierarchy.cpp:
  20  void CAnimBlendHierarchy::CalcTotalTime() {
  21:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::CalcTotalTime), this);
  22  }

  27  void CAnimBlendHierarchy::RemoveAnimSequences() {
  28:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveAnimSequences), this);
  29  }

  34  void CAnimBlendHierarchy::RemoveQuaternionFlips() {
  35:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveQuaternionFlips), this);
  36  }

  41  void CAnimBlendHierarchy::RemoveUncompressedData() {
  42:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveUncompressedData), this);
  43  }

  48  void CAnimBlendHierarchy::SetName(char const *name) {
  49:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *, char const *>(gaddrof(CAnimBlendHierarchy::SetName), this, name);
  50  }

  55  void CAnimBlendHierarchy::Shutdown() {
  56:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::Shutdown), this);
  57  }

  62  void CAnimBlendHierarchy::Uncompress() {
  63:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::Uncompress), this);
  64  }

plugin_III\game_III\CAnimBlendNode.cpp:
  14  void CAnimBlendNode::CalcDeltas() {
  15:     plugin::CallMethodDynGlobal<CAnimBlendNode *>(gaddrof(CAnimBlendNode::CalcDeltas), this);
  16  }

  21  bool CAnimBlendNode::FindKeyFrame(float t) {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *, float>(gaddrof(CAnimBlendNode::FindKeyFrame), this, t);
  23  }

  28  void CAnimBlendNode::GetCurrentTranslation(CVector &trans, float weight) {
  29:     plugin::CallMethodDynGlobal<CAnimBlendNode *, CVector &, float>(gaddrof(CAnimBlendNode::GetCurrentTranslation), this, trans, weight);
  30  }

  35  void CAnimBlendNode::GetEndTranslation(CVector &trans, float weight) {
  36:     plugin::CallMethodDynGlobal<CAnimBlendNode *, CVector &, float>(gaddrof(CAnimBlendNode::GetEndTranslation), this, trans, weight);
  37  }

  42  void CAnimBlendNode::Init() {
  43:     plugin::CallMethodDynGlobal<CAnimBlendNode *>(gaddrof(CAnimBlendNode::Init), this);
  44  }

  49  bool CAnimBlendNode::NextKeyFrame() {
  50:     return plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *>(gaddrof(CAnimBlendNode::NextKeyFrame), this);
  51  }

  56  bool CAnimBlendNode::Update(CVector &trans, CQuaternion &rot, float weight) {
  57:     return plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *, CVector &, CQuaternion &, float>(gaddrof(CAnimBlendNode::Update), this, trans, rot, weight);
  58  }

plugin_III\game_III\CAnimBlendSequence.cpp:
  23  void CAnimBlendSequence::RemoveQuaternionFlips() {
  24:     plugin::CallMethodDynGlobal<CAnimBlendSequence *>(gaddrof(CAnimBlendSequence::RemoveQuaternionFlips), this);
  25  }

  30  void CAnimBlendSequence::SetName(char const *name) {
  31:     plugin::CallMethodDynGlobal<CAnimBlendSequence *, char const *>(gaddrof(CAnimBlendSequence::SetName), this, name);
  32  }

  37  void CAnimBlendSequence::SetNumFrames(int numFrames, bool translation) {
  38:     plugin::CallMethodDynGlobal<CAnimBlendSequence *, int, bool>(gaddrof(CAnimBlendSequence::SetNumFrames), this, numFrames, translation);
  39  }

plugin_III\game_III\CAnimManager.cpp:
   22  CAnimBlendAssociation *CAnimManager::AddAnimation(RpClump *clump, int groupId, int animId) {
   23:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int, int>(gaddrof(CAnimManager::AddAnimation), clump, groupId, animId);
   24  }

   29  CAnimBlendAssociation *CAnimManager::AddAnimationAndSync(RpClump *clump, CAnimBlendAssociation *association, int groupId, int animId) {
   30:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendAssociation *, int, int>(gaddrof(CAnimManager::AddAnimationAndSync), clump, association, groupId, animId);
   31  }

   36  CAnimBlendAssociation *CAnimManager::BlendAnimation(RpClump *clump, int groupId, int animId, float delta) {
   37:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int, int, float>(gaddrof(CAnimManager::BlendAnimation), clump, groupId, animId, delta);
   38  }

   43  CAnimBlendAssociation *CAnimManager::CreateAnimAssociation(int groupId, int animId) {
   44:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, int>(gaddrof(CAnimManager::CreateAnimAssociation), groupId, animId);
   45  }

   50  CAnimBlendAssociation *CAnimManager::GetAnimAssociation(int groupId, int animId) {
   51:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, int>(gaddrof_o(CAnimManager::GetAnimAssociation, CAnimBlendAssociation *(*)(int, int)), groupId, animId);
   52  }

   57  CAnimBlendAssociation *CAnimManager::GetAnimAssociation(int groupId, char const *name) {
   58:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, char const *>(gaddrof_o(CAnimManager::GetAnimAssociation, CAnimBlendAssociation *(*)(int, char const *)), groupId, name);
   59  }

   64  char const *CAnimManager::GetAnimGroupName(int groupId) {
   65:     return plugin::CallAndReturnDynGlobal<char const *, int>(gaddrof(CAnimManager::GetAnimGroupName), groupId);
   66  }

   71  CAnimBlendHierarchy *CAnimManager::GetAnimation(char const *name, CAnimBlock *animBlock) {
   72:     return plugin::CallAndReturnDynGlobal<CAnimBlendHierarchy *, char const *, CAnimBlock *>(gaddrof(CAnimManager::GetAnimation), name, animBlock);
   73  }

   78  CAnimBlock *CAnimManager::GetAnimationBlock(char const *name) {
   79:     return plugin::CallAndReturnDynGlobal<CAnimBlock *, char const *>(gaddrof(CAnimManager::GetAnimationBlock), name);
   80  }

   92  void CAnimManager::LoadAnimFile(char const *name) {
   93:     plugin::CallDynGlobal<char const *>(gaddrof_o(CAnimManager::LoadAnimFile, void (*)(char const *)), name);
   94  }

   99  void CAnimManager::LoadAnimFile(int fileHandle, bool compress) {
  100:     plugin::CallDynGlobal<int, bool>(gaddrof_o(CAnimManager::LoadAnimFile, void (*)(int, bool)), fileHandle, compress);
  101  }

  127  void CAnimManager::UncompressAnimation(CAnimBlendHierarchy *hier) {
  128:     plugin::CallDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimManager::UncompressAnimation), hier);
  129  }

plugin_III\game_III\CAntenna.cpp:
  17  void CAntenna::Update(CVector dir, CVector pos) {
  18:     plugin::CallMethodDynGlobal<CAntenna *, CVector, CVector>(gaddrof(CAntenna::Update), this, dir, pos);
  19  }

plugin_III\game_III\CAntennas.cpp:
  23  void CAntennas::RegisterOne(unsigned int id, CVector dir, CVector pos, float length) {
  24:     plugin::CallDynGlobal<unsigned int, CVector, CVector, float>(gaddrof(CAntennas::RegisterOne), id, dir, pos, length);
  25  }

plugin_III\game_III\cAudioCollisionManager.cpp:
  14  void cAudioCollisionManager::AddCollisionToRequestedQueue() {
  15:     plugin::CallMethodDynGlobal<cAudioCollisionManager *>(gaddrof(cAudioCollisionManager::AddCollisionToRequestedQueue), this);
  16  }

plugin_III\game_III\CAudioHydrant.cpp:
  17  void CAudioHydrant::Add(CParticleObject *object) {
  18:     plugin::CallDynGlobal<CParticleObject *>(gaddrof(CAudioHydrant::Add), object);
  19  }

  24  void CAudioHydrant::Remove(CParticleObject *object) {
  25:     plugin::CallDynGlobal<CParticleObject *>(gaddrof(CAudioHydrant::Remove), object);
  26  }

plugin_III\game_III\cAudioManager.cpp:
  12  cAudioManager::cAudioManager() {
  13:     plugin::CallMethod<0x579AB0, cAudioManager *>(this);
  14  }

  17  cAudioManager::~cAudioManager() {
  18:     plugin::CallMethod<0x57A0A0, cAudioManager *>(this);
  19  }

  22  bool cAudioManager::UsesSiren(unsigned int index) {
  23:     return plugin::CallMethodAndReturn<bool, 0x56C3C0, cAudioManager *, unsigned int>(this, index);
  24  }

  27  bool cAudioManager::UsesSirenSwitching(unsigned int index) {
  28:     return plugin::CallMethodAndReturn<bool, 0x56C3F0, cAudioManager *, unsigned int>(this, index);
  29  }

plugin_III\game_III\cAudioScriptObject.cpp:
  29  void cAudioScriptObject::Reset() {
  30:     plugin::CallMethodDynGlobal<cAudioScriptObject *>(gaddrof(cAudioScriptObject::Reset), this);
  31  }

  36  void cAudioScriptObject::LoadAllAudioScriptObjects(unsigned char *buf, unsigned int size) {
  37:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(cAudioScriptObject::LoadAllAudioScriptObjects), buf, size);
  38  }

  43  void cAudioScriptObject::SaveAllAudioScriptObjects(unsigned char *buf, unsigned int *size) {
  44:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(cAudioScriptObject::SaveAllAudioScriptObjects), buf, size);
  45  }

  50  void PlayOneShotScriptObject(unsigned char id, CVector const &pos) {
  51:     plugin::CallDynGlobal<unsigned char, CVector const &>(gaddrof(PlayOneShotScriptObject), id, pos);
  52  }

plugin_III\game_III\CAutomobile.cpp:
   29  void CAutomobile::SetModelIndex(unsigned int modelIndex) {
   30:     plugin::CallVirtualMethod<3, CAutomobile *, unsigned int>(this, modelIndex);
   31  }

   36  void CAutomobile::ProcessControl() {
   37:     plugin::CallVirtualMethod<8, CAutomobile *>(this);
   38  }

   43  void CAutomobile::Teleport(CVector pos) {
   44:     plugin::CallVirtualMethod<11, CAutomobile *, CVector>(this, pos);
   45  }

   50  void CAutomobile::PreRender() {
   51:     plugin::CallVirtualMethod<12, CAutomobile *>(this);
   52  }

   57  void CAutomobile::Render() {
   58:     plugin::CallVirtualMethod<13, CAutomobile *>(this);
   59  }

   64  void CAutomobile::ProcessEntityCollision(CEntity *entity, CColPoint *colPoint) {
   65:     plugin::CallVirtualMethod<17, CAutomobile *, CEntity *, CColPoint *>(this, entity, colPoint);
   66  }

   71  void CAutomobile::ProcessControlInputs(unsigned char pad) {
   72:     plugin::CallVirtualMethod<18, CAutomobile *, unsigned char>(this, pad);
   73  }

   78  void CAutomobile::GetComponentWorldPosition(int component, CVector &pos) {
   79:     plugin::CallVirtualMethod<19, CAutomobile *, int, CVector &>(this, component, pos);
   80  }

   85  bool CAutomobile::IsComponentPresent(int component) {
   86:     return plugin::CallVirtualMethodAndReturn<bool, 20, CAutomobile *, int>(this, component);
   87  }

   92  void CAutomobile::SetComponentRotation(int component, CVector rotation) {
   93:     plugin::CallVirtualMethod<21, CAutomobile *, int, CVector>(this, component, rotation);
   94  }

   99  void CAutomobile::OpenDoor(int component, eDoors door, float angle) {
  100:     plugin::CallVirtualMethod<22, CAutomobile *, int, eDoors, float>(this, component, door, angle);
  101  }

  106  void CAutomobile::ProcessOpenDoor(unsigned int component, unsigned int anim, float angle) {
  107:     plugin::CallVirtualMethod<23, CAutomobile *, unsigned int, unsigned int, float>(this, component, anim, angle);
  108  }

  113  bool CAutomobile::IsDoorReady(eDoors door) {
  114:     return plugin::CallVirtualMethodAndReturn<bool, 24, CAutomobile *, eDoors>(this, door);
  115  }

  120  bool CAutomobile::IsDoorFullyOpen(eDoors door) {
  121:     return plugin::CallVirtualMethodAndReturn<bool, 25, CAutomobile *, eDoors>(this, door);
  122  }

  127  bool CAutomobile::IsDoorClosed(eDoors door) {
  128:     return plugin::CallVirtualMethodAndReturn<bool, 26, CAutomobile *, eDoors>(this, door);
  129  }

  134  bool CAutomobile::IsDoorMissing(eDoors door) {
  135:     return plugin::CallVirtualMethodAndReturn<bool, 27, CAutomobile *, eDoors>(this, door);
  136  }

  141  void CAutomobile::RemoveRefsToVehicle(CEntity *entity) {
  142:     plugin::CallVirtualMethod<28, CAutomobile *, CEntity *>(this, entity);
  143  }

  148  void CAutomobile::BlowUpCar(CEntity *culprit) {
  149:     plugin::CallVirtualMethod<29, CAutomobile *, CEntity *>(this, culprit);
  150  }

  155  bool CAutomobile::SetUpWheelColModel(CColModel *wheelCol) {
  156:     return plugin::CallVirtualMethodAndReturn<bool, 30, CAutomobile *, CColModel *>(this, wheelCol);
  157  }

  162  void CAutomobile::BurstTyre(unsigned char wheel) {
  163:     plugin::CallVirtualMethod<31, CAutomobile *, unsigned char>(this, wheel);
  164  }

  169  bool CAutomobile::IsRoomForPedToLeaveCar(unsigned int component, CVector *doorOffset) {
  170:     return plugin::CallVirtualMethodAndReturn<bool, 32, CAutomobile *, unsigned int, CVector *>(this, component, doorOffset);
  171  }

  176  float CAutomobile::GetHeightAboveRoad() {
  177:     return plugin::CallVirtualMethodAndReturn<float, 33, CAutomobile *>(this);
  178  }

  183  void CAutomobile::PlayCarHorn() {
  184:     plugin::CallVirtualMethod<34, CAutomobile *>(this);
  185  }

  190  void CAutomobile::AddDamagedVehicleParticles() {
  191:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::AddDamagedVehicleParticles), this);
  192  }

  197  bool CAutomobile::AddWheelDirtAndWater(CColPoint &point, unsigned int belowEffectSpeed) {
  198:     return plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *, CColPoint &, unsigned int>(gaddrof(CAutomobile::AddWheelDirtAndWater), this, point, belowEffectSpeed);
  199  }

  204  void CAutomobile::BlowUpCarsInPath() {
  205:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::BlowUpCarsInPath), this);
  206  }

  211  void CAutomobile::DoDriveByShootings() {
  212:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::DoDriveByShootings), this);
  213  }

  218  void CAutomobile::FireTruckControl() {
  219:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::FireTruckControl), this);
  220  }

  225  void CAutomobile::Fix() {
  226:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::Fix), this);
  227  }

  232  bool CAutomobile::GetAllWheelsOffGround() {
  233:     return plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::GetAllWheelsOffGround), this);
  234  }

  239  bool CAutomobile::HasCarStoppedBecauseOfLight() {
  240:     return plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::HasCarStoppedBecauseOfLight), this);
  241  }

  246  void CAutomobile::HideAllComps() {
  247:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::HideAllComps), this);
  248  }

  253  void CAutomobile::HydraulicControl() {
  254:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::HydraulicControl), this);
  255  }

  260  void CAutomobile::PlaceOnRoadProperly() {
  261:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::PlaceOnRoadProperly), this);
  262  }

  267  void CAutomobile::PlayHornIfNecessary() {
  268:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::PlayHornIfNecessary), this);
  269  }

  274  void CAutomobile::ProcessAutoBusDoors() {
  275:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ProcessAutoBusDoors), this);
  276  }

  281  void CAutomobile::ProcessBuoyancy() {
  282:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ProcessBuoyancy), this);
  283  }

  288  void CAutomobile::ProcessSwingingDoor(int component, eDoors door) {
  289:     plugin::CallMethodDynGlobal<CAutomobile *, int, eDoors>(gaddrof(CAutomobile::ProcessSwingingDoor), this, component, door);
  290  }

  295  bool CAutomobile::RcbanditCheck1CarWheels(CPtrList &list) {
  296:     return plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *, CPtrList &>(gaddrof(CAutomobile::RcbanditCheck1CarWheels), this, list);
  297  }

  302  bool CAutomobile::RcbanditCheckHitWheels() {
  303:     return plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::RcbanditCheckHitWheels), this);
  304  }

  309  void CAutomobile::ReduceHornCounter() {
  310:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ReduceHornCounter), this);
  311  }

  316  CObject *CAutomobile::RemoveBonnetInPedCollision() {
  317:     return plugin::CallMethodAndReturnDynGlobal<CObject *, CAutomobile *>(gaddrof(CAutomobile::RemoveBonnetInPedCollision), this);
  318  }

  323  void CAutomobile::ResetSuspension() {
  324:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ResetSuspension), this);
  325  }

  330  void CAutomobile::ScanForCrimes() {
  331:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ScanForCrimes), this);
  332  }

  337  void CAutomobile::SetBumperDamage(int component, ePanels panel, bool noFlyingComponents) {
  338:     plugin::CallMethodDynGlobal<CAutomobile *, int, ePanels, bool>(gaddrof(CAutomobile::SetBumperDamage), this, component, panel, noFlyingComponents);
  339  }

  344  void CAutomobile::SetBusDoorTimer(unsigned int timer, unsigned char type) {
  345:     plugin::CallMethodDynGlobal<CAutomobile *, unsigned int, unsigned char>(gaddrof(CAutomobile::SetBusDoorTimer), this, timer, type);
  346  }

  351  void CAutomobile::SetComponentVisibility(RwFrame *frame, unsigned int flag) {
  352:     plugin::CallMethodDynGlobal<CAutomobile *, RwFrame *, unsigned int>(gaddrof(CAutomobile::SetComponentVisibility), this, frame, flag);
  353  }

  358  void CAutomobile::SetDoorDamage(int component, eDoors door, bool noFlyingComponents) {
  359:     plugin::CallMethodDynGlobal<CAutomobile *, int, eDoors, bool>(gaddrof(CAutomobile::SetDoorDamage), this, component, door, noFlyingComponents);
  360  }

  365  void CAutomobile::SetPanelDamage(int component, ePanels panel, bool noFlyingComponents) {
  366:     plugin::CallMethodDynGlobal<CAutomobile *, int, ePanels, bool>(gaddrof(CAutomobile::SetPanelDamage), this, component, panel, noFlyingComponents);
  367  }

  372  void CAutomobile::SetTaxiLight(bool enable) {
  373:     plugin::CallMethodDynGlobal<CAutomobile *, bool>(gaddrof(CAutomobile::SetTaxiLight), this, enable);
  374  }

  379  void CAutomobile::SetupDamageAfterLoad() {
  380:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupDamageAfterLoad), this);
  381  }

  386  void CAutomobile::SetupModelNodes() {
  387:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupModelNodes), this);
  388  }

  393  void CAutomobile::SetupSuspensionLines() {
  394:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupSuspensionLines), this);
  395  }

  400  void CAutomobile::ShowAllComps() {
  401:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ShowAllComps), this);
  402  }

  407  CObject *CAutomobile::SpawnFlyingComponent(int component, unsigned int type) {
  408:     return plugin::CallMethodAndReturnDynGlobal<CObject *, CAutomobile *, int, unsigned int>(gaddrof(CAutomobile::SpawnFlyingComponent), this, component, type);
  409  }

  414  void CAutomobile::TankControl() {
  415:     plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::TankControl), this);
  416  }

  421  void CAutomobile::VehicleDamage(float impulse, unsigned short damagedPiece) {
  422:     plugin::CallMethodDynGlobal<CAutomobile *, float, unsigned short>(gaddrof(CAutomobile::VehicleDamage), this, impulse, damagedPiece);
  423  }

  428  void CAutomobile::dmgDrawCarCollidingParticles(CVector const &pos, float amount) {
  429:     plugin::CallMethodDynGlobal<CAutomobile *, CVector const &, float>(gaddrof(CAutomobile::dmgDrawCarCollidingParticles), this, pos, amount);
  430  }

  435  void CAutomobile::SetAllTaxiLights(bool enable) {
  436:     plugin::CallDynGlobal<bool>(gaddrof(CAutomobile::SetAllTaxiLights), enable);
  437  }

  442  RwObject *SetVehicleAtomicVisibilityCB(RwObject *object, void *data) {
  443:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(SetVehicleAtomicVisibilityCB), object, data);
  444  }

  449  RwObject *GetCurrentAtomicObjectCB(RwObject *object, void *data) {
  450:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetCurrentAtomicObjectCB), object, data);
  451  }

plugin_III\game_III\CAutoPilot.cpp:
  10  void CAutoPilot::ModifySpeed(float speed) {
  11:     plugin::CallMethod<0x4137B0, CAutoPilot *, float>(this, speed);
  12  }

  15  void CAutoPilot::RemoveOnePathNode() {
  16:     plugin::CallMethod<0x413A00, CAutoPilot *>(this);
  17  }

plugin_III\game_III\CBaseModelInfo.cpp:
  23  void CBaseModelInfo::Shutdown() {
  24:     plugin::CallVirtualMethod<1, CBaseModelInfo *>(this);
  25  }

  30  void CBaseModelInfo::Add2dEffect(C2dEffect *effect) {
  31:     plugin::CallMethodDynGlobal<CBaseModelInfo *, C2dEffect *>(gaddrof(CBaseModelInfo::Add2dEffect), this, effect);
  32  }

  37  void CBaseModelInfo::AddRef() {
  38:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::AddRef), this);
  39  }

  44  void CBaseModelInfo::AddTexDictionaryRef() {
  45:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::AddTexDictionaryRef), this);
  46  }

  51  void CBaseModelInfo::ClearTexDictionary() {
  52:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::ClearTexDictionary), this);
  53  }

  58  void CBaseModelInfo::DeleteCollisionModel() {
  59:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::DeleteCollisionModel), this);
  60  }

  65  C2dEffect *CBaseModelInfo::Get2dEffect(int effectNumber) {
  66:     return plugin::CallMethodAndReturnDynGlobal<C2dEffect *, CBaseModelInfo *, int>(gaddrof(CBaseModelInfo::Get2dEffect), this, effectNumber);
  67  }

  72  void CBaseModelInfo::Init2dEffects() {
  73:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::Init2dEffects), this);
  74  }

  79  void CBaseModelInfo::RemoveRef() {
  80:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::RemoveRef), this);
  81  }

  86  void CBaseModelInfo::RemoveTexDictionaryRef() {
  87:     plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::RemoveTexDictionaryRef), this);
  88  }

  93  void CBaseModelInfo::SetTexDictionary(char const *txdName) {
  94:     plugin::CallMethodDynGlobal<CBaseModelInfo *, char const *>(gaddrof(CBaseModelInfo::SetTexDictionary), this, txdName);
  95  }

plugin_III\game_III\CBoat.cpp:
   34  void CBoat::SetModelIndex(unsigned int modelIndex) {
   35:     plugin::CallVirtualMethod<3, CBoat *, unsigned int>(this, modelIndex);
   36  }

   41  void CBoat::ProcessControl() {
   42:     plugin::CallVirtualMethod<8, CBoat *>(this);
   43  }

   48  void CBoat::Teleport(CVector point) {
   49:     plugin::CallVirtualMethod<11, CBoat *, CVector>(this, point);
   50  }

   55  void CBoat::PreRender() {
   56:     plugin::CallVirtualMethod<12, CBoat *>(this);
   57  }

   62  void CBoat::Render() {
   63:     plugin::CallVirtualMethod<13, CBoat *>(this);
   64  }

   69  void CBoat::ProcessControlInputs(unsigned char padNumber) {
   70:     plugin::CallVirtualMethod<18, CBoat *, unsigned char>(this, padNumber);
   71  }

   76  void CBoat::GetComponentWorldPosition(int component, CVector &pos) {
   77:     plugin::CallVirtualMethod<19, CBoat *, int, CVector &>(this, component, pos);
   78  }

   83  bool CBoat::IsComponentPresent(int component) {
   84:     return plugin::CallVirtualMethodAndReturn<bool, 20, CBoat *, int>(this, component);
   85  }

   90  void CBoat::BlowUpCar(CEntity *entity) {
   91:     plugin::CallVirtualMethod<29, CBoat *, CEntity *>(this, entity);
   92  }

   97  void CBoat::AddWakePoint(CVector point) {
   98:     plugin::CallMethodDynGlobal<CBoat *, CVector>(gaddrof(CBoat::AddWakePoint), this, point);
   99  }

  104  void CBoat::ApplyWaterResistance() {
  105:     plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::ApplyWaterResistance), this);
  106  }

  111  void CBoat::PruneWakeTrail() {
  112:     plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::PruneWakeTrail), this);
  113  }

  118  void CBoat::SetupModelNodes() {
  119:     plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::SetupModelNodes), this);
  120  }

  132  bool CBoat::IsSectorAffectedByWake(CVector2D sector, float size, CBoat **apBoats) {
  133:     return plugin::CallAndReturnDynGlobal<bool, CVector2D, float, CBoat **>(gaddrof(CBoat::IsSectorAffectedByWake), sector, size, apBoats);
  134  }

  139  float CBoat::IsVertexAffectedByWake(CVector vecVertex, CBoat *boat) {
  140:     return plugin::CallAndReturnDynGlobal<float, CVector, CBoat *>(gaddrof(CBoat::IsVertexAffectedByWake), vecVertex, boat);
  141  }

  146  RwObject *GetBoatAtomicObjectCB(RwObject *object, void *data) {
  147:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetBoatAtomicObjectCB), object, data);
  148  }

plugin_III\game_III\CBridge.cpp:
  39  bool CBridge::ShouldLightsBeFlashing() {
  40:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CBridge::ShouldLightsBeFlashing));
  41  }

  46  bool CBridge::ThisIsABridgeObjectMovingUp(unsigned int modelIndex) {
  47:     return plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CBridge::ThisIsABridgeObjectMovingUp), modelIndex);
  48  }

plugin_III\game_III\CBrightLights.cpp:
  42  void CBrightLights::RegisterOne(CVector posn, CVector right, CVector up, CVector at, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) {
  43:     plugin::CallDynGlobal<CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(gaddrof(CBrightLights::RegisterOne), posn, right, up, at, red, green, blue, alpha);
  44  }

plugin_III\game_III\CBuilding.cpp:
  29  bool CBuilding::GetIsATreadable() {
  30:     return plugin::CallVirtualMethodAndReturn<bool, 17, CBuilding *>(this);
  31  }

  36  void CBuilding::ReplaceWithNewModel(int modelIndex) {
  37:     plugin::CallMethodDynGlobal<CBuilding *, int>(gaddrof(CBuilding::ReplaceWithNewModel), this, modelIndex);
  38  }

plugin_III\game_III\CBulletInfo.cpp:
  22  void CBulletInfo::AddBullet(CEntity *pSource, eWeaponType type, CVector pos, CVector speed) {
  23:     plugin::CallDynGlobal<CEntity *, eWeaponType, CVector, CVector>(gaddrof(CBulletInfo::AddBullet), pSource, type, pos, speed);
  24  }

  43  bool CBulletInfo::TestForSniperBullet(float x1, float x2, float y1, float y2, float z1, float z2) {
  44:     return plugin::CallAndReturnDynGlobal<bool, float, float, float, float, float, float>(gaddrof(CBulletInfo::TestForSniperBullet), x1, x2, y1, y2, z1, z2);
  45  }

plugin_III\game_III\CBulletTrace.cpp:
  20  void CBulletTrace::Update() {
  21:     plugin::CallMethodDynGlobal<CBulletTrace *>(gaddrof(CBulletTrace::Update), this);
  22  }

plugin_III\game_III\CBulletTraces.cpp:
  16  void CBulletTraces::AddTrace(CVector *origin, CVector *target) {
  17:     plugin::CallDynGlobal<CVector *, CVector *>(gaddrof(CBulletTraces::AddTrace), origin, target);
  18  }

plugin_III\game_III\CCamera.cpp:
   26  void CCamera::CalculateDerivedValues() {
   27:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CalculateDerivedValues), this);
   28  }

   33  void CCamera::CamControl() {
   34:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CamControl), this);
   35  }

   40  void CCamera::CamShake(float strength, float x, float y, float z) {
   41:     plugin::CallMethodDynGlobal<CCamera *, float, float, float, float>(gaddrof(CCamera::CamShake), this, strength, x, y, z);
   42  }

   47  void CCamera::ClearPlayerWeaponMode() {
   48:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ClearPlayerWeaponMode), this);
   49  }

   54  void CCamera::DontProcessObbeCinemaCamera() {
   55:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DontProcessObbeCinemaCamera), this);
   56  }

   61  void CCamera::DrawBordersForWideScreen() {
   62:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DrawBordersForWideScreen), this);
   63  }

   68  void CCamera::Fade(float timeOut, short direction) {
   69:     plugin::CallMethodDynGlobal<CCamera *, float, short>(gaddrof(CCamera::Fade), this, timeOut, direction);
   70  }

   75  void CCamera::Find3rdPersonCamTargetVector(float dist, CVector pos, CVector &source, CVector &target) {
   76:     plugin::CallMethodDynGlobal<CCamera *, float, CVector, CVector &, CVector &>(gaddrof(CCamera::Find3rdPersonCamTargetVector), this, dist, pos, source, target);
   77  }

   82  float CCamera::Find3rdPersonQuickAimPitch() {
   83:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::Find3rdPersonQuickAimPitch), this);
   84  }

   89  void CCamera::FinishCutscene() {
   90:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::FinishCutscene), this);
   91  }

   96  CMatrix *CCamera::GetCameraMatrix() {
   97:     return plugin::CallMethodAndReturnDynGlobal<CMatrix *, CCamera *>(gaddrof(CCamera::GetCameraMatrix), this);
   98  }

  103  unsigned int CCamera::GetCutSceneFinishTime() {
  104:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::GetCutSceneFinishTime), this);
  105  }

  110  bool CCamera::GetFading() {
  111:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetFading), this);
  112  }

  117  int CCamera::GetFadingDirection() {
  118:     return plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetFadingDirection), this);
  119  }

  124  CVector *CCamera::GetGameCamPosition() {
  125:     return plugin::CallMethodAndReturnDynGlobal<CVector *, CCamera *>(gaddrof(CCamera::GetGameCamPosition), this);
  126  }

  131  int CCamera::GetLookDirection() {
  132:     return plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetLookDirection), this);
  133  }

  138  bool CCamera::GetLookingForwardFirstPerson() {
  139:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingForwardFirstPerson), this);
  140  }

  145  bool CCamera::GetLookingLRBFirstPerson() {
  146:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingLRBFirstPerson), this);
  147  }

  152  float CCamera::GetPositionAlongSpline() {
  153:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetPositionAlongSpline), this);
  154  }

  159  int CCamera::GetScreenFadeStatus() {
  160:     return plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetScreenFadeStatus), this);
  161  }

  166  bool CCamera::Get_Just_Switched_Status() {
  167:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Get_Just_Switched_Status), this);
  168  }

  173  void CCamera::Init() {
  174:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Init), this);
  175  }

  180  void CCamera::InitialiseCameraForDebugMode() {
  181:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::InitialiseCameraForDebugMode), this);
  182  }

  187  bool CCamera::IsItTimeForNewcam(int obbeMode, int time) {
  188:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int, int>(gaddrof(CCamera::IsItTimeForNewcam), this, obbeMode, time);
  189  }

  194  bool CCamera::IsSphereVisible(CVector const &center, float radius, CMatrix const *matrix) {
  195:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float, CMatrix const *>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float, CMatrix const *)), this, center, radius, matrix);
  196  }

  201  bool CCamera::IsSphereVisible(CVector const &center, float radius) {
  202:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float)), this, center, radius);
  203  }

  208  void CCamera::LoadPathSplines(int file) {
  209:     plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::LoadPathSplines), this, file);
  210  }

  215  void CCamera::LoadTrainCamNodes(char const *name) {
  216:     plugin::CallMethodDynGlobal<CCamera *, char const *>(gaddrof(CCamera::LoadTrainCamNodes), this, name);
  217  }

  222  void CCamera::Process() {
  223:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process), this);
  224  }

  229  void CCamera::ProcessFade() {
  230:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessFade), this);
  231  }

  236  void CCamera::ProcessMusicFade() {
  237:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessMusicFade), this);
  238  }

  243  void CCamera::ProcessObbeCinemaCameraCar() {
  244:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraCar), this);
  245  }

  250  void CCamera::ProcessObbeCinemaCameraPed() {
  251:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPed), this);
  252  }

  257  void CCamera::ProcessWideScreenOn() {
  258:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessWideScreenOn), this);
  259  }

  264  void CCamera::Process_Train_Camera_Control() {
  265:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process_Train_Camera_Control), this);
  266  }

  271  void CCamera::RenderMotionBlur() {
  272:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RenderMotionBlur), this);
  273  }

  278  void CCamera::Restore() {
  279:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Restore), this);
  280  }

  285  void CCamera::RestoreWithJumpCut() {
  286:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreWithJumpCut), this);
  287  }

  292  void CCamera::SetCamCutSceneOffSet(CVector const &pos) {
  293:     plugin::CallMethodDynGlobal<CCamera *, CVector const &>(gaddrof(CCamera::SetCamCutSceneOffSet), this, pos);
  294  }

  299  void CCamera::SetCamPositionForFixedMode(CVector const &source, CVector const &offset) {
  300:     plugin::CallMethodDynGlobal<CCamera *, CVector const &, CVector const &>(gaddrof(CCamera::SetCamPositionForFixedMode), this, source, offset);
  301  }

  306  void CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString() {
  307:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString), this);
  308  }

  313  void CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString() {
  314:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString), this);
  315  }

  320  void CCamera::SetFadeColour(unsigned char red, unsigned char green, unsigned char blue) {
  321:     plugin::CallMethodDynGlobal<CCamera *, unsigned char, unsigned char, unsigned char>(gaddrof(CCamera::SetFadeColour), this, red, green, blue);
  322  }

  327  void CCamera::SetMotionBlur(int red, int green, int blue, int value, int type) {
  328:     plugin::CallMethodDynGlobal<CCamera *, int, int, int, int, int>(gaddrof(CCamera::SetMotionBlur), this, red, green, blue, value, type);
  329  }

  334  void CCamera::SetMotionBlurAlpha(int alpha) {
  335:     plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::SetMotionBlurAlpha), this, alpha);
  336  }

  341  void CCamera::SetNearClipScript(float clip) {
  342:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipScript), this, clip);
  343  }

  348  void CCamera::SetNewPlayerWeaponMode(short mode, short minZoom, short maxZoom) {
  349:     plugin::CallMethodDynGlobal<CCamera *, short, short, short>(gaddrof(CCamera::SetNewPlayerWeaponMode), this, mode, minZoom, maxZoom);
  350  }

  355  void CCamera::SetParametersForScriptInterpolation(float stopMoving, float catchUp, unsigned int time) {
  356:     plugin::CallMethodDynGlobal<CCamera *, float, float, unsigned int>(gaddrof(CCamera::SetParametersForScriptInterpolation), this, stopMoving, catchUp, time);
  357  }

  362  void CCamera::SetPercentAlongCutScene(float percent) {
  363:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetPercentAlongCutScene), this, percent);
  364  }

  369  void CCamera::SetRwCamera(RwCamera *rwCamera) {
  370:     plugin::CallMethodDynGlobal<CCamera *, RwCamera *>(gaddrof(CCamera::SetRwCamera), this, rwCamera);
  371  }

  376  void CCamera::SetWideScreenOff() {
  377:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOff), this);
  378  }

  383  void CCamera::SetWideScreenOn() {
  384:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOn), this);
  385  }

  390  void CCamera::SetZoomValueCamStringScript(short dist) {
  391:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueCamStringScript), this, dist);
  392  }

  397  void CCamera::SetZoomValueFollowPedScript(short dist) {
  398:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueFollowPedScript), this, dist);
  399  }

  404  void CCamera::StartTransition(short newMode) {
  405:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransition), this, newMode);
  406  }

  411  void CCamera::StartTransitionWhenNotFinishedInter(short mode) {
  412:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransitionWhenNotFinishedInter), this, mode);
  413  }

  418  void CCamera::StoreValuesDuringInterPol(CVector &source, CVector &target, CVector &up, float *fov) {
  419:     plugin::CallMethodDynGlobal<CCamera *, CVector &, CVector &, CVector &, float *>(gaddrof(CCamera::StoreValuesDuringInterPol), this, source, target, up, fov);
  420  }

  425  void CCamera::TakeControl(CEntity *target, short mode, short typeOfSwitch, int controller) {
  426:     plugin::CallMethodDynGlobal<CCamera *, CEntity *, short, short, int>(gaddrof(CCamera::TakeControl), this, target, mode, typeOfSwitch, controller);
  427  }

  432  void CCamera::TakeControlNoEntity(CVector const &pos, short typeOfSwitch, int controller) {
  433:     plugin::CallMethodDynGlobal<CCamera *, CVector const &, short, int>(gaddrof(CCamera::TakeControlNoEntity), this, pos, typeOfSwitch, controller);
  434  }

  439  void CCamera::TakeControlWithSpline(short typeOfSwitch) {
  440:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::TakeControlWithSpline), this, typeOfSwitch);
  441  }

  446  bool CCamera::TryToStartNewCamMode(int obbeMode) {
  447:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int>(gaddrof(CCamera::TryToStartNewCamMode), this, obbeMode);
  448  }

  453  void CCamera::UpdateAimingCoors(CVector const &coors) {
  454:     plugin::CallMethodDynGlobal<CCamera *, CVector const &>(gaddrof(CCamera::UpdateAimingCoors), this, coors);
  455  }

  460  void CCamera::UpdateSoundDistances() {
  461:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateSoundDistances), this);
  462  }

  467  void CCamera::UpdateTargetEntity() {
  468:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateTargetEntity), this);
  469  }

  474  void CamShakeNoPos(CCamera *camera, float strength) {
  475:     plugin::CallDynGlobal<CCamera *, float>(gaddrof(CamShakeNoPos), camera, strength);
  476  }

plugin_III\game_III\CCarAI.cpp:
   14  void CCarAI::AddAmbulanceOccupants(CVehicle *vehicle) {
   15:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddAmbulanceOccupants), vehicle);
   16  }

   21  void CCarAI::AddFiretruckOccupants(CVehicle *vehicle) {
   22:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddFiretruckOccupants), vehicle);
   23  }

   28  void CCarAI::AddPoliceCarOccupants(CVehicle *vehicle) {
   29:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddPoliceCarOccupants), vehicle);
   30  }

   35  void CCarAI::CarHasReasonToStop(CVehicle *vehicle) {
   36:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::CarHasReasonToStop), vehicle);
   37  }

   42  eCarMission CCarAI::FindPoliceCarMissionForWantedLevel() {
   43:     return plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceCarMissionForWantedLevel));
   44  }

   49  int CCarAI::FindPoliceCarSpeedForWantedLevel(CVehicle *vehicle) {
   50:     return plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CCarAI::FindPoliceCarSpeedForWantedLevel), vehicle);
   51  }

   56  float CCarAI::FindSwitchDistanceClose() {
   57:     return plugin::CallAndReturnDynGlobal<float>(gaddrof(CCarAI::FindSwitchDistanceClose));
   58  }

   63  float CCarAI::FindSwitchDistanceFar(CVehicle *vehicle) {
   64:     return plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarAI::FindSwitchDistanceFar), vehicle);
   65  }

   70  float CCarAI::GetCarToGoToCoors(CVehicle *vehicle, CVector *coors) {
   71:     return plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToGoToCoors), vehicle, coors);
   72  }

   77  void CCarAI::MakeWayForCarWithSiren(CVehicle *vehicle) {
   78:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MakeWayForCarWithSiren), vehicle);
   79  }

   84  void CCarAI::MellowOutChaseSpeed(CVehicle *vehicle) {
   85:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeed), vehicle);
   86  }

   91  void CCarAI::TellCarToBlockOtherCar(CVehicle *vehicle, CVehicle *blockVehicle) {
   92:     plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToBlockOtherCar), vehicle, blockVehicle);
   93  }

   98  void CCarAI::TellCarToRamOtherCar(CVehicle *vehicle, CVehicle *ramVehicle) {
   99:     plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToRamOtherCar), vehicle, ramVehicle);
  100  }

  105  void CCarAI::TellOccupantsToLeaveCar(CVehicle *vehicle) {
  106:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToLeaveCar), vehicle);
  107  }

  112  void CCarAI::UpdateCarAI(CVehicle *vehicle) {
  113:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::UpdateCarAI), vehicle);
  114  }

plugin_III\game_III\CCarCtrl.cpp:
   34  void CCarCtrl::AddToCarArray(int id, int vehicleClass) {
   35:     plugin::CallDynGlobal<int, int>(gaddrof(CCarCtrl::AddToCarArray), id, vehicleClass);
   36  }

   41  int CCarCtrl::ChooseCarModel(int vehicleClass) {
   42:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::ChooseCarModel), vehicleClass);
   43  }

   48  int CCarCtrl::ChooseGangCarModel(int gang) {
   49:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::ChooseGangCarModel), gang);
   50  }

   55  int CCarCtrl::ChooseModel(CZoneInfo *info, CVector *pos, int *outVehicleClass) {
   56:     return plugin::CallAndReturnDynGlobal<int, CZoneInfo *, CVector *, int *>(gaddrof(CCarCtrl::ChooseModel), info, pos, outVehicleClass);
   57  }

   62  int CCarCtrl::ChoosePoliceCarModel() {
   63:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CCarCtrl::ChoosePoliceCarModel));
   64  }

   76  int CCarCtrl::CountCarsOfType(int modelIndex) {
   77:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::CountCarsOfType), modelIndex);
   78  }

   83  void CCarCtrl::DragCarToPoint(CVehicle *vehicle, CVector *point) {
   84:     plugin::CallDynGlobal<CVehicle *, CVector *>(gaddrof(CCarCtrl::DragCarToPoint), vehicle, point);
   85  }

   90  float CCarCtrl::FindAngleToWeaveThroughTraffic(CVehicle *vehicle, CPhysical *target, float angleToTarget, float angleForward) {
   91:     return plugin::CallAndReturnDynGlobal<float, CVehicle *, CPhysical *, float, float>(gaddrof(CCarCtrl::FindAngleToWeaveThroughTraffic), vehicle, target, angleToTarget, angleForward);
   92  }

   97  void CCarCtrl::FindLinksToGoWithTheseNodes(CVehicle *vehicle) {
   98:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::FindLinksToGoWithTheseNodes), vehicle);
   99  }

  104  float CCarCtrl::FindMaxSteerAngle(CVehicle *vehicle) {
  105:     return plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarCtrl::FindMaxSteerAngle), vehicle);
  106  }

  111  float CCarCtrl::FindMaximumSpeedForThisCarInTraffic(CVehicle *vehicle) {
  112:     return plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarCtrl::FindMaximumSpeedForThisCarInTraffic), vehicle);
  113  }

  118  unsigned char CCarCtrl::FindPathDirection(int prevNode, int curNode, int nextNode) {
  119:     return plugin::CallAndReturnDynGlobal<unsigned char, int, int, int>(gaddrof(CCarCtrl::FindPathDirection), prevNode, curNode, nextNode);
  120  }

  125  float CCarCtrl::FindSpeedMultiplier(float angleChange, float minAngle, float maxAngle, float coef) {
  126:     return plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CCarCtrl::FindSpeedMultiplier), angleChange, minAngle, maxAngle, coef);
  127  }

  139  bool CCarCtrl::GenerateOneEmergencyServicesCar(unsigned int modelIndex, CVector point) {
  140:     return plugin::CallAndReturnDynGlobal<bool, unsigned int, CVector>(gaddrof(CCarCtrl::GenerateOneEmergencyServicesCar), modelIndex, point);
  141  }

  167  bool CCarCtrl::IsThisVehicleInteresting(CVehicle *vehicle) {
  168:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::IsThisVehicleInteresting), vehicle);
  169  }

  174  void CCarCtrl::JoinCarWithRoadSystem(CVehicle *vehicle) {
  175:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::JoinCarWithRoadSystem), vehicle);
  176  }

  181  bool CCarCtrl::JoinCarWithRoadSystemGotoCoors(CVehicle *vehicle, CVector point, bool isProperNow) {
  182:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *, CVector, bool>(gaddrof(CCarCtrl::JoinCarWithRoadSystemGotoCoors), vehicle, point, isProperNow);
  183  }

  188  bool CCarCtrl::MapCouldMoveInThisArea(float x, float y) {
  189:     return plugin::CallAndReturnDynGlobal<bool, float, float>(gaddrof(CCarCtrl::MapCouldMoveInThisArea), x, y);
  190  }

  195  bool CCarCtrl::PickNextNodeAccordingStrategy(CVehicle *vehicle) {
  196:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeAccordingStrategy), vehicle);
  197  }

  202  void CCarCtrl::PickNextNodeRandomly(CVehicle *vehicle) {
  203:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::PickNextNodeRandomly), vehicle);
  204  }

  209  void CCarCtrl::PickNextNodeToChaseCar(CVehicle *vehicle, float targetX, float targetY, CVehicle *target) {
  210:     plugin::CallDynGlobal<CVehicle *, float, float, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeToChaseCar), vehicle, targetX, targetY, target);
  211  }

  216  bool CCarCtrl::PickNextNodeToFollowPath(CVehicle *vehicle) {
  217:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeToFollowPath), vehicle);
  218  }

  223  void CCarCtrl::PossiblyRemoveVehicle(CVehicle *vehicle) {
  224:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::PossiblyRemoveVehicle), vehicle);
  225  }

  237  void CCarCtrl::RegisterVehicleOfInterest(CVehicle *vehicle) {
  238:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::RegisterVehicleOfInterest), vehicle);
  239  }

  251  void CCarCtrl::RemoveFromInterestingVehicleList(CVehicle *vehicle) {
  252:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::RemoveFromInterestingVehicleList), vehicle);
  253  }

  258  void CCarCtrl::ScanForPedDanger(CVehicle *vehicle) {
  259:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::ScanForPedDanger), vehicle);
  260  }

  265  void CCarCtrl::SlowCarDownForCarsSectorList(CPtrList &list, CVehicle *vehicle, float x_inf, float y_inf, float x_sup, float y_sup, float *pSpeed, float curSpeed) {
  266:     plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float>(gaddrof(CCarCtrl::SlowCarDownForCarsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pSpeed, curSpeed);
  267  }

  272  void CCarCtrl::SlowCarDownForOtherCar(CEntity *entity, CVehicle *vehicle, float *pSpeed, float curSpeed) {
  273:     plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float>(gaddrof(CCarCtrl::SlowCarDownForOtherCar), entity, vehicle, pSpeed, curSpeed);
  274  }

  279  void CCarCtrl::SlowCarDownForPedsSectorList(CPtrList &list, CVehicle *vehicle, float x_inf, float y_inf, float x_sup, float y_sup, float *pSpeed, float curSpeed) {
  280:     plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float>(gaddrof(CCarCtrl::SlowCarDownForPedsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pSpeed, curSpeed);
  281  }

  286  void CCarCtrl::SlowCarOnRailsDownForTrafficAndLights(CVehicle *vehicle) {
  287:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SlowCarOnRailsDownForTrafficAndLights), vehicle);
  288  }

  293  void CCarCtrl::SteerAIBoatWithPhysics(CBoat *boat) {
  294:     plugin::CallDynGlobal<CBoat *>(gaddrof(CCarCtrl::SteerAIBoatWithPhysics), boat);
  295  }

  300  void CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget(CBoat *boat, float targetX, float targetY, float *steerAngle, float *gasPedal, float *breakPedal) {
  301:     plugin::CallDynGlobal<CBoat *, float, float, float *, float *, float *>(gaddrof(CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget), boat, targetX, targetY, steerAngle, gasPedal, breakPedal);
  302  }

  307  void CCarCtrl::SteerAICarWithPhysics(CVehicle *vehicle) {
  308:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SteerAICarWithPhysics), vehicle);
  309  }

  314  void CCarCtrl::SteerAICarWithPhysicsFollowPath(CVehicle *vehicle, float *steerAngle, float *gasPedal, float *breakPedal, bool *bHandBrake) {
  315:     plugin::CallDynGlobal<CVehicle *, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsFollowPath), vehicle, steerAngle, gasPedal, breakPedal, bHandBrake);
  316  }

  321  void CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(CVehicle *vehicle, CPhysical *target, float targetX, float targetY, float *steerAngle, float *gasPedal, float *breakPedal, bool *bHandBrake) {
  322:     plugin::CallDynGlobal<CVehicle *, CPhysical *, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsHeadingForTarget), vehicle, target, targetX, targetY, steerAngle, gasPedal, breakPedal, bHandBrake);
  323  }

  328  void CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget(CVehicle *vehicle, float targetX, float targetY, float targetSpeedX, float targetSpeedY, float *steerAngle, float *gasPedal, float *breakPedal, bool *bHandBrake) {
  329:     plugin::CallDynGlobal<CVehicle *, float, float, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget), vehicle, targetX, targetY, targetSpeedX, targetSpeedY, steerAngle, gasPedal, breakPedal, bHandBrake);
  330  }

  335  void CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop(CVehicle *vehicle, float targetX, float targetY, float targetSpeedX, float targetSpeedY, float *steerAngle, float *gasPedal, float *breakPedal, bool *bHandBrake) {
  336:     plugin::CallDynGlobal<CVehicle *, float, float, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop), vehicle, targetX, targetY, targetSpeedX, targetSpeedY, steerAngle, gasPedal, breakPedal, bHandBrake);
  337  }

  342  void CCarCtrl::SteerAICarWithPhysics_OnlyMission(CVehicle *vehicle, float *steerAngle, float *gasPedal, float *breakPedal, bool *bHandBrake) {
  343:     plugin::CallDynGlobal<CVehicle *, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysics_OnlyMission), vehicle, steerAngle, gasPedal, breakPedal, bHandBrake);
  344  }

  349  void CCarCtrl::SwitchVehicleToRealPhysics(CVehicle *vehicle) {
  350:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SwitchVehicleToRealPhysics), vehicle);
  351  }

  356  float CCarCtrl::TestCollisionBetween2MovingRects(CVehicle *vehicleA, CVehicle *vehicleB, float projectionX, float projectionY, CVector *pForwardA, CVector *pForwardB, unsigned char id) {
  357:     return plugin::CallAndReturnDynGlobal<float, CVehicle *, CVehicle *, float, float, CVector *, CVector *, unsigned char>(gaddrof(CCarCtrl::TestCollisionBetween2MovingRects), vehicleA, vehicleB, projectionX, projectionY, pForwardA, pForwardB, id);
  358  }

  363  bool CCarCtrl::ThisRoadObjectCouldMove(unsigned int objectModelIndex) {
  364:     return plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CCarCtrl::ThisRoadObjectCouldMove), objectModelIndex);
  365  }

  370  void CCarCtrl::UpdateCarCount(CVehicle *vehicle, bool remove) {
  371:     plugin::CallDynGlobal<CVehicle *, bool>(gaddrof(CCarCtrl::UpdateCarCount), vehicle, remove);
  372  }

  377  void CCarCtrl::UpdateCarOnRails(CVehicle *vehicle) {
  378:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::UpdateCarOnRails), vehicle);
  379  }

  384  void CCarCtrl::WeaveForObject(CEntity *entity, CVehicle *vehicle, float *pAngleToWeaveLeft, float *pAngleToWeaveRight) {
  385:     plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForObject), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);
  386  }

  391  void CCarCtrl::WeaveForOtherCar(CEntity *entity, CVehicle *vehicle, float *pAngleToWeaveLeft, float *pAngleToWeaveRight) {
  392:     plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForOtherCar), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);
  393  }

  398  void CCarCtrl::WeaveForPed(CEntity *entity, CVehicle *vehicle, float *pAngleToWeaveLeft, float *pAngleToWeaveRight) {
  399:     plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForPed), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);
  400  }

  405  void CCarCtrl::WeaveThroughCarsSectorList(CPtrList &list, CVehicle *vehicle, CPhysical *target, float x_inf, float y_inf, float x_sup, float y_sup, float *pAngleToWeaveLeft, float *pAngleToWeaveRight) {
  406:     plugin::CallDynGlobal<CPtrList &, CVehicle *, CPhysical *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughCarsSectorList), list, vehicle, target, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);
  407  }

  412  void CCarCtrl::WeaveThroughObjectsSectorList(CPtrList &list, CVehicle *vehicle, float x_inf, float y_inf, float x_sup, float y_sup, float *pAngleToWeaveLeft, float *pAngleToWeaveRight) {
  413:     plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughObjectsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);
  414  }

  419  void CCarCtrl::WeaveThroughPedsSectorList(CPtrList &list, CVehicle *vehicle, CPhysical *target, float x_inf, float y_inf, float x_sup, float y_sup, float *pAngleToWeaveLeft, float *pAngleToWeaveRight) {
  420:     plugin::CallDynGlobal<CPtrList &, CVehicle *, CPhysical *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughPedsSectorList), list, vehicle, target, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);
  421  }

plugin_III\game_III\CCarGenerator.cpp:
  17  unsigned int CCarGenerator::CalcNextGen() {
  18:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CCarGenerator *>(gaddrof(CCarGenerator::CalcNextGen), this);
  19  }

  24  bool CCarGenerator::CheckForBlockage() {
  25:     return plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckForBlockage), this);
  26  }

  31  bool CCarGenerator::CheckIfWithinRangeOfAnyPlayers() {
  32:     return plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckIfWithinRangeOfAnyPlayers), this);
  33  }

  38  void CCarGenerator::DoInternalProcessing() {
  39:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::DoInternalProcessing), this);
  40  }

  45  void CCarGenerator::Process() {
  46:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::Process), this);
  47  }

  52  void CCarGenerator::Setup(float x, float y, float z, float angle, int modelId, short primaryColor, short secondaryColor, unsigned char forceSpawn, unsigned char alarm, unsigned char doorLock, unsigned short minDelay, unsigned short maxDelay) {
  53:     plugin::CallMethodDynGlobal<CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(gaddrof(CCarGenerator::Setup), this, x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay);
  54  }

  59  void CCarGenerator::SwitchOff() {
  60:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOff), this);
  61  }

  66  void CCarGenerator::SwitchOn() {
  67:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOn), this);
  68  }

plugin_III\game_III\CCivilianPed.cpp:
  23  void CCivilianPed::ProcessControl() {
  24:     plugin::CallVirtualMethod<8, CCivilianPed *>(this);
  25  }

  30  void CCivilianPed::CivilianAI() {
  31:     plugin::CallMethodDynGlobal<CCivilianPed *>(gaddrof(CCivilianPed::CivilianAI), this);
  32  }

plugin_III\game_III\CClock.cpp:
  24  int CClock::GetGameClockMinutesUntil(unsigned char hours, unsigned char minutes) {
  25:     return plugin::CallAndReturnDynGlobal<int, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);
  26  }

  31  bool CClock::GetIsTimeInRange(unsigned char hourA, unsigned char hourB) {
  32:     return plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);
  33  }

  38  void CClock::Initialise(unsigned int milisecondsPerGameMinute) {
  39:     plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);
  40  }

  52  void CClock::SetGameClock(unsigned char hours, unsigned char minutes) {
  53:     plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes);
  54  }

plugin_III\game_III\CClouds.cpp:
  36  void CClouds::RenderBackground(short redTop, short greenTop, short blueTop, short redBottom, short greenBottom, short blueBottom, short alpha) {
  37:     plugin::CallDynGlobal<short, short, short, short, short, short, short>(gaddrof(CClouds::RenderBackground), redTop, greenTop, blueTop, redBottom, greenBottom, blueBottom, alpha);
  38  }

  64  bool UseDarkBackground() {
  65:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(UseDarkBackground));
  66  }

plugin_III\game_III\CClumpModelInfo.cpp:
   23  void CClumpModelInfo::DeleteRwObject() {
   24:     plugin::CallVirtualMethod<2, CClumpModelInfo *>(this);
   25  }

   30  RwObject *CClumpModelInfo::CreateInstance() {
   31:     return plugin::CallVirtualMethodAndReturn<RwObject *, 3, CClumpModelInfo *>(this);
   32  }

   37  RwObject *CClumpModelInfo::CreateInstance(RwMatrix *matrix) {
   38:     return plugin::CallVirtualMethodAndReturn<RwObject *, 4, CClumpModelInfo *, RwMatrix *>(this, matrix);
   39  }

   44  RwObject *CClumpModelInfo::GetRwObject() {
   45:     return plugin::CallVirtualMethodAndReturn<RwObject *, 5, CClumpModelInfo *>(this);
   46  }

   51  void CClumpModelInfo::SetClump(RpClump *clump) {
   52:     plugin::CallVirtualMethod<6, CClumpModelInfo *, RpClump *>(this, clump);
   53  }

   58  void CClumpModelInfo::SetFrameIds(RwObjectNameIdAssocation *id) {
   59:     plugin::CallMethodDynGlobal<CClumpModelInfo *, RwObjectNameIdAssocation *>(gaddrof(CClumpModelInfo::SetFrameIds), this, id);
   60  }

   65  void CClumpModelInfo::FillFrameArray(RpClump *clump, RwFrame **frames) {
   66:     plugin::CallDynGlobal<RpClump *, RwFrame **>(gaddrof(CClumpModelInfo::FillFrameArray), clump, frames);
   67  }

   72  RwFrame *CClumpModelInfo::FillFrameArrayCB(RwFrame *frame, void *data) {
   73:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FillFrameArrayCB), frame, data);
   74  }

   79  RwFrame *CClumpModelInfo::FindFrameFromIdCB(RwFrame *frame, void *data) {
   80:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromIdCB), frame, data);
   81  }

   86  RwFrame *CClumpModelInfo::FindFrameFromNameCB(RwFrame *frame, void *data) {
   87:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromNameCB), frame, data);
   88  }

   93  RwFrame *CClumpModelInfo::FindFrameFromNameWithoutIdCB(RwFrame *frame, void *data) {
   94:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromNameWithoutIdCB), frame, data);
   95  }

  100  RwFrame *CClumpModelInfo::GetFrameFromId(RpClump *clump, int id) {
  101:     return plugin::CallAndReturnDynGlobal<RwFrame *, RpClump *, int>(gaddrof(CClumpModelInfo::GetFrameFromId), clump, id);
  102  }

  107  RpAtomic *CClumpModelInfo::SetAtomicRendererCB(RpAtomic *atomic, void *data) {
  108:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CClumpModelInfo::SetAtomicRendererCB), atomic, data);
  109  }

plugin_III\game_III\CColBox.cpp:
  14  void CColBox::operator=(CColBox const &right) {
  15:     plugin::CallMethodDynGlobal<CColBox *, CColBox const &>(gaddrof(CColBox::operator=), this, right);
  16  }

  21  void CColBox::Set(CVector &min, CVector &max, unsigned char material, unsigned char flag) {
  22:     plugin::CallMethodDynGlobal<CColBox *, CVector &, CVector &, unsigned char, unsigned char>(gaddrof(CColBox::Set), this, min, max, material, flag);
  23  }

plugin_III\game_III\CColLine.cpp:
  20  void CColLine::Set(CVector const &start, CVector const &end) {
  21:     plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(gaddrof(CColLine::Set), this, start, end);
  22  }

plugin_III\game_III\CCollision.cpp:
   11      eLevelName result;
   12:     plugin::CallAndReturn<eLevelName, 0x40B4E0, eLevelName*, CPtrList&>(&result, list);
   13      return result;

   18      eLevelName result;
   19:     plugin::CallAndReturn<eLevelName, 0x40B520, eLevelName*, CSector&>(&result, sector);
   20      return result;

   24  void CCollision::Init() {
   25:     plugin::Call<0x40B380>();
   26  }

   29  void CCollision::Shutdown() {
   30:     plugin::Call<0x40B3A0>();
   31  }

   34  void CCollision::Update() {
   35:     plugin::Call<0x40B3B0>();
   36  }

   39  void CCollision::LoadCollisionScreen(eLevelName levelName) {
   40:     plugin::Call<0x40B580, eLevelName>(levelName);
   41  }

   44  void CCollision::LoadCollisionWhenINeedIt(bool arg0) {
   45:     plugin::Call<0x40B5B0, bool>(arg0);
   46  }

   49  void CCollision::SortOutCollisionAfterLoad() {
   50:     plugin::Call<0x40B900>();
   51  }

   54  void CCollision::CalculateTrianglePlanes(CColModel* colModel) {
   55:     plugin::Call<0x40B960, CColModel*>(colModel);
   56  }

   59  bool CCollision::ProcessSphereSphere(CColSphere const& sphere1, CColSphere const& sphere2, CColPoint& colPoint, float& maxTouchDistance) {
   60:     return plugin::CallAndReturn<bool, 0x40B9F0, CColSphere const&, CColSphere const&, CColPoint&, float&>(sphere1, sphere2, colPoint, maxTouchDistance);
   61  }

   64  bool CCollision::TestSphereBox(CColSphere const& sphere, CColBox const& box) {
   65:     return plugin::CallAndReturn<bool, 0x40BB70, CColSphere const&, CColBox const&>(sphere, box);
   66  }

   69  bool CCollision::ProcessSphereBox(CColSphere const& sphere, CColBox const& box, CColPoint& colPoint, float& maxTouchDistance) {
   70:     return plugin::CallAndReturn<bool, 0x40BC00, CColSphere const&, CColBox const&, CColPoint&, float&>(sphere, box, colPoint, maxTouchDistance);
   71  }

   74  bool CCollision::TestSphereTriangle(CColSphere const& sphere, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane) {
   75:     return plugin::CallAndReturn<bool, 0x40C580, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(sphere, verts, tri, triPlane);
   76  }

   79  bool CCollision::ProcessSphereTriangle(CColSphere const& sphere, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane, CColPoint& colPoint, float& maxTouchDistance) {
   80:     return plugin::CallAndReturn<bool, 0x40CE30, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(sphere, verts, tri, triPlane, colPoint, maxTouchDistance);
   81  }

   84  bool CCollision::TestLineSphere(CColLine const& colLine, CColSphere const& sphere) {
   85:     return plugin::CallAndReturn<bool, 0x40DAA0, CColLine const&, CColSphere const&>(colLine, sphere);
   86  }

   89  float CCollision::DistToLine(CVector const* lineStart, CVector const* lineEnd, CVector const* point) {
   90:     return plugin::CallAndReturn<float, 0x40DC70, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
   91  }

   94  bool CCollision::ProcessLineSphere(CColLine const& colLine, CColSphere const& sphere, CColPoint& colPoint, float& depth) {
   95:     return plugin::CallAndReturn<bool, 0x40DE80, CColLine const&, CColSphere const&, CColPoint&, float&>(colLine, sphere, colPoint, depth);
   96  }

   99  bool CCollision::TestLineBox(CColLine const& colLine, CColBox const& colBox) {
  100:     return plugin::CallAndReturn<bool, 0x40E130, CColLine const&, CColBox const&>(colLine, colBox);
  101  }

  104  bool CCollision::TestVerticalLineBox(CColLine const& colLine, CColBox const& colBox) {
  105:     return plugin::CallAndReturn<bool, 0x40E5C0, CColLine const&, CColBox const&>(colLine, colBox);
  106  }

  109  bool CCollision::ProcessLineBox(CColLine const& colLine, CColBox const& colBox, CColPoint& colPoint, float& maxTouchDistance) {
  110:     return plugin::CallAndReturn<bool, 0x40E670, CColLine const&, CColBox const&, CColPoint&, float&>(colLine, colBox, colPoint, maxTouchDistance);
  111  }

  114  bool CCollision::TestLineTriangle(CColLine const& colLine, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane) {
  115:     return plugin::CallAndReturn<bool, 0x40EC10, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(colLine, verts, tri, triPlane);
  116  }

  119  bool CCollision::ProcessLineTriangle(CColLine const& colLine, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane, CColPoint& colPoint, float& maxTouchDistance) {
  120:     return plugin::CallAndReturn<bool, 0x40F140, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(colLine, verts, tri, triPlane, colPoint, maxTouchDistance);
  121  }

  124  bool CCollision::TestLineOfSight(CColLine const& colLine, CMatrix const& transform, CColModel& colModel, bool doSeeThroughCheck) {
  125:     return plugin::CallAndReturn<bool, 0x40F720, CColLine const&, CMatrix const&, CColModel&, bool>(colLine, transform, colModel, doSeeThroughCheck);
  126  }

  129  bool CCollision::ProcessLineOfSight(CColLine const& colLine, CMatrix const& transform, CColModel& colModel, CColPoint& colPoint, float& maxTouchDistance, bool doSeeThroughCheck) {
  130:     return plugin::CallAndReturn<bool, 0x40F910, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool>(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck);
  131  }

  134  bool CCollision::ProcessVerticalLineTriangle(CColLine const& colLine, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane, CColPoint& colPoint, float& maxTouchDistance, CStoredCollPoly* colPoly) {
  135:     return plugin::CallAndReturn<bool, 0x40FB50, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly*>(colLine, verts, tri, triPlane, colPoint, maxTouchDistance, colPoly);
  136  }

  139  bool CCollision::ProcessVerticalLine(CColLine const& colLine, CMatrix const& transform, CColModel& colModel, CColPoint& colPoint, float& maxTouchDistance, bool doSeeThroughCheck, CStoredCollPoly* colPoly) {
  140:     return plugin::CallAndReturn<bool, 0x410120, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, CStoredCollPoly*>(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, colPoly);
  141  }

  144  bool CCollision::IsStoredPolyStillValidVerticalLine(CVector const& lineOrigin, float lineDist, CColPoint& colPoint, CStoredCollPoly* colPoly) {
  145:     return plugin::CallAndReturn<bool, 0x4105A0, CVector const&, float, CColPoint&, CStoredCollPoly*>(lineOrigin, lineDist, colPoint, colPoly);
  146  }

  149  int CCollision::ProcessColModels(CMatrix const& transform1, CColModel& colModel1, CMatrix const& transform2, CColModel& colModel2, CColPoint* colPoint1, CColPoint* colPoint2, float* maxTouchDistance) {
  150:     return plugin::CallAndReturn<int, 0x410BE0, CMatrix const&, CColModel&, CMatrix const&, CColModel&, CColPoint*, CColPoint*, float*>(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance);
  151  }

plugin_III\game_III\CColModel.cpp:
  14  CColModel::CColModel() {
  15:     plugin::CallMethodDynGlobal<CColModel *>(ctor_gaddr(CColModel), this);
  16  }

  21  CColModel::~CColModel() {
  22:     plugin::CallMethodDynGlobal<CColModel *>(dtor_gaddr(CColModel), this);
  23  }

  28  void CColModel::operator=(CColModel const &right) {
  29:     plugin::CallMethodDynGlobal<CColModel *, CColModel const &>(gaddrof_o(CColModel::operator=, void (CColModel::*)(CColModel const &)), this, right);
  30  }

  35  void CColModel::CalculateTrianglePlanes() {
  36:     plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::CalculateTrianglePlanes), this);
  37  }

  42  CLink<CColModel *> *CColModel::GetLinkPtr() {
  43:     return plugin::CallMethodAndReturnDynGlobal<CLink<CColModel *> *, CColModel *>(gaddrof(CColModel::GetLinkPtr), this);
  44  }

  49  void CColModel::GetTrianglePoint(CVector &outVec, int vertId) {
  50:     plugin::CallMethodDynGlobal<CColModel *, CVector &, int>(gaddrof(CColModel::GetTrianglePoint), this, outVec, vertId);
  51  }

  56  void CColModel::RemoveCollisionVolumes() {
  57:     plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::RemoveCollisionVolumes), this);
  58  }

  63  void CColModel::RemoveTrianglePlanes() {
  64:     plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::RemoveTrianglePlanes), this);
  65  }

  70  void CColModel::SetLinkPtr(CLink<CColModel *> *link) {
  71:     plugin::CallMethodDynGlobal<CColModel *, CLink<CColModel *> *>(gaddrof(CColModel::SetLinkPtr), this, link);
  72  }

plugin_III\game_III\CColSphere.cpp:
  14  CColSphere::CColSphere() {
  15:     plugin::CallMethodDynGlobal<CColSphere *>(ctor_gaddr(CColSphere), this);
  16  }

  21  void CColSphere::Set(float radius, CVector &center, unsigned char material, unsigned char flag) {
  22:     plugin::CallMethodDynGlobal<CColSphere *, float, CVector &, unsigned char, unsigned char>(gaddrof(CColSphere::Set), this, radius, center, material, flag);
  23  }

plugin_III\game_III\CColTriangle.cpp:
  14  void CColTriangle::Set(CompressedVector const *verts, int vertA, int vertB, int vertC, unsigned char material, unsigned char flag) {
  15:     plugin::CallMethodDynGlobal<CColTriangle *, CompressedVector const *, int, int, int, unsigned char, unsigned char>(gaddrof(CColTriangle::Set), this, verts, vertA, vertB, vertC, material, flag);
  16  }

plugin_III\game_III\CColTrianglePlane.cpp:
  14  void CColTrianglePlane::GetNormal(CVector &point) {
  15:     plugin::CallMethodDynGlobal<CColTrianglePlane *, CVector &>(gaddrof(CColTrianglePlane::GetNormal), this, point);
  16  }

  21  void CColTrianglePlane::Set(CompressedVector const *verts, CColTriangle &tri) {
  22:     plugin::CallMethodDynGlobal<CColTrianglePlane *, CompressedVector const *, CColTriangle &>(gaddrof(CColTrianglePlane::Set), this, verts, tri);
  23  }

plugin_III\game_III\CControllerState.cpp:
  10  void CControllerState::Clear() {
  11:     plugin::CallMethod<0x4916C0, CControllerState *>(this);
  12  }

plugin_III\game_III\CCopPed.cpp:
  23  void CCopPed::ProcessControl() {
  24:     plugin::CallVirtualMethod<8, CCopPed *>(this);
  25  }

  30  void CCopPed::ArrestPlayer() {
  31:     plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ArrestPlayer), this);
  32  }

  37  void CCopPed::ClearPursuit() {
  38:     plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ClearPursuit), this);
  39  }

  44  void CCopPed::CopAI() {
  45:     plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::CopAI), this);
  46  }

  51  void CCopPed::ScanForCrimes() {
  52:     plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ScanForCrimes), this);
  53  }

  58  void CCopPed::SetArrestPlayer(CPed *player) {
  59:     plugin::CallMethodDynGlobal<CCopPed *, CPed *>(gaddrof(CCopPed::SetArrestPlayer), this, player);
  60  }

  65  void CCopPed::SetPursuit(bool ignoreCopLimit) {
  66:     plugin::CallMethodDynGlobal<CCopPed *, bool>(gaddrof(CCopPed::SetPursuit), this, ignoreCopLimit);
  67  }

plugin_III\game_III\CCoronas.cpp:
  37  void CCoronas::RegisterCorona(unsigned int id, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, CVector const &coors, float size, float drawDist, unsigned char coronaType, unsigned char flareType, unsigned char reflection, unsigned char LOScheck, unsigned char drawStreak, float someAngle) {
  38:     plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof_o(CCoronas::RegisterCorona, void (*)(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float)), id, red, green, blue, alpha, coors, size, drawDist, coronaType, flareType, reflection, LOScheck, drawStreak, someAngle);
  39  }

  44  void CCoronas::RegisterCorona(unsigned int id, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, CVector const &coors, float size, float drawDist, RwTexture *texture, unsigned char flareType, unsigned char reflection, unsigned char LOScheck, unsigned char drawStreak, float someAngle) {
  45:     plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, RwTexture *, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof_o(CCoronas::RegisterCorona, void (*)(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, RwTexture *, unsigned char, unsigned char, unsigned char, unsigned char, float)), id, red, green, blue, alpha, coors, size, drawDist, texture, flareType, reflection, LOScheck, drawStreak, someAngle);
  46  }

  79  void CCoronas::UpdateCoronaCoors(unsigned int id, CVector const &coors, float drawDist, float someAngle) {
  80:     plugin::CallDynGlobal<unsigned int, CVector const &, float, float>(gaddrof(CCoronas::UpdateCoronaCoors), id, coors, drawDist, someAngle);
  81  }

plugin_III\game_III\CCrane.cpp:
  14  void CCrane::CalcHookCoordinates(float *pX, float *pY, float *pZ) {
  15:     plugin::CallMethodDynGlobal<CCrane *, float *, float *, float *>(gaddrof(CCrane::CalcHookCoordinates), this, pX, pY, pZ);
  16  }

  21  bool CCrane::DoesCranePickUpThisCarType(unsigned int vehicleModelIndex) {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, unsigned int>(gaddrof(CCrane::DoesCranePickUpThisCarType), this, vehicleModelIndex);
  23  }

  28  void CCrane::FindCarInSectorList(CPtrList *list) {
  29:     plugin::CallMethodDynGlobal<CCrane *, CPtrList *>(gaddrof(CCrane::FindCarInSectorList), this, list);
  30  }

  35  void CCrane::FindParametersForTarget(float x, float y, float z, float *pAngle, float *pDistance, float *pHeight) {
  36:     plugin::CallMethodDynGlobal<CCrane *, float, float, float, float *, float *, float *>(gaddrof(CCrane::FindParametersForTarget), this, x, y, z, pAngle, pDistance, pHeight);
  37  }

  42  bool CCrane::GoTowardsHeightTarget(float targetHeight, float speedMultiplier) {
  43:     return plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, float, float>(gaddrof(CCrane::GoTowardsHeightTarget), this, targetHeight, speedMultiplier);
  44  }

  49  bool CCrane::GoTowardsTarget(float angleToTarget, float distanceToTarget, float targetHeight, float speedMultiplier) {
  50:     return plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, float, float, float, float>(gaddrof(CCrane::GoTowardsTarget), this, angleToTarget, distanceToTarget, targetHeight, speedMultiplier);
  51  }

  56  bool CCrane::RotateCarriedCarProperly() {
  57:     return plugin::CallMethodAndReturnDynGlobal<bool, CCrane *>(gaddrof(CCrane::RotateCarriedCarProperly), this);
  58  }

  63  void CCrane::SetHookMatrix() {
  64:     plugin::CallMethodDynGlobal<CCrane *>(gaddrof(CCrane::SetHookMatrix), this);
  65  }

  70  void CCrane::Update() {
  71:     plugin::CallMethodDynGlobal<CCrane *>(gaddrof(CCrane::Update), this);
  72  }

plugin_III\game_III\CCranes.cpp:
   18  void CCranes::ActivateCrane(float infX, float supX, float infY, float supY, float dropOffX, float dropOffY, float dropOffZ, float heading, bool isCrusher, bool isMilitary, float posX, float posY) {
   19:     plugin::CallDynGlobal<float, float, float, float, float, float, float, float, bool, bool, float, float>(gaddrof(CCranes::ActivateCrane), infX, supX, infY, supY, dropOffX, dropOffY, dropOffZ, heading, isCrusher, isMilitary, posX, posY);
   20  }

   25  void CCranes::AddThisOneCrane(CEntity *entity) {
   26:     plugin::CallDynGlobal<CEntity *>(gaddrof(CCranes::AddThisOneCrane), entity);
   27  }

   32  void CCranes::DeActivateCrane(float x, float y) {
   33:     plugin::CallDynGlobal<float, float>(gaddrof(CCranes::DeActivateCrane), x, y);
   34  }

   39  bool CCranes::DoesMilitaryCraneHaveThisOneAlready(unsigned int vehicleModelIndex) {
   40:     return plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CCranes::DoesMilitaryCraneHaveThisOneAlready), vehicleModelIndex);
   41  }

   46  bool CCranes::HaveAllCarsBeenCollectedByMilitaryCrane() {
   47:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CCranes::HaveAllCarsBeenCollectedByMilitaryCrane));
   48  }

   60  bool CCranes::IsThisCarBeingCarriedByAnyCrane(CVehicle *vehicle) {
   61:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingCarriedByAnyCrane), vehicle);
   62  }

   67  bool CCranes::IsThisCarBeingTargettedByAnyCrane(CVehicle *vehicle) {
   68:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingTargettedByAnyCrane), vehicle);
   69  }

   74  bool CCranes::IsThisCarPickedUp(float x, float y, CVehicle *vehicle) {
   75:     return plugin::CallAndReturnDynGlobal<bool, float, float, CVehicle *>(gaddrof(CCranes::IsThisCarPickedUp), x, y, vehicle);
   76  }

   81  void CCranes::RegisterCarForMilitaryCrane(unsigned int vehicleModelIndex) {
   82:     plugin::CallDynGlobal<unsigned int>(gaddrof(CCranes::RegisterCarForMilitaryCrane), vehicleModelIndex);
   83  }

   88  void CCranes::Save(unsigned char *buf, unsigned int *size) {
   89:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CCranes::Save), buf, size);
   90  }

  102  void CranesLoad(unsigned char *buf, unsigned int size) {
  103:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CranesLoad), buf, size);
  104  }

plugin_III\game_III\CCredits.cpp:
  17  bool CCredits::AreCreditsDone() {
  18:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CCredits::AreCreditsDone));
  19  }

  31  void CCredits::PrintCreditSpace(float space, unsigned int *line) {
  32:     plugin::CallDynGlobal<float, unsigned int *>(gaddrof(CCredits::PrintCreditSpace), space, line);
  33  }

  38  void CCredits::PrintCreditText(float scaleX, float scaleY, wchar_t *text, unsigned int *lineOffset, float scrollOffset) {
  39:     plugin::CallDynGlobal<float, float, wchar_t *, unsigned int *, float>(gaddrof(CCredits::PrintCreditText), scaleX, scaleY, text, lineOffset, scrollOffset);
  40  }

plugin_III\game_III\CCurrentVehicle.cpp:
  17  void CCurrentVehicle::Display() {
  18:     plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Display), this);
  19  }

  24  void CCurrentVehicle::Init() {
  25:     plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Init), this);
  26  }

  31  void CCurrentVehicle::Process() {
  32:     plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Process), this);
  33  }

plugin_III\game_III\CCurves.cpp:
  14  void CCurves::CalcCurvePoint(CVector *pPos1, CVector *pPos2, CVector *pDir1, CVector *pDir2, float between, int timeOnCurve, CVector *pOutPos, CVector *pOutDir) {
  15:     plugin::CallDynGlobal<CVector *, CVector *, CVector *, CVector *, float, int, CVector *, CVector *>(gaddrof(CCurves::CalcCurvePoint), pPos1, pPos2, pDir1, pDir2, between, timeOnCurve, pOutPos, pOutDir);
  16  }

  21  float CCurves::CalcSpeedScaleFactor(CVector *pPoint1, CVector *pPoint2, float dir1X, float dir1Y, float dir2X, float dir2Y) {
  22:     return plugin::CallAndReturnDynGlobal<float, CVector *, CVector *, float, float, float, float>(gaddrof(CCurves::CalcSpeedScaleFactor), pPoint1, pPoint2, dir1X, dir1Y, dir2X, dir2Y);
  23  }

plugin_III\game_III\CCutsceneHead.cpp:
  23  void CCutsceneHead::CreateRwObject() {
  24:     plugin::CallVirtualMethod<5, CCutsceneHead *>(this);
  25  }

  30  void CCutsceneHead::DeleteRwObject() {
  31:     plugin::CallVirtualMethod<6, CCutsceneHead *>(this);
  32  }

  37  void CCutsceneHead::ProcessControl() {
  38:     plugin::CallVirtualMethod<8, CCutsceneHead *>(this);
  39  }

  44  void CCutsceneHead::Render() {
  45:     plugin::CallVirtualMethod<13, CCutsceneHead *>(this);
  46  }

  51  void CCutsceneHead::PlayAnimation(char const *name) {
  52:     plugin::CallMethodDynGlobal<CCutsceneHead *, char const *>(gaddrof(CCutsceneHead::PlayAnimation), this, name);
  53  }

plugin_III\game_III\CCutsceneMgr.cpp:
  24  CCutsceneHead* CCutsceneMgr::AddCutsceneHead(CObject* object, int modelIndex) {
  25:     return plugin::CallAndReturn<CCutsceneHead*, 0x404CD0, CObject*, int>(object, modelIndex);
  26  }

  29  CCutsceneObject* CCutsceneMgr::CreateCutsceneObject(int modelIndex) {
  30:     return plugin::CallAndReturn<CCutsceneObject*, 0x404BE0, int>(modelIndex);
  31  }

  34  void CCutsceneMgr::DeleteCutsceneData() {
  35:     plugin::Call<0x4048E0>();
  36  }

  39  void CCutsceneMgr::FinishCutscene() {
  40:     plugin::Call<0x405140>();
  41  }

  44  int CCutsceneMgr::GetCutsceneTimeInMilleseconds() {
  45:     return plugin::CallAndReturn<int, 0x4051B0>();
  46  }

  49  bool CCutsceneMgr::HasCutsceneFinished() {
  50:     return plugin::CallAndReturn<bool, 0x4051F0>();
  51  }

  54  void CCutsceneMgr::Initialise() {
  55:     plugin::Call<0x4045D0>();
  56  }

  59  void CCutsceneMgr::LoadCutsceneData(char const* cutsceneName) {
  60:     plugin::Call<0x404650, char const*>(cutsceneName);
  61  }

  64  void CCutsceneMgr::SetCutsceneAnim(char const* animName, CObject* object) {
  65:     plugin::Call<0x404D20, char const*, CObject*>(animName, object);
  66  }

  69  void CCutsceneMgr::SetHeadAnim(char const* animName, CObject* object) {
  70:     plugin::Call<0x404D80, char const*, CObject*>(animName, object);
  71  }

  74  void CCutsceneMgr::SetupCutsceneToStart() {
  75:     plugin::Call<0x404DC0>();
  76  }

  79  void CCutsceneMgr::Shutdown() {
  80:     plugin::Call<0x404630>();
  81  }

  84  void CCutsceneMgr::Update() {
  85:     plugin::Call<0x404EE0>();
  86  }

  89  int FindCutsceneAudioTrackId(char const* cutsceneName) {
  90:     return plugin::CallAndReturn<int, 0x404530, char const*>(cutsceneName);
  91  }

plugin_III\game_III\CCutsceneObject.cpp:
  23  void CCutsceneObject::SetModelIndex(unsigned int modelIndex) {
  24:     plugin::CallVirtualMethod<3, CCutsceneObject *, unsigned int>(this, modelIndex);
  25  }

  30  void CCutsceneObject::ProcessControl() {
  31:     plugin::CallVirtualMethod<8, CCutsceneObject *>(this);
  32  }

  37  void CCutsceneObject::PreRender() {
  38:     plugin::CallVirtualMethod<12, CCutsceneObject *>(this);
  39  }

  44  void CCutsceneObject::Render() {
  45:     plugin::CallVirtualMethod<13, CCutsceneObject *>(this);
  46  }

  51  bool CCutsceneObject::SetupLighting() {
  52:     return plugin::CallVirtualMethodAndReturn<bool, 14, CCutsceneObject *>(this);
  53  }

  58  void CCutsceneObject::RemoveLighting(bool resetWorldColors) {
  59:     plugin::CallVirtualMethod<15, CCutsceneObject *, bool>(this, resetWorldColors);
  60  }

plugin_III\game_III\CDamageManager.cpp:
   16  bool CDamageManager::ApplyDamage(tComponent component, float damage, float unused) {
   17:     return plugin::CallMethodAndReturnDynGlobal<bool, CDamageManager *, tComponent, float, float>(gaddrof(CDamageManager::ApplyDamage), this, component, damage, unused);
   18  }

   23  void CDamageManager::FuckCarCompletely() {
   24:     plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::FuckCarCompletely), this);
   25  }

   30  bool CDamageManager::GetComponentGroup(tComponent component, tComponentGroup *group, unsigned char *subComp) {
   31:     return plugin::CallMethodAndReturnDynGlobal<bool, CDamageManager *, tComponent, tComponentGroup *, unsigned char *>(gaddrof(CDamageManager::GetComponentGroup), this, component, group, subComp);
   32  }

   37  int CDamageManager::GetDoorStatus(int door) {
   38:     return plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetDoorStatus), this, door);
   39  }

   44  int CDamageManager::GetEngineStatus() {
   45:     return plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *>(gaddrof(CDamageManager::GetEngineStatus), this);
   46  }

   51  int CDamageManager::GetLightStatus(eLights light) {
   52:     return plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, eLights>(gaddrof(CDamageManager::GetLightStatus), this, light);
   53  }

   58  int CDamageManager::GetPanelStatus(int panel) {
   59:     return plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetPanelStatus), this, panel);
   60  }

   65  int CDamageManager::GetWheelStatus(int wheel) {
   66:     return plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetWheelStatus), this, wheel);
   67  }

   72  void CDamageManager::ProgressDoorDamage(unsigned char door) {
   73:     plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressDoorDamage), this, door);
   74  }

   79  void CDamageManager::ProgressEngineDamage() {
   80:     plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::ProgressEngineDamage), this);
   81  }

   86  void CDamageManager::ProgressPanelDamage(unsigned char panel) {
   87:     plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressPanelDamage), this, panel);
   88  }

   93  void CDamageManager::ProgressWheelDamage(unsigned char wheel) {
   94:     plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressWheelDamage), this, wheel);
   95  }

  100  void CDamageManager::ResetDamageStatus() {
  101:     plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::ResetDamageStatus), this);
  102  }

  107  void CDamageManager::SetDoorStatus(int door, unsigned int status) {
  108:     plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetDoorStatus), this, door, status);
  109  }

  114  void CDamageManager::SetEngineStatus(unsigned int status) {
  115:     plugin::CallMethodDynGlobal<CDamageManager *, unsigned int>(gaddrof(CDamageManager::SetEngineStatus), this, status);
  116  }

  121  void CDamageManager::SetLightStatus(eLights light, unsigned int status) {
  122:     plugin::CallMethodDynGlobal<CDamageManager *, eLights, unsigned int>(gaddrof(CDamageManager::SetLightStatus), this, light, status);
  123  }

  128  void CDamageManager::SetPanelStatus(int panel, unsigned int status) {
  129:     plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetPanelStatus), this, panel, status);
  130  }

  135  void CDamageManager::SetWheelStatus(int wheel, unsigned int status) {
  136:     plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetWheelStatus), this, wheel, status);
  137  }

plugin_III\game_III\CDarkel.cpp:
   32  unsigned char CDarkel::CalcFade(unsigned int time, unsigned int min, unsigned int max) {
   33:     return plugin::CallAndReturnDynGlobal<unsigned char, unsigned int, unsigned int, unsigned int>(gaddrof(CDarkel::CalcFade), time, min, max);
   34  }

   46  bool CDarkel::FrenzyOnGoing() {
   47:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CDarkel::FrenzyOnGoing));
   48  }

   60  unsigned short CDarkel::QueryModelsKilledByPlayer(int modelId) {
   61:     return plugin::CallAndReturnDynGlobal<unsigned short, int>(gaddrof(CDarkel::QueryModelsKilledByPlayer), modelId);
   62  }

   67  eDarkelStatus CDarkel::ReadStatus() {
   68:     return plugin::CallAndReturnDynGlobal<eDarkelStatus>(gaddrof(CDarkel::ReadStatus));
   69  }

   74  void CDarkel::RegisterCarBlownUpByPlayer(CVehicle *vehicle) {
   75:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CDarkel::RegisterCarBlownUpByPlayer), vehicle);
   76  }

   81  void CDarkel::RegisterKillByPlayer(CPed *ped, eWeaponType weaponType, bool headShot) {
   82:     plugin::CallDynGlobal<CPed *, eWeaponType, bool>(gaddrof(CDarkel::RegisterKillByPlayer), ped, weaponType, headShot);
   83  }

   88  void CDarkel::RegisterKillNotByPlayer(CPed *ped, eWeaponType weaponType) {
   89:     plugin::CallDynGlobal<CPed *, eWeaponType>(gaddrof(CDarkel::RegisterKillNotByPlayer), ped, weaponType);
   90  }

  109  void CDarkel::StartFrenzy(eWeaponType weaponType, int time, unsigned short kill, int model, wchar_t *text, int model2, int model3, int model4, bool standardSound, bool headShot) {
  110:     plugin::CallDynGlobal<eWeaponType, int, unsigned short, int, wchar_t *, int, int, int, bool, bool>(gaddrof(CDarkel::StartFrenzy), weaponType, time, kill, model, text, model2, model3, model4, standardSound, headShot);
  111  }

plugin_III\game_III\CDigitalClock.cpp:
  17  void CDigitalClock::Init(CVector pos, float sizeX, float sizeY, unsigned char red, unsigned char green, unsigned char blue, float drawDistance, float scale) {
  18:     plugin::CallMethodDynGlobal<CDigitalClock *, CVector, float, float, unsigned char, unsigned char, unsigned char, float, float>(gaddrof(CDigitalClock::Init), this, pos, sizeX, sizeY, red, green, blue, drawDistance, scale);
  19  }

  24  void CDigitalClock::Render() {
  25:     plugin::CallMethodDynGlobal<CDigitalClock *>(gaddrof(CDigitalClock::Render), this);
  26  }

  31  void CDigitalClock::Update() {
  32:     plugin::CallMethodDynGlobal<CDigitalClock *>(gaddrof(CDigitalClock::Update), this);
  33  }

  38  char const *CDigitalClock::GetString() {
  39:     return plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CDigitalClock::GetString));
  40  }

plugin_III\game_III\CDirectory.cpp:
  20  void CDirectory::AddItem(CDirectory::DirectoryInfo const &entry) {
  21:     plugin::CallMethodDynGlobal<CDirectory *, CDirectory::DirectoryInfo const &>(gaddrof(CDirectory::AddItem), this, entry);
  22  }

  27  bool CDirectory::FindItem(char const *name, unsigned int &outOffset, unsigned int &outSize) {
  28:     return plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *, unsigned int &, unsigned int &>(gaddrof(CDirectory::FindItem), this, name, outOffset, outSize);
  29  }

  34  void CDirectory::ReadDirFile(char const *fileName) {
  35:     plugin::CallMethodDynGlobal<CDirectory *, char const *>(gaddrof(CDirectory::ReadDirFile), this, fileName);
  36  }

  41  bool CDirectory::WriteDirFile(char const *fileName) {
  42:     return plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *>(gaddrof(CDirectory::WriteDirFile), this, fileName);
  43  }

plugin_III\game_III\cDMAudio.cpp:
   19  void cDMAudio::ChangeMusicMode(unsigned char mode) {
   20:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::ChangeMusicMode), this, mode);
   21  }

   26  bool cDMAudio::CheckForAnAudioFileOnCD() {
   27:     return plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::CheckForAnAudioFileOnCD), this);
   28  }

   33  void cDMAudio::ClearMissionAudio() {
   34:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ClearMissionAudio), this);
   35  }

   40  int cDMAudio::CreateEntity(eAudioType type, void *data) {
   41:     return plugin::CallMethodAndReturnDynGlobal<int, cDMAudio *, eAudioType, void *>(gaddrof(cDMAudio::CreateEntity), this, type, data);
   42  }

   47  int cDMAudio::CreateLoopingScriptObject(cAudioScriptObject *object) {
   48:     return plugin::CallMethodAndReturnDynGlobal<int, cDMAudio *, cAudioScriptObject *>(gaddrof(cDMAudio::CreateLoopingScriptObject), this, object);
   49  }

   54  void cDMAudio::CreateOneShotScriptObject(cAudioScriptObject *object) {
   55:     plugin::CallMethodDynGlobal<cDMAudio *, cAudioScriptObject *>(gaddrof(cDMAudio::CreateOneShotScriptObject), this, object);
   56  }

   61  void cDMAudio::DestroyAllGameCreatedEntities() {
   62:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::DestroyAllGameCreatedEntities), this);
   63  }

   68  void cDMAudio::DestroyEntity(int audioEntity) {
   69:     plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::DestroyEntity), this, audioEntity);
   70  }

   75  void cDMAudio::DestroyLoopingScriptObject(int audioEntity) {
   76:     plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::DestroyLoopingScriptObject), this, audioEntity);
   77  }

   82  char *cDMAudio::Get3DProviderName(unsigned char id) {
   83:     return plugin::CallMethodAndReturnDynGlobal<char *, cDMAudio *, unsigned char>(gaddrof(cDMAudio::Get3DProviderName), this, id);
   84  }

   89  char cDMAudio::GetCDAudioDriveLetter() {
   90:     return plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *>(gaddrof(cDMAudio::GetCDAudioDriveLetter), this);
   91  }

   96  char cDMAudio::GetCurrent3DProviderIndex() {
   97:     return plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *>(gaddrof(cDMAudio::GetCurrent3DProviderIndex), this);
   98  }

  103  unsigned char cDMAudio::GetMissionAudioLoadingStatus() {
  104:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetMissionAudioLoadingStatus), this);
  105  }

  110  unsigned char cDMAudio::GetNum3DProvidersAvailable() {
  111:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetNum3DProvidersAvailable), this);
  112  }

  117  unsigned char cDMAudio::GetRadioInCar() {
  118:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetRadioInCar), this);
  119  }

  124  void cDMAudio::Initialise() {
  125:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Initialise), this);
  126  }

  131  bool cDMAudio::IsAudioInitialised() {
  132:     return plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsAudioInitialised), this);
  133  }

  138  bool cDMAudio::IsMP3RadioChannelAvailable() {
  139:     return plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsMP3RadioChannelAvailable), this);
  140  }

  145  bool cDMAudio::IsMissionAudioSampleFinished() {
  146:     return plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsMissionAudioSampleFinished), this);
  147  }

  152  void cDMAudio::PlayFrontEndSound(unsigned short frontend, unsigned int volume) {
  153:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned short, unsigned int>(gaddrof(cDMAudio::PlayFrontEndSound), this, frontend, volume);
  154  }

  159  void cDMAudio::PlayFrontEndTrack(unsigned char track, unsigned char frontendFlag) {
  160:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char, unsigned char>(gaddrof(cDMAudio::PlayFrontEndTrack), this, track, frontendFlag);
  161  }

  166  void cDMAudio::PlayLoadedMissionAudio() {
  167:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::PlayLoadedMissionAudio), this);
  168  }

  173  void cDMAudio::PlayOneShot(int audioEntity, unsigned short oneShot, float volume) {
  174:     plugin::CallMethodDynGlobal<cDMAudio *, int, unsigned short, float>(gaddrof(cDMAudio::PlayOneShot), this, audioEntity, oneShot, volume);
  175  }

  180  void cDMAudio::PlayPreloadedCutSceneMusic() {
  181:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::PlayPreloadedCutSceneMusic), this);
  182  }

  187  void cDMAudio::PlayRadioAnnouncement(unsigned char announcement) {
  188:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::PlayRadioAnnouncement), this, announcement);
  189  }

  194  void cDMAudio::PlaySuspectLastSeen(float x, float y, float z) {
  195:     plugin::CallMethodDynGlobal<cDMAudio *, float, float, float>(gaddrof(cDMAudio::PlaySuspectLastSeen), this, x, y, z);
  196  }

  201  void cDMAudio::PreloadCutSceneMusic(unsigned char track) {
  202:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::PreloadCutSceneMusic), this, track);
  203  }

  208  void cDMAudio::PreloadMissionAudio(char *name) {
  209:     plugin::CallMethodDynGlobal<cDMAudio *, char *>(gaddrof(cDMAudio::PreloadMissionAudio), this, name);
  210  }

  215  void cDMAudio::ReacquireDigitalHandle() {
  216:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ReacquireDigitalHandle), this);
  217  }

  222  void cDMAudio::ReleaseDigitalHandle() {
  223:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ReleaseDigitalHandle), this);
  224  }

  229  void cDMAudio::ReportCollision(CEntity *entityA, CEntity *entityB, unsigned char surfaceTypeA, unsigned char surfaceTypeB, float collisionPower, float velocity) {
  230:     plugin::CallMethodDynGlobal<cDMAudio *, CEntity *, CEntity *, unsigned char, unsigned char, float, float>(gaddrof(cDMAudio::ReportCollision), this, entityA, entityB, surfaceTypeA, surfaceTypeB, collisionPower, velocity);
  231  }

  236  void cDMAudio::ReportCrime(eCrimeType crime, CVector const &pos) {
  237:     plugin::CallMethodDynGlobal<cDMAudio *, eCrimeType, CVector const &>(gaddrof(cDMAudio::ReportCrime), this, crime, pos);
  238  }

  243  void cDMAudio::ResetTimers(unsigned int time) {
  244:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned int>(gaddrof(cDMAudio::ResetTimers), this, time);
  245  }

  250  void cDMAudio::Service() {
  251:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Service), this);
  252  }

  257  char cDMAudio::SetCurrent3DProvider(unsigned char which) {
  258:     return plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetCurrent3DProvider), this, which);
  259  }

  264  void cDMAudio::SetDynamicAcousticModelingStatus(unsigned char status) {
  265:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetDynamicAcousticModelingStatus), this, status);
  266  }

  271  void cDMAudio::SetEffectsFadeVol(unsigned char volume) {
  272:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetEffectsFadeVol), this, volume);
  273  }

  278  void cDMAudio::SetEffectsMasterVolume(unsigned char volume) {
  279:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetEffectsMasterVolume), this, volume);
  280  }

  285  void cDMAudio::SetEntityStatus(int audioEntity, unsigned char status) {
  286:     plugin::CallMethodDynGlobal<cDMAudio *, int, unsigned char>(gaddrof(cDMAudio::SetEntityStatus), this, audioEntity, status);
  287  }

  292  void cDMAudio::SetMissionAudioLocation(float x, float y, float z) {
  293:     plugin::CallMethodDynGlobal<cDMAudio *, float, float, float>(gaddrof(cDMAudio::SetMissionAudioLocation), this, x, y, z);
  294  }

  299  void cDMAudio::SetMusicFadeVol(unsigned char volume) {
  300:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetMusicFadeVol), this, volume);
  301  }

  306  void cDMAudio::SetMusicMasterVolume(unsigned char volume) {
  307:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetMusicMasterVolume), this, volume);
  308  }

  313  void cDMAudio::SetRadioChannel(unsigned char radio, int pos) {
  314:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned char, int>(gaddrof(cDMAudio::SetRadioChannel), this, radio, pos);
  315  }

  320  void cDMAudio::SetRadioInCar(unsigned int radio) {
  321:     plugin::CallMethodDynGlobal<cDMAudio *, unsigned int>(gaddrof(cDMAudio::SetRadioInCar), this, radio);
  322  }

  327  void cDMAudio::SetSpeakerConfig(int config) {
  328:     plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::SetSpeakerConfig), this, config);
  329  }

  334  void cDMAudio::StopCutSceneMusic() {
  335:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::StopCutSceneMusic), this);
  336  }

  341  void cDMAudio::StopFrontEndTrack() {
  342:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::StopFrontEndTrack), this);
  343  }

  348  void cDMAudio::Terminate() {
  349:     plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Terminate), this);
  350  }

plugin_III\game_III\CDoor.cpp:
  10  CDoor::CDoor() {
  11:     plugin::CallMethod<0x52D150, CDoor *>(this);
  12  }

  15  float CDoor::GetAngleOpenRatio() {
  16:     return plugin::CallMethodAndReturn<float, 0x545F80, CDoor *>(this);
  17  }

  20  bool CDoor::IsClosed() {
  21:     return plugin::CallMethodAndReturn<bool, 0x546060, CDoor *>(this);
  22  }

  25  bool CDoor::IsFullyOpen() {
  26:     return plugin::CallMethodAndReturn<bool, 0x546090, CDoor *>(this);
  27  }

  30  void CDoor::Open(float angle) {
  31:     plugin::CallMethod<0x545EF0, CDoor *, float>(this, angle);
  32  }

  35  void CDoor::Process(CVehicle* vehicle) {
  36:     plugin::CallMethod<0x545BD0, CDoor *, CVehicle*>(this, vehicle);
  37  }

  40  float CDoor::RetAngleWhenClosed() {
  41:     return plugin::CallMethodAndReturn<float, 0x545FE0, CDoor *>(this);
  42  }

  45  float CDoor::RetAngleWhenOpen() {
  46:     return plugin::CallMethodAndReturn<float, 0x546020, CDoor *>(this);
  47  }

plugin_III\game_III\CDraw.cpp:
  23  void CDraw::SetFOV(float fovValue) {
  24:     plugin::CallDynGlobal<float>(gaddrof(CDraw::SetFOV), fovValue);
  25  }

plugin_III\game_III\CDummy.cpp:
  29  void CDummy::Add() {
  30:     plugin::CallVirtualMethod<1, CDummy *>(this);
  31  }

  36  void CDummy::Remove() {
  37:     plugin::CallVirtualMethod<2, CDummy *>(this);
  38  }

plugin_III\game_III\CEmergencyPed.cpp:
  23  void CEmergencyPed::ProcessControl() {
  24:     plugin::CallVirtualMethod<8, CEmergencyPed *>(this);
  25  }

  30  void CEmergencyPed::FiremanAI() {
  31:     plugin::CallMethodDynGlobal<CEmergencyPed *>(gaddrof(CEmergencyPed::FiremanAI), this);
  32  }

  37  bool CEmergencyPed::InRange(CPed *victim) {
  38:     return plugin::CallMethodAndReturnDynGlobal<bool, CEmergencyPed *, CPed *>(gaddrof(CEmergencyPed::InRange), this, victim);
  39  }

  44  void CEmergencyPed::MedicAI() {
  45:     plugin::CallMethodDynGlobal<CEmergencyPed *>(gaddrof(CEmergencyPed::MedicAI), this);
  46  }

plugin_III\game_III\CEntity.cpp:
   23  void CEntity::Add() {
   24:     plugin::CallVirtualMethod<1, CEntity *>(this);
   25  }

   30  void CEntity::Remove() {
   31:     plugin::CallVirtualMethod<2, CEntity *>(this);
   32  }

   37  void CEntity::SetModelIndex(unsigned int modelIndex) {
   38:     plugin::CallVirtualMethod<3, CEntity *, unsigned int>(this, modelIndex);
   39  }

   44  void CEntity::SetModelIndexNoCreate(unsigned int modelIndex) {
   45:     plugin::CallVirtualMethod<4, CEntity *, unsigned int>(this, modelIndex);
   46  }

   51  void CEntity::CreateRwObject() {
   52:     plugin::CallVirtualMethod<5, CEntity *>(this);
   53  }

   58  void CEntity::DeleteRwObject() {
   59:     plugin::CallVirtualMethod<6, CEntity *>(this);
   60  }

   65  CRect *CEntity::GetBoundRect() {
   66:     return plugin::CallVirtualMethodAndReturn<CRect *, 7, CEntity *>(this);
   67  }

   72  void CEntity::ProcessControl() {
   73:     plugin::CallVirtualMethod<8, CEntity *>(this);
   74  }

   79  void CEntity::ProcessCollision() {
   80:     plugin::CallVirtualMethod<9, CEntity *>(this);
   81  }

   86  void CEntity::ProcessShift() {
   87:     plugin::CallVirtualMethod<10, CEntity *>(this);
   88  }

   93  void CEntity::Teleport(CVector point) {
   94:     plugin::CallVirtualMethod<11, CEntity *, CVector>(this, point);
   95  }

  100  void CEntity::PreRender() {
  101:     plugin::CallVirtualMethod<12, CEntity *>(this);
  102  }

  107  void CEntity::Render() {
  108:     plugin::CallVirtualMethod<13, CEntity *>(this);
  109  }

  114  bool CEntity::SetupLighting() {
  115:     return plugin::CallVirtualMethodAndReturn<bool, 14, CEntity *>(this);
  116  }

  121  void CEntity::RemoveLighting(bool resetWorldColors) {
  122:     plugin::CallVirtualMethod<15, CEntity *, bool>(this, resetWorldColors);
  123  }

  128  void CEntity::FlagToDestroyWhenNextProcessed() {
  129:     plugin::CallVirtualMethod<16, CEntity *>(this);
  130  }

  135  void CEntity::AddSteamsFromGround(CVector *unused) {
  136:     plugin::CallMethodDynGlobal<CEntity *, CVector *>(gaddrof(CEntity::AddSteamsFromGround), this, unused);
  137  }

  142  void CEntity::AttachToRwObject(RwObject *rwObject) {
  143:     plugin::CallMethodDynGlobal<CEntity *, RwObject *>(gaddrof(CEntity::AttachToRwObject), this, rwObject);
  144  }

  149  void CEntity::DetachFromRwObject() {
  150:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::DetachFromRwObject), this);
  151  }

  156  CVector *CEntity::GetBoundCentre() {
  157:     return plugin::CallMethodAndReturnDynGlobal<CVector *, CEntity *>(gaddrof_o(CEntity::GetBoundCentre, CVector *(CEntity::*)()), this);
  158  }

  163  void CEntity::GetBoundCentre(CVector &out) {
  164:     plugin::CallMethodDynGlobal<CEntity *, CVector &>(gaddrof_o(CEntity::GetBoundCentre, void (CEntity::*)(CVector &)), this, out);
  165  }

  170  float CEntity::GetBoundRadius() {
  171:     return plugin::CallMethodAndReturnDynGlobal<float, CEntity *>(gaddrof(CEntity::GetBoundRadius), this);
  172  }

  177  float CEntity::GetDistanceFromCentreOfMassToBaseOfModel() {
  178:     return plugin::CallMethodAndReturnDynGlobal<float, CEntity *>(gaddrof(CEntity::GetDistanceFromCentreOfMassToBaseOfModel), this);
  179  }

  184  bool CEntity::GetIsOnScreen() {
  185:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::GetIsOnScreen), this);
  186  }

  191  bool CEntity::GetIsOnScreenComplex() {
  192:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::GetIsOnScreenComplex), this);
  193  }

  198  bool CEntity::GetIsTouching(CVector const &posn, float radius) {
  199:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntity *, CVector const &, float>(gaddrof(CEntity::GetIsTouching), this, posn, radius);
  200  }

  205  bool CEntity::IsVisible() {
  206:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::IsVisible), this);
  207  }

  212  void CEntity::ModifyMatrixForBannerInWind() {
  213:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ModifyMatrixForBannerInWind), this);
  214  }

  219  void CEntity::ModifyMatrixForTreeInWind() {
  220:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ModifyMatrixForTreeInWind), this);
  221  }

  226  void CEntity::PreRenderForGlassWindow() {
  227:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::PreRenderForGlassWindow), this);
  228  }

  233  void CEntity::ProcessLightsForEntity() {
  234:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ProcessLightsForEntity), this);
  235  }

  240  void CEntity::PruneReferences() {
  241:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::PruneReferences), this);
  242  }

  247  void CEntity::RegisterReference(CEntity **entity) {
  248:     plugin::CallMethodDynGlobal<CEntity *, CEntity **>(gaddrof(CEntity::RegisterReference), this, entity);
  249  }

  254  void CEntity::ResolveReferences() {
  255:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ResolveReferences), this);
  256  }

  261  void CEntity::SetState(unsigned char state) {
  262:     plugin::CallMethodDynGlobal<CEntity *, unsigned char>(gaddrof(CEntity::SetState), this, state);
  263  }

  268  void CEntity::SetupBigBuilding() {
  269:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::SetupBigBuilding), this);
  270  }

  275  void CEntity::UpdateRwFrame() {
  276:     plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::UpdateRwFrame), this);
  277  }

plugin_III\game_III\CEventList.cpp:
  17  void CEventList::ClearEvent(int event) {
  18:     plugin::CallDynGlobal<int>(gaddrof(CEventList::ClearEvent), event);
  19  }

  24  bool CEventList::FindClosestEvent(eEventType type, CVector pos, int *event) {
  25:     return plugin::CallAndReturnDynGlobal<bool, eEventType, CVector, int *>(gaddrof(CEventList::FindClosestEvent), type, pos, event);
  26  }

  31  bool CEventList::GetEvent(eEventType type, int *event) {
  32:     return plugin::CallAndReturnDynGlobal<bool, eEventType, int *>(gaddrof(CEventList::GetEvent), type, event);
  33  }

  45  void CEventList::RegisterEvent(eEventType type, eEventEntity entityType, CEntity *entity, CPed *criminal, int time) {
  46:     plugin::CallDynGlobal<eEventType, eEventEntity, CEntity *, CPed *, int>(gaddrof_o(CEventList::RegisterEvent, void (*)(eEventType, eEventEntity, CEntity *, CPed *, int)), type, entityType, entity, criminal, time);
  47  }

  52  void CEventList::RegisterEvent(eEventType type, CVector pos, int time) {
  53:     plugin::CallDynGlobal<eEventType, CVector, int>(gaddrof_o(CEventList::RegisterEvent, void (*)(eEventType, CVector, int)), type, pos, time);
  54  }

  59  void CEventList::ReportCrimeForEvent(eEventType type, int crimeId, bool bPoliceDontReallyCare) {
  60:     plugin::CallDynGlobal<eEventType, int, bool>(gaddrof(CEventList::ReportCrimeForEvent), type, crimeId, bPoliceDontReallyCare);
  61  }

plugin_III\game_III\CExplosion.cpp:
  12  bool CExplosion::AddExplosion(CEntity* victim, CEntity* creator, eExplosionType explosionType, CVector const& posn, unsigned int time) {
  13:     return plugin::CallAndReturn<bool, 0x5591C0, CEntity*, CEntity*, eExplosionType, CVector const&, unsigned int>(victim, creator, explosionType, posn, time);
  14  }

  17  CExplosion::CExplosion() {
  18:     plugin::CallMethod<0x55ADE0, CExplosion *>(this);
  19  }

  22  unsigned char CExplosion::GetExplosionActiveCounter(unsigned char index) {
  23:     return plugin::CallAndReturn<unsigned char, 0x559140, unsigned char>(index);
  24  }

  27  CVector* CExplosion::GetExplosionPosition(unsigned char index) {
  28:     return plugin::CallAndReturn<CVector*, 0x5591A0, unsigned char>(index);
  29  }

  33      eExplosionType result;
  34:     plugin::CallAndReturn<eExplosionType, 0x559180, eExplosionType*, unsigned char>(&result, index);
  35      return result;

  39  void CExplosion::Initialise() {
  40:     plugin::Call<0x559030>();
  41  }

  44  void CExplosion::RemoveAllExplosionsInArea(CVector posn, float radius) {
  45:     plugin::Call<0x55AD40, CVector, float>(posn, radius);
  46  }

  49  void CExplosion::ResetExplosionActiveCounter(unsigned char index) {
  50:     plugin::Call<0x559160, unsigned char>(index);
  51  }

  54  void CExplosion::Shutdown() {
  55:     plugin::Call<0x559100>();
  56  }

  59  bool CExplosion::TestForExplosionInArea(eExplosionType explosionType, float x1, float y1, float z1, float x2, float y2, float z2) {
  60:     return plugin::CallAndReturn<bool, 0x55AC80, eExplosionType, float, float, float, float, float, float>(explosionType, x1, y1, z1, x2, y2, z2);
  61  }

  64  void CExplosion::Update() {
  65:     plugin::Call<0x55A0C0>();
  66  }

plugin_III\game_III\CFallingGlassPane.cpp:
  29  void CFallingGlassPane::Render() {
  30:     plugin::CallMethodDynGlobal<CFallingGlassPane *>(gaddrof(CFallingGlassPane::Render), this);
  31  }

  36  void CFallingGlassPane::Update() {
  37:     plugin::CallMethodDynGlobal<CFallingGlassPane *>(gaddrof(CFallingGlassPane::Update), this);
  38  }

plugin_III\game_III\CFileLoader.cpp:
   12  char* CFileLoader::LoadLine(int fileHandle) {
   13:     return plugin::CallAndReturn<char*, 0x4761D0, int>(fileHandle);
   14  }

   17  char* GetFilename(char const* filepath) {
   18:     return plugin::CallAndReturn<char*, 0x476230, char const*>(filepath);
   19  }

   22  void LoadingScreenLoadingFile(char const* filepath) {
   23:     plugin::Call<0x476250, char const*>(filepath);
   24  }

   27  void CFileLoader::LoadLevel(char const* datFilePath) {
   28:     plugin::Call<0x476290, char const*>(datFilePath);
   29  }

   32  void CFileLoader::LoadCollisionFromDatFile(unsigned int gameLevel) {
   33:     plugin::Call<0x476520, unsigned int>(gameLevel);
   34  }

   37  RwTexDictionary * CFileLoader::LoadTexDictionary(char const* filepath) {
   38:     return plugin::CallAndReturn<RwTexDictionary *, 0x4765B0, char const*>(filepath);
   39  }

   42  RwTexture* MoveTexturesCB(RwTexture* texture, void* data) {
   43:     return plugin::CallAndReturn<RwTexture*, 0x476610, RwTexture*, void*>(texture, data);
   44  }

   47  void CFileLoader::AddTexDictionaries(RwTexDictionary* dst, RwTexDictionary* src) {
   48:     plugin::Call<0x476630, RwTexDictionary*, RwTexDictionary*>(dst, src);
   49  }

   52  void GetNameAndLOD(char* nodeName, char* outName, unsigned int *outLodIndex) {
   53:     plugin::Call<0x476650, char*, char*, unsigned int *>(nodeName, outName, outLodIndex);
   54  }

   57  RpAtomic* CFileLoader::FindRelatedModelInfoCB(RpAtomic* atomic, void* data) {
   58:     return plugin::CallAndReturn<RpAtomic*, 0x4766C0, RpAtomic*, void*>(atomic, data);
   59  }

   62  void CFileLoader::LoadAtomicFile(char const* filepath) {
   63:     plugin::Call<0x476750, char const*>(filepath);
   64  }

   67  RpClump* CFileLoader::LoadAtomicFile2Return(char const* filepath) {
   68:     return plugin::CallAndReturn<RpClump*, 0x4767C0, char const*>(filepath);
   69  }

   72  void CFileLoader::LoadClumpFile(char const* filepath) {
   73:     plugin::Call<0x476810, char const*>(filepath);
   74  }

   77  RpAtomic* CFileLoader::SetRelatedModelInfoCB(RpAtomic* atomic, void* data) {
   78:     return plugin::CallAndReturn<RpAtomic*, 0x4768C0, RpAtomic*, void*>(atomic, data);
   79  }

   82  bool CFileLoader::LoadAtomicFile(RwStream* stream, unsigned int modelIndex) {
   83:     return plugin::CallAndReturn<bool, 0x476930, RwStream*, unsigned int>(stream, modelIndex);
   84  }

   87  bool CFileLoader::LoadClumpFile(RwStream* stream, unsigned int modelIndex) {
   88:     return plugin::CallAndReturn<bool, 0x476990, RwStream*, unsigned int>(stream, modelIndex);
   89  }

   92  bool CFileLoader::StartLoadClumpFile(RwStream* stream, unsigned int modelIndex) {
   93:     return plugin::CallAndReturn<bool, 0x476A20, RwStream*, unsigned int>(stream, modelIndex);
   94  }

   97  bool CFileLoader::FinishLoadClumpFile(RwStream* stream, unsigned int modelIndex) {
   98:     return plugin::CallAndReturn<bool, 0x476A70, RwStream*, unsigned int>(stream, modelIndex);
   99  }

  102  void CFileLoader::LoadObjectTypes(char const* filepath) {
  103:     plugin::Call<0x476AC0, char const*>(filepath);
  104  }

  107  void CFileLoader::ReloadPaths(char const* filepath) {
  108:     plugin::Call<0x476DB0, char const*>(filepath);
  109  }

  112  void CFileLoader::ReloadObjectTypes(char const* filepath) {
  113:     plugin::Call<0x476F30, char const*>(filepath);
  114  }

  117  void CFileLoader::LoadObject(char const* line) {
  118:     plugin::Call<0x477040, char const*>(line);
  119  }

  122  void CFileLoader::ReloadObject(char const* line) {
  123:     plugin::Call<0x4772B0, char const*>(line);
  124  }

  127  void CFileLoader::LoadTimeObject(char const* line) {
  128:     plugin::Call<0x4774B0, char const*>(line);
  129  }

  132  void CFileLoader::LoadMLO(char const* line) {
  133:     plugin::Call<0x477750, char const*>(line);
  134  }

  137  void CFileLoader::LoadMLOInstance(int modelIndex, char const* line) {
  138:     plugin::Call<0x4777C0, int, char const*>(modelIndex, line);
  139  }

  142  void CFileLoader::LoadClumpObject(char const* line) {
  143:     plugin::Call<0x477920, char const*>(line);
  144  }

  147  void CFileLoader::LoadVehicleObject(char const* line) {
  148:     plugin::Call<0x477990, char const*>(line);
  149  }

  152  void CFileLoader::LoadPedObject(char const* line) {
  153:     plugin::Call<0x477DE0, char const*>(line);
  154  }

  157  int CFileLoader::LoadPathHeader(char const* line, char* outPathType) {
  158:     return plugin::CallAndReturn<int, 0x477ED0, char const*, char*>(line, outPathType);
  159  }

  162  void CFileLoader::LoadPedPathNode(char const* line, int id, int index) {
  163:     plugin::Call<0x477F00, char const*, int, int>(line, id, index);
  164  }

  167  void CFileLoader::LoadCarPathNode(char const* line, int id, int index) {
  168:     plugin::Call<0x477FF0, char const*, int, int>(line, id, index);
  169  }

  172  void CFileLoader::Load2dEffect(char const* line) {
  173:     plugin::Call<0x4780E0, char const*>(line);
  174  }

  177  void CFileLoader::LoadScene(char const* filepath) {
  178:     plugin::Call<0x478370, char const*>(filepath);
  179  }

  182  void CFileLoader::LoadMapZones(char const* filepath) {
  183:     plugin::Call<0x478550, char const*>(filepath);
  184  }

  187  void CFileLoader::LoadObjectInstance(char const* line) {
  188:     plugin::Call<0x4786B0, char const*>(line);
  189  }

  192  void CFileLoader::LoadPickup(char const* line) {
  193:     plugin::Call<0x4789C0, char const*>(line);
  194  }

  197  void CFileLoader::LoadZone(char const* line) {
  198:     plugin::Call<0x478A00, char const*>(line);
  199  }

  202  void CFileLoader::LoadCullZone(char const* line) {
  203:     plugin::Call<0x478A90, char const*>(line);
  204  }

  207  void CFileLoader::LoadCollisionFile(char* filepath) {
  208:     plugin::Call<0x478B20, char*>(filepath);
  209  }

  212  void CFileLoader::LoadCollisionModel(unsigned char* buffer, CColModel& outColModel, char* name) {
  213:     plugin::Call<0x478C20, unsigned char*, CColModel&, char*>(buffer, outColModel, name);
  214  }

plugin_III\game_III\CFileMgr.cpp:
   17  void CFileMgr::ChangeDir(char const *dir) {
   18:     plugin::CallDynGlobal<char const *>(gaddrof(CFileMgr::ChangeDir), dir);
   19  }

   24  int CFileMgr::CloseFile(FILESTREAM fileHandle) {
   25:     return plugin::CallAndReturnDynGlobal<int, FILESTREAM>(gaddrof(CFileMgr::CloseFile), fileHandle);
   26  }

   31  int CFileMgr::GetErrorReadWrite(FILESTREAM fileHandle) {
   32:     return plugin::CallAndReturnDynGlobal<int, FILESTREAM>(gaddrof(CFileMgr::GetErrorReadWrite), fileHandle);
   33  }

   45  FILESTREAM CFileMgr::LoadTextFile(char const *filePath, unsigned char *buf, int size, char const *mode) {
   46:     return plugin::CallAndReturnDynGlobal<FILESTREAM, char const *, unsigned char *, int, char const *>(gaddrof(CFileMgr::LoadTextFile), filePath, buf, size, mode);
   47  }

   52  FILESTREAM CFileMgr::OpenFile(char const *filePath, char const *mode) {
   53:     return plugin::CallAndReturnDynGlobal<FILESTREAM, char const *, char const *>(gaddrof(CFileMgr::OpenFile), filePath, mode);
   54  }

   59  FILESTREAM CFileMgr::OpenFileForWriting(char const *filePath) {
   60:     return plugin::CallAndReturnDynGlobal<FILESTREAM, char const *>(gaddrof(CFileMgr::OpenFileForWriting), filePath);
   61  }

   66  int CFileMgr::Read(FILESTREAM fileHandle, char *buf, int size) {
   67:     return plugin::CallAndReturnDynGlobal<int, FILESTREAM, char *, int>(gaddrof(CFileMgr::Read), fileHandle, buf, size);
   68  }

   73  bool CFileMgr::ReadLine(FILESTREAM fileHandle, char *buf, int len) {
   74:     return plugin::CallAndReturnDynGlobal<bool, FILESTREAM, char *, int>(gaddrof(CFileMgr::ReadLine), fileHandle, buf, len);
   75  }

   80  bool CFileMgr::Seek(FILESTREAM fileHandle, int offset, int origin) {
   81:     return plugin::CallAndReturnDynGlobal<bool, FILESTREAM, int, int>(gaddrof(CFileMgr::Seek), fileHandle, offset, origin);
   82  }

   87  void CFileMgr::SetDir(char const *dir) {
   88:     plugin::CallDynGlobal<char const *>(gaddrof(CFileMgr::SetDir), dir);
   89  }

  101  int CFileMgr::Write(FILESTREAM fileHandle, char *buf, int size) {
  102:     return plugin::CallAndReturnDynGlobal<int, FILESTREAM, char *, int>(gaddrof(CFileMgr::Write), fileHandle, buf, size);
  103  }

plugin_III\game_III\CFire.cpp:
  20  void CFire::Extinguish() {
  21:     plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::Extinguish), this);
  22  }

  27  void CFire::ProcessFire() {
  28:     plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::ProcessFire), this);
  29  }

  34  void CFire::ReportThisFire() {
  35:     plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::ReportThisFire), this);
  36  }

plugin_III\game_III\CFireManager.cpp:
   22  void CFireManager::ExtinguishPoint(CVector point, float range) {
   23:     plugin::CallMethodDynGlobal<CFireManager *, CVector, float>(gaddrof(CFireManager::ExtinguishPoint), this, point, range);
   24  }

   29  CFire *CFireManager::FindFurthestFire_NeverMindFireMen(CVector pos, float minRange, float maxRange) {
   30:     return plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *, CVector, float, float>(gaddrof(CFireManager::FindFurthestFire_NeverMindFireMen), this, pos, minRange, maxRange);
   31  }

   36  CFire *CFireManager::FindNearestFire(CVector pos, float *pDistance) {
   37:     return plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *, CVector, float *>(gaddrof(CFireManager::FindNearestFire), this, pos, pDistance);
   38  }

   43  CFire *CFireManager::GetNextFreeFire() {
   44:     return plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *>(gaddrof(CFireManager::GetNextFreeFire), this);
   45  }

   50  bool CFireManager::IsScriptFireExtinguished(short fireIndex) {
   51:     return plugin::CallMethodAndReturnDynGlobal<bool, CFireManager *, short>(gaddrof(CFireManager::IsScriptFireExtinguished), this, fireIndex);
   52  }

   57  void CFireManager::RemoveAllScriptFires() {
   58:     plugin::CallMethodDynGlobal<CFireManager *>(gaddrof(CFireManager::RemoveAllScriptFires), this);
   59  }

   64  void CFireManager::RemoveScriptFire(short fireIndex) {
   65:     plugin::CallMethodDynGlobal<CFireManager *, short>(gaddrof(CFireManager::RemoveScriptFire), this, fireIndex);
   66  }

   71  void CFireManager::SetScriptFireAudio(short fireIndex, bool state) {
   72:     plugin::CallMethodDynGlobal<CFireManager *, short, bool>(gaddrof(CFireManager::SetScriptFireAudio), this, fireIndex, state);
   73  }

   78  void CFireManager::StartFire(CVector pos, float strength, unsigned char propagation) {
   79:     plugin::CallMethodDynGlobal<CFireManager *, CVector, float, unsigned char>(gaddrof_o(CFireManager::StartFire, void (CFireManager::*)(CVector, float, unsigned char)), this, pos, strength, propagation);
   80  }

   85  void CFireManager::StartFire(CEntity *entityOnFire, CEntity *fleeFrom, float strength, unsigned char propagation) {
   86:     plugin::CallMethodDynGlobal<CFireManager *, CEntity *, CEntity *, float, unsigned char>(gaddrof_o(CFireManager::StartFire, void (CFireManager::*)(CEntity *, CEntity *, float, unsigned char)), this, entityOnFire, fleeFrom, strength, propagation);
   87  }

   92  int CFireManager::StartScriptFire(CVector const &pos, CEntity *target, float strength, unsigned char propagation) {
   93:     return plugin::CallMethodAndReturnDynGlobal<int, CFireManager *, CVector const &, CEntity *, float, unsigned char>(gaddrof(CFireManager::StartScriptFire), this, pos, target, strength, propagation);
   94  }

   99  void CFireManager::Update() {
  100:     plugin::CallMethodDynGlobal<CFireManager *>(gaddrof(CFireManager::Update), this);
  101  }

plugin_III\game_III\CFont.cpp:
   17  void CFont::DrawFonts() {
   18:     plugin::Call<0x501B50>();
   19  }

   22  wchar_t* CFont::GetNextSpace(const wchar_t* str) {
   23:     return plugin::CallAndReturn<wchar_t*, 0x501960, const wchar_t*>(str);
   24  }

   27  int CFont::GetNumberLines(float x, float y, const wchar_t* text) {
   28:     return plugin::CallAndReturn<int, 0x501260, float, float, const wchar_t*>(x, y, text);
   29  }

   32  float CFont::GetStringWidth(const wchar_t* str, bool sentence) {
   33:     return plugin::CallAndReturn<float, 0x5018A0, const wchar_t*, bool>(str, sentence);
   34  }

   37  CRect* CFont::GetTextRect(CRect* rect_out, float x, float y, const wchar_t* text) {
   38:     return plugin::CallAndReturn<CRect*, 0x5013B0, CRect*, float, float, const wchar_t*>(rect_out, x, y, text);
   39  }

   42  void CFont::InitPerFrame() {
   43:     plugin::Call<0x500BE0>();
   44  }

   47  void CFont::Initialise() {
   48:     plugin::Call<0x500A40>();
   49  }

   52  wchar_t* CFont::ParseToken(wchar_t* str) {
   53:     return plugin::CallAndReturn<wchar_t*, 0x5019A0, wchar_t*>(str);
   54  }

   57  void CFont::PrintChar(float x, float y, short character) {
   58:     plugin::Call<0x500C30, float, float, short>(x, y, character);
   59  }

   62  void CFont::PrintString(float x, float y, const wchar_t* text) {
   63:     plugin::Call<0x500F50, float, float, const wchar_t*>(x, y, text);
   64  }

   67  void CFont::PrintString(float x, float y, const wchar_t* start, const wchar_t* end, float arg4) {
   68:     plugin::Call<0x501730, float, float, const wchar_t*, const wchar_t*, float>(x, y, start, end, arg4);
   69  }

   72  void CFont::SetAlphaFade(float alpha) {
   73:     plugin::Call<0x501DD0, float>(alpha);
   74  }

   77  void CFont::SetBackGroundOnlyTextOff() {
   78:     plugin::Call<0x501D40>();
   79  }

   82  void CFont::SetBackGroundOnlyTextOn() {
   83:     plugin::Call<0x501D30>();
   84  }

   87  void CFont::SetBackgroundColor(CRGBA color) {
   88:     plugin::Call<0x501D00, CRGBA*>(&color);
   89  }

   92  void CFont::SetBackgroundOff() {
   93:     plugin::Call<0x501CF0>();
   94  }

   97  void CFont::SetBackgroundOn() {
   98:     plugin::Call<0x501CE0>();
   99  }

  102  void CFont::SetCentreOff() {
  103:     plugin::Call<0x501CB0>();
  104  }

  107  void CFont::SetCentreOn() {
  108:     plugin::Call<0x501C90>();
  109  }

  112  void CFont::SetCentreSize(float size) {
  113:     plugin::Call<0x501CD0, float>(size);
  114  }

  117  void CFont::SetColor(CRGBA color) {
  118:     plugin::Call<0x501BD0, CRGBA*>(&color);
  119  }

  122  void CFont::SetDropColor(CRGBA color) {
  123:     plugin::Call<0x501DE0, CRGBA*>(&color);
  124  }

  127  void CFont::SetDropShadowPosition(short value) {
  128:     plugin::Call<0x501E70, short>(value);
  129  }

  132  void CFont::SetFontStyle(short style) {
  133:     plugin::Call<0x501DB0, short>(style);
  134  }

  137  void CFont::SetJustifyOff() {
  138:     plugin::Call<0x501C80>();
  139  }

  142  void CFont::SetJustifyOn() {
  143:     plugin::Call<0x501C60>();
  144  }

  147  void CFont::SetPropOff() {
  148:     plugin::Call<0x501D90>();
  149  }

  152  void CFont::SetPropOn() {
  153:     plugin::Call<0x501DA0>();
  154  }

  157  void CFont::SetRightJustifyOff() {
  158:     plugin::Call<0x501D70>();
  159  }

  162  void CFont::SetRightJustifyOn() {
  163:     plugin::Call<0x501D50>();
  164  }

  167  void CFont::SetRightJustifyWrap(float value) {
  168:     plugin::Call<0x501DC0, float>(value);
  169  }

  172  void CFont::SetScale(float width, float height) {
  173:     plugin::Call<0x501B80, float, float>(width, height);
  174  }

  177  void CFont::SetSlant(float value) {
  178:     plugin::Call<0x501BC0, float>(value);
  179  }

  182  void CFont::SetSlantRefPoint(float x, float y) {
  183:     plugin::Call<0x501BA0, float, float>(x, y);
  184  }

  187  void CFont::SetWrapx(float value) {
  188:     plugin::Call<0x501CC0, float>(value);
  189  }

  192  void CFont::Shutdown() {
  193:     plugin::Call<0x500BA0>();
  194  }

  197  short CFont::character_code(unsigned char character) {
  198:     return plugin::CallAndReturn<short, 0x501E80, unsigned char>(character);
  199  }

  243  void AsciiToUnicode(char const* str_ascii, wchar_t* str_unicode) {
  244:     plugin::Call<0x5009C0, char const*, wchar_t*>(str_ascii, str_unicode);
  245  }

  248  int UnicodeStrlen(wchar_t const* str) {
  249:     return plugin::CallAndReturn<int, 0x500A20, wchar_t const*>(str);
  250  }

plugin_III\game_III\CFontDetails.cpp:
  10  CFontDetails::~CFontDetails() {
  11:     plugin::CallMethod<0x501F10, CFontDetails *>(this);
  12  }

plugin_III\game_III\CGame.cpp:
   24  void CGame::DrasticTidyUpMemory(bool flushDraw) {
   25:     plugin::CallDynGlobal<bool>(gaddrof(CGame::DrasticTidyUpMemory), flushDraw);
   26  }

   38  bool CGame::Initialise(char const *datFile) {
   39:     return plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);
   40  }

   45  bool CGame::InitialiseOnceAfterRW() {
   46:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceAfterRW));
   47  }

   52  bool CGame::InitialiseOnceBeforeRW() {
   53:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));
   54  }

   59  bool CGame::InitialiseRenderWare() {
   60:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));
   61  }

  101  bool CGame::Shutdown() {
  102:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));
  103  }

  115  void CGame::TidyUpMemory(bool moveTextures, bool flushDraw) {
  116:     plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), moveTextures, flushDraw);
  117  }

plugin_III\game_III\CGameLogic.cpp:
  23  void CGameLogic::PassTime(unsigned int time) {
  24:     plugin::CallDynGlobal<unsigned int>(gaddrof(CGameLogic::PassTime), time);
  25  }

  30  void CGameLogic::RestorePlayerStuffDuringResurrection(CPlayerPed *player, CVector pos, float angle) {
  31:     plugin::CallDynGlobal<CPlayerPed *, CVector, float>(gaddrof(CGameLogic::RestorePlayerStuffDuringResurrection), player, pos, angle);
  32  }

  37  void CGameLogic::SortOutStreamingAndMemory(CVector const &pos) {
  38:     plugin::CallDynGlobal<CVector const &>(gaddrof(CGameLogic::SortOutStreamingAndMemory), pos);
  39  }

plugin_III\game_III\CGangs.cpp:
  16  char CGangs::GetGangPedModelOverride(short gang) {
  17:     return plugin::CallAndReturnDynGlobal<char, short>(gaddrof(CGangs::GetGangPedModelOverride), gang);
  18  }

  30  void CGangs::LoadAllGangData(unsigned char *buf, unsigned int size) {
  31:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CGangs::LoadAllGangData), buf, size);
  32  }

  37  void CGangs::SaveAllGangData(unsigned char *buf, unsigned int *size) {
  38:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CGangs::SaveAllGangData), buf, size);
  39  }

  44  void CGangs::SetGangPedModelOverride(short gang, char ovrd) {
  45:     plugin::CallDynGlobal<short, char>(gaddrof(CGangs::SetGangPedModelOverride), gang, ovrd);
  46  }

  51  void CGangs::SetGangVehicleModel(short gang, int model) {
  52:     plugin::CallDynGlobal<short, int>(gaddrof(CGangs::SetGangVehicleModel), gang, model);
  53  }

  58  void CGangs::SetGangWeapons(short gang, int weaponOne, int weaponTwo) {
  59:     plugin::CallDynGlobal<short, int, int>(gaddrof(CGangs::SetGangWeapons), gang, weaponOne, weaponTwo);
  60  }

plugin_III\game_III\CGarage.cpp:
   12  void CGarage::BuildRotatedDoorMatrix(CEntity* door, float angle) {
   13:     plugin::CallMethod<0x4267C0, CGarage *, CEntity*, float>(this, door, angle);
   14  }

   17  float CGarage::CalcDistToGarageRectangleSquared(float x, float y) {
   18:     return plugin::CallMethodAndReturn<float, 0x426F50, CGarage *, float, float>(this, x, y);
   19  }

   22  float CGarage::CalcSmallestDistToGarageDoorSquared(float x, float y) {
   23:     return plugin::CallMethodAndReturn<float, 0x426FE0, CGarage *, float, float>(this, x, y);
   24  }

   27  bool CGarage::CenterCarInGarage(CVehicle* vehicle) {
   28:     return plugin::CallMethodAndReturn<bool, 0x428000, CGarage *, CVehicle*>(this, vehicle);
   29  }

   33      eGarageState result;
   34:     plugin::CallMethodAndReturn<eGarageState, 0x426F40, CGarage *, eGarageState*>(this, &result);
   35      return result;

   39  int CGarage::CountCarsWithCenterPointWithinGarage(CEntity* vehicle) {
   40:     return plugin::CallMethodAndReturn<int, 0x426130, CGarage *, CEntity*>(this, vehicle);
   41  }

   44  bool CGarage::DoesCraigNeedThisCar(int modelIndex) {
   45:     return plugin::CallMethodAndReturn<bool, 0x426D90, CGarage *, int>(this, modelIndex);
   46  }

   49  bool CGarage::EntityHasASphereWayOutsideGarage(CEntity* entity, float radius) {
   50:     return plugin::CallMethodAndReturn<bool, 0x425B30, CGarage *, CEntity*, float>(this, entity, radius);
   51  }

   54  void CGarage::FindDoorsEntities() {
   55:     plugin::CallMethod<0x427060, CGarage *>(this);
   56  }

   59  char CGarage::FindDoorsEntitiesSectorList(CPtrList& list, bool arg1) {
   60:     return plugin::CallMethodAndReturn<char, 0x427300, CGarage *, CPtrList&, bool>(this, list, arg1);
   61  }

   64  bool CGarage::HasCraigCollectedThisCar(int modelIndex) {
   65:     return plugin::CallMethodAndReturn<bool, 0x426DF0, CGarage *, int>(this, modelIndex);
   66  }

   69  bool CGarage::IsAnyCarBlockingDoor() {
   70:     return plugin::CallMethodAndReturn<bool, 0x425FB0, CGarage *>(this);
   71  }

   74  bool CGarage::IsAnyOtherCarTouchingGarage(CVehicle* vehicle) {
   75:     return plugin::CallMethodAndReturn<bool, 0x425C90, CGarage *, CVehicle*>(this, vehicle);
   76  }

   79  bool CGarage::IsAnyOtherPedTouchingGarage(CPed* ped) {
   80:     return plugin::CallMethodAndReturn<bool, 0x425E20, CGarage *, CPed*>(this, ped);
   81  }

   84  bool CGarage::IsEntityEntirelyInside(CEntity* entity) {
   85:     return plugin::CallMethodAndReturn<bool, 0x425370, CGarage *, CEntity*>(this, entity);
   86  }

   89  bool CGarage::IsEntityEntirelyInside3D(CEntity* entity, float radius) {
   90:     return plugin::CallMethodAndReturn<bool, 0x4254F0, CGarage *, CEntity*, float>(this, entity, radius);
   91  }

   94  bool CGarage::IsEntityEntirelyOutside(CEntity* entity, float radius) {
   95:     return plugin::CallMethodAndReturn<bool, 0x425740, CGarage *, CEntity*, float>(this, entity, radius);
   96  }

   99  bool CGarage::IsEntityTouching3D(CEntity* entity) {
  100:     return plugin::CallMethodAndReturn<bool, 0x425950, CGarage *, CEntity*>(this, entity);
  101  }

  104  bool CGarage::IsGarageEmpty() {
  105:     return plugin::CallMethodAndReturn<bool, 0x425890, CGarage *>(this);
  106  }

  109  bool CGarage::IsPlayerOutsideGarage() {
  110:     return plugin::CallMethodAndReturn<bool, 0x425910, CGarage *>(this);
  111  }

  114  bool CGarage::IsStaticPlayerCarEntirelyInside() {
  115:     return plugin::CallMethodAndReturn<bool, 0x4251C0, CGarage *>(this);
  116  }

  119  void CGarage::Load(unsigned char* bufferPointer, unsigned int structSize) {
  120:     plugin::CallMethod<0x4288E0, CGarage *, unsigned char*, unsigned int>(this, bufferPointer, structSize);
  121  }

  124  bool CGarage::MarkThisCarAsCollectedForCraig(int modelIndex) {
  125:     return plugin::CallMethodAndReturn<bool, 0x426E50, CGarage *, int>(this, modelIndex);
  126  }

  130      eGarageState result;
  131:     plugin::CallMethodAndReturn<eGarageState, 0x426F20, CGarage *, eGarageState*>(this, &result);
  132      return result;

  136  void CGarage::PlayerArrestedOrDied() {
  137:     plugin::CallMethod<0x427FC0, CGarage *>(this);
  138  }

  141  void CGarage::RefreshDoorPointers(bool arg0) {
  142:     plugin::CallMethod<0x426980, CGarage *, bool>(this, arg0);
  143  }

  146  void CGarage::RemoveCarsBlockingDoorNotInside() {
  147:     plugin::CallMethod<0x4261F0, CGarage *>(this);
  148  }

  151  bool CGarage::RestoreCarsForThisHideOut(CStoredCar* car) {
  152:     return plugin::CallMethodAndReturn<bool, 0x427A40, CGarage *, CStoredCar*>(this, car);
  153  }

  156  void CGarage::StoreAndRemoveCarsForThisHideOut(CStoredCar* car, int count) {
  157:     plugin::CallMethod<0x427840, CGarage *, CStoredCar*, int>(this, car, count);
  158  }

  161  void CGarage::TidyUpGarage() {
  162:     plugin::CallMethod<0x427C30, CGarage *>(this);
  163  }

  166  void CGarage::TidyUpGarageClose() {
  167:     plugin::CallMethod<0x427D90, CGarage *>(this);
  168  }

  171  void CGarage::Update() {
  172:     plugin::CallMethod<0x4222D0, CGarage *>(this);
  173  }

  176  void CGarage::UpdateCrusherAngle() {
  177:     plugin::CallMethod<0x4268A0, CGarage *>(this);
  178  }

  181  void CGarage::UpdateCrusherShake(float x, float y) {
  182:     plugin::CallMethod<0x4268E0, CGarage *, float, float>(this, x, y);
  183  }

  186  void CGarage::UpdateDoorsHeight() {
  187:     plugin::CallMethod<0x426730, CGarage *>(this);
  188  }

plugin_III\game_III\CGarages.cpp:
   34  void CGarages::ActivateGarage(short index) {
   35:     plugin::Call<0x426C60, short>(index);
   36  }

   39  int CGarages::AddOne(CVector pointFront, CVector pointBack, unsigned char type, unsigned int vehicleModelIndex) {
   40:     return plugin::CallAndReturn<int, 0x421FA0, CVector, CVector, unsigned char, unsigned int>(pointFront, pointBack, type, vehicleModelIndex);
   41  }

   44  bool CGarages::CameraShouldBeOutside() {
   45:     return plugin::CallAndReturn<bool, 0x427BC0>();
   46  }

   49  void CGarages::ChangeGarageType(short index, unsigned char type, unsigned int vehicleModelIndex) {
   50:     plugin::Call<0x4222A0, short, unsigned char, unsigned int>(index, type, vehicleModelIndex);
   51  }

   54  void CGarages::CloseHideOutGaragesBeforeSave() {
   55:     plugin::Call<0x428130>();
   56  }

   59  int CGarages::CountCarsInHideoutGarage(unsigned char type) {
   60:     return plugin::CallAndReturn<int, 0x4281E0, unsigned char>(type);
   61  }

   64  void CGarages::DeActivateGarage(short index) {
   65:     plugin::Call<0x426C40, short>(index);
   66  }

   69  float CGarages::FindDoorHeightForMI(unsigned int vehicleModelIndex) {
   70:     return plugin::CallAndReturn<float, 0x427C10, unsigned int>(vehicleModelIndex);
   71  }

   74  int CGarages::FindMaxNumStoredCarsForGarage(unsigned char type) {
   75:     return plugin::CallAndReturn<int, 0x428230, unsigned char>(type);
   76  }

   79  void CGarages::GivePlayerDetonator() {
   80:     plugin::Call<0x427BD0>();
   81  }

   84  bool CGarages::HasCarBeenCrushed(int vehicleModelIndex) {
   85:     return plugin::CallAndReturn<bool, 0x4275A0, int>(vehicleModelIndex);
   86  }

   89  bool CGarages::HasCarBeenDroppedOffYet(short index) {
   90:     return plugin::CallAndReturn<bool, 0x426C20, short>(index);
   91  }

   94  bool CGarages::HasImportExportGarageCollectedThisCar(short index, int vehicleModelIndex) {
   95:     return plugin::CallAndReturn<bool, 0x426CB0, short, int>(index, vehicleModelIndex);
   96  }

   99  bool CGarages::HasResprayHappened(short index) {
  100:     return plugin::CallAndReturn<bool, 0x4274F0, short>(index);
  101  }

  104  bool CGarages::HasThisCarBeenCollected(short index, int vehicleModelIndex) {
  105:     return plugin::CallAndReturn<bool, 0x426D50, short, int>(index, vehicleModelIndex);
  106  }

  109  void CGarages::Init() {
  110:     plugin::Call<0x421C60>();
  111  }

  114  bool CGarages::IsCarSprayable(CAutomobile* car) {
  115:     return plugin::CallAndReturn<bool, 0x426700, CAutomobile*>(car);
  116  }

  119  bool CGarages::IsGarageClosed(short index) {
  120:     return plugin::CallAndReturn<bool, 0x426D20, short>(index);
  121  }

  124  bool CGarages::IsGarageOpen(short index) {
  125:     return plugin::CallAndReturn<bool, 0x426CF0, short>(index);
  126  }

  129  bool CGarages::IsModelIndexADoor(unsigned int modelIndexDoor) {
  130:     return plugin::CallAndReturn<bool, 0x428D90, unsigned int>(modelIndexDoor);
  131  }

  134  bool CGarages::IsPointInAGarageCameraZone(CVector point) {
  135:     return plugin::CallAndReturn<bool, 0x427AB0, CVector>(point);
  136  }

  139  bool CGarages::IsPointWithinAnyGarage(CVector& point) {
  140:     return plugin::CallAndReturn<bool, 0x428320, CVector&>(point);
  141  }

  144  bool CGarages::IsPointWithinHideOutGarage(CVector& point) {
  145:     return plugin::CallAndReturn<bool, 0x428260, CVector&>(point);
  146  }

  149  bool CGarages::IsThisCarWithinGarageArea(short index, CEntity* entity) {
  150:     return plugin::CallAndReturn<bool, 0x427570, short, CEntity*>(index, entity);
  151  }

  154  void CGarages::Load(unsigned char* bufferPointer, unsigned int structSize) {
  155:     plugin::Call<0x428940, unsigned char*, unsigned int>(bufferPointer, structSize);
  156  }

  159  void CGarages::PlayerArrestedOrDied() {
  160:     plugin::Call<0x427F60>();
  161  }

  164  void CGarages::PrintMessages() {
  165:     plugin::Call<0x426310>();
  166  }

  169  int CGarages::QueryCarsCollected(short index) {
  170:     return plugin::CallAndReturn<int, 0x426CA0, short>(index);
  171  }

  174  void CGarages::Save(unsigned char* bufferPointer, unsigned int* structSize) {
  175:     plugin::Call<0x4284E0, unsigned char*, unsigned int*>(bufferPointer, structSize);
  176  }

  179  void CGarages::SetAllDoorsBackToOriginalHeight() {
  180:     plugin::Call<0x4283D0>();
  181  }

  184  void CGarages::SetGarageDoorToRotate(short index) {
  185:     plugin::Call<0x427510, short>(index);
  186  }

  189  void CGarages::SetLeaveCameraForThisGarage(short index) {
  190:     plugin::Call<0x427550, short>(index);
  191  }

  194  void CGarages::SetTargetCarForMissionGarage(short index, CAutomobile* car) {
  195:     plugin::Call<0x426BD0, short, CAutomobile*>(index, car);
  196  }

  199  void CGarages::Shutdown() {
  200:     plugin::Call<0x421E10>();
  201  }

  204  void CGarages::TriggerMessage(char* text, short numberInString, unsigned short time, short numberInString2) {
  205:     plugin::Call<0x426B20, char*, short, unsigned short, short>(text, numberInString, time, numberInString2);
  206  }

  209  void CGarages::Update() {
  210:     plugin::Call<0x421E40>();
  211  }

plugin_III\game_III\CGeneral.cpp:
  14  float CGeneral::GetATanOfXY(float x, float y) {
  15:     return plugin::CallAndReturnDynGlobal<float, float, float>(gaddrof(CGeneral::GetATanOfXY), x, y);
  16  }

  21  float CGeneral::GetAngleBetweenPoints(float x1, float y1, float x2, float y2) {
  22:     return plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetAngleBetweenPoints), x1, y1, x2, y2);
  23  }

  28  int CGeneral::GetNodeHeadingFromVector(float x, float y) {
  29:     return plugin::CallAndReturnDynGlobal<int, float, float>(gaddrof(CGeneral::GetNodeHeadingFromVector), x, y);
  30  }

  35  float CGeneral::GetRadianAngleBetweenPoints(float x1, float y1, float x2, float y2) {
  36:     return plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetRadianAngleBetweenPoints), x1, y1, x2, y2);
  37  }

  42  float CGeneral::LimitAngle(float angle) {
  43:     return plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitAngle), angle);
  44  }

  49  float CGeneral::LimitRadianAngle(float angle) {
  50:     return plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitRadianAngle), angle);
  51  }

plugin_III\game_III\CGlass.cpp:
   18  void CGlass::AskForObjectToBeRenderedInGlass(CEntity *entity) {
   19:     plugin::CallDynGlobal<CEntity *>(gaddrof(CGlass::AskForObjectToBeRenderedInGlass), entity);
   20  }

   25  int CGlass::CalcAlphaWithNormal(CVector *normal) {
   26:     return plugin::CallAndReturnDynGlobal<int, CVector *>(gaddrof(CGlass::CalcAlphaWithNormal), normal);
   27  }

   32  CFallingGlassPane *CGlass::FindFreePane() {
   33:     return plugin::CallAndReturnDynGlobal<CFallingGlassPane *>(gaddrof(CGlass::FindFreePane));
   34  }

   39  void CGlass::GeneratePanesForWindow(unsigned int type, CVector pos, CVector at, CVector right, CVector speed, CVector point, float moveSpeed, bool cracked, bool explosion) {
   40:     plugin::CallDynGlobal<unsigned int, CVector, CVector, CVector, CVector, CVector, float, bool, bool>(gaddrof(CGlass::GeneratePanesForWindow), type, pos, at, right, speed, point, moveSpeed, cracked, explosion);
   41  }

   60  void CGlass::RenderEntityInGlass(CEntity *entity) {
   61:     plugin::CallDynGlobal<CEntity *>(gaddrof(CGlass::RenderEntityInGlass), entity);
   62  }

   95  void CGlass::WasGlassHitByBullet(CEntity *entity, CVector point) {
   96:     plugin::CallDynGlobal<CEntity *, CVector>(gaddrof(CGlass::WasGlassHitByBullet), entity, point);
   97  }

  102  void CGlass::WindowRespondsToCollision(CEntity *entity, float amount, CVector speed, CVector point, bool explosion) {
  103:     plugin::CallDynGlobal<CEntity *, float, CVector, CVector, bool>(gaddrof(CGlass::WindowRespondsToCollision), entity, amount, speed, point, explosion);
  104  }

  109  void CGlass::WindowRespondsToExplosion(CEntity *entity, CVector point) {
  110:     plugin::CallDynGlobal<CEntity *, CVector>(gaddrof(CGlass::WindowRespondsToExplosion), entity, point);
  111  }

  116  void CGlass::WindowRespondsToSoftCollision(CEntity *entity, float amount) {
  117:     plugin::CallDynGlobal<CEntity *, float>(gaddrof(CGlass::WindowRespondsToSoftCollision), entity, amount);
  118  }

plugin_III\game_III\CHeli.cpp:
   44  void CHeli::SetModelIndex(unsigned int modelIndex) {
   45:     plugin::CallVirtualMethod<3, CHeli *, unsigned int>(this, modelIndex);
   46  }

   51  void CHeli::ProcessControl() {
   52:     plugin::CallVirtualMethod<8, CHeli *>(this);
   53  }

   58  void CHeli::PreRender() {
   59:     plugin::CallVirtualMethod<12, CHeli *>(this);
   60  }

   65  void CHeli::Render() {
   66:     plugin::CallVirtualMethod<13, CHeli *>(this);
   67  }

   72  void CHeli::PreRenderAlways() {
   73:     plugin::CallMethodDynGlobal<CHeli *>(gaddrof(CHeli::PreRenderAlways), this);
   74  }

   79  CObject *CHeli::SpawnFlyingComponent(int component) {
   80:     return plugin::CallMethodAndReturnDynGlobal<CObject *, CHeli *, int>(gaddrof(CHeli::SpawnFlyingComponent), this, component);
   81  }

   86  void CHeli::ActivateHeli(bool activate) {
   87:     plugin::CallDynGlobal<bool>(gaddrof(CHeli::ActivateHeli), activate);
   88  }

  100  CHeli *CHeli::FindPointerToCatalinasHeli() {
  101:     return plugin::CallAndReturnDynGlobal<CHeli *>(gaddrof(CHeli::FindPointerToCatalinasHeli));
  102  }

  107  bool CHeli::HasCatalinaBeenShotDown() {
  108:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CHeli::HasCatalinaBeenShotDown));
  109  }

  142  bool CHeli::TestBulletCollision(CVector *lineStart, CVector *lineEnd, CVector *bulletPos, int damage) {
  143:     return plugin::CallAndReturnDynGlobal<bool, CVector *, CVector *, CVector *, int>(gaddrof(CHeli::TestBulletCollision), lineStart, lineEnd, bulletPos, damage);
  144  }

  149  bool CHeli::TestRocketCollision(CVector *coors) {
  150:     return plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CHeli::TestRocketCollision), coors);
  151  }

  163  CHeli *GenerateHeli(bool catalina) {
  164:     return plugin::CallAndReturnDynGlobal<CHeli *, bool>(gaddrof(GenerateHeli), catalina);
  165  }

  177  RwObject *GetHeliAtomicObjectCB(RwObject *object, void *data) {
  178:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetHeliAtomicObjectCB), object, data);
  179  }

plugin_III\game_III\CHud.cpp:
   55  void CHud::Draw() {
   56: 	plugin::Call<0x5052A0>();
   57  }

   59  void CHud::DrawAfterFade() {
   60: 	plugin::Call<0x509030>();
   61  }

   63  void CHud::GetRidOfAllHudMessages() {
   64: 	plugin::Call<0x504F90>();
   65  }

   67  void CHud::Initialise() {
   68: 	plugin::Call<0x5048F0>();
   69  }

   71  void CHud::ReInitialise() {
   72: 	plugin::Call<0x504CC0>();
   73  }

   75  void CHud::SetBigMessage(wchar_t *message, char style) {
   76: 	plugin::Call<0x50A250, wchar_t *, char>(message, style);
   77  }

   79  void CHud::SetHelpMessage(wchar_t *message, bool quick) {
   80: 	plugin::Call<0x5051E0, wchar_t *, bool>(message, quick);
   81  }

   83  void CHud::SetMessage(wchar_t *message) {
   84: 	plugin::Call<0x50A210, wchar_t *>(message);
   85  }

   87  void CHud::SetPagerMessage(wchar_t *message) {
   88: 	plugin::Call<0x50A320, wchar_t *>(message);
   89  }

   91  void CHud::SetVehicleName(wchar_t *name) {
   92: 	plugin::Call<0x505290, wchar_t *>(name);
   93  }

   95  void CHud::SetZoneName(wchar_t *name) {
   96: 	plugin::Call<0x5051D0, wchar_t *>(name);
   97  }

   99  void CHud::Shutdown() {
  100: 	plugin::Call<0x504C50>();
  101  }

plugin_III\game_III\CInstance.cpp:
  23  void CInstance::Shutdown() {
  24:     plugin::CallMethodDynGlobal<CInstance *>(gaddrof(CInstance::Shutdown), this);
  25  }

plugin_III\game_III\CKeyboardState.cpp:
  10  void CKeyboardState::Clear() {
  11:     plugin::CallMethod<0x491760, CKeyboardState *>(this);
  12  }

plugin_III\game_III\CLines.cpp:
  14  void CLines::RenderLineWithClipping(float x1, float y1, float z1, float x2, float y2, float z2, unsigned int color1, unsigned int color2) {
  15:     plugin::CallDynGlobal<float, float, float, float, float, float, unsigned int, unsigned int>(gaddrof(CLines::RenderLineWithClipping), x1, y1, z1, x2, y2, z2, color1, color2);
  16  }

plugin_III\game_III\CMatrix.cpp:
   14  CMatrix::CMatrix() {
   15:     plugin::CallMethodDynGlobal<CMatrix *>(ctor_gaddr(CMatrix), this);
   16  }

   21  CMatrix::CMatrix(RwMatrix *rwMatrix, bool deleteOnDetach) {
   22:     plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(ctor_gaddr_o(CMatrix, void(RwMatrix *, bool)), this, rwMatrix, deleteOnDetach);
   23  }

   28  CMatrix::CMatrix(CMatrix const &matrix) {
   29:     plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(ctor_gaddr_o(CMatrix, void(CMatrix const &)), this, matrix);
   30  }

   35  CMatrix::~CMatrix() {
   36:     plugin::CallMethodDynGlobal<CMatrix *>(dtor_gaddr(CMatrix), this);
   37  }

   42  void CMatrix::operator+=(CMatrix const &right) {
   43:     plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof_o(CMatrix::operator+=, void (CMatrix::*)(CMatrix const &)), this, right);
   44  }

   49  void CMatrix::operator=(CMatrix const &right) {
   50:     plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof_o(CMatrix::operator=, void (CMatrix::*)(CMatrix const &)), this, right);
   51  }

   56  void CMatrix::Attach(RwMatrix *rwMatrix, bool deleteOnDetach) {
   57:     plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(gaddrof(CMatrix::Attach), this, rwMatrix, deleteOnDetach);
   58  }

   63  void CMatrix::AttachRW(RwMatrix *rwMatrix, bool deleteOnDetach) {
   64:     plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(gaddrof(CMatrix::AttachRW), this, rwMatrix, deleteOnDetach);
   65  }

   70  void CMatrix::CopyOnlyMatrix(CMatrix const &matrix) {
   71:     plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof(CMatrix::CopyOnlyMatrix), this, matrix);
   72  }

   77  void CMatrix::Detach() {
   78:     plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Detach), this);
   79  }

   84  void CMatrix::Reorthogonalise() {
   85:     plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Reorthogonalise), this);
   86  }

   91  void CMatrix::ResetOrientation() {
   92:     plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::ResetOrientation), this);
   93  }

   98  void CMatrix::Rotate(float x, float y, float z) {
   99:     plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::Rotate), this, x, y, z);
  100  }

  105  void CMatrix::RotateX(float angle) {
  106:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::RotateX), this, angle);
  107  }

  112  void CMatrix::RotateZ(float angle) {
  113:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::RotateZ), this, angle);
  114  }

  119  void CMatrix::SetRotate(float x, float y, float z) {
  120:     plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::SetRotate), this, x, y, z);
  121  }

  126  void CMatrix::SetRotateX(float angle) {
  127:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateX), this, angle);
  128  }

  133  void CMatrix::SetRotateXOnly(float angle) {
  134:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateXOnly), this, angle);
  135  }

  140  void CMatrix::SetRotateY(float angle) {
  141:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateY), this, angle);
  142  }

  147  void CMatrix::SetRotateYOnly(float angle) {
  148:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateYOnly), this, angle);
  149  }

  154  void CMatrix::SetRotateZ(float angle) {
  155:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateZ), this, angle);
  156  }

  161  void CMatrix::SetRotateZOnly(float angle) {
  162:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateZOnly), this, angle);
  163  }

  168  void CMatrix::SetScale(float factor) {
  169:     plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetScale), this, factor);
  170  }

  175  void CMatrix::SetTranslate(float x, float y, float z) {
  176:     plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof_o(CMatrix::SetTranslate, void (CMatrix::*)(float, float, float)), this, x, y, z);
  177  }

  182  void CMatrix::SetTranslate(CVector *pos) {
  183:     plugin::CallMethodDynGlobal<CMatrix *, CVector *>(gaddrof_o(CMatrix::SetTranslate, void (CMatrix::*)(CVector *)), this, pos);
  184  }

  189  void CMatrix::SetTranslateOnly(float x, float y, float z) {
  190:     plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::SetTranslateOnly), this, x, y, z);
  191  }

  196  void CMatrix::SetUnity() {
  197:     plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::SetUnity), this);
  198  }

  203  void CMatrix::Update() {
  204:     plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Update), this);
  205  }

  210  void CMatrix::UpdateRW() {
  211:     plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::UpdateRW), this);
  212  }

plugin_III\game_III\CMBlur.cpp:
  21  void CMBlur::CreateImmediateModeData(RwCamera *cam, RwRect *rect) {
  22:     plugin::CallDynGlobal<RwCamera *, RwRect *>(gaddrof(CMBlur::CreateImmediateModeData), cam, rect);
  23  }

  28  RwBool CMBlur::MotionBlurClose() {
  29:     return plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(CMBlur::MotionBlurClose));
  30  }

  35  RwBool CMBlur::MotionBlurOpen(RwCamera *cam) {
  36:     return plugin::CallAndReturnDynGlobal<RwBool, RwCamera *>(gaddrof(CMBlur::MotionBlurOpen), cam);
  37  }

  42  void CMBlur::MotionBlurRender(RwCamera *cam, unsigned int red, unsigned int green, unsigned int blue, unsigned int blur, int type, unsigned int blurAlpha) {
  43:     plugin::CallDynGlobal<RwCamera *, unsigned int, unsigned int, unsigned int, unsigned int, int, unsigned int>(gaddrof(CMBlur::MotionBlurRender), cam, red, green, blue, blur, type, blurAlpha);
  44  }

  49  void CMBlur::OverlayRender(RwCamera *cam, RwRaster *raster, RwRGBA color, int type, int blurAlpha) {
  50:     plugin::CallDynGlobal<RwCamera *, RwRaster *, RwRGBA, int, int>(gaddrof(CMBlur::OverlayRender), cam, raster, color, type, blurAlpha);
  51  }

plugin_III\game_III\CMenuManager.cpp:
   36  void CMenuManager::BuildStatLine(char *text, float *stat, bool aFloat, float* stat2) {
   37: 	plugin::CallMethod<0x483870, CMenuManager *, char *, float *, bool, float*>(this, text, stat, aFloat, stat2);
   38  }

   40  void CMenuManager::CentreMousePointer() {
   41: 	plugin::Call<0x48ACE0>();
   42  }

   44  int CMenuManager::CheckCodesForControls(int type) {
   45: 	return plugin::CallMethodAndReturn<int, 0x483870, CMenuManager *, int>(this, type);
   46  }

   48  bool CMenuManager::CheckHover(int x1, int x2, int y1, int y2) {
   49: 	return plugin::CallMethodAndReturn<bool, 0x48ACA0, CMenuManager *, int, int, int, int>(this, x1, x2, y1, y2);
   50  }

   52  void CMenuManager::CheckSliderMovement(int direction) {
   53: 	plugin::CallMethod<0x48B210, CMenuManager *, int>(this, direction);
   54  }

   56  int CMenuManager::CostructStatLine(int line) {
   57: 	return plugin::CallMethodAndReturn<int, 0x482800, CMenuManager *, int>(this, line);
   58  }

   60  void CMenuManager::DisplayHelperText() {
   61: 	plugin::CallMethod<0x48B490, CMenuManager *>(this);
   62  }

   64  float CMenuManager::DisplaySlider(float, float, float, float, float, float) {
   65: 	return plugin::CallMethodAndReturn<float, 0x00, CMenuManager *>(this);
   66  }

   68  void CMenuManager::DoSettingsBeforeStartingAGame() {
   69: 	plugin::CallMethod<0x48AB40, CMenuManager *>(this);
   70  }

   72  void CMenuManager::Draw() {
   73: 	plugin::CallMethod<0x47AE00, CMenuManager *>(this);
   74  }

   76  void CMenuManager::DrawControllerBound(int arg0, int arg1, int arg2, char arg3) {
   77: 	plugin::CallMethod<0x489710, CMenuManager *, int, int, int, char>(this, arg0, arg1, arg2, arg3);
   78  }

   80  void CMenuManager::DrawControllerScreenExtraText(int arg0, int arg1, int arg2) {
   81: 	plugin::CallMethod<0x4892F0, CMenuManager *, int, int, int>(this, arg0, arg1, arg2);
   82  }

   84  void CMenuManager::DrawControllerSetupScreen() {
   85: 	plugin::CallMethod<0x481210, CMenuManager *>(this);
   86  }

   88  void CMenuManager::DrawFrontEnd() {
   89: 	plugin::CallMethod<0x47A540, CMenuManager *>(this);
   90  }

   92  void CMenuManager::DrawFrontEndNormal() {
   93: 	plugin::CallMethod<0x47A5B0, CMenuManager *>(this);
   94  }

   96  void CMenuManager::DrawPlayerSetupScreen() {
   97: 	plugin::CallMethod<0x47F2B0, CMenuManager *>(this);
   98  }

  100  int CMenuManager::FadeIn(int alpha) {
  101: 	return plugin::CallMethodAndReturn<int, 0x48AC60, CMenuManager *, int>(this, alpha);
  102  }

  104  void CMenuManager::FilterOutColorMarkersFromString(char s, CRGBA &color) {
  105: 	plugin::CallMethod<0x4889C0, CMenuManager *, char, CRGBA &>(this, s, color);
  106  }

  108  int CMenuManager::GetStartOptionsCntrlConfigScreens() {
  109: 	return plugin::CallMethodAndReturn<int, 0x489270, CMenuManager *>(this);
  110  }

  112  void CMenuManager::InitialiseChangedLanguageSettings() {
  113: 	plugin::Call<0x47A4D0>();
  114  }

  116  void CMenuManager::LoadAllTextures() {
  117: 	plugin::CallMethod<0x47A230, CMenuManager *>(this);
  118  }

  120  void CMenuManager::LoadSettings() {
  121: 	plugin::CallMethod<0x488EE0, CMenuManager *>(this);
  122  }

  124  void CMenuManager::MessageScreen(char *message) {
  125: 	plugin::Call<0x48B7E0, char *>(message);
  126  }

  128  void CMenuManager::PickNewPlayerColour() {
  129: 	plugin::Call<0x488C40>();
  130  }

  132  void CMenuManager::PrintBriefs() {
  133: 	plugin::CallMethod<0x484D60, CMenuManager *>(this);
  134  }

  136  void CMenuManager::PrintErrorMessage() {
  137: 	plugin::Call<0x484F70>();
  138  }

  140  void CMenuManager::PrintStats() {
  141: 	plugin::CallMethod<0x482100, CMenuManager *>(this);
  142  }

  144  void CMenuManager::Process() {
  145: 	plugin::CallMethod<0x485100, CMenuManager *>(this);
  146  }

  148  void CMenuManager::ProcessButtonPresses() {
  149: 	plugin::CallMethod<0x4856F0, CMenuManager *>(this);
  150  }

  152  void CMenuManager::ProcessOnOffMenuOptions() {
  153: 	plugin::CallMethod<0x48AE60, CMenuManager *>(this);
  154  }

  156  void CMenuManager::RequestFrontEndShutDown() {
  157: 	plugin::Call<0x488750>();
  158  }

  160  void CMenuManager::RequestFrontEndStartUp() {
  161: 	plugin::Call<0x488770>();
  162  }

  164  void CMenuManager::ResetHelperText() {
  165: 	plugin::CallMethod<0x48B470, CMenuManager *>(this);
  166  }

  168  void CMenuManager::SaveLoadFileError_SetUpErrorScreen() {
  169: 	plugin::CallMethod<0x488930, CMenuManager *>(this);
  170  }

  172  void CMenuManager::SaveSettings() {
  173: 	plugin::CallMethod<0x488CC0, CMenuManager *>(this);
  174  }

  176  void CMenuManager::SetHelperText(int text) {
  177: 	plugin::CallMethod<0x48B450, CMenuManager *, int>(this, text);
  178  }

  180  void CMenuManager::ShutdownJustMenu() {
  181: 	plugin::CallMethod<0x488920, CMenuManager *>(this);
  182  }

  184  float CMenuManager::StretchX(float x) {
  185: 	return plugin::CallMethodAndReturn<float, 0x48ABE0, CMenuManager *, float>(this, x);
  186  }

  188  float CMenuManager::StretchY(float y) {
  189: 	return plugin::CallMethodAndReturn<float, 0x48AC20, CMenuManager *, float>(this, y);
  190  }

  192  void CMenuManager::SwitchMenuOnAndOff() {
  193: 	plugin::CallMethod<0x488790, CMenuManager *>(this);
  194  }

  196  void CMenuManager::UnloadTextures() {
  197: 	plugin::CallMethod<0x47A440, CMenuManager *>(this);
  198  }

  200  void CMenuManager::WaitForUserCD() {
  201: 	plugin::CallMethod<0x48ADD0, CMenuManager *>(this);
  202  }

plugin_III\game_III\CMessages.cpp:
   16  void CMessages::Init() {
   17:     plugin::Call<0x529310>();
   18  }

   21  int CMessages::GetWideStringLength(wchar_t* str) {
   22:     return plugin::CallAndReturn<int, 0x529490, wchar_t*>(str);
   23  }

   26  int CMessages::WideStringCopy(wchar_t* dst, wchar_t* src, unsigned short size) {
   27:     return plugin::CallAndReturn<int, 0x5294B0, wchar_t*, wchar_t*, unsigned short>(dst, src, size);
   28  }

   31  bool CMessages::WideStringCompare(wchar_t* str1, wchar_t* str2, unsigned short size) {
   32:     return plugin::CallAndReturn<bool, 0x529510, wchar_t*, wchar_t*, unsigned short>(str1, str2, size);
   33  }

   36  void CMessages::Process() {
   37:     plugin::Call<0x529580>();
   38  }

   41  void CMessages::Display() {
   42:     plugin::Call<0x529800>();
   43  }

   46  void CMessages::AddMessage(wchar_t* text, unsigned int time, unsigned short flag) {
   47:     plugin::Call<0x529900, wchar_t*, unsigned int, unsigned short>(text, time, flag);
   48  }

   51  void CMessages::AddMessageJumpQ(wchar_t* text, unsigned int time, unsigned short flag) {
   52:     plugin::Call<0x529A10, wchar_t*, unsigned int, unsigned short>(text, time, flag);
   53  }

   56  void CMessages::AddMessageSoon(wchar_t* text, unsigned int time, unsigned short flag) {
   57:     plugin::Call<0x529AF0, wchar_t*, unsigned int, unsigned short>(text, time, flag);
   58  }

   61  void CMessages::ClearMessages() {
   62:     plugin::Call<0x529CE0>();
   63  }

   66  void CMessages::ClearSmallMessagesOnly() {
   67:     plugin::Call<0x529E00>();
   68  }

   71  void CMessages::AddBigMessage(wchar_t* text, unsigned int time, unsigned short flag) {
   72:     plugin::Call<0x529EB0, wchar_t*, unsigned int, unsigned short>(text, time, flag);
   73  }

   76  void CMessages::AddBigMessageQ(wchar_t* text, unsigned int time, unsigned short flag) {
   77:     plugin::Call<0x529F60, wchar_t*, unsigned int, unsigned short>(text, time, flag);
   78  }

   81  void CMessages::AddToPreviousBriefArray(wchar_t* text, int n1, int n2, int n3, int n4, int n5, int n6, wchar_t* str) {
   82:     plugin::Call<0x52A040, wchar_t*, int, int, int, int, int, int, wchar_t*>(text, n1, n2, n3, n4, n5, n6, str);
   83  }

   86  void CMessages::InsertNumberInString(wchar_t* src, int n1, int n2, int n3, int n4, int n5, int n6, wchar_t* dst) {
   87:     plugin::Call<0x52A1A0, wchar_t*, int, int, int, int, int, int, wchar_t*>(src, n1, n2, n3, n4, n5, n6, dst);
   88  }

   91  void CMessages::InsertStringInString(wchar_t* text, wchar_t* str) {
   92:     plugin::Call<0x52A300, wchar_t*, wchar_t*>(text, str);
   93  }

   96  void CMessages::InsertPlayerControlKeysInString(wchar_t* text) {
   97:     plugin::Call<0x52A490, wchar_t*>(text);
   98  }

  101  void CMessages::AddMessageWithNumber(wchar_t* text, unsigned int time, unsigned short flag, int n1, int n2, int n3, int n4, int n5, int n6) {
  102:     plugin::Call<0x52A850, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
  103  }

  106  void CMessages::AddMessageJumpQWithNumber(wchar_t* text, unsigned int time, unsigned short flag, int n1, int n2, int n3, int n4, int n5, int n6) {
  107:     plugin::Call<0x52A9A0, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
  108  }

  111  void CMessages::AddMessageSoonWithNumber(wchar_t* text, unsigned int time, unsigned short flag, int n1, int n2, int n3, int n4, int n5, int n6) {
  112:     plugin::Call<0x52AAC0, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
  113  }

  116  void CMessages::AddBigMessageWithNumber(wchar_t* text, unsigned int time, unsigned short flag, int n1, int n2, int n3, int n4, int n5, int n6) {
  117:     plugin::Call<0x52AD10, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
  118  }

  121  void CMessages::AddBigMessageWithNumberQ(wchar_t* text, unsigned int time, unsigned short flag, int n1, int n2, int n3, int n4, int n5, int n6) {
  122:     plugin::Call<0x52AE00, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
  123  }

  126  void CMessages::AddMessageWithString(wchar_t* text, unsigned int time, unsigned short flag, wchar_t* str) {
  127:     plugin::Call<0x52AF30, wchar_t*, unsigned int, unsigned short, wchar_t*>(text, time, flag, str);
  128  }

  131  void CMessages::AddMessageJumpQWithString(wchar_t* text, unsigned int time, unsigned short flag, wchar_t* str) {
  132:     plugin::Call<0x52B050, wchar_t*, unsigned int, unsigned short, wchar_t*>(text, time, flag, str);
  133  }

  136  void CMessages::ClearThisPrint(wchar_t* text) {
  137:     plugin::Call<0x52B140, wchar_t*>(text);
  138  }

  141  void CMessages::ClearThisBigPrint(wchar_t* text) {
  142:     plugin::Call<0x52B3C0, wchar_t*>(text);
  143  }

  146  void CMessages::ClearAllMessagesDisplayedByGame() {
  147:     plugin::Call<0x52B670>();
  148  }

plugin_III\game_III\CMissionCleanup.cpp:
  17  void CMissionCleanup::AddEntityToList(int id, unsigned char type) {
  18:     plugin::CallMethodDynGlobal<CMissionCleanup *, int, unsigned char>(gaddrof(CMissionCleanup::AddEntityToList), this, id, type);
  19  }

  24  tCleanupEntity *CMissionCleanup::FindFree() {
  25:     return plugin::CallMethodAndReturnDynGlobal<tCleanupEntity *, CMissionCleanup *>(gaddrof(CMissionCleanup::FindFree), this);
  26  }

  31  void CMissionCleanup::Init() {
  32:     plugin::CallMethodDynGlobal<CMissionCleanup *>(gaddrof(CMissionCleanup::Init), this);
  33  }

  38  void CMissionCleanup::Process() {
  39:     plugin::CallMethodDynGlobal<CMissionCleanup *>(gaddrof(CMissionCleanup::Process), this);
  40  }

  45  void CMissionCleanup::RemoveEntityFromList(int id, unsigned char type) {
  46:     plugin::CallMethodDynGlobal<CMissionCleanup *, int, unsigned char>(gaddrof(CMissionCleanup::RemoveEntityFromList), this, id, type);
  47  }

plugin_III\game_III\CMloModelInfo.cpp:
  23  void CMloModelInfo::ConstructClump() {
  24:     plugin::CallMethodDynGlobal<CMloModelInfo *>(gaddrof(CMloModelInfo::ConstructClump), this);
  25  }

plugin_III\game_III\CModelInfo.cpp:
   25  CClumpModelInfo *CModelInfo::AddClumpModel(int index) {
   26:     return plugin::CallAndReturnDynGlobal<CClumpModelInfo *, int>(gaddrof(CModelInfo::AddClumpModel), index);
   27  }

   32  CMloModelInfo *CModelInfo::AddMloModel(int index) {
   33:     return plugin::CallAndReturnDynGlobal<CMloModelInfo *, int>(gaddrof(CModelInfo::AddMloModel), index);
   34  }

   39  CPedModelInfo *CModelInfo::AddPedModel(int index) {
   40:     return plugin::CallAndReturnDynGlobal<CPedModelInfo *, int>(gaddrof(CModelInfo::AddPedModel), index);
   41  }

   46  CSimpleModelInfo *CModelInfo::AddSimpleModel(int index) {
   47:     return plugin::CallAndReturnDynGlobal<CSimpleModelInfo *, int>(gaddrof(CModelInfo::AddSimpleModel), index);
   48  }

   53  CTimeModelInfo *CModelInfo::AddTimeModel(int index) {
   54:     return plugin::CallAndReturnDynGlobal<CTimeModelInfo *, int>(gaddrof(CModelInfo::AddTimeModel), index);
   55  }

   60  CVehicleModelInfo *CModelInfo::AddVehicleModel(int index) {
   61:     return plugin::CallAndReturnDynGlobal<CVehicleModelInfo *, int>(gaddrof(CModelInfo::AddVehicleModel), index);
   62  }

   74  CStore<C2dEffect, 2000> *CModelInfo::Get2dEffectStore() {
   75:     return plugin::CallAndReturnDynGlobal<CStore<C2dEffect, 2000> *>(gaddrof(CModelInfo::Get2dEffectStore));
   76  }

   81  CStore<CInstance, 1> *CModelInfo::GetMloInstanceStore() {
   82:     return plugin::CallAndReturnDynGlobal<CStore<CInstance, 1> *>(gaddrof(CModelInfo::GetMloInstanceStore));
   83  }

   88  CBaseModelInfo *CModelInfo::GetModelInfo(char const *name, int *index) {
   89:     return plugin::CallAndReturnDynGlobal<CBaseModelInfo *, char const *, int *>(gaddrof(CModelInfo::GetModelInfo), name, index);
   90  }

  102  bool CModelInfo::IsBoatModel(int index) {
  103:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CModelInfo::IsBoatModel), index);
  104  }

  116  void CModelInfo::RemoveColModelsFromOtherLevels(eLevelName level) {
  117:     plugin::CallDynGlobal<eLevelName>(gaddrof(CModelInfo::RemoveColModelsFromOtherLevels), level);
  118  }

plugin_III\game_III\CMoneyMessage.cpp:
  17  void CMoneyMessage::Render() {
  18:     plugin::CallMethodDynGlobal<CMoneyMessage *>(gaddrof(CMoneyMessage::Render), this);
  19  }

plugin_III\game_III\CMotionBlurStreaks.cpp:
  23  void CMotionBlurStreaks::RegisterStreak(unsigned int id, unsigned char red, unsigned char green, unsigned char blue, CVector leftPoint, CVector rightPoint) {
  24:     plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(gaddrof(CMotionBlurStreaks::RegisterStreak), id, red, green, blue, leftPoint, rightPoint);
  25  }

plugin_III\game_III\CMouseControllerState.cpp:
  14  CMouseControllerState::CMouseControllerState() {
  15:     plugin::CallMethodDynGlobal<CMouseControllerState *>(ctor_gaddr(CMouseControllerState), this);
  16  }

  21  void CMouseControllerState::Clear() {
  22:     plugin::CallMethodDynGlobal<CMouseControllerState *>(gaddrof(CMouseControllerState::Clear), this);
  23  }

plugin_III\game_III\CMousePointerStateHelper.cpp:
  17      CMouseControllerState ret_state;
  18:     plugin::CallMethodDynGlobal<CMousePointerStateHelper *, CMouseControllerState *>(gaddrof(CMousePointerStateHelper::GetMouseSetUp), this, &ret_state);
  19      return ret_state;

plugin_III\game_III\CMovingThing.cpp:
  17  void CMovingThing::AddToList(CMovingThing *pThing) {
  18:     plugin::CallMethodDynGlobal<CMovingThing *, CMovingThing *>(gaddrof(CMovingThing::AddToList), this, pThing);
  19  }

  24  void CMovingThing::RemoveFromList() {
  25:     plugin::CallMethodDynGlobal<CMovingThing *>(gaddrof(CMovingThing::RemoveFromList), this);
  26  }

  31  void CMovingThing::Update() {
  32:     plugin::CallMethodDynGlobal<CMovingThing *>(gaddrof(CMovingThing::Update), this);
  33  }

plugin_III\game_III\cMusicManager.cpp:
   28  void cMusicManager::ChangeMusicMode(unsigned char mode) {
   29:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::ChangeMusicMode), this, mode);
   30  }

   35  bool cMusicManager::ChangeRadioChannel() {
   36:     return plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::ChangeRadioChannel), this);
   37  }

   42  void cMusicManager::ComputeAmbienceVol(unsigned char reset, unsigned char &outVolume) {
   43:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, unsigned char &>(gaddrof(cMusicManager::ComputeAmbienceVol), this, reset, outVolume);
   44  }

   49  void cMusicManager::DisplayRadioStationName() {
   50:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::DisplayRadioStationName), this);
   51  }

   56  unsigned char cMusicManager::GetCarTuning() {
   57:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetCarTuning), this);
   58  }

   63  unsigned char cMusicManager::GetNextCarTuning() {
   64:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetNextCarTuning), this);
   65  }

   70  unsigned char cMusicManager::GetRadioInCar() {
   71:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetRadioInCar), this);
   72  }

   77  unsigned int cMusicManager::GetTrackStartPos(unsigned char track) {
   78:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, cMusicManager *, unsigned char>(gaddrof(cMusicManager::GetTrackStartPos), this, track);
   79  }

   84  void cMusicManager::Initialise() {
   85:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Initialise), this);
   86  }

   91  void cMusicManager::PlayAnnouncement(unsigned char announcement) {
   92:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::PlayAnnouncement), this, announcement);
   93  }

   98  void cMusicManager::PlayFrontEndTrack(unsigned char track, unsigned char bPlayInFrontend) {
   99:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, unsigned char>(gaddrof(cMusicManager::PlayFrontEndTrack), this, track, bPlayInFrontend);
  100  }

  105  void cMusicManager::PlayPreloadedCutSceneMusic() {
  106:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::PlayPreloadedCutSceneMusic), this);
  107  }

  112  bool cMusicManager::PlayerInCar() {
  113:     return plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::PlayerInCar), this);
  114  }

  119  void cMusicManager::PreloadCutSceneMusic(unsigned char sound) {
  120:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::PreloadCutSceneMusic), this, sound);
  121  }

  126  void cMusicManager::ResetMusicAfterReload() {
  127:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ResetMusicAfterReload), this);
  128  }

  133  void cMusicManager::ResetTimers(unsigned int time) {
  134:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned int>(gaddrof(cMusicManager::ResetTimers), this, time);
  135  }

  140  void cMusicManager::Service() {
  141:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Service), this);
  142  }

  147  void cMusicManager::ServiceAmbience() {
  148:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceAmbience), this);
  149  }

  154  bool cMusicManager::ServiceAnnouncement() {
  155:     return plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::ServiceAnnouncement), this);
  156  }

  161  void cMusicManager::ServiceFrontEndMode() {
  162:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceFrontEndMode), this);
  163  }

  168  void cMusicManager::ServiceGameMode() {
  169:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceGameMode), this);
  170  }

  175  void cMusicManager::ServiceTrack() {
  176:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceTrack), this);
  177  }

  182  void cMusicManager::SetRadioChannelByScript(unsigned char station, int position) {
  183:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, int>(gaddrof(cMusicManager::SetRadioChannelByScript), this, station, position);
  184  }

  189  void cMusicManager::SetRadioInCar(unsigned int radioStation) {
  190:     plugin::CallMethodDynGlobal<cMusicManager *, unsigned int>(gaddrof(cMusicManager::SetRadioInCar), this, radioStation);
  191  }

  196  void cMusicManager::StopCutSceneMusic() {
  197:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::StopCutSceneMusic), this);
  198  }

  203  void cMusicManager::StopFrontEndTrack() {
  204:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::StopFrontEndTrack), this);
  205  }

  210  void cMusicManager::Terminate() {
  211:     plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Terminate), this);
  212  }

  217  bool cMusicManager::UsesPoliceRadio(CVehicle *vehicle) {
  218:     return plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *, CVehicle *>(gaddrof(cMusicManager::UsesPoliceRadio), this, vehicle);
  219  }

plugin_III\game_III\CObject.cpp:
   41  void CObject::ProcessControl() {
   42:     plugin::CallVirtualMethod<8, CObject *>(this);
   43  }

   48  void CObject::Teleport(CVector pos) {
   49:     plugin::CallVirtualMethod<11, CObject *, CVector>(this, pos);
   50  }

   55  void CObject::Render() {
   56:     plugin::CallVirtualMethod<13, CObject *>(this);
   57  }

   62  bool CObject::SetupLighting() {
   63:     return plugin::CallVirtualMethodAndReturn<bool, 14, CObject *>(this);
   64  }

   69  void CObject::RemoveLighting(bool resetWorldColors) {
   70:     plugin::CallVirtualMethod<15, CObject *, bool>(this, resetWorldColors);
   71  }

   76  bool CObject::CanBeDeleted() {
   77:     return plugin::CallMethodAndReturnDynGlobal<bool, CObject *>(gaddrof(CObject::CanBeDeleted), this);
   78  }

   83  void CObject::Init() {
   84:     plugin::CallMethodDynGlobal<CObject *>(gaddrof(CObject::Init), this);
   85  }

   90  void CObject::ObjectDamage(float amount) {
   91:     plugin::CallMethodDynGlobal<CObject *, float>(gaddrof(CObject::ObjectDamage), this, amount);
   92  }

   97  void CObject::RefModelInfo(int modelIndex) {
   98:     plugin::CallMethodDynGlobal<CObject *, int>(gaddrof(CObject::RefModelInfo), this, modelIndex);
   99  }

  118  void CObject::DeleteAllTempObjectsInArea(CVector point, float radius) {
  119:     plugin::CallDynGlobal<CVector, float>(gaddrof(CObject::DeleteAllTempObjectsInArea), point, radius);
  120  }

plugin_III\game_III\CObjectData.cpp:
  16  void CObjectData::Initialise(char const *fileName) {
  17:     plugin::CallDynGlobal<char const *>(gaddrof(CObjectData::Initialise), fileName);
  18  }

  23  void CObjectData::SetObjectData(int modelIndex, CObject &object) {
  24:     plugin::CallDynGlobal<int, CObject &>(gaddrof(CObjectData::SetObjectData), modelIndex, object);
  25  }

plugin_III\game_III\common.cpp:
   10  float FindPlayerHeading() {
   11:     return plugin::CallAndReturn<float, 0x4A1220>();
   12  }

   15  CVector& FindPlayerCentreOfWorld_NoSniperShift() {
   16:     return plugin::CallAndReturn<CVector&, 0x4A11C0>();
   17  }

   20  CVector& FindPlayerCentreOfWorld(int playerId) {
   21:     return plugin::CallAndReturn<CVector&, 0x4A1170, int>(playerId);
   22  }

   25  CPlayerPed* FindPlayerPed() {
   26:     return plugin::CallAndReturn<CPlayerPed*, 0x4A1150>();
   27  }

   30  CTrain* FindPlayerTrain() {
   31:     return plugin::CallAndReturn<CTrain*, 0x4A1120>();
   32  }

   35  CEntity* FindPlayerEntity() {
   36:     return plugin::CallAndReturn<CEntity*, 0x4A10F0>();
   37  }

   40  CVehicle* FindPlayerVehicle() {
   41:     return plugin::CallAndReturn<CVehicle*, 0x4A10C0>();
   42  }

   45  CVector& FindPlayerSpeed() {
   46:     return plugin::CallAndReturn<CVector&, 0x4A1090>();
   47  }

   50  CVector& FindPlayerCoors() {
   51:     return plugin::CallAndReturn<CVector&, 0x4A1030>();
   52  }

   55  RwTexture* GetFirstTexture(RwTexDictionary* texDictionary) {
   56:     return plugin::CallAndReturn<RwTexture*, 0x5264E0, RwTexDictionary*>(texDictionary);
   57  }

   60  RwObject* GetFirstObject(RwFrame* frame) {
   61:     return plugin::CallAndReturn<RwObject*, 0x526460, RwFrame*>(frame);
   62  }

   65  RpAtomic* GetFirstAtomic(RpClump* clump) {
   66:     return plugin::CallAndReturn<RpAtomic*, 0x526420, RpClump*>(clump);
   67  }

   70  void SetAmbientColours(RwRGBAReal* colours) {
   71:     plugin::Call<0x526FA0, RwRGBAReal*>(colours);
   72  }

   75  void SetAmbientColoursForPedsCarsAndObjects() {
   76:     plugin::Call<0x526F80>();
   77  }

   80  void SetAmbientColours() {
   81:     plugin::Call<0x526F60>();
   82  }

   85  void ActivateDirectional() {
   86:     plugin::Call<0x526F50>();
   87  }

   90  void DeActivateDirectional() {
   91:     plugin::Call<0x526F40>();
   92  }

   95  void ReSetAmbientAndDirectionalColours() {
   96:     plugin::Call<0x526F10>();
   97  }

  100  void SetBrightMarkerColours(float power) {
  101:     plugin::Call<0x526E60, float>(power);
  102  }

  105  void SetAmbientAndDirectionalColours(float power) {
  106:     plugin::Call<0x526DE0, float>(power);
  107  }

  110  void RemoveExtraDirectionalLights(RpWorld* world) {
  111:     plugin::Call<0x526DB0, RpWorld*>(world);
  112  }

  115  void AddAnExtraDirectionalLight(RpWorld* world, float x, float y, float z, float red, float green, float blue) {
  116:     plugin::Call<0x526C70, RpWorld*, float, float, float, float, float, float>(world, x, y, z, red, green, blue);
  117  }

  120  void WorldReplaceNormalLightsWithScorched(RpWorld* world, float intensity) {
  121:     plugin::Call<0x526C10, RpWorld*, float>(world, intensity);
  122  }

  125  RpWorld* LightsDestroy(RpWorld* world) {
  126:     return plugin::CallAndReturn<RpWorld*, 0x526B40, RpWorld*>(world);
  127  }

  130  RpWorld* LightsCreate(RpWorld* world) {
  131:     return plugin::CallAndReturn<RpWorld*, 0x5269A0, RpWorld*>(world);
  132  }

  135  void SetLightsWithTimeOfDayColour(RpWorld* world) {
  136:     plugin::Call<0x526510, RpWorld*>(world);
  137  }

  140  RwFrame* GetFirstChild(RwFrame* frame) {
  141:     return plugin::CallAndReturn<RwFrame*, 0x5264A0, RwFrame*>(frame);
  142  }

  145  RpAtomic* GetFirstAtomicCallback(RpAtomic* atomic, void* data) {
  146:     return plugin::CallAndReturn<RpAtomic*, 0x526410, RpAtomic*, void*>(atomic, data);
  147  }

  150  RwObject* GetFirstObjectCallback(RwObject* object, void* data) {
  151:     return plugin::CallAndReturn<RwObject*, 0x526450, RwObject*, void*>(object, data);
  152  }

  155  RwFrame* GetFirstFrameCallback(RwFrame* frame, void* data) {
  156:     return plugin::CallAndReturn<RwFrame*, 0x526490, RwFrame*, void*>(frame, data);
  157  }

  160  RwTexture* GetFirstTextureCallback(RwTexture* texture, void* data) {
  161:     return plugin::CallAndReturn<RwTexture*, 0x5264D0, RwTexture*, void*>(texture, data);
  162  }

  165  void WorldReplaceScorchedLightsWithNormal(RpWorld* world) {
  166:     plugin::Call<0x526C50, RpWorld*>(world);
  167  }

  170  void CreateDebugFont() {
  171:     plugin::Call<0x526300>();
  172  }

  175  void DestroyDebugFont() {
  176:     plugin::Call<0x526310>();
  177  }

  180  void FlushObrsPrintfs() {
  181:     plugin::Call<0x526320>();
  182  }

  185  void DefinedState() {
  186:     plugin::Call<0x526330>();
  187  }

  189  CAnimBlendAssociation* RpAnimBlendClumpGetAssociation(RpClump* clump, unsigned int animId) {
  190:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4055C0>(clump, animId);
  191  }

plugin_III\game_III\COneSheet.cpp:
  14  void COneSheet::AddToList(COneSheet *list) {
  15:     plugin::CallMethodDynGlobal<COneSheet *, COneSheet *>(gaddrof(COneSheet::AddToList), this, list);
  16  }

  21  void COneSheet::RemoveFromList() {
  22:     plugin::CallMethodDynGlobal<COneSheet *>(gaddrof(COneSheet::RemoveFromList), this);
  23  }

plugin_III\game_III\COnscreenTimer.cpp:
  14  void COnscreenTimer::AddClock(unsigned int offset, char *gxt) {
  15:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, char *>(gaddrof(COnscreenTimer::AddClock), this, offset, gxt);
  16  }

  21  void COnscreenTimer::AddCounter(unsigned int offset, unsigned short type, char *gxt) {
  22:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned short, char *>(gaddrof(COnscreenTimer::AddCounter), this, offset, type, gxt);
  23  }

  28  void COnscreenTimer::ClearClock(unsigned int offset) {
  29:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearClock), this, offset);
  30  }

  35  void COnscreenTimer::ClearCounter(unsigned int offset) {
  36:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearCounter), this, offset);
  37  }

  42  void COnscreenTimer::Init() {
  43:     plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Init), this);
  44  }

  49  void COnscreenTimer::Process() {
  50:     plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Process), this);
  51  }

  56  void COnscreenTimer::ProcessForDisplay() {
  57:     plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::ProcessForDisplay), this);
  58  }

plugin_III\game_III\COnscreenTimerEntry.cpp:
  14  void COnscreenTimerEntry::Process() {
  15:     plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::Process), this);
  16  }

  21  bool COnscreenTimerEntry::ProcessForDisplay() {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplay), this);
  23  }

  28  void COnscreenTimerEntry::ProcessForDisplayClock() {
  29:     plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayClock), this);
  30  }

  35  void COnscreenTimerEntry::ProcessForDisplayCounter() {
  36:     plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayCounter), this);
  37  }

plugin_III\game_III\CPacManPickup.cpp:
  17  void CPacManPickup::Update() {
  18:     plugin::CallMethodDynGlobal<CPacManPickup *>(gaddrof(CPacManPickup::Update), this);
  19  }

plugin_III\game_III\CPacManPickups.cpp:
   36  void CPacManPickups::GenerateOnePMPickUp(CVector pos) {
   37:     plugin::CallDynGlobal<CVector>(gaddrof(CPacManPickups::GenerateOnePMPickUp), pos);
   38  }

   43  void CPacManPickups::GeneratePMPickUps(CVector pos, float scrambleMult, short count, unsigned char type) {
   44:     plugin::CallDynGlobal<CVector, float, short, unsigned char>(gaddrof(CPacManPickups::GeneratePMPickUps), pos, scrambleMult, count, type);
   45  }

   50  void CPacManPickups::GeneratePMPickUpsForRace(int race) {
   51:     plugin::CallDynGlobal<int>(gaddrof(CPacManPickups::GeneratePMPickUpsForRace), race);
   52  }

   64  unsigned int CPacManPickups::QueryPowerPillsCarriedByPlayer() {
   65:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CPacManPickups::QueryPowerPillsCarriedByPlayer));
   66  }

   71  int CPacManPickups::QueryPowerPillsEatenInRace() {
   72:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CPacManPickups::QueryPowerPillsEatenInRace));
   73  }

   99  void CPacManPickups::StartPacManRace(int race) {
  100:     plugin::CallDynGlobal<int>(gaddrof(CPacManPickups::StartPacManRace), race);
  101  }

  113  void CPacManPickups::StartPacManScramble(CVector pos, float scrambleMult, short count) {
  114:     plugin::CallDynGlobal<CVector, float, short>(gaddrof(CPacManPickups::StartPacManScramble), pos, scrambleMult, count);
  115  }

plugin_III\game_III\CPad.cpp:
   31  void CPad::AddToPCCheatString(char name) {
   32:     plugin::CallMethod<0x492450, CPad *, char>(this, name);
   33  }

   36  CPad::CPad() {
   37:     plugin::CallMethod<0x494EE0, CPad *>(this);
   38  }

   41  bool CPad::CarGunJustDown() {
   42:     return plugin::CallMethodAndReturn<bool, 0x4934F0, CPad *>(this);
   43  }

   46  bool CPad::ChangeStationJustDown() {
   47:     return plugin::CallMethodAndReturn<bool, 0x493870, CPad *>(this);
   48  }

   51  void CPad::Clear(bool enable) {
   52:     plugin::CallMethod<0x491A10, CPad *, bool>(this, enable);
   53  }

   56  void CPad::ClearMouseHistory() {
   57:     plugin::CallMethod<0x491B50, CPad *>(this);
   58  }

   61  bool CPad::CycleCameraModeDownJustDown() {
   62:     return plugin::CallMethodAndReturn<bool, 0x493830, CPad *>(this);
   63  }

   66  bool CPad::CycleCameraModeUpJustDown() {
   67:     return plugin::CallMethodAndReturn<bool, 0x4937D0, CPad *>(this);
   68  }

   71  bool CPad::CycleWeaponLeftJustDown() {
   72:     return plugin::CallMethodAndReturn<bool, 0x493910, CPad *>(this);
   73  }

   76  bool CPad::CycleWeaponRightJustDown() {
   77:     return plugin::CallMethodAndReturn<bool, 0x493940, CPad *>(this);
   78  }

   81  void CPad::DoCheats(short arg0) {
   82:     plugin::CallMethod<0x492F20, CPad *, short>(this, arg0);
   83  }

   86  void CPad::DoCheats() {
   87:     plugin::Call<0x492F00>();
   88  }

   91  void CPad::EditCodesForControls(int* arg0) {
   92:     plugin::Call<0x494690, int*>(arg0);
   93  }

   96  void CPad::EditString(char* name, int arg1) {
   97:     plugin::Call<0x4944B0, char*, int>(name, arg1);
   98  }

  101  bool CPad::ExitVehicleJustDown() {
  102:     return plugin::CallMethodAndReturn<bool, 0x493650, CPad *>(this);
  103  }

  106  bool CPad::ForceCameraBehindPlayer() {
  107:     return plugin::CallMethodAndReturn<bool, 0x493D80, CPad *>(this);
  108  }

  111  short CPad::GetAccelerate() {
  112:     return plugin::CallMethodAndReturn<short, 0x493780, CPad *>(this);
  113  }

  116  bool CPad::GetAnaloguePadDown() {
  117:     return plugin::CallAndReturn<bool, 0x493BA0>();
  118  }

  121  bool CPad::GetAnaloguePadLeft() {
  122:     return plugin::CallAndReturn<bool, 0x493C00>();
  123  }

  126  bool CPad::GetAnaloguePadLeftJustUp() {
  127:     return plugin::CallAndReturn<bool, 0x493CC0>();
  128  }

  131  bool CPad::GetAnaloguePadRight() {
  132:     return plugin::CallAndReturn<bool, 0x493C60>();
  133  }

  136  bool CPad::GetAnaloguePadRightJustUp() {
  137:     return plugin::CallAndReturn<bool, 0x493D20>();
  138  }

  141  bool CPad::GetAnaloguePadUp() {
  142:     return plugin::CallAndReturn<bool, 0x493B40>();
  143  }

  146  short CPad::GetAnalogueUpDown() {
  147:     return plugin::CallMethodAndReturn<short, 0x493210, CPad *>(this);
  148  }

  151  short CPad::GetBrake() {
  152:     return plugin::CallMethodAndReturn<short, 0x4935A0, CPad *>(this);
  153  }

  156  bool CPad::GetCarGunFired() {
  157:     return plugin::CallMethodAndReturn<bool, 0x493490, CPad *>(this);
  158  }

  161  short CPad::GetCarGunLeftRight() {
  162:     return plugin::CallMethodAndReturn<short, 0x4930C0, CPad *>(this);
  163  }

  166  short CPad::GetCarGunUpDown() {
  167:     return plugin::CallMethodAndReturn<short, 0x493070, CPad *>(this);
  168  }

  171  bool CPad::GetExitVehicle() {
  172:     return plugin::CallMethodAndReturn<bool, 0x4935F0, CPad *>(this);
  173  }

  176  short CPad::GetHandBrake() {
  177:     return plugin::CallMethodAndReturn<short, 0x493560, CPad *>(this);
  178  }

  181  bool CPad::GetHorn() {
  182:     return plugin::CallMethodAndReturn<bool, 0x493350, CPad *>(this);
  183  }

  186  bool CPad::GetLookBehindForCar() {
  187:     return plugin::CallMethodAndReturn<bool, 0x4932F0, CPad *>(this);
  188  }

  191  bool CPad::GetLookBehindForPed() {
  192:     return plugin::CallMethodAndReturn<bool, 0x493320, CPad *>(this);
  193  }

  196  bool CPad::GetLookLeft() {
  197:     return plugin::CallMethodAndReturn<bool, 0x493290, CPad *>(this);
  198  }

  201  bool CPad::GetLookRight() {
  202:     return plugin::CallMethodAndReturn<bool, 0x4932C0, CPad *>(this);
  203  }

  206  CPad* CPad::GetPad(int padNumber) {
  207:     return plugin::CallAndReturn<CPad*, 0x492F60, int>(padNumber);
  208  }

  211  short CPad::GetPedWalkLeftRight() {
  212:     return plugin::CallMethodAndReturn<short, 0x493110, CPad *>(this);
  213  }

  216  short CPad::GetPedWalkUpDown() {
  217:     return plugin::CallMethodAndReturn<short, 0x493190, CPad *>(this);
  218  }

  221  bool CPad::GetSprint() {
  222:     return plugin::CallMethodAndReturn<bool, 0x493A70, CPad *>(this);
  223  }

  226  short CPad::GetSteeringLeftRight() {
  227:     return plugin::CallMethodAndReturn<short, 0x492F70, CPad *>(this);
  228  }

  231  short CPad::GetSteeringUpDown() {
  232:     return plugin::CallMethodAndReturn<short, 0x492FF0, CPad *>(this);
  233  }

  236  bool CPad::GetTarget() {
  237:     return plugin::CallMethodAndReturn<bool, 0x493970, CPad *>(this);
  238  }

  241  bool CPad::GetWeapon() {
  242:     return plugin::CallMethodAndReturn<bool, 0x4936C0, CPad *>(this);
  243  }

  246  bool CPad::HornJustDown() {
  247:     return plugin::CallMethodAndReturn<bool, 0x4933F0, CPad *>(this);
  248  }

  251  bool CPad::JumpJustDown() {
  252:     return plugin::CallMethodAndReturn<bool, 0x493A40, CPad *>(this);
  253  }

  256  int CPad::LookAroundLeftRight() {
  257:     return plugin::CallMethodAndReturn<int, 0x493F80, CPad *>(this);
  258  }

  261  int CPad::LookAroundUpDown() {
  262:     return plugin::CallMethodAndReturn<int, 0x494130, CPad *>(this);
  263  }

  266  void CPad::PrintErrorMessage() {
  267:     plugin::Call<0x4942B0>();
  268  }

  271  void CPad::ProcessPCSpecificStuff() {
  272:     plugin::CallMethod<0x492C60, CPad *>(this);
  273  }

  276  void CPad::ReconcileTwoControllersInput(CControllerState const& controllerA, CControllerState const& controllerB) {
  277:     plugin::CallMethod<0x491E60, CPad *, CControllerState const&, CControllerState const&>(this, controllerA, controllerB);
  278  }

  281  void CPad::ResetAverageWeapon() {
  282:     plugin::CallMethod<0x494290, CPad *>(this);
  283  }

  286  void CPad::ResetCheats() {
  287:     plugin::Call<0x494450>();
  288  }

  291  bool CPad::ShiftTargetLeftJustDown() {
  292:     return plugin::CallMethodAndReturn<bool, 0x493AE0, CPad *>(this);
  293  }

  296  bool CPad::ShiftTargetRightJustDown() {
  297:     return plugin::CallMethodAndReturn<bool, 0x493B10, CPad *>(this);
  298  }

  301  short CPad::SniperModeLookLeftRight() {
  302:     return plugin::CallMethodAndReturn<short, 0x493EE0, CPad *>(this);
  303  }

  306  short CPad::SniperModeLookUpDown() {
  307:     return plugin::CallMethodAndReturn<short, 0x493F30, CPad *>(this);
  308  }

  311  bool CPad::SniperZoomIn() {
  312:     return plugin::CallMethodAndReturn<bool, 0x493E00, CPad *>(this);
  313  }

  316  bool CPad::SniperZoomOut() {
  317:     return plugin::CallMethodAndReturn<bool, 0x493E70, CPad *>(this);
  318  }

  321  void CPad::StartShake(short time, unsigned char frequency) {
  322:     plugin::CallMethod<0x492230, CPad *, short, unsigned char>(this, time, frequency);
  323  }

  326  void CPad::StartShake_Distance(short time, unsigned char frequency, float x, float y, float z) {
  327:     plugin::CallMethod<0x492290, CPad *, short, unsigned char, float, float, float>(this, time, frequency, x, y, z);
  328  }

  331  void CPad::StartShake_Train(float x, float y) {
  332:     plugin::CallMethod<0x492360, CPad *, float, float>(this, x, y);
  333  }

  336  void CPad::StopPadsShaking() {
  337:     plugin::Call<0x492F30>();
  338  }

  341  void CPad::StopShaking(short arg0) {
  342:     plugin::CallMethod<0x492F50, CPad *, short>(this, arg0);
  343  }

  346  bool CPad::TargetJustDown() {
  347:     return plugin::CallMethodAndReturn<bool, 0x4939D0, CPad *>(this);
  348  }

  351  void CPad::Update() {
  352:     plugin::CallMethod<0x492C70, CPad *>(this);
  353  }

  356  void CPad::UpdateMouse() {
  357:     plugin::CallMethod<0x491CA0, CPad *>(this);
  358  }

  361  void CPad::UpdatePads() {
  362:     plugin::Call<0x492720>();
  363  }

  366  bool CPad::WeaponJustDown() {
  367:     return plugin::CallMethodAndReturn<bool, 0x493700, CPad *>(this);
  368  }

  371  CPad::~CPad() {
  372:     plugin::CallMethod<0x494ED0, CPad *>(this);
  373  }

plugin_III\game_III\CPager.cpp:
  12  void CPager::Init() {
  13:     plugin::CallMethod<0x52B6F0, CPager *>(this);
  14  }

  17  void CPager::Process() {
  18:     plugin::CallMethod<0x52B740, CPager *>(this);
  19  }

  22  void CPager::Display() {
  23:     plugin::CallMethod<0x52B890, CPager *>(this);
  24  }

  27  void CPager::AddMessage(wchar_t* text, unsigned short speed, unsigned short priority, unsigned short arg3) {
  28:     plugin::CallMethod<0x52B940, CPager *, wchar_t*, unsigned short, unsigned short, unsigned short>(this, text, speed, priority, arg3);
  29  }

  32  void CPager::AddMessageWithNumber(wchar_t* text, int n1, int n2, int n3, int n4, int n5, int n6, unsigned short speed, unsigned short priority, unsigned short arg9) {
  33:     plugin::CallMethod<0x52BB50, CPager *, wchar_t*, int, int, int, int, int, int, unsigned short, unsigned short, unsigned short>(this, text, n1, n2, n3, n4, n5, n6, speed, priority, arg9);
  34  }

  37  void CPager::ClearMessages() {
  38:     plugin::CallMethod<0x52BE00, CPager *>(this);
  39  }

  42  void CPager::RestartCurrentMessage() {
  43:     plugin::CallMethod<0x52BE50, CPager *>(this);
  44  }

plugin_III\game_III\CParticle.cpp:
   78  void CParticle::AddJetExplosion(CVector const &pos, float power, float size) {
   79:     plugin::CallDynGlobal<CVector const &, float, float>(gaddrof(CParticle::AddJetExplosion), pos, power, size);
   80  }

   85  CParticle *CParticle::AddParticle(tParticleType type, CVector const &pos, CVector const &direction, CEntity *entity, float size, int rotationSpeed, int rotation, int currentFrame, int lifeSpan) {
   86:     return plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int)), type, pos, direction, entity, size, rotationSpeed, rotation, currentFrame, lifeSpan);
   87  }

   92  CParticle *CParticle::AddParticle(tParticleType type, CVector const &pos, CVector const &direction, CEntity *entity, float size, RwRGBA const &color, int rotationSpeed, int rotation, int currentFrame, int lifeSpan) {
   93:     return plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const &, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const &, int, int, int, int)), type, pos, direction, entity, size, color, rotationSpeed, rotation, currentFrame, lifeSpan);
   94  }

   99  void CParticle::AddYardieDoorSmoke(CVector const &pos, CMatrix const &matrix) {
  100:     plugin::CallDynGlobal<CVector const &, CMatrix const &>(gaddrof(CParticle::AddYardieDoorSmoke), pos, matrix);
  101  }

  120  void CParticle::RemovePSystem(tParticleType type) {
  121:     plugin::CallDynGlobal<tParticleType>(gaddrof(CParticle::RemovePSystem), type);
  122  }

  127  void CParticle::RemoveParticle(CParticle *particle, CParticle *previousParticle, tParticleSystemData *particleSystem) {
  128:     plugin::CallDynGlobal<CParticle *, CParticle *, tParticleSystemData *>(gaddrof(CParticle::RemoveParticle), particle, previousParticle, particleSystem);
  129  }

plugin_III\game_III\CParticleObject.cpp:
   28  void CParticleObject::RemoveObject() {
   29:     plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::RemoveObject), this);
   30  }

   35  void CParticleObject::UpdateClose() {
   36:     plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::UpdateClose), this);
   37  }

   42  void CParticleObject::UpdateFar() {
   43:     plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::UpdateFar), this);
   44  }

   49  CParticleObject *CParticleObject::AddObject(unsigned short type, CVector const &pos, unsigned char remove) {
   50:     return plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, unsigned char)), type, pos, remove);
   51  }

   56  CParticleObject *CParticleObject::AddObject(unsigned short type, CVector const &pos, float size, unsigned char remove) {
   57:     return plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, float, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, float, unsigned char)), type, pos, size, remove);
   58  }

   63  CParticleObject *CParticleObject::AddObject(unsigned short type, CVector const &pos, CVector const &target, float size, unsigned char remove) {
   64:     return plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, CVector const &, float, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, CVector const &, float, unsigned char)), type, pos, target, size, remove);
   65  }

   70  CParticleObject *CParticleObject::AddObject(unsigned short type, CVector const &pos, CVector const &target, float size, unsigned int lifeTime, RwRGBA const &color, unsigned char remove) {
   71:     return plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, CVector const &, float, unsigned int, RwRGBA const &, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, CVector const &, float, unsigned int, RwRGBA const &, unsigned char)), type, pos, target, size, lifeTime, color, remove);
   72  }

   84  void CParticleObject::LoadParticle(unsigned char *buffer, unsigned int size) {
   85:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CParticleObject::LoadParticle), buffer, size);
   86  }

   91  void CParticleObject::MoveToList(CParticleObject **from, CParticleObject **to, CParticleObject *object) {
   92:     plugin::CallDynGlobal<CParticleObject **, CParticleObject **, CParticleObject *>(gaddrof(CParticleObject::MoveToList), from, to, object);
   93  }

  105  void CParticleObject::SaveParticle(unsigned char *buffer, unsigned int *size) {
  106:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CParticleObject::SaveParticle), buffer, size);
  107  }

plugin_III\game_III\cParticleSystemMgr.cpp:
  13  cParticleSystemMgr::cParticleSystemMgr() {
  14:     plugin::CallMethod<0x50FCB0, cParticleSystemMgr *>(this);
  15  }

  18  void cParticleSystemMgr::Initialise() {
  19:     plugin::CallMethod<0x50FCD0, cParticleSystemMgr *>(this);
  20  }

  23  void cParticleSystemMgr::LoadParticleData() {
  24:     plugin::CallMethod<0x50FDF0, cParticleSystemMgr *>(this);
  25  }

plugin_III\game_III\CPathFind.cpp:
   25  void CPathFind::AddNodeToList(CPathNode *node, int listId) {
   26:     plugin::CallMethodDynGlobal<CPathFind *, CPathNode *, int>(gaddrof(CPathFind::AddNodeToList), this, node, listId);
   27  }

   32  void CPathFind::AllocatePathFindInfoMem(short numPathGroups) {
   33:     plugin::CallMethodDynGlobal<CPathFind *, short>(gaddrof(CPathFind::AllocatePathFindInfoMem), this, numPathGroups);
   34  }

   39  void CPathFind::CalcNodeCoors(short x, short y, short z, int id, CVector *out) {
   40:     plugin::CallMethodDynGlobal<CPathFind *, short, short, short, int, CVector *>(gaddrof(CPathFind::CalcNodeCoors), this, x, y, z, id, out);
   41  }

   46  float CPathFind::CalcRoadDensity(float x, float y) {
   47:     return plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, float, float>(gaddrof(CPathFind::CalcRoadDensity), this, x, y);
   48  }

   53  void CPathFind::CountFloodFillGroups(unsigned char type) {
   54:     plugin::CallMethodDynGlobal<CPathFind *, unsigned char>(gaddrof(CPathFind::CountFloodFillGroups), this, type);
   55  }

   60  void CPathFind::DoPathSearch(unsigned char type, CVector start, int startNodeId, CVector target, CPathNode **nodes, short *numNodes, short maxNumNodes, CVehicle *vehicle, float *dist, float distLimit, int forcedTargetNode) {
   61:     plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CVector, int, CVector, CPathNode **, short *, short, CVehicle *, float *, float, int>(gaddrof(CPathFind::DoPathSearch), this, type, start, startNodeId, target, nodes, numNodes, maxNumNodes, vehicle, dist, distLimit, forcedTargetNode);
   62  }

   67  void CPathFind::FindNextNodeWandering(unsigned char type, CVector coors, CPathNode **lastNode, CPathNode **nextNode, unsigned char curDir, unsigned char *nextDir) {
   68:     plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CVector, CPathNode **, CPathNode **, unsigned char, unsigned char *>(gaddrof(CPathFind::FindNextNodeWandering), this, type, coors, lastNode, nextNode, curDir, nextDir);
   69  }

   74  int CPathFind::FindNodeClosestToCoors(CVector coors, unsigned char type, float distLimit, bool ignoreDisabled, bool ignoreBetweenLevels) {
   75:     return plugin::CallMethodAndReturnDynGlobal<int, CPathFind *, CVector, unsigned char, float, bool, bool>(gaddrof(CPathFind::FindNodeClosestToCoors), this, coors, type, distLimit, ignoreDisabled, ignoreBetweenLevels);
   76  }

   81  int CPathFind::FindNodeClosestToCoorsFavourDirection(CVector coors, unsigned char type, float dirX, float dirY) {
   82:     return plugin::CallMethodAndReturnDynGlobal<int, CPathFind *, CVector, unsigned char, float, float>(gaddrof(CPathFind::FindNodeClosestToCoorsFavourDirection), this, coors, type, dirX, dirY);
   83  }

   88  float CPathFind::FindNodeOrientationForCarPlacement(unsigned int nodeId) {
   89:     return plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, unsigned int>(gaddrof(CPathFind::FindNodeOrientationForCarPlacement), this, nodeId);
   90  }

   95  float CPathFind::FindNodeOrientationForCarPlacementFacingDestination(unsigned int nodeId, float x, float y, bool towards) {
   96:     return plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, unsigned int, float, float, bool>(gaddrof(CPathFind::FindNodeOrientationForCarPlacementFacingDestination), this, nodeId, x, y, towards);
   97  }

  102  CTreadable *CPathFind::FindRoadObjectClosestToCoors(CVector coors, unsigned char type) {
  103:     return plugin::CallMethodAndReturnDynGlobal<CTreadable *, CPathFind *, CVector, unsigned char>(gaddrof(CPathFind::FindRoadObjectClosestToCoors), this, coors, type);
  104  }

  109  bool CPathFind::GeneratePedCreationCoors(float x, float y, float minDist, float maxDist, float minDistOffScreen, float maxDistOffScreen, CVector *posn, int *pNode1, int *pNode2, float *positionBetweenNodes, CMatrix *camMatrix) {
  110:     return plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, float, float, float, float, float, float, CVector *, int *, int *, float *, CMatrix *>(gaddrof(CPathFind::GeneratePedCreationCoors), this, x, y, minDist, maxDist, minDistOffScreen, maxDistOffScreen, posn, pNode1, pNode2, positionBetweenNodes, camMatrix);
  111  }

  116  void CPathFind::Init() {
  117:     plugin::CallMethodDynGlobal<CPathFind *>(gaddrof(CPathFind::Init), this);
  118  }

  123  void CPathFind::Load(unsigned char *buf, unsigned int size) {
  124:     plugin::CallMethodDynGlobal<CPathFind *, unsigned char *, unsigned int>(gaddrof(CPathFind::Load), this, buf, size);
  125  }

  130  void CPathFind::MarkRoadsBetweenLevelsInArea(float x1, float x2, float y1, float y2, float z1, float z2) {
  131:     plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float>(gaddrof(CPathFind::MarkRoadsBetweenLevelsInArea), this, x1, x2, y1, y2, z1, z2);
  132  }

  137  void CPathFind::MarkRoadsBetweenLevelsNodeAndNeighbours(int nodeId) {
  138:     plugin::CallMethodDynGlobal<CPathFind *, int>(gaddrof(CPathFind::MarkRoadsBetweenLevelsNodeAndNeighbours), this, nodeId);
  139  }

  144  bool CPathFind::NewGenerateCarCreationCoors(float x, float y, float dirX, float dirY, float spawnDist, float angleLimit, bool forward, CVector *posn, int *pNode1, int *pNode2, float *positionBetweenNodes, bool ignoreDisabled) {
  145:     return plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, float, float, float, float, float, float, bool, CVector *, int *, int *, float *, bool>(gaddrof(CPathFind::NewGenerateCarCreationCoors), this, x, y, dirX, dirY, spawnDist, angleLimit, forward, posn, pNode1, pNode2, positionBetweenNodes, ignoreDisabled);
  146  }

  151  void CPathFind::PedMarkRoadsBetweenLevelsInArea(float x1, float x2, float y1, float y2, float z1, float z2) {
  152:     plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float>(gaddrof(CPathFind::PedMarkRoadsBetweenLevelsInArea), this, x1, x2, y1, y2, z1, z2);
  153  }

  158  void CPathFind::PreparePathData() {
  159:     plugin::CallMethodDynGlobal<CPathFind *>(gaddrof(CPathFind::PreparePathData), this);
  160  }

  165  void CPathFind::PreparePathDataForType(unsigned char type, CTempNode *tempNodes, CPathInfoForObject *info, float maxDist, CTempDetachedNode *detachedNodes, int numDetached) {
  166:     plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CTempNode *, CPathInfoForObject *, float, CTempDetachedNode *, int>(gaddrof(CPathFind::PreparePathDataForType), this, type, tempNodes, info, maxDist, detachedNodes, numDetached);
  167  }

  172  void CPathFind::RegisterMapObject(CTreadable *mapObject) {
  173:     plugin::CallMethodDynGlobal<CPathFind *, CTreadable *>(gaddrof(CPathFind::RegisterMapObject), this, mapObject);
  174  }

  179  void CPathFind::RemoveBadStartNode(CVector pos, CPathNode **nodes, short *nodeCount) {
  180:     plugin::CallMethodDynGlobal<CPathFind *, CVector, CPathNode **, short *>(gaddrof(CPathFind::RemoveBadStartNode), this, pos, nodes, nodeCount);
  181  }

  186  void CPathFind::RemoveNodeFromList(CPathNode *node) {
  187:     plugin::CallMethodDynGlobal<CPathFind *, CPathNode *>(gaddrof(CPathFind::RemoveNodeFromList), this, node);
  188  }

  193  void CPathFind::Save(unsigned char *buf, unsigned int *size) {
  194:     plugin::CallMethodDynGlobal<CPathFind *, unsigned char *, unsigned int *>(gaddrof(CPathFind::Save), this, buf, size);
  195  }

  200  void CPathFind::SetLinksBridgeLights(float x1, float y1, float x2, float y2, bool enable) {
  201:     plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, bool>(gaddrof(CPathFind::SetLinksBridgeLights), this, x1, y1, x2, y2, enable);
  202  }

  207  void CPathFind::StoreNodeInfoCar(short id, short node, char type, char next, short x, short y, short z, short width, char numLeft, char numRight) {
  208:     plugin::CallMethodDynGlobal<CPathFind *, short, short, char, char, short, short, short, short, char, char>(gaddrof(CPathFind::StoreNodeInfoCar), this, id, node, type, next, x, y, z, width, numLeft, numRight);
  209  }

  214  void CPathFind::StoreNodeInfoPed(short id, short node, char type, char next, short x, short y, short z, short width, bool crossing) {
  215:     plugin::CallMethodDynGlobal<CPathFind *, short, short, char, char, short, short, short, short, bool>(gaddrof(CPathFind::StoreNodeInfoPed), this, id, node, type, next, x, y, z, width, crossing);
  216  }

  221  void CPathFind::SwitchOffNodeAndNeighbours(int nodeId, bool disable) {
  222:     plugin::CallMethodDynGlobal<CPathFind *, int, bool>(gaddrof(CPathFind::SwitchOffNodeAndNeighbours), this, nodeId, disable);
  223  }

  228  void CPathFind::SwitchPedRoadsOffInArea(float x1, float x2, float y1, float y2, float z1, float z2, bool disable) {
  229:     plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, bool>(gaddrof(CPathFind::SwitchPedRoadsOffInArea), this, x1, x2, y1, y2, z1, z2, disable);
  230  }

  235  void CPathFind::SwitchRoadsInAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float length, unsigned char type, unsigned char enable) {
  236:     plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, float, unsigned char, unsigned char>(gaddrof(CPathFind::SwitchRoadsInAngledArea), this, x1, y1, z1, x2, y2, z2, length, type, enable);
  237  }

  242  void CPathFind::SwitchRoadsOffInArea(float x1, float x2, float y1, float y2, float z1, float z2, bool disable) {
  243:     plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, bool>(gaddrof(CPathFind::SwitchRoadsOffInArea), this, x1, x2, y1, y2, z1, z2, disable);
  244  }

  249  bool CPathFind::TestCoorsCloseness(CVector target, unsigned char type, CVector start) {
  250:     return plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CVector, unsigned char, CVector>(gaddrof(CPathFind::TestCoorsCloseness), this, target, type, start);
  251  }

  256  bool CPathFind::TestCrossesRoad(CPathNode *node1, CPathNode *node2) {
  257:     return plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CPathNode *, CPathNode *>(gaddrof(CPathFind::TestCrossesRoad), this, node1, node2);
  258  }

  263  bool CPathFind::TestForPedTrafficLight(CPathNode *node1, CPathNode *node2) {
  264:     return plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CPathNode *, CPathNode *>(gaddrof(CPathFind::TestForPedTrafficLight), this, node1, node2);
  265  }

  270  bool CPathFind::LoadPathFindData() {
  271:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPathFind::LoadPathFindData));
  272  }

plugin_III\game_III\CPed.cpp:
    50  void CPed::SetModelIndex(unsigned int modelIndex) {
    51:     plugin::CallVirtualMethod<3, CPed *, unsigned int>(this, modelIndex);
    52  }

    57  void CPed::ProcessControl() {
    58:     plugin::CallVirtualMethod<8, CPed *>(this);
    59  }

    64  void CPed::Teleport(CVector pos) {
    65:     plugin::CallVirtualMethod<11, CPed *, CVector>(this, pos);
    66  }

    71  void CPed::PreRender() {
    72:     plugin::CallVirtualMethod<12, CPed *>(this);
    73  }

    78  void CPed::Render() {
    79:     plugin::CallVirtualMethod<13, CPed *>(this);
    80  }

    85  bool CPed::SetupLighting() {
    86:     return plugin::CallVirtualMethodAndReturn<bool, 14, CPed *>(this);
    87  }

    92  void CPed::RemoveLighting(bool resetWorldColors) {
    93:     plugin::CallVirtualMethod<15, CPed *, bool>(this, resetWorldColors);
    94  }

    99  void CPed::FlagToDestroyWhenNextProcessed() {
   100:     plugin::CallVirtualMethod<16, CPed *>(this);
   101  }

   106  void CPed::ProcessEntityCollision(CEntity *entity, CColPoint *colPoint) {
   107:     plugin::CallVirtualMethod<17, CPed *, CEntity *, CColPoint *>(this, entity, colPoint);
   108  }

   113  void CPed::SetMoveAnim() {
   114:     plugin::CallVirtualMethod<18, CPed *>(this);
   115  }

   120  void CPed::AddWeaponModel(int modelIndex) {
   121:     plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::AddWeaponModel), this, modelIndex);
   122  }

   127  void CPed::AimGun() {
   128:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::AimGun), this);
   129  }

   134  void CPed::ApplyHeadShot(eWeaponType type, CVector pos, unsigned char evenOnPlayer) {
   135:     plugin::CallMethodDynGlobal<CPed *, eWeaponType, CVector, unsigned char>(gaddrof(CPed::ApplyHeadShot), this, type, pos, evenOnPlayer);
   136  }

   141  void CPed::Attack() {
   142:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Attack), this);
   143  }

   148  void CPed::Avoid() {
   149:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Avoid), this);
   150  }

   155  void CPed::BeingDraggedFromCar() {
   156:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::BeingDraggedFromCar), this);
   157  }

   162  void CPed::BuildPedLists() {
   163:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::BuildPedLists), this);
   164  }

   169  void CPed::CalculateNewOrientation() {
   170:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CalculateNewOrientation), this);
   171  }

   176  void CPed::CalculateNewVelocity() {
   177:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CalculateNewVelocity), this);
   178  }

   183  bool CPed::CanBeDeleted() {
   184:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanBeDeleted), this);
   185  }

   190  bool CPed::CanPedDriveOff() {
   191:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedDriveOff), this);
   192  }

   197  bool CPed::CanPedJumpThis() {
   198:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedJumpThis), this);
   199  }

   204  bool CPed::CanPedReturnToState() {
   205:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedReturnToState), this);
   206  }

   211  bool CPed::CanSeeEntity(CEntity *entity, float threshold) {
   212:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *, float>(gaddrof(CPed::CanSeeEntity), this, entity, threshold);
   213  }

   218  bool CPed::CanSetPedState() {
   219:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanSetPedState), this);
   220  }

   225  bool CPed::CanStrafeOrMouseControl() {
   226:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanStrafeOrMouseControl), this);
   227  }

   232  void CPed::Chat() {
   233:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Chat), this);
   234  }

   239  void CPed::CheckAroundForPossibleCollisions() {
   240:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CheckAroundForPossibleCollisions), this);
   241  }

   246  CPed *CPed::CheckForDeadPeds() {
   247:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CPed *>(gaddrof(CPed::CheckForDeadPeds), this);
   248  }

   253  bool CPed::CheckForExplosions(CVector2D &area) {
   254:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector2D &>(gaddrof(CPed::CheckForExplosions), this, area);
   255  }

   260  CPed *CPed::CheckForGunShots() {
   261:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CPed *>(gaddrof(CPed::CheckForGunShots), this);
   262  }

   267  unsigned char CPed::CheckForPointBlankPeds(CPed *pedToVerify) {
   268:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, CPed *>(gaddrof(CPed::CheckForPointBlankPeds), this, pedToVerify);
   269  }

   274  bool CPed::CheckIfInTheAir() {
   275:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CheckIfInTheAir), this);
   276  }

   281  void CPed::ClearAimFlag() {
   282:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAimFlag), this);
   283  }

   288  void CPed::ClearAll() {
   289:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAll), this);
   290  }

   295  void CPed::ClearAttack() {
   296:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAttack), this);
   297  }

   302  void CPed::ClearAttackByRemovingAnim() {
   303:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAttackByRemovingAnim), this);
   304  }

   309  void CPed::ClearChat() {
   310:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearChat), this);
   311  }

   316  void CPed::ClearDuck() {
   317:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearDuck), this);
   318  }

   323  void CPed::ClearFall() {
   324:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearFall), this);
   325  }

   330  void CPed::ClearFlee() {
   331:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearFlee), this);
   332  }

   337  void CPed::ClearInvestigateEvent() {
   338:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearInvestigateEvent), this);
   339  }

   344  void CPed::ClearLeader() {
   345:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLeader), this);
   346  }

   351  void CPed::ClearLook() {
   352:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLook), this);
   353  }

   358  void CPed::ClearLookFlag() {
   359:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLookFlag), this);
   360  }

   365  void CPed::ClearObjective() {
   366:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearObjective), this);
   367  }

   372  void CPed::ClearPause() {
   373:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearPause), this);
   374  }

   379  void CPed::ClearPointGunAt() {
   380:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearPointGunAt), this);
   381  }

   386  void CPed::ClearSeek() {
   387:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearSeek), this);
   388  }

   393  void CPed::ClearWeapons() {
   394:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearWeapons), this);
   395  }

   400  void CPed::CollideWithPed(CPed *collideWith) {
   401:     plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::CollideWithPed), this, collideWith);
   402  }

   407  void CPed::CreateDeadPedMoney() {
   408:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CreateDeadPedMoney), this);
   409  }

   414  void CPed::CreateDeadPedWeaponPickups() {
   415:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CreateDeadPedWeaponPickups), this);
   416  }

   421  void CPed::Die() {
   422:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Die), this);
   423  }

   428  unsigned char CPed::DoesLOSBulletHitPed(CColPoint &colPoint) {
   429:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, CColPoint &>(gaddrof(CPed::DoesLOSBulletHitPed), this, colPoint);
   430  }

   435  void CPed::Duck() {
   436:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Duck), this);
   437  }

   442  bool CPed::DuckAndCover() {
   443:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::DuckAndCover), this);
   444  }

   449  void CPed::EndFight(unsigned char endType) {
   450:     plugin::CallMethodDynGlobal<CPed *, unsigned char>(gaddrof(CPed::EndFight), this, endType);
   451  }

   456  void CPed::EnterCar() {
   457:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::EnterCar), this);
   458  }

   463  void CPed::EnterTrain() {
   464:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::EnterTrain), this);
   465  }

   470  void CPed::ExitCar() {
   471:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ExitCar), this);
   472  }

   477  void CPed::ExitTrain() {
   478:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ExitTrain), this);
   479  }

   484  bool CPed::FacePhone() {
   485:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::FacePhone), this);
   486  }

   491  void CPed::Fall() {
   492:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Fall), this);
   493  }

   498  void CPed::Fight() {
   499:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Fight), this);
   500  }

   505  void CPed::FightStrike(CVector &touchedNodePos) {
   506:     plugin::CallMethodDynGlobal<CPed *, CVector &>(gaddrof(CPed::FightStrike), this, touchedNodePos);
   507  }

   512  bool CPed::FindBestCoordsFromNodes(CVector unused, CVector *bestCoords) {
   513:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector, CVector *>(gaddrof(CPed::FindBestCoordsFromNodes), this, unused, bestCoords);
   514  }

   519  void CPed::Flee() {
   520:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Flee), this);
   521  }

   526  void CPed::FollowPath() {
   527:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::FollowPath), this);
   528  }

   533  void CPed::ForceStoredObjective(eObjective objective) {
   534:     plugin::CallMethodDynGlobal<CPed *, eObjective>(gaddrof(CPed::ForceStoredObjective), this, objective);
   535  }

   540  CVector *CPed::GetFormationPosition() {
   541:     return plugin::CallMethodAndReturnDynGlobal<CVector *, CPed *>(gaddrof(CPed::GetFormationPosition), this);
   542  }

   547  int CPed::GetLocalDirection(CVector2D const &posOffset) {
   548:     return plugin::CallMethodAndReturnDynGlobal<int, CPed *, CVector2D const &>(gaddrof(CPed::GetLocalDirection), this, posOffset);
   549  }

   554  void CPed::GetNearestDoor(CVehicle *vehicle, CVector &posToOpen) {
   555:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestDoor), this, vehicle, posToOpen);
   556  }

   561  bool CPed::GetNearestPassengerDoor(CVehicle *vehicle, CVector &posToOpen) {
   562:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestPassengerDoor), this, vehicle, posToOpen);
   563  }

   568  bool CPed::GetNearestTrainDoor(CVehicle *vehicle, CVector &doorPos) {
   569:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestTrainDoor), this, vehicle, doorPos);
   570  }

   575  void CPed::GetNearestTrainPedPosition(CVehicle *vehicle, CVector &enterPos) {
   576:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestTrainPedPosition), this, vehicle, enterPos);
   577  }

   582  short CPed::GetNextPointOnRoute() {
   583:     return plugin::CallMethodAndReturnDynGlobal<short, CPed *>(gaddrof(CPed::GetNextPointOnRoute), this);
   584  }

   589  unsigned char CPed::GetPedRadioCategory(unsigned int modelIndex) {
   590:     return plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, unsigned int>(gaddrof(CPed::GetPedRadioCategory), this, modelIndex);
   591  }

   596  int CPed::GetWeaponSlot(eWeaponType type) {
   597:     return plugin::CallMethodAndReturnDynGlobal<int, CPed *, eWeaponType>(gaddrof(CPed::GetWeaponSlot), this, type);
   598  }

   603  unsigned int CPed::GiveWeapon(eWeaponType type, unsigned int ammo) {
   604:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CPed *, eWeaponType, unsigned int>(gaddrof(CPed::GiveWeapon), this, type, ammo);
   605  }

   610  void CPed::GoToNearestDoor(CVehicle *vehicle) {
   611:     plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::GoToNearestDoor), this, vehicle);
   612  }

   617  void CPed::GrantAmmo(eWeaponType type, unsigned int ammo) {
   618:     plugin::CallMethodDynGlobal<CPed *, eWeaponType, unsigned int>(gaddrof(CPed::GrantAmmo), this, type, ammo);
   619  }

   624  bool CPed::HaveReachedNextPointOnRoute(float distToCountReached) {
   625:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, float>(gaddrof(CPed::HaveReachedNextPointOnRoute), this, distToCountReached);
   626  }

   631  void CPed::Idle() {
   632:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Idle), this);
   633  }

   638  void CPed::InTheAir() {
   639:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::InTheAir), this);
   640  }

   645  bool CPed::InflictDamage(CEntity *damagedBy, eWeaponType type, float damage, ePedPieceTypes pedPiece, unsigned char direction) {
   646:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *, eWeaponType, float, ePedPieceTypes, unsigned char>(gaddrof(CPed::InflictDamage), this, damagedBy, type, damage, pedPiece, direction);
   647  }

   652  void CPed::InformMyGangOfAttack(CEntity *attacker) {
   653:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::InformMyGangOfAttack), this, attacker);
   654  }

   659  void CPed::InvestigateEvent() {
   660:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::InvestigateEvent), this);
   661  }

   666  bool CPed::IsGangMember() {
   667:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsGangMember), this);
   668  }

   673  bool CPed::IsPedHeadAbovePos(float zOffset) {
   674:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, float>(gaddrof(CPed::IsPedHeadAbovePos), this, zOffset);
   675  }

   680  bool CPed::IsPedInControl() {
   681:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPedInControl), this);
   682  }

   687  bool CPed::IsPedShootable() {
   688:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPedShootable), this);
   689  }

   694  bool CPed::IsPlayer() {
   695:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPlayer), this);
   696  }

   701  bool CPed::IsPointerValid() {
   702:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPointerValid), this);
   703  }

   708  bool CPed::IsRoomToBeCarJacked() {
   709:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsRoomToBeCarJacked), this);
   710  }

   715  bool CPed::IsTemporaryObjective(eObjective objective) {
   716:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, eObjective>(gaddrof(CPed::IsTemporaryObjective), this, objective);
   717  }

   722  void CPed::KillPedWithCar(CVehicle *vehicle, float impulse) {
   723:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, float>(gaddrof(CPed::KillPedWithCar), this, vehicle, impulse);
   724  }

   729  void CPed::LineUpPedWithCar(unsigned int phase) {
   730:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::LineUpPedWithCar), this, phase);
   731  }

   736  void CPed::LineUpPedWithTrain() {
   737:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LineUpPedWithTrain), this);
   738  }

   743  void CPed::Look() {
   744:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Look), this);
   745  }

   750  bool CPed::LookForInterestingNodes() {
   751:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::LookForInterestingNodes), this);
   752  }

   757  void CPed::LookForSexyCars() {
   758:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LookForSexyCars), this);
   759  }

   764  void CPed::LookForSexyPeds() {
   765:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LookForSexyPeds), this);
   766  }

   771  bool CPed::MakePhonecall() {
   772:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::MakePhonecall), this);
   773  }

   778  void CPed::MoveHeadToLook() {
   779:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::MoveHeadToLook), this);
   780  }

   785  void CPed::Mug() {
   786:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Mug), this);
   787  }

   792  bool CPed::OurPedCanSeeThisOne(CEntity *entity) {
   793:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *>(gaddrof(CPed::OurPedCanSeeThisOne), this, entity);
   794  }

   799  void CPed::Pause() {
   800:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Pause), this);
   801  }

   806  bool CPed::PlacePedOnDryLand() {
   807:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::PlacePedOnDryLand), this);
   808  }

   813  void CPed::PlayFootSteps() {
   814:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::PlayFootSteps), this);
   815  }

   820  void CPed::PlayHitSound(CPed *hitTo) {
   821:     plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::PlayHitSound), this, hitTo);
   822  }

   827  void CPed::PointGunAt() {
   828:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::PointGunAt), this);
   829  }

   834  bool CPed::PositionPedOutOfCollision() {
   835:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::PositionPedOutOfCollision), this);
   836  }

   841  bool CPed::PossiblyFindBetterPosToSeekCar(CVector *pos, CVehicle *vehicle) {
   842:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector *, CVehicle *>(gaddrof(CPed::PossiblyFindBetterPosToSeekCar), this, pos, vehicle);
   843  }

   848  void CPed::ProcessBuoyancy() {
   849:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ProcessBuoyancy), this);
   850  }

   855  void CPed::ProcessObjective() {
   856:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ProcessObjective), this);
   857  }

   862  void CPed::QuitEnteringCar() {
   863:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::QuitEnteringCar), this);
   864  }

   869  void CPed::ReactToAttack(CEntity *attacker) {
   870:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::ReactToAttack), this, attacker);
   871  }

   876  void CPed::ReactToPointGun(CEntity *entWithGun) {
   877:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::ReactToPointGun), this, entWithGun);
   878  }

   883  void CPed::RegisterThreatWithGangPeds(CEntity *attacker) {
   884:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::RegisterThreatWithGangPeds), this, attacker);
   885  }

   890  void CPed::RemoveBodyPart(int nodeId, char direction) {
   891:     plugin::CallMethodDynGlobal<CPed *, int, char>(gaddrof(CPed::RemoveBodyPart), this, nodeId, direction);
   892  }

   897  void CPed::RemoveInCarAnims() {
   898:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RemoveInCarAnims), this);
   899  }

   904  void CPed::RemoveWeaponModel(int modelIndex) {
   905:     plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::RemoveWeaponModel), this, modelIndex);
   906  }

   911  void CPed::RestartNonPartialAnims() {
   912:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestartNonPartialAnims), this);
   913  }

   918  void CPed::RestoreGunPosition() {
   919:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreGunPosition), this);
   920  }

   925  void CPed::RestoreHeadPosition() {
   926:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreHeadPosition), this);
   927  }

   932  void CPed::RestoreHeadingRate() {
   933:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreHeadingRate), this);
   934  }

   939  void CPed::RestorePreviousObjective() {
   940:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestorePreviousObjective), this);
   941  }

   946  void CPed::RestorePreviousState() {
   947:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestorePreviousState), this);
   948  }

   953  bool CPed::RunToReportCrime(eCrimeType type) {
   954:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, eCrimeType>(gaddrof(CPed::RunToReportCrime), this, type);
   955  }

   960  void CPed::Say(unsigned short audio) {
   961:     plugin::CallMethodDynGlobal<CPed *, unsigned short>(gaddrof(CPed::Say), this, audio);
   962  }

   967  void CPed::ScanForInterestingStuff() {
   968:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ScanForInterestingStuff), this);
   969  }

   974  unsigned int CPed::ScanForThreats() {
   975:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CPed *>(gaddrof(CPed::ScanForThreats), this);
   976  }

   981  bool CPed::Seek() {
   982:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::Seek), this);
   983  }

   988  void CPed::SeekBoatPosition() {
   989:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SeekBoatPosition), this);
   990  }

   995  void CPed::SeekCar() {
   996:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SeekCar), this);
   997  }

  1002  bool CPed::SeekFollowingPath(CVector *unused) {
  1003:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector *>(gaddrof(CPed::SeekFollowingPath), this, unused);
  1004  }

  1009  bool CPed::SelectGunIfArmed() {
  1010:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::SelectGunIfArmed), this);
  1011  }

  1016  void CPed::ServiceTalking() {
  1017:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ServiceTalking), this);
  1018  }

  1023  bool CPed::ServiceTalkingWhenDead() {
  1024:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::ServiceTalkingWhenDead), this);
  1025  }

  1030  void CPed::SetAimFlag(float direction) {
  1031:     plugin::CallMethodDynGlobal<CPed *, float>(gaddrof_o(CPed::SetAimFlag, void (CPed::*)(float)), this, direction);
  1032  }

  1037  void CPed::SetAimFlag(CEntity *entity) {
  1038:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof_o(CPed::SetAimFlag, void (CPed::*)(CEntity *)), this, entity);
  1039  }

  1044  void CPed::SetAmmo(eWeaponType type, unsigned int ammo) {
  1045:     plugin::CallMethodDynGlobal<CPed *, eWeaponType, unsigned int>(gaddrof(CPed::SetAmmo), this, type, ammo);
  1046  }

  1051  void CPed::SetAttack(CEntity *victim) {
  1052:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetAttack), this, victim);
  1053  }

  1058  void CPed::SetAttackTimer(unsigned int time) {
  1059:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetAttackTimer), this, time);
  1060  }

  1065  void CPed::SetBeingDraggedFromCar(CVehicle *vehicle, unsigned int doorNode, bool quickJack) {
  1066:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, bool>(gaddrof(CPed::SetBeingDraggedFromCar), this, vehicle, doorNode, quickJack);
  1067  }

  1072  void CPed::SetBuyIceCream() {
  1073:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetBuyIceCream), this);
  1074  }

  1079  void CPed::SetCarJack(CVehicle *vehicle) {
  1080:     plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetCarJack), this, vehicle);
  1081  }

  1086  void CPed::SetCarJack_AllClear(CVehicle *vehicle, unsigned int doorNode, unsigned int doorFlag) {
  1087:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, unsigned int>(gaddrof(CPed::SetCarJack_AllClear), this, vehicle, doorNode, doorFlag);
  1088  }

  1093  void CPed::SetChat(CEntity *chatWith, unsigned int time) {
  1094:     plugin::CallMethodDynGlobal<CPed *, CEntity *, unsigned int>(gaddrof(CPed::SetChat), this, chatWith, time);
  1095  }

  1100  void CPed::SetCurrentWeapon(int type) {
  1101:     plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::SetCurrentWeapon), this, type);
  1102  }

  1107  void CPed::SetDead() {
  1108:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetDead), this);
  1109  }

  1114  void CPed::SetDie(int animId, float delta, float speed) {
  1115:     plugin::CallMethodDynGlobal<CPed *, int, float, float>(gaddrof(CPed::SetDie), this, animId, delta, speed);
  1116  }

  1121  void CPed::SetDirectionToWalkAroundObject(CEntity *entity) {
  1122:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetDirectionToWalkAroundObject), this, entity);
  1123  }

  1128  void CPed::SetDuck(unsigned int time) {
  1129:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetDuck), this, time);
  1130  }

  1135  void CPed::SetEnterCar(CVehicle *vehicle, unsigned int unused) {
  1136:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetEnterCar), this, vehicle, unused);
  1137  }

  1142  void CPed::SetEnterCar_AllClear(CVehicle *vehicle, unsigned int doorNode, unsigned int doorFlag) {
  1143:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, unsigned int>(gaddrof(CPed::SetEnterCar_AllClear), this, vehicle, doorNode, doorFlag);
  1144  }

  1149  void CPed::SetEnterTrain(CVehicle *train, unsigned int unused) {
  1150:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetEnterTrain), this, train, unused);
  1151  }

  1156  void CPed::SetEvasiveDive(CPhysical *reason, unsigned char onlyRandomJump) {
  1157:     plugin::CallMethodDynGlobal<CPed *, CPhysical *, unsigned char>(gaddrof(CPed::SetEvasiveDive), this, reason, onlyRandomJump);
  1158  }

  1163  void CPed::SetEvasiveStep(CPhysical *reason, unsigned char animType) {
  1164:     plugin::CallMethodDynGlobal<CPed *, CPhysical *, unsigned char>(gaddrof(CPed::SetEvasiveStep), this, reason, animType);
  1165  }

  1170  void CPed::SetExitCar(CVehicle *vehicle, unsigned int doorNode) {
  1171:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetExitCar), this, vehicle, doorNode);
  1172  }

  1177  void CPed::SetExitTrain(CVehicle *train) {
  1178:     plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetExitTrain), this, train);
  1179  }

  1184  void CPed::SetFall(int extraTime, int animId, unsigned char evenIfNotInControl) {
  1185:     plugin::CallMethodDynGlobal<CPed *, int, int, unsigned char>(gaddrof(CPed::SetFall), this, extraTime, animId, evenIfNotInControl);
  1186  }

  1191  void CPed::SetFlee(CVector2D const &from, int time) {
  1192:     plugin::CallMethodDynGlobal<CPed *, CVector2D const &, int>(gaddrof_o(CPed::SetFlee, void (CPed::*)(CVector2D const &, int)), this, from, time);
  1193  }

  1198  void CPed::SetFlee(CEntity *fleeFrom, int time) {
  1199:     plugin::CallMethodDynGlobal<CPed *, CEntity *, int>(gaddrof_o(CPed::SetFlee, void (CPed::*)(CEntity *, int)), this, fleeFrom, time);
  1200  }

  1205  bool CPed::SetFollowPath(CVector dest) {
  1206:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector>(gaddrof(CPed::SetFollowPath), this, dest);
  1207  }

  1212  void CPed::SetFollowRoute(short currentPoint, short routeType) {
  1213:     plugin::CallMethodDynGlobal<CPed *, short, short>(gaddrof(CPed::SetFollowRoute), this, currentPoint, routeType);
  1214  }

  1219  void CPed::SetFormation(eFormation formation) {
  1220:     plugin::CallMethodDynGlobal<CPed *, eFormation>(gaddrof(CPed::SetFormation), this, formation);
  1221  }

  1226  void CPed::SetGetUp() {
  1227:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetGetUp), this);
  1228  }

  1233  void CPed::SetIdle() {
  1234:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetIdle), this);
  1235  }

  1240  void CPed::SetInTheAir() {
  1241:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetInTheAir), this);
  1242  }

  1247  void CPed::SetInvestigateEvent(eEventType type, CVector2D pos, float distanceToCountDone, unsigned short time, float angle) {
  1248:     plugin::CallMethodDynGlobal<CPed *, eEventType, CVector2D, float, unsigned short, float>(gaddrof(CPed::SetInvestigateEvent), this, type, pos, distanceToCountDone, time, angle);
  1249  }

  1254  void CPed::SetJump() {
  1255:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetJump), this);
  1256  }

  1261  void CPed::SetLanding() {
  1262:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetLanding), this);
  1263  }

  1268  void CPed::SetLeader(CPed *leader) {
  1269:     plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::SetLeader), this, leader);
  1270  }

  1275  void CPed::SetLookFlag(float direction, bool keepTryingToLook) {
  1276:     plugin::CallMethodDynGlobal<CPed *, float, bool>(gaddrof_o(CPed::SetLookFlag, void (CPed::*)(float, bool)), this, direction, keepTryingToLook);
  1277  }

  1282  void CPed::SetLookFlag(CEntity *target, bool keepTryingToLook) {
  1283:     plugin::CallMethodDynGlobal<CPed *, CEntity *, bool>(gaddrof_o(CPed::SetLookFlag, void (CPed::*)(CEntity *, bool)), this, target, keepTryingToLook);
  1284  }

  1289  void CPed::SetLookTimer(unsigned int time) {
  1290:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetLookTimer), this, time);
  1291  }

  1296  void CPed::SetMoveState(eMoveState state) {
  1297:     plugin::CallMethodDynGlobal<CPed *, eMoveState>(gaddrof(CPed::SetMoveState), this, state);
  1298  }

  1303  void CPed::SetObjective(eObjective objective) {
  1304:     plugin::CallMethodDynGlobal<CPed *, eObjective>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective)), this, objective);
  1305  }

  1310  void CPed::SetObjective(eObjective objective, void *entity) {
  1311:     plugin::CallMethodDynGlobal<CPed *, eObjective, void *>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, void *)), this, objective, entity);
  1312  }

  1317  void CPed::SetObjective(eObjective objective, CVector dest, float safeDist) {
  1318:     plugin::CallMethodDynGlobal<CPed *, eObjective, CVector, float>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, CVector, float)), this, objective, dest, safeDist);
  1319  }

  1324  void CPed::SetObjective(eObjective objective, short routePoint, short routeType) {
  1325:     plugin::CallMethodDynGlobal<CPed *, eObjective, short, short>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, short, short)), this, objective, routePoint, routeType);
  1326  }

  1331  void CPed::SetObjective(eObjective objective, CVector dest) {
  1332:     plugin::CallMethodDynGlobal<CPed *, eObjective, CVector>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, CVector)), this, objective, dest);
  1333  }

  1338  void CPed::SetObjectiveTimer(unsigned int time) {
  1339:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetObjectiveTimer), this, time);
  1340  }

  1345  void CPed::SetPedPositionInCar() {
  1346:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetPedPositionInCar), this);
  1347  }

  1352  void CPed::SetPedPositionInTrain() {
  1353:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetPedPositionInTrain), this);
  1354  }

  1359  void CPed::SetPedStats(ePedStats stat) {
  1360:     plugin::CallMethodDynGlobal<CPed *, ePedStats>(gaddrof(CPed::SetPedStats), this, stat);
  1361  }

  1366  void CPed::SetPointGunAt(CEntity *entity) {
  1367:     plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetPointGunAt), this, entity);
  1368  }

  1373  void CPed::SetRadioStation() {
  1374:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetRadioStation), this);
  1375  }

  1380  void CPed::SetSeek(CVector pos, float distanceToCountDone) {
  1381:     plugin::CallMethodDynGlobal<CPed *, CVector, float>(gaddrof_o(CPed::SetSeek, void (CPed::*)(CVector, float)), this, pos, distanceToCountDone);
  1382  }

  1387  void CPed::SetSeek(CEntity *seeking, float distanceToCountDone) {
  1388:     plugin::CallMethodDynGlobal<CPed *, CEntity *, float>(gaddrof_o(CPed::SetSeek, void (CPed::*)(CEntity *, float)), this, seeking, distanceToCountDone);
  1389  }

  1394  void CPed::SetSeekBoatPosition(CVehicle *boat) {
  1395:     plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetSeekBoatPosition), this, boat);
  1396  }

  1401  void CPed::SetSeekCar(CVehicle *vehicle, unsigned int doorNode) {
  1402:     plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetSeekCar), this, vehicle, doorNode);
  1403  }

  1408  void CPed::SetShootTimer(unsigned int time) {
  1409:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetShootTimer), this, time);
  1410  }

  1415  void CPed::SetSolicit(unsigned int time) {
  1416:     plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetSolicit), this, time);
  1417  }

  1422  void CPed::SetStoredObjective() {
  1423:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetStoredObjective), this);
  1424  }

  1429  void CPed::SetStoredState() {
  1430:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetStoredState), this);
  1431  }

  1436  void CPed::SetWaitState(eWaitState state, void *time) {
  1437:     plugin::CallMethodDynGlobal<CPed *, eWaitState, void *>(gaddrof(CPed::SetWaitState), this, state, time);
  1438  }

  1443  bool CPed::SetWanderPath(char pathStateDest) {
  1444:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, char>(gaddrof(CPed::SetWanderPath), this, pathStateDest);
  1445  }

  1450  void CPed::Solicit() {
  1451:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Solicit), this);
  1452  }

  1457  void CPed::SortPeds(CPed **list, int min, int max) {
  1458:     plugin::CallMethodDynGlobal<CPed *, CPed **, int, int>(gaddrof(CPed::SortPeds), this, list, min, max);
  1459  }

  1464  void CPed::SpawnFlyingComponent(int nodeId, char direction) {
  1465:     plugin::CallMethodDynGlobal<CPed *, int, char>(gaddrof(CPed::SpawnFlyingComponent), this, nodeId, direction);
  1466  }

  1471  void CPed::StartFightAttack(unsigned char buttonPressure) {
  1472:     plugin::CallMethodDynGlobal<CPed *, unsigned char>(gaddrof(CPed::StartFightAttack), this, buttonPressure);
  1473  }

  1478  void CPed::StartFightDefend(unsigned char direction, unsigned char hitLevel, unsigned char strength) {
  1479:     plugin::CallMethodDynGlobal<CPed *, unsigned char, unsigned char, unsigned char>(gaddrof(CPed::StartFightDefend), this, direction, hitLevel, strength);
  1480  }

  1485  void CPed::StopNonPartialAnims() {
  1486:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::StopNonPartialAnims), this);
  1487  }

  1492  bool CPed::TurnBody() {
  1493:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::TurnBody), this);
  1494  }

  1499  void CPed::UpdateFromLeader() {
  1500:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::UpdateFromLeader), this);
  1501  }

  1506  void CPed::UpdatePosition() {
  1507:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::UpdatePosition), this);
  1508  }

  1513  bool CPed::UseGroundColModel() {
  1514:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::UseGroundColModel), this);
  1515  }

  1520  void CPed::Wait() {
  1521:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Wait), this);
  1522  }

  1527  void CPed::WanderPath() {
  1528:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::WanderPath), this);
  1529  }

  1534  void CPed::WanderRange() {
  1535:     plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::WanderRange), this);
  1536  }

  1541  void CPed::WarpPedIntoCar(CVehicle *vehicle) {
  1542:     plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::WarpPedIntoCar), this, vehicle);
  1543  }

  1548  bool CPed::WarpPedToNearEntityOffScreen(CEntity *warpTo) {
  1549:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *>(gaddrof(CPed::WarpPedToNearEntityOffScreen), this, warpTo);
  1550  }

  1555  bool CPed::WarpPedToNearLeaderOffScreen() {
  1556:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::WarpPedToNearLeaderOffScreen), this);
  1557  }

  1562  bool CPed::WillChat(CPed *stranger) {
  1563:     return plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CPed *>(gaddrof(CPed::WillChat), this, stranger);
  1564  }

  1569  float CPed::WorkOutHeadingForMovingFirstPerson(float offset) {
  1570:     return plugin::CallMethodAndReturnDynGlobal<float, CPed *, float>(gaddrof(CPed::WorkOutHeadingForMovingFirstPerson), this, offset);
  1571  }

  1576  void CPed::FinishDieAnimCB(CAnimBlendAssociation *association, void *data) {
  1577:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishDieAnimCB), association, data);
  1578  }

  1583  void CPed::FinishFightMoveCB(CAnimBlendAssociation *association, void *data) {
  1584:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishFightMoveCB), association, data);
  1585  }

  1590  void CPed::FinishHitHeadCB(CAnimBlendAssociation *association, void *data) {
  1591:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishHitHeadCB), association, data);
  1592  }

  1597  void CPed::FinishJumpCB(CAnimBlendAssociation *association, void *data) {
  1598:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishJumpCB), association, data);
  1599  }

  1604  void CPed::FinishLaunchCB(CAnimBlendAssociation *association, void *data) {
  1605:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishLaunchCB), association, data);
  1606  }

  1611  void CPed::FinishedAttackCB(CAnimBlendAssociation *association, void *data) {
  1612:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishedAttackCB), association, data);
  1613  }

  1618  void CPed::FinishedWaitCB(CAnimBlendAssociation *association, void *data) {
  1619:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishedWaitCB), association, data);
  1620  }

  1626      CVector ret_pos;
  1627:     plugin::CallDynGlobal<CVector *, CVehicle *, unsigned int, float>(gaddrof(CPed::GetLocalPositionToOpenCarDoor), &ret_pos, vehicle, doorNode, offset);
  1628      return ret_pos;

  1635      CVector ret_pos;
  1636:     plugin::CallDynGlobal<CVector *, CVehicle *, unsigned int>(gaddrof(CPed::GetPositionToOpenCarDoor), &ret_pos, vehicle, doorNode);
  1637      return ret_pos;

  1644      CVector ret_pos;
  1645:     plugin::CallDynGlobal<CVector *, CVehicle *, unsigned int, float>(gaddrof(CPed::GetPositionToOpenCarDoor_), &ret_pos, vehicle, doorNode, offset);
  1646      return ret_pos;

  1666  void CPed::PedAnimAlignCB(CAnimBlendAssociation *association, void *data) {
  1667:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimAlignCB), association, data);
  1668  }

  1673  void CPed::PedAnimDoorCloseCB(CAnimBlendAssociation *association, void *data) {
  1674:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorCloseCB), association, data);
  1675  }

  1680  void CPed::PedAnimDoorCloseRollingCB(CAnimBlendAssociation *association, void *data) {
  1681:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorCloseRollingCB), association, data);
  1682  }

  1687  void CPed::PedAnimDoorOpenCB(CAnimBlendAssociation *association, void *data) {
  1688:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorOpenCB), association, data);
  1689  }

  1694  void CPed::PedAnimGetInCB(CAnimBlendAssociation *association, void *data) {
  1695:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimGetInCB), association, data);
  1696  }

  1701  void CPed::PedAnimPullPedOutCB(CAnimBlendAssociation *association, void *data) {
  1702:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimPullPedOutCB), association, data);
  1703  }

  1708  void CPed::PedAnimStepOutCarCB(CAnimBlendAssociation *association, void *data) {
  1709:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimStepOutCarCB), association, data);
  1710  }

  1715  void CPed::PedEvadeCB(CAnimBlendAssociation *association, void *data) {
  1716:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedEvadeCB), association, data);
  1717  }

  1722  void CPed::PedGetupCB(CAnimBlendAssociation *association, void *data) {
  1723:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedGetupCB), association, data);
  1724  }

  1729  void CPed::PedLandCB(CAnimBlendAssociation *association, void *data) {
  1730:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedLandCB), association, data);
  1731  }

  1736  void CPed::PedSetDraggedOutCarCB(CAnimBlendAssociation *association, void *data) {
  1737:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetDraggedOutCarCB), association, data);
  1738  }

  1743  void CPed::PedSetDraggedOutCarPositionCB(CAnimBlendAssociation *association, void *data) {
  1744:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetDraggedOutCarPositionCB), association, data);
  1745  }

  1750  void CPed::PedSetInCarCB(CAnimBlendAssociation *association, void *data) {
  1751:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetInCarCB), association, data);
  1752  }

  1757  void CPed::PedSetInTrainCB(CAnimBlendAssociation *association, void *data) {
  1758:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetInTrainCB), association, data);
  1759  }

  1764  void CPed::PedSetOutCarCB(CAnimBlendAssociation *association, void *data) {
  1765:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetOutCarCB), association, data);
  1766  }

  1771  void CPed::PedSetOutTrainCB(CAnimBlendAssociation *association, void *data) {
  1772:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetOutTrainCB), association, data);
  1773  }

  1778  void CPed::PedSetQuickDraggedOutCarPositionCB(CAnimBlendAssociation *association, void *data) {
  1779:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetQuickDraggedOutCarPositionCB), association, data);
  1780  }

  1785  void CPed::PedStaggerCB(CAnimBlendAssociation *association, void *data) {
  1786:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedStaggerCB), association, data);
  1787  }

  1792  void CPed::RestoreHeadingRateCB(CAnimBlendAssociation *association, void *data) {
  1793:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::RestoreHeadingRateCB), association, data);
  1794  }

  1813  void FinishFuckUCB(CAnimBlendAssociation *anim, void *data) {
  1814:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(FinishFuckUCB), anim, data);
  1815  }

  1820  void particleProduceFootSplash(CPed *ped, CVector const &pos, float size, int times) {
  1821:     plugin::CallDynGlobal<CPed *, CVector const &, float, int>(gaddrof(particleProduceFootSplash), ped, pos, size, times);
  1822  }

  1827  void particleProduceFootDust(CPed *ped, CVector const &pos, float size, int times) {
  1828:     plugin::CallDynGlobal<CPed *, CVector const &, float, int>(gaddrof(particleProduceFootDust), ped, pos, size, times);
  1829  }

  1834  RwObject *RemoveAllModelCB(RwObject *object, void *data) {
  1835:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(RemoveAllModelCB), object, data);
  1836  }

  1841  void AddYardieDoorSmoke(CVehicle *vehicle, unsigned int doorNode) {
  1842:     plugin::CallDynGlobal<CVehicle *, unsigned int>(gaddrof(AddYardieDoorSmoke), vehicle, doorNode);
  1843  }

  1848  int CheckForPedsOnGroundToAttack(CPed *attacker, CPed **pedOnGround) {
  1849:     return plugin::CallAndReturnDynGlobal<int, CPed *, CPed **>(gaddrof(CheckForPedsOnGroundToAttack), attacker, pedOnGround);
  1850  }

  1855  RwObject *SetPedAtomicVisibilityCB(RwObject *object, void *data) {
  1856:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(SetPedAtomicVisibilityCB), object, data);
  1857  }

  1862  RwFrame *RecurseFrameChildrenVisibilityCB(RwFrame *frame, void *data) {
  1863:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(RecurseFrameChildrenVisibilityCB), frame, data);
  1864  }

  1869  RwObject *CloneAtomicToFrameCB(RwObject *object, void *data) {
  1870:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CloneAtomicToFrameCB), object, data);
  1871  }

  1876  RwFrame *RecurseFrameChildrenToCloneCB(RwFrame *frame, void *data) {
  1877:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(RecurseFrameChildrenToCloneCB), frame, data);
  1878  }

plugin_III\game_III\CPedIK.cpp:
   23  void CPedIK::ExtractYawAndPitchLocal(RwMatrix *matrix, float *yaw, float *pitch) {
   24:     plugin::CallMethodDynGlobal<CPedIK *, RwMatrix *, float *, float *>(gaddrof(CPedIK::ExtractYawAndPitchLocal), this, matrix, yaw, pitch);
   25  }

   30  void CPedIK::ExtractYawAndPitchWorld(RwMatrix *matrix, float *yaw, float *pitch) {
   31:     plugin::CallMethodDynGlobal<CPedIK *, RwMatrix *, float *, float *>(gaddrof(CPedIK::ExtractYawAndPitchWorld), this, matrix, yaw, pitch);
   32  }

   37  void CPedIK::GetComponentPosition(RwV3d &pos, unsigned int node) {
   38:     plugin::CallMethodDynGlobal<CPedIK *, RwV3d &, unsigned int>(gaddrof(CPedIK::GetComponentPosition), this, pos, node);
   39  }

   44  void CPedIK::Init(CPed *ped) {
   45:     plugin::CallMethodDynGlobal<CPedIK *, CPed *>(gaddrof(CPedIK::Init), this, ped);
   46  }

   51  bool CPedIK::LookAtPosition(CVector const &pos) {
   52:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, CVector const &>(gaddrof(CPedIK::LookAtPosition), this, pos);
   53  }

   58  bool CPedIK::LookInDirection(float targetYaw, float targetPitch) {
   59:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::LookInDirection), this, targetYaw, targetPitch);
   60  }

   65  unsigned int CPedIK::MoveLimb(LimbOrientation &limb, float targetYaw, float targetPitch, LimbMovementInfo &moveInfo) {
   66:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CPedIK *, LimbOrientation &, float, float, LimbMovementInfo &>(gaddrof(CPedIK::MoveLimb), this, limb, targetYaw, targetPitch, moveInfo);
   67  }

   72  bool CPedIK::PointGunAtPosition(CVector const &pos) {
   73:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, CVector const &>(gaddrof(CPedIK::PointGunAtPosition), this, pos);
   74  }

   79  bool CPedIK::PointGunInDirection(float targetYaw, float targetPitch) {
   80:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::PointGunInDirection), this, targetYaw, targetPitch);
   81  }

   86  bool CPedIK::PointGunInDirectionUsingArm(float targetYaw, float targetPitch) {
   87:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::PointGunInDirectionUsingArm), this, targetYaw, targetPitch);
   88  }

   93  bool CPedIK::RestoreGunPosn() {
   94:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *>(gaddrof(CPedIK::RestoreGunPosn), this);
   95  }

  100  bool CPedIK::RestoreLookAt() {
  101:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *>(gaddrof(CPedIK::RestoreLookAt), this);
  102  }

  107  void CPedIK::RotateTorso(AnimBlendFrameData *frameData, LimbOrientation &limb, bool changeRoll) {
  108:     plugin::CallMethodDynGlobal<CPedIK *, AnimBlendFrameData *, LimbOrientation &, bool>(gaddrof(CPedIK::RotateTorso), this, frameData, limb, changeRoll);
  109  }

  114  RwMatrix *CPedIK::GetWorldMatrix(RwFrame *frame, RwMatrix *matrix) {
  115:     return plugin::CallAndReturnDynGlobal<RwMatrix *, RwFrame *, RwMatrix *>(gaddrof(CPedIK::GetWorldMatrix), frame, matrix);
  116  }

plugin_III\game_III\CPedModelInfo.cpp:
  25  void CPedModelInfo::DeleteRwObject() {
  26:     plugin::CallVirtualMethod<2, CPedModelInfo *>(this);
  27  }

  32  void CPedModelInfo::SetClump(RpClump *clump) {
  33:     plugin::CallVirtualMethod<6, CPedModelInfo *, RpClump *>(this, clump);
  34  }

  39  void CPedModelInfo::CreateHitColModel() {
  40:     plugin::CallMethodDynGlobal<CPedModelInfo *>(gaddrof(CPedModelInfo::CreateHitColModel), this);
  41  }

  46  void CPedModelInfo::SetLowDetailClump(RpClump *clump) {
  47:     plugin::CallMethodDynGlobal<CPedModelInfo *, RpClump *>(gaddrof(CPedModelInfo::SetLowDetailClump), this, clump);
  48  }

plugin_III\game_III\CPedPath.cpp:
  14  void CPedPath::AddBlockade(CEntity *entity, CPedPathNode(*pathNodes)[40], CVector *posn) {
  15:     plugin::CallDynGlobal<CEntity *, CPedPathNode(*)[40], CVector *>(gaddrof(CPedPath::AddBlockade), entity, pathNodes, posn);
  16  }

  21  void CPedPath::AddBlockadeSectorList(CPtrList *list, CPedPathNode(*pathNodes)[40], CVector *posn) {
  22:     plugin::CallDynGlobal<CPtrList *, CPedPathNode(*)[40], CVector *>(gaddrof(CPedPath::AddBlockadeSectorList), list, pathNodes, posn);
  23  }

  28  void CPedPath::AddNodeToList(CPedPathNode *pNode, short index, CPedPathNode *pList) {
  29:     plugin::CallDynGlobal<CPedPathNode *, short, CPedPathNode *>(gaddrof(CPedPath::AddNodeToList), pNode, index, pList);
  30  }

  35  void CPedPath::AddNodeToPathList(CPedPathNode *pNode, short index, CPedPathNode *pNodeList) {
  36:     plugin::CallDynGlobal<CPedPathNode *, short, CPedPathNode *>(gaddrof(CPedPath::AddNodeToPathList), pNode, index, pNodeList);
  37  }

  42  bool CPedPath::CalcPedRoute(unsigned char pathType, CVector position, CVector destination, CVector *pointPoses, short *pointsFound, short maxPoints) {
  43:     return plugin::CallAndReturnDynGlobal<bool, unsigned char, CVector, CVector, CVector *, short *, short>(gaddrof(CPedPath::CalcPedRoute), pathType, position, destination, pointPoses, pointsFound, maxPoints);
  44  }

  49  void CPedPath::RemoveNodeFromList(CPedPathNode *node) {
  50:     plugin::CallDynGlobal<CPedPathNode *>(gaddrof(CPedPath::RemoveNodeFromList), node);
  51  }

plugin_III\game_III\CPedPlacement.cpp:
  14  void CPedPlacement::FindZCoorForPed(CVector *position) {
  15:     plugin::CallDynGlobal<CVector *>(gaddrof(CPedPlacement::FindZCoorForPed), position);
  16  }

  21  bool CPedPlacement::IsPositionClearForPed(CVector *position) {
  22:     return plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPedPlacement::IsPositionClearForPed), position);
  23  }

  28  CEntity *CPedPlacement::IsPositionClearOfCars(CVector *position) {
  29:     return plugin::CallAndReturnDynGlobal<CEntity *, CVector *>(gaddrof(CPedPlacement::IsPositionClearOfCars), position);
  30  }

plugin_III\game_III\CPedStats.cpp:
  16  unsigned int CPedStats::GetPedStatType(char *name) {
  17:     return plugin::CallAndReturnDynGlobal<unsigned int, char *>(gaddrof(CPedStats::GetPedStatType), name);
  18  }

plugin_III\game_III\CPedType.cpp:
  12  unsigned int CPedType::FindPedFlag(char* flagName) {
  13:     return plugin::CallAndReturn<unsigned int, 0x4EEF40, char*>(flagName);
  14  }

  17  unsigned int CPedType::FindPedType(char* pedName) {
  18:     return plugin::CallAndReturn<unsigned int, 0x4EEC10, char*>(pedName);
  19  }

  22  void CPedType::Initialise() {
  23:     plugin::Call<0x4EE7E0>();
  24  }

  27  void CPedType::Load(unsigned char* bufferPointer, unsigned int structSize) {
  28:     plugin::Call<0x4EF3D0, unsigned char*, unsigned int>(bufferPointer, structSize);
  29  }

  32  void CPedType::LoadPedData() {
  33:     plugin::Call<0x4EE8D0>();
  34  }

  37  void CPedType::Save(unsigned char* bufferPointer, unsigned int* structSize) {
  38:     plugin::Call<0x4EF320, unsigned char*, unsigned int*>(bufferPointer, structSize);
  39  }

  42  void CPedType::Shutdown() {
  43:     plugin::Call<0x4EE890>();
  44  }

plugin_III\game_III\CPhoneInfo.cpp:
   27  int CPhoneInfo::FindNearestFreePhone(CVector *point) {
   28:     return plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, CVector *>(gaddrof(CPhoneInfo::FindNearestFreePhone), this, point);
   29  }

   34  int CPhoneInfo::GrabPhone(float x, float y) {
   35:     return plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, float, float>(gaddrof(CPhoneInfo::GrabPhone), this, x, y);
   36  }

   41  bool CPhoneInfo::HasMessageBeenDisplayed(int index) {
   42:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, int>(gaddrof(CPhoneInfo::HasMessageBeenDisplayed), this, index);
   43  }

   48  void CPhoneInfo::Initialise() {
   49:     plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Initialise), this);
   50  }

   55  bool CPhoneInfo::IsMessageBeingDisplayed(int index) {
   56:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, int>(gaddrof(CPhoneInfo::IsMessageBeingDisplayed), this, index);
   57  }

   62  void CPhoneInfo::Load(unsigned char *buf, unsigned int size) {
   63:     plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int>(gaddrof(CPhoneInfo::Load), this, buf, size);
   64  }

   69  bool CPhoneInfo::PhoneAtThisPosition(CVector point) {
   70:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, CVector>(gaddrof(CPhoneInfo::PhoneAtThisPosition), this, point);
   71  }

   76  void CPhoneInfo::Save(unsigned char *buf, unsigned int *size) {
   77:     plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int *>(gaddrof(CPhoneInfo::Save), this, buf, size);
   78  }

   83  void CPhoneInfo::SetPhoneMessage_JustOnce(int index, wchar_t *text_1, wchar_t *text_2, wchar_t *text_3, wchar_t *text_4, wchar_t *text_5, wchar_t *text_6) {
   84:     plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_JustOnce), this, index, text_1, text_2, text_3, text_4, text_5, text_6);
   85  }

   90  void CPhoneInfo::SetPhoneMessage_Repeatedly(int index, wchar_t *text_1, wchar_t *text_2, wchar_t *text_3, wchar_t *text_4, wchar_t *text_5, wchar_t *text_6) {
   91:     plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_Repeatedly), this, index, text_1, text_2, text_3, text_4, text_5, text_6);
   92  }

   97  void CPhoneInfo::Shutdown() {
   98:     plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Shutdown), this);
   99  }

  104  void CPhoneInfo::Update() {
  105:     plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Update), this);
  106  }

  111  void PhonePickUpCB(CAnimBlendAssociation *association, void *data) {
  112:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(PhonePickUpCB), association, data);
  113  }

  118  void PhonePutDownCB(CAnimBlendAssociation *association, void *data) {
  119:     plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(PhonePutDownCB), association, data);
  120  }

plugin_III\game_III\CPhysical.cpp:
   23  void CPhysical::Add() {
   24:     plugin::CallVirtualMethod<1, CPhysical *>(this);
   25  }

   30  void CPhysical::Remove() {
   31:     plugin::CallVirtualMethod<2, CPhysical *>(this);
   32  }

   37  CRect *CPhysical::GetBoundRect() {
   38:     return plugin::CallVirtualMethodAndReturn<CRect *, 7, CPhysical *>(this);
   39  }

   44  void CPhysical::ProcessControl() {
   45:     plugin::CallVirtualMethod<8, CPhysical *>(this);
   46  }

   51  void CPhysical::ProcessCollision() {
   52:     plugin::CallVirtualMethod<9, CPhysical *>(this);
   53  }

   58  void CPhysical::ProcessShift() {
   59:     plugin::CallVirtualMethod<10, CPhysical *>(this);
   60  }

   65  void CPhysical::ProcessEntityCollision(CEntity *entity, CColPoint *colPoint) {
   66:     plugin::CallVirtualMethod<17, CPhysical *, CEntity *, CColPoint *>(this, entity, colPoint);
   67  }

   72  void CPhysical::AddCollisionRecord(CEntity *entity) {
   73:     plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::AddCollisionRecord), this, entity);
   74  }

   79  void CPhysical::AddCollisionRecord_Treadable(CEntity *entity) {
   80:     plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::AddCollisionRecord_Treadable), this, entity);
   81  }

   86  void CPhysical::AddToMovingList() {
   87:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::AddToMovingList), this);
   88  }

   93  void CPhysical::ApplyAirResistance() {
   94:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyAirResistance), this);
   95  }

  100  bool CPhysical::ApplyCollision(CPhysical *physical, CColPoint &colPoint, float *impulseA, float *impulseB) {
  101:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPhysical *, CColPoint &, float *, float *>(gaddrof(CPhysical::ApplyCollision), this, physical, colPoint, impulseA, impulseB);
  102  }

  107  bool CPhysical::ApplyCollisionAlt(CEntity *entity, CColPoint &colPoint, float *impulse, CVector &moveSpeed, CVector &turnSpeed) {
  108:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CEntity *, CColPoint &, float *, CVector &, CVector &>(gaddrof(CPhysical::ApplyCollisionAlt), this, entity, colPoint, impulse, moveSpeed, turnSpeed);
  109  }

  114  void CPhysical::ApplyFriction() {
  115:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof_o(CPhysical::ApplyFriction, void (CPhysical::*)()), this);
  116  }

  121  bool CPhysical::ApplyFriction(float adhesiveLimit, CColPoint &colPoint) {
  122:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CColPoint &>(gaddrof_o(CPhysical::ApplyFriction, bool (CPhysical::*)(float, CColPoint &)), this, adhesiveLimit, colPoint);
  123  }

  128  bool CPhysical::ApplyFriction(CPhysical *physical, float adhesiveLimit, CColPoint &colPoint) {
  129:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPhysical *, float, CColPoint &>(gaddrof_o(CPhysical::ApplyFriction, bool (CPhysical::*)(CPhysical *, float, CColPoint &)), this, physical, adhesiveLimit, colPoint);
  130  }

  135  void CPhysical::ApplyFrictionMoveForce(float jx, float jy, float jz) {
  136:     plugin::CallMethodDynGlobal<CPhysical *, float, float, float>(gaddrof(CPhysical::ApplyFrictionMoveForce), this, jx, jy, jz);
  137  }

  142  void CPhysical::ApplyFrictionTurnForce(float jx, float jy, float jz, float rx, float ry, float rz) {
  143:     plugin::CallMethodDynGlobal<CPhysical *, float, float, float, float, float, float>(gaddrof(CPhysical::ApplyFrictionTurnForce), this, jx, jy, jz, rx, ry, rz);
  144  }

  149  void CPhysical::ApplyGravity() {
  150:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyGravity), this);
  151  }

  156  void CPhysical::ApplyMoveForce(float jx, float jy, float jz) {
  157:     plugin::CallMethodDynGlobal<CPhysical *, float, float, float>(gaddrof(CPhysical::ApplyMoveForce), this, jx, jy, jz);
  158  }

  163  void CPhysical::ApplyMoveSpeed() {
  164:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyMoveSpeed), this);
  165  }

  170  bool CPhysical::ApplySpringCollisionAlt(float springConst, CVector &springDir, CVector &point, float springRatio, float bias) {
  171:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CVector &, CVector &, float, float>(gaddrof(CPhysical::ApplySpringCollisionAlt), this, springConst, springDir, point, springRatio, bias);
  172  }

  177  bool CPhysical::ApplySpringDampening(float damping, CVector &springDir, CVector &point, CVector &speed) {
  178:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CVector &, CVector &, CVector &>(gaddrof(CPhysical::ApplySpringDampening), this, damping, springDir, point, speed);
  179  }

  184  void CPhysical::ApplyTurnForce(float jx, float jy, float jz, float px, float py, float pz) {
  185:     plugin::CallMethodDynGlobal<CPhysical *, float, float, float, float, float, float>(gaddrof(CPhysical::ApplyTurnForce), this, jx, jy, jz, px, py, pz);
  186  }

  191  void CPhysical::ApplyTurnSpeed() {
  192:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyTurnSpeed), this);
  193  }

  198  bool CPhysical::CheckCollision() {
  199:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *>(gaddrof(CPhysical::CheckCollision), this);
  200  }

  205  bool CPhysical::CheckCollision_SimpleCar() {
  206:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *>(gaddrof(CPhysical::CheckCollision_SimpleCar), this);
  207  }

  212  bool CPhysical::GetHasCollidedWith(CEntity *entity) {
  213:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CEntity *>(gaddrof(CPhysical::GetHasCollidedWith), this, entity);
  214  }

  219  bool CPhysical::ProcessCollisionSectorList(CPtrList *list) {
  220:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPtrList *>(gaddrof(CPhysical::ProcessCollisionSectorList), this, list);
  221  }

  226  bool CPhysical::ProcessCollisionSectorList_SimpleCar(CSector *sector) {
  227:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CSector *>(gaddrof(CPhysical::ProcessCollisionSectorList_SimpleCar), this, sector);
  228  }

  233  bool CPhysical::ProcessShiftSectorList(CPtrList *list) {
  234:     return plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPtrList *>(gaddrof(CPhysical::ProcessShiftSectorList), this, list);
  235  }

  240  void CPhysical::RemoveAndAdd() {
  241:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::RemoveAndAdd), this);
  242  }

  247  void CPhysical::RemoveFromMovingList() {
  248:     plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::RemoveFromMovingList), this);
  249  }

  254  void CPhysical::RemoveRefsToEntity(CEntity *entity) {
  255:     plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::RemoveRefsToEntity), this, entity);
  256  }

  261  void CPhysical::PlacePhysicalRelativeToOtherPhysical(CPhysical *other, CPhysical *physical, CVector localPos) {
  262:     plugin::CallDynGlobal<CPhysical *, CPhysical *, CVector>(gaddrof(CPhysical::PlacePhysicalRelativeToOtherPhysical), other, physical, localPos);
  263  }

plugin_III\game_III\CPickup.cpp:
  21  CObject *CPickup::GiveUsAPickUpObject(int handle) {
  22:     return plugin::CallMethodAndReturnDynGlobal<CObject *, CPickup *, int>(gaddrof(CPickup::GiveUsAPickUpObject), this, handle);
  23  }

  28  bool CPickup::Update(CPlayerPed *player, CVehicle *vehicle, int playerId) {
  29:     return plugin::CallMethodAndReturnDynGlobal<bool, CPickup *, CPlayerPed *, CVehicle *, int>(gaddrof(CPickup::Update), this, player, vehicle, playerId);
  30  }

plugin_III\game_III\CPickups.cpp:
   28  void CPickups::AddToCollectedPickupsArray(int index) {
   29:     plugin::CallDynGlobal<int>(gaddrof(CPickups::AddToCollectedPickupsArray), index);
   30  }

   35  void CPickups::DoCollectableEffects(CEntity *entity) {
   36:     plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoCollectableEffects), entity);
   37  }

   42  void CPickups::DoMineEffects(CEntity *entity) {
   43:     plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoMineEffects), entity);
   44  }

   49  void CPickups::DoMoneyEffects(CEntity *entity) {
   50:     plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoMoneyEffects), entity);
   51  }

   56  void CPickups::DoPickUpEffects(CObject *entity) {
   57:     plugin::CallDynGlobal<CObject *>(gaddrof(CPickups::DoPickUpEffects), entity);
   58  }

   63  int CPickups::FindColourIndexForWeaponMI(int model) {
   64:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::FindColourIndexForWeaponMI), model);
   65  }

   70  int CPickups::GenerateNewOne(CVector pos, unsigned int modelIndex, unsigned char type, unsigned int quantity) {
   71:     return plugin::CallAndReturnDynGlobal<int, CVector, unsigned int, unsigned char, unsigned int>(gaddrof(CPickups::GenerateNewOne), pos, modelIndex, type, quantity);
   72  }

   77  int CPickups::GenerateNewOne_WeaponType(CVector pos, eWeaponType weaponType, unsigned char type, unsigned int quantity) {
   78:     return plugin::CallAndReturnDynGlobal<int, CVector, eWeaponType, unsigned char, unsigned int>(gaddrof(CPickups::GenerateNewOne_WeaponType), pos, weaponType, type, quantity);
   79  }

   84  int CPickups::GetActualPickupIndex(int index) {
   85:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::GetActualPickupIndex), index);
   86  }

   91  int CPickups::GetNewUniquePickupIndex(int handle) {
   92:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::GetNewUniquePickupIndex), handle);
   93  }

   98  bool CPickups::GivePlayerGoodiesWithPickUpMI(unsigned short modelId, int playerId) {
   99:     return plugin::CallAndReturnDynGlobal<bool, unsigned short, int>(gaddrof(CPickups::GivePlayerGoodiesWithPickUpMI), modelId, playerId);
  100  }

  112  bool CPickups::IsPickUpPickedUp(int handle) {
  113:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CPickups::IsPickUpPickedUp), handle);
  114  }

  119  void CPickups::Load(unsigned char *buf, unsigned int size) {
  120:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPickups::Load), buf, size);
  121  }

  126  int CPickups::ModelForWeapon(eWeaponType weaponType) {
  127:     return plugin::CallAndReturnDynGlobal<int, eWeaponType>(gaddrof(CPickups::ModelForWeapon), weaponType);
  128  }

  133  void CPickups::PassTime(unsigned int time) {
  134:     plugin::CallDynGlobal<unsigned int>(gaddrof(CPickups::PassTime), time);
  135  }

  147  void CPickups::RemovePickUp(int handle) {
  148:     plugin::CallDynGlobal<int>(gaddrof(CPickups::RemovePickUp), handle);
  149  }

  161  void CPickups::Save(unsigned char *buf, unsigned int *size) {
  162:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPickups::Save), buf, size);
  163  }

  175  eWeaponType CPickups::WeaponForModel(int model) {
  176:     return plugin::CallAndReturnDynGlobal<eWeaponType, int>(gaddrof(CPickups::WeaponForModel), model);
  177  }

plugin_III\game_III\CPlaceable.cpp:
  23  CVector &CPlaceable::GetPosition() {
  24:     return plugin::CallMethodAndReturnDynGlobal<CVector &, CPlaceable *>(gaddrof(CPlaceable::GetPosition), this);
  25  }

  30  bool CPlaceable::IsWithinArea(float x1, float y1, float x2, float y2) {
  31:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlaceable *, float, float, float, float>(gaddrof_o(CPlaceable::IsWithinArea, bool (CPlaceable::*)(float, float, float, float)), this, x1, y1, x2, y2);
  32  }

  37  bool CPlaceable::IsWithinArea(float x1, float y1, float z1, float x2, float y2, float z2) {
  38:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlaceable *, float, float, float, float, float, float>(gaddrof_o(CPlaceable::IsWithinArea, bool (CPlaceable::*)(float, float, float, float, float, float)), this, x1, y1, z1, x2, y2, z2);
  39  }

  44  void CPlaceable::SetHeading(float angle) {
  45:     plugin::CallMethodDynGlobal<CPlaceable *, float>(gaddrof(CPlaceable::SetHeading), this, angle);
  46  }

  51  void CPlaceable::SetPosition(float x, float y, float z) {
  52:     plugin::CallMethodDynGlobal<CPlaceable *, float, float, float>(gaddrof(CPlaceable::SetPosition), this, x, y, z);
  53  }

plugin_III\game_III\CPlaceName.cpp:
  17  void CPlaceName::Display() {
  18:     plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Display), this);
  19  }

  24  void CPlaceName::Init() {
  25:     plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Init), this);
  26  }

  31  void CPlaceName::Process() {
  32:     plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Process), this);
  33  }

plugin_III\game_III\CPlane.cpp:
   58  void CPlane::SetModelIndex(unsigned int modelIndex) {
   59:     plugin::CallVirtualMethod<3, CPlane *, unsigned int>(this, modelIndex);
   60  }

   65  void CPlane::DeleteRwObject() {
   66:     plugin::CallVirtualMethod<6, CPlane *>(this);
   67  }

   72  void CPlane::ProcessControl() {
   73:     plugin::CallVirtualMethod<8, CPlane *>(this);
   74  }

   79  void CPlane::PreRender() {
   80:     plugin::CallVirtualMethod<12, CPlane *>(this);
   81  }

   86  void CPlane::Render() {
   87:     plugin::CallVirtualMethod<13, CPlane *>(this);
   88  }

   93  void CPlane::FlagToDestroyWhenNextProcessed() {
   94:     plugin::CallVirtualMethod<16, CPlane *>(this);
   95  }

  108      CVector ret_coors;
  109:     plugin::CallDynGlobal<CVector *>(gaddrof(CPlane::FindDropOffCesnaCoordinates), &ret_coors);
  110      return ret_coors;

  117      CVector ret_coors;
  118:     plugin::CallDynGlobal<CVector *>(gaddrof(CPlane::FindDrugPlaneCoordinates), &ret_coors);
  119      return ret_coors;

  125  bool CPlane::HasCesnaBeenDestroyed() {
  126:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasCesnaBeenDestroyed));
  127  }

  132  bool CPlane::HasCesnaLanded() {
  133:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasCesnaLanded));
  134  }

  139  bool CPlane::HasDropOffCesnaBeenShotDown() {
  140:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasDropOffCesnaBeenShotDown));
  141  }

  153  CPlaneNode *CPlane::LoadPath(char const *filename, int *numNodes, float *totalLength, bool loop) {
  154:     return plugin::CallAndReturnDynGlobal<CPlaneNode *, char const *, int *, float *, bool>(gaddrof(CPlane::LoadPath), filename, numNodes, totalLength, loop);
  155  }

  167  bool CPlane::TestRocketCollision(CVector *coors) {
  168:     return plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPlane::TestRocketCollision), coors);
  169  }

plugin_III\game_III\CPlayerInfo.cpp:
   10  void CPlayerInfo::ArrestPlayer() {
   11:     plugin::CallMethod<0x4A1330, CPlayerInfo *>(this);
   12  }

   15  void CPlayerInfo::AwardMoneyForExplosion(CVehicle* vehicle) {
   16:     plugin::CallMethod<0x4A15F0, CPlayerInfo *, CVehicle*>(this, vehicle);
   17  }

   20  void CPlayerInfo::BlowUpRCBuggy() {
   21:     plugin::CallMethod<0x4A15C0, CPlayerInfo *>(this);
   22  }

   25  void CPlayerInfo::CancelPlayerEnteringCars(CVehicle* vehicle) {
   26:     plugin::CallMethod<0x4A13B0, CPlayerInfo *, CVehicle*>(this, vehicle);
   27  }

   30  void CPlayerInfo::Clear() {
   31:     plugin::CallMethod<0x49FC10, CPlayerInfo *>(this);
   32  }

   35  void CPlayerInfo::DeletePlayerSkin() {
   36:     plugin::CallMethod<0x4A1750, CPlayerInfo *>(this);
   37  }

   40  void CPlayerInfo::EvaluateCarPosition(CEntity* entity, CPed* ped, float radius, float* dist, CVehicle** vehicle) {
   41:     plugin::CallMethod<0x4A0EC0, CPlayerInfo *, CEntity*, CPed*, float, float*, CVehicle**>(this, entity, ped, radius, dist, vehicle);
   42  }

   45  void CPlayerInfo::FindClosestCarSectorList(CPtrList& list, CPed* ped, float conrerAX, float cornerAY, float cornerBX, float cornerBY, float* dist, CVehicle** closestCar) {
   46:     plugin::CallMethod<0x4A0CD0, CPlayerInfo *, CPtrList&, CPed*, float, float, float, float, float*, CVehicle**>(this, list, ped, conrerAX, cornerAY, cornerBX, cornerBY, dist, closestCar);
   47  }

   50  CVector* CPlayerInfo::GetPos(CVector* point) {
   51:     return plugin::CallMethodAndReturn<CVector*, 0x4A0FE0, CPlayerInfo *, CVector*>(this, point);
   52  }

   55  bool CPlayerInfo::IsPlayerInRemoteMode() {
   56:     return plugin::CallMethodAndReturn<bool, 0x4A0930, CPlayerInfo *>(this);
   57  }

   60  bool CPlayerInfo::IsRestartingAfterArrest() {
   61:     return plugin::CallMethodAndReturn<bool, 0x4A12C0, CPlayerInfo *>(this);
   62  }

   65  bool CPlayerInfo::IsRestartingAfterDeath() {
   66:     return plugin::CallMethodAndReturn<bool, 0x4A12A0, CPlayerInfo *>(this);
   67  }

   70  void CPlayerInfo::KillPlayer() {
   71:     plugin::CallMethod<0x4A12E0, CPlayerInfo *>(this);
   72  }

   75  void CPlayerInfo::LoadPlayerInfo(unsigned char* bufferPointer, unsigned int structSize) {
   76:     plugin::CallMethod<0x4A0B20, CPlayerInfo *, unsigned char*, unsigned int>(this, bufferPointer, structSize);
   77  }

   80  void CPlayerInfo::LoadPlayerSkin() {
   81:     plugin::CallMethod<0x4A1700, CPlayerInfo *>(this);
   82  }

   85  void CPlayerInfo::MakePlayerSafe(bool safe) {
   86:     plugin::CallMethod<0x4A1400, CPlayerInfo *, bool>(this, safe);
   87  }

   90  void CPlayerInfo::PlayerFailedCriticalMission() {
   91:     plugin::CallMethod<0x4A1380, CPlayerInfo *>(this);
   92  }

   95  void CPlayerInfo::Process() {
   96:     plugin::CallMethod<0x49FD30, CPlayerInfo *>(this);
   97  }

  100  void CPlayerInfo::SavePlayerInfo(unsigned char* bufferPointer, unsigned int* structSize) {
  101:     plugin::CallMethod<0x4A0960, CPlayerInfo *, unsigned char*, unsigned int*>(this, bufferPointer, structSize);
  102  }

  105  void CPlayerInfo::SetPlayerSkin(char const* skinName) {
  106:     plugin::CallMethod<0x4A16D0, CPlayerInfo *, char const*>(this, skinName);
  107  }

  110  CPlayerInfo::~CPlayerInfo() {
  111:     plugin::CallMethod<0x4B5DC0, CPlayerInfo *>(this);
  112  }

plugin_III\game_III\CPlayerPed.cpp:
   23  void CPlayerPed::ProcessControl() {
   24:     plugin::CallVirtualMethod<8, CPlayerPed *>(this);
   25  }

   30  void CPlayerPed::SetMoveAnim() {
   31:     plugin::CallVirtualMethod<18, CPlayerPed *>(this);
   32  }

   37  void CPlayerPed::AnnoyPlayerPed(bool annoyedByPassingEntity) {
   38:     plugin::CallMethodDynGlobal<CPlayerPed *, bool>(gaddrof(CPlayerPed::AnnoyPlayerPed), this, annoyedByPassingEntity);
   39  }

   44  void CPlayerPed::ClearAdrenaline() {
   45:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ClearAdrenaline), this);
   46  }

   51  void CPlayerPed::ClearWeaponTarget() {
   52:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ClearWeaponTarget), this);
   53  }

   58  void CPlayerPed::DoStuffToGoOnFire() {
   59:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::DoStuffToGoOnFire), this);
   60  }

   65  bool CPlayerPed::DoWeaponSmoothSpray() {
   66:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *>(gaddrof(CPlayerPed::DoWeaponSmoothSpray), this);
   67  }

   72  bool CPlayerPed::DoesTargetHaveToBeBroken(CVector target, CWeapon *weapon) {
   73:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CVector, CWeapon *>(gaddrof(CPlayerPed::DoesTargetHaveToBeBroken), this, target, weapon);
   74  }

   79  void CPlayerPed::EvaluateNeighbouringTarget(CEntity *candidate, CEntity **targetPtr, float *lastCloseness, float distLimit, float angleOffset, bool lookToLeft) {
   80:     plugin::CallMethodDynGlobal<CPlayerPed *, CEntity *, CEntity **, float *, float, float, bool>(gaddrof(CPlayerPed::EvaluateNeighbouringTarget), this, candidate, targetPtr, lastCloseness, distLimit, angleOffset, lookToLeft);
   81  }

   86  void CPlayerPed::EvaluateTarget(CEntity *candidate, CEntity **targetPtr, float *lastCloseness, float distLimit, float angleOffset, bool priority) {
   87:     plugin::CallMethodDynGlobal<CPlayerPed *, CEntity *, CEntity **, float *, float, float, bool>(gaddrof(CPlayerPed::EvaluateTarget), this, candidate, targetPtr, lastCloseness, distLimit, angleOffset, priority);
   88  }

   93  bool CPlayerPed::FindNextWeaponLockOnTarget(CEntity *previousTarget, bool lookToLeft) {
   94:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CEntity *, bool>(gaddrof(CPlayerPed::FindNextWeaponLockOnTarget), this, previousTarget, lookToLeft);
   95  }

  100  bool CPlayerPed::FindWeaponLockOnTarget() {
  101:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *>(gaddrof(CPlayerPed::FindWeaponLockOnTarget), this);
  102  }

  107  CPlayerInfo *CPlayerPed::GetPlayerInfoForThisPlayerPed() {
  108:     return plugin::CallMethodAndReturnDynGlobal<CPlayerInfo *, CPlayerPed *>(gaddrof(CPlayerPed::GetPlayerInfoForThisPlayerPed), this);
  109  }

  114  bool CPlayerPed::IsThisPedAttackingPlayer(CPed *ped) {
  115:     return plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CPed *>(gaddrof(CPlayerPed::IsThisPedAttackingPlayer), this, ped);
  116  }

  121  void CPlayerPed::KeepAreaAroundPlayerClear() {
  122:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::KeepAreaAroundPlayerClear), this);
  123  }

  128  void CPlayerPed::MakeChangesForNewWeapon(char weaponType) {
  129:     plugin::CallMethodDynGlobal<CPlayerPed *, char>(gaddrof(CPlayerPed::MakeChangesForNewWeapon), this, weaponType);
  130  }

  135  void CPlayerPed::MakeObjectTargettable(int handle) {
  136:     plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::MakeObjectTargettable), this, handle);
  137  }

  142  void CPlayerPed::PlayerControl1stPersonRunAround(CPad *pad) {
  143:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControl1stPersonRunAround), this, pad);
  144  }

  149  void CPlayerPed::PlayerControlFighter(CPad *pad) {
  150:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlFighter), this, pad);
  151  }

  156  void CPlayerPed::PlayerControlM16(CPad *pad) {
  157:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlM16), this, pad);
  158  }

  163  void CPlayerPed::PlayerControlSniper(CPad *pad) {
  164:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlSniper), this, pad);
  165  }

  170  void CPlayerPed::PlayerControlZelda(CPad *pad) {
  171:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlZelda), this, pad);
  172  }

  177  void CPlayerPed::ProcessAnimGroups() {
  178:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ProcessAnimGroups), this);
  179  }

  184  void CPlayerPed::ProcessPlayerWeapon(CPad *pad) {
  185:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::ProcessPlayerWeapon), this, pad);
  186  }

  191  void CPlayerPed::ProcessWeaponSwitch(CPad *pad) {
  192:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::ProcessWeaponSwitch), this, pad);
  193  }

  198  void CPlayerPed::ReApplyMoveAnims() {
  199:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ReApplyMoveAnims), this);
  200  }

  205  void CPlayerPed::RestoreSprintEnergy(float restoreSpeed) {
  206:     plugin::CallMethodDynGlobal<CPlayerPed *, float>(gaddrof(CPlayerPed::RestoreSprintEnergy), this, restoreSpeed);
  207  }

  212  void CPlayerPed::RunningLand(CPad *pad) {
  213:     plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::RunningLand), this, pad);
  214  }

  219  void CPlayerPed::SetInitialState() {
  220:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::SetInitialState), this);
  221  }

  226  void CPlayerPed::SetRealMoveAnim() {
  227:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::SetRealMoveAnim), this);
  228  }

  233  void CPlayerPed::SetWantedLevel(int level) {
  234:     plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::SetWantedLevel), this, level);
  235  }

  240  void CPlayerPed::SetWantedLevelNoDrop(int level) {
  241:     plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::SetWantedLevelNoDrop), this, level);
  242  }

  247  void CPlayerPed::UseSprintEnergy() {
  248:     plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::UseSprintEnergy), this);
  249  }

  254  void CPlayerPed::DeactivatePlayerPed(int playerId) {
  255:     plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::DeactivatePlayerPed), playerId);
  256  }

  261  void CPlayerPed::ReactivatePlayerPed(int playerId) {
  262:     plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::ReactivatePlayerPed), playerId);
  263  }

  268  void CPlayerPed::SetupPlayerPed(int playerId) {
  269:     plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::SetupPlayerPed), playerId);
  270  }

plugin_III\game_III\CPlayerSkin.cpp:
  32  RwTexture *CPlayerSkin::GetSkinTexture(char const *name) {
  33:     return plugin::CallAndReturnDynGlobal<RwTexture *, char const *>(gaddrof(CPlayerSkin::GetSkinTexture), name);
  34  }

  60  void FindPlayerDff(unsigned int &offset, unsigned int &size) {
  61:     plugin::CallDynGlobal<unsigned int &, unsigned int &>(gaddrof(FindPlayerDff), offset, size);
  62  }

plugin_III\game_III\CPointLights.cpp:
  15  void CPointLights::AddLight(unsigned char lightType, CVector point, CVector direction, float radius, float red, float green, float blue, unsigned char fogType, bool generateExtraShadows) {
  16:     plugin::Call<0x510790, unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool>(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows);
  17  }

  20  float CPointLights::GenerateLightsAffectingObject(CVector* point) {
  21:     return plugin::CallAndReturn<float, 0x510960, CVector*>(point);
  22  }

  25  void CPointLights::RemoveLightsAffectingObject() {
  26:     plugin::Call<0x510C20>();
  27  }

  30  void CPointLights::RenderFogEffect() {
  31:     plugin::Call<0x510C30>();
  32  }

  35  CPointLight::CPointLight() {
  36:     plugin::CallMethod<0x511930, CPointLight *>(this);
  37  }

plugin_III\game_III\CPools.cpp:
   31  CPool<CBuilding> *CPools::GetBuildingPool() {
   32:     return plugin::CallAndReturnDynGlobal<CPool<CBuilding> *>(gaddrof(CPools::GetBuildingPool));
   33  }

   38  int CPools::GetCCutsceneHeadSize() {
   39:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CPools::GetCCutsceneHeadSize));
   40  }

   45  CObject *CPools::GetObject(int handle) {
   46:     return plugin::CallAndReturnDynGlobal<CObject *, int>(gaddrof(CPools::GetObject), handle);
   47  }

   52  CPool<CObject, CCutsceneObject> *CPools::GetObjectPool() {
   53:     return plugin::CallAndReturnDynGlobal<CPool<CObject, CCutsceneObject> *>(gaddrof(CPools::GetObjectPool));
   54  }

   59  int CPools::GetObjectRef(CObject *object) {
   60:     return plugin::CallAndReturnDynGlobal<int, CObject *>(gaddrof(CPools::GetObjectRef), object);
   61  }

   66  CPed *CPools::GetPed(int handle) {
   67:     return plugin::CallAndReturnDynGlobal<CPed *, int>(gaddrof(CPools::GetPed), handle);
   68  }

   73  int CPools::GetPedRef(CPed *ped) {
   74:     return plugin::CallAndReturnDynGlobal<int, CPed *>(gaddrof(CPools::GetPedRef), ped);
   75  }

   80  CVehicle *CPools::GetVehicle(int handle) {
   81:     return plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CPools::GetVehicle), handle);
   82  }

   87  CPool<CVehicle, CAutomobile> *CPools::GetVehiclePool() {
   88:     return plugin::CallAndReturnDynGlobal<CPool<CVehicle, CAutomobile> *>(gaddrof(CPools::GetVehiclePool));
   89  }

   94  int CPools::GetVehicleRef(CVehicle *vehicle) {
   95:     return plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CPools::GetVehicleRef), vehicle);
   96  }

  108  void CPools::LoadObjectPool(unsigned char *buffer, unsigned int size) {
  109:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadObjectPool), buffer, size);
  110  }

  115  void CPools::LoadPedPool(unsigned char *buffer, unsigned int size) {
  116:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadPedPool), buffer, size);
  117  }

  122  void CPools::LoadVehiclePool(unsigned char *buffer, unsigned int size) {
  123:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadVehiclePool), buffer, size);
  124  }

  129  void CPools::MakeSureSlotInObjectPoolIsEmpty(int slot) {
  130:     plugin::CallDynGlobal<int>(gaddrof(CPools::MakeSureSlotInObjectPoolIsEmpty), slot);
  131  }

  136  void CPools::SaveObjectPool(unsigned char *buffer, unsigned int *outSize) {
  137:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveObjectPool), buffer, outSize);
  138  }

  143  void CPools::SavePedPool(unsigned char *buffer, unsigned int *outSize) {
  144:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SavePedPool), buffer, outSize);
  145  }

  150  void CPools::SaveVehiclePool(unsigned char *buffer, unsigned int *outSize) {
  151:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveVehiclePool), buffer, outSize);
  152  }

plugin_III\game_III\CPopulation.cpp:
   45  CPed *CPopulation::AddPed(ePedType pedType, unsigned int modelIndexOrCopType, CVector const &coors) {
   46:     return plugin::CallAndReturnDynGlobal<CPed *, ePedType, unsigned int, CVector const &>(gaddrof(CPopulation::AddPed), pedType, modelIndexOrCopType, coors);
   47  }

   52  CPed *CPopulation::AddPedInCar(CVehicle *vehicle) {
   53:     return plugin::CallAndReturnDynGlobal<CPed *, CVehicle *>(gaddrof(CPopulation::AddPedInCar), vehicle);
   54  }

   59  void CPopulation::AddToPopulation(float minDist, float maxDist, float minDistOffScreen, float maxDistOffScreen) {
   60:     plugin::CallDynGlobal<float, float, float, float>(gaddrof(CPopulation::AddToPopulation), minDist, maxDist, minDistOffScreen, maxDistOffScreen);
   61  }

   66  int CPopulation::ChooseCivilianOccupation(int group) {
   67:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPopulation::ChooseCivilianOccupation), group);
   68  }

   73  int CPopulation::ChooseGangOccupation(int gangId) {
   74:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPopulation::ChooseGangOccupation), gangId);
   75  }

   80  eCopType CPopulation::ChoosePolicePedOccupation() {
   81:     return plugin::CallAndReturnDynGlobal<eCopType>(gaddrof(CPopulation::ChoosePolicePedOccupation));
   82  }

   94  void CPopulation::ConvertToDummyObject(CObject *object) {
   95:     plugin::CallDynGlobal<CObject *>(gaddrof(CPopulation::ConvertToDummyObject), object);
   96  }

  101  void CPopulation::ConvertToRealObject(CDummyObject *dummy) {
  102:     plugin::CallDynGlobal<CDummyObject *>(gaddrof(CPopulation::ConvertToRealObject), dummy);
  103  }

  108  void CPopulation::DealWithZoneChange(eLevelName oldLevel, eLevelName newLevel, bool forceIndustrialZone) {
  109:     plugin::CallDynGlobal<eLevelName, eLevelName, bool>(gaddrof(CPopulation::DealWithZoneChange), oldLevel, newLevel, forceIndustrialZone);
  110  }

  115  void CPopulation::FindClosestZoneForCoors(CVector *coors, int *safeZoneOut, eLevelName level1, eLevelName level2) {
  116:     plugin::CallDynGlobal<CVector *, int *, eLevelName, eLevelName>(gaddrof(CPopulation::FindClosestZoneForCoors), coors, safeZoneOut, level1, level2);
  117  }

  122  void CPopulation::FindCollisionZoneForCoors(CVector *coors, int *safeZoneOut, eLevelName *levelOut) {
  123:     plugin::CallDynGlobal<CVector *, int *, eLevelName *>(gaddrof(CPopulation::FindCollisionZoneForCoors), coors, safeZoneOut, levelOut);
  124  }

  143  bool CPopulation::IsPointInSafeZone(CVector *coors) {
  144:     return plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPopulation::IsPointInSafeZone), coors);
  145  }

  171  float CPopulation::PedCreationDistMultiplier() {
  172:     return plugin::CallAndReturnDynGlobal<float>(gaddrof(CPopulation::PedCreationDistMultiplier));
  173  }

  178  void CPopulation::RemovePed(CPed *ped) {
  179:     plugin::CallDynGlobal<CPed *>(gaddrof(CPopulation::RemovePed), ped);
  180  }

  185  bool CPopulation::TestRoomForDummyObject(CObject *object) {
  186:     return plugin::CallAndReturnDynGlobal<bool, CObject *>(gaddrof(CPopulation::TestRoomForDummyObject), object);
  187  }

  192  bool CPopulation::TestSafeForRealObject(CDummyObject *dummy) {
  193:     return plugin::CallAndReturnDynGlobal<bool, CDummyObject *>(gaddrof(CPopulation::TestSafeForRealObject), dummy);
  194  }

  206  void CPopulation::UpdatePedCount(ePedType pedType, bool decrease) {
  207:     plugin::CallDynGlobal<ePedType, bool>(gaddrof(CPopulation::UpdatePedCount), pedType, decrease);
  208  }

plugin_III\game_III\CProjectileInfo.cpp:
  13  bool CProjectileInfo::AddProjectile(CEntity* creator, eWeaponType weaponType, CVector posn, float force) {
  14:     return plugin::CallAndReturn<bool, 0x55B030, CEntity*, eWeaponType, CVector, float>(creator, weaponType, posn, force);
  15  }

  18  CProjectileInfo::CProjectileInfo() {
  19:     plugin::CallMethod<0x55BC50, CProjectileInfo *>(this);
  20  }

  23  CProjectileInfo* CProjectileInfo::GetProjectileInfo(int index) {
  24:     return plugin::CallAndReturn<CProjectileInfo*, 0x55B010, int>(index);
  25  }

  28  void CProjectileInfo::Initialise() {
  29:     plugin::Call<0x55ADF0>();
  30  }

  33  bool CProjectileInfo::IsProjectileInRange(float x1, float y1, float z1, float x2, float y2, float z2, bool bDestroy) {
  34:     return plugin::CallAndReturn<bool, 0x55BA50, float, float, float, float, float, float, bool>(x1, y1, z1, x2, y2, z2, bDestroy);
  35  }

  38  void CProjectileInfo::RemoveAllProjectiles() {
  39:     plugin::Call<0x55BB80>();
  40  }

  43  bool CProjectileInfo::RemoveIfThisIsAProjectile(CObject* object) {
  44:     return plugin::CallAndReturn<bool, 0x55BBD0, CObject*>(object);
  45  }

  48  void CProjectileInfo::RemoveNotAdd(CEntity* creator, eWeaponType weaponType, CVector posn) {
  49:     plugin::Call<0x55B770, CEntity*, eWeaponType, CVector>(creator, weaponType, posn);
  50  }

  53  void CProjectileInfo::RemoveProjectile(CProjectileInfo* info, CProjectile* projectileObject) {
  54:     plugin::Call<0x55B700, CProjectileInfo*, CProjectile*>(info, projectileObject);
  55  }

  58  void CProjectileInfo::Shutdown() {
  59:     plugin::Call<0x55AFF0>();
  60  }

  63  void CProjectileInfo::Update() {
  64:     plugin::Call<0x55B7C0>();
  65  }

plugin_III\game_III\CQuaternion.cpp:
  14  void CQuaternion::Get(RwMatrix *matrix) {
  15:     plugin::CallMethodDynGlobal<CQuaternion *, RwMatrix *>(gaddrof(CQuaternion::Get), this, matrix);
  16  }

  21  void CQuaternion::Slerp(CQuaternion const &from, CQuaternion const &to, float halftheta, float sintheta_inv, float t) {
  22:     plugin::CallMethodDynGlobal<CQuaternion *, CQuaternion const &, CQuaternion const &, float, float, float>(gaddrof(CQuaternion::Slerp), this, from, to, halftheta, sintheta_inv, t);
  23  }

plugin_III\game_III\CRadar.cpp:
   41  unsigned char CRadar::CalculateBlipAlpha(float distance) {
   42:     return plugin::CallAndReturnDynGlobal<unsigned char, float>(gaddrof(CRadar::CalculateBlipAlpha), distance);
   43  }

   48  void CRadar::ChangeBlipBrightness(int i, int bright) {
   49:     plugin::CallDynGlobal<int, int>(gaddrof(CRadar::ChangeBlipBrightness), i, bright);
   50  }

   55  void CRadar::ChangeBlipColour(int i, unsigned int colour) {
   56:     plugin::CallDynGlobal<int, unsigned int>(gaddrof(CRadar::ChangeBlipColour), i, colour);
   57  }

   62  void CRadar::ChangeBlipDisplay(int i, eBlipDisplay display) {
   63:     plugin::CallDynGlobal<int, eBlipDisplay>(gaddrof(CRadar::ChangeBlipDisplay), i, display);
   64  }

   69  void CRadar::ChangeBlipScale(int i, int scale) {
   70:     plugin::CallDynGlobal<int, int>(gaddrof(CRadar::ChangeBlipScale), i, scale);
   71  }

   76  void CRadar::ClearBlip(int i) {
   77:     plugin::CallDynGlobal<int>(gaddrof(CRadar::ClearBlip), i);
   78  }

   83  void CRadar::ClearBlipForEntity(eBlipType type, int handle) {
   84:     plugin::CallDynGlobal<eBlipType, int>(gaddrof(CRadar::ClearBlipForEntity), type, handle);
   85  }

   90  int CRadar::ClipRadarPoly(CVector2D *out, CVector2D const *in) {
   91:     return plugin::CallAndReturnDynGlobal<int, CVector2D *, CVector2D const *>(gaddrof(CRadar::ClipRadarPoly), out, in);
   92  }

  132  void CRadar::DrawRadarSection(int x, int y) {
  133:     plugin::CallDynGlobal<int, int>(gaddrof(CRadar::DrawRadarSection), x, y);
  134  }

  139  void CRadar::DrawRadarSprite(unsigned short sprite, float x, float y, unsigned char alpha) {
  140:     plugin::CallDynGlobal<unsigned short, float, float, unsigned char>(gaddrof(CRadar::DrawRadarSprite), sprite, x, y, alpha);
  141  }

  146  void CRadar::DrawRotatingRadarSprite(CSprite2d *sprite, float x, float y, float angle, unsigned char alpha) {
  147:     plugin::CallDynGlobal<CSprite2d *, float, float, float, unsigned char>(gaddrof(CRadar::DrawRotatingRadarSprite), sprite, x, y, angle, alpha);
  148  }

  153  int CRadar::GetActualBlipArrayIndex(int i) {
  154:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CRadar::GetActualBlipArrayIndex), i);
  155  }

  160  int CRadar::GetNewUniqueBlipIndex(int i) {
  161:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CRadar::GetNewUniqueBlipIndex), i);
  162  }

  167  unsigned int CRadar::GetRadarTraceColour(unsigned int colour, bool bright) {
  168:     return plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, bool>(gaddrof(CRadar::GetRadarTraceColour), colour, bright);
  169  }

  181  float CRadar::LimitRadarPoint(CVector2D &point) {
  182:     return plugin::CallAndReturnDynGlobal<float, CVector2D &>(gaddrof(CRadar::LimitRadarPoint), point);
  183  }

  188  void CRadar::LoadAllRadarBlips(unsigned char *buf, unsigned int size) {
  189:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CRadar::LoadAllRadarBlips), buf, size);
  190  }

  209  void CRadar::SaveAllRadarBlips(unsigned char *buf, unsigned int *size) {
  210:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CRadar::SaveAllRadarBlips), buf, size);
  211  }

  216  void CRadar::SetBlipSprite(int i, int icon) {
  217:     plugin::CallDynGlobal<int, int>(gaddrof(CRadar::SetBlipSprite), i, icon);
  218  }

  223  int CRadar::SetCoordBlip(eBlipType type, CVector pos, unsigned int colour, eBlipDisplay display) {
  224:     return plugin::CallAndReturnDynGlobal<int, eBlipType, CVector, unsigned int, eBlipDisplay>(gaddrof(CRadar::SetCoordBlip), type, pos, colour, display);
  225  }

  230  void CRadar::SetEntityBlip(eBlipType type, int handle, unsigned int colour, eBlipDisplay display) {
  231:     plugin::CallDynGlobal<eBlipType, int, unsigned int, eBlipDisplay>(gaddrof(CRadar::SetEntityBlip), type, handle, colour, display);
  232  }

  237  void CRadar::SetRadarMarkerState(int i, unsigned char flag) {
  238:     plugin::CallDynGlobal<int, unsigned char>(gaddrof(CRadar::SetRadarMarkerState), i, flag);
  239  }

  244  void CRadar::ShowRadarMarker(CVector pos, unsigned int colour, float radius) {
  245:     plugin::CallDynGlobal<CVector, unsigned int, float>(gaddrof(CRadar::ShowRadarMarker), pos, colour, radius);
  246  }

  251  void CRadar::ShowRadarTrace(float x, float y, unsigned int size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) {
  252:     plugin::CallDynGlobal<float, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char>(gaddrof(CRadar::ShowRadarTrace), x, y, size, red, green, blue, alpha);
  253  }

  265  void CRadar::StreamRadarSections(int x, int y) {
  266:     plugin::CallDynGlobal<int, int>(gaddrof_o(CRadar::StreamRadarSections, void (*)(int, int)), x, y);
  267  }

  272  void CRadar::StreamRadarSections(CVector const &pos) {
  273:     plugin::CallDynGlobal<CVector const &>(gaddrof_o(CRadar::StreamRadarSections, void (*)(CVector const &)), pos);
  274  }

  279  void CRadar::TransformRadarPointToRealWorldSpace(CVector2D &out, CVector2D const &in) {
  280:     plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRadarPointToRealWorldSpace), out, in);
  281  }

  286  void CRadar::TransformRadarPointToScreenSpace(CVector2D &out, CVector2D const &in) {
  287:     plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRadarPointToScreenSpace), out, in);
  288  }

  293  void CRadar::TransformRealWorldPointToRadarSpace(CVector2D &out, CVector2D const &in) {
  294:     plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRealWorldPointToRadarSpace), out, in);
  295  }

  300  void CRadar::TransformRealWorldToTexCoordSpace(CVector2D &out, CVector2D const &in, int x, int y) {
  301:     plugin::CallDynGlobal<CVector2D &, CVector2D const &, int, int>(gaddrof(CRadar::TransformRealWorldToTexCoordSpace), out, in, x, y);
  302  }

  310  void ClipRadarTileCoords(int &x, int &y) {
  311:     plugin::CallDynGlobal<int &, int &>(gaddrof(ClipRadarTileCoords), x, y);
  312  }

  317  void RequestMapSection(int x, int y) {
  318:     plugin::CallDynGlobal<int, int>(gaddrof(RequestMapSection), x, y);
  319  }

  324  void RemoveMapSection(int x, int y) {
  325:     plugin::CallDynGlobal<int, int>(gaddrof(RemoveMapSection), x, y);
  326  }

  331  bool IsPointInsideRadar(CVector2D const &point) {
  332:     return plugin::CallAndReturnDynGlobal<bool, CVector2D const &>(gaddrof(IsPointInsideRadar), point);
  333  }

  338  void GetTextureCorners(int x, int y, CVector2D *out) {
  339:     plugin::CallDynGlobal<int, int, CVector2D *>(gaddrof(GetTextureCorners), x, y, out);
  340  }

  345  int LineRadarBoxCollision(CVector2D &out, CVector2D const &lineStart, CVector2D const &lineEnd) {
  346:     return plugin::CallAndReturnDynGlobal<int, CVector2D &, CVector2D const &, CVector2D const &>(gaddrof(LineRadarBoxCollision), out, lineStart, lineEnd);
  347  }

plugin_III\game_III\CRange2D.cpp:
  14  CVector2D *CRange2D::GetRandomPointInRange() {
  15:     return plugin::CallMethodAndReturnDynGlobal<CVector2D *, CRange2D *>(gaddrof(CRange2D::GetRandomPointInRange), this);
  16  }

plugin_III\game_III\CRecordDataForChase.cpp:
   38  void CRecordDataForChase::GiveUsACar(int modelIndex, CVector pos, float angleZ, CAutomobile **pCar, unsigned char prim, unsigned char sec) {
   39:     plugin::CallDynGlobal<int, CVector, float, CAutomobile **, unsigned char, unsigned char>(gaddrof(CRecordDataForChase::GiveUsACar), modelIndex, pos, angleZ, pCar, prim, sec);
   40  }

   59  void CRecordDataForChase::RemoveCarFromChase(int index) {
   60:     plugin::CallDynGlobal<int>(gaddrof(CRecordDataForChase::RemoveCarFromChase), index);
   61  }

   66  void CRecordDataForChase::RestoreInfoForCar(CAutomobile *car, CCarStateEachFrame *carState, bool stop) {
   67:     plugin::CallDynGlobal<CAutomobile *, CCarStateEachFrame *, bool>(gaddrof(CRecordDataForChase::RestoreInfoForCar), car, carState, stop);
   68  }

   73  void CRecordDataForChase::RestoreInfoForMatrix(CMatrix &matrix, CCarStateEachFrame *carState) {
   74:     plugin::CallDynGlobal<CMatrix &, CCarStateEachFrame *>(gaddrof(CRecordDataForChase::RestoreInfoForMatrix), matrix, carState);
   75  }

  101  void CRecordDataForChase::StartChaseScene(float startTime) {
  102:     plugin::CallDynGlobal<float>(gaddrof(CRecordDataForChase::StartChaseScene), startTime);
  103  }

  108  void CRecordDataForChase::StoreInfoForCar(CAutomobile *car, CCarStateEachFrame *carState) {
  109:     plugin::CallDynGlobal<CAutomobile *, CCarStateEachFrame *>(gaddrof(CRecordDataForChase::StoreInfoForCar), car, carState);
  110  }

  115  CVehicle *CRecordDataForChase::TurnChaseCarIntoScriptCar(int index) {
  116:     return plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CRecordDataForChase::TurnChaseCarIntoScriptCar), index);
  117  }

plugin_III\game_III\CRecordDataForGame.cpp:
  20  unsigned short CRecordDataForGame::CalcGameChecksum() {
  21:     return plugin::CallAndReturnDynGlobal<unsigned short>(gaddrof(CRecordDataForGame::CalcGameChecksum));
  22  }

  34  unsigned char *CRecordDataForGame::PackCurrentPadValues(unsigned char *buf, CControllerState *os, CControllerState *ns) {
  35:     return plugin::CallAndReturnDynGlobal<unsigned char *, unsigned char *, CControllerState *, CControllerState *>(gaddrof(CRecordDataForGame::PackCurrentPadValues), buf, os, ns);
  36  }

  48  unsigned char *CRecordDataForGame::UnPackCurrentPadValues(unsigned char *buf, unsigned char total, CControllerState *state) {
  49:     return plugin::CallAndReturnDynGlobal<unsigned char *, unsigned char *, unsigned char, CControllerState *>(gaddrof(CRecordDataForGame::UnPackCurrentPadValues), buf, total, state);
  50  }

plugin_III\game_III\CRegisteredCorona.cpp:
  17  void CRegisteredCorona::Update() {
  18:     plugin::CallMethodDynGlobal<CRegisteredCorona *>(gaddrof(CRegisteredCorona::Update), this);
  19  }

plugin_III\game_III\CRegisteredMotionBlurStreak.cpp:
  20  void CRegisteredMotionBlurStreak::Render() {
  21:     plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(gaddrof(CRegisteredMotionBlurStreak::Render), this);
  22  }

  27  void CRegisteredMotionBlurStreak::Update() {
  28:     plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(gaddrof(CRegisteredMotionBlurStreak::Update), this);
  29  }

plugin_III\game_III\CRemote.cpp:
  14  void CRemote::GivePlayerRemoteControlledCar(float x, float y, float z, float angle, unsigned short modelIndex) {
  15:     plugin::CallDynGlobal<float, float, float, float, unsigned short>(gaddrof(CRemote::GivePlayerRemoteControlledCar), x, y, z, angle, modelIndex);
  16  }

plugin_III\game_III\CRestart.cpp:
  28  void CRestart::AddHospitalRestartPoint(CVector const &pos, float heading) {
  29:     plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::AddHospitalRestartPoint), pos, heading);
  30  }

  35  void CRestart::AddPoliceRestartPoint(CVector const &pos, float heading) {
  36:     plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::AddPoliceRestartPoint), pos, heading);
  37  }

  49  void CRestart::FindClosestHospitalRestartPoint(CVector const &pos, CVector *outPos, float *outHeading) {
  50:     plugin::CallDynGlobal<CVector const &, CVector *, float *>(gaddrof(CRestart::FindClosestHospitalRestartPoint), pos, outPos, outHeading);
  51  }

  56  void CRestart::FindClosestPoliceRestartPoint(CVector const &pos, CVector *outPos, float *outHeading) {
  57:     plugin::CallDynGlobal<CVector const &, CVector *, float *>(gaddrof(CRestart::FindClosestPoliceRestartPoint), pos, outPos, outHeading);
  58  }

  70  void CRestart::LoadAllRestartPoints(unsigned char *buf, unsigned int size) {
  71:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CRestart::LoadAllRestartPoints), buf, size);
  72  }

  77  void CRestart::OverrideNextRestart(CVector const &pos, float heading) {
  78:     plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::OverrideNextRestart), pos, heading);
  79  }

  84  void CRestart::SaveAllRestartPoints(unsigned char *buf, unsigned int *size) {
  85:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CRestart::SaveAllRestartPoints), buf, size);
  86  }

plugin_III\game_III\CRoadBlocks.cpp:
  18  void CRoadBlocks::GenerateRoadBlockCopsForCar(CVehicle *vehicle, int roadBlockType, short roadBlockNode) {
  19:     plugin::CallDynGlobal<CVehicle *, int, short>(gaddrof(CRoadBlocks::GenerateRoadBlockCopsForCar), vehicle, roadBlockType, roadBlockNode);
  20  }

plugin_III\game_III\CRouteNode.cpp:
  19  void CRouteNode::AddRoutePoint(short route, CVector pos) {
  20:     plugin::CallDynGlobal<short, CVector>(gaddrof(CRouteNode::AddRoutePoint), route, pos);
  21  }

  27      CVector ret_pos;
  28:     plugin::CallDynGlobal<CVector *, short>(gaddrof(CRouteNode::GetPointPosition), &ret_pos, point);
  29      return ret_pos;

  35  short CRouteNode::GetRouteStart(short route) {
  36:     return plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteStart), route);
  37  }

  42  short CRouteNode::GetRouteThisPointIsOn(short point) {
  43:     return plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteThisPointIsOn), point);
  44  }

  56  void CRouteNode::RemoveRoute(short route) {
  57:     plugin::CallDynGlobal<short>(gaddrof(CRouteNode::RemoveRoute), route);
  58  }

plugin_III\game_III\CRubbish.cpp:
  43  void CRubbish::SetVisibility(bool visible) {
  44:     plugin::CallDynGlobal<bool>(gaddrof(CRubbish::SetVisibility), visible);
  45  }

  57  void CRubbish::StirUp(CVehicle *vehicle) {
  58:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CRubbish::StirUp), vehicle);
  59  }

plugin_III\game_III\CRunningScript.cpp:
  11  void CRunningScript::Init() {
  12:     plugin::CallMethod<0x4386C0, CRunningScript *>(this);
  13  }

  16  char CRunningScript::ProcessOneCommand() {
  17:     return plugin::CallMethodAndReturn<char, 0x439500, CRunningScript *>(this);
  18  }

  21  void CRunningScript::CollectParameters(int* arg0, short count) {
  22:     plugin::CallMethod<0x4382E0, CRunningScript *, int*, short>(this, arg0, count);
  23  }

  26  void CRunningScript::UpdateCompareFlag(unsigned char flag) {
  27:     plugin::CallMethod<0x44FD90, CRunningScript *, unsigned char>(this, flag);
  28  }

plugin_III\game_III\CSceneEdit.cpp:
   39  void CSceneEdit::LoadMovie() {
   40:     plugin::Call<0x5850A0>();
   41  }

   44  void CSceneEdit::SaveMovie() {
   45:     plugin::Call<0x585110>();
   46  }

   49  void CSceneEdit::Initialise() {
   50:     plugin::Call<0x585170>();
   51  }

   54  void CSceneEdit::InitPlayBack() {
   55:     plugin::Call<0x5852C0>();
   56  }

   59  void CSceneEdit::ReInitialise() {
   60:     plugin::Call<0x5853F0>();
   61  }

   64  void CSceneEdit::Update() {
   65:     plugin::Call<0x585570>();
   66  }

   69  void CSceneEdit::Draw() {
   70:     plugin::Call<0x5855F0>();
   71  }

   74  void CSceneEdit::ProcessCommand() {
   75:     plugin::Call<0x585BB0>();
   76  }

   79  void CSceneEdit::PlayBack() {
   80:     plugin::Call<0x587200>();
   81  }

   84  void CSceneEdit::ClearForNewCommand() {
   85:     plugin::Call<0x587AF0>();
   86  }

   89  bool CSceneEdit::SelectActor() {
   90:     return plugin::CallAndReturn<bool, 0x587B30>();
   91  }

   94  bool CSceneEdit::SelectActor2() {
   95:     return plugin::CallAndReturn<bool, 0x587DC0>();
   96  }

   99  bool CSceneEdit::SelectVehicle() {
  100:     return plugin::CallAndReturn<bool, 0x588040>();
  101  }

  104  bool CSceneEdit::SelectWeapon() {
  105:     return plugin::CallAndReturn<bool, 0x588220>();
  106  }

  109  int NextValidModelId(int currentModelIndex, int PrevOrNextModelIndex) {
  110:     return plugin::CallAndReturn<int, 0x585050, int, int>(currentModelIndex, PrevOrNextModelIndex);
  111  }

plugin_III\game_III\CScrollBar.cpp:
  17  void CScrollBar::Init(CVector pos, unsigned char type, float sizeX, float sizeY, float sizeZ, unsigned char red, unsigned char green, unsigned char blue, float scale) {
  18:     plugin::CallMethodDynGlobal<CScrollBar *, CVector, unsigned char, float, float, float, unsigned char, unsigned char, unsigned char, float>(gaddrof(CScrollBar::Init), this, pos, type, sizeX, sizeY, sizeZ, red, green, blue, scale);
  19  }

  24  void CScrollBar::Render() {
  25:     plugin::CallMethodDynGlobal<CScrollBar *>(gaddrof(CScrollBar::Render), this);
  26  }

  31  void CScrollBar::Update() {
  32:     plugin::CallMethodDynGlobal<CScrollBar *>(gaddrof(CScrollBar::Update), this);
  33  }

  38  char const *CScrollBar::GetBridgeString() {
  39:     return plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CScrollBar::GetBridgeString));
  40  }

  45  char const *CScrollBar::GetTunnelString() {
  46:     return plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CScrollBar::GetTunnelString));
  47  }

plugin_III\game_III\CShadows.cpp:
   32  CPermanentShadow::CPermanentShadow() {
   33:     plugin::CallMethod<0x517900, CPermanentShadow *>(this);
   34  }

   37  CStaticShadow::CStaticShadow() {
   38:     plugin::CallMethod<0x517910, CStaticShadow *>(this);
   39  }

   42  void CStaticShadow::Free() {
   43:     plugin::CallMethod<0x516E70, CStaticShadow *>(this);
   44  }

   47  CPolyBunch::CPolyBunch() {
   48:     plugin::CallMethod<0x517920, CPolyBunch *>(this);
   49  }

   52  CRegisteredShadow::CRegisteredShadow() {
   53:     plugin::CallMethod<0x517940, CRegisteredShadow *>(this);
   54  }

   57  void CShadows::RenderIndicatorShadow(unsigned int id, unsigned char shadowType, RwTexture* texture, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity) {
   58:     plugin::Call<0x517810, unsigned int, unsigned char, RwTexture*, CVector*, float, float, float, float, short>(id, shadowType, texture, posn, frontX, frontY, sideX, sideY, intensity);
   59  }

   62  void CShadows::Init() {
   63:     plugin::Call<0x512AB0>();
   64  }

   67  void CShadows::Shutdown() {
   68:     plugin::Call<0x512F20>();
   69  }

   72  void CShadows::AddPermanentShadow(unsigned char type, RwTexture* texture, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity, unsigned char red, unsigned char green, unsigned char blue, float zDistance, unsigned int time, float upDistance) {
   73:     plugin::Call<0x512FD0, unsigned char, RwTexture*, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, unsigned int, float>(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, time, upDistance);
   74  }

   77  void CShadows::StoreStaticShadow(unsigned int id, unsigned char type, RwTexture* texture, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity, unsigned char red, unsigned char green, unsigned char blue, float zDistance, float scale, float drawDistance, bool temporaryShadow, float upDistance) {
   78:     plugin::Call<0x5130A0, unsigned int, unsigned char, RwTexture*, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, float, bool, float>(id, type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, drawDistance, temporaryShadow, upDistance);
   79  }

   82  void CShadows::StoreShadowToBeRendered(unsigned char shadowTextureType, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity, unsigned char red, unsigned char green, unsigned char blue) {
   83:     plugin::Call<0x513550, unsigned char, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char>(shadowTextureType, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue);
   84  }

   87  void CShadows::StoreShadowToBeRendered(unsigned char type, RwTexture* texture, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity, unsigned char red, unsigned char green, unsigned char blue, float zDistance, bool drawOnWater, float scale) {
   88:     plugin::Call<0x513750, unsigned char, RwTexture*, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, bool, float>(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, drawOnWater, scale);
   89  }

   92  void CShadows::StoreShadowForCar(CAutomobile* car) {
   93:     plugin::Call<0x513830, CAutomobile*>(car);
   94  }

   97  void CShadows::StoreCarLightShadow(CVehicle* vehicle, int id, RwTexture* texture, CVector* posn, float frontX, float frontY, float sideX, float sideY, unsigned char red, unsigned char green, unsigned char blue, float maxViewAngle) {
   98:     plugin::Call<0x513A70, CVehicle*, int, RwTexture*, CVector*, float, float, float, float, unsigned char, unsigned char, unsigned char, float>(vehicle, id, texture, posn, frontX, frontY, sideX, sideY, red, green, blue, maxViewAngle);
   99  }

  102  void CShadows::StoreShadowForPed(CPed* ped, float displacementX, float displacementY, float frontX, float frontY, float sideX, float sideY) {
  103:     plugin::Call<0x513C50, CPed*, float, float, float, float, float, float>(ped, displacementX, displacementY, frontX, frontY, sideX, sideY);
  104  }

  107  void CShadows::StoreShadowForPedObject(CEntity* entity, float displacementX, float displacementY, float frontX, float frontY, float sideX, float sideY) {
  108:     plugin::Call<0x513CB0, CEntity*, float, float, float, float, float, float>(entity, displacementX, displacementY, frontX, frontY, sideX, sideY);
  109  }

  112  void CShadows::StoreShadowForTree(CEntity* entity) {
  113:     plugin::Call<0x513E00, CEntity*>(entity);
  114  }

  117  void CShadows::StoreShadowForPole(CEntity* entity, float offsetX, float offsetY, float offsetZ, float poleHeight, float poleWidth, unsigned int localId) {
  118:     plugin::Call<0x513E10, CEntity*, float, float, float, float, float, unsigned int>(entity, offsetX, offsetY, offsetZ, poleHeight, poleWidth, localId);
  119  }

  122  void CShadows::SetRenderModeForShadowType(unsigned char shadowType) {
  123:     plugin::Call<0x513FC0, unsigned char>(shadowType);
  124  }

  127  void CShadows::RenderStoredShadows() {
  128:     plugin::Call<0x514010>();
  129  }

  132  void CShadows::RenderStaticShadows() {
  133:     plugin::Call<0x5145F0>();
  134  }

  137  void CShadows::GeneratePolysForStaticShadow(short staticShadowIndex) {
  138:     plugin::Call<0x514910, short>(staticShadowIndex);
  139  }

  142  void CShadows::CastShadowSectorList(CPtrList& ptrList, float conrerAX, float cornerAY, float cornerBX, float cornerBY, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity, unsigned char red, unsigned char green, unsigned char blue, float zDistance, float scale, CPolyBunch** ppPolyBunch) {
  143:     plugin::Call<0x514C90, CPtrList&, float, float, float, float, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, CPolyBunch**>(ptrList, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch);
  144  }

  147  void CShadows::CastShadowEntity(CEntity* entity, float conrerAX, float cornerAY, float cornerBX, float cornerBY, CVector* posn, float frontX, float frontY, float sideX, float sideY, short intensity, unsigned char red, unsigned char green, unsigned char blue, float zDistance, float scale, CPolyBunch** ppPolyBunch) {
  148:     plugin::Call<0x514E30, CEntity*, float, float, float, float, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, CPolyBunch**>(entity, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch);
  149  }

  152  void CShadows::UpdateStaticShadows() {
  153:     plugin::Call<0x516BE0>();
  154  }

  157  void CShadows::UpdatePermanentShadows() {
  158:     plugin::Call<0x516C40>();
  159  }

  162  void CShadows::CalcPedShadowValues(CVector sunPosn, float* displacementX, float* displacementY, float* frontX, float* frontY, float* sideX, float* sideY) {
  163:     plugin::Call<0x516EB0, CVector, float*, float*, float*, float*, float*, float*>(sunPosn, displacementX, displacementY, frontX, frontY, sideX, sideY);
  164  }

  167  void CShadows::RenderExtraPlayerShadows() {
  168:     plugin::Call<0x516F90>();
  169  }

  172  void CShadows::TidyUpShadows() {
  173:     plugin::Call<0x517570>();
  174  }

plugin_III\game_III\CShinyTexts.cpp:
  24  void CShinyTexts::RegisterOne(CVector cornerAA, CVector cornerAB, CVector cornerBA, CVector cornerBB, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4, unsigned char type, unsigned char red, unsigned char green, unsigned char blue, float maxDistance) {
  25:     plugin::CallDynGlobal<CVector, CVector, CVector, CVector, float, float, float, float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof(CShinyTexts::RegisterOne), cornerAA, cornerAB, cornerBA, cornerBB, u1, v1, u2, v2, u3, v3, u4, v4, type, red, green, blue, maxDistance);
  26  }

plugin_III\game_III\CShotInfo.cpp:
  20  bool CShotInfo::AddShot(CEntity *sourceEntity, eWeaponType weaponType, CVector startPos, CVector endPos) {
  21:     return plugin::CallAndReturnDynGlobal<bool, CEntity *, eWeaponType, CVector, CVector>(gaddrof(CShotInfo::AddShot), sourceEntity, weaponType, startPos, endPos);
  22  }

plugin_III\game_III\CSimpleModelInfo.cpp:
   23  void CSimpleModelInfo::DeleteRwObject() {
   24:     plugin::CallVirtualMethod<2, CSimpleModelInfo *>(this);
   25  }

   30  RwObject *CSimpleModelInfo::CreateInstance() {
   31:     return plugin::CallVirtualMethodAndReturn<RwObject *, 3, CSimpleModelInfo *>(this);
   32  }

   37  RwObject *CSimpleModelInfo::CreateInstance(RwMatrix *matrix) {
   38:     return plugin::CallVirtualMethodAndReturn<RwObject *, 4, CSimpleModelInfo *, RwMatrix *>(this, matrix);
   39  }

   44  RwObject *CSimpleModelInfo::GetRwObject() {
   45:     return plugin::CallVirtualMethodAndReturn<RwObject *, 5, CSimpleModelInfo *>(this);
   46  }

   51  void CSimpleModelInfo::FindRelatedModel() {
   52:     plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::FindRelatedModel), this);
   53  }

   58  RpAtomic *CSimpleModelInfo::GetAtomicFromDistance(float distance) {
   59:     return plugin::CallMethodAndReturnDynGlobal<RpAtomic *, CSimpleModelInfo *, float>(gaddrof(CSimpleModelInfo::GetAtomicFromDistance), this, distance);
   60  }

   65  float CSimpleModelInfo::GetLargestLodDistance() {
   66:     return plugin::CallMethodAndReturnDynGlobal<float, CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::GetLargestLodDistance), this);
   67  }

   72  float CSimpleModelInfo::GetNearDistance() {
   73:     return plugin::CallMethodAndReturnDynGlobal<float, CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::GetNearDistance), this);
   74  }

   79  void CSimpleModelInfo::IncreaseAlpha() {
   80:     plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::IncreaseAlpha), this);
   81  }

   86  void CSimpleModelInfo::Init() {
   87:     plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::Init), this);
   88  }

   93  void CSimpleModelInfo::SetAtomic(int number, RpAtomic *atomic) {
   94:     plugin::CallMethodDynGlobal<CSimpleModelInfo *, int, RpAtomic *>(gaddrof(CSimpleModelInfo::SetAtomic), this, number, atomic);
   95  }

  100  void CSimpleModelInfo::SetLodDistances(float *distance) {
  101:     plugin::CallMethodDynGlobal<CSimpleModelInfo *, float *>(gaddrof(CSimpleModelInfo::SetLodDistances), this, distance);
  102  }

  107  void CSimpleModelInfo::SetupBigBuilding() {
  108:     plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::SetupBigBuilding), this);
  109  }

plugin_III\game_III\CSkidmarks.cpp:
  35  void CSkidmarks::RegisterOne(unsigned int id, CVector pos, float fwdX, float fwdY, bool *isMuddy, bool *isBloody) {
  36:     plugin::CallDynGlobal<unsigned int, CVector, float, float, bool *, bool *>(gaddrof(CSkidmarks::RegisterOne), id, pos, fwdX, fwdY, isMuddy, isBloody);
  37  }

plugin_III\game_III\CSpecialFX.cpp:
  42  RwObject *LookForBatCB(RwObject *object, void *data) {
  43:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(LookForBatCB), object, data);
  44  }

plugin_III\game_III\CSpecialParticleStuff.cpp:
  16  void CSpecialParticleStuff::CreateFoamAroundObject(CMatrix *matrix, float x, float y, float z, int particles) {
  17:     plugin::CallDynGlobal<CMatrix *, float, float, float, int>(gaddrof(CSpecialParticleStuff::CreateFoamAroundObject), matrix, x, y, z, particles);
  18  }

  30  void CSpecialParticleStuff::UpdateBoatFoamAnimation(CMatrix *matrix) {
  31:     plugin::CallDynGlobal<CMatrix *>(gaddrof(CSpecialParticleStuff::UpdateBoatFoamAnimation), matrix);
  32  }

plugin_III\game_III\CSprite.cpp:
   22  float CSprite::CalcHorizonCoors() {
   23:     return plugin::CallAndReturnDynGlobal<float>(gaddrof(CSprite::CalcHorizonCoors));
   24  }

   29  bool CSprite::CalcScreenCoors(RwV3d const &in, RwV3d *out, float *outW, float *outH, bool farClip) {
   30:     return plugin::CallAndReturnDynGlobal<bool, RwV3d const &, RwV3d *, float *, float *, bool>(gaddrof(CSprite::CalcScreenCoors), in, out, outW, outH, farClip);
   31  }

   57  void CSprite::RenderBufferedOneXLUSprite(float x, float y, float z, float w, float h, unsigned char red, unsigned char green, unsigned char blue, short alpha, float rhw, unsigned char intensity) {
   58:     plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite), x, y, z, w, h, red, green, blue, alpha, rhw, intensity);
   59  }

   64  void CSprite::RenderBufferedOneXLUSprite2D(float x, float y, float w, float h, RwRGBA const &color, short intensity, unsigned char alpha) {
   65:     plugin::CallDynGlobal<float, float, float, float, RwRGBA const &, short, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite2D), x, y, w, h, color, intensity, alpha);
   66  }

   71  void CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension(float x, float y, float w, float h, RwRGBA const &color, short intensity, float angle, unsigned char alpha) {
   72:     plugin::CallDynGlobal<float, float, float, float, RwRGBA const &, short, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension), x, y, w, h, color, intensity, angle, alpha);
   73  }

   78  void CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours(float x, float y, float z, float w, float h, unsigned char red, unsigned char green, unsigned char blue, unsigned char red2, unsigned char green2, unsigned char blue2, float colx, float coly, float rhw, float angle, unsigned char intensity) {
   79:     plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float, float, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours), x, y, z, w, h, red, green, blue, red2, green2, blue2, colx, coly, rhw, angle, intensity);
   80  }

   85  void CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(float x, float y, float z, float w, float h, unsigned char red, unsigned char green, unsigned char blue, short alpha, float rhw, float angle, unsigned char intensity) {
   86:     plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);
   87  }

   92  void CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension(float x, float y, float z, float w, float h, unsigned char red, unsigned char green, unsigned char blue, short alpha, float rhw, float angle, unsigned char intensity) {
   93:     plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);
   94  }

   99  void CSprite::RenderOneXLUSprite(float x, float y, float z, float w, float h, unsigned char red, unsigned char green, unsigned char blue, short alpha, float rhw, unsigned char intensity) {
  100:     plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(gaddrof(CSprite::RenderOneXLUSprite), x, y, z, w, h, red, green, blue, alpha, rhw, intensity);
  101  }

  106  void CSprite::RenderOneXLUSprite_Rotate_Aspect(float x, float y, float z, float w, float h, unsigned char red, unsigned char green, unsigned char blue, short alpha, float rhw, float angle, unsigned char intensity) {
  107:     plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderOneXLUSprite_Rotate_Aspect), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);
  108  }

  113  void CSprite::Set6Vertices2D(RwIm2DVertex *vertex, CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4) {
  114:     plugin::CallDynGlobal<RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite::Set6Vertices2D, void (*)(RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), vertex, rect, color1, color2, color3, color4);
  115  }

  120  void CSprite::Set6Vertices2D(RwIm2DVertex *vertex, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4) {
  121:     plugin::CallDynGlobal<RwIm2DVertex *, float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite::Set6Vertices2D, void (*)(RwIm2DVertex *, float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), vertex, x1, y1, x2, y2, x3, y3, x4, y4, color1, color2, color3, color4);
  122  }

plugin_III\game_III\CSprite2d.cpp:
   28  void CSprite2d::Delete() {
   29:     plugin::CallMethodDynGlobal<CSprite2d *>(gaddrof(CSprite2d::Delete), this);
   30  }

   35  void CSprite2d::Draw(float x, float y, float w, float h, CRGBA const &color) {
   36:     plugin::CallMethodDynGlobal<CSprite2d *, float, float, float, float, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(float, float, float, float, CRGBA const &)), this, x, y, w, h, color);
   37  }

   42  void CSprite2d::Draw(CRect const &rect, CRGBA const &color) {
   43:     plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &, CRGBA const &)), this, rect, color);
   44  }

   49  void CSprite2d::Draw(CRect const &rect, CRGBA const &color, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4) {
   50:     plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &, CRGBA const &, float, float, float, float, float, float, float, float)), this, rect, color, u1, v1, u2, v2, u3, v3, u4, v4);
   51  }

   56  void CSprite2d::Draw(CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4) {
   57:     plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), this, rect, color1, color2, color3, color4);
   58  }

   63  void CSprite2d::Draw(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, CRGBA const &color) {
   64:     plugin::CallMethodDynGlobal<CSprite2d *, float, float, float, float, float, float, float, float, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(float, float, float, float, float, float, float, float, CRGBA const &)), this, x1, y1, x2, y2, x3, y3, x4, y4, color);
   65  }

   70  void CSprite2d::SetAddressing(RwTextureAddressMode modeUV) {
   71:     plugin::CallMethodDynGlobal<CSprite2d *, RwTextureAddressMode>(gaddrof(CSprite2d::SetAddressing), this, modeUV);
   72  }

   77  void CSprite2d::SetRenderState() {
   78:     plugin::CallMethodDynGlobal<CSprite2d *>(gaddrof(CSprite2d::SetRenderState), this);
   79  }

   84  void CSprite2d::SetTexture(char *name) {
   85:     plugin::CallMethodDynGlobal<CSprite2d *, char *>(gaddrof_o(CSprite2d::SetTexture, void (CSprite2d::*)(char *)), this, name);
   86  }

   91  void CSprite2d::SetTexture(char *name, char *maskName) {
   92:     plugin::CallMethodDynGlobal<CSprite2d *, char *, char *>(gaddrof_o(CSprite2d::SetTexture, void (CSprite2d::*)(char *, char *)), this, name, maskName);
   93  }

   98  void CSprite2d::AddSpriteToBank(int bank, CRect const &rect, CRGBA const &color, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4) {
   99:     plugin::CallDynGlobal<int, CRect const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof(CSprite2d::AddSpriteToBank), bank, rect, color, u1, v1, u2, v2, u3, v3, u4, v4);
  100  }

  105  void CSprite2d::DrawBank(int bank) {
  106:     plugin::CallDynGlobal<int>(gaddrof(CSprite2d::DrawBank), bank);
  107  }

  112  void CSprite2d::DrawRect(CRect const &rect, CRGBA const &color) {
  113:     plugin::CallDynGlobal<CRect const &, CRGBA const &>(gaddrof_o(CSprite2d::DrawRect, void (*)(CRect const &, CRGBA const &)), rect, color);
  114  }

  119  void CSprite2d::DrawRect(CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4) {
  120:     plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::DrawRect, void (*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), rect, color1, color2, color3, color4);
  121  }

  126  void CSprite2d::DrawRectXLU(CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4) {
  127:     plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof(CSprite2d::DrawRectXLU), rect, color1, color2, color3, color4);
  128  }

  133  int CSprite2d::GetBank(int n, RwTexture *texture) {
  134:     return plugin::CallAndReturnDynGlobal<int, int, RwTexture *>(gaddrof(CSprite2d::GetBank), n, texture);
  135  }

  147  void CSprite2d::SetMaskVertices(int numVerts, float *pos) {
  148:     plugin::CallDynGlobal<int, float *>(gaddrof(CSprite2d::SetMaskVertices), numVerts, pos);
  149  }

  161  void CSprite2d::SetVertices(CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4, unsigned int bFar) {
  162:     plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, unsigned int>(gaddrof_o(CSprite2d::SetVertices, void (*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, unsigned int)), rect, color1, color2, color3, color4, bFar);
  163  }

  168  void CSprite2d::SetVertices(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4) {
  169:     plugin::CallDynGlobal<float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::SetVertices, void (*)(float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), x1, y1, x2, y2, x3, y3, x4, y4, color1, color2, color3, color4);
  170  }

  175  void CSprite2d::SetVertices(CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4) {
  176:     plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::SetVertices, void (*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float)), rect, color1, color2, color3, color4, u1, v1, u2, v2, u3, v3, u4, v4);
  177  }

  182  void CSprite2d::SetVertices(int numVerts, float *pos, float *texCoors, CRGBA const &color) {
  183:     plugin::CallDynGlobal<int, float *, float *, CRGBA const &>(gaddrof_o(CSprite2d::SetVertices, void (*)(int, float *, float *, CRGBA const &)), numVerts, pos, texCoors, color);
  184  }

  189  void CSprite2d::SetVertices(RwIm2DVertex *vertices, CRect const &rect, CRGBA const &color1, CRGBA const &color2, CRGBA const &color3, CRGBA const &color4, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4) {
  190:     plugin::CallDynGlobal<RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::SetVertices, void (*)(RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float)), vertices, rect, color1, color2, color3, color4, u1, v1, u2, v2, u3, v3, u4, v4);
  191  }

plugin_III\game_III\CStats.cpp:
   63  void CStats::AnotherCriminalCaught() {
   64:     plugin::Call<0x4AB050>();
   65  }

   68  void CStats::AnotherFireExtinguished() {
   69:     plugin::Call<0x4AB080>();
   70  }

   73  void CStats::AnotherKillFrenzyPassed() {
   74:     plugin::Call<0x4AB240>();
   75  }

   78  void CStats::AnotherLifeSavedWithAmbulance() {
   79:     plugin::Call<0x4AB040>();
   80  }

   83  void CStats::CheckPointReachedSuccessfully() {
   84:     plugin::Call<0x4AB270>();
   85  }

   88  void CStats::CheckPointReachedUnsuccessfully() {
   89:     plugin::Call<0x4AB290>();
   90  }

   93  int CStats::FindCriminalRatingNumber() {
   94:     return plugin::CallAndReturn<int, 0x4AB2A0>();
   95  }

   98  wchar_t* CStats::FindCriminalRatingString() {
   99:     return plugin::CallAndReturn<wchar_t*, 0x4AB090>();
  100  }

  103  void CStats::Init() {
  104:     plugin::Call<0x4AAC60>();
  105  }

  108  void CStats::LoadStats(unsigned char* bufferPointer, unsigned int structSize) {
  109:     plugin::Call<0x4AB670, unsigned char*, unsigned int>(bufferPointer, structSize);
  110  }

  113  void CStats::Register4x4MayhemTime(int time) {
  114:     plugin::Call<0x4AB020, int>(time);
  115  }

  118  void CStats::Register4x4OneTime(int time) {
  119:     plugin::Call<0x4AAFC0, int>(time);
  120  }

  123  void CStats::Register4x4ThreeTime(int time) {
  124:     plugin::Call<0x4AB000, int>(time);
  125  }

  128  void CStats::Register4x4TwoTime(int time) {
  129:     plugin::Call<0x4AAFE0, int>(time);
  130  }

  133  void CStats::RegisterElBurroTime(int time) {
  134:     plugin::Call<0x4AAFA0, int>(time);
  135  }

  138  void CStats::RegisterFastestTime(int statID, int time) {
  139:     plugin::Call<0x4AAF50, int, int>(statID, time);
  140  }

  143  void CStats::RegisterHighestScore(int statID, int score) {
  144:     plugin::Call<0x4AAF80, int, int>(statID, score);
  145  }

  148  void CStats::RegisterLevelAmbulanceMission(int level) {
  149:     plugin::Call<0x4AB060, int>(level);
  150  }

  153  void CStats::RegisterLongestFlightInDodo(int distance) {
  154:     plugin::Call<0x4AB200, int>(distance);
  155  }

  158  void CStats::RegisterTimeTakenDefuseMission(int time) {
  159:     plugin::Call<0x4AB220, int>(time);
  160  }

  163  void CStats::SaveStats(unsigned char* bufferPointer, unsigned int* structSize) {
  164:     plugin::Call<0x4AB3E0, unsigned char*, unsigned int*>(bufferPointer, structSize);
  165  }

  168  void CStats::SetTotalNumberKillFrenzies(int number) {
  169:     plugin::Call<0x4AB250, int>(number);
  170  }

  173  void CStats::SetTotalNumberMissions(int number) {
  174:     plugin::Call<0x4AB260, int>(number);
  175  }

plugin_III\game_III\CStoredCar.cpp:
  14  CVehicle *CStoredCar::RestoreCar() {
  15:     return plugin::CallMethodAndReturnDynGlobal<CVehicle *, CStoredCar *>(gaddrof(CStoredCar::RestoreCar), this);
  16  }

  21  void CStoredCar::StoreCar(CVehicle *vehicle) {
  22:     plugin::CallMethodDynGlobal<CStoredCar *, CVehicle *>(gaddrof(CStoredCar::StoreCar), this, vehicle);
  23  }

  28  void CStoredCar::SetExtras(char first, char second) {
  29:     plugin::CallDynGlobal<char, char>(gaddrof(CStoredCar::SetExtras), first, second);
  30  }

plugin_III\game_III\CStreaming.cpp:
   40  void CStreaming::RequestModel(int modelIndex, int flags) {
   41:     plugin::Call<0x407EA0, int, int>(modelIndex, flags);
   42  }

   45  void CStreaming::LoadRequestedModels() {
   46:     plugin::Call<0x40A390>();
   47  }

   50  void CStreaming::Init() {
   51:     plugin::Call<0x406430>();
   52  }

   55  void CStreaming::FlushChannels() {
   56:     plugin::Call<0x40A610>();
   57  }

   60  void CStreaming::FlushRequestList() {
   61:     plugin::Call<0x40A680>();
   62  }

   65  int CStreaming::GetAvailableVehicleSlot() {
   66:     return plugin::CallAndReturn<int, 0x40B160>();
   67  }

   70  bool CStreaming::IsTxdUsedByRequestedModels(int index) {
   71:     return plugin::CallAndReturn<bool, 0x4094C0, int>(index);
   72  }

   75  void CStreaming::LoadAllRequestedModels(bool onlyQuickRequests) {
   76:     plugin::Call<0x40A440, bool>(onlyQuickRequests);
   77  }

   80  void CStreaming::RemoveModel(int modelIndex) {
   81:     plugin::Call<0x408830, int>(modelIndex);
   82  }

   85  bool CStreaming::RemoveLeastUsedModel() {
   86:     return plugin::CallAndReturn<bool, 0x4089B0>();
   87  }

   90  bool CStreaming::RemoveLoadedVehicle() {
   91:     return plugin::CallAndReturn<bool, 0x40B180>();
   92  }

   95  void CStreaming::RemoveAllUnusedModels() {
   96:     plugin::Call<0x408940>();
   97  }

  100  void CStreaming::RemoveCurrentZonesModels() {
  101:     plugin::Call<0x40AD00>();
  102  }

  105  void CStreaming::RemoveUnusedModelsInLoadedList() {
  106:     plugin::Call<0x4089A0>();
  107  }

  110  void CStreaming::RequestModelStream(int streamnum) {
  111:     plugin::Call<0x40A060, int>(streamnum);
  112  }

  115  void CStreaming::RequestSpecialChar(int index, char const* txdname, int modelrequestflag) {
  116:     plugin::Call<0x40ADA0, int, char const*, int>(index, txdname, modelrequestflag);
  117  }

  120  void CStreaming::RequestSpecialModel(int slot, char const* name, int modelrequestflag) {
  121:     plugin::Call<0x40A890, int, char const*, int>(slot, name, modelrequestflag);
  122  }

  125  void CStreaming::RequestSubway() {
  126:     plugin::Call<0x407FD0>();
  127  }

  130  void CStreaming::SetMissionDoesntRequireModel(int modelIndex) {
  131:     plugin::Call<0x40A820, int>(modelIndex);
  132  }

  135  void CStreaming::SetMissionDoesntRequireSpecialChar(int index) {
  136:     plugin::Call<0x40ADE0, int>(index);
  137  }

  140  void CStreaming::SetModelIsDeletable(int modelIndex) {
  141:     plugin::Call<0x40A790, int>(modelIndex);
  142  }

  145  void CStreaming::SetModelTxdIsDeletable(int modelIndex) {
  146:     plugin::Call<0x40A800, int>(modelIndex);
  147  }

  150  void CStreaming::Shutdown() {
  151:     plugin::Call<0x406C80>();
  152  }

  155  void CStreaming::StreamVehiclesAndPeds() {
  156:     plugin::Call<0x40AE60>();
  157  }

  160  void CStreaming::Update() {
  161:     plugin::Call<0x4076C0>();
  162  }

  165  void CStreaming::UpdateMemoryUsed() {
  166:     plugin::Call<0x4076B0>();
  167  }

  170  void CStreaming::AddModelsToRequestList(CVector const& point) {
  171:     plugin::Call<0x4078F0, CVector const&>(point);
  172  }

  175  void CStreaming::AddToLoadedVehiclesList(int vehicleId) {
  176:     plugin::Call<0x40B060, int>(vehicleId);
  177  }

  180  bool CStreaming::ConvertBufferToObject(char* pFileContect, int modelIndex) {
  181:     return plugin::CallAndReturn<bool, 0x409740, char*, int>(pFileContect, modelIndex);
  182  }

  185  void CStreaming::DeleteAllRwObjects() {
  186:     plugin::Call<0x407390>();
  187  }

  190  void CStreaming::DeleteFarAwayRwObjects(CVector const& point) {
  191:     plugin::Call<0x407070, CVector const&>(point);
  192  }

  195  void CStreaming::DeleteRwObjectsAfterDeath(CVector const& point) {
  196:     plugin::Call<0x407400, CVector const&>(point);
  197  }

  200  void CStreaming::DeleteRwObjectsBehindCamera(int size) {
  201:     plugin::Call<0x408A60, int>(size);
  202  }

  205  bool CStreaming::DeleteRwObjectsBehindCameraInSectorList(CPtrList& list, int size) {
  206:     return plugin::CallAndReturn<bool, 0x409340, CPtrList&, int>(list, size);
  207  }

  210  void CStreaming::DeleteRwObjectsInOverlapSectorList(CPtrList& list, int arg1, int arg2) {
  211:     plugin::Call<0x4075A0, CPtrList&, int, int>(list, arg1, arg2);
  212  }

  215  void CStreaming::DeleteRwObjectsInSectorList(CPtrList& list) {
  216:     plugin::Call<0x407560, CPtrList&>(list);
  217  }

  220  bool CStreaming::DeleteRwObjectsNotInFrustumInSectorList(CPtrList& list, int size) {
  221:     return plugin::CallAndReturn<bool, 0x4093C0, CPtrList&, int>(list, size);
  222  }

  225  bool CStreaming::FinishLoadingLargeFile(char* FileName, int modelIndex) {
  226:     return plugin::CallAndReturn<bool, 0x409580, char*, int>(FileName, modelIndex);
  227  }

  230  unsigned int CStreaming::GetCdImageOffset(int arg0) {
  231:     return plugin::CallAndReturn<unsigned int, 0x409FF0, int>(arg0);
  232  }

  235  int CStreaming::GetNextFileOnCd(int arg0, bool arg1) {
  236:     return plugin::CallAndReturn<int, 0x409E50, int, bool>(arg0, arg1);
  237  }

  240  bool CStreaming::HasSpecialCharLoaded(int modelIndex) {
  241:     return plugin::CallAndReturn<bool, 0x40ADC0, int>(modelIndex);
  242  }

  245  void CStreaming::HaveAllBigBuildingsLoaded(eLevelName levelName) {
  246:     plugin::Call<0x408280, eLevelName>(levelName);
  247  }

  250  void CStreaming::IHaveUsedStreamingMemory() {
  251:     plugin::Call<0x409BD0>();
  252  }

  255  void CStreaming::ImGonnaUseStreamingMemory() {
  256:     plugin::Call<0x409BC0>();
  257  }

  260  bool CStreaming::IsObjectInCdImage(int modelIndex) {
  261:     return plugin::CallAndReturn<bool, 0x407E70, int>(modelIndex);
  262  }

  265  void CStreaming::LoadCdDirectory(char const* archivename, int archiveID) {
  266:     plugin::Call<0x406DA0, char const*, int>(archivename, archiveID);
  267  }

  270  void CStreaming::LoadCdDirectory() {
  271:     plugin::Call<0x406CC0>();
  272  }

  275  void CStreaming::LoadInitialPeds() {
  276:     plugin::Call<0x40AA00>();
  277  }

  280  void CStreaming::LoadInitialVehicles() {
  281:     plugin::Call<0x40ADF0>();
  282  }

  285  void CStreaming::LoadScene(CVector const& point) {
  286:     plugin::Call<0x40A6D0, CVector const&>(point);
  287  }

  290  void CStreaming::MakeSpaceFor(int size) {
  291:     plugin::Call<0x409B70, int>(size);
  292  }

  295  void CStreaming::MemoryCardLoad(unsigned char* arg0, unsigned int arg1) {
  296:     plugin::Call<0x40B250, unsigned char*, unsigned int>(arg0, arg1);
  297  }

  300  void CStreaming::MemoryCardSave(unsigned char* arg0, unsigned int* arg1) {
  301:     plugin::Call<0x40B210, unsigned char*, unsigned int*>(arg0, arg1);
  302  }

  305  void CStreaming::ProcessEntitiesInSectorList(CPtrList& list) {
  306:     plugin::Call<0x407DD0, CPtrList&>(list);
  307  }

  310  void CStreaming::ProcessEntitiesInSectorList(CPtrList& list, float x1, float y1, float z1, float x2, float y2, float z2) {
  311:     plugin::Call<0x407C50, CPtrList&, float, float, float, float, float, float>(list, x1, y1, z1, x2, y2, z2);
  312  }

  315  bool CStreaming::ProcessLoadingChannel(int channelindex) {
  316:     return plugin::CallAndReturn<bool, 0x409BE0, int>(channelindex);
  317  }

  320  void CStreaming::RemoveBigBuildings(eLevelName levelName) {
  321:     plugin::Call<0x408680, eLevelName>(levelName);
  322  }

  325  void CStreaming::RemoveBuildings(eLevelName levelName) {
  326:     plugin::Call<0x4083D0, eLevelName>(levelName);
  327  }

  330  void CStreaming::RemoveIslandsNotUsed(eLevelName levelName) {
  331:     plugin::Call<0x408780, eLevelName>(levelName);
  332  }

  335  bool CStreaming::RemoveReferencedTxds(int arg0) {
  336:     return plugin::CallAndReturn<bool, 0x409450, int>(arg0);
  337  }

  340  void CStreaming::RemoveUnusedBigBuildings(eLevelName levelName) {
  341:     plugin::Call<0x408640, eLevelName>(levelName);
  342  }

  345  void CStreaming::RemoveUnusedBuildings(eLevelName levelName) {
  346:     plugin::Call<0x4083A0, eLevelName>(levelName);
  347  }

  350  void CStreaming::RequestBigBuildings(eLevelName levelName) {
  351:     plugin::Call<0x408190, eLevelName>(levelName);
  352  }

  355  void CStreaming::RequestIslands(eLevelName levelName) {
  356:     plugin::Call<0x408210, eLevelName>(levelName);
  357  }

  360  void CStreaming::RetryLoadFile(int streamnum) {
  361:     plugin::Call<0x4077F0, int>(streamnum);
  362  }

  365  void CStreaming::StreamZoneModels(CVector const& point) {
  366:     plugin::Call<0x40AA30, CVector const&>(point);
  367  }

  370  void DeleteIsland(CEntity* entity) {
  371:     plugin::Call<0x408740, CEntity*>(entity);
  372  }

plugin_III\game_III\CStreamingInfo.cpp:
  10  void CStreamingInfo::AddToList(CStreamingInfo* listStart) {
  11:     return plugin::CallMethod<0x406380, CStreamingInfo *, CStreamingInfo*>(this, listStart);
  12  }

  15  bool CStreamingInfo::GetCdPosnAndSize(unsigned int& posn, unsigned int& size) {
  16:     return plugin::CallMethodAndReturn<bool, 0x4063E0, CStreamingInfo *, unsigned int&, unsigned int&>(this, posn, size);
  17  }

  20  unsigned int CStreamingInfo::GetCdSize() {
  21:     return plugin::CallMethodAndReturn<unsigned int, 0x4063D0, CStreamingInfo *>(this);
  22  }

  25  void CStreamingInfo::RemoveFromList() {
  26:     return plugin::CallMethod<0x4063A0, CStreamingInfo *>(this);
  27  }

  30  void CStreamingInfo::SetCdPosnAndSize(unsigned int posn, unsigned int size) {
  31:     plugin::CallMethod<0x406410, CStreamingInfo *, unsigned int, unsigned int>(this, posn, size);
  32  }

plugin_III\game_III\CStuckCarCheck.cpp:
  17  void CStuckCarCheck::AddCarToCheck(int id, float radius, unsigned int time) {
  18:     plugin::CallMethodDynGlobal<CStuckCarCheck *, int, float, unsigned int>(gaddrof(CStuckCarCheck::AddCarToCheck), this, id, radius, time);
  19  }

  24  bool CStuckCarCheck::HasCarBeenStuckForAWhile(int id) {
  25:     return plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::HasCarBeenStuckForAWhile), this, id);
  26  }

  31  void CStuckCarCheck::Init() {
  32:     plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Init), this);
  33  }

  38  void CStuckCarCheck::Process() {
  39:     plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Process), this);
  40  }

  45  void CStuckCarCheck::RemoveCarFromCheck(int id) {
  46:     plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::RemoveCarFromCheck), this, id);
  47  }

plugin_III\game_III\CSurfaceTable.cpp:
  16  int CSurfaceTable::GetAdhesionGroup(unsigned char surfaceType) {
  17:     return plugin::CallAndReturnDynGlobal<int, unsigned char>(gaddrof(CSurfaceTable::GetAdhesionGroup), surfaceType);
  18  }

  23  float CSurfaceTable::GetAdhesiveLimit(CColPoint &colPoint) {
  24:     return plugin::CallAndReturnDynGlobal<float, CColPoint &>(gaddrof(CSurfaceTable::GetAdhesiveLimit), colPoint);
  25  }

  30  float CSurfaceTable::GetWetMultiplier(unsigned char surfaceType) {
  31:     return plugin::CallAndReturnDynGlobal<float, unsigned char>(gaddrof(CSurfaceTable::GetWetMultiplier), surfaceType);
  32  }

  37  void CSurfaceTable::Initialise(char const *fileName) {
  38:     plugin::CallDynGlobal<char const *>(gaddrof(CSurfaceTable::Initialise), fileName);
  39  }

plugin_III\game_III\CText.cpp:
   17  CKeyEntry *CKeyArray::BinarySearch(char const *key, CKeyEntry *entries, short low, short high) {
   18:     return plugin::CallMethodAndReturnDynGlobal<CKeyEntry *, CKeyArray *, char const *, CKeyEntry *, short, short>(gaddrof(CKeyArray::BinarySearch), this, key, entries, low, high);
   19  }

   24  void CKeyArray::Load(unsigned int length, unsigned char *data, unsigned int *offset) {
   25:     plugin::CallMethodDynGlobal<CKeyArray *, unsigned int, unsigned char *, unsigned int *>(gaddrof(CKeyArray::Load), this, length, data, offset);
   26  }

   31  wchar_t *CKeyArray::Search(char const *key) {
   32:     return plugin::CallMethodAndReturnDynGlobal<wchar_t *, CKeyArray *, char const *>(gaddrof(CKeyArray::Search), this, key);
   33  }

   38  void CKeyArray::Unload() {
   39:     plugin::CallMethodDynGlobal<CKeyArray *>(gaddrof(CKeyArray::Unload), this);
   40  }

   45  void CKeyArray::Update(wchar_t *chars) {
   46:     plugin::CallMethodDynGlobal<CKeyArray *, wchar_t *>(gaddrof(CKeyArray::Update), this, chars);
   47  }

   52  void CData::Load(unsigned int length, char *data, int *offset) {
   53:     plugin::CallMethodDynGlobal<CData *, unsigned int, char *, int *>(gaddrof(CData::Load), this, length, data, offset);
   54  }

   59  void CData::Unload() {
   60:     plugin::CallMethodDynGlobal<CData *>(gaddrof(CData::Unload), this);
   61  }

   72  wchar_t *CText::Get(char const *key) {
   73:     return plugin::CallMethodAndReturnDynGlobal<wchar_t *, CText *, char const *>(gaddrof(CText::Get), this, key);
   74  }

   79  wchar_t CText::GetUpperCase(wchar_t c) {
   80:     return plugin::CallMethodAndReturnDynGlobal<wchar_t, CText *, wchar_t>(gaddrof(CText::GetUpperCase), this, c);
   81  }

   86  void CText::Load() {
   87:     plugin::CallMethodDynGlobal<CText *>(gaddrof(CText::Load), this);
   88  }

   93  void CText::Unload() {
   94:     plugin::CallMethodDynGlobal<CText *>(gaddrof(CText::Unload), this);
   95  }

  100  void CText::UpperCase(wchar_t *s) {
  101:     plugin::CallMethodDynGlobal<CText *, wchar_t *>(gaddrof(CText::UpperCase), this, s);
  102  }

  107  char *UnicodeToAscii(wchar_t *src) {
  108:     return plugin::CallAndReturnDynGlobal<char *, wchar_t *>(gaddrof(UnicodeToAscii), src);
  109  }

  114  char *UnicodeToAsciiForSaveLoad(wchar_t *src) {
  115:     return plugin::CallAndReturnDynGlobal<char *, wchar_t *>(gaddrof(UnicodeToAsciiForSaveLoad), src);
  116  }

  121  void TextCopy(wchar_t *dst, wchar_t const *src) {
  122:     plugin::CallDynGlobal<wchar_t *, wchar_t const *>(gaddrof(TextCopy), dst, src);
  123  }

plugin_III\game_III\CTheCarGenerators.cpp:
  20  int CTheCarGenerators::CreateCarGenerator(float x, float y, float z, float angle, int modelId, short colorPrim, short colorSec, unsigned char forceSpawn, unsigned char alarm, unsigned char doorLock, unsigned short minDelay, unsigned short maxDelay) {
  21:     return plugin::CallAndReturnDynGlobal<int, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(gaddrof(CTheCarGenerators::CreateCarGenerator), x, y, z, angle, modelId, colorPrim, colorSec, forceSpawn, alarm, doorLock, minDelay, maxDelay);
  22  }

  34  void CTheCarGenerators::LoadAllCarGenerators(unsigned char *buffer, unsigned int size) {
  35:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CTheCarGenerators::LoadAllCarGenerators), buffer, size);
  36  }

  48  void CTheCarGenerators::SaveAllCarGenerators(unsigned char *buffer, unsigned int *size) {
  49:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CTheCarGenerators::SaveAllCarGenerators), buffer, size);
  50  }

plugin_III\game_III\CTheScripts.cpp:
  40  void CTheScripts::Init() {
  41:     plugin::Call<0x438790>();
  42  }

  45  bool CTheScripts::IsPedStopped(CPed* ped) {
  46:     return plugin::CallAndReturn<bool, 0x454670, CPed*>(ped);
  47  }

  50  bool CTheScripts::IsPlayerOnAMission() {
  51:     return plugin::CallAndReturn<bool, 0x439410>();
  52  }

  55  bool CTheScripts::IsPlayerStopped(CPlayerInfo* info) {
  56:     return plugin::CallAndReturn<bool, 0x4546C0, CPlayerInfo*>(info);
  57  }

  60  bool CTheScripts::IsVehicleStopped(CVehicle* vehicle) {
  61:     return plugin::CallAndReturn<bool, 0x454770, CVehicle*>(vehicle);
  62  }

  65  void CTheScripts::CleanUpThisPed(CPed* ped) {
  66:     plugin::Call<0x4547A0, CPed*>(ped);
  67  }

  70  void CTheScripts::CleanUpThisObject(CObject* object) {
  71:     plugin::Call<0x454910, CObject*>(object);
  72  }

  75  void CTheScripts::CleanUpThisVehicle(CVehicle* vehicle) {
  76:     plugin::Call<0x4548D0, CVehicle*>(vehicle);
  77  }

  80  void CTheScripts::ClearSpaceForMissionEntity(CVector const& position, CEntity* entity) {
  81:     plugin::Call<0x454060, CVector const&, CEntity*>(position, entity);
  82  }

plugin_III\game_III\CTheZones.cpp:
   9  CZone* CTheZones::FindSmallestZonePosition(CVector const& pos) {
  10:     return plugin::CallAndReturn<CZone*, 0x4B69B0, CVector const&>(pos);
  11  }

  13  CZone* CTheZones::FindSmallestZonePositionType(CVector const& pos, int type) {
  14:     return plugin::CallAndReturn<CZone*, 0x4B6790, CVector const&, int>(pos, type);
  15  }

  17  CZoneInfo* CTheZones::GetZoneInfo(CVector const& pos, bool day) {
  18:     return plugin::CallAndReturn<CZoneInfo*, 0x4B6A10, CVector const&, char>(pos, day);
  19  }

plugin_III\game_III\CTimeModelInfo.cpp:
  23  CTimeModelInfo *CTimeModelInfo::FindOtherTimeModel() {
  24:     return plugin::CallMethodAndReturnDynGlobal<CTimeModelInfo *, CTimeModelInfo *>(gaddrof(CTimeModelInfo::FindOtherTimeModel), this);
  25  }

plugin_III\game_III\CTimer.cpp:
  35  unsigned int CTimer::GetCurrentTimeInCycles() {
  36:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CTimer::GetCurrentTimeInCycles));
  37  }

  42  int CTimer::GetCyclesPerMillisecond() {
  43:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CTimer::GetCyclesPerMillisecond));
  44  }

  49  bool CTimer::GetIsSlowMotionActive() {
  50:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTimer::GetIsSlowMotionActive));
  51  }

plugin_III\game_III\CTowerClock.cpp:
  19  void CTowerClock::Init(CVector pos, float sizeX, float sizeY, unsigned char red, unsigned char green, unsigned char blue, float drawDistance, float scale) {
  20:     plugin::CallMethodDynGlobal<CTowerClock *, CVector, float, float, unsigned char, unsigned char, unsigned char, float, float>(gaddrof(CTowerClock::Init), this, pos, sizeX, sizeY, red, green, blue, drawDistance, scale);
  21  }

  26  void CTowerClock::Render() {
  27:     plugin::CallMethodDynGlobal<CTowerClock *>(gaddrof(CTowerClock::Render), this);
  28  }

  33  void CTowerClock::Update() {
  34:     plugin::CallMethodDynGlobal<CTowerClock *>(gaddrof(CTowerClock::Update), this);
  35  }

plugin_III\game_III\CTrafficLights.cpp:
  14  void CTrafficLights::DisplayActualLight(CEntity *entity) {
  15:     plugin::CallDynGlobal<CEntity *>(gaddrof(CTrafficLights::DisplayActualLight), entity);
  16  }

  21  int CTrafficLights::FindTrafficLightType(CEntity *entity) {
  22:     return plugin::CallAndReturnDynGlobal<int, CEntity *>(gaddrof(CTrafficLights::FindTrafficLightType), entity);
  23  }

  28  unsigned char CTrafficLights::LightForCars1() {
  29:     return plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForCars1));
  30  }

  35  unsigned char CTrafficLights::LightForCars2() {
  36:     return plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForCars2));
  37  }

  42  unsigned char CTrafficLights::LightForPeds() {
  43:     return plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForPeds));
  44  }

  56  bool CTrafficLights::ShouldCarStopForBridge(CVehicle *vehicle) {
  57:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTrafficLights::ShouldCarStopForBridge), vehicle);
  58  }

  63  bool CTrafficLights::ShouldCarStopForLight(CVehicle *vehicle, bool alwaysStop) {
  64:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *, bool>(gaddrof(CTrafficLights::ShouldCarStopForLight), vehicle, alwaysStop);
  65  }

plugin_III\game_III\CTrain.cpp:
   43  void CTrain::SetModelIndex(unsigned int modelIndex) {
   44:     plugin::CallVirtualMethod<3, CTrain *, unsigned int>(this, modelIndex);
   45  }

   50  void CTrain::ProcessControl() {
   51:     plugin::CallVirtualMethod<8, CTrain *>(this);
   52  }

   57  void CTrain::PreRender() {
   58:     plugin::CallVirtualMethod<12, CTrain *>(this);
   59  }

   64  void CTrain::Render() {
   65:     plugin::CallVirtualMethod<13, CTrain *>(this);
   66  }

   71  void CTrain::AddPassenger(CPed *passenger) {
   72:     plugin::CallMethodDynGlobal<CTrain *, CPed *>(gaddrof(CTrain::AddPassenger), this, passenger);
   73  }

   78  void CTrain::OpenTrainDoor(float angle) {
   79:     plugin::CallMethodDynGlobal<CTrain *, float>(gaddrof(CTrain::OpenTrainDoor), this, angle);
   80  }

   85  void CTrain::TrainHitStuff(CPtrList &list) {
   86:     plugin::CallMethodDynGlobal<CTrain *, CPtrList &>(gaddrof(CTrain::TrainHitStuff), this, list);
   87  }

   99  void CTrain::ReadAndInterpretTrackFile(char const *filename, CTrainNode **nodes, short *numNodes, int numStations, float *stationDists, float *totalLength, float *totalDuration, CTrainInterpolationLine *line, bool rightRail) {
  100:     plugin::CallDynGlobal<char const *, CTrainNode **, short *, int, float *, float *, float *, CTrainInterpolationLine *, bool>(gaddrof(CTrain::ReadAndInterpretTrackFile), filename, nodes, numNodes, numStations, stationDists, totalLength, totalDuration, line, rightRail);
  101  }

  127  void PlayAnnouncement(unsigned char sound, unsigned char station) {
  128:     plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(PlayAnnouncement), sound, station);
  129  }

plugin_III\game_III\CTrainDoor.cpp:
  17  bool CTrainDoor::IsClosed() {
  18:     return plugin::CallMethodAndReturnDynGlobal<bool, CTrainDoor *>(gaddrof(CTrainDoor::IsClosed), this);
  19  }

  24  bool CTrainDoor::IsFullyOpen() {
  25:     return plugin::CallMethodAndReturnDynGlobal<bool, CTrainDoor *>(gaddrof(CTrainDoor::IsFullyOpen), this);
  26  }

  31  void CTrainDoor::Open(float angle) {
  32:     plugin::CallMethodDynGlobal<CTrainDoor *, float>(gaddrof(CTrainDoor::Open), this, angle);
  33  }

  38  float CTrainDoor::RetTranslationWhenClosed() {
  39:     return plugin::CallMethodAndReturnDynGlobal<float, CTrainDoor *>(gaddrof(CTrainDoor::RetTranslationWhenClosed), this);
  40  }

  45  float CTrainDoor::RetTranslationWhenOpen() {
  46:     return plugin::CallMethodAndReturnDynGlobal<float, CTrainDoor *>(gaddrof(CTrainDoor::RetTranslationWhenOpen), this);
  47  }

plugin_III\game_III\cTransmission.cpp:
  19  float cTransmission::CalculateDriveAcceleration(float const& gasPedal, unsigned char& currrentGear, float& pSpeed, float const& pCurrentSpeed, bool bCheat) {
  20:     return plugin::CallMethodAndReturn<float, 0x5506B0, cTransmission *, float const&, unsigned char&, float&, float const&, bool>(this, gasPedal, currrentGear, pSpeed, pCurrentSpeed, bCheat);
  21  }

  24  void cTransmission::CalculateGearForSimpleCar(float velocity, unsigned char& currrentGear) {
  25:     plugin::CallMethod<0x550A00, cTransmission *, float, unsigned char&>(this, velocity, currrentGear);
  26  }

  29  void cTransmission::InitGearRatios() {
  30:     plugin::CallMethod<0x550590, cTransmission *>(this);
  31  }

  34  cTransmission::cTransmission() {
  35:     plugin::CallMethod<0x550580, cTransmission *>(this);
  36  }

plugin_III\game_III\CTreadable.cpp:
  29  bool CTreadable::GetIsATreadable() {
  30:     return plugin::CallVirtualMethodAndReturn<bool, 17, CTreadable *>(this);
  31  }

plugin_III\game_III\CTxdStore.cpp:
   15  void CTxdStore::Initialise() {
   16:     plugin::Call<0x527440>();
   17  }

   20  void CTxdStore::Shutdown() {
   21:     plugin::Call<0x527470>();
   22  }

   25  void CTxdStore::GameShutdown() {
   26:     plugin::Call<0x527490>();
   27  }

   30  int CTxdStore::AddTxdSlot(char const* name) {
   31:     return plugin::CallAndReturn<int, 0x5274E0, char const*>(name);
   32  }

   35  void CTxdStore::RemoveTxdSlot(int id) {
   36:     plugin::Call<0x527520, int>(id);
   37  }

   40  char* CTxdStore::GetTxdName(int id) {
   41:     return plugin::CallAndReturn<char*, 0x527590, int>(id);
   42  }

   45  int CTxdStore::FindTxdSlot(char const* name) {
   46:     return plugin::CallAndReturn<int, 0x5275D0, char const*>(name);
   47  }

   50  bool CTxdStore::LoadTxd(int id, char const* name) {
   51:     return plugin::CallAndReturn<bool, 0x5276B0, int, char const*>(id, name);
   52  }

   55  bool CTxdStore::LoadTxd(int id, RwStream* stream) {
   56:     return plugin::CallAndReturn<bool, 0x527700, int, RwStream*>(id, stream);
   57  }

   60  bool CTxdStore::StartLoadTxd(int id, RwStream* stream) {
   61:     return plugin::CallAndReturn<bool, 0x527770, int, RwStream*>(id, stream);
   62  }

   65  bool CTxdStore::FinishLoadTxd(int id, RwStream* stream) {
   66:     return plugin::CallAndReturn<bool, 0x5277E0, int, RwStream*>(id, stream);
   67  }

   70  void CTxdStore::Create(int id) {
   71:     plugin::Call<0x527830, int>(id);
   72  }

   75  void CTxdStore::RemoveTxd(int id) {
   76:     plugin::Call<0x527870, int>(id);
   77  }

   80  void CTxdStore::SetCurrentTxd(int id) {
   81:     plugin::Call<0x5278C0, int>(id);
   82  }

   85  void CTxdStore::PushCurrentTxd() {
   86:     plugin::Call<0x527900>();
   87  }

   90  void CTxdStore::PopCurrentTxd() {
   91:     plugin::Call<0x527910>();
   92  }

   95  void CTxdStore::AddRef(int id) {
   96:     plugin::Call<0x527930, int>(id);
   97  }

  100  void CTxdStore::RemoveRef(int id) {
  101:     plugin::Call<0x527970, int>(id);
  102  }

  105  void CTxdStore::RemoveRefWithoutDelete(int id) {
  106:     plugin::Call<0x5279C0, int>(id);
  107  }

  110  int CTxdStore::GetNumRefs(int id) {
  111:     return plugin::CallAndReturn<int, 0x527A00, int>(id);
  112  }

plugin_III\game_III\CUpsideDownCarCheck.cpp:
  14  void CUpsideDownCarCheck::AddCarToCheck(int id) {
  15:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::AddCarToCheck), this, id);
  16  }

  21  bool CUpsideDownCarCheck::AreAnyCarsUpsideDown() {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::AreAnyCarsUpsideDown), this);
  23  }

  28  bool CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile(int id) {
  29:     return plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile), this, id);
  30  }

  35  void CUpsideDownCarCheck::Init() {
  36:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::Init), this);
  37  }

  42  bool CUpsideDownCarCheck::IsCarUpsideDown(int id) {
  43:     return plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::IsCarUpsideDown), this, id);
  44  }

  49  void CUpsideDownCarCheck::RemoveCarFromCheck(int id) {
  50:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::RemoveCarFromCheck), this, id);
  51  }

  56  void CUpsideDownCarCheck::UpdateTimers() {
  57:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::UpdateTimers), this);
  58  }

plugin_III\game_III\CVehicle.cpp:
   80  void CVehicle::SetModelIndex(unsigned int modelIndex) {
   81:     plugin::CallVirtualMethod<3, CVehicle *, unsigned int>(this, modelIndex);
   82  }

   87  bool CVehicle::SetupLighting() {
   88:     return plugin::CallVirtualMethodAndReturn<bool, 14, CVehicle *>(this);
   89  }

   94  void CVehicle::RemoveLighting(bool reset) {
   95:     plugin::CallVirtualMethod<15, CVehicle *, bool>(this, reset);
   96  }

  101  void CVehicle::FlagToDestroyWhenNextProcessed() {
  102:     plugin::CallVirtualMethod<16, CVehicle *>(this);
  103  }

  108  void CVehicle::ProcessControlInputs(unsigned char padNumber) {
  109:     plugin::CallVirtualMethod<18, CVehicle *, unsigned char>(this, padNumber);
  110  }

  115  void CVehicle::GetComponentWorldPosition(int component, CVector &pos) {
  116:     plugin::CallVirtualMethod<19, CVehicle *, int, CVector &>(this, component, pos);
  117  }

  122  bool CVehicle::IsComponentPresent(int component) {
  123:     return plugin::CallVirtualMethodAndReturn<bool, 20, CVehicle *, int>(this, component);
  124  }

  129  void CVehicle::SetComponentRotation(int component, CVector rotation) {
  130:     plugin::CallVirtualMethod<21, CVehicle *, int, CVector>(this, component, rotation);
  131  }

  136  void CVehicle::OpenDoor(int component, eDoors door, float angle) {
  137:     plugin::CallVirtualMethod<22, CVehicle *, int, eDoors, float>(this, component, door, angle);
  138  }

  143  void CVehicle::ProcessOpenDoor(unsigned int component, unsigned int anim, float angle) {
  144:     plugin::CallVirtualMethod<23, CVehicle *, unsigned int, unsigned int, float>(this, component, anim, angle);
  145  }

  150  bool CVehicle::IsDoorReady(eDoors door) {
  151:     return plugin::CallVirtualMethodAndReturn<bool, 24, CVehicle *, eDoors>(this, door);
  152  }

  157  bool CVehicle::IsDoorFullyOpen(eDoors door) {
  158:     return plugin::CallVirtualMethodAndReturn<bool, 25, CVehicle *, eDoors>(this, door);
  159  }

  164  bool CVehicle::IsDoorClosed(eDoors door) {
  165:     return plugin::CallVirtualMethodAndReturn<bool, 26, CVehicle *, eDoors>(this, door);
  166  }

  171  bool CVehicle::IsDoorMissing(eDoors door) {
  172:     return plugin::CallVirtualMethodAndReturn<bool, 27, CVehicle *, eDoors>(this, door);
  173  }

  178  void CVehicle::RemoveRefsToVehicle(CEntity *entity) {
  179:     plugin::CallVirtualMethod<28, CVehicle *, CEntity *>(this, entity);
  180  }

  185  void CVehicle::BlowUpCar(CEntity *entity) {
  186:     plugin::CallVirtualMethod<29, CVehicle *, CEntity *>(this, entity);
  187  }

  192  bool CVehicle::SetUpWheelColModel(CColModel *colModel) {
  193:     return plugin::CallVirtualMethodAndReturn<bool, 30, CVehicle *, CColModel *>(this, colModel);
  194  }

  199  void CVehicle::BurstTyre(unsigned char wheel) {
  200:     plugin::CallVirtualMethod<31, CVehicle *, unsigned char>(this, wheel);
  201  }

  206  bool CVehicle::IsRoomForPedToLeaveCar(unsigned int component, CVector *doorOffset) {
  207:     return plugin::CallVirtualMethodAndReturn<bool, 32, CVehicle *, unsigned int, CVector *>(this, component, doorOffset);
  208  }

  213  float CVehicle::GetHeightAboveRoad() {
  214:     return plugin::CallVirtualMethodAndReturn<float, 33, CVehicle *>(this);
  215  }

  220  void CVehicle::PlayCarHorn() {
  221:     plugin::CallVirtualMethod<34, CVehicle *>(this);
  222  }

  227  bool CVehicle::AddPassenger(CPed *passenger) {
  228:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *>(gaddrof_o(CVehicle::AddPassenger, bool (CVehicle::*)(CPed *)), this, passenger);
  229  }

  234  bool CVehicle::AddPassenger(CPed *passenger, unsigned char number) {
  235:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *, unsigned char>(gaddrof_o(CVehicle::AddPassenger, bool (CVehicle::*)(CPed *, unsigned char)), this, passenger, number);
  236  }

  241  bool CVehicle::CanBeDeleted() {
  242:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanBeDeleted), this);
  243  }

  248  bool CVehicle::CanPedEnterCar() {
  249:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanPedEnterCar), this);
  250  }

  255  bool CVehicle::CanPedExitCar() {
  256:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanPedExitCar), this);
  257  }

  262  bool CVehicle::CanPedOpenLocks(CPed *ped) {
  263:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *>(gaddrof(CVehicle::CanPedOpenLocks), this, ped);
  264  }

  269  bool CVehicle::CarHasRoof() {
  270:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CarHasRoof), this);
  271  }

  276  void CVehicle::ChangeLawEnforcerState(unsigned char enable) {
  277:     plugin::CallMethodDynGlobal<CVehicle *, unsigned char>(gaddrof(CVehicle::ChangeLawEnforcerState), this, enable);
  278  }

  283  void CVehicle::DoFixedMachineGuns() {
  284:     plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::DoFixedMachineGuns), this);
  285  }

  290  void CVehicle::ExtinguishCarFire() {
  291:     plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ExtinguishCarFire), this);
  292  }

  297  void CVehicle::FlyingControl(eFlightModel flightModel) {
  298:     plugin::CallMethodDynGlobal<CVehicle *, eFlightModel>(gaddrof(CVehicle::FlyingControl), this, flightModel);
  299  }

  304  void CVehicle::InflictDamage(CEntity *entity, eWeaponType weaponType, float damage) {
  305:     plugin::CallMethodDynGlobal<CVehicle *, CEntity *, eWeaponType, float>(gaddrof(CVehicle::InflictDamage), this, entity, weaponType, damage);
  306  }

  311  bool CVehicle::IsLawEnforcementVehicle() {
  312:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsLawEnforcementVehicle), this);
  313  }

  318  bool CVehicle::IsOnItsSide() {
  319:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsOnItsSide), this);
  320  }

  325  bool CVehicle::IsSphereTouchingVehicle(float x, float y, float z, float radius) {
  326:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, float, float, float, float>(gaddrof(CVehicle::IsSphereTouchingVehicle), this, x, y, z, radius);
  327  }

  332  bool CVehicle::IsUpsideDown() {
  333:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsUpsideDown), this);
  334  }

  339  bool CVehicle::IsVehicleNormal() {
  340:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsVehicleNormal), this);
  341  }

  346  void CVehicle::ProcessCarAlarm() {
  347:     plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ProcessCarAlarm), this);
  348  }

  353  void CVehicle::ProcessDelayedExplosion() {
  354:     plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ProcessDelayedExplosion), this);
  355  }

  360  void CVehicle::ProcessWheel(CVector &wheelFwd, CVector &wheelRight, CVector &wheelContactSpeed, CVector &wheelContactPoint, int wheelsOnGround, float thrust, float brake, float adhesion, char wheelId, float *wheelSpeed, tWheelState *wheelState, unsigned short wheelStatus) {
  361:     plugin::CallMethodDynGlobal<CVehicle *, CVector &, CVector &, CVector &, CVector &, int, float, float, float, char, float *, tWheelState *, unsigned short>(gaddrof(CVehicle::ProcessWheel), this, wheelFwd, wheelRight, wheelContactSpeed, wheelContactPoint, wheelsOnGround, thrust, brake, adhesion, wheelId, wheelSpeed, wheelState, wheelStatus);
  362  }

  367  float CVehicle::ProcessWheelRotation(tWheelState state, CVector const &fwd, CVector const &speed, float radius) {
  368:     return plugin::CallMethodAndReturnDynGlobal<float, CVehicle *, tWheelState, CVector const &, CVector const &, float>(gaddrof(CVehicle::ProcessWheelRotation), this, state, fwd, speed, radius);
  369  }

  374  void CVehicle::RemoveDriver() {
  375:     plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::RemoveDriver), this);
  376  }

  381  void CVehicle::RemovePassenger(CPed *passenger) {
  382:     plugin::CallMethodDynGlobal<CVehicle *, CPed *>(gaddrof(CVehicle::RemovePassenger), this, passenger);
  383  }

  388  void CVehicle::SetDriver(CPed *driver) {
  389:     plugin::CallMethodDynGlobal<CVehicle *, CPed *>(gaddrof(CVehicle::SetDriver), this, driver);
  390  }

  395  CPed *CVehicle::SetUpDriver() {
  396:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CVehicle *>(gaddrof(CVehicle::SetUpDriver), this);
  397  }

  402  CPed *CVehicle::SetupPassenger(int number) {
  403:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CVehicle *, int>(gaddrof(CVehicle::SetupPassenger), this, number);
  404  }

  409  bool CVehicle::ShufflePassengersToMakeSpace() {
  410:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::ShufflePassengersToMakeSpace), this);
  411  }

  416  bool CVehicle::UsesSiren(unsigned int vehicleModel) {
  417:     return plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, unsigned int>(gaddrof(CVehicle::UsesSiren), this, vehicleModel);
  418  }

  423  void DestroyVehicleAndDriverAndPassengers(CVehicle *vehicle) {
  424:     plugin::CallDynGlobal<CVehicle *>(gaddrof(DestroyVehicleAndDriverAndPassengers), vehicle);
  425  }

plugin_III\game_III\CVehicleModelInfo.cpp:
   32  void CVehicleModelInfo::DeleteRwObject() {
   33:     plugin::CallVirtualMethod<2, CVehicleModelInfo *>(this);
   34  }

   39  RwObject *CVehicleModelInfo::CreateInstance() {
   40:     return plugin::CallVirtualMethodAndReturn<RwObject *, 3, CVehicleModelInfo *>(this);
   41  }

   46  void CVehicleModelInfo::SetClump(RpClump *clump) {
   47:     plugin::CallVirtualMethod<6, CVehicleModelInfo *, RpClump *>(this, clump);
   48  }

   53  void CVehicleModelInfo::AvoidSameVehicleColour(unsigned char *prim, unsigned char *sec) {
   54:     plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char *, unsigned char *>(gaddrof(CVehicleModelInfo::AvoidSameVehicleColour), this, prim, sec);
   55  }

   60  int CVehicleModelInfo::ChooseComponent() {
   61:     return plugin::CallMethodAndReturnDynGlobal<int, CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::ChooseComponent), this);
   62  }

   67  int CVehicleModelInfo::ChooseSecondComponent() {
   68:     return plugin::CallMethodAndReturnDynGlobal<int, CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::ChooseSecondComponent), this);
   69  }

   74  void CVehicleModelInfo::ChooseVehicleColour(unsigned char *prim, unsigned char *sec) {
   75:     plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char *, unsigned char *>(gaddrof(CVehicleModelInfo::ChooseVehicleColour), this, prim, sec);
   76  }

   81  void CVehicleModelInfo::FindEditableMaterialList() {
   82:     plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::FindEditableMaterialList), this);
   83  }

   88  void CVehicleModelInfo::GetWheelPosn(int wheel, CVector &outPos) {
   89:     plugin::CallMethodDynGlobal<CVehicleModelInfo *, int, CVector &>(gaddrof(CVehicleModelInfo::GetWheelPosn), this, wheel, outPos);
   90  }

   95  void CVehicleModelInfo::PreprocessHierarchy() {
   96:     plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::PreprocessHierarchy), this);
   97  }

  102  void CVehicleModelInfo::SetAtomicRenderCallbacks() {
  103:     plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::SetAtomicRenderCallbacks), this);
  104  }

  109  void CVehicleModelInfo::SetEnvironmentMap() {
  110:     plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::SetEnvironmentMap), this);
  111  }

  116  void CVehicleModelInfo::SetVehicleColour(unsigned char prim, unsigned char sec) {
  117:     plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char, unsigned char>(gaddrof(CVehicleModelInfo::SetVehicleColour), this, prim, sec);
  118  }

  123  void CVehicleModelInfo::SetVehicleComponentFlags(RwFrame *frame, unsigned int flags) {
  124:     plugin::CallMethodDynGlobal<CVehicleModelInfo *, RwFrame *, unsigned int>(gaddrof(CVehicleModelInfo::SetVehicleComponentFlags), this, frame, flags);
  125  }

  130  RwObject *CVehicleModelInfo::ClearAtomicFlagCB(RwObject *object, void *data) {
  131:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::ClearAtomicFlagCB), object, data);
  132  }

  137  RwFrame *CVehicleModelInfo::CollapseFramesCB(RwFrame *frame, void *data) {
  138:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CVehicleModelInfo::CollapseFramesCB), frame, data);
  139  }

  151  RpMaterial *CVehicleModelInfo::GetEditableMaterialListCB(RpMaterial *material, void *data) {
  152:     return plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof_o(CVehicleModelInfo::GetEditableMaterialListCB, RpMaterial *(*)(RpMaterial *, void *)), material, data);
  153  }

  158  RpAtomic *CVehicleModelInfo::GetEditableMaterialListCB(RpAtomic *atomic, void *data) {
  159:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof_o(CVehicleModelInfo::GetEditableMaterialListCB, RpAtomic *(*)(RpAtomic *, void *)), atomic, data);
  160  }

  165  int CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors(int modelIndex) {
  166:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors), modelIndex);
  167  }

  172  RpMaterial *CVehicleModelInfo::HasAlphaMaterialCB(RpMaterial *material, void *data) {
  173:     return plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(CVehicleModelInfo::HasAlphaMaterialCB), material, data);
  174  }

  179  RpMaterial *CVehicleModelInfo::HasSpecularMaterialCB(RpMaterial *material, void *data) {
  180:     return plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(CVehicleModelInfo::HasSpecularMaterialCB), material, data);
  181  }

  186  RpAtomic *CVehicleModelInfo::HideAllComponentsAtomicCB(RpAtomic *atomic, void *data) {
  187:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::HideAllComponentsAtomicCB), atomic, data);
  188  }

  193  RpAtomic *CVehicleModelInfo::HideDamagedAtomicCB(RpAtomic *atomic, void *data) {
  194:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::HideDamagedAtomicCB), atomic, data);
  195  }

  214  RwObject *CVehicleModelInfo::MoveObjectsCB(RwObject *object, void *data) {
  215:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::MoveObjectsCB), object, data);
  216  }

  221  RwObject *CVehicleModelInfo::SetAtomicFlagCB(RwObject *object, void *data) {
  222:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::SetAtomicFlagCB), object, data);
  223  }

  228  RpAtomic *CVehicleModelInfo::SetAtomicRendererCB(RpAtomic *atomic, void *data) {
  229:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB), atomic, data);
  230  }

  235  RpAtomic *CVehicleModelInfo::SetAtomicRendererCB_BigVehicle(RpAtomic *atomic, void *data) {
  236:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_BigVehicle), atomic, data);
  237  }

  242  RpAtomic *CVehicleModelInfo::SetAtomicRendererCB_Boat(RpAtomic *atomic, void *data) {
  243:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Boat), atomic, data);
  244  }

  249  RpAtomic *CVehicleModelInfo::SetAtomicRendererCB_Heli(RpAtomic *atomic, void *data) {
  250:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Heli), atomic, data);
  251  }

  256  RpAtomic *CVehicleModelInfo::SetAtomicRendererCB_Train(RpAtomic *atomic, void *data) {
  257:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Train), atomic, data);
  258  }

  263  RpMaterial *CVehicleModelInfo::SetEnvironmentMapCB(RpMaterial *material, void *data) {
  264:     return plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof_o(CVehicleModelInfo::SetEnvironmentMapCB, RpMaterial *(*)(RpMaterial *, void *)), material, data);
  265  }

  270  RpAtomic *CVehicleModelInfo::SetEnvironmentMapCB(RpAtomic *atomic, void *data) {
  271:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof_o(CVehicleModelInfo::SetEnvironmentMapCB, RpAtomic *(*)(RpAtomic *, void *)), atomic, data);
  272  }

  284  RwObject *GetOkAndDamagedAtomicCB(RwObject *object, void *data) {
  285:     return plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetOkAndDamagedAtomicCB), object, data);
  286  }

  291  bool IsValidCompRule(int rule) {
  292:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(IsValidCompRule), rule);
  293  }

  298  int GetListOfComponentsNotUsedByRules(unsigned int compRulesBits, int numExtras, int *variationsList) {
  299:     return plugin::CallAndReturnDynGlobal<int, unsigned int, int, int *>(gaddrof(GetListOfComponentsNotUsedByRules), compRulesBits, numExtras, variationsList);
  300  }

  305  int CountCompsInRule(int compRulesBits) {
  306:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CountCompsInRule), compRulesBits);
  307  }

  312  int ChooseComponent(int rule, int compRulesBits) {
  313:     return plugin::CallAndReturnDynGlobal<int, int, int>(gaddrof(ChooseComponent), rule, compRulesBits);
  314  }

  319  RwTexture *CreateCarColourTexture(unsigned char red, unsigned char green, unsigned char blue) {
  320:     return plugin::CallAndReturnDynGlobal<RwTexture *, unsigned char, unsigned char, unsigned char>(gaddrof(CreateCarColourTexture), red, green, blue);
  321  }

plugin_III\game_III\CVisibilityPlugins.cpp:
   31  void *CVisibilityPlugins::AtomicConstructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   32:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicConstructor), object, offsetInObject, sizeInObject);
   33  }

   38  void *CVisibilityPlugins::AtomicCopyConstructor(void *dstObject, void const *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   39:     return plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);
   40  }

   45  void *CVisibilityPlugins::AtomicDestructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   46:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicDestructor), object, offsetInObject, sizeInObject);
   47  }

   52  void CVisibilityPlugins::ClearAtomicFlag(RpAtomic *atomic, int flag) {
   53:     plugin::CallDynGlobal<RpAtomic *, int>(gaddrof(CVisibilityPlugins::ClearAtomicFlag), atomic, flag);
   54  }

   59  void *CVisibilityPlugins::ClumpConstructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   60:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpConstructor), object, offsetInObject, sizeInObject);
   61  }

   66  void *CVisibilityPlugins::ClumpCopyConstructor(void *dstObject, void const *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   67:     return plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);
   68  }

   73  void *CVisibilityPlugins::ClumpDestructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   74:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpDestructor), object, offsetInObject, sizeInObject);
   75  }

   80  bool CVisibilityPlugins::DefaultVisibilityCB(RpClump *clump) {
   81:     return plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::DefaultVisibilityCB), clump);
   82  }

   87  void *CVisibilityPlugins::FrameConstructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   88:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameConstructor), object, offsetInObject, sizeInObject);
   89  }

   94  void *CVisibilityPlugins::FrameCopyConstructor(void *dstObject, void const *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   95:     return plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);
   96  }

  101  void *CVisibilityPlugins::FrameDestructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  102:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameDestructor), object, offsetInObject, sizeInObject);
  103  }

  108  bool CVisibilityPlugins::FrustumSphereCB(RpClump *clump) {
  109:     return plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::FrustumSphereCB), clump);
  110  }

  115  int CVisibilityPlugins::GetAtomicId(RpAtomic *atomic) {
  116:     return plugin::CallAndReturnDynGlobal<int, RpAtomic *>(gaddrof(CVisibilityPlugins::GetAtomicId), atomic);
  117  }

  122  CSimpleModelInfo *CVisibilityPlugins::GetAtomicModelInfo(RpAtomic *atomic) {
  123:     return plugin::CallAndReturnDynGlobal<CSimpleModelInfo *, RpAtomic *>(gaddrof(CVisibilityPlugins::GetAtomicModelInfo), atomic);
  124  }

  129  int CVisibilityPlugins::GetClumpAlpha(RpClump *clump) {
  130:     return plugin::CallAndReturnDynGlobal<int, RpClump *>(gaddrof(CVisibilityPlugins::GetClumpAlpha), clump);
  131  }

  136  float CVisibilityPlugins::GetDistanceSquaredFromCamera(RwFrame *frame) {
  137:     return plugin::CallAndReturnDynGlobal<float, RwFrame *>(gaddrof(CVisibilityPlugins::GetDistanceSquaredFromCamera), frame);
  138  }

  143  float CVisibilityPlugins::GetDotProductWithCameraVector(RwMatrix *atomicMat, RwMatrix *clumpMat, unsigned int flag) {
  144:     return plugin::CallAndReturnDynGlobal<float, RwMatrix *, RwMatrix *, unsigned int>(gaddrof(CVisibilityPlugins::GetDotProductWithCameraVector), atomicMat, clumpMat, flag);
  145  }

  150  int CVisibilityPlugins::GetFrameHierarchyId(RwFrame *frame) {
  151:     return plugin::CallAndReturnDynGlobal<int, RwFrame *>(gaddrof(CVisibilityPlugins::GetFrameHierarchyId), frame);
  152  }

  178  bool CVisibilityPlugins::InsertAtomicIntoSortedList(RpAtomic *atomic, float dist) {
  179:     return plugin::CallAndReturnDynGlobal<bool, RpAtomic *, float>(gaddrof(CVisibilityPlugins::InsertAtomicIntoSortedList), atomic, dist);
  180  }

  185  bool CVisibilityPlugins::InsertEntityIntoSortedList(CEntity *entity, float dist) {
  186:     return plugin::CallAndReturnDynGlobal<bool, CEntity *, float>(gaddrof(CVisibilityPlugins::InsertEntityIntoSortedList), entity, dist);
  187  }

  192  bool CVisibilityPlugins::MloVisibilityCB(RpClump *clump) {
  193:     return plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::MloVisibilityCB), clump);
  194  }

  199  bool CVisibilityPlugins::PluginAttach() {
  200:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CVisibilityPlugins::PluginAttach));
  201  }

  206  RpAtomic *CVisibilityPlugins::RenderAlphaAtomic(RpAtomic *atomic, int alpha) {
  207:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, int>(gaddrof(CVisibilityPlugins::RenderAlphaAtomic), atomic, alpha);
  208  }

  220  RpAtomic *CVisibilityPlugins::RenderFadingAtomic(RpAtomic *atomic, float camdist) {
  221:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, float>(gaddrof(CVisibilityPlugins::RenderFadingAtomic), atomic, camdist);
  222  }

  234  RpAtomic *CVisibilityPlugins::RenderObjAlwaysAtomic(RpAtomic *atomic) {
  235:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderObjAlwaysAtomic), atomic);
  236  }

  241  RpAtomic *CVisibilityPlugins::RenderPedHiDetailCB(RpAtomic *atomic) {
  242:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPedHiDetailCB), atomic);
  243  }

  248  RpAtomic *CVisibilityPlugins::RenderPedLowDetailCB(RpAtomic *atomic) {
  249:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPedLowDetailCB), atomic);
  250  }

  255  RpAtomic *CVisibilityPlugins::RenderPlayerCB(RpAtomic *atomic) {
  256:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPlayerCB), atomic);
  257  }

  262  RpAtomic *CVisibilityPlugins::RenderTrainHiDetailAlphaCB(RpAtomic *atomic) {
  263:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderTrainHiDetailAlphaCB), atomic);
  264  }

  269  RpAtomic *CVisibilityPlugins::RenderTrainHiDetailCB(RpAtomic *atomic) {
  270:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderTrainHiDetailCB), atomic);
  271  }

  276  RpAtomic *CVisibilityPlugins::RenderVehicleHiDetailAlphaCB(RpAtomic *atomic) {
  277:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailAlphaCB), atomic);
  278  }

  283  RpAtomic *CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle(RpAtomic *atomic) {
  284:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle), atomic);
  285  }

  290  RpAtomic *CVisibilityPlugins::RenderVehicleHiDetailCB(RpAtomic *atomic) {
  291:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB), atomic);
  292  }

  297  RpAtomic *CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle(RpAtomic *atomic) {
  298:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle), atomic);
  299  }

  304  RpAtomic *CVisibilityPlugins::RenderVehicleHiDetailCB_Boat(RpAtomic *atomic) {
  305:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB_Boat), atomic);
  306  }

  311  RpAtomic *CVisibilityPlugins::RenderVehicleLowDetailAlphaCB_BigVehicle(RpAtomic *atomic) {
  312:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleLowDetailAlphaCB_BigVehicle), atomic);
  313  }

  318  RpAtomic *CVisibilityPlugins::RenderVehicleLowDetailCB_BigVehicle(RpAtomic *atomic) {
  319:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleLowDetailCB_BigVehicle), atomic);
  320  }

  325  RpAtomic *CVisibilityPlugins::RenderVehicleReallyLowDetailCB(RpAtomic *atomic) {
  326:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleReallyLowDetailCB), atomic);
  327  }

  332  RpAtomic *CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle(RpAtomic *atomic) {
  333:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle), atomic);
  334  }

  339  RpAtomic *CVisibilityPlugins::RenderWheelAtomicCB(RpAtomic *atomic) {
  340:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderWheelAtomicCB), atomic);
  341  }

  346  void CVisibilityPlugins::SetAtomicFlag(RpAtomic *atomic, int flag) {
  347:     plugin::CallDynGlobal<RpAtomic *, int>(gaddrof(CVisibilityPlugins::SetAtomicFlag), atomic, flag);
  348  }

  353  void CVisibilityPlugins::SetAtomicModelInfo(RpAtomic *atomic, CSimpleModelInfo *info) {
  354:     plugin::CallDynGlobal<RpAtomic *, CSimpleModelInfo *>(gaddrof(CVisibilityPlugins::SetAtomicModelInfo), atomic, info);
  355  }

  360  void CVisibilityPlugins::SetAtomicRenderCallback(RpAtomic *atomic, RpAtomic *(*f)(RpAtomic *)) {
  361:     plugin::CallDynGlobal<RpAtomic *, RpAtomic *(*)(RpAtomic *)>(gaddrof(CVisibilityPlugins::SetAtomicRenderCallback), atomic, f);
  362  }

  367  void CVisibilityPlugins::SetClumpAlpha(RpClump *clump, int alpha) {
  368:     plugin::CallDynGlobal<RpClump *, int>(gaddrof(CVisibilityPlugins::SetClumpAlpha), clump, alpha);
  369  }

  374  void CVisibilityPlugins::SetClumpModelInfo(RpClump *clump, CClumpModelInfo *info) {
  375:     plugin::CallDynGlobal<RpClump *, CClumpModelInfo *>(gaddrof(CVisibilityPlugins::SetClumpModelInfo), clump, info);
  376  }

  381  void CVisibilityPlugins::SetFrameHierarchyId(RwFrame *frame, int id) {
  382:     plugin::CallDynGlobal<RwFrame *, int>(gaddrof(CVisibilityPlugins::SetFrameHierarchyId), frame, id);
  383  }

  388  void CVisibilityPlugins::SetRenderWareCamera(RwCamera *camera) {
  389:     plugin::CallDynGlobal<RwCamera *>(gaddrof(CVisibilityPlugins::SetRenderWareCamera), camera);
  390  }

  402  bool CVisibilityPlugins::VehicleVisibilityCB(RpClump *clump) {
  403:     return plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::VehicleVisibilityCB), clump);
  404  }

  409  bool CVisibilityPlugins::VehicleVisibilityCB_BigVehicle(RpClump *clump) {
  410:     return plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::VehicleVisibilityCB_BigVehicle), clump);
  411  }

  416  RpMaterial *SetAlphaCB(RpMaterial *material, void *data) {
  417:     return plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(SetAlphaCB), material, data);
  418  }

  423  RpMaterial *SetTextureCB(RpMaterial *material, void *data) {
  424:     return plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(SetTextureCB), material, data);
  425  }

plugin_III\game_III\CWanted.cpp:
   20  void CCrimeBeingQd::operator=(CCrimeBeingQd const &right) {
   21:     plugin::CallMethodDynGlobal<CCrimeBeingQd *, CCrimeBeingQd const &>(gaddrof_o(CCrimeBeingQd::operator=, void (CCrimeBeingQd::*)(CCrimeBeingQd const &)), this, right);
   22  }

   27  bool CWanted::AddCrimeToQ(eCrimeType crimeType, int crimeId, CVector const &pos, bool bAlreadyReported, bool bPoliceDontReallyCare) {
   28:     return plugin::CallMethodAndReturnDynGlobal<bool, CWanted *, eCrimeType, int, CVector const &, bool, bool>(gaddrof(CWanted::AddCrimeToQ), this, crimeType, crimeId, pos, bAlreadyReported, bPoliceDontReallyCare);
   29  }

   34  bool CWanted::AreArmyRequired() {
   35:     return plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreArmyRequired), this);
   36  }

   41  bool CWanted::AreFbiRequired() {
   42:     return plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreFbiRequired), this);
   43  }

   48  bool CWanted::AreSwatRequired() {
   49:     return plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreSwatRequired), this);
   50  }

   55  void CWanted::ClearQdCrimes() {
   56:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::ClearQdCrimes), this);
   57  }

   62  void CWanted::Initialise() {
   63:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Initialise), this);
   64  }

   69  int CWanted::NumOfHelisRequired() {
   70:     return plugin::CallMethodAndReturnDynGlobal<int, CWanted *>(gaddrof(CWanted::NumOfHelisRequired), this);
   71  }

   76  void CWanted::RegisterCrime(eCrimeType crimeType, CVector const &pos, unsigned int crimeId, bool bPoliceDontReallyCare) {
   77:     plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, unsigned int, bool>(gaddrof(CWanted::RegisterCrime), this, crimeType, pos, crimeId, bPoliceDontReallyCare);
   78  }

   83  void CWanted::RegisterCrime_Immediately(eCrimeType crimeType, CVector const &pos, unsigned int crimeId, bool bPoliceDontReallyCare) {
   84:     plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, unsigned int, bool>(gaddrof(CWanted::RegisterCrime_Immediately), this, crimeType, pos, crimeId, bPoliceDontReallyCare);
   85  }

   90  void CWanted::ReportCrimeNow(eCrimeType crimeType, CVector const &pos, bool bPoliceDontReallyCare) {
   91:     plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, bool>(gaddrof(CWanted::ReportCrimeNow), this, crimeType, pos, bPoliceDontReallyCare);
   92  }

   97  void CWanted::Reset() {
   98:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Reset), this);
   99  }

  104  void CWanted::ResetPolicePursuit() {
  105:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::ResetPolicePursuit), this);
  106  }

  111  void CWanted::SetWantedLevel(int level) {
  112:     plugin::CallMethodDynGlobal<CWanted *, int>(gaddrof(CWanted::SetWantedLevel), this, level);
  113  }

  118  void CWanted::SetWantedLevelNoDrop(int level) {
  119:     plugin::CallMethodDynGlobal<CWanted *, int>(gaddrof(CWanted::SetWantedLevelNoDrop), this, level);
  120  }

  125  void CWanted::Update() {
  126:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Update), this);
  127  }

  132  void CWanted::UpdateCrimesQ() {
  133:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::UpdateCrimesQ), this);
  134  }

  139  void CWanted::UpdateWantedLevel() {
  140:     plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::UpdateWantedLevel), this);
  141  }

  146  void CWanted::SetMaximumWantedLevel(int level) {
  147:     plugin::CallDynGlobal<int>(gaddrof(CWanted::SetMaximumWantedLevel), level);
  148  }

  153  int CWanted::WorkOutPolicePresence(CVector pos, float radius) {
  154:     return plugin::CallAndReturnDynGlobal<int, CVector, float>(gaddrof(CWanted::WorkOutPolicePresence), pos, radius);
  155  }

plugin_III\game_III\CWaterCannon.cpp:
  20  void CWaterCannon::Init() {
  21:     plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::Init), this);
  22  }

  27  void CWaterCannon::PushPeds() {
  28:     plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::PushPeds), this);
  29  }

  34  void CWaterCannon::Render() {
  35:     plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::Render), this);
  36  }

  41  void CWaterCannon::Update_NewInput(CVector *pos, CVector *dir) {
  42:     plugin::CallMethodDynGlobal<CWaterCannon *, CVector *, CVector *>(gaddrof(CWaterCannon::Update_NewInput), this, pos, dir);
  43  }

  48  void CWaterCannon::Update_OncePerFrame(short index) {
  49:     plugin::CallMethodDynGlobal<CWaterCannon *, short>(gaddrof(CWaterCannon::Update_OncePerFrame), this, index);
  50  }

plugin_III\game_III\CWaterCannons.cpp:
  37  void CWaterCannons::UpdateOne(unsigned int id, CVector *pos, CVector *dir) {
  38:     plugin::CallDynGlobal<unsigned int, CVector *, CVector *>(gaddrof(CWaterCannons::UpdateOne), id, pos, dir);
  39  }

plugin_III\game_III\CWeapon.cpp:
   20  void CWeapon::AddGunshell(CEntity *shooter, CVector const &source, CVector2D const &direction, float size) {
   21:     plugin::CallMethodDynGlobal<CWeapon *, CEntity *, CVector const &, CVector2D const &, float>(gaddrof(CWeapon::AddGunshell), this, shooter, source, direction, size);
   22  }

   27  void CWeapon::DoBulletImpact(CEntity *shooter, CEntity *victim, CVector *source, CVector *target, CColPoint *colPoint, CVector2D ahead) {
   28:     plugin::CallMethodDynGlobal<CWeapon *, CEntity *, CEntity *, CVector *, CVector *, CColPoint *, CVector2D>(gaddrof(CWeapon::DoBulletImpact), this, shooter, victim, source, target, colPoint, ahead);
   29  }

   34  bool CWeapon::Fire(CEntity *shooter, CVector *fireSource) {
   35:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::Fire), this, shooter, fireSource);
   36  }

   41  bool CWeapon::FireAreaEffect(CEntity *shooter, CVector *fireSource) {
   42:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireAreaEffect), this, shooter, fireSource);
   43  }

   48  bool CWeapon::FireFromCar(CAutomobile *shooter, bool left) {
   49:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CAutomobile *, bool>(gaddrof(CWeapon::FireFromCar), this, shooter, left);
   50  }

   55  bool CWeapon::FireInstantHit(CEntity *shooter, CVector *fireSource) {
   56:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireInstantHit), this, shooter, fireSource);
   57  }

   62  bool CWeapon::FireInstantHitFromCar(CAutomobile *shooter, bool left) {
   63:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CAutomobile *, bool>(gaddrof(CWeapon::FireInstantHitFromCar), this, shooter, left);
   64  }

   69  bool CWeapon::FireM16_1stPerson(CEntity *shooter) {
   70:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *>(gaddrof(CWeapon::FireM16_1stPerson), this, shooter);
   71  }

   76  bool CWeapon::FireMelee(CEntity *shooter, CVector &fireSource) {
   77:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector &>(gaddrof(CWeapon::FireMelee), this, shooter, fireSource);
   78  }

   83  bool CWeapon::FireProjectile(CEntity *shooter, CVector *fireSource, float power) {
   84:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *, float>(gaddrof(CWeapon::FireProjectile), this, shooter, fireSource, power);
   85  }

   90  bool CWeapon::FireShotgun(CEntity *shooter, CVector *fireSource) {
   91:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireShotgun), this, shooter, fireSource);
   92  }

   97  bool CWeapon::FireSniper(CEntity *shooter) {
   98:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *>(gaddrof(CWeapon::FireSniper), this, shooter);
   99  }

  104  bool CWeapon::HasWeaponAmmoToBeUsed() {
  105:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::HasWeaponAmmoToBeUsed), this);
  106  }

  111  bool CWeapon::HitsGround(CEntity *holder, CVector *fireSource, CEntity *aimingTo) {
  112:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *, CEntity *>(gaddrof(CWeapon::HitsGround), this, holder, fireSource, aimingTo);
  113  }

  118  void CWeapon::Initialise(eWeaponType type, int ammo) {
  119:     plugin::CallMethodDynGlobal<CWeapon *, eWeaponType, int>(gaddrof(CWeapon::Initialise), this, type, ammo);
  120  }

  125  bool CWeapon::IsType2Handed() {
  126:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::IsType2Handed), this);
  127  }

  132  bool CWeapon::IsTypeMelee() {
  133:     return plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::IsTypeMelee), this);
  134  }

  139  void CWeapon::Reload() {
  140:     plugin::CallMethodDynGlobal<CWeapon *>(gaddrof(CWeapon::Reload), this);
  141  }

  146  void CWeapon::Update(int audioEntity) {
  147:     plugin::CallMethodDynGlobal<CWeapon *, int>(gaddrof(CWeapon::Update), this, audioEntity);
  148  }

  153  void CWeapon::BlowUpExplosiveThings(CEntity *thing) {
  154:     plugin::CallDynGlobal<CEntity *>(gaddrof(CWeapon::BlowUpExplosiveThings), thing);
  155  }

  160  void CWeapon::DoDoomAiming(CEntity *shooter, CVector *source, CVector *target) {
  161:     plugin::CallDynGlobal<CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoDoomAiming), shooter, source, target);
  162  }

  167  void CWeapon::DoDriveByAutoAiming(CEntity *shooter, CVector *source, CVector *target) {
  168:     plugin::CallDynGlobal<CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoDriveByAutoAiming), shooter, source, target);
  169  }

  174  void CWeapon::DoTankDoomAiming(CEntity *shooter, CEntity *driver, CVector *source, CVector *target) {
  175:     plugin::CallDynGlobal<CEntity *, CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoTankDoomAiming), shooter, driver, source, target);
  176  }

  181  void CWeapon::GenerateFlameThrowerParticles(CVector pos, CVector dir) {
  182:     plugin::CallDynGlobal<CVector, CVector>(gaddrof(CWeapon::GenerateFlameThrowerParticles), pos, dir);
  183  }

  195  void CWeapon::MakePedsJumpAtShot(CPhysical *shooter, CVector *source, CVector *target) {
  196:     plugin::CallDynGlobal<CPhysical *, CVector *, CVector *>(gaddrof(CWeapon::MakePedsJumpAtShot), shooter, source, target);
  197  }

  202  bool CWeapon::ProcessLineOfSight(CVector const &origin, CVector const &target, CColPoint &point, CEntity **outEntity, eWeaponType type, CEntity *entity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  203:     return plugin::CallAndReturnDynGlobal<bool, CVector const &, CVector const &, CColPoint &, CEntity **, eWeaponType, CEntity *, bool, bool, bool, bool, bool, bool, bool>(gaddrof(CWeapon::ProcessLineOfSight), origin, target, point, outEntity, type, entity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  204  }

  223  void FireOneInstantHitRound(CVector *source, CVector *target, int damage) {
  224:     plugin::CallDynGlobal<CVector *, CVector *, int>(gaddrof(FireOneInstantHitRound), source, target, damage);
  225  }

plugin_III\game_III\CWeaponEffects.cpp:
  14  CWeaponEffects::CWeaponEffects() {
  15:     plugin::CallMethod<0x564C40, CWeaponEffects *>(this);
  16  }

  19  void CWeaponEffects::ClearCrossHair() {
  20:     plugin::Call<0x564D60>();
  21  }

  24  void CWeaponEffects::Init() {
  25:     plugin::Call<0x564C60>();
  26  }

  29  void CWeaponEffects::MarkTarget(CVector pos, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, float size) {
  30:     plugin::Call<0x564D00, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float>(pos, red, green, blue, alpha, size);
  31  }

  34  void CWeaponEffects::Render() {
  35:     plugin::Call<0x564D70>();
  36  }

  39  void CWeaponEffects::Shutdown() {
  40:     plugin::Call<0x564CF0>();
  41  }

  44  CWeaponEffects::~CWeaponEffects() {
  45:     plugin::CallMethod<0x564C50, CWeaponEffects *>(this);
  46  }

plugin_III\game_III\CWeaponInfo.cpp:
  13  CWeaponInfo::CWeaponInfo() {
  14:     plugin::CallMethod<0x5654F0, CWeaponInfo *>(this);
  15  }

  19      eWeaponFire result;
  20:     plugin::CallAndReturn<eWeaponFire, 0x5653E0, eWeaponFire*, char*>(&result, name);
  21      return result;

  26      eWeaponType result;
  27:     plugin::CallAndReturn<eWeaponType, 0x5653B0, eWeaponType*, char*>(&result, name);
  28      return result;

  32  CWeaponInfo* CWeaponInfo::GetWeaponInfo(eWeaponType weaponType) {
  33:     return plugin::CallAndReturn<CWeaponInfo*, 0x564FD0, eWeaponType>(weaponType);
  34  }

  37  void CWeaponInfo::Initialise() {
  38:     plugin::Call<0x564EA0>();
  39  }

  42  void CWeaponInfo::LoadWeaponData() {
  43:     plugin::Call<0x564FE0>();
  44  }

  47  void CWeaponInfo::Shutdown() {
  48:     plugin::Call<0x564FB0>();
  49  }

  52  CWeaponInfo::~CWeaponInfo() {
  53:     plugin::CallMethod<0x5654E0, CWeaponInfo *>(this);
  54  }

plugin_III\game_III\CWeather.cpp:
   49  void CWeather::ForceWeather(short weather) {
   50:     plugin::CallDynGlobal<short>(gaddrof(CWeather::ForceWeather), weather);
   51  }

   56  void CWeather::ForceWeatherNow(short weather) {
   57:     plugin::CallDynGlobal<short>(gaddrof(CWeather::ForceWeatherNow), weather);
   58  }

  105  void RenderOneRainStreak(CVector pos, CVector unused, int intensity, bool scale, float distance) {
  106:     plugin::CallDynGlobal<CVector, CVector, int, bool, float>(gaddrof(RenderOneRainStreak), pos, unused, intensity, scale, distance);
  107  }

plugin_III\game_III\CWorld.cpp:
   25  void CWorld::Add(CEntity* entity) {
   26:     plugin::Call<0x4AE930, CEntity*>(entity);
   27  }

   30  void CWorld::AddParticles() {
   31:     plugin::Call<0x4B4010>();
   32  }

   35  void CWorld::CallOffChaseForArea(float x1, float y1, float x2, float y2) {
   36:     plugin::Call<0x4B5530, float, float, float, float>(x1, y1, x2, y2);
   37  }

   40  void CWorld::CallOffChaseForAreaSectorListPeds(CPtrList& list, float x1, float y1, float x2, float y2, float arg5, float arg6, float arg7, float arg8) {
   41:     plugin::Call<0x4B5A60, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
   42  }

   45  void CWorld::CallOffChaseForAreaSectorListVehicles(CPtrList& list, float x1, float y1, float x2, float y2, float arg5, float arg6, float arg7, float arg8) {
   46:     plugin::Call<0x4B57B0, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
   47  }

   50  bool CWorld::CameraToIgnoreThisObject(CEntity* entity) {
   51:     return plugin::CallAndReturn<bool, 0x4B5C30, CEntity*>(entity);
   52  }

   55  void CWorld::ClearCarsFromArea(float x1, float y1, float z1, float x2, float y2, float z2) {
   56:     plugin::Call<0x4B50E0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
   57  }

   60  void CWorld::ClearExcitingStuffFromArea(CVector const& point, float radius, unsigned char bRemoveProjectilesAndShadows) {
   61:     plugin::Call<0x4B4E70, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);
   62  }

   65  void CWorld::ClearForRestart() {
   66:     plugin::Call<0x4AE850>();
   67  }

   70  void CWorld::ClearPedsFromArea(float x1, float y1, float z1, float x2, float y2, float z2) {
   71:     plugin::Call<0x4B52B0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
   72  }

   75  void CWorld::ClearScanCodes() {
   76:     plugin::Call<0x4B1F60>();
   77  }

   80  void CWorld::ExtinguishAllCarFiresInArea(CVector point, float radius) {
   81:     plugin::Call<0x4B5460, CVector, float>(point, radius);
   82  }

   85  float CWorld::FindGroundZFor3DCoord(float x, float y, float z, bool* outResult) {
   86:     return plugin::CallAndReturn<float, 0x4B3AE0, float, float, float, bool*>(x, y, z, outResult);
   87  }

   90  float CWorld::FindGroundZForCoord(float x, float y) {
   91:     return plugin::CallAndReturn<float, 0x4B3A80, float, float>(x, y);
   92  }

   95  void CWorld::FindMissionEntitiesIntersectingCube(CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool vehicles, bool peds, bool objects) {
   96:     plugin::Call<0x4B3680, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);
   97  }

  100  void CWorld::FindMissionEntitiesIntersectingCubeSectorList(CPtrList& list, CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool vehiclesList, bool pedsList, bool objectsList) {
  101:     plugin::Call<0x4B3920, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);
  102  }

  105  void CWorld::FindObjectsInRange(CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  106:     plugin::Call<0x4B2200, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  107  }

  110  void CWorld::FindObjectsInRangeSectorList(CPtrList& list, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  111:     plugin::Call<0x4B2540, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
  112  }

  115  void CWorld::FindObjectsIntersectingAngledCollisionBox(CColBox const& box, CMatrix const& transform, CVector const& point, float x1, float y1, float x2, float y2, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  116:     plugin::Call<0x4B3280, CColBox const&, CMatrix const&, CVector const&, float, float, float, float, short*, short, CEntity**, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  117  }

  120  void CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(CPtrList& list, CColBox const& box, CMatrix const& transform, CVector const& poin, short* outCount, short maxCount, CEntity** outEntities) {
  121:     plugin::Call<0x4B3590, CPtrList&, CColBox const&, CMatrix const&, CVector const&, short*, short, CEntity**>(list, box, transform, poin, outCount, maxCount, outEntities);
  122  }

  125  void CWorld::FindObjectsIntersectingCube(CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  126:     plugin::Call<0x4B2E70, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  127  }

  130  void CWorld::FindObjectsIntersectingCubeSectorList(CPtrList& list, CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities) {
  131:     plugin::Call<0x4B3150, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**>(list, cornerA, cornerB, outCount, maxCount, outEntities);
  132  }

  135  void CWorld::FindObjectsKindaColliding(CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  136:     plugin::Call<0x4B2A30, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  137  }

  140  void CWorld::FindObjectsKindaCollidingSectorList(CPtrList& list, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  141:     plugin::Call<0x4B2D70, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
  142  }

  145  void CWorld::FindObjectsOfTypeInRange(unsigned int modelId, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  146:     plugin::Call<0x4B2600, unsigned int, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  147  }

  150  void CWorld::FindObjectsOfTypeInRangeSectorList(unsigned int modelId, CPtrList& list, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  151:     plugin::Call<0x4B2960, unsigned int, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(modelId, list, point, radius, b2D, outCount, maxCount, outEntities);
  152  }

  155  float CWorld::FindRoofZFor3DCoord(float x, float y, float z, bool* outResult) {
  156:     return plugin::CallAndReturn<float, 0x4B3B50, float, float, float, bool*>(x, y, z, outResult);
  157  }

  160  bool CWorld::GetIsLineOfSightClear(CVector const& origin, CVector const& target, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  161:     return plugin::CallAndReturn<bool, 0x4AEAA0, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  162  }

  165  bool CWorld::GetIsLineOfSightSectorClear(CSector& sector, CColLine const& line, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  166:     return plugin::CallAndReturn<bool, 0x4B2000, CSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  167  }

  170  bool CWorld::GetIsLineOfSightSectorListClear(CPtrList& list, CColLine const& line, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  171:     return plugin::CallAndReturn<bool, 0x4B2160, CPtrList&, CColLine const&, bool, bool>(list, line, doSeeThroughCheck, doCameraIgnoreCheck);
  172  }

  175  void CWorld::Initialise() {
  176:     plugin::Call<0x4AE410>();
  177  }

  180  void CWorld::Process() {
  181:     plugin::Call<0x4B1A60>();
  182  }

  185  bool CWorld::ProcessLineOfSight(CVector const& origin, CVector const& target, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  186:     return plugin::CallAndReturn<bool, 0x4AF970, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  187  }

  190  bool CWorld::ProcessLineOfSightSector(CSector& sector, CColLine const& line, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  191:     return plugin::CallAndReturn<bool, 0x4B0A80, CSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool>(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  192  }

  195  bool CWorld::ProcessLineOfSightSectorList(CPtrList& list, CColLine const& line, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  196:     return plugin::CallAndReturn<bool, 0x4B0C70, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck);
  197  }

  200  bool CWorld::ProcessVerticalLine(CVector const& origin, float distance, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  201:     return plugin::CallAndReturn<bool, 0x4B0DE0, CVector const&, float, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  202  }

  205  bool CWorld::ProcessVerticalLineSector(CSector& sector, CColLine const& line, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  206:     return plugin::CallAndReturn<bool, 0x4B0EF0, CSector&, CColLine const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  207  }

  210  bool CWorld::ProcessVerticalLineSectorList(CPtrList& list, CColLine const& line, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  211:     return plugin::CallAndReturn<bool, 0x4B1090, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, CStoredCollPoly*>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, outCollPoly);
  212  }

  215  void CWorld::Remove(CEntity* entity) {
  216:     plugin::Call<0x4AE9D0, CEntity*>(entity);
  217  }

  220  void CWorld::RemoveEntityInsteadOfProcessingIt(CEntity* entity) {
  221:     plugin::Call<0x4B4E10, CEntity*>(entity);
  222  }

  225  void CWorld::RemoveFallenCars() {
  226:     plugin::Call<0x4B4170>();
  227  }

  230  void CWorld::RemoveFallenPeds() {
  231:     plugin::Call<0x4B4060>();
  232  }

  235  void CWorld::RemoveReferencesToDeletedObject(CEntity* entity) {
  236:     plugin::Call<0x4B3BF0, CEntity*>(entity);
  237  }

  240  void CWorld::RemoveStaticObjects() {
  241:     plugin::Call<0x4B4D50>();
  242  }

  245  void CWorld::RepositionCertainDynamicObjects() {
  246:     plugin::Call<0x4B42B0>();
  247  }

  250  void CWorld::RepositionOneObject(CEntity* entity) {
  251:     plugin::Call<0x4B4300, CEntity*>(entity);
  252  }

  255  void CWorld::SetAllCarsCanBeDamaged(bool enable) {
  256:     plugin::Call<0x4B53F0, bool>(enable);
  257  }

  260  void CWorld::SetCarsOnFire(float x, float y, float z, float radius, CEntity* fireCreator) {
  261:     plugin::Call<0x4B3E90, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
  262  }

  265  void CWorld::SetPedsOnFire(float x, float y, float z, float radius, CEntity* fireCreator) {
  266:     plugin::Call<0x4B3D30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
  267  }

  270  void CWorld::ShutDown() {
  271:     plugin::Call<0x4AE450>();
  272  }

  275  void CWorld::StopAllLawEnforcersInTheirTracks() {
  276:     plugin::Call<0x4B5BC0>();
  277  }

  280  CEntity* CWorld::TestSphereAgainstSectorList(CPtrList& list, CVector sphereCenter, float sphereRadius, CEntity* ignoreEntity, bool doCameraIgnoreCheck) {
  281:     return plugin::CallAndReturn<CEntity*, 0x4B4AC0, CPtrList&, CVector, float, CEntity*, bool>(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);
  282  }

  285  CEntity* CWorld::TestSphereAgainstWorld(CVector sphereCenter, float sphereRadius, CEntity* ignoreEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck) {
  286:     return plugin::CallAndReturn<CEntity*, 0x4B4710, CVector, float, CEntity*, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck);
  287  }

  290  void CWorld::TriggerExplosion(CVector const& point, float radius, float visibleDistance, CEntity* entity, bool processVehicleBombTimer) {
  291:     plugin::Call<0x4B1140, CVector const&, float, float, CEntity*, bool>(point, radius, visibleDistance, entity, processVehicleBombTimer);
  292  }

  295  void CWorld::TriggerExplosionSectorList(CPtrList& list, CVector const& point, float radius, float visibleDistance, CEntity* entity, bool processVehicleBombTimer) {
  296:     plugin::Call<0x4B1340, CPtrList&, CVector const&, float, float, CEntity*, bool>(list, point, radius, visibleDistance, entity, processVehicleBombTimer);
  297  }

  300  void CWorld::UseDetonator(CEntity* creator) {
  301:     plugin::Call<0x4B4650, CEntity*>(creator);
  302  }

plugin_III\game_III\CXtraCompsModelInfo.cpp:
  23  void CXtraCompsModelInfo::Shutdown() {
  24:     plugin::CallVirtualMethod<1, CXtraCompsModelInfo *>(this);
  25  }

  30  RwObject *CXtraCompsModelInfo::CreateInstance() {
  31:     return plugin::CallVirtualMethodAndReturn<RwObject *, 3, CXtraCompsModelInfo *>(this);
  32  }

  37  void CXtraCompsModelInfo::SetClump(RpClump *clump) {
  38:     plugin::CallVirtualMethod<6, CXtraCompsModelInfo *, RpClump *>(this, clump);
  39  }

plugin_III\game_III\CZone.cpp:
  14  wchar_t *CZone::GetTranslatedName() {
  15:     return plugin::CallMethodAndReturnDynGlobal<wchar_t *, CZone *>(gaddrof(CZone::GetTranslatedName), this);
  16  }

plugin_III\game_III\GenericGameStorage.cpp:
   30  bool GenericSave(int file) {
   31:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(GenericSave), file);
   32  }

   37  bool GenericLoad() {
   38:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(GenericLoad));
   39  }

   44  bool ReadInSizeofSaveFileBuffer(int &file, unsigned int &size) {
   45:     return plugin::CallAndReturnDynGlobal<bool, int &, unsigned int &>(gaddrof(ReadInSizeofSaveFileBuffer), file, size);
   46  }

   51  bool ReadDataFromFile(int file, unsigned char *buf, unsigned int size) {
   52:     return plugin::CallAndReturnDynGlobal<bool, int, unsigned char *, unsigned int>(gaddrof(ReadDataFromFile), file, buf, size);
   53  }

   58  bool CloseFile(int file) {
   59:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CloseFile), file);
   60  }

   72  bool CheckSlotDataValid(int slot) {
   73:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CheckSlotDataValid), slot);
   74  }

   79  void MakeSpaceForSizeInBufferPointer(unsigned char *&preSize, unsigned char *&buf, unsigned char *&postSize) {
   80:     plugin::CallDynGlobal<unsigned char *&, unsigned char *&, unsigned char *&>(gaddrof(MakeSpaceForSizeInBufferPointer), preSize, buf, postSize);
   81  }

   86  void CopySizeAndPreparePointer(unsigned char *&buf, unsigned char *&postBuf, unsigned char *&postBuf2, unsigned int &unused, unsigned int &size) {
   87:     plugin::CallDynGlobal<unsigned char *&, unsigned char *&, unsigned char *&, unsigned int &, unsigned int &>(gaddrof(CopySizeAndPreparePointer), buf, postBuf, postBuf2, unused, size);
   88  }

  100  void MakeValidSaveName(int slot) {
  101:     plugin::CallDynGlobal<int>(gaddrof(MakeValidSaveName), slot);
  102  }

  107  wchar_t *GetSavedGameDateAndTime(int slot) {
  108:     return plugin::CallAndReturnDynGlobal<wchar_t *, int>(gaddrof(GetSavedGameDateAndTime), slot);
  109  }

  114  wchar_t *GetNameOfSavedGame(int slot) {
  115:     return plugin::CallAndReturnDynGlobal<wchar_t *, int>(gaddrof(GetNameOfSavedGame), slot);
  116  }

  121  bool CheckDataNotCorrupt(int slot, char *name) {
  122:     return plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CheckDataNotCorrupt), slot, name);
  123  }

  128  bool RestoreForStartLoad() {
  129:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(RestoreForStartLoad));
  130  }

  135  int align4bytes(int size) {
  136:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(align4bytes), size);
  137  }

plugin_III\game_III\NodeName.cpp:
  16  void *NodeNameConstructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  17:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameConstructor), object, offsetInObject, sizeInObject);
  18  }

  23  void *NodeNameDestructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  24:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameDestructor), object, offsetInObject, sizeInObject);
  25  }

  30  void *NodeNameCopy(void *dstObject, void const *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  31:     return plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(NodeNameCopy), dstObject, srcObject, offsetInObject, sizeInObject);
  32  }

  37  RwStream *NodeNameStreamWrite(RwStream *stream, RwInt32 binaryLength, void const *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  38:     return plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamWrite), stream, binaryLength, object, offsetInObject, sizeInObject);
  39  }

  44  RwStream *NodeNameStreamRead(RwStream *stream, RwInt32 binaryLength, void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  45:     return plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void *, RwInt32, RwInt32>(gaddrof(NodeNameStreamRead), stream, binaryLength, object, offsetInObject, sizeInObject);
  46  }

  51  RwInt32 NodeNameStreamGetSize(void const *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  52:     return plugin::CallAndReturnDynGlobal<RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamGetSize), object, offsetInObject, sizeInObject);
  53  }

  58  RwBool NodeNamePluginAttach() {
  59:     return plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(NodeNamePluginAttach));
  60  }

  65  char *GetFrameNodeName(RwFrame *frame) {
  66:     return plugin::CallAndReturnDynGlobal<char *, RwFrame *>(gaddrof(GetFrameNodeName), frame);
  67  }

plugin_III\game_III\RenderBuffer.cpp:
  35  void RenderBuffer::StartStoring(int numIndices, int numVertices, RwImVertexIndex **indexStart, RwIm3DVertex **vertexStart) {
  36:     plugin::CallDynGlobal<int, int, RwImVertexIndex **, RwIm3DVertex **>(gaddrof(RenderBuffer::StartStoring), numIndices, numVertices, indexStart, vertexStart);
  37  }

plugin_III\game_III\RpAnimBlend.cpp:
   18  void RpAnimBlendClumpUpdateAnimations(RpClump *clump, float timeDelta) {
   19:     plugin::CallDynGlobal<RpClump *, float>(gaddrof(RpAnimBlendClumpUpdateAnimations), clump, timeDelta);
   20  }

   25  void FrameUpdateCallBack(AnimBlendFrameData *frames, void *data) {
   26:     plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBack), frames, data);
   27  }

   32  void FrameUpdateCallBackWithVelocityExtraction(AnimBlendFrameData *frames, void *data) {
   33:     plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBackWithVelocityExtraction), frames, data);
   34  }

   39  void FrameUpdateCallBackWith3dVelocityExtraction(AnimBlendFrameData *frames, void *data) {
   40:     plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBackWith3dVelocityExtraction), frames, data);
   41  }

   46  CAnimBlendAssociation *RpAnimBlendClumpGetFirstAssociation(RpClump *clump) {
   47:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *>(gaddrof_o(RpAnimBlendClumpGetFirstAssociation, CAnimBlendAssociation *(*)(RpClump *)), clump);
   48  }

   53  void *AnimBlendClumpDestroy(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   54:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpDestroy), object, offsetInObject, sizeInObject);
   55  }

   60  void *AnimBlendClumpCreate(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   61:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpCreate), object, offsetInObject, sizeInObject);
   62  }

   67  void RpAnimBlendAllocateData(RpClump *clump) {
   68:     plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendAllocateData), clump);
   69  }

   74  void *AnimBlendClumpCopy(void *dstObject, void const *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject) {
   75:     return plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpCopy), dstObject, srcObject, offsetInObject, sizeInObject);
   76  }

   81  RwBool RpAnimBlendPluginAttach() {
   82:     return plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(RpAnimBlendPluginAttach));
   83  }

   88  RwFrame *FrameForAllChildrenCountCBnonskin(RwFrame *frame, void *data) {
   89:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(FrameForAllChildrenCountCBnonskin), frame, data);
   90  }

   95  RwFrame *FrameForAllChildrenFillFrameArrayCBnonskin(RwFrame *frame, void *data) {
   96:     return plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(FrameForAllChildrenFillFrameArrayCBnonskin), frame, data);
   97  }

  102  void FrameInitCBnonskin(AnimBlendFrameData *frames, void *data) {
  103:     plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameInitCBnonskin), frames, data);
  104  }

  109  void FrameFindByNameCBnonskin(AnimBlendFrameData *frames, void *data) {
  110:     plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameFindByNameCBnonskin), frames, data);
  111  }

  116  void FillFrameArrayCBnonskin(AnimBlendFrameData *frames, void *data) {
  117:     plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FillFrameArrayCBnonskin), frames, data);
  118  }

  123  AnimBlendFrameData *RpAnimBlendClumpFindFrame(RpClump *clump, char const *name) {
  124:     return plugin::CallAndReturnDynGlobal<AnimBlendFrameData *, RpClump *, char const *>(gaddrof(RpAnimBlendClumpFindFrame), clump, name);
  125  }

  130  void RpAnimBlendClumpFillFrameArray(RpClump *clump, AnimBlendFrameData **frames) {
  131:     plugin::CallDynGlobal<RpClump *, AnimBlendFrameData **>(gaddrof(RpAnimBlendClumpFillFrameArray), clump, frames);
  132  }

  137  void RpAnimBlendClumpInit(RpClump *clump) {
  138:     plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendClumpInit), clump);
  139  }

  144  bool RpAnimBlendClumpIsInitialized(RpClump *clump) {
  145:     return plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(RpAnimBlendClumpIsInitialized), clump);
  146  }

  151  void RpAnimBlendClumpSetBlendDeltas(RpClump *clump, unsigned int mask, float delta) {
  152:     plugin::CallDynGlobal<RpClump *, unsigned int, float>(gaddrof(RpAnimBlendClumpSetBlendDeltas), clump, mask, delta);
  153  }

  158  void RpAnimBlendClumpRemoveAllAssociations(RpClump *clump) {
  159:     plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendClumpRemoveAllAssociations), clump);
  160  }

  165  void RpAnimBlendClumpRemoveAssociations(RpClump *clump, unsigned int mask) {
  166:     plugin::CallDynGlobal<RpClump *, unsigned int>(gaddrof(RpAnimBlendClumpRemoveAssociations), clump, mask);
  167  }

  172  CAnimBlendAssociation *RpAnimBlendClumpGetAssociation(RpClump *clump, unsigned int id) {
  173:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, unsigned int>(gaddrof(RpAnimBlendClumpGetAssociation), clump, id);
  174  }

  179  CAnimBlendAssociation *RpAnimBlendClumpGetMainAssociation(RpClump *clump, CAnimBlendAssociation **assocRet, float *blendRet) {
  180:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendAssociation **, float *>(gaddrof(RpAnimBlendClumpGetMainAssociation), clump, assocRet, blendRet);
  181  }

  186  CAnimBlendAssociation *RpAnimBlendClumpGetMainPartialAssociation(RpClump *clump) {
  187:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *>(gaddrof(RpAnimBlendClumpGetMainPartialAssociation), clump);
  188  }

  193  CAnimBlendAssociation *RpAnimBlendClumpGetMainAssociation_N(RpClump *clump, int n) {
  194:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int>(gaddrof(RpAnimBlendClumpGetMainAssociation_N), clump, n);
  195  }

  200  CAnimBlendAssociation *RpAnimBlendClumpGetMainPartialAssociation_N(RpClump *clump, int n) {
  201:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int>(gaddrof(RpAnimBlendClumpGetMainPartialAssociation_N), clump, n);
  202  }

  207  CAnimBlendAssociation *RpAnimBlendClumpGetFirstAssociation(RpClump *clump, unsigned int mask) {
  208:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, unsigned int>(gaddrof_o(RpAnimBlendClumpGetFirstAssociation, CAnimBlendAssociation *(*)(RpClump *, unsigned int)), clump, mask);
  209  }

  214  CAnimBlendAssociation *RpAnimBlendGetNextAssociation(CAnimBlendAssociation *assoc) {
  215:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof_o(RpAnimBlendGetNextAssociation, CAnimBlendAssociation *(*)(CAnimBlendAssociation *)), assoc);
  216  }

  221  CAnimBlendAssociation *RpAnimBlendGetNextAssociation(CAnimBlendAssociation *assoc, unsigned int mask) {
  222:     return plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *, unsigned int>(gaddrof_o(RpAnimBlendGetNextAssociation, CAnimBlendAssociation *(*)(CAnimBlendAssociation *, unsigned int)), assoc, mask);
  223  }

plugin_III\game_III\meta\meta.C2deffectsModelInfo.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), reinterpret_cast<C2deffectsModelInfo *>(objBuff));
  45      }
  46      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  47:         plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), reinterpret_cast<C2deffectsModelInfo *>(objBuff));
  48      }

  54      C2deffectsModelInfo *obj = reinterpret_cast<C2deffectsModelInfo *>(objData);
  55:     plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), obj);
  56      return obj;

  63      for (unsigned int i = 0; i < objCount; i++)
  64:         plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), &objArray[i]);
  65      return objArray;

  69      if (obj == nullptr) return;
  70:     plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), obj);
  71      operator delete(obj);

  78      for (unsigned int i = 0; i < arraySize; i++)
  79:         plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), &objArray[i]);
  80      operator delete(objData);

plugin_III\game_III\meta\meta.C3dMarker.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), reinterpret_cast<C3dMarker *>(objBuff));
  105      }
  106      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  107:         plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), reinterpret_cast<C3dMarker *>(objBuff));
  108      }

  114      C3dMarker *obj = reinterpret_cast<C3dMarker *>(objData);
  115:     plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), obj);
  116      return obj;

  123      for (unsigned int i = 0; i < objCount; i++)
  124:         plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), &objArray[i]);
  125      return objArray;

  129      if (obj == nullptr) return;
  130:     plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), obj);
  131      operator delete(obj);

  138      for (unsigned int i = 0; i < arraySize; i++)
  139:         plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), &objArray[i]);
  140      operator delete(objData);

plugin_III\game_III\meta\meta.CAccident.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), reinterpret_cast<CAccident *>(objBuff));
  45      }
  46      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  47:         plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), reinterpret_cast<CAccident *>(objBuff));
  48      }

  54      CAccident *obj = reinterpret_cast<CAccident *>(objData);
  55:     plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), obj);
  56      return obj;

  63      for (unsigned int i = 0; i < objCount; i++)
  64:         plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), &objArray[i]);
  65      return objArray;

  69      if (obj == nullptr) return;
  70:     plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), obj);
  71      operator delete(obj);

  78      for (unsigned int i = 0; i < arraySize; i++)
  79:         plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), &objArray[i]);
  80      operator delete(objData);

plugin_III\game_III\meta\meta.CAccidentManager.h:
  148      SUPPORTED_10EN_11EN_STEAM stack_object() {
  149:         plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), reinterpret_cast<CAccidentManager *>(objBuff));
  150      }

  156      CAccidentManager *obj = reinterpret_cast<CAccidentManager *>(objData);
  157:     plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), obj);
  158      return obj;

  165      for (unsigned int i = 0; i < objCount; i++)
  166:         plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), &objArray[i]);
  167      return objArray;

  171      if (obj == nullptr) return;
  172:     plugin::CallMethodDynGlobal<CAccidentManager *>(del_dtor_gaddr(CAccidentManager), obj);
  173  }

  179      for (unsigned int i = 0; i < arraySize; i++)
  180:         plugin::CallMethodDynGlobal<CAccidentManager *>(del_dtor_gaddr(CAccidentManager), &objArray[i]);
  181      operator delete(objData);

plugin_III\game_III\meta\meta.CAnimBlendAssocGroup.h:
  178      SUPPORTED_10EN_11EN_STEAM stack_object() {
  179:         plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), reinterpret_cast<CAnimBlendAssocGroup *>(objBuff));
  180      }
  181      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  182:         plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), reinterpret_cast<CAnimBlendAssocGroup *>(objBuff));
  183      }

  189      CAnimBlendAssocGroup *obj = reinterpret_cast<CAnimBlendAssocGroup *>(objData);
  190:     plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), obj);
  191      return obj;

  198      for (unsigned int i = 0; i < objCount; i++)
  199:         plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), &objArray[i]);
  200      return objArray;

  204      if (obj == nullptr) return;
  205:     plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), obj);
  206      operator delete(obj);

  213      for (unsigned int i = 0; i < arraySize; i++)
  214:         plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), &objArray[i]);
  215      operator delete(objData);

plugin_III\game_III\meta\meta.CAnimBlendAssociation.h:
  268      SUPPORTED_10EN_11EN_STEAM stack_object() {
  269:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));
  270      }
  271      SUPPORTED_10EN_11EN_STEAM stack_object(CAnimBlendAssociation &other) {
  272:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), other);
  273      }
  274      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  275:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(dtor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));
  276      }

  282      CAnimBlendAssociation *obj = reinterpret_cast<CAnimBlendAssociation *>(objData);
  283:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), obj);
  284      return obj;

  291      for (unsigned int i = 0; i < objCount; i++)
  292:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), &objArray[i]);
  293      return objArray;

  298      CAnimBlendAssociation *obj = reinterpret_cast<CAnimBlendAssociation *>(objData);
  299:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), obj, other);
  300      return obj;

  304      if (obj == nullptr) return;
  305:     plugin::CallVirtualMethod<0, CAnimBlendAssociation *, int>(obj, 1);
  306  }

  312      for (unsigned int i = 0; i < arraySize; i++)
  313:         plugin::CallVirtualMethod<0, CAnimBlendAssociation *, int>(&objArray[i], 1);
  314      operator delete(objData);

plugin_III\game_III\meta\meta.CAnimBlendClumpData.h:
   73      SUPPORTED_10EN_11EN_STEAM stack_object() {
   74:         plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), reinterpret_cast<CAnimBlendClumpData *>(objBuff));
   75      }
   76      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
   77:         plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), reinterpret_cast<CAnimBlendClumpData *>(objBuff));
   78      }

   84      CAnimBlendClumpData *obj = reinterpret_cast<CAnimBlendClumpData *>(objData);
   85:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), obj);
   86      return obj;

   93      for (unsigned int i = 0; i < objCount; i++)
   94:         plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), &objArray[i]);
   95      return objArray;

   99      if (obj == nullptr) return;
  100:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), obj);
  101      operator delete(obj);

  108      for (unsigned int i = 0; i < arraySize; i++)
  109:         plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), &objArray[i]);
  110      operator delete(objData);

plugin_III\game_III\meta\meta.CAnimBlendHierarchy.h:
  148      SUPPORTED_10EN_11EN_STEAM stack_object() {
  149:         plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), reinterpret_cast<CAnimBlendHierarchy *>(objBuff));
  150      }
  151      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  152:         plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), reinterpret_cast<CAnimBlendHierarchy *>(objBuff));
  153      }

  159      CAnimBlendHierarchy *obj = reinterpret_cast<CAnimBlendHierarchy *>(objData);
  160:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), obj);
  161      return obj;

  168      for (unsigned int i = 0; i < objCount; i++)
  169:         plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), &objArray[i]);
  170      return objArray;

  174      if (obj == nullptr) return;
  175:     plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), obj);
  176      operator delete(obj);

  183      for (unsigned int i = 0; i < arraySize; i++)
  184:         plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), &objArray[i]);
  185      operator delete(objData);

plugin_III\game_III\meta\meta.CAnimBlendSequence.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), reinterpret_cast<CAnimBlendSequence *>(objBuff));
  105      }
  106      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  107:         plugin::CallMethodDynGlobal<CAnimBlendSequence *>(dtor_gaddr(CAnimBlendSequence), reinterpret_cast<CAnimBlendSequence *>(objBuff));
  108      }

  114      CAnimBlendSequence *obj = reinterpret_cast<CAnimBlendSequence *>(objData);
  115:     plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), obj);
  116      return obj;

  123      for (unsigned int i = 0; i < objCount; i++)
  124:         plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), &objArray[i]);
  125      return objArray;

  129      if (obj == nullptr) return;
  130:     plugin::CallVirtualMethod<0, CAnimBlendSequence *, int>(obj, 1);
  131  }

  137      for (unsigned int i = 0; i < arraySize; i++)
  138:         plugin::CallVirtualMethod<0, CAnimBlendSequence *, int>(&objArray[i], 1);
  139      operator delete(objData);

plugin_III\game_III\meta\meta.CAntenna.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), reinterpret_cast<CAntenna *>(objBuff));
  45      }

  51      CAntenna *obj = reinterpret_cast<CAntenna *>(objData);
  52:     plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), obj);
  53      return obj;

  60      for (unsigned int i = 0; i < objCount; i++)
  61:         plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), &objArray[i]);
  62      return objArray;

plugin_III\game_III\meta\meta.cAudioCollision.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), reinterpret_cast<cAudioCollision *>(objBuff));
  30      }

  36      cAudioCollision *obj = reinterpret_cast<cAudioCollision *>(objData);
  37:     plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CAudioHydrant.h:
  58      SUPPORTED_10EN_11EN_STEAM stack_object() {
  59:         plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), reinterpret_cast<CAudioHydrant *>(objBuff));
  60      }

  66      CAudioHydrant *obj = reinterpret_cast<CAudioHydrant *>(objData);
  67:     plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), obj);
  68      return obj;

  75      for (unsigned int i = 0; i < objCount; i++)
  76:         plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), &objArray[i]);
  77      return objArray;

plugin_III\game_III\meta\meta.cAudioScriptObject.h:
  148      SUPPORTED_10EN_11EN_STEAM stack_object() {
  149:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));
  150      }
  151      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  152:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));
  153      }

  157  SUPPORTED_10EN_11EN_STEAM inline cAudioScriptObject *operator_new<cAudioScriptObject>() {
  158:     void *objData = plugin::CallAndReturnDynGlobal<void *, unsigned int>(op_new_gaddr(cAudioScriptObject), sizeof(cAudioScriptObject));
  159      cAudioScriptObject *obj = reinterpret_cast<cAudioScriptObject *>(objData);
  160:     plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), obj);
  161      return obj;

  168      for (unsigned int i = 0; i < objCount; i++)
  169:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), &objArray[i]);
  170      return objArray;

  174      if (obj == nullptr) return;
  175:     plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), obj);
  176:     plugin::CallDynGlobal<void *>(op_delete_gaddr(cAudioScriptObject), obj);
  177  }

  183      for (unsigned int i = 0; i < arraySize; i++)
  184:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), &objArray[i]);
  185      operator delete(objData);

plugin_III\game_III\meta\meta.CBaseModelInfo.h:
  223      SUPPORTED_10EN_11EN_STEAM stack_object(ModelInfoType type) {
  224:         plugin::CallMethodDynGlobal<CBaseModelInfo *, ModelInfoType>(ctor_gaddr_o(CBaseModelInfo, void(ModelInfoType)), reinterpret_cast<CBaseModelInfo *>(objBuff), type);
  225      }
  226      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  227:         plugin::CallMethodDynGlobal<CBaseModelInfo *>(dtor_gaddr(CBaseModelInfo), reinterpret_cast<CBaseModelInfo *>(objBuff));
  228      }

  234      CBaseModelInfo *obj = reinterpret_cast<CBaseModelInfo *>(objData);
  235:     plugin::CallMethodDynGlobal<CBaseModelInfo *, ModelInfoType>(ctor_gaddr_o(CBaseModelInfo, void(ModelInfoType)), obj, type);
  236      return obj;

  240      if (obj == nullptr) return;
  241:     plugin::CallVirtualMethod<0, CBaseModelInfo *>(obj);
  242  }

  248      for (unsigned int i = 0; i < arraySize; i++)
  249:         plugin::CallVirtualMethod<0, CBaseModelInfo *>(&objArray[i]);
  250      operator delete(objData);

plugin_III\game_III\meta\meta.CBrightLight.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), reinterpret_cast<CBrightLight *>(objBuff));
  30      }

  36      CBrightLight *obj = reinterpret_cast<CBrightLight *>(objData);
  37:     plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CBulletInfo.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), reinterpret_cast<CBulletInfo *>(objBuff));
  105      }

  111      CBulletInfo *obj = reinterpret_cast<CBulletInfo *>(objData);
  112:     plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), obj);
  113      return obj;

  120      for (unsigned int i = 0; i < objCount; i++)
  121:         plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), &objArray[i]);
  122      return objArray;

plugin_III\game_III\meta\meta.CBulletTrace.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), reinterpret_cast<CBulletTrace *>(objBuff));
  45      }

  51      CBulletTrace *obj = reinterpret_cast<CBulletTrace *>(objData);
  52:     plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), obj);
  53      return obj;

  60      for (unsigned int i = 0; i < objCount; i++)
  61:         plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), &objArray[i]);
  62      return objArray;

plugin_III\game_III\meta\meta.CCamera.h:
  1018      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  1019:         plugin::CallMethodDynGlobal<CCamera *>(dtor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));
  1020      }

  1025      if (obj == nullptr) return;
  1026:     plugin::CallVirtualMethod<0, CCamera *, char>(obj, 1);
  1027  }

  1033      for (unsigned int i = 0; i < arraySize; i++)
  1034:         plugin::CallVirtualMethod<0, CCamera *, char>(&objArray[i], 1);
  1035      operator delete(objData);

plugin_III\game_III\meta\meta.CCarGenerator.h:
  148      SUPPORTED_10EN_11EN_STEAM stack_object() {
  149:         plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), reinterpret_cast<CCarGenerator *>(objBuff));
  150      }

  156      CCarGenerator *obj = reinterpret_cast<CCarGenerator *>(objData);
  157:     plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), obj);
  158      return obj;

  165      for (unsigned int i = 0; i < objCount; i++)
  166:         plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), &objArray[i]);
  167      return objArray;

plugin_III\game_III\meta\meta.CColLine.h:
  58      SUPPORTED_10EN_11EN_STEAM stack_object() {
  59:         plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), reinterpret_cast<CColLine *>(objBuff));
  60      }
  61      SUPPORTED_10EN_11EN_STEAM stack_object(CVector const &start, CVector const &end) {
  62:         plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(ctor_gaddr_o(CColLine, void(CVector const &, CVector const &)), reinterpret_cast<CColLine *>(objBuff), start, end);
  63      }

  69      CColLine *obj = reinterpret_cast<CColLine *>(objData);
  70:     plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), obj);
  71      return obj;

  78      for (unsigned int i = 0; i < objCount; i++)
  79:         plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), &objArray[i]);
  80      return objArray;

  85      CColLine *obj = reinterpret_cast<CColLine *>(objData);
  86:     plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(ctor_gaddr_o(CColLine, void(CVector const &, CVector const &)), obj, start, end);
  87      return obj;

plugin_III\game_III\meta\meta.CColPoint.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), reinterpret_cast<CColPoint *>(objBuff));
  30      }

  36      CColPoint *obj = reinterpret_cast<CColPoint *>(objData);
  37:     plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CCurrentVehicle.h:
  73      SUPPORTED_10EN_11EN_STEAM stack_object() {
  74:         plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), reinterpret_cast<CCurrentVehicle *>(objBuff));
  75      }

  81      CCurrentVehicle *obj = reinterpret_cast<CCurrentVehicle *>(objData);
  82:     plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), obj);
  83      return obj;

  90      for (unsigned int i = 0; i < objCount; i++)
  91:         plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), &objArray[i]);
  92      return objArray;

plugin_III\game_III\meta\meta.CDate.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), reinterpret_cast<CDate *>(objBuff));
  30      }

  36      CDate *obj = reinterpret_cast<CDate *>(objData);
  37:     plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CDigitalClock.h:
   88      SUPPORTED_10EN_11EN_STEAM stack_object() {
   89:         plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), reinterpret_cast<CDigitalClock *>(objBuff));
   90      }

   96      CDigitalClock *obj = reinterpret_cast<CDigitalClock *>(objData);
   97:     plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), obj);
   98      return obj;

  105      for (unsigned int i = 0; i < objCount; i++)
  106:         plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), &objArray[i]);
  107      return objArray;

plugin_III\game_III\meta\meta.CDirectory.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object(int capacity) {
  104:         plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), reinterpret_cast<CDirectory *>(objBuff), capacity);
  105      }
  106      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  107:         plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), reinterpret_cast<CDirectory *>(objBuff));
  108      }

  114      CDirectory *obj = reinterpret_cast<CDirectory *>(objData);
  115:     plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), obj, capacity);
  116      return obj;

  120      if (obj == nullptr) return;
  121:     plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), obj);
  122      operator delete(obj);

  129      for (unsigned int i = 0; i < arraySize; i++)
  130:         plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), &objArray[i]);
  131      operator delete(objData);

plugin_III\game_III\meta\meta.cDMAudio.h:
  748      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  749:         plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), reinterpret_cast<cDMAudio *>(objBuff));
  750      }

  755      if (obj == nullptr) return;
  756:     plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), obj);
  757      operator delete(obj);

  764      for (unsigned int i = 0; i < arraySize; i++)
  765:         plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), &objArray[i]);
  766      operator delete(objData);

plugin_III\game_III\meta\meta.CEntity.h:
  613      SUPPORTED_10EN_11EN_STEAM stack_object() {
  614:         plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), reinterpret_cast<CEntity *>(objBuff));
  615      }
  616      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  617:         plugin::CallMethodDynGlobal<CEntity *>(dtor_gaddr(CEntity), reinterpret_cast<CEntity *>(objBuff));
  618      }

  624      CEntity *obj = reinterpret_cast<CEntity *>(objData);
  625:     plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), obj);
  626      return obj;

  633      for (unsigned int i = 0; i < objCount; i++)
  634:         plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), &objArray[i]);
  635      return objArray;

  639      if (obj == nullptr) return;
  640:     plugin::CallVirtualMethod<0, CEntity *, char>(obj, 1);
  641  }

  647      for (unsigned int i = 0; i < arraySize; i++)
  648:         plugin::CallVirtualMethod<0, CEntity *, char>(&objArray[i], 1);
  649      operator delete(objData);

plugin_III\game_III\meta\meta.CEventList.h:
  148      SUPPORTED_10EN_11EN_STEAM stack_object() {
  149:         plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), reinterpret_cast<CEvent *>(objBuff));
  150      }

  156      CEvent *obj = reinterpret_cast<CEvent *>(objData);
  157:     plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), obj);
  158      return obj;

  165      for (unsigned int i = 0; i < objCount; i++)
  166:         plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), &objArray[i]);
  167      return objArray;

plugin_III\game_III\meta\meta.CFallingGlassPane.h:
   73      SUPPORTED_10EN_11EN_STEAM stack_object() {
   74:         plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), reinterpret_cast<CFallingGlassPane *>(objBuff));
   75      }
   76      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
   77:         plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), reinterpret_cast<CFallingGlassPane *>(objBuff));
   78      }

   84      CFallingGlassPane *obj = reinterpret_cast<CFallingGlassPane *>(objData);
   85:     plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), obj);
   86      return obj;

   93      for (unsigned int i = 0; i < objCount; i++)
   94:         plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), &objArray[i]);
   95      return objArray;

   99      if (obj == nullptr) return;
  100:     plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), obj);
  101      operator delete(obj);

  108      for (unsigned int i = 0; i < arraySize; i++)
  109:         plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), &objArray[i]);
  110      operator delete(objData);

plugin_III\game_III\meta\meta.CFire.h:
   88      SUPPORTED_10EN_11EN_STEAM stack_object() {
   89:         plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), reinterpret_cast<CFire *>(objBuff));
   90      }
   91      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
   92:         plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), reinterpret_cast<CFire *>(objBuff));
   93      }

   99      CFire *obj = reinterpret_cast<CFire *>(objData);
  100:     plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), obj);
  101      return obj;

  108      for (unsigned int i = 0; i < objCount; i++)
  109:         plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), &objArray[i]);
  110      return objArray;

  114      if (obj == nullptr) return;
  115:     plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), obj);
  116      operator delete(obj);

  123      for (unsigned int i = 0; i < arraySize; i++)
  124:         plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), &objArray[i]);
  125      operator delete(objData);

plugin_III\game_III\meta\meta.CFireManager.h:
  223      SUPPORTED_10EN_11EN_STEAM stack_object() {
  224:         plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), reinterpret_cast<CFireManager *>(objBuff));
  225      }
  226      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  227:         plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), reinterpret_cast<CFireManager *>(objBuff));
  228      }

  234      CFireManager *obj = reinterpret_cast<CFireManager *>(objData);
  235:     plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), obj);
  236      return obj;

  243      for (unsigned int i = 0; i < objCount; i++)
  244:         plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), &objArray[i]);
  245      return objArray;

  249      if (obj == nullptr) return;
  250:     plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), obj);
  251      operator delete(obj);

  258      for (unsigned int i = 0; i < arraySize; i++)
  259:         plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), &objArray[i]);
  260      operator delete(objData);

plugin_III\game_III\meta\meta.CGangInfo.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));
  45      }
  46      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  47:         plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));
  48      }

  54      CGangInfo *obj = reinterpret_cast<CGangInfo *>(objData);
  55:     plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), obj);
  56      return obj;

  63      for (unsigned int i = 0; i < objCount; i++)
  64:         plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), &objArray[i]);
  65      return objArray;

  69      if (obj == nullptr) return;
  70:     plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), obj);
  71      operator delete(obj);

  78      for (unsigned int i = 0; i < arraySize; i++)
  79:         plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), &objArray[i]);
  80      operator delete(objData);

plugin_III\game_III\meta\meta.CInstance.h:
   73      SUPPORTED_10EN_11EN_STEAM stack_object() {
   74:         plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), reinterpret_cast<CInstance *>(objBuff));
   75      }
   76      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
   77:         plugin::CallMethodDynGlobal<CInstance *>(dtor_gaddr(CInstance), reinterpret_cast<CInstance *>(objBuff));
   78      }

   84      CInstance *obj = reinterpret_cast<CInstance *>(objData);
   85:     plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), obj);
   86      return obj;

   93      for (unsigned int i = 0; i < objCount; i++)
   94:         plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), &objArray[i]);
   95      return objArray;

   99      if (obj == nullptr) return;
  100:     plugin::CallVirtualMethod<0, CInstance *, char>(obj, 1);
  101  }

  107      for (unsigned int i = 0; i < arraySize; i++)
  108:         plugin::CallVirtualMethod<0, CInstance *, char>(&objArray[i], 1);
  109      operator delete(objData);

plugin_III\game_III\meta\meta.CMissionCleanup.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), reinterpret_cast<CMissionCleanup *>(objBuff));
  105      }

  111      CMissionCleanup *obj = reinterpret_cast<CMissionCleanup *>(objData);
  112:     plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), obj);
  113      return obj;

  120      for (unsigned int i = 0; i < objCount; i++)
  121:         plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), &objArray[i]);
  122      return objArray;

plugin_III\game_III\meta\meta.CMoneyMessage.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), reinterpret_cast<CMoneyMessage *>(objBuff));
  45      }

  51      CMoneyMessage *obj = reinterpret_cast<CMoneyMessage *>(objData);
  52:     plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), obj);
  53      return obj;

  60      for (unsigned int i = 0; i < objCount; i++)
  61:         plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), &objArray[i]);
  62      return objArray;

plugin_III\game_III\meta\meta.CMovie.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), reinterpret_cast<CMovie *>(objBuff));
  30      }

  36      CMovie *obj = reinterpret_cast<CMovie *>(objData);
  37:     plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CMovingThing.h:
  73      SUPPORTED_10EN_11EN_STEAM stack_object() {
  74:         plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), reinterpret_cast<CMovingThing *>(objBuff));
  75      }

  81      CMovingThing *obj = reinterpret_cast<CMovingThing *>(objData);
  82:     plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), obj);
  83      return obj;

  90      for (unsigned int i = 0; i < objCount; i++)
  91:         plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), &objArray[i]);
  92      return objArray;

plugin_III\game_III\meta\meta.cMusicManager.h:
  448      SUPPORTED_10EN_11EN_STEAM stack_object() {
  449:         plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), reinterpret_cast<cMusicManager *>(objBuff));
  450      }

  456      cMusicManager *obj = reinterpret_cast<cMusicManager *>(objData);
  457:     plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), obj);
  458      return obj;

  465      for (unsigned int i = 0; i < objCount; i++)
  466:         plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), &objArray[i]);
  467      return objArray;

plugin_III\game_III\meta\meta.CPacManPickup.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), reinterpret_cast<CPacManPickup *>(objBuff));
  45      }

  51      CPacManPickup *obj = reinterpret_cast<CPacManPickup *>(objData);
  52:     plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), obj);
  53      return obj;

  60      for (unsigned int i = 0; i < objCount; i++)
  61:         plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), &objArray[i]);
  62      return objArray;

plugin_III\game_III\meta\meta.CParticle.h:
  208      SUPPORTED_10EN_11EN_STEAM stack_object() {
  209:         plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));
  210      }
  211      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  212:         plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));
  213      }

  219      CParticle *obj = reinterpret_cast<CParticle *>(objData);
  220:     plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), obj);
  221      return obj;

  228      for (unsigned int i = 0; i < objCount; i++)
  229:         plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), &objArray[i]);
  230      return objArray;

  234      if (obj == nullptr) return;
  235:     plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), obj);
  236      operator delete(obj);

  243      for (unsigned int i = 0; i < arraySize; i++)
  244:         plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), &objArray[i]);
  245      operator delete(objData);

plugin_III\game_III\meta\meta.CParticleObject.h:
  253      SUPPORTED_10EN_11EN_STEAM stack_object() {
  254:         plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), reinterpret_cast<CParticleObject *>(objBuff));
  255      }
  256      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  257:         plugin::CallMethodDynGlobal<CParticleObject *>(dtor_gaddr(CParticleObject), reinterpret_cast<CParticleObject *>(objBuff));
  258      }

  264      CParticleObject *obj = reinterpret_cast<CParticleObject *>(objData);
  265:     plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), obj);
  266      return obj;

  273      for (unsigned int i = 0; i < objCount; i++)
  274:         plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), &objArray[i]);
  275      return objArray;

  279      if (obj == nullptr) return;
  280:     plugin::CallVirtualMethod<0, CParticleObject *, char>(obj, 1);
  281  }

  287      for (unsigned int i = 0; i < arraySize; i++)
  288:         plugin::CallVirtualMethod<0, CParticleObject *, char>(&objArray[i], 1);
  289      operator delete(objData);

plugin_III\game_III\meta\meta.CPathNode.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), reinterpret_cast<CPathNode *>(objBuff));
  30      }

  36      CPathNode *obj = reinterpret_cast<CPathNode *>(objData);
  37:     plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CPhone.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));
  45      }
  46      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  47:         plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));
  48      }

  54      CPhone *obj = reinterpret_cast<CPhone *>(objData);
  55:     plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), obj);
  56      return obj;

  63      for (unsigned int i = 0; i < objCount; i++)
  64:         plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), &objArray[i]);
  65      return objArray;

  69      if (obj == nullptr) return;
  70:     plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), obj);
  71      operator delete(obj);

  78      for (unsigned int i = 0; i < arraySize; i++)
  79:         plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), &objArray[i]);
  80      operator delete(objData);

plugin_III\game_III\meta\meta.CPhoneInfo.h:
  253      SUPPORTED_10EN_11EN_STEAM stack_object() {
  254:         plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));
  255      }
  256      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  257:         plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));
  258      }

  264      CPhoneInfo *obj = reinterpret_cast<CPhoneInfo *>(objData);
  265:     plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), obj);
  266      return obj;

  273      for (unsigned int i = 0; i < objCount; i++)
  274:         plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), &objArray[i]);
  275      return objArray;

  279      if (obj == nullptr) return;
  280:     plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), obj);
  281      operator delete(obj);

  288      for (unsigned int i = 0; i < arraySize; i++)
  289:         plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), &objArray[i]);
  290      operator delete(objData);

plugin_III\game_III\meta\meta.CPickup.h:
  58      SUPPORTED_10EN_11EN_STEAM stack_object() {
  59:         plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), reinterpret_cast<CPickup *>(objBuff));
  60      }

  66      CPickup *obj = reinterpret_cast<CPickup *>(objData);
  67:     plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), obj);
  68      return obj;

  75      for (unsigned int i = 0; i < objCount; i++)
  76:         plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), &objArray[i]);
  77      return objArray;

plugin_III\game_III\meta\meta.CPlaceable.h:
  133      SUPPORTED_10EN_11EN_STEAM stack_object() {
  134:         plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), reinterpret_cast<CPlaceable *>(objBuff));
  135      }
  136      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  137:         plugin::CallMethodDynGlobal<CPlaceable *>(dtor_gaddr(CPlaceable), reinterpret_cast<CPlaceable *>(objBuff));
  138      }

  144      CPlaceable *obj = reinterpret_cast<CPlaceable *>(objData);
  145:     plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), obj);
  146      return obj;

  153      for (unsigned int i = 0; i < objCount; i++)
  154:         plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), &objArray[i]);
  155      return objArray;

  159      if (obj == nullptr) return;
  160:     plugin::CallVirtualMethod<0, CPlaceable *, unsigned char>(obj, 1);
  161  }

  167      for (unsigned int i = 0; i < arraySize; i++)
  168:         plugin::CallVirtualMethod<0, CPlaceable *, unsigned char>(&objArray[i], 1);
  169      operator delete(objData);

plugin_III\game_III\meta\meta.CPlaceName.h:
  73      SUPPORTED_10EN_11EN_STEAM stack_object() {
  74:         plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), reinterpret_cast<CPlaceName *>(objBuff));
  75      }

  81      CPlaceName *obj = reinterpret_cast<CPlaceName *>(objData);
  82:     plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), obj);
  83      return obj;

  90      for (unsigned int i = 0; i < objCount; i++)
  91:         plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), &objArray[i]);
  92      return objArray;

plugin_III\game_III\meta\meta.CRadar.h:
  688      SUPPORTED_10EN_11EN_STEAM stack_object() {
  689:         plugin::CallMethodDynGlobal<tRadarTrace*>(ctor_gaddr(tRadarTrace), reinterpret_cast<tRadarTrace *>(objBuff));
  690      }

  696      tRadarTrace *obj = reinterpret_cast<tRadarTrace *>(objData);
  697:     plugin::CallMethodDynGlobal<tRadarTrace *>(ctor_gaddr(tRadarTrace), obj);
  698      return obj;

  705      for (unsigned int i = 0; i < objCount; i++)
  706:         plugin::CallMethodDynGlobal<tRadarTrace *>(ctor_gaddr(tRadarTrace), &objArray[i]);
  707      return objArray;

plugin_III\game_III\meta\meta.CRegisteredCorona.h:
  43      SUPPORTED_10EN_11EN_STEAM stack_object() {
  44:         plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), reinterpret_cast<CRegisteredCorona *>(objBuff));
  45      }

  51      CRegisteredCorona *obj = reinterpret_cast<CRegisteredCorona *>(objData);
  52:     plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), obj);
  53      return obj;

  60      for (unsigned int i = 0; i < objCount; i++)
  61:         plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), &objArray[i]);
  62      return objArray;

plugin_III\game_III\meta\meta.CRegisteredMotionBlurStreak.h:
  58      SUPPORTED_10EN_11EN_STEAM stack_object() {
  59:         plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), reinterpret_cast<CRegisteredMotionBlurStreak *>(objBuff));
  60      }

  66      CRegisteredMotionBlurStreak *obj = reinterpret_cast<CRegisteredMotionBlurStreak *>(objData);
  67:     plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), obj);
  68      return obj;

  75      for (unsigned int i = 0; i < objCount; i++)
  76:         plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), &objArray[i]);
  77      return objArray;

plugin_III\game_III\meta\meta.CRegisteredShinyText.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), reinterpret_cast<CRegisteredShinyText *>(objBuff));
  30      }

  36      CRegisteredShinyText *obj = reinterpret_cast<CRegisteredShinyText *>(objData);
  37:     plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CRouteNode.h:
  118      SUPPORTED_10EN_11EN_STEAM stack_object() {
  119:         plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), reinterpret_cast<CRouteNode *>(objBuff));
  120      }

  126      CRouteNode *obj = reinterpret_cast<CRouteNode *>(objData);
  127:     plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), obj);
  128      return obj;

  135      for (unsigned int i = 0; i < objCount; i++)
  136:         plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), &objArray[i]);
  137      return objArray;

plugin_III\game_III\meta\meta.CScrollBar.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), reinterpret_cast<CScrollBar *>(objBuff));
  105      }

  111      CScrollBar *obj = reinterpret_cast<CScrollBar *>(objData);
  112:     plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), obj);
  113      return obj;

  120      for (unsigned int i = 0; i < objCount; i++)
  121:         plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), &objArray[i]);
  122      return objArray;

plugin_III\game_III\meta\meta.CShotInfo.h:
   88      SUPPORTED_10EN_11EN_STEAM stack_object() {
   89:         plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), reinterpret_cast<CShotInfo *>(objBuff));
   90      }

   96      CShotInfo *obj = reinterpret_cast<CShotInfo *>(objData);
   97:     plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), obj);
   98      return obj;

  105      for (unsigned int i = 0; i < objCount; i++)
  106:         plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), &objArray[i]);
  107      return objArray;

plugin_III\game_III\meta\meta.CSkidmark.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), reinterpret_cast<CSkidmark *>(objBuff));
  30      }

  36      CSkidmark *obj = reinterpret_cast<CSkidmark *>(objData);
  37:     plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CSprite2d.h:
  403      SUPPORTED_10EN_11EN_STEAM stack_object() {
  404:         plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), reinterpret_cast<CSprite2d *>(objBuff));
  405      }
  406      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  407:         plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), reinterpret_cast<CSprite2d *>(objBuff));
  408      }

  414      CSprite2d *obj = reinterpret_cast<CSprite2d *>(objData);
  415:     plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), obj);
  416      return obj;

  423      for (unsigned int i = 0; i < objCount; i++)
  424:         plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), &objArray[i]);
  425      return objArray;

  429      if (obj == nullptr) return;
  430:     plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), obj);
  431      operator delete(obj);

  438      for (unsigned int i = 0; i < arraySize; i++)
  439:         plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), &objArray[i]);
  440      operator delete(objData);

plugin_III\game_III\meta\meta.CStoredCollPoly.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), reinterpret_cast<CStoredCollPoly *>(objBuff));
  30      }

  36      CStoredCollPoly *obj = reinterpret_cast<CStoredCollPoly *>(objData);
  37:     plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CStuckCarCheck.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), reinterpret_cast<CStuckCarCheck *>(objBuff));
  105      }

  111      CStuckCarCheck *obj = reinterpret_cast<CStuckCarCheck *>(objData);
  112:     plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), obj);
  113      return obj;

  120      for (unsigned int i = 0; i < objCount; i++)
  121:         plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), &objArray[i]);
  122      return objArray;

plugin_III\game_III\meta\meta.CTempNode.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), reinterpret_cast<CTempNode *>(objBuff));
  30      }

  36      CTempNode *obj = reinterpret_cast<CTempNode *>(objData);
  37:     plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CText.h:
  268      SUPPORTED_10EN_11EN_STEAM stack_object() {
  269:         plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), reinterpret_cast<CText *>(objBuff));
  270      }
  271      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  272:         plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), reinterpret_cast<CText *>(objBuff));
  273      }

  279      CText *obj = reinterpret_cast<CText *>(objData);
  280:     plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), obj);
  281      return obj;

  288      for (unsigned int i = 0; i < objCount; i++)
  289:         plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), &objArray[i]);
  290      return objArray;

  294      if (obj == nullptr) return;
  295:     plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), obj);
  296      operator delete(obj);

  303      for (unsigned int i = 0; i < arraySize; i++)
  304:         plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), &objArray[i]);
  305      operator delete(objData);

plugin_III\game_III\meta\meta.CTowerClock.h:
  73      SUPPORTED_10EN_11EN_STEAM stack_object() {
  74:         plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), reinterpret_cast<CTowerClock *>(objBuff));
  75      }

  81      CTowerClock *obj = reinterpret_cast<CTowerClock *>(objData);
  82:     plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), obj);
  83      return obj;

  90      for (unsigned int i = 0; i < objCount; i++)
  91:         plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), &objArray[i]);
  92      return objArray;

plugin_III\game_III\meta\meta.CTrainCamNode.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), reinterpret_cast<CTrainCamNode *>(objBuff));
  30      }

  36      CTrainCamNode *obj = reinterpret_cast<CTrainCamNode *>(objData);
  37:     plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), &objArray[i]);
  47      return objArray;

plugin_III\game_III\meta\meta.CTrainDoor.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), reinterpret_cast<CTrainDoor *>(objBuff));
  105      }

  111      CTrainDoor *obj = reinterpret_cast<CTrainDoor *>(objData);
  112:     plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), obj);
  113      return obj;

  120      for (unsigned int i = 0; i < objCount; i++)
  121:         plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), &objArray[i]);
  122      return objArray;

plugin_III\game_III\meta\meta.CWanted.h:
  328      SUPPORTED_10EN_11EN_STEAM stack_object() {
  329:         plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), reinterpret_cast<CCrimeBeingQd *>(objBuff));
  330      }

  336      CCrimeBeingQd *obj = reinterpret_cast<CCrimeBeingQd *>(objData);
  337:     plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), obj);
  338      return obj;

  345      for (unsigned int i = 0; i < objCount; i++)
  346:         plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), &objArray[i]);
  347      return objArray;

plugin_III\game_III\meta\meta.CWaterCannon.h:
  103      SUPPORTED_10EN_11EN_STEAM stack_object() {
  104:         plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), reinterpret_cast<CWaterCannon *>(objBuff));
  105      }

  111      CWaterCannon *obj = reinterpret_cast<CWaterCannon *>(objData);
  112:     plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), obj);
  113      return obj;

  120      for (unsigned int i = 0; i < objCount; i++)
  121:         plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), &objArray[i]);
  122      return objArray;

plugin_III\game_III\meta\meta.CWeapon.h:
  493      SUPPORTED_10EN_11EN_STEAM stack_object() {
  494:         plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), reinterpret_cast<CWeapon *>(objBuff));
  495      }
  496      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  497:         plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), reinterpret_cast<CWeapon *>(objBuff));
  498      }

  504      CWeapon *obj = reinterpret_cast<CWeapon *>(objData);
  505:     plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), obj);
  506      return obj;

  513      for (unsigned int i = 0; i < objCount; i++)
  514:         plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), &objArray[i]);
  515      return objArray;

  519      if (obj == nullptr) return;
  520:     plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), obj);
  521      operator delete(obj);

  528      for (unsigned int i = 0; i < arraySize; i++)
  529:         plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), &objArray[i]);
  530      operator delete(objData);

plugin_sa\game_sa\C_PcSave.cpp:
  11  void C_PcSave::PopulateSlotInfo() {
  12:     plugin::CallMethod<0x619140, C_PcSave*>(this);
  13  }

  15  bool C_PcSave::DeleteSlot(int slot) {
  16:     return plugin::CallMethodAndReturn<bool, 0x6190D0, C_PcSave*, int>(this, slot);
  17  }

  19  bool C_PcSave::SaveSlot(int slot) {
  20:     return plugin::CallMethodAndReturn<bool, 0x619060, C_PcSave*, int>(this, slot);
  21  }

  23  void C_PcSave::SetSaveDirectory(const char* path) {
  24:     plugin::Call<0x619040, const char*>(path);
  25  }

plugin_sa\game_sa\C3dMarker.cpp:
  10  bool C3dMarker::AddMarker(unsigned int id, unsigned short type, float size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, unsigned short pulsePeriod, float pulseFraction, short rotateRate) {
  11:     return plugin::CallMethodAndReturn<bool, 0x722230, C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(this, id, type, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);
  12  }

  15  void C3dMarker::DeleteMarkerObject() {
  16:     plugin::CallMethod<0x722390, C3dMarker *>(this);
  17  }

  20  bool C3dMarker::IsZCoordinateUpToDate() {
  21:     return plugin::CallMethodAndReturn<bool, 0x7226A0, C3dMarker *>(this);
  22  }

  25  void C3dMarker::Render() {
  26:     plugin::CallMethod<0x7223D0, C3dMarker *>(this);
  27  }

  30  void C3dMarker::SetZCoordinateIfNotUpToDate(float coordinate) {
  31:     plugin::CallMethod<0x724E10, C3dMarker *, float>(this, coordinate);
  32  }

  35  void C3dMarker::UpdateZCoordinate(CVector arg0, float arg1) {
  36:     plugin::CallMethod<0x724D40, C3dMarker *, CVector, float>(this, arg0, arg1);
  37  }

plugin_sa\game_sa\C3dMarkers.cpp:
   24  int C3dMarkers::DirectionArrowFindFirstFreeSlot() {
   25:     return plugin::CallAndReturn<int, 0x721120>();
   26  }

   29  void C3dMarkers::DirectionArrowSet(CVector posn, float size, int red, int green, int blue, int alpha, float dir_x, float dir_y, float dir_z) {
   30:     plugin::Call<0x721140, CVector, float, int, int, int, int, float, float, float>(posn, size, red, green, blue, alpha, dir_x, dir_y, dir_z);
   31  }

   34  void C3dMarkers::DirectionArrowsDraw() {
   35:     plugin::Call<0x7211F0>();
   36  }

   39  void C3dMarkers::DirectionArrowsInit() {
   40:     plugin::Call<0x721100>();
   41  }

   44  void C3dMarkers::ForceRender(unsigned char bEnable) {
   45:     plugin::Call<0x722870, unsigned char>(bEnable);
   46  }

   49  void C3dMarkers::Init() {
   50:     plugin::Call<0x724E40>();
   51  }

   54  RpClump* C3dMarkers::LoadMarker(char const* modelName) {
   55:     return plugin::CallAndReturn<RpClump*, 0x722810, char const*>(modelName);
   56  }

   59  bool C3dMarkers::LoadUser3dMarkers() {
   60:     return plugin::CallAndReturn<bool, 0x5D42E0>();
   61  }

   64  C3dMarker* C3dMarkers::PlaceMarker(unsigned int id, unsigned short type, CVector& posn, float size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, unsigned short pulsePeriod, float pulseFraction, short rotateRate, float nrm_x, float nrm_y, float nrm_z, bool zCheck) {
   65:     return plugin::CallAndReturn<C3dMarker*, 0x725120, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short, float, float, float, bool>(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, nrm_x, nrm_y, nrm_z, zCheck);
   66  }

   69  void C3dMarkers::PlaceMarkerCone(unsigned int id, CVector& posn, float size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, unsigned short pulsePeriod, float pulseFraction, short rotateRate, unsigned char bEnableCollision) {
   70:     plugin::Call<0x726D40, unsigned int, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short, unsigned char>(id, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, bEnableCollision);
   71  }

   74  void C3dMarkers::PlaceMarkerSet(unsigned int id, unsigned short type, CVector& posn, float size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, unsigned short pulsePeriod, float pulseFraction, short rotateRate) {
   75:     plugin::Call<0x725BA0, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);
   76  }

   79  void C3dMarkers::Render() {
   80:     plugin::Call<0x725040>();
   81  }

   84  void C3dMarkers::SaveUser3dMarkers() {
   85:     plugin::Call<0x5D4300>();
   86  }

   89  void C3dMarkers::Shutdown() {
   90:     plugin::Call<0x722710>();
   91  }

   94  void C3dMarkers::Update() {
   95:     plugin::Call<0x7227B0>();
   96  }

   99  RpAtomic* C3dMarkers::User3dMarkerAtomicCB(RpAtomic* atomic, void* _IGNORED_ data) {
  100:     return plugin::CallAndReturn<RpAtomic*, 0x7210D0, RpAtomic*, void*>(atomic, data);
  101  }

  104  void C3dMarkers::User3dMarkerDelete(int slotIndex) {
  105:     plugin::Call<0x721090, int>(slotIndex);
  106  }

  109  void C3dMarkers::User3dMarkerDeleteAll() {
  110:     plugin::Call<0x7210B0>();
  111  }

  114  int C3dMarkers::User3dMarkerFindFirstFreeSlot() {
  115:     return plugin::CallAndReturn<int, 0x720FB0>();
  116  }

  119  int C3dMarkers::User3dMarkerSet(float x, float y, float z, int colour) {
  120:     return plugin::CallAndReturn<int, 0x720FD0, float, float, float, int>(x, y, z, colour);
  121  }

  124  void C3dMarkers::User3dMarkersDraw() {
  125:     plugin::Call<0x723240>();
  126  }

  129  RpAtomic* MarkerAtomicCB(RpAtomic* atomic, void* data) {
  130:     return plugin::CallAndReturn<RpAtomic*, 0x722220, RpAtomic*, void*>(atomic, data);
  131  }

plugin_sa\game_sa\CAEAudioHardware.cpp:
  11  int CAEAudioHardware::GetActiveTrackID() {
  12:     return plugin::CallMethodAndReturn<int, 0x4D8F80, CAEAudioHardware*>(this);
  13  }

plugin_sa\game_sa\CAECutsceneTrackManager.cpp:
  12  void CAECutsceneTrackManager::StopCutsceneTrack() {
  13:     plugin::CallMethod<0x4DBE80, CAECutsceneTrackManager*>(this);
  14  }

  16  void CAECutsceneTrackManager::StartTrackPlayback() {
  17:     plugin::CallMethod<0x4DBF10, CAECutsceneTrackManager*>(this);
  18  }

  20  void CAECutsceneTrackManager::Service(int time) {
  21:     plugin::CallMethod<0x4DBFB0, CAECutsceneTrackManager*, int>(this, time);
  22  }

  24  void CAECutsceneTrackManager::PreloadBeatTrack(char arg1, bool arg2) {
  25:     plugin::CallMethod<0x4DC130, CAECutsceneTrackManager*, char, bool>(this, arg1, arg2);
  26  }

  28  void CAECutsceneTrackManager::PlayPreloadedCutsceneTrack() {
  29:     plugin::CallMethod<0x4DBE70, CAECutsceneTrackManager*>(this);
  30  }

  32  bool CAECutsceneTrackManager::IsCutsceneTrackActive() {
  33:     return plugin::CallMethodAndReturn<bool, 0x4DBEB0, CAECutsceneTrackManager*>(this);
  34  }

  36  char CAECutsceneTrackManager::GetCutsceneTrackStatus() {
  37:     return plugin::CallMethodAndReturn<char, 0x4DBEC0, CAECutsceneTrackManager*>(this);
  38  }

plugin_sa\game_sa\CAERadioTrackManager.cpp:
  21  void CAERadioTrackManager::StartRadio(int stationId, float bass, int arg, char unused) {
  22:     plugin::CallMethod<0x4EB3C0, CAERadioTrackManager*, int, float, int, char>(this, stationId, bass, arg, unused);
  23  }

  25  void CAERadioTrackManager::StopRadio(tVehicleAudioSettings* settings, char arg) {
  26:     plugin::CallMethod<0x4E9820, CAERadioTrackManager*, tVehicleAudioSettings*, char>(this, settings, arg);
  27  }

plugin_sa\game_sa\CAEStreamThread.cpp:
   9  bool CAEStreamThread::Initialise(void* channel) {
  10:     return plugin::CallMethodAndReturn<bool, 0x4F1680, CAEStreamThread*>(this);
  11  }

  13  int CAEStreamThread::GetActiveTrackID() {
  14:     return plugin::CallMethodAndReturn<int, 0x4F1560, CAEStreamThread*>(this);
  15  }

plugin_sa\game_sa\CAEWeaponAudioEntity.cpp:
  10  CAEWeaponAudioEntity::CAEWeaponAudioEntity() {
  11: 	plugin::CallMethod<0x507560, CAEWeaponAudioEntity *>(this);
  12  }

  15  void CAEWeaponAudioEntity::WeaponReload(eWeaponType weaptype, CPhysical* entity, int AudioEventId) {
  16: 	plugin::CallMethod<0x503690, CAEWeaponAudioEntity *, eWeaponType, CPhysical*, int>(this, weaptype, entity, AudioEventId);
  17  }

  20  void CAEWeaponAudioEntity::WeaponFire(eWeaponType weaptype, CPhysical* entity, int AudioEventId) {
  21: 	plugin::CallMethod<0x504F80, CAEWeaponAudioEntity *, eWeaponType, CPhysical*, int>(this, weaptype, entity, AudioEventId);
  22  }

  25  void CAEWeaponAudioEntity::Terminate() {
  26: 	plugin::CallMethod<0x503480, CAEWeaponAudioEntity *>(this);
  27  }

  30  void CAEWeaponAudioEntity::StopFlameThrowerIdleGasLoop() {
  31: 	plugin::CallMethod<0x5034E0, CAEWeaponAudioEntity *>(this);
  32  }

  35  void CAEWeaponAudioEntity::Reset() {
  36: 	plugin::CallMethod<0x503490, CAEWeaponAudioEntity *>(this);
  37  }

  40  void CAEWeaponAudioEntity::ReportStealthKill(eWeaponType weaptype, CPhysical* entity, int AudioEventId) {
  41: 	plugin::CallMethod<0x503B20, CAEWeaponAudioEntity *, eWeaponType, CPhysical*, int>(this, weaptype, entity, AudioEventId);
  42  }

  45  void CAEWeaponAudioEntity::ReportChainsawEvent(CPhysical* entity, int AudioEventId) {
  46: 	plugin::CallMethod<0x503910, CAEWeaponAudioEntity *, CPhysical*, int>(this, entity, AudioEventId);
  47  }

  50  void CAEWeaponAudioEntity::PlayWeaponLoopSound(CPhysical* arg0, short sfxId, int AudioEventId, float audability, float speed, int finalEvent) {
  51: 	plugin::CallMethod<0x504610, CAEWeaponAudioEntity *, CPhysical*, short, int, float, float, int>(this, arg0, sfxId, AudioEventId, audability, speed, finalEvent);
  52  }

  55  void CAEWeaponAudioEntity::PlayMiniGunStopSound(CPhysical* entity) {
  56: 	plugin::CallMethod<0x504960, CAEWeaponAudioEntity *, CPhysical*>(this, entity);
  57  }

  60  void CAEWeaponAudioEntity::PlayMiniGunFireSounds(CPhysical* entity, int AudioEventId) {
  61: 	plugin::CallMethod<0x5047C0, CAEWeaponAudioEntity *, CPhysical*, int>(this, entity, AudioEventId);
  62  }

  65  void CAEWeaponAudioEntity::PlayGunSounds(CPhysical* entity, short emptySfxId, short farSfxId2, short highPitchSfxId3, short lowPitchSfxId4, short echoSfxId5, int nAudioEventId, float volumeChange, float speed1, float speed2) {
  66: 	plugin::CallMethod<0x503CE0, CAEWeaponAudioEntity *, CPhysical*, short, short, short, short, short, int, float, float, float>(this, entity, emptySfxId, farSfxId2, highPitchSfxId3, lowPitchSfxId4, echoSfxId5, nAudioEventId, volumeChange, speed1, speed2);
  67  }

  70  void CAEWeaponAudioEntity::PlayGoggleSound(short sfxId, int AudioEventId) {
  71: 	plugin::CallMethod<0x503500, CAEWeaponAudioEntity *, short, int>(this, sfxId, AudioEventId);
  72  }

  75  void CAEWeaponAudioEntity::PlayFlameThrowerSounds(CPhysical* entity, short sfx1, short sfx2, int AudioEventId, float audability, float speed) {
  76: 	plugin::CallMethod<0x504470, CAEWeaponAudioEntity *, CPhysical*, short, short, int, float, float>(this, entity, sfx1, sfx2, AudioEventId, audability, speed);
  77  }

  80  void CAEWeaponAudioEntity::PlayFlameThrowerIdleGasLoop(CPhysical* entity) {
  81: 	plugin::CallMethod<0x503870, CAEWeaponAudioEntity *, CPhysical*>(this, entity);
  82  }

  85  void CAEWeaponAudioEntity::PlayChainsawStopSound(CPhysical* entity) {
  86: 	plugin::CallMethod<0x504AA0, CAEWeaponAudioEntity *, CPhysical*>(this, entity);
  87  }

  90  void CAEWeaponAudioEntity::PlayCameraSound(CPhysical* entity, int AudioEventId, float audability) {
  91: 	plugin::CallMethod<0x5046F0, CAEWeaponAudioEntity *, CPhysical*, int, float>(this, entity, AudioEventId, audability);
  92  }

  95  void CAEWeaponAudioEntity::Initialise() {
  96: 	plugin::CallMethod<0x503450, CAEWeaponAudioEntity *>(this);
  97  }

plugin_sa\game_sa\CAnimatedBuilding.cpp:
  10  CAnimatedBuilding::CAnimatedBuilding() : CBuilding(plugin::dummy) {
  11:     plugin::CallMethod<0x537A10, CAnimatedBuilding *>(this);
  12  }

plugin_sa\game_sa\CAnimBlendAssocGroup.cpp:
  10  CAnimBlendAssocGroup::CAnimBlendAssocGroup() {
  11: 	plugin::CallMethod<0x4CDE70, CAnimBlendAssocGroup *>(this);
  12  }

  15  CAnimBlendAssociation* CAnimBlendAssocGroup::CopyAnimation(char const* AnimName) {
  16: 	return plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE0B0, CAnimBlendAssocGroup *, char const*>(this, AnimName);
  17  }

  20  CAnimBlendAssociation* CAnimBlendAssocGroup::CopyAnimation(unsigned int ID) {
  21: 	return plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE130, CAnimBlendAssocGroup *, unsigned int>(this, ID);
  22  }

  25  void CAnimBlendAssocGroup::CreateAssociations(char const* szBlockName) {
  26: 	plugin::CallMethod<0x4CE220, CAnimBlendAssocGroup *, char const*>(this, szBlockName);
  27  }

  30  void CAnimBlendAssocGroup::CreateAssociations(char const* AnimName, RpClump* pClump, char** arg3, int NumAnimations) {
  31: 	plugin::CallMethod<0x4CE6E0, CAnimBlendAssocGroup *, char const*, RpClump*, char**, int>(this, AnimName, pClump, arg3, NumAnimations);
  32  }

  35  void CAnimBlendAssocGroup::CreateAssociations(char const* AnimName, char const* arg2, char const* arg3, int arg4) {
  36: 	plugin::CallMethod<0x4CE3B0, CAnimBlendAssocGroup *, char const*, char const*, char const*, int>(this, AnimName, arg2, arg3, arg4);
  37  }

  40  void CAnimBlendAssocGroup::DestroyAssociations() {
  41: 	plugin::CallMethod<0x4CDFF0, CAnimBlendAssocGroup *>(this);
  42  }

  45  CAnimBlendAssociation* CAnimBlendAssocGroup::GetAnimation(char const* AnimName) {
  46: 	return plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE040, CAnimBlendAssocGroup *, char const*>(this, AnimName);
  47  }

  50  CAnimBlendAssociation* CAnimBlendAssocGroup::GetAnimation(unsigned int ID) {
  51: 	return plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE090, CAnimBlendAssocGroup *, unsigned int>(this, ID);
  52  }

  55  unsigned int CAnimBlendAssocGroup::GetAnimationId(char const* AnimName) {
  56: 	return plugin::CallMethodAndReturn<unsigned int, 0x4CE1B0, CAnimBlendAssocGroup *, char const*>(this, AnimName);
  57  }

  60  void CAnimBlendAssocGroup::InitEmptyAssociations(RpClump* pClump) {
  61: 	plugin::CallMethod<0x4CDFB0, CAnimBlendAssocGroup *, RpClump*>(this, pClump);
  62  }

  65  CAnimBlendAssocGroup::~CAnimBlendAssocGroup() {
  66: 	plugin::CallMethod<0x4CE1D0, CAnimBlendAssocGroup *>(this);
  67  }

plugin_sa\game_sa\CAnimBlendAssociation.cpp:
   30  {
   31:     plugin::CallVirtualMethod<0, CAnimBlendAssociation *>(this, 1);
   32  }

   37  void CAnimBlendAssociation::AllocateAnimBlendNodeArray(int count) {
   38:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::AllocateAnimBlendNodeArray), this, count);
   39  }

   44  void CAnimBlendAssociation::FreeAnimBlendNodeArray() {
   45:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::FreeAnimBlendNodeArray), this);
   46  }

   51  CAnimBlendNode *CAnimBlendAssociation::GetNode(int nodeIndex) {
   52:     return plugin::CallMethodAndReturnDynGlobal<CAnimBlendNode *, CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::GetNode), this, nodeIndex);
   53  }

   58  void CAnimBlendAssociation::Init(RpClump *clump, CAnimBlendHierarchy *hierarchy) {
   59:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(RpClump *, CAnimBlendHierarchy *)), this, clump, hierarchy);
   60  }

   65  void CAnimBlendAssociation::Init(CAnimBlendAssociation &source) {
   66:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendAssociation &)), this, source);
   67  }

   72  void CAnimBlendAssociation::Init(CAnimBlendStaticAssociation &source) {
   73:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendStaticAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendStaticAssociation &)), this, source);
   74  }

   79  void CAnimBlendAssociation::ReferenceAnimBlock() {
   80:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::ReferenceAnimBlock), this);
   81  }

   86  void CAnimBlendAssociation::SetBlend(float blendAmount, float blendDelta) {
   87:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlend), this, blendAmount, blendDelta);
   88  }

   93  void CAnimBlendAssociation::SetBlendTo(float blendAmount, float blendDelta) {
   94:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlendTo), this, blendAmount, blendDelta);
   95  }

  100  void CAnimBlendAssociation::SetCurrentTime(float currentTime) {
  101:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::SetCurrentTime), this, currentTime);
  102  }

  107  void CAnimBlendAssociation::SetDeleteCallback(void(*callback)(CAnimBlendAssociation *, void *), void *data) {
  108:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetDeleteCallback), this, callback, data);
  109  }

  114  void CAnimBlendAssociation::SetFinishCallback(void(*callback)(CAnimBlendAssociation *, void *), void *data) {
  115:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetFinishCallback), this, callback, data);
  116  }

  121  void CAnimBlendAssociation::Start(float currentTime) {
  122:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::Start), this, currentTime);
  123  }

  128  void CAnimBlendAssociation::SyncAnimation(CAnimBlendAssociation *syncWith) {
  129:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::SyncAnimation), this, syncWith);
  130  }

  135  bool CAnimBlendAssociation::UpdateBlend(float blendDeltaMult) {
  136:     return plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::UpdateBlend), this, blendDeltaMult);
  137  }

  142  bool CAnimBlendAssociation::UpdateTime(float unused1, float unused2) {
  143:     return plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTime), this, unused1, unused2);
  144  }

  149  void CAnimBlendAssociation::UpdateTimeStep(float speedMult, float timeMult) {
  150:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTimeStep), this, speedMult, timeMult);
  151  }

plugin_sa\game_sa\CAnimBlendClumpData.cpp:
  14  CAnimBlendClumpData::CAnimBlendClumpData() {
  15:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), this);
  16  }

  21  CAnimBlendClumpData::~CAnimBlendClumpData() {
  22:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), this);
  23  }

  28  void CAnimBlendClumpData::ForAllFrames(void(*callback)(AnimBlendFrameData *, void *), void *data) {
  29:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *>(gaddrof(CAnimBlendClumpData::ForAllFrames), this, callback, data);
  30  }

  35  void CAnimBlendClumpData::ForAllFramesInSPR(void(*callback)(AnimBlendFrameData *, void *), void *data, unsigned int a3) {
  36:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *, unsigned int>(gaddrof(CAnimBlendClumpData::ForAllFramesInSPR), this, callback, data, a3);
  37  }

  42  void CAnimBlendClumpData::LoadFramesIntoSPR() {
  43:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(gaddrof(CAnimBlendClumpData::LoadFramesIntoSPR), this);
  44  }

  49  void CAnimBlendClumpData::SetNumberOfBones(int numBones) {
  50:     plugin::CallMethodDynGlobal<CAnimBlendClumpData *, int>(gaddrof(CAnimBlendClumpData::SetNumberOfBones), this, numBones);
  51  }

plugin_sa\game_sa\CAnimBlendHierarchy.cpp:
  11  void* CAnimBlendHierarchy::AllocSequenceBlock(bool arg1) {
  12: 	return plugin::CallMethodAndReturn<void*, 0x4CF510, CAnimBlendHierarchy *, bool>(this, arg1);
  13  }

  16  CAnimBlendHierarchy::CAnimBlendHierarchy() {
  17: 	plugin::CallMethod<0x4CF270, CAnimBlendHierarchy *>(this);
  18  }

  21  void CAnimBlendHierarchy::CalcTotalTime() {
  22: 	plugin::CallMethod<0x4CF2F0, CAnimBlendHierarchy *>(this);
  23  }

  26  void CAnimBlendHierarchy::CalcTotalTimeCompressed() {
  27: 	plugin::CallMethod<0x4CF3E0, CAnimBlendHierarchy *>(this);
  28  }

  31  void CAnimBlendHierarchy::RemoveAnimSequences() {
  32: 	plugin::CallMethod<0x4CF8E0, CAnimBlendHierarchy *>(this);
  33  }

  36  void CAnimBlendHierarchy::RemoveQuaternionFlips() {
  37: 	plugin::CallMethod<0x4CF4E0, CAnimBlendHierarchy *>(this);
  38  }

  41  void CAnimBlendHierarchy::RemoveUncompressedData() {
  42: 	plugin::CallMethod<0x4CF760, CAnimBlendHierarchy *>(this);
  43  }

  46  void CAnimBlendHierarchy::SetName(char const* string) {
  47: 	plugin::CallMethod<0x4CF2D0, CAnimBlendHierarchy *, char const*>(this, string);
  48  }

  51  void CAnimBlendHierarchy::Shutdown() {
  52: 	plugin::CallMethod<0x4CF980, CAnimBlendHierarchy *>(this);
  53  }

  56  void CAnimBlendHierarchy::Uncompress() {
  57: 	plugin::CallMethod<0x4CF5F0, CAnimBlendHierarchy *>(this);
  58  }

plugin_sa\game_sa\CAnimBlendNode.cpp:
  11  void CAnimBlendNode::CalcDeltas() {
  12:     plugin::CallMethod<0x4D0190, CAnimBlendNode *>(this);
  13  }

  16  void CAnimBlendNode::CalcDeltasCompressed() {
  17:     plugin::CallMethod<0x4D0350, CAnimBlendNode *>(this);
  18  }

  21  bool CAnimBlendNode::FindKeyFrame(float arg1) {
  22:     return plugin::CallMethodAndReturn<bool, 0x4D0240, CAnimBlendNode *, float>(this, arg1);
  23  }

  26  void CAnimBlendNode::GetCurrentTranslation(CVector& Vector, float arg2) {
  27:     plugin::CallMethod<0x4CFC50, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
  28  }

  31  void CAnimBlendNode::GetCurrentTranslationCompressed(CVector& Vector, float arg2) {
  32:     plugin::CallMethod<0x4CFE60, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
  33  }

  36  void CAnimBlendNode::GetEndTranslation(CVector& Vector, float arg2) {
  37:     plugin::CallMethod<0x4CFD90, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
  38  }

  41  void CAnimBlendNode::GetEndTranslationCompressed(CVector& Vector, float arg2) {
  42:     plugin::CallMethod<0x4D0000, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
  43  }

  46  void CAnimBlendNode::Init() {
  47:     plugin::CallMethod<0x4CFB70, CAnimBlendNode *>(this);
  48  }

  51  bool CAnimBlendNode::NextKeyFrame() {
  52:     return plugin::CallMethodAndReturn<bool, 0x4D04A0, CAnimBlendNode *>(this);
  53  }

  56  bool CAnimBlendNode::NextKeyFrameCompressed() {
  57:     return plugin::CallMethodAndReturn<bool, 0x4D0570, CAnimBlendNode *>(this);
  58  }

  61  bool CAnimBlendNode::NextKeyFrameNoCalc() {
  62:     return plugin::CallMethodAndReturn<bool, 0x4CFB90, CAnimBlendNode *>(this);
  63  }

  66  bool CAnimBlendNode::SetupKeyFrameCompressed() {
  67:     return plugin::CallMethodAndReturn<bool, 0x4D0650, CAnimBlendNode *>(this);
  68  }

  71  bool CAnimBlendNode::Update(CVector& Vector, CQuaternion& Qauternion, float arg3) {
  72:     return plugin::CallMethodAndReturn<bool, 0x4D06C0, CAnimBlendNode *, CVector&, CQuaternion&, float>(this, Vector, Qauternion, arg3);
  73  }

  76  bool CAnimBlendNode::UpdateCompressed(CVector& Vector, CQuaternion& Quaternion, float arg3) {
  77:     return plugin::CallMethodAndReturn<bool, 0x4D08D0, CAnimBlendNode *, CVector&, CQuaternion&, float>(this, Vector, Quaternion, arg3);
  78  }

plugin_sa\game_sa\CAnimBlendSequence.cpp:
  11  CAnimBlendSequence::CAnimBlendSequence() {
  12: 	plugin::CallMethod<0x4D0C10, CAnimBlendSequence *>(this);
  13  }

  16  void CAnimBlendSequence::CompressKeyframes(unsigned char* arg1) {
  17: 	plugin::CallMethod<0x4D0F40, CAnimBlendSequence *, unsigned char*>(this, arg1);
  18  }

  21  int CAnimBlendSequence::GetDataSize(bool arg1) {
  22: 	return plugin::CallMethodAndReturn<int, 0x4D0C90, CAnimBlendSequence *, bool>(this, arg1);
  23  }

  26  bool CAnimBlendSequence::MoveMemorY() {
  27: 	return plugin::CallMethodAndReturn<bool, 0x4D1150, CAnimBlendSequence *>(this);
  28  }

  31  int CAnimBlendSequence::RemoveQuaternionFlips() {
  32: 	return plugin::CallMethodAndReturn<int, 0x4D1190, CAnimBlendSequence *>(this);
  33  }

  36  void CAnimBlendSequence::RemoveUncompressedData(unsigned char* arg1) {
  37: 	plugin::CallMethod<0x4D12A0, CAnimBlendSequence *, unsigned char*>(this, arg1);
  38  }

  41  void CAnimBlendSequence::SetBoneTag(int hash) {
  42: 	plugin::CallMethod<0x4D0C70, CAnimBlendSequence *, int>(this, hash);
  43  }

  46  void CAnimBlendSequence::SetName(char const* string) {
  47: 	plugin::CallMethod<0x4D0C50, CAnimBlendSequence *, char const*>(this, string);
  48  }

  51  void CAnimBlendSequence::SetNumFrames(int count, bool arg2, bool arg3, unsigned char* arg4) {
  52: 	plugin::CallMethod<0x4D0CD0, CAnimBlendSequence *, int, bool, bool, unsigned char*>(this, count, arg2, arg3, arg4);
  53  }

  56  void CAnimBlendSequence::Uncompress(unsigned char* arg1) {
  57: 	plugin::CallMethod<0x4D0D40, CAnimBlendSequence *, unsigned char*>(this, arg1);
  58  }

  61  CAnimBlendSequence::~CAnimBlendSequence() {
  62: 	plugin::CallMethod<0x4D0C30, CAnimBlendSequence *>(this);
  63  }

plugin_sa\game_sa\CAnimBlendStaticAssociation.cpp:
  26  void CAnimBlendStaticAssociation::AllocateSequenceArray(int count) {
  27:     plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, int>(gaddrof(CAnimBlendStaticAssociation::AllocateSequenceArray), this, count);
  28  }

  33  void CAnimBlendStaticAssociation::FreeSequenceArray() {
  34:     plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(gaddrof(CAnimBlendStaticAssociation::FreeSequenceArray), this);
  35  }

  40  void CAnimBlendStaticAssociation::Init(RpClump *clump, CAnimBlendHierarchy *hierarchy) {
  41:     plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof(CAnimBlendStaticAssociation::Init), this, clump, hierarchy);
  42  }

plugin_sa\game_sa\CAnimManager.cpp:
   20  CAnimBlock* CAnimManager::GetAnimationBlock(char const* name) {
   21: 	return plugin::CallAndReturn<CAnimBlock*, 0x4D3940, char const*>(name);
   22  }

   25  int CAnimManager::GetAnimationBlockIndex(char const* name) {
   26: 	return plugin::CallAndReturn<int, 0x4D3990, char const*>(name);
   27  }

   30  int CAnimManager::GetFirstAssocGroup(char const* basename) {
   31: 	return plugin::CallAndReturn<int, 0x4D39B0, char const*>(basename);
   32  }

   35  CAnimBlendHierarchy* CAnimManager::GetAnimation(unsigned int hash, CAnimBlock const* ifp) {
   36: 	return plugin::CallAndReturn<CAnimBlendHierarchy*, 0x4D39F0, unsigned int, CAnimBlock const*>(hash, ifp);
   37  }

   40  CAnimBlendHierarchy* CAnimManager::GetAnimation(char const* animName, CAnimBlock const* ifp) {
   41: 	return plugin::CallAndReturn<CAnimBlendHierarchy*, 0x4D42F0, char const*, CAnimBlock const*>(animName, ifp);
   42  }

   45  char* CAnimManager::GetAnimGroupName(int AssocGroupId) {
   46: 	return plugin::CallAndReturn<char*, 0x4D3A20, int>(AssocGroupId);
   47  }

   50  char* CAnimManager::GetAnimBlockName(int AssocGroupId) {
   51: 	return plugin::CallAndReturn<char*, 0x4D3A30, int>(AssocGroupId);
   52  }

   55  CAnimBlendAssociation* CAnimManager::CreateAnimAssociation(int AssocGroupId, int AnimationId) {
   56: 	return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3A40, int, int>(AssocGroupId, AnimationId);
   57  }

   60  CAnimBlendStaticAssociation* CAnimManager::GetAnimAssociation(int AssocGroupId, int AnimationId) {
   61: 	return plugin::CallAndReturn<CAnimBlendStaticAssociation*, 0x4D3A60, int, int>(AssocGroupId, AnimationId);
   62  }

   65  CAnimBlendStaticAssociation* CAnimManager::GetAnimAssociation(int AssocGroupId, char const* arg2) {
   66: 	return plugin::CallAndReturn<CAnimBlendStaticAssociation*, 0x4D3A80, int, char const*>(AssocGroupId, arg2);
   67  }

   70  CAnimBlendAssociation* CAnimManager::AddAnimation(RpClump* clump, int AssocGroupId, int AnimationId) {
   71: 	return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3AA0, RpClump*, int, int>(clump, AssocGroupId, AnimationId);
   72  }

   75  CAnimBlendAssociation* CAnimManager::AddAnimation(RpClump* clump, CAnimBlendHierarchy* pAnimBlendHier, int clumpAssocFlag) {
   76: 	return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D4330, RpClump*, CAnimBlendHierarchy*, int>(clump, pAnimBlendHier, clumpAssocFlag);
   77  }

   80  CAnimBlendAssociation* CAnimManager::AddAnimationAndSync(RpClump* clump, CAnimBlendAssociation* pAnimBlendAssoc, int AssocGroupId, int AnimationId) {
   81: 	return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3B30, RpClump*, CAnimBlendAssociation*, int, int>(clump, pAnimBlendAssoc, AssocGroupId, AnimationId);
   82  }

   85  CAnimationStyleDescriptor* CAnimManager::AddAnimAssocDefinition(char const* groupName, char const* blockName, unsigned int arg3, unsigned int animsCount, void* pAnimDescriptor) {
   86: 	return plugin::CallAndReturn<CAnimationStyleDescriptor*, 0x4D3BA0, char const*, char const*, unsigned int, unsigned int, void*>(groupName, blockName, arg3, animsCount, pAnimDescriptor);
   87  }

   90  void* CAnimManager::AddAnimToAssocDefinition(void* pAnimAssocDefinition, char const* arg2) {
   91: 	return plugin::CallAndReturn<void*, 0x4D3C80, void*, char const*>(pAnimAssocDefinition, arg2);
   92  }

   95  void CAnimManager::CreateAnimAssocGroups() {
   96: 	plugin::Call<0x4D3CC0>();
   97  }

  100  int CAnimManager::RegisterAnimBlock(char const* name) {
  101: 	return plugin::CallAndReturn<int, 0x4D3E50, char const*>(name);
  102  }

  105  void CAnimManager::RemoveLastAnimFile() {
  106: 	plugin::Call<0x4D3ED0>();
  107  }

  110  void CAnimManager::RemoveAnimBlock(int index) {
  111: 	plugin::Call<0x4D3F40, int>(index);
  112  }

  115  void CAnimManager::AddAnimBlockRef(int index) {
  116: 	plugin::Call<0x4D3FB0, int>(index);
  117  }

  120  void CAnimManager::RemoveAnimBlockRef(int index) {
  121: 	plugin::Call<0x4D3FD0, int>(index);
  122  }

  125  void CAnimManager::RemoveAnimBlockRefWithoutDelete(int index) {
  126: 	plugin::Call<0x4D3FF0, int>(index);
  127  }

  130  int CAnimManager::GetNumRefsToAnimBlock(int index) {
  131: 	return plugin::CallAndReturn<int, 0x4D4010, int>(index);
  132  }

  135  void CAnimManager::Shutdown() {
  136: 	plugin::Call<0x4D4130>();
  137  }

  140  void CAnimManager::UncompressAnimation(CAnimBlendHierarchy* pAnimBlendHier) {
  141: 	plugin::Call<0x4D41C0, CAnimBlendHierarchy*>(pAnimBlendHier);
  142  }

  145  void CAnimManager::RemoveFromUncompressedCache(CAnimBlendHierarchy* pAnimBlendHier) {
  146: 	plugin::Call<0x4D42A0, CAnimBlendHierarchy*>(pAnimBlendHier);
  147  }

  150  CAnimBlendAssociation* CAnimManager::BlendAnimation(RpClump* clump, CAnimBlendHierarchy* pAnimBlendHier, int flags, float clumpAssocBlendData) {
  151: 	return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D4410, RpClump*, CAnimBlendHierarchy*, int, float>(clump, pAnimBlendHier, flags, clumpAssocBlendData);
  152  }

  155  CAnimBlendAssociation* CAnimManager::BlendAnimation(RpClump* clump, int AssocGroupId, int AnimationId, float clumpAssocBlendData) {
  156: 	return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D4610, RpClump*, int, int, float>(clump, AssocGroupId, AnimationId, clumpAssocBlendData);
  157  }

  160  void CAnimManager::LoadAnimFile(RwStream* stream, bool arg1, char const(*string)[32]) {
  161: 	plugin::Call<0x4D47F0, RwStream*, bool, char const(*)[32]>(stream, arg1, string);
  162  }

  165  void CAnimManager::LoadAnimFiles() {
  166: 	plugin::Call<0x4D5620>();
  167  }

  170  void CAnimManager::ReadAnimAssociationDefinitions() {
  171: 	plugin::Call<0x5BC910>();
  172  }

  175  void CAnimManager::Initialise() {
  176: 	plugin::Call<0x5BF6B0>();
  177  }

plugin_sa\game_sa\CAudioEngine.cpp:
  12  void CAudioEngine::Initialise() {
  13:     plugin::CallMethod<0x5B9C60, CAudioEngine*>(this);
  14  }

  16  void CAudioEngine::Restart() {
  17:     plugin::CallMethod<0x506DB0, CAudioEngine*>(this);
  18  }

  20  void CAudioEngine::Shutdown() {
  21:     plugin::CallMethod<0x507CB0, CAudioEngine*>(this);
  22  }

  24  void CAudioEngine::SetEffectsMasterVolume(char volume) {
  25:     plugin::CallMethod<0x506E10, CAudioEngine*, char>(this, volume);
  26  }

  28  void CAudioEngine::SetMusicMasterVolume(char volume) {
  29:     plugin::CallMethod<0x506DE0, CAudioEngine*, char>(this, volume);
  30  }

  32  void CAudioEngine::SetBassEnhanceOnOff(bool on) {
  33:     plugin::CallMethod<0x506F90, CAudioEngine*, bool>(this, on);
  34  }

  36  void CAudioEngine::SetRadioAutoRetuneOnOff(bool on) {
  37:     plugin::CallMethod<0x506F80, CAudioEngine*, bool>(this, on);
  38  }

  40  void CAudioEngine::RetuneRadio(char stationId) {
  41:     plugin::CallMethod<0x507E10, CAudioEngine*, char>(this, stationId);
  42  }

  44  CReference* CAudioEngine::ReportFrontendAudioEvent(int id, float volume, float speed) {
  45:     return plugin::CallMethodAndReturn<CReference*, 0x506EA0, CAudioEngine*, int, float, float>(this, id, volume, speed);
  46  }

  49  void CAudioEngine::ReportMissionAudioEvent(eAudioEvents audioEvent, CVector const* coords) {
  50:     plugin::CallMethod<0x507340, CAudioEngine*, eAudioEvents,CVector const*>(this,audioEvent,coords);
  51  }

  53  void CAudioEngine::Service() {
  54:     plugin::CallMethod<0x507750, CAudioEngine*>(this);
  55  }

  57  void CAudioEngine::ServiceLoadingTune(float fade) {
  58:     plugin::CallMethod<0x5078A0, CAudioEngine*, float>(this, fade);
  59  }

  61  void CAudioEngine::StartRadio(int radioStation, char arg) {
  62:     plugin::CallMethod<0x507DC0, CAudioEngine*, int, char>(this, radioStation, arg);
  63  }

  65  void CAudioEngine::StopRadio(tVehicleAudioSettings* settings, bool arg) {
  66:     plugin::CallMethod<0x506F70, CAudioEngine*, tVehicleAudioSettings*, bool>(this, settings, arg);
  67  }

  69  bool CAudioEngine::IsRadioRetuneInProgress() {
  70:     return plugin::CallMethodAndReturn<bool, 0x506FF0, CAudioEngine*>(this);
  71  }

  73  bool CAudioEngine::IsLoadingTuneActive() {
  74:     return plugin::CallMethodAndReturn<bool, 0x506D90, CAudioEngine*>(this);
  75  }

  77  bool CAudioEngine::IsRadioOn() {
  78:     return plugin::CallMethodAndReturn<bool, 0x506FD0, CAudioEngine*>(this);
  79  }

  81  bool CAudioEngine::IsAmbienceTrackActive() {
  82:     return plugin::CallMethodAndReturn<bool, 0x507210, CAudioEngine*>(this);
  83  }

  85  bool CAudioEngine::StartLoadingTune() {
  86:     return plugin::CallMethodAndReturn<bool, 0x507410, CAudioEngine*>(this);
  87  }

  89  char CAudioEngine::GetCurrentRadioStationID() {
  90:     return plugin::CallMethodAndReturn<bool, 0x507040, CAudioEngine*>(this);
  91  }

  93  bool CAudioEngine::IsVehicleRadioActive() {
  94:     return plugin::CallMethodAndReturn<bool, 0x507050, CAudioEngine*>(this);
  95  }

  97  void CAudioEngine::InitialisePostLoading() {
  98:     plugin::CallMethod<0x5078F0, CAudioEngine*>(this);
  99  }

plugin_sa\game_sa\CBaseModelInfo.cpp:
  140  bool CBaseModelInfo::GetIsDrawLast() {
  141: 	return plugin::CallMethodAndReturn<bool, 0x5328C0, CBaseModelInfo *>(this);
  142  }

  145  bool CBaseModelInfo::HasBeenPreRendered() {
  146: 	return plugin::CallMethodAndReturn<bool, 0x5328B0, CBaseModelInfo *>(this);
  147  }

  150  bool CBaseModelInfo::HasComplexHierarchy() {
  151: 	return plugin::CallMethodAndReturn<bool, 0x4C4E00, CBaseModelInfo *>(this);
  152  }

  155  bool CBaseModelInfo::IsBackfaceCulled() {
  156: 	return plugin::CallMethodAndReturn<bool, 0x5328F0, CBaseModelInfo *>(this);
  157  }

  160  bool CBaseModelInfo::IsBreakableStatuePart() {
  161: 	return plugin::CallMethodAndReturn<bool, 0x59F090, CBaseModelInfo *>(this);
  162  }

  165  bool CBaseModelInfo::IsLod() {
  166: 	return plugin::CallMethodAndReturn<bool, 0x4C4A00, CBaseModelInfo *>(this);
  167  }

  170  bool CBaseModelInfo::IsRoad() {
  171: 	return plugin::CallMethodAndReturn<bool, 0x4C4DF0, CBaseModelInfo *>(this);
  172  }

  175  bool CBaseModelInfo::IsTagModel() {
  176: 	return plugin::CallMethodAndReturn<bool, 0x49CC20, CBaseModelInfo *>(this);
  177  }

  180  bool CBaseModelInfo::SwaysInWind() {
  181: 	return plugin::CallMethodAndReturn<bool, 0x4212C0, CBaseModelInfo *>(this);
  182  }

  185  void CBaseModelInfo::SetHasBeenPreRendered(int bHasBeenPreRendered) {
  186: 	plugin::CallMethod<0x4C42F0, CBaseModelInfo *, int>(this, bHasBeenPreRendered);
  187  }

  190  void CBaseModelInfo::SetIsLod(int bIsLod) {
  191: 	plugin::CallMethod<0x4C4A10, CBaseModelInfo *, int>(this, bIsLod);
  192  }

  195  void CBaseModelInfo::SetOwnsColModel(int bOwns) {
  196: 	plugin::CallMethod<0x5328D0, CBaseModelInfo *, int>(this, bOwns);
  197  }

  200  void CBaseModelInfo::IncreaseAlpha() {
  201: 	plugin::CallMethod<0x532900, CBaseModelInfo *>(this);
  202  }

plugin_sa\game_sa\CBirds.cpp:
  19  void CBirds::Init() {
  20:     plugin::Call<0x711EC0>();
  21  }

  24  int CBirds::CreateNumberOfBirds(CVector pos, CVector destination, int count, int birdType, bool checkObstacles) {
  25:     return plugin::CallAndReturn<int, 0x711EF0, CVector, CVector, int, int, bool>(pos, destination, count, birdType, checkObstacles);
  26  }

  29  void CBirds::Shutdown() {
  30:     plugin::Call<0x712300>();
  31  }

  34  void CBirds::Update() {
  35:     plugin::Call<0x712330>();
  36  }

  39  void CBirds::Render() {
  40:     plugin::Call<0x712810>();
  41  }

  44  void CBirds::HandleGunShot(CVector const* pointA, CVector const* pointB) {
  45:     plugin::Call<0x712E40, CVector const*, CVector const*>(pointA, pointB);
  46  }

plugin_sa\game_sa\CBouncingPanel.cpp:
  16  void CBouncingPanel::ResetPanel() {
  17:     plugin::CallMethod<0x6F4910, CBouncingPanel *>(this);
  18  }

  21  void CBouncingPanel::SetPanel(short frameId, short axis, float angleLimit) {
  22:     plugin::CallMethod<0x6F4920, CBouncingPanel *, short, short, float>(this, frameId, axis, angleLimit);
  23  }

  26  void CBouncingPanel::ProcessPanel(CVehicle* vehicle, RwFrame* frame, CVector arg2, CVector arg3, float arg4, float arg5) {
  27:     plugin::CallMethod<0x6F49A0, CBouncingPanel *, CVehicle*, RwFrame*, CVector, CVector, float, float>(this, vehicle, frame, arg2, arg3, arg4, arg5);
  28  }

plugin_sa\game_sa\CBoundingBox.cpp:
  10  CBoundingBox::CBoundingBox() {
  11:     plugin::CallMethod<0x40FAF0, CBoundingBox *>(this);
  12  }

plugin_sa\game_sa\CBrightLights.cpp:
  15  void CBrightLights::RenderOutGeometryBuffer() {
  16:     plugin::Call<0x722150>();
  17  }

  20  void CBrightLights::Render() {
  21:     plugin::Call<0x7241C0>();
  22  }

  25  void CBrightLights::RegisterOne(CVector posn, CVector top, CVector right, CVector at, unsigned char color, unsigned char arg5, unsigned char arg6, unsigned char arg7) {
  26:     plugin::Call<0x724770, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(posn, top, right, at, color, arg5, arg6, arg7);
  27  }

  30  void CBrightLights::Init() {
  31:     plugin::Call<0x722140>();
  32  }

plugin_sa\game_sa\CBuilding.cpp:
  15  void* CBuilding::operator new(unsigned int size) {
  16:     return plugin::CallAndReturn<void*, 0x404090, unsigned int>(size);
  17  }

  20  void CBuilding::operator delete(void* data) {
  21:     plugin::Call<0x4040A0, void*>(data);
  22  }

  25  CBuilding::CBuilding() : CEntity(plugin::dummy) {
  26:     plugin::CallMethod<0x403E00, CBuilding *>(this);
  27  }

plugin_sa\game_sa\CBulletInfo.cpp:
  15  void CBulletInfo::Initialise() {
  16:     plugin::Call<0x735FD0>();
  17  }

  20  void CBulletInfo::Shutdown() {
  21:     plugin::Call<0x736000>();
  22  }

  25  bool CBulletInfo::AddBullet(CEntity* creator, eWeaponType weaponType, CVector position, CVector velocity) {
  26:     return plugin::CallAndReturn<bool, 0x736010, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, position, velocity);
  27  }

  30  void CBulletInfo::Update() {
  31:     plugin::Call<0x7360D0>();
  32  }

plugin_sa\game_sa\CBulletTrace.cpp:
  10  void CBulletTrace::Update() {
  11:     plugin::CallMethod<0x721D70, CBulletTrace *>(this);
  12  }

plugin_sa\game_sa\CBulletTraces.cpp:
  14  void CBulletTraces::AddTrace(CVector* start, CVector* end, int weaponType, CEntity* entity) {
  15:     plugin::Call<0x726AF0, CVector*, CVector*, int, CEntity*>(start, end, weaponType, entity);
  16  }

  34  void CBulletTraces::Init() {
  35:     plugin::Call<0x721D50>();
  36  }

plugin_sa\game_sa\CCamera.cpp:
   30  void CCamera::AddShakeSimple(float duration, int type, float intensity) {
   31:     plugin::CallMethodDynGlobal<CCamera *, float, int, float>(gaddrof(CCamera::AddShakeSimple), this, duration, type, intensity);
   32  }

   37  void CCamera::AllowShootingWith2PlayersInCar(bool bAllowShootingWith2PlayersInCar) {
   38:     plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::AllowShootingWith2PlayersInCar), this, bAllowShootingWith2PlayersInCar);
   39  }

   44  void CCamera::ApplyVehicleCameraTweaks(CVehicle *vehicle) {
   45:     plugin::CallMethodDynGlobal<CCamera *, CVehicle *>(gaddrof(CCamera::ApplyVehicleCameraTweaks), this, vehicle);
   46  }

   51  void CCamera::AvoidTheGeometry(CVector const *arg2, CVector const *arg3, CVector *arg4, float FOV) {
   52:     plugin::CallMethodDynGlobal<CCamera *, CVector const *, CVector const *, CVector *, float>(gaddrof(CCamera::AvoidTheGeometry), this, arg2, arg3, arg4, FOV);
   53  }

   58  void CCamera::CalculateDerivedValues(bool bForMirror, bool bOriented) {
   59:     plugin::CallMethodDynGlobal<CCamera *, bool, bool>(gaddrof(CCamera::CalculateDerivedValues), this, bForMirror, bOriented);
   60  }

   65  void CCamera::CalculateFrustumPlanes(bool bForMirror) {
   66:     plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::CalculateFrustumPlanes), this, bForMirror);
   67  }

   72  float CCamera::CalculateGroundHeight(unsigned int type) {
   73:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *, unsigned int>(gaddrof(CCamera::CalculateGroundHeight), this, type);
   74  }

   79  void CCamera::CalculateMirroredMatrix(CVector posn, float MirrorV, CMatrix *CamMat, CMatrix *MirrorMat) {
   80:     plugin::CallMethodDynGlobal<CCamera *, CVector, float, CMatrix *, CMatrix *>(gaddrof(CCamera::CalculateMirroredMatrix), this, posn, MirrorV, CamMat, MirrorMat);
   81  }

   86  void CCamera::CamControl() {
   87:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CamControl), this);
   88  }

   93  void CCamera::CamShake(float arg2, float x, float y, float z) {
   94:     plugin::CallMethodDynGlobal<CCamera *, float, float, float, float>(gaddrof(CCamera::CamShake), this, arg2, x, y, z);
   95  }

  100  char CCamera::CameraColDetAndReact(CVector *source, CVector *target) {
  101:     return plugin::CallMethodAndReturnDynGlobal<char, CCamera *, CVector *, CVector *>(gaddrof(CCamera::CameraColDetAndReact), this, source, target);
  102  }

  107  void CCamera::CameraGenericModeSpecialCases(CPed *targetPed) {
  108:     plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::CameraGenericModeSpecialCases), this, targetPed);
  109  }

  114  void CCamera::CameraPedAimModeSpecialCases(CPed *targPed) {
  115:     plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::CameraPedAimModeSpecialCases), this, targPed);
  116  }

  121  void CCamera::CameraPedModeSpecialCases() {
  122:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CameraPedModeSpecialCases), this);
  123  }

  128  void CCamera::CameraVehicleModeSpecialCases(CVehicle *targVehicle) {
  129:     plugin::CallMethodDynGlobal<CCamera *, CVehicle *>(gaddrof(CCamera::CameraVehicleModeSpecialCases), this, targVehicle);
  130  }

  135  void CCamera::ClearPlayerWeaponMode() {
  136:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ClearPlayerWeaponMode), this);
  137  }

  142  bool CCamera::ConeCastCollisionResolve(CVector *source, CVector *center, CVector *pVecOut, float radius, float arg5, float *pFloatOut) {
  143:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector *, CVector *, CVector *, float, float, float *>(gaddrof(CCamera::ConeCastCollisionResolve), this, source, center, pVecOut, radius, arg5, pFloatOut);
  144  }

  149  bool CCamera::ConsiderPedAsDucking(CPed *ped) {
  150:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CPed *>(gaddrof(CCamera::ConsiderPedAsDucking), this, ped);
  151  }

  156  void CCamera::CopyCameraMatrixToRWCam(bool bUpdateMatrix) {
  157:     plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::CopyCameraMatrixToRWCam), this, bUpdateMatrix);
  158  }

  163  void CCamera::DealWithMirrorBeforeConstructRenderList(bool bActiveMirror, CVector MirrorNormal, float MirrorV, CMatrix *matMirror) {
  164:     plugin::CallMethodDynGlobal<CCamera *, bool, CVector, float, CMatrix *>(gaddrof(CCamera::DealWithMirrorBeforeConstructRenderList), this, bActiveMirror, MirrorNormal, MirrorV, matMirror);
  165  }

  170  void CCamera::DeleteCutSceneCamDataMemory() {
  171:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DeleteCutSceneCamDataMemory), this);
  172  }

  177  void CCamera::DrawBordersForWideScreen() {
  178:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DrawBordersForWideScreen), this);
  179  }

  184  void CCamera::Enable1rstPersonCamCntrlsScript() {
  185:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Enable1rstPersonCamCntrlsScript), this);
  186  }

  191  void CCamera::Enable1rstPersonWeaponsCamera() {
  192:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Enable1rstPersonWeaponsCamera), this);
  193  }

  198  void CCamera::Fade(float fadeDuration, short FadeInOutFlag) {
  199:     plugin::CallMethodDynGlobal<CCamera *, float, short>(gaddrof(CCamera::Fade), this, fadeDuration, FadeInOutFlag);
  200  }

  205  void CCamera::Find3rdPersonCamTargetVector(float range, CVector source, CVector *pCamera, CVector *pPoint) {
  206:     plugin::CallMethodDynGlobal<CCamera *, float, CVector, CVector *, CVector *>(gaddrof(CCamera::Find3rdPersonCamTargetVector), this, range, source, pCamera, pPoint);
  207  }

  212  float CCamera::Find3rdPersonQuickAimPitch() {
  213:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::Find3rdPersonQuickAimPitch), this);
  214  }

  219  float CCamera::FindCamFOV() {
  220:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::FindCamFOV), this);
  221  }

  226  void CCamera::FinishCutscene() {
  227:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::FinishCutscene), this);
  228  }

  233  void CCamera::GetArrPosForVehicleType(int type, int *arrPos) {
  234:     plugin::CallMethodDynGlobal<CCamera *, int, int *>(gaddrof(CCamera::GetArrPosForVehicleType), this, type, arrPos);
  235  }

  240  unsigned int CCamera::GetCutSceneFinishTime() {
  241:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::GetCutSceneFinishTime), this);
  242  }

  247  bool CCamera::GetFading() {
  248:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetFading), this);
  249  }

  254  int CCamera::GetFadingDirection() {
  255:     return plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetFadingDirection), this);
  256  }

  261  CVector *CCamera::GetGameCamPosition() {
  262:     return plugin::CallMethodAndReturnDynGlobal<CVector *, CCamera *>(gaddrof(CCamera::GetGameCamPosition), this);
  263  }

  268  signed int CCamera::GetLookDirection() {
  269:     return plugin::CallMethodAndReturnDynGlobal<signed int, CCamera *>(gaddrof(CCamera::GetLookDirection), this);
  270  }

  275  bool CCamera::GetLookingForwardFirstPerson() {
  276:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingForwardFirstPerson), this);
  277  }

  282  bool CCamera::GetLookingLRBFirstPerson() {
  283:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingLRBFirstPerson), this);
  284  }

  289  float CCamera::GetPositionAlongSpline() {
  290:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetPositionAlongSpline), this);
  291  }

  296  float CCamera::GetRoughDistanceToGround() {
  297:     return plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetRoughDistanceToGround), this);
  298  }

  303  signed int CCamera::GetScreenFadeStatus() {
  304:     return plugin::CallMethodAndReturnDynGlobal<signed int, CCamera *>(gaddrof(CCamera::GetScreenFadeStatus), this);
  305  }

  310  void CCamera::GetScreenRect(CRect *pRect) {
  311:     plugin::CallMethodDynGlobal<CCamera *, CRect *>(gaddrof(CCamera::GetScreenRect), this, pRect);
  312  }

  317  bool CCamera::Get_Just_Switched_Status() {
  318:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Get_Just_Switched_Status), this);
  319  }

  324  void CCamera::HandleCameraMotionForDucking(CPed *ped, CVector *source, CVector *targPosn, bool arg5) {
  325:     plugin::CallMethodDynGlobal<CCamera *, CPed *, CVector *, CVector *, bool>(gaddrof(CCamera::HandleCameraMotionForDucking), this, ped, source, targPosn, arg5);
  326  }

  331  void CCamera::HandleCameraMotionForDuckingDuringAim(CPed *ped, CVector *source, CVector *targPosn, bool arg5) {
  332:     plugin::CallMethodDynGlobal<CCamera *, CPed *, CVector *, CVector *, bool>(gaddrof(CCamera::HandleCameraMotionForDuckingDuringAim), this, ped, source, targPosn, arg5);
  333  }

  338  void CCamera::ImproveNearClip(CVehicle *pVehicle, CPed *pPed, CVector *source, CVector *targPosn) {
  339:     plugin::CallMethodDynGlobal<CCamera *, CVehicle *, CPed *, CVector *, CVector *>(gaddrof(CCamera::ImproveNearClip), this, pVehicle, pPed, source, targPosn);
  340  }

  345  void CCamera::Init() {
  346:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Init), this);
  347  }

  352  void CCamera::InitCameraVehicleTweaks() {
  353:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::InitCameraVehicleTweaks), this);
  354  }

  359  int CCamera::InitialiseScriptableComponents() {
  360:     return plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::InitialiseScriptableComponents), this);
  361  }

  366  bool CCamera::IsExtraEntityToIgnore(CEntity *entity) {
  367:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CEntity *>(gaddrof(CCamera::IsExtraEntityToIgnore), this, entity);
  368  }

  373  bool CCamera::IsItTimeForNewcam(int CamSequence, int StartTime) {
  374:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int, int>(gaddrof(CCamera::IsItTimeForNewcam), this, CamSequence, StartTime);
  375  }

  380  bool CCamera::IsSphereVisible(CVector const &origin, float radius, RwMatrixTag *transformMatrix) {
  381:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float, RwMatrixTag *>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float, RwMatrixTag *)), this, origin, radius, transformMatrix);
  382  }

  387  bool CCamera::IsSphereVisible(CVector const &origin, float radius) {
  388:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float)), this, origin, radius);
  389  }

  394  void CCamera::LerpFOV(float zoomInFactor, float zoomOutFactor, float timelimit, bool bEase) {
  395:     plugin::CallMethodDynGlobal<CCamera *, float, float, float, bool>(gaddrof(CCamera::LerpFOV), this, zoomInFactor, zoomOutFactor, timelimit, bEase);
  396  }

  401  void CCamera::LoadPathSplines(int pFile) {
  402:     plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::LoadPathSplines), this, pFile);
  403  }

  408  void CCamera::Process() {
  409:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process), this);
  410  }

  415  void CCamera::ProcessFOVLerp(float ratio) {
  416:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessFOVLerp, void (CCamera::*)(float)), this, ratio);
  417  }

  422  void CCamera::ProcessFOVLerp() {
  423:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessFOVLerp, void (CCamera::*)()), this);
  424  }

  429  void CCamera::ProcessFade() {
  430:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessFade), this);
  431  }

  436  void CCamera::ProcessMusicFade() {
  437:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessMusicFade), this);
  438  }

  443  void CCamera::ProcessObbeCinemaCameraBoat() {
  444:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraBoat), this);
  445  }

  450  void CCamera::ProcessObbeCinemaCameraCar() {
  451:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraCar), this);
  452  }

  457  void CCamera::ProcessObbeCinemaCameraHeli() {
  458:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraHeli), this);
  459  }

  464  unsigned int CCamera::ProcessObbeCinemaCameraPed() {
  465:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPed), this);
  466  }

  471  void CCamera::ProcessObbeCinemaCameraPlane() {
  472:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPlane), this);
  473  }

  478  void CCamera::ProcessObbeCinemaCameraTrain() {
  479:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraTrain), this);
  480  }

  485  void CCamera::ProcessScriptedCommands() {
  486:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessScriptedCommands), this);
  487  }

  492  void CCamera::ProcessShake(float JiggleIntensity) {
  493:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessShake, void (CCamera::*)(float)), this, JiggleIntensity);
  494  }

  499  void CCamera::ProcessShake() {
  500:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessShake, void (CCamera::*)()), this);
  501  }

  506  void CCamera::ProcessVectorMoveLinear(float ratio) {
  507:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessVectorMoveLinear, void (CCamera::*)(float)), this, ratio);
  508  }

  513  void CCamera::ProcessVectorMoveLinear() {
  514:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessVectorMoveLinear, void (CCamera::*)()), this);
  515  }

  520  void CCamera::ProcessVectorTrackLinear(float ratio) {
  521:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessVectorTrackLinear, void (CCamera::*)(float)), this, ratio);
  522  }

  527  void CCamera::ProcessVectorTrackLinear() {
  528:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessVectorTrackLinear, void (CCamera::*)()), this);
  529  }

  534  void CCamera::ProcessWideScreenOn() {
  535:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessWideScreenOn), this);
  536  }

  541  void CCamera::RenderMotionBlur() {
  542:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RenderMotionBlur), this);
  543  }

  548  void CCamera::ResetDuckingSystem(CPed *ped) {
  549:     plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::ResetDuckingSystem), this, ped);
  550  }

  555  void CCamera::Restore() {
  556:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Restore), this);
  557  }

  562  void CCamera::RestoreCameraAfterMirror() {
  563:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreCameraAfterMirror), this);
  564  }

  569  void CCamera::RestoreWithJumpCut() {
  570:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreWithJumpCut), this);
  571  }

  576  void CCamera::SetCamCutSceneOffSet(CVector const *cutsceneOffset) {
  577:     plugin::CallMethodDynGlobal<CCamera *, CVector const *>(gaddrof(CCamera::SetCamCutSceneOffSet), this, cutsceneOffset);
  578  }

  583  void CCamera::SetCamPositionForFixedMode(CVector const *fixedModeSource, CVector const *fixedModeUpOffset) {
  584:     plugin::CallMethodDynGlobal<CCamera *, CVector const *, CVector const *>(gaddrof(CCamera::SetCamPositionForFixedMode), this, fixedModeSource, fixedModeUpOffset);
  585  }

  590  void CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString() {
  591:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString), this);
  592  }

  597  void CCamera::SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString(CPed *targetPed) {
  598:     plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString), this, targetPed);
  599  }

  604  void CCamera::SetCameraUpForMirror() {
  605:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraUpForMirror), this);
  606  }

  611  void CCamera::SetFadeColour(unsigned char Red, unsigned char Green, unsigned char Blue) {
  612:     plugin::CallMethodDynGlobal<CCamera *, unsigned char, unsigned char, unsigned char>(gaddrof(CCamera::SetFadeColour), this, Red, Green, Blue);
  613  }

  618  void CCamera::SetMotionBlur(int Red, int Green, int Blue, int value, int Blurtype) {
  619:     plugin::CallMethodDynGlobal<CCamera *, int, int, int, int, int>(gaddrof(CCamera::SetMotionBlur), this, Red, Green, Blue, value, Blurtype);
  620  }

  625  void CCamera::SetMotionBlurAlpha(int Alpha) {
  626:     plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::SetMotionBlurAlpha), this, Alpha);
  627  }

  632  void CCamera::SetNearClipBasedOnPedCollision(float arg2) {
  633:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipBasedOnPedCollision), this, arg2);
  634  }

  639  void CCamera::SetNearClipScript(float NearClip) {
  640:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipScript), this, NearClip);
  641  }

  646  void CCamera::SetNewPlayerWeaponMode(short mode, short maxZoom, short minZoom) {
  647:     plugin::CallMethodDynGlobal<CCamera *, short, short, short>(gaddrof(CCamera::SetNewPlayerWeaponMode), this, mode, maxZoom, minZoom);
  648  }

  653  void CCamera::SetParametersForScriptInterpolation(float InterpolationToStopMoving, float InterpolationToCatchUp, unsigned int TimeForInterPolation) {
  654:     plugin::CallMethodDynGlobal<CCamera *, float, float, unsigned int>(gaddrof(CCamera::SetParametersForScriptInterpolation), this, InterpolationToStopMoving, InterpolationToCatchUp, TimeForInterPolation);
  655  }

  660  void CCamera::SetPercentAlongCutScene(float percent) {
  661:     plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetPercentAlongCutScene), this, percent);
  662  }

  667  void CCamera::SetRwCamera(RwCamera *rwcamera) {
  668:     plugin::CallMethodDynGlobal<CCamera *, RwCamera *>(gaddrof(CCamera::SetRwCamera), this, rwcamera);
  669  }

  674  void CCamera::SetWideScreenOff() {
  675:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOff), this);
  676  }

  681  void CCamera::SetWideScreenOn() {
  682:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOn), this);
  683  }

  688  void CCamera::SetZoomValueCamStringScript(short zoomMode) {
  689:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueCamStringScript), this, zoomMode);
  690  }

  695  void CCamera::SetZoomValueFollowPedScript(short zoomMode) {
  696:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueFollowPedScript), this, zoomMode);
  697  }

  702  void CCamera::StartCooperativeCamMode() {
  703:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::StartCooperativeCamMode), this);
  704  }

  709  void CCamera::StartTransition(short currentCamMode) {
  710:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransition), this, currentCamMode);
  711  }

  716  void CCamera::StartTransitionWhenNotFinishedInter(short currentCamMode) {
  717:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransitionWhenNotFinishedInter), this, currentCamMode);
  718  }

  723  void CCamera::StopCooperativeCamMode() {
  724:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::StopCooperativeCamMode), this);
  725  }

  730  void CCamera::StoreValuesDuringInterPol(CVector *SourceDuringInter, CVector *TargetDuringInter, CVector *UpDuringInter, float *FOVDuringInter) {
  731:     plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, CVector *, float *>(gaddrof(CCamera::StoreValuesDuringInterPol), this, SourceDuringInter, TargetDuringInter, UpDuringInter, FOVDuringInter);
  732  }

  737  void CCamera::TakeControl(CEntity *target, short ModeToGoTo, short TypeOfSwitch, int WhoIsInControlOfTheCamera) {
  738:     plugin::CallMethodDynGlobal<CCamera *, CEntity *, short, short, int>(gaddrof(CCamera::TakeControl), this, target, ModeToGoTo, TypeOfSwitch, WhoIsInControlOfTheCamera);
  739  }

  744  void CCamera::TakeControlAttachToEntity(CEntity *target, CEntity *attached, CVector *AttachedCamOffset, CVector *AttachedCamLookAt, float AttachedCamAngle, short TypeOfSwitch, int WhoIsInControlOfTheCamera) {
  745:     plugin::CallMethodDynGlobal<CCamera *, CEntity *, CEntity *, CVector *, CVector *, float, short, int>(gaddrof(CCamera::TakeControlAttachToEntity), this, target, attached, AttachedCamOffset, AttachedCamLookAt, AttachedCamAngle, TypeOfSwitch, WhoIsInControlOfTheCamera);
  746  }

  751  void CCamera::TakeControlNoEntity(CVector const *FixedModeVector, short TypeOfSwitch, int WhoIsInControlOfTheCamera) {
  752:     plugin::CallMethodDynGlobal<CCamera *, CVector const *, short, int>(gaddrof(CCamera::TakeControlNoEntity), this, FixedModeVector, TypeOfSwitch, WhoIsInControlOfTheCamera);
  753  }

  758  void CCamera::TakeControlWithSpline(short TypeOfSwitch) {
  759:     plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::TakeControlWithSpline), this, TypeOfSwitch);
  760  }

  765  bool CCamera::TryToStartNewCamMode(int CamSequence) {
  766:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int>(gaddrof(CCamera::TryToStartNewCamMode), this, CamSequence);
  767  }

  772  void CCamera::UpdateAimingCoors(CVector const *AimingTargetCoors) {
  773:     plugin::CallMethodDynGlobal<CCamera *, CVector const *>(gaddrof(CCamera::UpdateAimingCoors), this, AimingTargetCoors);
  774  }

  779  void CCamera::UpdateSoundDistances() {
  780:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateSoundDistances), this);
  781  }

  786  void CCamera::UpdateTargetEntity() {
  787:     plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateTargetEntity), this);
  788  }

  793  bool CCamera::Using1stPersonWeaponMode() {
  794:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Using1stPersonWeaponMode), this);
  795  }

  800  void CCamera::VectorMoveLinear(CVector *MoveLinearPosnEnd, CVector *MoveLinearPosnStart, float duration, bool bMoveLinearWithEase) {
  801:     plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, float, bool>(gaddrof(CCamera::VectorMoveLinear), this, MoveLinearPosnEnd, MoveLinearPosnStart, duration, bMoveLinearWithEase);
  802  }

  807  bool CCamera::VectorMoveRunning() {
  808:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::VectorMoveRunning), this);
  809  }

  814  void CCamera::VectorTrackLinear(CVector *TrackLinearStartPoint, CVector *TrackLinearEndPoint, float duration, bool bEase) {
  815:     plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, float, bool>(gaddrof(CCamera::VectorTrackLinear), this, TrackLinearStartPoint, TrackLinearEndPoint, duration, bEase);
  816  }

  821  bool CCamera::VectorTrackRunning() {
  822:     return plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::VectorTrackRunning), this);
  823  }

  835  void CCamera::SetCamCollisionVarDataSet(int index) {
  836:     plugin::CallDynGlobal<int>(gaddrof(CCamera::SetCamCollisionVarDataSet), index);
  837  }

  842  void CCamera::SetColVarsAimWeapon(int aimingType) {
  843:     plugin::CallDynGlobal<int>(gaddrof(CCamera::SetColVarsAimWeapon), aimingType);
  844  }

  849  void CCamera::SetColVarsPed(int pedtype, int nCamPedZoom) {
  850:     plugin::CallDynGlobal<int, int>(gaddrof(CCamera::SetColVarsPed), pedtype, nCamPedZoom);
  851  }

  856  void CCamera::SetColVarsVehicle(int vehicletype, int CamVehicleZoom) {
  857:     plugin::CallDynGlobal<int, int>(gaddrof(CCamera::SetColVarsVehicle), vehicletype, CamVehicleZoom);
  858  }

plugin_sa\game_sa\CCarAI.cpp:
  11  void CCarAI::BackToCruisingIfNoWantedLevel(CVehicle* pVehicle) {
  12: 	plugin::Call<0x41BFA0, CVehicle*>(pVehicle);
  13  }

  16  void CCarAI::CarHasReasonToStop(CVehicle* pVehicle) {
  17: 	plugin::Call<0x41C050, CVehicle*>(pVehicle);
  18  }

  21  void CCarAI::AddPoliceCarOccupants(CVehicle* pVehicle, bool arg2) {
  22: 	plugin::Call<0x41C070, CVehicle*, bool>(pVehicle, arg2);
  23  }

  26  void CCarAI::AddAmbulanceOccupants(CVehicle* pVehicle) {
  27: 	plugin::Call<0x41C4A0, CVehicle*>(pVehicle);
  28  }

  31  void CCarAI::AddFiretruckOccupants(CVehicle* pVehicle) {
  32: 	plugin::Call<0x41C600, CVehicle*>(pVehicle);
  33  }

  36  void CCarAI::TellOccupantsToLeaveCar(CVehicle* pVehicle) {
  37: 	plugin::Call<0x41C760, CVehicle*>(pVehicle);
  38  }

  41  void CCarAI::TellCarToFollowOtherCar(CVehicle* pVehicle1, CVehicle* pVehicle2, float radius) {
  42: 	plugin::Call<0x41C960, CVehicle*, CVehicle*, float>(pVehicle1, pVehicle2, radius);
  43  }

  46  char CCarAI::FindPoliceBikeMissionForWantedLevel() {
  47: 	return plugin::CallAndReturn<char, 0x41CA40>();
  48  }

  51  char CCarAI::FindPoliceBoatMissionForWantedLevel() {
  52: 	return plugin::CallAndReturn<char, 0x41CA50>();
  53  }

  56  int CCarAI::FindPoliceCarSpeedForWantedLevel(CVehicle* pVehicle) {
  57: 	return plugin::CallAndReturn<int, 0x41CAA0, CVehicle*>(pVehicle);
  58  }

  61  float CCarAI::GetCarToGoToCoors(CVehicle* pVehicle1, CVector* pVector, int drivingStyle, bool bSpeedLimit20) {
  62: 	return plugin::CallAndReturn<float, 0x41CE30, CVehicle*, CVector*, int, bool>(pVehicle1, pVector, drivingStyle, bSpeedLimit20);
  63  }

  66  float CCarAI::GetCarToParkAtCoors(CVehicle* pVehicle, CVector* pVector) {
  67: 	return plugin::CallAndReturn<float, 0x41D350, CVehicle*, CVector*>(pVehicle, pVector);
  68  }

  71  void CCarAI::MellowOutChaseSpeed(CVehicle* pVehicle) {
  72: 	plugin::Call<0x41D3D0, CVehicle*>(pVehicle);
  73  }

  76  void CCarAI::MakeWayForCarWithSiren(CVehicle* pVehicle) {
  77: 	plugin::Call<0x41D660, CVehicle*>(pVehicle);
  78  }

  81  void CCarAI::UpdateCarAI(CVehicle* pVehicle) {
  82: 	plugin::Call<0x41DA30, CVehicle*>(pVehicle);
  83  }

  86  char CCarAI::FindPoliceCarMissionForWantedLevel() {
  87: 	return plugin::CallAndReturn<char, 0x41C9D0>();
  88  }

plugin_sa\game_sa\CCarCtrl.cpp:
    9  int CCarCtrl::ChooseBoatModel() {
   10: 	return plugin::CallAndReturn<int, 0x421970>();
   11  }

   14  int CCarCtrl::ChooseCarModelToLoad(int arg1) {
   15: 	return plugin::CallAndReturn<int, 0x421900, int>(arg1);
   16  }

   19  int CCarCtrl::ChooseGangCarModel(int arg1) {
   20: 	return plugin::CallAndReturn<int, 0x421A40, int>(arg1);
   21  }

   24  int CCarCtrl::ChooseModel(int* arg1) {
   25: 	return plugin::CallAndReturn<int, 0x424CE0, int*>(arg1);
   26  }

   29  int CCarCtrl::ChoosePoliceCarModel(unsigned int arg0) {
   30: 	return plugin::CallAndReturn<int, 0x421980, unsigned int>(arg0);
   31  }

   34  void CCarCtrl::ClearInterestingVehicleList() {
   35: 	plugin::Call<0x423F00>();
   36  }

   39  void CCarCtrl::ClipTargetOrientationToLink(CVehicle* pVehicle, CCarPathLinkAddress arg2, char arg3, float* arg4, float arg5, float arg6) {
   40: 	plugin::Call<0x422760, CVehicle*, CCarPathLinkAddress, char, float*, float, float>(pVehicle, arg2, arg3, arg4, arg5, arg6);
   41  }

   44  CVehicle* CCarCtrl::CreateCarForScript(int modelid, CVector posn, unsigned char MissionCleanUpFlag) {
   45: 	return plugin::CallAndReturn<CVehicle*, 0x431F80, int, CVector, unsigned char>(modelid, posn, MissionCleanUpFlag);
   46  }

   49  bool CCarCtrl::CreateConvoy(CVehicle* pVehicle, int arg2) {
   50: 	return plugin::CallAndReturn<bool, 0x42C740, CVehicle*, int>(pVehicle, arg2);
   51  }

   54  bool CCarCtrl::CreatePoliceChase(CVehicle* pVehicle, int arg2, CNodeAddress NodeAddress) {
   55: 	return plugin::CallAndReturn<bool, 0x42C2B0, CVehicle*, int, CNodeAddress>(pVehicle, arg2, NodeAddress);
   56  }

   59  bool CCarCtrl::DealWithBend_Racing(CVehicle* pVehicle, CCarPathLinkAddress LinkAddress1, CCarPathLinkAddress LinkAddress2, CCarPathLinkAddress LinkAddress3, CCarPathLinkAddress LinkAddress4, char arg6, char arg7, char arg8, char arg9, float arg10, float* arg11, float* arg12, float* arg13, float* arg14, CVector* pVector) {
   60: 	return plugin::CallAndReturn<bool, 0x428040, CVehicle*, CCarPathLinkAddress, CCarPathLinkAddress, CCarPathLinkAddress, CCarPathLinkAddress, char, char, char, char, float, float*, float*, float*, float*, CVector*>(pVehicle, LinkAddress1, LinkAddress2, LinkAddress3, LinkAddress4, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, pVector);
   61  }

   64  void CCarCtrl::DragCarToPoint(CVehicle* pVehicle, CVector* pVector) {
   65: 	plugin::Call<0x42EC90, CVehicle*, CVector*>(pVehicle, pVector);
   66  }

   69  float CCarCtrl::FindAngleToWeaveThroughTraffic(CVehicle* pVehicle, CPhysical* pPhysical, float arg3, float arg4, float arg5) {
   70: 	return plugin::CallAndReturn<float, 0x4325C0, CVehicle*, CPhysical*, float, float, float>(pVehicle, pPhysical, arg3, arg4, arg5);
   71  }

   74  void CCarCtrl::FindIntersection2Lines(float arg1, float arg2, float arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float* arg9, float* arg10) {
   75: 	plugin::Call<0x4226F0, float, float, float, float, float, float, float, float, float*, float*>(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
   76  }

   79  void CCarCtrl::FindLinksToGoWithTheseNodes(CVehicle* pVehicle) {
   80: 	plugin::Call<0x42B470, CVehicle*>(pVehicle);
   81  }

   84  float CCarCtrl::FindMaximumSpeedForThisCarInTraffic(CVehicle* pVehicle) {
   85: 	return plugin::CallAndReturn<float, 0x434400, CVehicle*>(pVehicle);
   86  }

   89  void CCarCtrl::FindNodesThisCarIsNearestTo(CVehicle* pVehicle, CNodeAddress& NodeAddress1, CNodeAddress& NodeAddress2) {
   90: 	plugin::Call<0x42BD20, CVehicle*, CNodeAddress&, CNodeAddress&>(pVehicle, NodeAddress1, NodeAddress2);
   91  }

   94  char CCarCtrl::FindPathDirection(CNodeAddress NodeAddress1, CNodeAddress NodeAddress2, CNodeAddress NodeAddress3, bool* arg4) {
   95: 	return plugin::CallAndReturn<char, 0x422090, CNodeAddress, CNodeAddress, CNodeAddress, bool*>(NodeAddress1, NodeAddress2, NodeAddress3, arg4);
   96  }

   99  float CCarCtrl::FindPercDependingOnDistToLink(CVehicle* pVehicle, CCarPathLinkAddress LinkAddress) {
  100: 	return plugin::CallAndReturn<float, 0x422620, CVehicle*, CCarPathLinkAddress>(pVehicle, LinkAddress);
  101  }

  104  int CCarCtrl::FindSequenceElement(int arg1) {
  105: 	return plugin::CallAndReturn<int, 0x421770, int>(arg1);
  106  }

  109  float CCarCtrl::FindSpeedMultiplier(float arg1, float arg2, float arg3, float arg4) {
  110: 	return plugin::CallAndReturn<float, 0x4224E0, float, float, float, float>(arg1, arg2, arg3, arg4);
  111  }

  114  float CCarCtrl::FindSpeedMultiplierWithSpeedFromNodes(char arg1) {
  115: 	return plugin::CallAndReturn<float, 0x424130, char>(arg1);
  116  }

  119  void CCarCtrl::FireHeliRocketsAtTarget(CAutomobile* pEntityLauncher, CEntity* pEntity) {
  120: 	plugin::Call<0x42B270, CAutomobile*, CEntity*>(pEntityLauncher, pEntity);
  121  }

  124  void CCarCtrl::FlyAIHeliInCertainDirection(CHeli* pHeli, float arg2, float arg3, bool arg4) {
  125: 	plugin::Call<0x429A70, CHeli*, float, float, bool>(pHeli, arg2, arg3, arg4);
  126  }

  129  void CCarCtrl::FlyAIHeliToTarget_FixedOrientation(CHeli* pHeli, float Orientation, CVector posn) {
  130: 	plugin::Call<0x423940, CHeli*, float, CVector>(pHeli, Orientation, posn);
  131  }

  134  void CCarCtrl::FlyAIPlaneInCertainDirection(CPlane* pPlane) {
  135: 	plugin::Call<0x423000, CPlane*>(pPlane);
  136  }

  139  bool CCarCtrl::GenerateCarCreationCoors2(CVector posn, float radius, float arg3, float arg4, bool arg5, float arg6, float arg7, CVector* pOrigin, CNodeAddress* pNodeAddress1, CNodeAddress* pNodeAddress12, float* arg11, bool arg12, bool arg13) {
  140: 	return plugin::CallAndReturn<bool, 0x424210, CVector, float, float, float, bool, float, float, CVector*, CNodeAddress*, CNodeAddress*, float*, bool, bool>(posn, radius, arg3, arg4, arg5, arg6, arg7, pOrigin, pNodeAddress1, pNodeAddress12, arg11, arg12, arg13);
  141  }

  144  void CCarCtrl::GenerateEmergencyServicesCar() {
  145: 	plugin::Call<0x42F9C0>();
  146  }

  149  bool CCarCtrl::GenerateOneEmergencyServicesCar(unsigned int modelID, CVector posn) {
  150: 	return plugin::CallAndReturn<bool, 0x42B7D0, unsigned int, CVector>(modelID, posn);
  151  }

  154  void CCarCtrl::GenerateOneRandomCar() {
  155: 	plugin::Call<0x430050>();
  156  }

  159  void CCarCtrl::GenerateRandomCars() {
  160: 	plugin::Call<0x4341C0>();
  161  }

  164  void CCarCtrl::GetAIHeliToAttackPlayer(CAutomobile* pAutomobile) {
  165: 	plugin::Call<0x42F3C0, CAutomobile*>(pAutomobile);
  166  }

  169  void CCarCtrl::GetAIHeliToFlyInDirection(CAutomobile* pAutomobile) {
  170: 	plugin::Call<0x42A730, CAutomobile*>(pAutomobile);
  171  }

  174  void CCarCtrl::GetAIPlaneToAttackPlayer(CAutomobile* pAutomobile) {
  175: 	plugin::Call<0x429780, CAutomobile*>(pAutomobile);
  176  }

  179  void CCarCtrl::GetAIPlaneToDoDogFight(CAutomobile* pAutomobile) {
  180: 	plugin::Call<0x429890, CAutomobile*>(pAutomobile);
  181  }

  184  void CCarCtrl::GetAIPlaneToDoDogFightAgainstPlayer(CAutomobile* pAutomobile) {
  185: 	plugin::Call<0x42F370, CAutomobile*>(pAutomobile);
  186  }

  189  CVehicle* CCarCtrl::GetNewVehicleDependingOnCarModel(int modelID, unsigned char createdBy) {
  190: 	return plugin::CallAndReturn<CVehicle*, 0x421440, int, unsigned char>(modelID, createdBy);
  191  }

  194  void CCarCtrl::Init() {
  195: 	plugin::Call<0x4212E0>();
  196  }

  199  void CCarCtrl::InitSequence(int SequenceElements) {
  200: 	plugin::Call<0x421740, int>(SequenceElements);
  201  }

  204  bool CCarCtrl::IsAnyoneParking() {
  205: 	return plugin::CallAndReturn<bool, 0x42C250>();
  206  }

  209  bool CCarCtrl::IsThisAnAppropriateNode(CVehicle* pVehicle, CNodeAddress NodeAddress1, CNodeAddress NodeAddress2, CNodeAddress NodeAddress3, bool arg5) {
  210: 	return plugin::CallAndReturn<bool, 0x42DAB0, CVehicle*, CNodeAddress, CNodeAddress, CNodeAddress, bool>(pVehicle, NodeAddress1, NodeAddress2, NodeAddress3, arg5);
  211  }

  214  bool CCarCtrl::IsThisVehicleInteresting(CVehicle* pVehicle) {
  215: 	return plugin::CallAndReturn<bool, 0x423EA0, CVehicle*>(pVehicle);
  216  }

  219  void CCarCtrl::JoinCarWithRoadAccordingToMission(CVehicle* pVehicle) {
  220: 	plugin::Call<0x432CB0, CVehicle*>(pVehicle);
  221  }

  224  void CCarCtrl::JoinCarWithRoadSystem(CVehicle* pVehicle) {
  225: 	plugin::Call<0x42F5A0, CVehicle*>(pVehicle);
  226  }

  229  bool CCarCtrl::JoinCarWithRoadSystemGotoCoors(CVehicle* pVehicle, CVector const& posn, bool unused, bool bIsBoat) {
  230: 	return plugin::CallAndReturn<bool, 0x42F870, CVehicle*, CVector const&, bool, bool>(pVehicle, posn, unused, bIsBoat);
  231  }

  234  bool CCarCtrl::PickNextNodeAccordingStrategy(CVehicle* pVehicle) {
  235: 	return plugin::CallAndReturn<bool, 0x432B10, CVehicle*>(pVehicle);
  236  }

  239  void CCarCtrl::PickNextNodeRandomly(CVehicle* pVehicle) {
  240: 	plugin::Call<0x42DE80, CVehicle*>(pVehicle);
  241  }

  244  bool CCarCtrl::PickNextNodeToChaseCar(CVehicle* pVehicle, float x_dest, float y_dest, float z_dest) {
  245: 	return plugin::CallAndReturn<bool, 0x426EF0, CVehicle*, float, float, float>(pVehicle, x_dest, y_dest, z_dest);
  246  }

  249  bool CCarCtrl::PickNextNodeToFollowPath(CVehicle* pVehicle) {
  250: 	return plugin::CallAndReturn<bool, 0x427740, CVehicle*>(pVehicle);
  251  }

  254  void CCarCtrl::PossiblyFireHSMissile(CVehicle* pEntityLauncher, CEntity* pTargetEntity) {
  255: 	plugin::Call<0x429600, CVehicle*, CEntity*>(pEntityLauncher, pTargetEntity);
  256  }

  259  void CCarCtrl::PossiblyRemoveVehicle(CVehicle* pVehicle) {
  260: 	plugin::Call<0x424F80, CVehicle*>(pVehicle);
  261  }

  264  void CCarCtrl::PruneVehiclesOfInterest() {
  265: 	plugin::Call<0x423F10>();
  266  }

  269  void CCarCtrl::ReInit() {
  270: 	plugin::Call<0x4213B0>();
  271  }

  274  void CCarCtrl::ReconsiderRoute(CVehicle* pVehicle) {
  275: 	plugin::Call<0x42FC40, CVehicle*>(pVehicle);
  276  }

  279  void CCarCtrl::RegisterVehicleOfInterest(CVehicle* pVehicle) {
  280: 	plugin::Call<0x423DE0, CVehicle*>(pVehicle);
  281  }

  284  void CCarCtrl::RemoveCarsIfThePoolGetsFull() {
  285: 	plugin::Call<0x4322B0>();
  286  }

  289  void CCarCtrl::RemoveDistantCars() {
  290: 	plugin::Call<0x42CD10>();
  291  }

  294  void CCarCtrl::RemoveFromInterestingVehicleList(CVehicle* pVehicle) {
  295: 	plugin::Call<0x423ED0, CVehicle*>(pVehicle);
  296  }

  299  void CCarCtrl::ScanForPedDanger(CVehicle* pVehicle) {
  300: 	plugin::Call<0x42CE40, CVehicle*>(pVehicle);
  301  }

  304  bool CCarCtrl::ScriptGenerateOneEmergencyServicesCar(unsigned int modelID, CVector posn) {
  305: 	return plugin::CallAndReturn<bool, 0x42FBC0, unsigned int, CVector>(modelID, posn);
  306  }

  309  void CCarCtrl::SetCoordsOfScriptCar(CVehicle* pVehicle, float x, float y, float z, unsigned char arg5, unsigned char arg6) {
  310: 	plugin::Call<0x4342A0, CVehicle*, float, float, float, unsigned char, unsigned char>(pVehicle, x, y, z, arg5, arg6);
  311  }

  314  void CCarCtrl::SetUpDriverAndPassengersForVehicle(CVehicle* pVehicle, int arg2, int arg3, bool arg4, bool arg5, int passengersNum) {
  315: 	plugin::Call<0x4217C0, CVehicle*, int, int, bool, bool, int>(pVehicle, arg2, arg3, arg4, arg5, passengersNum);
  316  }

  319  void CCarCtrl::SlowCarDownForCarsSectorList(CPtrList& PtrList, CVehicle* pVehicle, float arg3, float arg4, float arg5, float arg6, float* arg7, float arg8) {
  320: 	plugin::Call<0x432420, CPtrList&, CVehicle*, float, float, float, float, float*, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
  321  }

  324  void CCarCtrl::SlowCarDownForObject(CEntity* pEntity, CVehicle* pVehicle, float* arg3, float arg4) {
  325: 	plugin::Call<0x426220, CEntity*, CVehicle*, float*, float>(pEntity, pVehicle, arg3, arg4);
  326  }

  329  void CCarCtrl::SlowCarDownForObjectsSectorList(CPtrList& PtrList, CVehicle* pVehicle, float arg3, float arg4, float arg5, float arg6, float* arg7, float arg8) {
  330: 	plugin::Call<0x42D4F0, CPtrList&, CVehicle*, float, float, float, float, float*, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
  331  }

  334  void CCarCtrl::SlowCarDownForOtherCar(CEntity* pCar1, CVehicle* pCar2, float* arg3, float arg4) {
  335: 	plugin::Call<0x42D0E0, CEntity*, CVehicle*, float*, float>(pCar1, pCar2, arg3, arg4);
  336  }

  339  void CCarCtrl::SlowCarDownForPedsSectorList(CPtrList& PtrList, CVehicle* pVehicle, float arg3, float arg4, float arg5, float arg6, float* arg7, float arg8) {
  340: 	plugin::Call<0x425440, CPtrList&, CVehicle*, float, float, float, float, float*, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
  341  }

  344  void CCarCtrl::SlowCarOnRailsDownForTrafficAndLights(CVehicle* pVehicle) {
  345: 	plugin::Call<0x434790, CVehicle*>(pVehicle);
  346  }

  349  void CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  350: 	plugin::Call<0x428DE0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  351  }

  354  void CCarCtrl::SteerAIBoatWithPhysicsCirclingPlayer(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  355: 	plugin::Call<0x429090, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  356  }

  359  void CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget(CVehicle* pVehicle, float arg2, float arg3, float* arg4, float* arg5, float* arg6) {
  360: 	plugin::Call<0x428BE0, CVehicle*, float, float, float*, float*, float*>(pVehicle, arg2, arg3, arg4, arg5, arg6);
  361  }

  364  void CCarCtrl::SteerAICarBlockingPlayerForwardAndBack(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  365: 	plugin::Call<0x422B20, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  366  }

  369  void CCarCtrl::SteerAICarParkParallel(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  370: 	plugin::Call<0x433BA0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  371  }

  374  void CCarCtrl::SteerAICarParkPerpendicular(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  375: 	plugin::Call<0x433EA0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  376  }

  379  void CCarCtrl::SteerAICarTowardsPointInEscort(CVehicle* pVehicle1, CVehicle* pVehicle2, float arg3, float arg4, float* arg5, float* arg6, float* arg7, bool* arg8) {
  380: 	plugin::Call<0x4336D0, CVehicle*, CVehicle*, float, float, float*, float*, float*, bool*>(pVehicle1, pVehicle2, arg3, arg4, arg5, arg6, arg7, arg8);
  381  }

  384  void CCarCtrl::SteerAICarWithPhysics(CVehicle* pVehicle) {
  385: 	plugin::Call<0x437C20, CVehicle*>(pVehicle);
  386  }

  389  void CCarCtrl::SteerAICarWithPhysicsFollowPath(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  390: 	plugin::Call<0x434900, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  391  }

  394  void CCarCtrl::SteerAICarWithPhysicsFollowPath_Racing(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  395: 	plugin::Call<0x435830, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  396  }

  399  void CCarCtrl::SteerAICarWithPhysicsFollowPreRecordedPath(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  400: 	plugin::Call<0x432DD0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  401  }

  404  void CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(CVehicle* pVehicle, CPhysical* pTarget, float arg3, float arg4, float* arg5, float* arg6, float* arg7, bool* arg8) {
  405: 	plugin::Call<0x433280, CVehicle*, CPhysical*, float, float, float*, float*, float*, bool*>(pVehicle, pTarget, arg3, arg4, arg5, arg6, arg7, arg8);
  406  }

  409  void CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget(CVehicle* pVehicle, CEntity* Unusued, float arg3, float arg4, float arg5, float arg6, float* arg7, float* arg8, float* arg9, bool* arg10) {
  410: 	plugin::Call<0x4335E0, CVehicle*, CEntity*, float, float, float, float, float*, float*, float*, bool*>(pVehicle, Unusued, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
  411  }

  414  void CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop(CVehicle* pVehicle, float x, float y, float arg4, float arg5, float* arg6, float* arg7, float* arg8, bool* arg9) {
  415: 	plugin::Call<0x428990, CVehicle*, float, float, float, float, float*, float*, float*, bool*>(pVehicle, x, y, arg4, arg5, arg6, arg7, arg8, arg9);
  416  }

  419  void CCarCtrl::SteerAICarWithPhysics_OnlyMission(CVehicle* pVehicle, float* arg2, float* arg3, float* arg4, bool* arg5) {
  420: 	plugin::Call<0x436A90, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
  421  }

  424  void CCarCtrl::SteerAIHeliAsPoliceHeli(CAutomobile* pAutomobile) {
  425: 	plugin::Call<0x42AAD0, CAutomobile*>(pAutomobile);
  426  }

  429  void CCarCtrl::SteerAIHeliFlyingAwayFromPlayer(CAutomobile* pAutomobile) {
  430: 	plugin::Call<0x42ACB0, CAutomobile*>(pAutomobile);
  431  }

  434  void CCarCtrl::SteerAIHeliToCrashAndBurn(CAutomobile* pAutomobile) {
  435: 	plugin::Call<0x4238E0, CAutomobile*>(pAutomobile);
  436  }

  439  void CCarCtrl::SteerAIHeliToFollowEntity(CAutomobile* pAutomobile) {
  440: 	plugin::Call<0x42A750, CAutomobile*>(pAutomobile);
  441  }

  444  void CCarCtrl::SteerAIHeliToKeepEntityInView(CAutomobile* pAutomobile) {
  445: 	plugin::Call<0x42AEB0, CAutomobile*>(pAutomobile);
  446  }

  449  void CCarCtrl::SteerAIHeliToLand(CAutomobile* pAutomobile) {
  450: 	plugin::Call<0x42AD30, CAutomobile*>(pAutomobile);
  451  }

  454  void CCarCtrl::SteerAIHeliTowardsTargetCoors(CAutomobile* pAutomobile) {
  455: 	plugin::Call<0x42A630, CAutomobile*>(pAutomobile);
  456  }

  459  void CCarCtrl::SteerAIPlaneToCrashAndBurn(CAutomobile* pAutomobile) {
  460: 	plugin::Call<0x423880, CAutomobile*>(pAutomobile);
  461  }

  464  void CCarCtrl::SteerAIPlaneToFollowEntity(CAutomobile* pAutomobile) {
  465: 	plugin::Call<0x4237F0, CAutomobile*>(pAutomobile);
  466  }

  469  void CCarCtrl::SteerAIPlaneTowardsTargetCoors(CAutomobile* pAutomobile) {
  470: 	plugin::Call<0x423790, CAutomobile*>(pAutomobile);
  471  }

  474  bool CCarCtrl::StopCarIfNodesAreInvalid(CVehicle* pVehicle) {
  475: 	return plugin::CallAndReturn<bool, 0x422590, CVehicle*>(pVehicle);
  476  }

  479  void CCarCtrl::SwitchBetweenPhysicsAndGhost(CVehicle* pVehicle) {
  480: 	plugin::Call<0x4222A0, CVehicle*>(pVehicle);
  481  }

  484  void CCarCtrl::SwitchVehicleToRealPhysics(CVehicle* pVehicle) {
  485: 	plugin::Call<0x423FC0, CVehicle*>(pVehicle);
  486  }

  489  float CCarCtrl::TestCollisionBetween2MovingRects(CVehicle* pVehicle1, CVehicle* pVehicle2, float arg3, float arg4, CVector* pVector1, CVector* pVector2) {
  490: 	return plugin::CallAndReturn<float, 0x425B30, CVehicle*, CVehicle*, float, float, CVector*, CVector*>(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2);
  491  }

  494  float CCarCtrl::TestCollisionBetween2MovingRects_OnlyFrontBumper(CVehicle* pVehicle1, CVehicle* pVehicle2, float arg3, float arg4, CVector* pVector1, CVector* pVector2) {
  495: 	return plugin::CallAndReturn<float, 0x425F70, CVehicle*, CVehicle*, float, float, CVector*, CVector*>(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2);
  496  }

  499  void CCarCtrl::TestWhetherToFirePlaneGuns(CVehicle* pVehicle, CEntity* pTarget) {
  500: 	plugin::Call<0x429520, CVehicle*, CEntity*>(pVehicle, pTarget);
  501  }

  504  bool CCarCtrl::ThisVehicleShouldTryNotToTurn(CVehicle* pVehicle) {
  505: 	return plugin::CallAndReturn<bool, 0x421FE0, CVehicle*>(pVehicle);
  506  }

  509  void CCarCtrl::TriggerDogFightMoves(CVehicle* pVehicle1, CVehicle* pVehicle2) {
  510: 	plugin::Call<0x429300, CVehicle*, CVehicle*>(pVehicle1, pVehicle2);
  511  }

  514  void CCarCtrl::UpdateCarCount(CVehicle* pVehicle, unsigned char bDecrease) {
  515: 	plugin::Call<0x424000, CVehicle*, unsigned char>(pVehicle, bDecrease);
  516  }

  519  void CCarCtrl::UpdateCarOnRails(CVehicle* pVehicle) {
  520: 	plugin::Call<0x436540, CVehicle*>(pVehicle);
  521  }

  524  void CCarCtrl::WeaveForObject(CEntity* pEntity, CVehicle* pVehicle, float* arg3, float* arg4) {
  525: 	plugin::Call<0x426BC0, CEntity*, CVehicle*, float*, float*>(pEntity, pVehicle, arg3, arg4);
  526  }

  529  void CCarCtrl::WeaveForOtherCar(CEntity* pEntity, CVehicle* pVehicle, float* arg3, float* arg4) {
  530: 	plugin::Call<0x426350, CEntity*, CVehicle*, float*, float*>(pEntity, pVehicle, arg3, arg4);
  531  }

  534  void CCarCtrl::WeaveThroughCarsSectorList(CPtrList& PtrList, CVehicle* pVehicle, CPhysical* pPhysical, float arg4, float arg5, float arg6, float arg7, float* arg8, float* arg9) {
  535: 	plugin::Call<0x42D680, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9);
  536  }

  539  void CCarCtrl::WeaveThroughObjectsSectorList(CPtrList& PtrList, CVehicle* pVehicle, float arg3, float arg4, float arg5, float arg6, float* arg7, float* arg8) {
  540: 	plugin::Call<0x42D950, CPtrList&, CVehicle*, float, float, float, float, float*, float*>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
  541  }

  544  void CCarCtrl::WeaveThroughPedsSectorList(CPtrList& PtrList, CVehicle* pVehicle, CPhysical* pPhysical, float arg4, float arg5, float arg6, float arg7, float* arg8, float* arg9) {
  545: 	plugin::Call<0x42D7E0, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9);
  546  }

plugin_sa\game_sa\CCarEnterExit.cpp:
   24  void CCarEnterExit::AddInCarAnim(CVehicle const *vehicle, CPed *ped, bool bAsDriver) {
   25:     plugin::CallDynGlobal<CVehicle const *, CPed *, bool>(gaddrof(CCarEnterExit::AddInCarAnim), vehicle, ped, bAsDriver);
   26  }

   31  bool CCarEnterExit::CarHasDoorToClose(CVehicle const *vehicle, int doorId) {
   32:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasDoorToClose), vehicle, doorId);
   33  }

   38  bool CCarEnterExit::CarHasDoorToOpen(CVehicle const *vehicle, int doorID) {
   39:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasDoorToOpen), vehicle, doorID);
   40  }

   45  bool CCarEnterExit::CarHasOpenableDoor(CVehicle const *vehicle, int DoorID_UnusedArg, CPed const *ped) {
   46:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CPed const *>(gaddrof(CCarEnterExit::CarHasOpenableDoor), vehicle, DoorID_UnusedArg, ped);
   47  }

   52  bool CCarEnterExit::CarHasPartiallyOpenDoor(CVehicle const *vehicle, int doorID) {
   53:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasPartiallyOpenDoor), vehicle, doorID);
   54  }

   59  int CCarEnterExit::ComputeDoorFlag(CVehicle const *vehicle, int doorId, bool bCheckVehicleType) {
   60:     return plugin::CallAndReturnDynGlobal<int, CVehicle const *, int, bool>(gaddrof(CCarEnterExit::ComputeDoorFlag), vehicle, doorId, bCheckVehicleType);
   61  }

   66  int CCarEnterExit::ComputeOppositeDoorFlag(CVehicle const *vehicle, int doorId, bool bCheckVehicleType) {
   67:     return plugin::CallAndReturnDynGlobal<int, CVehicle const *, int, bool>(gaddrof(CCarEnterExit::ComputeOppositeDoorFlag), vehicle, doorId, bCheckVehicleType);
   68  }

   73  signed int CCarEnterExit::ComputePassengerIndexFromCarDoor(CVehicle const *vehicle, int doorID) {
   74:     return plugin::CallAndReturnDynGlobal<signed int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputePassengerIndexFromCarDoor), vehicle, doorID);
   75  }

   80  int CCarEnterExit::ComputeSlowJackedPed(CVehicle const *vehicle, int doorID) {
   81:     return plugin::CallAndReturnDynGlobal<int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputeSlowJackedPed), vehicle, doorID);
   82  }

   87  signed int CCarEnterExit::ComputeTargetDoorToEnterAsPassenger(CVehicle const *pVehicle, int nPassengerNum) {
   88:     return plugin::CallAndReturnDynGlobal<signed int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputeTargetDoorToEnterAsPassenger), pVehicle, nPassengerNum);
   89  }

   94  int CCarEnterExit::ComputeTargetDoorToExit(CVehicle const *pVehicle, CPed const *pPed) {
   95:     return plugin::CallAndReturnDynGlobal<int, CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::ComputeTargetDoorToExit), pVehicle, pPed);
   96  }

  101  bool CCarEnterExit::GetNearestCarDoor(CPed const *pPed, CVehicle const *pVehicle, CVector *outPos, int doorID) {
  102:     return plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, CVector *, int>(gaddrof(CCarEnterExit::GetNearestCarDoor), pPed, pVehicle, outPos, doorID);
  103  }

  108  bool CCarEnterExit::GetNearestCarPassengerDoor(CPed const *ped, CVehicle const *vehicle, CVector *outVec, int *doorId, bool flag1, bool flag2, bool flag3) {
  109:     return plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, CVector *, int *, bool, bool, bool>(gaddrof(CCarEnterExit::GetNearestCarPassengerDoor), ped, vehicle, outVec, doorId, flag1, flag2, flag3);
  110  }

  115  CVector *CCarEnterExit::GetPositionToOpenCarDoor(CVector *out, CVehicle const *vehicle, int doorId) {
  116:     return plugin::CallAndReturnDynGlobal<CVector *, CVector *, CVehicle const *, int>(gaddrof(CCarEnterExit::GetPositionToOpenCarDoor), out, vehicle, doorId);
  117  }

  122  bool CCarEnterExit::IsCarDoorInUse(CVehicle const *vehicle, int door1Id, int door2Id) {
  123:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, int>(gaddrof(CCarEnterExit::IsCarDoorInUse), vehicle, door1Id, door2Id);
  124  }

  129  bool CCarEnterExit::IsCarDoorReady(CVehicle const *vehicle, int doorID) {
  130:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::IsCarDoorReady), vehicle, doorID);
  131  }

  136  bool CCarEnterExit::IsCarQuickJackPossible(CVehicle const *vehicle, int doorID, CPed const *ped) {
  137:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CPed const *>(gaddrof(CCarEnterExit::IsCarQuickJackPossible), vehicle, doorID, ped);
  138  }

  143  bool CCarEnterExit::IsCarSlowJackRequired(CVehicle const *vehicle, int doorID) {
  144:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::IsCarSlowJackRequired), vehicle, doorID);
  145  }

  150  bool CCarEnterExit::IsClearToDriveAway(CVehicle const *outVehicle) {
  151:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *>(gaddrof(CCarEnterExit::IsClearToDriveAway), outVehicle);
  152  }

  157  bool CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(CPed const *ped, CVehicle *vehicle, CVector const *pos) {
  158:     return plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle *, CVector const *>(gaddrof(CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel), ped, vehicle, pos);
  159  }

  164  bool CCarEnterExit::IsPedHealthy(CPed *vehicle) {
  165:     return plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CCarEnterExit::IsPedHealthy), vehicle);
  166  }

  171  bool CCarEnterExit::IsPlayerToQuitCarEnter(CPed const *ped, CVehicle const *vehicle, int StartTime, CTask *task) {
  172:     return plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, int, CTask *>(gaddrof(CCarEnterExit::IsPlayerToQuitCarEnter), ped, vehicle, StartTime, task);
  173  }

  178  bool CCarEnterExit::IsRoomForPedToLeaveCar(CVehicle const *veh, int doorID, CVector *pos) {
  179:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CVector *>(gaddrof(CCarEnterExit::IsRoomForPedToLeaveCar), veh, doorID, pos);
  180  }

  185  bool CCarEnterExit::IsVehicleHealthy(CVehicle const *vehicle) {
  186:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *>(gaddrof(CCarEnterExit::IsVehicleHealthy), vehicle);
  187  }

  192  bool CCarEnterExit::IsVehicleStealable(CVehicle const *vehicle, CPed const *ped) {
  193:     return plugin::CallAndReturnDynGlobal<bool, CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::IsVehicleStealable), vehicle, ped);
  194  }

  199  void CCarEnterExit::MakeUndraggedDriverPedLeaveCar(CVehicle const *vehicle, CPed const *ped) {
  200:     plugin::CallDynGlobal<CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::MakeUndraggedDriverPedLeaveCar), vehicle, ped);
  201  }

  206  void CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar(CVehicle const *targetVehicle, CPed const *draggedPed, CPed const *ped) {
  207:     plugin::CallDynGlobal<CVehicle const *, CPed const *, CPed const *>(gaddrof(CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar), targetVehicle, draggedPed, ped);
  208  }

  213  void CCarEnterExit::QuitEnteringCar(CPed *ped, CVehicle *vehicle, int doorID, bool bCarWasBeingJacked) {
  214:     plugin::CallDynGlobal<CPed *, CVehicle *, int, bool>(gaddrof(CCarEnterExit::QuitEnteringCar), ped, vehicle, doorID, bCarWasBeingJacked);
  215  }

  220  void CCarEnterExit::RemoveCarSitAnim(CPed const *ped) {
  221:     plugin::CallDynGlobal<CPed const *>(gaddrof(CCarEnterExit::RemoveCarSitAnim), ped);
  222  }

  227  void CCarEnterExit::RemoveGetInAnims(CPed const *ped) {
  228:     plugin::CallDynGlobal<CPed const *>(gaddrof(CCarEnterExit::RemoveGetInAnims), ped);
  229  }

  241  void CCarEnterExit::SetPedInCarDirect(CPed *ped, CVehicle *vehicle, int seatNumber, bool bAsDriver) {
  242:     plugin::CallDynGlobal<CPed *, CVehicle *, int, bool>(gaddrof(CCarEnterExit::SetPedInCarDirect), ped, vehicle, seatNumber, bAsDriver);
  243  }

plugin_sa\game_sa\CCarGenerator.cpp:
  14  bool CCarGenerator::CheckForBlockage(int modelId) {
  15:     return plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *, int>(gaddrof(CCarGenerator::CheckForBlockage), this, modelId);
  16  }

  21  bool CCarGenerator::CheckIfWithinRangeOfAnyPlayers() {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckIfWithinRangeOfAnyPlayers), this);
  23  }

  28  void CCarGenerator::DoInternalProcessing() {
  29:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::DoInternalProcessing), this);
  30  }

  35  void CCarGenerator::Process() {
  36:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::Process), this);
  37  }

  42  void CCarGenerator::Setup(float x, float y, float z, float angle, int modelId, short color1, short color2, unsigned char bforceSpawn, unsigned char alarm_chances, unsigned char doorLock_chances, unsigned short minDelay, unsigned short maxDelay, unsigned char iplId, unsigned char bOwnedbyplayer) {
  43:     plugin::CallMethodDynGlobal<CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short, unsigned char, unsigned char>(gaddrof(CCarGenerator::Setup), this, x, y, z, angle, modelId, color1, color2, bforceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer);
  44  }

  49  void CCarGenerator::SwitchOff() {
  50:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOff), this);
  51  }

  56  void CCarGenerator::SwitchOn() {
  57:     plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOn), this);
  58  }

  63  unsigned int CCarGenerator::CalcNextGen() {
  64:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CCarGenerator::CalcNextGen));
  65  }

  70  CCarGenerator *CCarGenerator::Get(unsigned short index) {
  71:     return plugin::CallAndReturnDynGlobal<CCarGenerator *, unsigned short>(gaddrof(CCarGenerator::Get), index);
  72  }

plugin_sa\game_sa\CCarPathLink.cpp:
  14  float CCarPathLink::OneWayLaneOffset() {
  15:     return plugin::CallMethodAndReturnDynGlobal<float, CCarPathLink *>(gaddrof(CCarPathLink::OneWayLaneOffset), this);
  16  }

plugin_sa\game_sa\CCheat.cpp:
   21  void CCheat::AddToCheatString(char LastPressedKey) {
   22:     plugin::CallDynGlobal<char>(gaddrof(CCheat::AddToCheatString), LastPressedKey);
   23  }

  189  void CCheat::HandleSpecialCheats(int CheatID) {
  190:     plugin::CallDynGlobal<int>(gaddrof(CCheat::HandleSpecialCheats), CheatID);
  191  }

  427  CVehicle* CCheat::VehicleCheat(int vehicleModelId) {
  428:     return plugin::CallAndReturnDynGlobal<CVehicle*,int>(gaddrof(CCheat::VehicleCheat), vehicleModelId);
  429  }

  501  void CCheat::ResetCheats() {
  502:     plugin::Call<0x438450>();
  503  }

plugin_sa\game_sa\CCheckpoint.cpp:
  10  void CCheckpoint::Render() {
  11:     plugin::CallMethod<0x725C00, CCheckpoint *>(this);
  12  }

plugin_sa\game_sa\CCheckpoints.cpp:
  15  void CCheckpoints::DeleteCP(unsigned int id, unsigned short type) {
  16:     plugin::Call<0x722FC0, unsigned int, unsigned short>(id, type);
  17  }

  20  void CCheckpoints::Init() {
  21:     plugin::Call<0x722880>();
  22  }

  25  CCheckpoint* CCheckpoints::PlaceMarker(unsigned int id, unsigned short type, CVector& posn, CVector& direction, float size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, unsigned short pulsePeriod, float pulseFraction, short rotateRate) {
  26:     return plugin::CallAndReturn<CCheckpoint*, 0x722C40, unsigned int, unsigned short, CVector&, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, posn, direction, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);
  27  }

  30  void CCheckpoints::Render() {
  31:     plugin::Call<0x726060>();
  32  }

  35  void CCheckpoints::SetHeading(unsigned int id, float angle) {
  36:     plugin::Call<0x722970, unsigned int, float>(id, angle);
  37  }

  40  void CCheckpoints::Shutdown() {
  41:     plugin::Call<0x7228F0>();
  42  }

  45  void CCheckpoints::Update() {
  46:     plugin::Call<0x7229C0>();
  47  }

  50  void CCheckpoints::UpdatePos(unsigned int id, CVector& posn) {
  51:     plugin::Call<0x722900, unsigned int, CVector&>(id, posn);
  52  }

plugin_sa\game_sa\CClock.cpp:
  30  unsigned short CClock::GetGameClockMinutesUntil(unsigned char hours, unsigned char minutes) {
  31:     return plugin::CallAndReturnDynGlobal<unsigned short, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);
  32  }

  37  bool CClock::GetIsTimeInRange(unsigned char hourA, unsigned char hourB) {
  38:     return plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);
  39  }

  44  void CClock::Initialise(unsigned int milisecondsPerGameMinute) {
  45:     plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);
  46  }

  58  void CClock::OffsetClockByADay(unsigned int timeDirection) {
  59:     plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::OffsetClockByADay), timeDirection);
  60  }

  72  void CClock::SetGameClock(unsigned char hours, unsigned char minutes, unsigned char day) {
  73:     plugin::CallDynGlobal<unsigned char, unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes, day);
  74  }

plugin_sa\game_sa\CClothes.cpp:
  11  void CClothes::ConstructPedModel(unsigned int modelid, CPedClothesDesc& newclothes, CPedClothesDesc const* oldclothes, bool bCutscenePlayer) {
  12:     plugin::Call<0x5A81E0, unsigned int, CPedClothesDesc&, CPedClothesDesc const*, bool>(modelid, newclothes, oldclothes, bCutscenePlayer);
  13  }

  16  void CClothes::RequestMotionGroupAnims() {
  17:     plugin::Call<0x5A8120>();
  18  }

  21  void CClothes::RebuildPlayerIfNeeded(CPlayerPed* player) {
  22:     plugin::Call<0x5A8390, CPlayerPed*>(player);
  23  }

  26  void CClothes::RebuildPlayer(CPlayerPed* player, bool bIgnoreFatAndMuscle) {
  27:     plugin::Call<0x5A82C0, CPlayerPed*, bool>(player, bIgnoreFatAndMuscle);
  28  }

  31  void CClothes::RebuildCutscenePlayer(CPlayerPed* player, int modelid) {
  32:     plugin::Call<0x5A8270, CPlayerPed*, int>(player, modelid);
  33  }

  36  void CClothes::LoadClothesFile() {
  37:     plugin::Call<0x5A7B30>();
  38  }

  41  void CClothes::Init() {
  42:     plugin::Call<0x5A80D0>();
  43  }

  47      eClothesModelPart result;
  48:     plugin::CallAndReturn<eClothesModelPart, 0x5A7EA0, eClothesModelPart*, int>(&result, eClothesTexturePart);
  49      return result;

  53  int CClothes::GetPlayerMotionGroupToLoad() {
  54:     return plugin::CallAndReturn<int, 0x5A7FB0>();
  55  }

  59      eClothesTexturePart result;
  60:     plugin::CallAndReturn<eClothesTexturePart, 0x5A7F30, eClothesTexturePart*, int>(&result, eClothesModelPart);
  61      return result;

  65  int CClothes::GetDefaultPlayerMotionGroup() {
  66:     return plugin::CallAndReturn<int, 0x5A81B0>();
  67  }

plugin_sa\game_sa\CClothesBuilder.cpp:
   11  void CClothesBuilder::BlendTextures(RwTexture* texture1, RwTexture* texture2, RwTexture* texture3, float factorA, float factorB, float factorC, int arg7, RwTexture* texture4) {
   12:     plugin::Call<0x5A5BC0, RwTexture*, RwTexture*, RwTexture*, float, float, float, int, RwTexture*>(texture1, texture2, texture3, factorA, factorB, factorC, arg7, texture4);
   13  }

   16  void CClothesBuilder::BlendTextures(RwTexture* texture1, RwTexture* texture2, RwTexture* texture3, float factorA, float factorB, float factorC) {
   17:     plugin::Call<0x5A59C0, RwTexture*, RwTexture*, RwTexture*, float, float, float>(texture1, texture2, texture3, factorA, factorB, factorC);
   18  }

   21  void CClothesBuilder::BlendTextures(RwTexture* texture1, RwTexture* texture2, float arg3, float arg4) {
   22:     plugin::Call<0x5A5820, RwTexture*, RwTexture*, float, float>(texture1, texture2, arg3, arg4);
   23  }

   26  void CClothesBuilder::BuildBoneIndexConversionTable(unsigned char* arg1, RpHAnimHierarchy* arg2, int arg3) {
   27:     plugin::Call<0x5A56E0, unsigned char*, RpHAnimHierarchy*, int>(arg1, arg2, arg3);
   28  }

   31  void CClothesBuilder::ConstructGeometryAndSkinArrays(RpHAnimHierarchy* arg1, RpGeometry** arg2, RwMatrixWeights** arg3, unsigned int** arg4, unsigned int arg5, RpGeometry** arg6, RpMaterial** arg7) {
   32:     plugin::Call<0x5A6530, RpHAnimHierarchy*, RpGeometry**, RwMatrixWeights**, unsigned int**, unsigned int, RpGeometry**, RpMaterial**>(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
   33  }

   36  void CClothesBuilder::ConstructGeometryArray(RpGeometry** arg1, unsigned int* arg2, float arg3, float arg4, float arg5) {
   37:     plugin::Call<0x5A55A0, RpGeometry**, unsigned int*, float, float, float>(arg1, arg2, arg3, arg4, arg5);
   38  }

   41  void CClothesBuilder::ConstructTextures(RwTexDictionary* dict, unsigned int* hashes, float factorA, float factorB, float factorC) {
   42:     plugin::Call<0x5A6040, RwTexDictionary*, unsigned int*, float, float, float>(dict, hashes, factorA, factorB, factorC);
   43  }

   46  RwTexture* CClothesBuilder::CopyTexture(RwTexture* texture) {
   47:     return plugin::CallAndReturn<RwTexture*, 0x5A5730, RwTexture*>(texture);
   48  }

   51  RpClump* CClothesBuilder::CreateSkinnedClump(RpClump* clump, RwTexDictionary* dict, CPedClothesDesc& newclothes, CPedClothesDesc const* oldclothes, bool bCutscenePlayer) {
   52:     return plugin::CallAndReturn<RpClump*, 0x5A69D0, RpClump*, RwTexDictionary*, CPedClothesDesc&, CPedClothesDesc const*, bool>(clump, dict, newclothes, oldclothes, bCutscenePlayer);
   53  }

   56  void CClothesBuilder::DestroySkinArrays(RwMatrixWeights* arg1, unsigned int* arg2) {
   57:     plugin::Call<0x5A56C0, RwMatrixWeights*, unsigned int*>(arg1, arg2);
   58  }

   61  int CClothesBuilder::FindNearestColour(RwRGBA* color) {
   62:     return plugin::CallAndReturn<int, 0x5A5F40, RwRGBA*>(color);
   63  }

   66  void CClothesBuilder::InitPaletteOctTree(int numColors) {
   67:     plugin::Call<0x5A5EB0, int>(numColors);
   68  }

   71  void CClothesBuilder::LoadCdDirectory() {
   72:     plugin::Call<0x5A4190>();
   73  }

   76  void CClothesBuilder::PlaceTextureOnTopOfTexture(RwTexture* texture1, RwTexture* texture2) {
   77:     plugin::Call<0x5A57B0, RwTexture*, RwTexture*>(texture1, texture2);
   78  }

   81  void CClothesBuilder::PreprocessClothesDesc(CPedClothesDesc& arg1, bool arg2) {
   82:     plugin::Call<0x5A44C0, CPedClothesDesc&, bool>(arg1, arg2);
   83  }

   86  void CClothesBuilder::ReducePaletteSize(RwTexture* texture, int numColorsToReduce) {
   87:     plugin::Call<0x5A6870, RwTexture*, int>(texture, numColorsToReduce);
   88  }

   91  void CClothesBuilder::ReleaseGeometry(int numToRelease) {
   92:     plugin::Call<0x5A47B0, int>(numToRelease);
   93  }

   96  void CClothesBuilder::RequestGeometry(int modelid, unsigned int crc) {
   97:     plugin::CallMethod<0x5A41C0, CClothesBuilder *, int, unsigned int>(this, modelid, crc);
   98  }

  101  void CClothesBuilder::StoreBoneArray(RpClump* clump, int arg2) {
  102:     plugin::Call<0x5A48B0, RpClump*, int>(clump, arg2);
  103  }

  106  RpGeometry* CClothesBuilder::BlendGeometry(RpClump* clump, char const* arg2, char const* arg3, char const* arg4, float arg5, float arg6, float arg7) {
  107:     return plugin::CallAndReturn<RpGeometry*, 0x5A4940, RpClump*, char const*, char const*, char const*, float, float, float>(clump, arg2, arg3, arg4, arg5, arg6, arg7);
  108  }

  111  RpGeometry* CClothesBuilder::BlendGeometry(RpClump* clump, char const* arg2, char const* arg3, float arg4, float arg5) {
  112:     return plugin::CallAndReturn<RpGeometry*, 0x5A4F10, RpClump*, char const*, char const*, float, float>(clump, arg2, arg3, arg4, arg5);
  113  }

  116  RpGeometry* CClothesBuilder::CopyGeometry(RpClump* clump, char const* arg2, char const* arg3) {
  117:     return plugin::CallAndReturn<RpGeometry*, 0x5A5340, RpClump*, char const*, char const*>(clump, arg2, arg3);
  118  }

  121  void CClothesBuilder::ShutdownPaletteOctTree() {
  122:     plugin::Call<0x5A5EE0>();
  123  }

  126  void CClothesBuilder::ReducePaletteOctTree(int numColorsToReduce) {
  127:     plugin::Call<0x5A5EF0, int>(numColorsToReduce);
  128  }

  131  bool CClothesBuilder::AddColour(RwRGBA* color) {
  132:     return plugin::CallAndReturn<bool, 0x5A5F00, RwRGBA*>(color);
  133  }

  136  void CClothesBuilder::FillPalette(RwRGBA* color) {
  137:     plugin::Call<0x5A5F30, RwRGBA*>(color);
  138  }

plugin_sa\game_sa\CClouds.cpp:
   35  void CClouds::Shutdown() {
   36:     plugin::Call<0x712FA0>();
   37  }

   40  void CClouds::Update() {
   41:     plugin::Call<0x712FF0>();
   42  }

   45  void CClouds::SetUpOneSkyPoly(CVector vert1pos, CVector vert2pos, CVector vert3pos, CVector vert4pos, unsigned char topRed, unsigned char topGreen, unsigned char topBlue, unsigned char bottomRed, unsigned char bottomGreen, unsigned char bottomBlue) {
   46:     plugin::Call<0x713060, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char>(vert1pos, vert2pos, vert3pos, vert4pos, topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue);
   47  }

   50  void CClouds::VolumetricCloudsInit() {
   51:     plugin::Call<0x7131C0>();
   52  }

   55  int CClouds::VolumetricClouds_GetFirstFreeSlot() {
   56:     return plugin::CallAndReturn<int, 0x7135C0>();
   57  }

   60  void CClouds::VolumetricClouds_Delete(int vcSlotIndex) {
   61:     plugin::Call<0x7135F0, int>(vcSlotIndex);
   62  }

   65  float CClouds::VolumetricCloudsGetMaxDistance() {
   66:     return plugin::CallAndReturn<float, 0x713630>();
   67  }

   70  void CClouds::MovingFogInit() {
   71:     plugin::Call<0x713660>();
   72  }

   75  float CClouds::MovingFog_GetFXIntensity() {
   76:     return plugin::CallAndReturn<float, 0x7136D0>();
   77  }

   81      CVector result;
   82:     plugin::Call<0x7136E0, CVector*>(&result);
   83      return result;

   87  int CClouds::MovingFog_GetFirstFreeSlot() {
   88:     return plugin::CallAndReturn<int, 0x713710>();
   89  }

   92  void CClouds::MovingFog_Delete(int fogSlotIndex) {
   93:     plugin::Call<0x713730, int>(fogSlotIndex);
   94  }

   97  void CClouds::MovingFog_Create(CVector* posn) {
   98:     plugin::Call<0x713760, CVector*>(posn);
   99  }

  102  void CClouds::Init() {
  103:     plugin::Call<0x7138D0>();
  104  }

  107  void CClouds::Render() {
  108:     plugin::Call<0x713950>();
  109  }

  112  void CClouds::RenderSkyPolys() {
  113:     plugin::Call<0x714650>();
  114  }

  117  void CClouds::RenderBottomFromHeight() {
  118:     plugin::Call<0x7154B0>();
  119  }

  122  void CClouds::VolumetricClouds_Create(CVector* posn) {
  123:     plugin::Call<0x715F40, CVector*>(posn);
  124  }

  127  void CClouds::VolumetricCloudsRender() {
  128:     plugin::Call<0x716380>();
  129  }

  132  void CClouds::MovingFog_Update() {
  133:     plugin::Call<0x716B10>();
  134  }

  137  void CClouds::MovingFogRender() {
  138:     plugin::Call<0x716C90>();
  139  }

plugin_sa\game_sa\CClumpModelInfo.cpp:
  60  void CClumpModelInfo::SetFrameIds(RwObjectNameIdAssocation* data) {
  61:     plugin::CallMethod<0x4C5460, CClumpModelInfo *, RwObjectNameIdAssocation*>(this, data);
  62  }

plugin_sa\game_sa\CColAccel.cpp:
   9  bool CColAccel::IsCacheLoading() {
  10:     return plugin::CallAndReturn<bool, 0x5B2AC0>();
  11  }

plugin_sa\game_sa\CColDisk.cpp:
  10  void CColDisk::Set(float startRadius, CVector const& start, CVector const& end, float endRadius, unsigned char material, unsigned char pieceType, unsigned char lighting) {
  11:     plugin::CallMethod<0x40FD50, CColDisk *, float, CVector const&, CVector const&, float, unsigned char, unsigned char, unsigned char>(this, startRadius, start, end, endRadius, material, pieceType, lighting);
  12  }

plugin_sa\game_sa\CCollision.cpp:
   10  void CCollision::Update() {
   11:     plugin::Call<0x411E20>();
   12  }

   15  void CCollision::SortOutCollisionAfterLoad() {
   16:     plugin::Call<0x411E30>();
   17  }

   20  bool CCollision::TestSphereSphere(CColSphere const& sphere1, CColSphere const& sphere2) {
   21:     return plugin::CallAndReturn<bool, 0x411E70, CColSphere const&, CColSphere const&>(sphere1, sphere2);
   22  }

   25  void CalculateColPointInsideBox(CBox const& box, CVector const& point, CColPoint& colPoint) {
   26:     plugin::Call<0x411EC0, CBox const&, CVector const&, CColPoint&>(box, point, colPoint);
   27  }

   30  bool CCollision::TestSphereBox(CSphere const& sphere, CBox const& box) {
   31:     return plugin::CallAndReturn<bool, 0x4120C0, CSphere const&, CBox const&>(sphere, box);
   32  }

   35  bool CCollision::ProcessSphereBox(CColSphere const& sphere, CColBox const& box, CColPoint& colPoint, float& maxTouchDistance) {
   36:     return plugin::CallAndReturn<bool, 0x412130, CColSphere const&, CColBox const&, CColPoint&, float&>(sphere, box, colPoint, maxTouchDistance);
   37  }

   40  bool CCollision::PointInTriangle(CVector const& point, CVector const* triPoints) {
   41:     return plugin::CallAndReturn<bool, 0x412700, CVector const&, CVector const*>(point, triPoints);
   42  }

   45  float CCollision::DistToLineSqr(CVector const* lineStart, CVector const* lineEnd, CVector const* point) {
   46:     return plugin::CallAndReturn<float, 0x412850, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
   47  }

   50  float CCollision::DistToMathematicalLine(CVector const* lineStart, CVector const* lineEnd, CVector const* point) {
   51:     return plugin::CallAndReturn<float, 0x412970, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
   52  }

   55  float CCollision::DistToMathematicalLine2D(float lineStartX, float lineStartY, float lineEndX, float lineEndY, float pointX, float pointY) {
   56:     return plugin::CallAndReturn<float, 0x412A30, float, float, float, float, float, float>(lineStartX, lineStartY, lineEndX, lineEndY, pointX, pointY);
   57  }

   60  float CCollision::DistAlongLine2D(float lineX, float lineY, float lineDirX, float lineDirY, float pointX, float pointY) {
   61:     return plugin::CallAndReturn<float, 0x412A80, float, float, float, float, float, float>(lineX, lineY, lineDirX, lineDirY, pointX, pointY);
   62  }

   65  bool CCollision::ProcessLineSphere(CColLine const& line, CColSphere const& sphere, CColPoint& colPoint, float& depth) {
   66:     return plugin::CallAndReturn<bool, 0x412AA0, CColLine const&, CColSphere const&, CColPoint&, float&>(line, sphere, colPoint, depth);
   67  }

   70  bool CCollision::TestLineBox_DW(CColLine const& line, CBox const& box) {
   71:     return plugin::CallAndReturn<bool, 0x412C70, CColLine const&, CBox const&>(line, box);
   72  }

   75  bool CCollision::TestLineBox(CColLine const& line, CBox const& box) {
   76:     return plugin::CallAndReturn<bool, 0x413070, CColLine const&, CBox const&>(line, box);
   77  }

   80  bool CCollision::TestVerticalLineBox(CColLine const& line, CBox const& box) {
   81:     return plugin::CallAndReturn<bool, 0x413080, CColLine const&, CBox const&>(line, box);
   82  }

   85  bool CCollision::ProcessLineBox(CColLine const& line, CColBox const& box, CColPoint& colPoint, float& maxTouchDistance) {
   86:     return plugin::CallAndReturn<bool, 0x413100, CColLine const&, CColBox const&, CColPoint&, float&>(line, box, colPoint, maxTouchDistance);
   87  }

   90  bool CCollision::Test2DLineAgainst2DLine(float line1StartX, float line1StartY, float line1EndX, float line1EndY, float line2StartX, float line2StartY, float line2EndX, float line2EndY) {
   91:     return plugin::CallAndReturn<bool, 0x4138D0, float, float, float, float, float, float, float, float>(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY);
   92  }

   95  bool ProcessDiscCollision(CColPoint& colPoint1, CMatrix const& mat, CColDisk const& disk, CColPoint& colPoint2, bool& arg4, float& arg5, CColPoint& colPoint3) {
   96:     return plugin::CallAndReturn<bool, 0x413960, CColPoint&, CMatrix const&, CColDisk const&, CColPoint&, bool&, float&, CColPoint&>(colPoint1, mat, disk, colPoint2, arg4, arg5, colPoint3);
   97  }

  100  bool CCollision::TestLineTriangle(CColLine const& line, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane) {
  101:     return plugin::CallAndReturn<bool, 0x413AC0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(line, verts, tri, triPlane);
  102  }

  105  bool CCollision::ProcessLineTriangle(CColLine const& line, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane, CColPoint& colPoint, float& maxTouchDistance, CStoredCollPoly* collPoly) {
  106:     return plugin::CallAndReturn<bool, 0x4140F0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly*>(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly);
  107  }

  110  bool CCollision::ProcessVerticalLineTriangle(CColLine const& line, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane, CColPoint& colPoint, float& maxTouchDistance, CStoredCollPoly* collPoly) {
  111:     return plugin::CallAndReturn<bool, 0x4147E0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly*>(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly);
  112  }

  115  bool CCollision::IsStoredPolyStillValidVerticalLine(CVector const& lineOrigin, float lineDist, CColPoint& colPoint, CStoredCollPoly* collPoly) {
  116:     return plugin::CallAndReturn<bool, 0x414D70, CVector const&, float, CColPoint&, CStoredCollPoly*>(lineOrigin, lineDist, colPoint, collPoly);
  117  }

  120  void CCollision::GetBoundingBoxFromTwoSpheres(CColBox* bbox, CColSphere* sphere1, CColSphere* sphere2) {
  121:     plugin::Call<0x415230, CColBox*, CColSphere*, CColSphere*>(bbox, sphere1, sphere2);
  122  }

  125  bool CCollision::IsThisVehicleSittingOnMe(CVehicle* vehicle, CVehicle* vehicleOnMe) {
  126:     return plugin::CallAndReturn<bool, 0x4152C0, CVehicle*, CVehicle*>(vehicle, vehicleOnMe);
  127  }

  130  bool CCollision::CheckCameraCollisionPeds(int sectorX, int sectorY, CVector* pos, CVector* dir, float* arg4) {
  131:     return plugin::CallAndReturn<bool, 0x415320, int, int, CVector*, CVector*, float*>(sectorX, sectorY, pos, dir, arg4);
  132  }

  135  bool CCollision::CheckPeds(CVector* pos, CVector* dir, float* arg2) {
  136:     return plugin::CallAndReturn<bool, 0x4154A0, CVector*, CVector*, float*>(pos, dir, arg2);
  137  }

  140  void ResetMadeInvisibleObjects() {
  141:     plugin::Call<0x415540>();
  142  }

  145  bool CCollision::SphereCastVsBBox(CColSphere* sphere1, CColSphere* sphere2, CColBox* box) {
  146:     return plugin::CallAndReturn<bool, 0x415590, CColSphere*, CColSphere*, CColBox*>(sphere1, sphere2, box);
  147  }

  150  bool CCollision::RayPolyPOP(CVector* arg0, CVector* arg1, CColTriangle* arg2, CVector* arg3, CVector* arg4) {
  151:     return plugin::CallAndReturn<bool, 0x415620, CVector*, CVector*, CColTriangle*, CVector*, CVector*>(arg0, arg1, arg2, arg3, arg4);
  152  }

  155  int CCollision::GetPrincipleAxis(CVector* vec) {
  156:     return plugin::CallAndReturn<int, 0x4156D0, CVector*>(vec);
  157  }

  160  bool CCollision::PointInPoly(CVector* point, CColTriangle* tri, CVector* arg2, CVector* triVerts) {
  161:     return plugin::CallAndReturn<bool, 0x415730, CVector*, CColTriangle*, CVector*, CVector*>(point, tri, arg2, triVerts);
  162  }

  165  void CCollision::Closest3(CVector* arg0, CVector* arg1) {
  166:     plugin::Call<0x415950, CVector*, CVector*>(arg0, arg1);
  167  }

  170  float ClosestSquaredDistanceBetweenFiniteLines(CVector* line1Start, CVector* line1End, CVector* line2Start, CVector* line2End, float arg4) {
  171:     return plugin::CallAndReturn<float, 0x415A40, CVector*, CVector*, CVector*, CVector*, float>(line1Start, line1End, line2Start, line2End, arg4);
  172  }

  175  bool CCollision::SphereCastVersusVsPoly(CColSphere* sphere1, CColSphere* sphere2, CColTriangle* tri, CColTrianglePlane* triPlane, CompressedVector* verts) {
  176:     return plugin::CallAndReturn<bool, 0x415CF0, CColSphere*, CColSphere*, CColTriangle*, CColTrianglePlane*, CompressedVector*>(sphere1, sphere2, tri, triPlane, verts);
  177  }

  180  void CCollision::Init() {
  181:     plugin::Call<0x416260>();
  182  }

  185  void CCollision::Shutdown() {
  186:     plugin::Call<0x4162E0>();
  187  }

  190  void CCollision::CalculateTrianglePlanes(CCollisionData* colData) {
  191:     plugin::Call<0x416330, CCollisionData*>(colData);
  192  }

  195  void CCollision::RemoveTrianglePlanes(CCollisionData* colData) {
  196:     plugin::Call<0x416400, CCollisionData*>(colData);
  197  }

  200  bool CCollision::ProcessSphereSphere(CColSphere const& sphere1, CColSphere const& sphere2, CColPoint& colPoint, float& maxTouchDistance) {
  201:     return plugin::CallAndReturn<bool, 0x416450, CColSphere const&, CColSphere const&, CColPoint&, float&>(sphere1, sphere2, colPoint, maxTouchDistance);
  202  }

  205  bool CCollision::TestSphereTriangle(CColSphere const& sphere, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane) {
  206:     return plugin::CallAndReturn<bool, 0x4165B0, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(sphere, verts, tri, triPlane);
  207  }

  210  bool CCollision::ProcessSphereTriangle(CColSphere const& sphere, CompressedVector const* verts, CColTriangle const& tri, CColTrianglePlane const& triPlane, CColPoint& colPoint, float& maxTouchDistance) {
  211:     return plugin::CallAndReturn<bool, 0x416BA0, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(sphere, verts, tri, triPlane, colPoint, maxTouchDistance);
  212  }

  215  bool CCollision::TestLineSphere(CColLine const& line, CColSphere const& sphere) {
  216:     return plugin::CallAndReturn<bool, 0x417470, CColLine const&, CColSphere const&>(line, sphere);
  217  }

  220  float CCollision::DistToLine(CVector const* lineStart, CVector const* lineEnd, CVector const* point) {
  221:     return plugin::CallAndReturn<float, 0x417610, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
  222  }

  225  bool CCollision::TestLineOfSight(CColLine const& line, CMatrix const& transform, CColModel& colModel, bool doSeeThroughCheck, bool doShootThroughCheck) {
  226:     return plugin::CallAndReturn<bool, 0x417730, CColLine const&, CMatrix const&, CColModel&, bool, bool>(line, transform, colModel, doSeeThroughCheck, doShootThroughCheck);
  227  }

  230  bool CCollision::ProcessLineOfSight(CColLine const& line, CMatrix const& transform, CColModel& colModel, CColPoint& colPoint, float& maxTouchDistance, bool doSeeThroughCheck, bool doShootThroughCheck) {
  231:     return plugin::CallAndReturn<bool, 0x417950, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, bool>(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck);
  232  }

  235  bool CCollision::ProcessVerticalLine(CColLine const& line, CMatrix const& transform, CColModel& colModel, CColPoint& colPoint, float& maxTouchDistance, bool doSeeThroughCheck, bool doShootThroughCheck, CStoredCollPoly* collPoly) {
  236:     return plugin::CallAndReturn<bool, 0x417BF0, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, bool, CStoredCollPoly*>(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck, collPoly);
  237  }

  240  bool CCollision::SphereCastVsSphere(CColSphere* arg0, CColSphere* arg1, CColSphere* arg2) {
  241:     return plugin::CallAndReturn<bool, 0x417F20, CColSphere*, CColSphere*, CColSphere*>(arg0, arg1, arg2);
  242  }

  245  void CCollision::ClosestPointOnLine(CVector* arg0, CVector* arg1, CVector* arg2, CVector* arg3) {
  246:     plugin::Call<0x417FD0, CVector*, CVector*, CVector*, CVector*>(arg0, arg1, arg2, arg3);
  247  }

  250  void CCollision::ClosestPointsOnPoly(CColTriangle* arg0, CVector* arg1, CVector* arg2, CVector* arg3) {
  251:     plugin::Call<0x418100, CColTriangle*, CVector*, CVector*, CVector*>(arg0, arg1, arg2, arg3);
  252  }

  255  void CCollision::ClosestPointOnPoly(CColTriangle* arg0, CVector* arg1, CVector* arg2) {
  256:     plugin::Call<0x418150, CColTriangle*, CVector*, CVector*>(arg0, arg1, arg2);
  257  }

  260  bool CCollision::SphereCastVsCaches(CColSphere* sphere, CVector* arg1, int arg2, CColCacheEntry* arg3, int* arg4, CColCacheEntry* arg5) {
  261:     return plugin::CallAndReturn<bool, 0x4181B0, CColSphere*, CVector*, int, CColCacheEntry*, int*, CColCacheEntry*>(sphere, arg1, arg2, arg3, arg4, arg5);
  262  }

  265  void CCollision::CalculateTrianglePlanes(CColModel* colModel) {
  266:     plugin::Call<0x418580, CColModel*>(colModel);
  267  }

  270  void CCollision::RemoveTrianglePlanes(CColModel* colModel) {
  271:     plugin::Call<0x4185A0, CColModel*>(colModel);
  272  }

  275  int CCollision::ProcessColModels(CMatrix const& transform1, CColModel& colModel1, CMatrix const& transform2, CColModel& colModel2, CColPoint* colPoint1, CColPoint* colPoint2, float* maxTouchDistance, bool arg7) {
  276:     return plugin::CallAndReturn<int, 0x4185C0, CMatrix const&, CColModel&, CMatrix const&, CColModel&, CColPoint*, CColPoint*, float*, bool>(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance, arg7);
  277  }

  280  bool CCollision::SphereCastVsEntity(CColSphere* sphere1, CColSphere* sphere2, CEntity* entity) {
  281:     return plugin::CallAndReturn<bool, 0x419F00, CColSphere*, CColSphere*, CEntity*>(sphere1, sphere2, entity);
  282  }

  285  bool CCollision::SphereVsEntity(CColSphere* sphere, CEntity* entity) {
  286:     return plugin::CallAndReturn<bool, 0x41A5A0, CColSphere*, CEntity*>(sphere, entity);
  287  }

  290  bool CCollision::CheckCameraCollisionBuildings(int sectorX, int sectorY, CColBox* arg2, CColSphere* arg3, CColSphere* arg4, CColSphere* arg5) {
  291:     return plugin::CallAndReturn<bool, 0x41A820, int, int, CColBox*, CColSphere*, CColSphere*, CColSphere*>(sectorX, sectorY, arg2, arg3, arg4, arg5);
  292  }

  295  bool CCollision::CheckCameraCollisionVehicles(int sectorX, int sectorY, CColBox* arg2, CColSphere* arg3, CColSphere* arg4, CColSphere* arg5, CVector* arg6) {
  296:     return plugin::CallAndReturn<bool, 0x41A990, int, int, CColBox*, CColSphere*, CColSphere*, CColSphere*, CVector*>(sectorX, sectorY, arg2, arg3, arg4, arg5, arg6);
  297  }

  300  bool CCollision::CheckCameraCollisionObjects(int sectorX, int sectorY, CColBox* arg2, CColSphere* arg3, CColSphere* arg4, CColSphere* arg5) {
  301:     return plugin::CallAndReturn<bool, 0x41AB20, int, int, CColBox*, CColSphere*, CColSphere*, CColSphere*>(sectorX, sectorY, arg2, arg3, arg4, arg5);
  302  }

  305  bool CCollision::BuildCacheOfCameraCollision(CColSphere* sphere1, CColSphere* sphere2) {
  306:     return plugin::CallAndReturn<bool, 0x41AC40, CColSphere*, CColSphere*>(sphere1, sphere2);
  307  }

  310  bool CCollision::CameraConeCastVsWorldCollision(CColSphere* sphere1, CColSphere* sphere2, float* arg2, float arg3) {
  311:     return plugin::CallAndReturn<bool, 0x41B000, CColSphere*, CColSphere*, float*, float>(sphere1, sphere2, arg2, arg3);
  312  }

plugin_sa\game_sa\CCollisionData.cpp:
  10  CCollisionData::CCollisionData() {
  11:     plugin::CallMethod<0x40F030, CCollisionData *>(this);
  12  }

  15  void CCollisionData::RemoveCollisionVolumes() {
  16:     plugin::CallMethod<0x40F070, CCollisionData *>(this);
  17  }

  20  void CCollisionData::Copy(CCollisionData const& arg0) {
  21:     plugin::CallMethod<0x40F120, CCollisionData *, CCollisionData const&>(this, arg0);
  22  }

  25  void CCollisionData::CalculateTrianglePlanes() {
  26:     plugin::CallMethod<0x40F590, CCollisionData *>(this);
  27  }

  30  void CCollisionData::GetTrianglePoint(CVector& outVec, int vertId) {
  31:     plugin::CallMethod<0x40F5E0, CCollisionData *, CVector&, int>(this, outVec, vertId);
  32  }

  35  void CCollisionData::GetShadTrianglePoint(CVector& outVec, int vertId) {
  36:     plugin::CallMethod<0x40F640, CCollisionData *, CVector&, int>(this, outVec, vertId);
  37  }

  40  void CCollisionData::RemoveTrianglePlanes() {
  41:     plugin::CallMethod<0x40F6A0, CCollisionData *>(this);
  42  }

  45  void CCollisionData::SetLinkPtr(CLink<CCollisionData*> *link) {
  46:     plugin::CallMethod<0x40F6C0, CCollisionData *, CLink<CCollisionData*> *>(this, link);
  47  }

  50  CLink<CCollisionData*> *CCollisionData::GetLinkPtr() {
  51:     return plugin::CallMethodAndReturn<CLink<CCollisionData*> *, 0x40F6E0, CCollisionData *>(this);
  52  }

plugin_sa\game_sa\CColModel.cpp:
  10  CColModel::CColModel() : m_boundBox(plugin::dummy) {
  11:     plugin::CallMethod<0x40FB60, CColModel *>(this);
  12  }

  15  CColModel::~CColModel() {
  16:     plugin::CallMethod<0x40F700, CColModel *>(this);
  17  }

  20  void CColModel::MakeMultipleAlloc() {
  21:     plugin::CallMethod<0x40F740, CColModel *>(this);
  22  }

  25  CColModel& CColModel::operator=(CColModel const& colModel) {
  26:     return plugin::CallMethodAndReturn<CColModel&, 0x40F7C0, CColModel *, CColModel const&>(this, colModel);
  27  }

  30  void CColModel::AllocateData() {
  31:     plugin::CallMethod<0x40F810, CColModel *>(this);
  32  }

  35  void CColModel::AllocateData(int numSpheres, int numBoxes, int numLines, int numVertices, int numTriangles, bool disks) {
  36:     plugin::CallMethod<0x40F870, CColModel *, int, int, int, int, int, bool>(this, numSpheres, numBoxes, numLines, numVertices, numTriangles, disks);
  37  }

  40  void CColModel::AllocateData(int size) {
  41:     plugin::CallMethod<0x40F9B0, CColModel *, int>(this, size);
  42  }

  45  void CColModel::RemoveCollisionVolumes() {
  46:     plugin::CallMethod<0x40F9E0, CColModel *>(this);
  47  }

  50  void CColModel::CalculateTrianglePlanes() {
  51:     plugin::CallMethod<0x40FA30, CColModel *>(this);
  52  }

  55  void CColModel::RemoveTrianglePlanes() {
  56:     plugin::CallMethod<0x40FA40, CColModel *>(this);
  57  }

  60  void* CColModel::operator new(unsigned int size) {
  61:     return plugin::CallAndReturn<void*, 0x40FC30, unsigned int>(size);
  62  }

  65  void CColModel::operator delete(void* data) {
  66:     plugin::Call<0x40FC40, void*>(data);
  67  }

plugin_sa\game_sa\CColourSet.cpp:
  10  CColourSet::CColourSet(int weatherId, int timeId) {
  11:     plugin::CallMethod<0x55F4B0, CColourSet *, int, int>(this, weatherId, timeId);
  12  }

  15  void CColourSet::Interpolate(CColourSet* a, CColourSet* b, float factor_a, float factor_b, bool bIgnoreSky) {
  16:     plugin::CallMethod<0x55F870, CColourSet *, CColourSet*, CColourSet*, float, float, bool>(this, a, b, factor_a, factor_b, bIgnoreSky);
  17  }

plugin_sa\game_sa\CControllerConfigManager.cpp:
  12  {
  13:     plugin::CallMethod <0x52D200, CControllerConfigManager*, int> ( this, file );
  14  }

  17  {
  18:     return plugin::CallMethodAndReturn <bool, 0x530530, CControllerConfigManager*, int> ( this, file );
  19  }

  22  bool CControllerConfigManager::GetIsKeyboardKeyDown(RsKeyCodes key) {
  23:     return plugin::CallMethodAndReturn<bool, 0x52DDB0, CControllerConfigManager *, RsKeyCodes>(this, key);
  24  }

  27  bool CControllerConfigManager::GetIsKeyboardKeyJustDown(RsKeyCodes key) {
  28:     return plugin::CallMethodAndReturn<bool, 0x52E450, CControllerConfigManager *, RsKeyCodes>(this, key);
  29  }

  31  void CControllerConfigManager::ResetSettingOrder(e_ControllerAction action) {
  32:     plugin::CallMethod<0x52F5F0, CControllerConfigManager*, e_ControllerAction>(this, action);
  33  }

plugin_sa\game_sa\CCover.cpp:
   18  void CCover::AddCoverPoint(int maxPeds, CEntity *coverEntity, CVector *position, char coverType, unsigned char direction) {
   19:     plugin::CallDynGlobal<int, CEntity *, CVector *, char, unsigned char>(gaddrof(CCover::AddCoverPoint), maxPeds, coverEntity, position, coverType, direction);
   20  }

   25  float CCover::CalculateHorizontalSize(CColTriangle *triangle, CVector *vertPositions) {
   26:     return plugin::CallAndReturnDynGlobal<float, CColTriangle *, CVector *>(gaddrof(CCover::CalculateHorizontalSize), triangle, vertPositions);
   27  }

   32  char CCover::DoLineCheckWithinObject(CColTriangle *triangle, int a2, CVector *a3, CVector *a4, CVector a5, CVector a6) {
   33:     return plugin::CallAndReturnDynGlobal<char, CColTriangle *, int, CVector *, CVector *, CVector, CVector>(gaddrof(CCover::DoLineCheckWithinObject), triangle, a2, a3, a4, a5, a6);
   34  }

   39  bool CCover::DoesCoverPointStillProvideCover(CCoverPoint *point, CVector position) {
   40:     return plugin::CallAndReturnDynGlobal<bool, CCoverPoint *, CVector>(gaddrof(CCover::DoesCoverPointStillProvideCover), point, position);
   41  }

   46  void CCover::Find2HighestPoints(CColTriangle *triangle, CVector *vertPositions, int &outPoint1, int &outPoint2) {
   47:     plugin::CallDynGlobal<CColTriangle *, CVector *, int &, int &>(gaddrof(CCover::Find2HighestPoints), triangle, vertPositions, outPoint1, outPoint2);
   48  }

   53  CCoverPoint *CCover::FindAndReserveCoverPoint(CPed *ped, CVector &position, bool a3) {
   54:     return plugin::CallAndReturnDynGlobal<CCoverPoint *, CPed *, CVector &, bool>(gaddrof(CCover::FindAndReserveCoverPoint), ped, position, a3);
   55  }

   60  bool CCover::FindCoordinatesCoverPoint(CCoverPoint *point, CPed *ped, CVector &position, CVector &outCoordinates) {
   61:     return plugin::CallAndReturnDynGlobal<bool, CCoverPoint *, CPed *, CVector &, CVector &>(gaddrof(CCover::FindCoordinatesCoverPoint), point, ped, position, outCoordinates);
   62  }

   67  void CCover::FindCoverPointsForThisBuilding(CBuilding *building) {
   68:     plugin::CallDynGlobal<CBuilding *>(gaddrof(CCover::FindCoverPointsForThisBuilding), building);
   69  }

   74  unsigned char CCover::FindDirFromVector(float x, float y) {
   75:     return plugin::CallAndReturnDynGlobal<unsigned char, float, float>(gaddrof(CCover::FindDirFromVector), x, y);
   76  }

   82      CVector ret_vec;
   83:     plugin::CallDynGlobal<CVector *, unsigned char>(gaddrof(CCover::FindVectorFromDir), &ret_vec, direction);
   84      return ret_vec;

   91      CVector ret_vec;
   92:     plugin::CallDynGlobal<CVector *, CColTriangle *, int *, CVector *>(gaddrof(CCover::FindVectorFromFirstToMissingVertex), &ret_vec, triangle, a3, vertPositions);
   93      return ret_vec;

  106  void CCover::RemoveCoverPointIfEntityLost(CCoverPoint *point) {
  107:     plugin::CallDynGlobal<CCoverPoint *>(gaddrof(CCover::RemoveCoverPointIfEntityLost), point);
  108  }

  113  void CCover::RemoveCoverPointsForThisEntity(CEntity *entity) {
  114:     plugin::CallDynGlobal<CEntity *>(gaddrof(CCover::RemoveCoverPointsForThisEntity), entity);
  115  }

  120  bool CCover::ShouldThisBuildingHaveItsCoverPointsCreated(CBuilding *building) {
  121:     return plugin::CallAndReturnDynGlobal<bool, CBuilding *>(gaddrof(CCover::ShouldThisBuildingHaveItsCoverPointsCreated), building);
  122  }

plugin_sa\game_sa\CCoverPoint.cpp:
  14  bool CCoverPoint::CanAccomodateAnotherPed() {
  15:     return plugin::CallMethodAndReturnDynGlobal<bool, CCoverPoint *>(gaddrof(CCoverPoint::CanAccomodateAnotherPed), this);
  16  }

  21  void CCoverPoint::ReleaseCoverPointForPed(CPed *ped) {
  22:     plugin::CallMethodDynGlobal<CCoverPoint *, CPed *>(gaddrof(CCoverPoint::ReleaseCoverPointForPed), this, ped);
  23  }

  28  void CCoverPoint::ReserveCoverPointForPed(CPed *ped) {
  29:     plugin::CallMethodDynGlobal<CCoverPoint *, CPed *>(gaddrof(CCoverPoint::ReserveCoverPointForPed), this, ped);
  30  }

plugin_sa\game_sa\CCredits.cpp:
  13  void CCredits::Render() {
  14:     plugin::Call<0x53D5B0>();
  15  }

  18  void CCredits::PrintCreditText(float scaleX, float scaleY, unsigned short* text, unsigned int& position, float currentOffset, bool highlighted) {
  19:     plugin::Call<0x5A8660, float, float, unsigned short*, unsigned int&, float, bool>(scaleX, scaleY, text, position, currentOffset, highlighted);
  20  }

  23  void CCredits::PrintCreditSpace(float spaceSize, unsigned int& position) {
  24:     plugin::Call<0x5A87C0, float, unsigned int&>(spaceSize, position);
  25  }

  28  void CCredits::RenderCredits() {
  29:     plugin::Call<0x5A87F0>();
  30  }

  33  void CCredits::Start() {
  34:     plugin::Call<0x7170E0>();
  35  }

  38  void CCredits::Stop() {
  39:     plugin::Call<0x717100>();
  40  }

plugin_sa\game_sa\CCullZones.cpp:
  23  bool CZoneDef::IsPointWithin(const CVector& point) {
  24:     return plugin::CallMethodAndReturn<bool, 0x72D850>(this, point);
  25  }

  27  void CCullZones::Init() {
  28:     plugin::Call<0x72D6B0>();
  29  }

  31  void CCullZones::Update() {
  32:     plugin::Call<0x72DEC0>();
  33  }

  35  void CCullZones::AddCullZone(const CVector& center, float unk1, float fWidthY, float fBottomZ, float fWidthX, float unk2, float fTopZ, ushort flags) {
  36:     plugin::Call<0x72DF70>();
  37  }

  39  void CCullZones::AddTunnelAttributeZone(const CVector& center, float unk1, float fWidthY, float fBottomZ, float fWidthX, float unk2, float fTopZ, ushort flags) {
  40:     plugin::Call<0x72DB50>();
  41  }

  43  void CCullZones::AddMirrorAttributeZone(const CVector& center, float unk1, float fWidthY, float fBottomZ, float fWidthX, float unk2, float fTopZ, eZoneAttributes flags, float cm, float vX, float vY, float vZ) {
  44:     plugin::Call<0x72DC10>();
  45  }

  47  bool CCullZones::InRoomForAudio() {
  48:     return plugin::CallAndReturn<bool, 0x72DD70>();
  49  }

  51  bool CCullZones::FewerCars() {
  52:     return plugin::CallAndReturn<bool, 0x72DD80>();
  53  }

  55  bool CCullZones::CamNoRain() {
  56:     return plugin::CallAndReturn<bool, 0x72DDB0>();
  57  }

  59  bool CCullZones::PlayerNoRain() {
  60:     return plugin::CallAndReturn<bool, 0x72DDC0>();
  61  }

  63  bool CCullZones::FewerPeds() {
  64:     return plugin::CallAndReturn<bool, 0x72DD90>();
  65  }

  67  bool CCullZones::NoPolice() {
  68:     return plugin::CallAndReturn<bool, 0x72DD50>();
  69  }

  71  bool CCullZones::DoExtraAirResistanceForPlayer() {
  72:     return plugin::CallAndReturn<bool, 0x72DDD0>();
  73  }

  75  eZoneAttributes CCullZones::FindTunnelAttributesForCoors(CVector point) {
  76:     return plugin::CallAndReturn<eZoneAttributes, 0x72D9F0>(point);
  77  }

  79  CCullZoneReflection* CCullZones::FindMirrorAttributesForCoors(CVector cameraPosition) {
  80:     return plugin::CallAndReturn<CCullZoneReflection*, 0x72DA70>(cameraPosition);
  81  }

  83  CCullZone* CCullZones::FindZoneWithStairsAttributeForPlayer() {
  84:     return plugin::CallAndReturn<CCullZone*, 0x72DAD0>();
  85  }

  87  eZoneAttributes CCullZones::FindAttributesForCoors(CVector pos) {
  88:     return plugin::CallAndReturn<eZoneAttributes, 0x72D970>(pos);
  89  }

plugin_sa\game_sa\CCustomCarEnvMapPipeline.cpp:
   20  int CCustomCarEnvMapPipeline::CustomPipeInstanceCB(int arg1, int arg2, int(__cdecl *callback)(int, int, int)) {
   21: 	return plugin::CallAndReturn<int,0x5D8490, int, int, int(__cdecl *)(int, int, int)>(arg1, arg2, callback);
   22  }

   25  void CCustomCarEnvMapPipeline::PreRenderUpdate() {
   26: 	plugin::Call<0x5D8870>();
   27  }

   30  void* CCustomCarEnvMapPipeline::pluginEnvMatConstructorCB(void* object, int offset) {
   31: 	return plugin::CallAndReturn<void*, 0x5D8BD0, void*, int>(object, offset);
   32  }

   35  RwStream* CCustomCarEnvMapPipeline::pluginEnvMatStreamWriteCB(RwStream* stream, int length, void const* arg3, int arg4) {
   36: 	return plugin::CallAndReturn<RwStream*, 0x5D8CD0, RwStream*, int, void const*, int>(stream, length, arg3, arg4);
   37  }

   40  int CCustomCarEnvMapPipeline::pluginEnvMatStreamGetSizeCB(void const* arg0) {
   41: 	return plugin::CallAndReturn<int, 0x5D8D10, void const*>(arg0);
   42  }

   45  void* CCustomCarEnvMapPipeline::pluginEnvAtmConstructorCB(void* object, int offset) {
   46: 	return plugin::CallAndReturn<void*, 0x5D8D30, void*, int>(object, offset);
   47  }

   50  void* CCustomCarEnvMapPipeline::pluginSpecMatConstructorCB(void* object) {
   51: 	return plugin::CallAndReturn<void*, 0x5D8D40, void*>(object);
   52  }

   55  RwStream* CCustomCarEnvMapPipeline::pluginSpecMatStreamWriteCB(RwStream* stream, int length, void const* object) {
   56: 	return plugin::CallAndReturn<RwStream*, 0x5D8D60, RwStream*, int, void const*>(stream, length, object);
   57  }

   60  signed int CCustomCarEnvMapPipeline::pluginSpecMatStreamGetSizeCB() {
   61: 	return plugin::CallAndReturn<signed int, 0x5D8DD0>();
   62  }

   65  CustomEnvMapPipeMaterialData* CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData(CustomEnvMapPipeMaterialData** arg0) {
   66: 	return plugin::CallAndReturn<CustomEnvMapPipeMaterialData*, 0x5D9570, CustomEnvMapPipeMaterialData**>(arg0);
   67  }

   70  void* CCustomCarEnvMapPipeline::pluginEnvMatDestructorCB(void* object, int offset) {
   71: 	return plugin::CallAndReturn<void*, 0x5D95B0, void*, int>(object, offset);
   72  }

   75  void* CCustomCarEnvMapPipeline::pluginEnvMatCopyConstructorCB(void* object_dst, void const* object_src, int offset, int size) {
   76: 	return plugin::CallAndReturn<void*, 0x5D9600, void*, void const*, int, int>(object_dst, object_src, offset, size);
   77  }

   80  RwStream* CCustomCarEnvMapPipeline::pluginEnvMatStreamReadCB(RwStream* stream, int length, void* object, int offset) {
   81: 	return plugin::CallAndReturn<RwStream*, 0x5D9660, RwStream*, int, void*, int>(stream, length, object, offset);
   82  }

   85  void* CCustomCarEnvMapPipeline::pluginEnvAtmDestructorCB(void* object, int offset) {
   86: 	return plugin::CallAndReturn<void*, 0x5D9730, void*, int>(object, offset);
   87  }

   90  void* CCustomCarEnvMapPipeline::pluginEnvAtmCopyConstructorCB(void* object_dst, void const* object_src, int offset, int size) {
   91: 	return plugin::CallAndReturn<void*, 0x5D9780, void*, void const*, int, int>(object_dst, object_src, offset, size);
   92  }

   95  void* CCustomCarEnvMapPipeline::pluginSpecMatDestructorCB(void* object) {
   96: 	return plugin::CallAndReturn<void*, 0x5D97D0, void*>(object);
   97  }

  100  void* CCustomCarEnvMapPipeline::pluginSpecMatCopyConstructorCB(void* object_dst, void const* object_src) {
  101: 	return plugin::CallAndReturn<void*, 0x5D9830, void*, void const*>(object_dst, object_src);
  102  }

  105  RwStream* CCustomCarEnvMapPipeline::pluginSpecMatStreamReadCB(RwStream* stream, int length, void* object) {
  106: 	return plugin::CallAndReturn<RwStream*, 0x5D9880, RwStream*, int, void*>(stream, length, object);
  107  }

  110  int CCustomCarEnvMapPipeline::CustomPipeRenderCB(RwResEntry* atomic, void* object, unsigned char flags1, unsigned int flags2) {
  111: 	return plugin::CallAndReturn<int, 0x5D9900, RwResEntry*, void*, unsigned char, unsigned int>(atomic, object, flags1, flags2);
  112  }

  115  RxPipeline* CCustomCarEnvMapPipeline::CreateCustomOpenGLObjPipe() {
  116: 	return plugin::CallAndReturn<RxPipeline*, 0x5D9F80>();
  117  }

  120  char CCustomCarEnvMapPipeline::CreatePipe() {
  121: 	return plugin::CallAndReturn<char, 0x5DA020>();
  122  }

  125  void CCustomCarEnvMapPipeline::DestroyPipe() {
  126: 	plugin::Call<0x5DA130>();
  127  }

  130  void CCustomCarEnvMapPipeline::SetFxEnvTexture(RpMaterial* material, RwTexture* texture) {
  131: 	plugin::Call<0x5DA230, RpMaterial*, RwTexture*>(material, texture);
  132  }

  135  char CCustomCarEnvMapPipeline::RegisterPlugin() {
  136: 	return plugin::CallAndReturn<char, 0x5DA450>();
  137  }

  140  RpMaterial* CCustomCarEnvMapPipeline::CustomPipeMaterialSetup(RpMaterial* arg0, void* arg1) {
  141: 	return plugin::CallAndReturn<RpMaterial*, 0x5DA560, RpMaterial*, void*>(arg0, arg1);
  142  }

  145  RpAtomic* CCustomCarEnvMapPipeline::CustomPipeAtomicSetup(RpAtomic* arg0) {
  146: 	return plugin::CallAndReturn<RpAtomic*, 0x5DA610, RpAtomic*>(arg0);
  147  }

plugin_sa\game_sa\CCustomCarPlateMgr.cpp:
  17  bool CCustomCarPlateMgr::Initialise() {
  18:     return plugin::CallAndReturn<bool, 0x6FD500>();
  19  }

  22  bool CCustomCarPlateMgr::GeneratePlateText(char* plateTextBuf, int length) {
  23:     return plugin::CallAndReturn<bool, 0x6FD5B0, char*, int>(plateTextBuf, length);
  24  }

  27  bool CCustomCarPlateMgr::Shutdown() {
  28:     return plugin::CallAndReturn<bool, 0x6FD720>();
  29  }

  32  unsigned char CCustomCarPlateMgr::GetMapRegionPlateDesign() {
  33:     return plugin::CallAndReturn<unsigned char, 0x6FD7A0>();
  34  }

  37  bool CCustomCarPlateMgr::LoadPlatecharsetDat(char const* filename, unsigned char* data, int arg2, int arg3) {
  38:     return plugin::CallAndReturn<bool, 0x6FDC00, char const*, unsigned char*, int, int>(filename, data, arg2, arg3);
  39  }

  42  bool RenderLicenseplateTextToRaster(char* text, RwRaster* charsetRaster, void* palette, RwRaster* resultRaster) {
  43:     return plugin::CallAndReturn<bool, 0x6FDD70, char*, RwRaster*, void*, RwRaster*>(text, charsetRaster, palette, resultRaster);
  44  }

  47  RpMaterial* CCustomCarPlateMgr::SetupMaterialPlatebackTexture(RpMaterial* material, unsigned char plateType) {
  48:     return plugin::CallAndReturn<RpMaterial*, 0x6FDE50, RpMaterial*, unsigned char>(material, plateType);
  49  }

  52  RwTexture* CCustomCarPlateMgr::CreatePlateTexture(char* text, unsigned char plateType) {
  53:     return plugin::CallAndReturn<RwTexture*, 0x6FDEA0, char*, unsigned char>(text, plateType);
  54  }

  57  RpMaterial* MaterialUpgradeSetCarplateTextureCB(RpMaterial* material, void* data) {
  58:     return plugin::CallAndReturn<RpMaterial*, 0x6FDF50, RpMaterial*, void*>(material, data);
  59  }

  62  RpAtomic* AtomicUpgradeSetCarplateTextureCB(RpAtomic* atomic, _IGNORED_ void* data) {
  63:     return plugin::CallAndReturn<RpAtomic*, 0x6FDFC0, RpAtomic*, void*>(atomic, data);
  64  }

  67  bool CCustomCarPlateMgr::SetupClumpAfterVehicleUpgrade(RpClump* clump, RpMaterial* plateMaterial, unsigned char plateType) {
  68:     return plugin::CallAndReturn<bool, 0x6FDFE0, RpClump*, RpMaterial*, unsigned char>(clump, plateMaterial, plateType);
  69  }

  72  RpMaterial* CCustomCarPlateMgr::SetupMaterialPlateTexture(RpMaterial* material, char* plateText, unsigned char plateType) {
  73:     return plugin::CallAndReturn<RpMaterial*, 0x6FE020, RpMaterial*, char*, unsigned char>(material, plateText, plateType);
  74  }

  77  RpMaterial* MaterialSetCarplateTextureCB(RpMaterial* material, void* data) {
  78:     return plugin::CallAndReturn<RpMaterial*, 0x6FE060, RpMaterial*, void*>(material, data);
  79  }

  82  RpAtomic* AtomicSetCarplateTextureCB(RpAtomic* atomic, void* data) {
  83:     return plugin::CallAndReturn<RpAtomic*, 0x6FE0D0, RpAtomic*, void*>(atomic, data);
  84  }

  87  RpMaterial* CCustomCarPlateMgr::SetupClump(RpClump* clump, char* plateText, unsigned char plateType) {
  88:     return plugin::CallAndReturn<RpMaterial*, 0x6FE0F0, RpClump*, char*, unsigned char>(clump, plateText, plateType);
  89  }

plugin_sa\game_sa\CCutsceneMgr.cpp:
   63  int CCutsceneMgr::AddCutsceneHead(CObject* object, int arg1) {
   64:     return plugin::CallAndReturn<int, 0x5B0380, CObject*, int>(object, arg1);
   65  }

   68  void CCutsceneMgr::AppendToNextCutscene(char const* objectName, char const* animName) {
   69:     plugin::Call<0x4D5DB0, char const*, char const*>(objectName, animName);
   70  }

   73  void CCutsceneMgr::AttachObjectToBone(CObject* attachment, CObject* object, int boneId) {
   74:     plugin::Call<0x5B0450, CObject*, CObject*, int>(attachment, object, boneId);
   75  }

   78  void CCutsceneMgr::AttachObjectToFrame(CObject* attachment, CEntity* object, char const* frameName) {
   79:     plugin::Call<0x5B0480, CObject*, CEntity*, char const*>(attachment, object, frameName);
   80  }

   83  void CCutsceneMgr::AttachObjectToParent(CObject* attachment, CEntity* object) {
   84:     plugin::Call<0x5B04B0, CObject*, CEntity*>(attachment, object);
   85  }

   88  void CCutsceneMgr::BuildCutscenePlayer() {
   89:     plugin::Call<0x4D5E20>();
   90  }

   93  CCutsceneObject* CCutsceneMgr::CreateCutsceneObject(int modelId) {
   94:     return plugin::CallAndReturn<CCutsceneObject*, 0x5B02A0, int>(modelId);
   95  }

   98  void CCutsceneMgr::DeleteCutsceneData() {
   99:     plugin::Call<0x4D5ED0>();
  100  }

  103  void CCutsceneMgr::DeleteCutsceneData_overlay() {
  104:     plugin::Call<0x5AFD60>();
  105  }

  108  void CCutsceneMgr::FinishCutscene() {
  109:     plugin::Call<0x5B04D0>();
  110  }

  113  long long CCutsceneMgr::GetCutsceneTimeInMilleseconds() {
  114:     return plugin::CallAndReturn<long long, 0x5B0550>();
  115  }

  118  bool CCutsceneMgr::HasCutsceneFinished() {
  119:     return plugin::CallAndReturn<bool, 0x5B0570>();
  120  }

  123  void CCutsceneMgr::HideRequestedObjects() {
  124:     plugin::Call<0x5AFAD0>();
  125  }

  128  void CCutsceneMgr::Initialise() {
  129:     plugin::Call<0x4D5A20>();
  130  }

  133  void CCutsceneMgr::IsCutsceneSkipButtonBeingPressed() {
  134:     plugin::Call<0x4D5D10>();
  135  }

  138  void CCutsceneMgr::LoadAnimationUncompressed(char const* animName) {
  139:     plugin::Call<0x4D5AB0, char const*>(animName);
  140  }

  143  void CCutsceneMgr::LoadCutsceneData(char const* cutsceneName) {
  144:     plugin::Call<0x4D5E80, char const*>(cutsceneName);
  145  }

  148  void CCutsceneMgr::LoadCutsceneData_loading() {
  149:     plugin::Call<0x5B11C0>();
  150  }

  153  void CCutsceneMgr::LoadCutsceneData_overlay(char const* cutsceneName) {
  154:     plugin::Call<0x5B13F0, char const*>(cutsceneName);
  155  }

  158  void CCutsceneMgr::LoadCutsceneData_postload() {
  159:     plugin::Call<0x5AFBC0>();
  160  }

  163  void CCutsceneMgr::LoadCutsceneData_preload() {
  164:     plugin::Call<0x5B05A0>();
  165  }

  168  void CCutsceneMgr::LoadEverythingBecauseCutsceneDeletedAllOfIt() {
  169:     plugin::Call<0x4D5C10>();
  170  }

  173  void CCutsceneMgr::RemoveCutscenePlayer() {
  174:     plugin::Call<0x4D5E50>();
  175  }

  178  void CCutsceneMgr::RemoveEverythingBecauseCutsceneDoesntFitInMemory() {
  179:     plugin::Call<0x4D5AF0>();
  180  }

  183  void CCutsceneMgr::SetCutsceneAnim(char const* animName, CObject* object) {
  184:     plugin::Call<0x5B0390, char const*, CObject*>(animName, object);
  185  }

  188  void CCutsceneMgr::SetCutsceneAnimToLoop(char const* animName) {
  189:     plugin::Call<0x5B0420, char const*>(animName);
  190  }

  193  void CCutsceneMgr::SetHeadAnim(char const* animName, CObject* headObject) {
  194:     plugin::Call<0x5B0440, char const*, CObject*>(animName, headObject);
  195  }

  198  void CCutsceneMgr::SetupCutsceneToStart() {
  199:     plugin::Call<0x5B14D0>();
  200  }

  203  void CCutsceneMgr::Shutdown() {
  204:     plugin::Call<0x4D5E60>();
  205  }

  208  void CCutsceneMgr::SkipCutscene() {
  209:     plugin::Call<0x5B1700>();
  210  }

  213  void CCutsceneMgr::StartCutscene() {
  214:     plugin::Call<0x5B1460>();
  215  }

  218  void CCutsceneMgr::Update() {
  219:     plugin::Call<0x4D5D00>();
  220  }

  223  void CCutsceneMgr::Update_overlay() {
  224:     plugin::Call<0x5B1720>();
  225  }

  228  short FindCutsceneAudioTrackId(char const* cutsceneName) {
  229:     return plugin::CallAndReturn<short, 0x5AFA50, char const*>(cutsceneName);
  230  }

  233  void UpdateCutsceneObjectBoundingBox(RpClump* clump, int modelId) {
  234:     plugin::Call<0x5B01E0, RpClump*, int>(clump, modelId);
  235  }

plugin_sa\game_sa\CDarkel.cpp:
   25  void CDarkel::Init() {
   26: 	plugin::Call<0x43CEB0>();
   27  }

   30  void CDarkel::DrawMessages() {
   31: 	plugin::Call<0x43CEC0>();
   32  }

   35  short CDarkel::ReadStatus() {
   36: 	return plugin::CallAndReturn<short, 0x43D1E0>();
   37  }

   40  void CDarkel::RegisterKillNotByPlayer(CPed const* pKilledPed) {
   41: 	plugin::Call<0x43D210, CPed const*>(pKilledPed);
   42  }

   45  bool CDarkel::ThisPedShouldBeKilledForFrenzy(CPed const* pPed) {
   46: 	return plugin::CallAndReturn<bool, 0x43D2F0, CPed const*>(pPed);
   47  }

   50  bool CDarkel::ThisVehicleShouldBeKilledForFrenzy(CVehicle const* pVehicle) {
   51: 	return plugin::CallAndReturn<bool, 0x43D350, CVehicle const*>(pVehicle);
   52  }

   55  void CDarkel::StartFrenzy(eWeaponType weapontype, int Timelimit, unsigned short KillsNeeded, int ModelToKill, unsigned short* pStartMessage, int ModelToKill2, int ModelToKill3, int ModelToKill4, bool bStandardSoundAndMessages, bool bNeedHeadShot) {
   56: 	plugin::Call<0x43D3B0, eWeaponType, int, unsigned short, int, unsigned short*, int, int, int, bool, bool>(weapontype, Timelimit, KillsNeeded, ModelToKill, pStartMessage, ModelToKill2, ModelToKill3, ModelToKill4, bStandardSoundAndMessages, bNeedHeadShot);
   57  }

   60  void CDarkel::ResetModelsKilledByPlayer(int playerid) {
   61: 	plugin::Call<0x43D6A0, int>(playerid);
   62  }

   65  int CDarkel::QueryModelsKilledByPlayer(int player, int modelid) {
   66: 	return plugin::CallAndReturn<int, 0x43D6C0, int, int>(player, modelid);
   67  }

   70  int CDarkel::FindTotalPedsKilledByPlayer(int player) {
   71: 	return plugin::CallAndReturn<int, 0x43D6E0, int>(player);
   72  }

   75  void CDarkel::DealWithWeaponChangeAtEndOfFrenzy() {
   76: 	plugin::Call<0x43D7A0>();
   77  }

   80  bool CDarkel::CheckDamagedWeaponType(int damageWeaponID, int expectedDamageWeaponID) {
   81: 	return plugin::CallAndReturn<bool, 0x43D9E0, int, int>(damageWeaponID, expectedDamageWeaponID);
   82  }

   85  void CDarkel::Update() {
   86: 	plugin::Call<0x43DAC0>();
   87  }

   90  void CDarkel::ResetOnPlayerDeath() {
   91: 	plugin::Call<0x43DC10>();
   92  }

   95  void CDarkel::FailKillFrenzy() {
   96: 	plugin::Call<0x43DC60>();
   97  }

  100  void CDarkel::RegisterKillByPlayer(CPed const* pKilledPed, eWeaponType damageWeaponID, bool bHeadShotted, int arg4) {
  101: 	plugin::Call<0x43DCD0, CPed const*, eWeaponType, bool, int>(pKilledPed, damageWeaponID, bHeadShotted, arg4);
  102  }

  105  void CDarkel::RegisterCarBlownUpByPlayer(CVehicle* pVehicle, int arg2) {
  106: 	plugin::Call<0x43DF20, CVehicle*, int>(pVehicle, arg2);
  107  }

plugin_sa\game_sa\CDate.cpp:
  14  CDate::CDate() {
  15:     plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), this);
  16  }

  21  bool CDate::operator<(CDate const &rhs) {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator<), this, rhs);
  23  }

  28  bool CDate::operator==(CDate const &rhs) {
  29:     return plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator==), this, rhs);
  30  }

  35  bool CDate::operator>(CDate const &rhs) {
  36:     return plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator>), this, rhs);
  37  }

  42  void CDate::PopulateDateFields(char const &seconds, char const &minutes, char const &hours, char const &day, char const &month, short year) {
  43:     plugin::CallMethodDynGlobal<CDate *, char const &, char const &, char const &, char const &, char const &, short>(gaddrof(CDate::PopulateDateFields), this, seconds, minutes, hours, day, month, year);
  44  }

plugin_sa\game_sa\CDecisionSimple.cpp:
  10  void CDecisionSimple::Set(int* taskTypes, unsigned char* chances, int count) {
  11:     plugin::CallMethod<0x600730, CDecisionSimple *, int*, unsigned char*, int>(this, taskTypes, chances, count);
  12  }

  15  void CDecisionSimple::MakeDecision(int taskType, short& outTaskType, int& outDecisionIndex) {
  16:     plugin::CallMethod<0x6007A0, CDecisionSimple *, int, short&, int&>(this, taskType, outTaskType, outDecisionIndex);
  17  }

  20  void CDecisionSimple::SetDefault() {
  21:     plugin::CallMethod<0x604220, CDecisionSimple *>(this);
  22  }

plugin_sa\game_sa\CDirectory.cpp:
  10  CDirectory::CDirectory() {
  11:     plugin::CallMethod<0x532290, CDirectory *>(this);
  12  }

  15  CDirectory::CDirectory(int capacity) {
  16:     plugin::CallMethod<0x5322A0, CDirectory *, int>(this, capacity);
  17  }

  20  CDirectory::~CDirectory() {
  21:     plugin::CallMethod<0x5322D0, CDirectory *>(this);
  22  }

  25  void CDirectory::Init(int capacity, void* entries) {
  26:     plugin::CallMethod<0x5322F0, CDirectory *, int, void*>(this, capacity, entries);
  27  }

  30  void CDirectory::AddItem(DirectoryInfo const& entry) {
  31:     plugin::CallMethod<0x532310, CDirectory *, DirectoryInfo const&>(this, entry);
  32  }

  35  void CDirectory::ReadDirFile(char const* filename) {
  36:     plugin::CallMethod<0x532350, CDirectory *, char const*>(this, filename);
  37  }

  40  bool CDirectory::WriteDirFile(char const* filename) {
  41:     return plugin::CallMethodAndReturn<bool, 0x532410, CDirectory *, char const*>(this, filename);
  42  }

  45  CDirectory::DirectoryInfo* CDirectory::FindItem(char const* name) {
  46:     return plugin::CallMethodAndReturn<DirectoryInfo*, 0x532450, CDirectory *, char const*>(this, name);
  47  }

  50  CDirectory::DirectoryInfo* CDirectory::FindItem(char const* name, unsigned int& outOffset, unsigned int& outStreamingSize) {
  51:     return plugin::CallMethodAndReturn<DirectoryInfo*, 0x5324A0, CDirectory *, char const*, unsigned int&, unsigned int&>(this, name, outOffset, outStreamingSize);
  52  }

  55  CDirectory::DirectoryInfo* CDirectory::FindItem(unsigned int key, unsigned int& outOffset, unsigned int& outStreamingSize) {
  56:     return plugin::CallMethodAndReturn<DirectoryInfo*, 0x5324D0, CDirectory *, unsigned int, unsigned int&, unsigned int&>(this, key, outOffset, outStreamingSize);
  57  }

plugin_sa\game_sa\CDoor.cpp:
  12  bool CDoor::Process(CVehicle* vehicle, CVector& arg1, CVector& arg2, CVector& arg3) {
  13:     return plugin::CallMethodAndReturn<bool, 0x6F4040, CDoor *, CVehicle*, CVector&, CVector&, CVector&>(this, vehicle, arg1, arg2, arg3);
  14  }

  17  bool CDoor::ProcessImpact(CVehicle* vehicle, CVector& arg1, CVector& arg2, CVector& arg3) {
  18:     return plugin::CallMethodAndReturn<bool, 0x6F4540, CDoor *, CVehicle*, CVector&, CVector&, CVector&>(this, vehicle, arg1, arg2, arg3);
  19  }

  22  void CDoor::Open(float openRatio) {
  23:     plugin::CallMethod<0x6F4790, CDoor *, float>(this, openRatio);
  24  }

  27  float CDoor::GetAngleOpenRatio() {
  28:     return plugin::CallMethodAndReturn<float, 0x6F47E0, CDoor *>(this);
  29  }

  32  bool CDoor::IsClosed() {
  33:     return plugin::CallMethodAndReturn<bool, 0x6F4800, CDoor *>(this);
  34  }

  37  bool CDoor::IsFullyOpen() {
  38:     return plugin::CallMethodAndReturn<bool, 0x6F4820, CDoor *>(this);
  39  }

plugin_sa\game_sa\CDraw.cpp:
  20  void CDraw::SetFOV(float fovValue) {
  21:     plugin::Call<0x6FF410, float>(fovValue);
  22  }

  25  float CDraw::CalculateAspectRatio() {
  26:     return plugin::CallAndReturn<float, 0x6FF420>();
  27  }

plugin_sa\game_sa\CEntryExit.cpp:
  21  void CEntryExit::GenerateAmbientPeds(CVector const &position) {
  22:     plugin::CallMethodDynGlobal<CEntryExit *, CVector const &>(gaddrof(CEntryExit::GenerateAmbientPeds), this, position);
  23  }

  28  char *CEntryExit::GetEntryExitToDisplayNameOf() {
  29:     return plugin::CallMethodAndReturnDynGlobal<char *, CEntryExit *>(gaddrof(CEntryExit::GetEntryExitToDisplayNameOf), this);
  30  }

  35  void CEntryExit::GetPositionRelativeToOutsideWorld(CVector &positionInOut) {
  36:     plugin::CallMethodDynGlobal<CEntryExit *, CVector &>(gaddrof(CEntryExit::GetPositionRelativeToOutsideWorld), this, positionInOut);
  37  }

  42  bool CEntryExit::IsInArea(CVector const &position) {
  43:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CVector const &>(gaddrof(CEntryExit::IsInArea), this, position);
  44  }

  49  void CEntryExit::RequestAmbientPeds() {
  50:     plugin::CallMethodDynGlobal<CEntryExit *>(gaddrof(CEntryExit::RequestAmbientPeds), this);
  51  }

  56  void CEntryExit::RequestObjectsInFrustum() {
  57:     plugin::CallMethodDynGlobal<CEntryExit *>(gaddrof(CEntryExit::RequestObjectsInFrustum), this);
  58  }

  63  bool CEntryExit::TransitionFinished(CPed *player) {
  64:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CPed *>(gaddrof(CEntryExit::TransitionFinished), this, player);
  65  }

  70  bool CEntryExit::TransitionStarted(CPed *player) {
  71:     return plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CPed *>(gaddrof(CEntryExit::TransitionStarted), this, player);
  72  }

  77  void CEntryExit::WarpGangWithPlayer(CPed *player) {
  78:     plugin::CallMethodDynGlobal<CEntryExit *, CPed *>(gaddrof(CEntryExit::WarpGangWithPlayer), this, player);
  79  }

plugin_sa\game_sa\CEntryExitManager.cpp:
   26  void CEntryExitManager::AddEntryExitToStack(CEntryExit *a1) {
   27:     plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::AddEntryExitToStack), a1);
   28  }

   33  int CEntryExitManager::AddOne(float entranceX, float entranceY, float entranceZ, float entranceAngle, float entranceRangeX, float entranceRangeY, int unused, float exitX, float exitY, float exitZ, float exitAngle, int area, int flags, int skyColor, int timeOn, int timeOff, int numberOfPeds, char const *name) {
   34:     return plugin::CallAndReturnDynGlobal<int, float, float, float, float, float, float, int, float, float, float, float, int, int, int, int, int, int, char const *>(gaddrof(CEntryExitManager::AddOne), entranceX, entranceY, entranceZ, entranceAngle, entranceRangeX, entranceRangeY, unused, exitX, exitY, exitZ, exitAngle, area, flags, skyColor, timeOn, timeOff, numberOfPeds, name);
   35  }

   40  void CEntryExitManager::DeleteOne(int index) {
   41:     plugin::CallDynGlobal<int>(gaddrof(CEntryExitManager::DeleteOne), index);
   42  }

   47  void CEntryExitManager::EnableBurglaryHouses(bool enable) {
   48:     plugin::CallDynGlobal<bool>(gaddrof(CEntryExitManager::EnableBurglaryHouses), enable);
   49  }

   54  CEntity *CEntryExitManager::FindNearestDoor(CEntryExit const &entryExit, float range) {
   55:     return plugin::CallAndReturnDynGlobal<CEntity *, CEntryExit const &, float>(gaddrof(CEntryExitManager::FindNearestDoor), entryExit, range);
   56  }

   61  int CEntryExitManager::FindNearestEntryExit(CVector2D const &position, float range, int ignoreArea) {
   62:     return plugin::CallAndReturnDynGlobal<int, CVector2D const &, float, int>(gaddrof(CEntryExitManager::FindNearestEntryExit), position, range, ignoreArea);
   63  }

   68  CEntryExit *CEntryExitManager::GetEntryExit(int index) {
   69:     return plugin::CallAndReturnDynGlobal<CEntryExit *, int>(gaddrof(CEntryExitManager::GetEntryExit), index);
   70  }

   75  int CEntryExitManager::GetEntryExitIndex(char const *name, unsigned short enabledFlags, unsigned short disabledFlags) {
   76:     return plugin::CallAndReturnDynGlobal<int, char const *, unsigned short, unsigned short>(gaddrof(CEntryExitManager::GetEntryExitIndex), name, enabledFlags, disabledFlags);
   77  }

   82  void CEntryExitManager::GetPositionRelativeToOutsideWorld(CVector &positionInOut) {
   83:     plugin::CallDynGlobal<CVector &>(gaddrof(CEntryExitManager::GetPositionRelativeToOutsideWorld), positionInOut);
   84  }

   89  void CEntryExitManager::GotoEntryExit(CEntryExit *entryExit) {
   90:     plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::GotoEntryExit), entryExit);
   91  }

   96  void CEntryExitManager::GotoEntryExitVC(char const *name) {
   97:     plugin::CallDynGlobal<char const *>(gaddrof(CEntryExitManager::GotoEntryExitVC), name);
   98  }

  124  void CEntryExitManager::LinkEntryExit(CEntryExit *entryExit) {
  125:     plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::LinkEntryExit), entryExit);
  126  }

  131  bool CEntryExitManager::Load() {
  132:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::Load));
  133  }

  152  bool CEntryExitManager::Save() {
  153:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::Save));
  154  }

  166  void CEntryExitManager::SetEnabled(int index, bool enable) {
  167:     plugin::CallDynGlobal<int, bool>(gaddrof(CEntryExitManager::SetEnabled), index, enable);
  168  }

  173  void CEntryExitManager::SetEnabledByName(char const *name, bool enable) {
  174:     plugin::CallDynGlobal<char const *, bool>(gaddrof(CEntryExitManager::SetEnabledByName), name, enable);
  175  }

  180  void CEntryExitManager::SetEntryExitFlag(char const *name, unsigned int flag, bool enable) {
  181:     plugin::CallDynGlobal<char const *, unsigned int, bool>(gaddrof(CEntryExitManager::SetEntryExitFlag), name, flag, enable);
  182  }

  187  void CEntryExitManager::SetEntryExitFlagWithIndex(int index, unsigned int flag, bool enable) {
  188:     plugin::CallDynGlobal<int, unsigned int, bool>(gaddrof(CEntryExitManager::SetEntryExitFlagWithIndex), index, flag, enable);
  189  }

  215  bool CEntryExitManager::WeAreInInteriorTransition() {
  216:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::WeAreInInteriorTransition));
  217  }

plugin_sa\game_sa\CExplosion.cpp:
  14  void CExplosion::ClearAllExplosions() {
  15:     plugin::Call<0x736840>();
  16  }

  19  void CExplosion::Shutdown() {
  20:     plugin::Call<0x7368F0>();
  21  }

  24  unsigned char CExplosion::GetExplosionActiveCounter(unsigned char explosionId) {
  25:     return plugin::CallAndReturn<unsigned char, 0x736900, unsigned char>(explosionId);
  26  }

  29  void CExplosion::ResetExplosionActiveCounter(unsigned char explosionId) {
  30:     plugin::Call<0x736910, unsigned char>(explosionId);
  31  }

  34  bool CExplosion::DoesExplosionMakeSound(unsigned char explosionId) {
  35:     return plugin::CallAndReturn<bool, 0x736920, unsigned char>(explosionId);
  36  }

  39  unsigned int CExplosion::GetExplosionType(unsigned char explosionId) {
  40:     return plugin::CallAndReturn<unsigned int, 0x736930, unsigned char>(explosionId);
  41  }

  44  CVector* CExplosion::GetExplosionPosition(unsigned char explosionId) {
  45:     return plugin::CallAndReturn<CVector*, 0x736940, unsigned char>(explosionId);
  46  }

  49  bool CExplosion::TestForExplosionInArea(eExplosionType explosionType, float x1, float y1, float z1, float x2, float y2, float z2) {
  50:     return plugin::CallAndReturn<bool, 0x736950, eExplosionType, float, float, float, float, float, float>(explosionType, x1, y1, z1, x2, y2, z2);
  51  }

  54  void CExplosion::RemoveAllExplosionsInArea(CVector posn, float radius) {
  55:     plugin::Call<0x7369E0, CVector, float>(posn, radius);
  56  }

  59  void CExplosion::Initialise() {
  60:     plugin::Call<0x736A40>();
  61  }

  64  bool CExplosion::AddExplosion(CEntity* victim, CEntity* creator, eExplosionType explosionType, CVector const& posn, unsigned int time, unsigned char makeSound, float camShake, unsigned char visibility) {
  65:     return plugin::CallAndReturn<bool, 0x736A50, CEntity*, CEntity*, eExplosionType, CVector const&, unsigned int, unsigned char, float, unsigned char>(victim, creator, explosionType, posn, time, makeSound, camShake, visibility);
  66  }

  69  void CExplosion::Update() {
  70:     plugin::Call<0x737620>();
  71  }

plugin_sa\game_sa\CFileLoader.cpp:
   17  void CFileLoader::AddTexDictionaries(RwTexDictionary *dictionary, RwTexDictionary *baseDictionary) {
   18:     plugin::CallDynGlobal<RwTexDictionary *, RwTexDictionary *>(gaddrof(CFileLoader::AddTexDictionaries), dictionary, baseDictionary);
   19  }

   24  RpAtomic *CFileLoader::FindRelatedModelInfoCB(RpAtomic *atomic, void *data) {
   25:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CFileLoader::FindRelatedModelInfoCB), atomic, data);
   26  }

   31  bool CFileLoader::FinishLoadClumpFile(RwStream *stream, unsigned int modelIndex) {
   32:     return plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof(CFileLoader::FinishLoadClumpFile), stream, modelIndex);
   33  }

   38  void CFileLoader::LoadAnimatedClumpObject(char const *line) {
   39:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadAnimatedClumpObject), line);
   40  }

   45  void CFileLoader::LoadAtomicFile(RwStream *stream, unsigned int modelIndex) {
   46:     plugin::CallDynGlobal<RwStream *, unsigned int>(gaddrof_o(CFileLoader::LoadAtomicFile, void (*)(RwStream *, unsigned int)), stream, modelIndex);
   47  }

   52  void CFileLoader::LoadAtomicFile(char const *filename) {
   53:     plugin::CallDynGlobal<char const *>(gaddrof_o(CFileLoader::LoadAtomicFile, void (*)(char const *)), filename);
   54  }

   59  RpClump *CFileLoader::LoadAtomicFile2Return(char const *filename) {
   60:     return plugin::CallAndReturnDynGlobal<RpClump *, char const *>(gaddrof(CFileLoader::LoadAtomicFile2Return), filename);
   61  }

   66  void CFileLoader::LoadAudioZone(char const *line) {
   67:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadAudioZone), line);
   68  }

   73  void CFileLoader::LoadBoundingBox(unsigned char *data, CBoundingBox &outBoundBox) {
   74:     plugin::CallDynGlobal<unsigned char *, CBoundingBox &>(gaddrof(CFileLoader::LoadBoundingBox), data, outBoundBox);
   75  }

   80  void CFileLoader::LoadCarGenerator(CFileCarGenerator *carGen, int iplId) {
   81:     plugin::CallDynGlobal<CFileCarGenerator *, int>(gaddrof_o(CFileLoader::LoadCarGenerator, void (*)(CFileCarGenerator *, int)), carGen, iplId);
   82  }

   87  void CFileLoader::LoadCarGenerator(char const *line, int iplId) {
   88:     plugin::CallDynGlobal<char const *, int>(gaddrof_o(CFileLoader::LoadCarGenerator, void (*)(char const *, int)), line, iplId);
   89  }

   94  void CFileLoader::LoadCarPathNode(char const *line, int objModelIndex, int pathEntryIndex, bool a4) {
   95:     plugin::CallDynGlobal<char const *, int, int, bool>(gaddrof(CFileLoader::LoadCarPathNode), line, objModelIndex, pathEntryIndex, a4);
   96  }

  101  bool CFileLoader::LoadClumpFile(RwStream *stream, unsigned int modelIndex) {
  102:     return plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof_o(CFileLoader::LoadClumpFile, bool (*)(RwStream *, unsigned int)), stream, modelIndex);
  103  }

  108  void CFileLoader::LoadClumpFile(char const *filename) {
  109:     plugin::CallDynGlobal<char const *>(gaddrof_o(CFileLoader::LoadClumpFile, void (*)(char const *)), filename);
  110  }

  115  int CFileLoader::LoadClumpObject(char const *line) {
  116:     return plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadClumpObject), line);
  117  }

  122  bool CFileLoader::LoadCollisionFile(unsigned char *data, unsigned int dataSize, unsigned char colId) {
  123:     return plugin::CallAndReturnDynGlobal<bool, unsigned char *, unsigned int, unsigned char>(gaddrof_o(CFileLoader::LoadCollisionFile, bool (*)(unsigned char *, unsigned int, unsigned char)), data, dataSize, colId);
  124  }

  129  void CFileLoader::LoadCollisionFile(char const *filename, unsigned char colId) {
  130:     plugin::CallDynGlobal<char const *, unsigned char>(gaddrof_o(CFileLoader::LoadCollisionFile, void (*)(char const *, unsigned char)), filename, colId);
  131  }

  136  bool CFileLoader::LoadCollisionFileFirstTime(unsigned char *data, unsigned int dataSize, unsigned char colId) {
  137:     return plugin::CallAndReturnDynGlobal<bool, unsigned char *, unsigned int, unsigned char>(gaddrof(CFileLoader::LoadCollisionFileFirstTime), data, dataSize, colId);
  138  }

  143  void CFileLoader::LoadCollisionModel(unsigned char *data, CColModel &outColModel) {
  144:     plugin::CallDynGlobal<unsigned char *, CColModel &>(gaddrof(CFileLoader::LoadCollisionModel), data, outColModel);
  145  }

  150  void CFileLoader::LoadCollisionModelVer2(unsigned char *data, unsigned int dataSize, CColModel &outColModel, char const *modelName) {
  151:     plugin::CallDynGlobal<unsigned char *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer2), data, dataSize, outColModel, modelName);
  152  }

  157  void CFileLoader::LoadCollisionModelVer3(unsigned char *data, unsigned int dataSize, CColModel &outColModel, char const *modelName) {
  158:     plugin::CallDynGlobal<unsigned char *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer3), data, dataSize, outColModel, modelName);
  159  }

  164  void CFileLoader::LoadCollisionModelVer4(void *data, unsigned int dataSize, CColModel &outColModel, char const *modelName) {
  165:     plugin::CallDynGlobal<void *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer4), data, dataSize, outColModel, modelName);
  166  }

  171  void CFileLoader::LoadCullZone(char const *line) {
  172:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadCullZone), line);
  173  }

  178  void CFileLoader::LoadEntryExit(char const *line) {
  179:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadEntryExit), line);
  180  }

  185  void CFileLoader::LoadGarage(char const *line) {
  186:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadGarage), line);
  187  }

  192  void CFileLoader::LoadLevel(char const *filename) {
  193:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadLevel), filename);
  194  }

  199  char *CFileLoader::LoadLine(FILESTREAM file) {
  200:     return plugin::CallAndReturnDynGlobal<char *, FILESTREAM>(gaddrof_o(CFileLoader::LoadLine, char *(*)(FILESTREAM)), file);
  201  }

  206  char *CFileLoader::LoadLine(char **outLine, int &outSize) {
  207:     return plugin::CallAndReturnDynGlobal<char *, char **, int &>(gaddrof_o(CFileLoader::LoadLine, char *(*)(char **, int &)), outLine, outSize);
  208  }

  213  int CFileLoader::LoadObject(char const *line) {
  214:     return plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadObject), line);
  215  }

  220  CEntity *CFileLoader::LoadObjectInstance(CFileObjectInstance *objInstance, char const *modelname) {
  221:     return plugin::CallAndReturnDynGlobal<CEntity *, CFileObjectInstance *, char const *>(gaddrof_o(CFileLoader::LoadObjectInstance, CEntity *(*)(CFileObjectInstance *, char const *)), objInstance, modelname);
  222  }

  227  CEntity *CFileLoader::LoadObjectInstance(char const *line) {
  228:     return plugin::CallAndReturnDynGlobal<CEntity *, char const *>(gaddrof_o(CFileLoader::LoadObjectInstance, CEntity *(*)(char const *)), line);
  229  }

  234  void CFileLoader::LoadObjectTypes(char const *filename) {
  235:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadObjectTypes), filename);
  236  }

  241  void CFileLoader::LoadOcclusionVolume(char const *line, char const *filename) {
  242:     plugin::CallDynGlobal<char const *, char const *>(gaddrof(CFileLoader::LoadOcclusionVolume), line, filename);
  243  }

  248  int CFileLoader::LoadPathHeader(char const *line, int &outPathType) {
  249:     return plugin::CallAndReturnDynGlobal<int, char const *, int &>(gaddrof(CFileLoader::LoadPathHeader), line, outPathType);
  250  }

  255  int CFileLoader::LoadPedObject(char const *line) {
  256:     return plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadPedObject), line);
  257  }

  262  void CFileLoader::LoadPedPathNode(char const *line, int objModelIndex, int pathEntryIndex) {
  263:     plugin::CallDynGlobal<char const *, int, int>(gaddrof(CFileLoader::LoadPedPathNode), line, objModelIndex, pathEntryIndex);
  264  }

  269  void CFileLoader::LoadPickup(char const *line) {
  270:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadPickup), line);
  271  }

  276  void CFileLoader::LoadScene(char const *filename) {
  277:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadScene), filename);
  278  }

  283  void CFileLoader::LoadStuntJump(char const *line) {
  284:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadStuntJump), line);
  285  }

  290  void CFileLoader::LoadTXDParent(char const *line) {
  291:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadTXDParent), line);
  292  }

  297  RwTexDictionary *CFileLoader::LoadTexDictionary(char const *filename) {
  298:     return plugin::CallAndReturnDynGlobal<RwTexDictionary *, char const *>(gaddrof(CFileLoader::LoadTexDictionary), filename);
  299  }

  304  void CFileLoader::LoadTimeCyclesModifier(char const *line) {
  305:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadTimeCyclesModifier), line);
  306  }

  311  int CFileLoader::LoadTimeObject(char const *line) {
  312:     return plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadTimeObject), line);
  313  }

  318  int CFileLoader::LoadVehicleObject(char const *line) {
  319:     return plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadVehicleObject), line);
  320  }

  325  int CFileLoader::LoadWeaponObject(char const *line) {
  326:     return plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadWeaponObject), line);
  327  }

  332  void CFileLoader::LoadZone(char const *line) {
  333:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadZone), line);
  334  }

  339  void CFileLoader::ReloadObjectTypes(char const *arg1) {
  340:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::ReloadObjectTypes), arg1);
  341  }

  346  void CFileLoader::ReloadPaths(char const *filename) {
  347:     plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::ReloadPaths), filename);
  348  }

  353  void CFileLoader::SaveTexDictionary(RwTexDictionary *dictionary, char const *filename) {
  354:     plugin::CallDynGlobal<RwTexDictionary *, char const *>(gaddrof(CFileLoader::SaveTexDictionary), dictionary, filename);
  355  }

  360  RpAtomic *CFileLoader::SetRelatedModelInfoCB(RpAtomic *atomic, void *data) {
  361:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CFileLoader::SetRelatedModelInfoCB), atomic, data);
  362  }

  367  bool CFileLoader::StartLoadClumpFile(RwStream *stream, unsigned int modelIndex) {
  368:     return plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof(CFileLoader::StartLoadClumpFile), stream, modelIndex);
  369  }

  374  void GetNameAndDamage(char const *nodeName, char *outName, bool &outDamage) {
  375:     plugin::CallDynGlobal<char const *, char *, bool &>(gaddrof(GetNameAndDamage), nodeName, outName, outDamage);
  376  }

  381  RpAtomic *CloneAtomicToClumpCB(RpAtomic *atomic, void *data) {
  382:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CloneAtomicToClumpCB), atomic, data);
  383  }

  388  char const *GetFilename(char const *filepath) {
  389:     return plugin::CallAndReturnDynGlobal<char const *, char const *>(gaddrof(GetFilename), filepath);
  390  }

  395  void LoadingScreenLoadingFile(char const *filename) {
  396:     plugin::CallDynGlobal<char const *>(gaddrof(LoadingScreenLoadingFile), filename);
  397  }

  402  RwTexture *AddTextureCB(RwTexture *texture, void *data) {
  403:     return plugin::CallAndReturnDynGlobal<RwTexture *, RwTexture *, void *>(gaddrof(AddTextureCB), texture, data);
  404  }

plugin_sa\game_sa\CFormation.cpp:
  20  void CFormation::DistributeDestinations(CPedList *pedlist) {
  21:     plugin::CallDynGlobal<CPedList *>(gaddrof(CFormation::DistributeDestinations), pedlist);
  22  }

  27  void CFormation::DistributeDestinations_CoverPoints(CPedList *pedlist, CVector pos) {
  28:     plugin::CallDynGlobal<CPedList *, CVector>(gaddrof(CFormation::DistributeDestinations_CoverPoints), pedlist, pos);
  29  }

  34  void CFormation::DistributeDestinations_PedsToAttack(CPedList *pedlist) {
  35:     plugin::CallDynGlobal<CPedList *>(gaddrof(CFormation::DistributeDestinations_PedsToAttack), pedlist);
  36  }

  41  void CFormation::FindCoverPoints(CVector pos, float radius) {
  42:     plugin::CallDynGlobal<CVector, float>(gaddrof(CFormation::FindCoverPoints), pos, radius);
  43  }

  48  void CFormation::FindCoverPointsBehindBox(CPointList *pointlist, CVector Pos, CMatrix *coverEntityMatrix, CVector const *vecCenter, CVector const *vecMin, CVector const *vecMax, float radius) {
  49:     plugin::CallDynGlobal<CPointList *, CVector, CMatrix *, CVector const *, CVector const *, CVector const *, float>(gaddrof(CFormation::FindCoverPointsBehindBox), pointlist, Pos, coverEntityMatrix, vecCenter, vecMin, vecMax, radius);
  50  }

  55  signed int CFormation::FindNearestAvailableDestination(CVector pos, float *pOutDistance) {
  56:     return plugin::CallAndReturnDynGlobal<signed int, CVector, float *>(gaddrof(CFormation::FindNearestAvailableDestination), pos, pOutDistance);
  57  }

  62  void CFormation::GenerateGatherDestinations(CPedList *pedList, CPed *ped) {
  63:     plugin::CallDynGlobal<CPedList *, CPed *>(gaddrof(CFormation::GenerateGatherDestinations), pedList, ped);
  64  }

  69  void CFormation::GenerateGatherDestinations_AroundCar(CPedList *pedlist, CVehicle *vehicle) {
  70:     plugin::CallDynGlobal<CPedList *, CVehicle *>(gaddrof(CFormation::GenerateGatherDestinations_AroundCar), pedlist, vehicle);
  71  }

  76  bool CFormation::ReturnDestinationForPed(CPed *ped, CVector *pos) {
  77:     return plugin::CallAndReturnDynGlobal<bool, CPed *, CVector *>(gaddrof(CFormation::ReturnDestinationForPed), ped, pos);
  78  }

  83  int CFormation::ReturnTargetPedForPed(CPed *ped, CPed **pOutTargetPed) {
  84:     return plugin::CallAndReturnDynGlobal<int, CPed *, CPed **>(gaddrof(CFormation::ReturnTargetPedForPed), ped, pOutTargetPed);
  85  }

plugin_sa\game_sa\CGame.cpp:
   22  bool CGame::CanSeeOutSideFromCurrArea() {
   23:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeOutSideFromCurrArea));
   24  }

   29  bool CGame::CanSeeWaterFromCurrArea() {
   30:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeWaterFromCurrArea));
   31  }

   36  void CGame::DrasticTidyUpMemory(bool a1) {
   37:     plugin::CallDynGlobal<bool>(gaddrof(CGame::DrasticTidyUpMemory), a1);
   38  }

   57  bool CGame::Init1(char const *datFile) {
   58:     return plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init1), datFile);
   59  }

   64  bool CGame::Init2(char const *datFile) {
   65:     return plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init2), datFile);
   66  }

   71  bool CGame::Init3(char const *datFile) {
   72:     return plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init3), datFile);
   73  }

   85  bool CGame::Initialise(char const *datFile) {
   86:     return plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);
   87  }

   92  bool CGame::InitialiseCoreDataAfterRW() {
   93:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseCoreDataAfterRW));
   94  }

   99  bool CGame::InitialiseEssentialsAfterRW() {
  100:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseEssentialsAfterRW));
  101  }

  106  bool CGame::InitialiseOnceBeforeRW() {
  107:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));
  108  }

  113  bool CGame::InitialiseRenderWare() {
  114:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));
  115  }

  155  bool CGame::Shutdown() {
  156:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));
  157  }

  169  void CGame::TidyUpMemory(bool a1, bool clearD3Dmem) {
  170:     plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), a1, clearD3Dmem);
  171  }

  176  bool MoveMem(void **pMem) {
  177:     return plugin::CallAndReturnDynGlobal<bool, void **>(gaddrof(MoveMem), pMem);
  178  }

  183  bool MoveColModelMemory(CColModel &colModel, bool a2) {
  184:     return plugin::CallAndReturnDynGlobal<bool, CColModel &, bool>(gaddrof(MoveColModelMemory), colModel, a2);
  185  }

  190  RpGeometry *MoveGeometryMemory(RpGeometry *geometry) {
  191:     return plugin::CallAndReturnDynGlobal<RpGeometry *, RpGeometry *>(gaddrof(MoveGeometryMemory), geometry);
  192  }

  197  bool TidyUpModelInfo2(CEntity *entity, bool a2) {
  198:     return plugin::CallAndReturnDynGlobal<bool, CEntity *, bool>(gaddrof(TidyUpModelInfo2), entity, a2);
  199  }

  218  bool DoHaspChecks() {
  219:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(DoHaspChecks));
  220  }

plugin_sa\game_sa\CGameLogic.cpp:
   21  void CGameLogic::InitAtStartOfGame() {
   22: 	plugin::Call<0x441210>();
   23  }

   26  bool CGameLogic::IsCoopGameGoingOn() {
   27: 	return plugin::CallAndReturn<bool, 0x441390>();
   28  }

   31  void CGameLogic::Remove2ndPlayerIfPresent() {
   32: 	plugin::Call<0x4413C0>();
   33  }

   36  void CGameLogic::SortOutStreamingAndMemory(CVector *translation, float angle) {
   37: 	plugin::Call<0x441440, CVector*, float>(translation, angle);
   38  }

   41  void CGameLogic::PassTime(unsigned int time) {
   42: 	plugin::Call<0x4414C0, unsigned int>(time);
   43  }

   46  void CGameLogic::ClearSkip(char a1) {
   47: 	plugin::Call<0x441560, char>(a1);
   48  }

   51  bool CGameLogic::SkipCanBeActivated() {
   52: 	return plugin::CallAndReturn<bool, 0x4415C0>();
   53  }

   56  int CGameLogic::IsPointWithinLineArea(RwV3d* vectors, signed int sizeofvectors, float x, float y) {
   57: 	return plugin::CallAndReturn<int, 0x4416E0, RwV3d*, signed int, float, float>(vectors, sizeofvectors, x, y);
   58  }

   61  void CGameLogic::SetPlayerWantedLevelForForbiddenTerritories(char townNumber) {
   62: 	 plugin::Call<0x441770, char>(townNumber);
   63  }

   66  long double CGameLogic::CalcDistanceToForbiddenTrainCrossing(float x1, float y1, float z1, float x2, float y2, float z2, char a7, CVector* a8) {
   67: 	return plugin::CallAndReturn<long double, 0x4418E0, float, float, float, float, float, float, char, CVector*>(x1, y1, z1, x2, y2, z2, a7, a8);
   68  }

   71  bool CGameLogic::LaRiotsActiveHere() {
   72: 	return plugin::CallAndReturn<bool, 0x441C10>();
   73  }

   76  signed int CGameLogic::RestorePedsWeapons(int a1) {
   77: 	return plugin::CallAndReturn<signed int, 0x441D30, int>(a1);
   78  }

   81  bool CGameLogic::IsPlayerAllowedToGoInThisDirection(CPed *a1, float a2, float a3, float a4, float a5) {
   82: 	return plugin::CallAndReturn<bool, 0x441E10, CPed*, float, float, float, float>(a1, a2, a3, a4, a5);
   83  }

   86  void CGameLogic::RestorePlayerStuffDuringResurrection(CPlayerPed *player, float x, float y, float z, float fAngle) {
   87: 	plugin::Call<0x442060, CPlayerPed*, float, float, float, float>(player, x, y, z, fAngle);
   88  }

   91  void CGameLogic::UpdateSkip() {
   92: 	plugin::Call<0x442480>();
   93  }

   96  void CGameLogic::ResetStuffUponResurrection() {
   97: 	plugin::Call<0x442980>();
   98  }

  101  void CGameLogic::Update() {
  102: 	plugin::Call<0x442AD0>();
  103  }

  106  void CGameLogic::Save() {
  107: 	plugin::Call<0x5D33C0>();
  108  }

plugin_sa\game_sa\CGangs.cpp:
  17  signed int CGangs::ChooseGangPedModel(short gangID) {
  18:     return plugin::CallAndReturnDynGlobal<signed int, short>(gaddrof(CGangs::ChooseGangPedModel), gangID);
  19  }

  24  bool CGangs::GetWillAttackPlayerWithCops(ePedType gangID) {
  25:     return plugin::CallAndReturnDynGlobal<bool, ePedType>(gaddrof(CGangs::GetWillAttackPlayerWithCops), gangID);
  26  }

  52  void CGangs::SetGangPedModelOverride(short gangID, signed char PedModelOverride) {
  53:     plugin::CallDynGlobal<short, signed char>(gaddrof(CGangs::SetGangPedModelOverride), gangID, PedModelOverride);
  54  }

  59  void CGangs::SetGangWeapons(short gangID, int weapID1, int weapID2, int weapID3) {
  60:     plugin::CallDynGlobal<short, int, int, int>(gaddrof(CGangs::SetGangWeapons), gangID, weapID1, weapID2, weapID3);
  61  }

  66  void CGangs::SetWillAttackPlayerWithCops(ePedType gangID, bool bAttackPlayerWithCops) {
  67:     plugin::CallDynGlobal<ePedType, bool>(gaddrof(CGangs::SetWillAttackPlayerWithCops), gangID, bAttackPlayerWithCops);
  68  }

plugin_sa\game_sa\CGangWars.cpp:
   42  void CGangWars::AddKillToProvocation(int Pedtype) {
   43:     plugin::CallDynGlobal<int>(gaddrof(CGangWars::AddKillToProvocation), Pedtype);
   44  }

   49  bool CGangWars::AttackWaveOvercome() {
   50:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::AttackWaveOvercome));
   51  }

   56  unsigned int CGangWars::CalculateTimeTillNextAttack() {
   57:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CGangWars::CalculateTimeTillNextAttack));
   58  }

   63  bool CGangWars::CanPlayerStartAGangWarHere(CZoneInfo *zoneInfo) {
   64:     return plugin::CallAndReturnDynGlobal<bool, CZoneInfo *>(gaddrof(CGangWars::CanPlayerStartAGangWarHere), zoneInfo);
   65  }

   91  bool CGangWars::CreateAttackWave(int warFerocity, int waveID) {
   92:     return plugin::CallAndReturnDynGlobal<bool, int, int>(gaddrof(CGangWars::CreateAttackWave), warFerocity, waveID);
   93  }

   98  bool CGangWars::CreateDefendingGroup(int unsued) {
   99:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGangWars::CreateDefendingGroup), unsued);
  100  }

  112  bool CGangWars::DoesPlayerControlThisZone(CZoneInfo *zoneinfo) {
  113:     return plugin::CallAndReturnDynGlobal<bool, CZoneInfo *>(gaddrof(CGangWars::DoesPlayerControlThisZone), zoneinfo);
  114  }

  119  bool CGangWars::DontCreateCivilians() {
  120:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::DontCreateCivilians));
  121  }

  126  void CGangWars::EndGangWar(bool bEnd) {
  127:     plugin::CallDynGlobal<bool>(gaddrof(CGangWars::EndGangWar), bEnd);
  128  }

  133  bool CGangWars::GangWarFightingGoingOn() {
  134:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::GangWarFightingGoingOn));
  135  }

  140  bool CGangWars::GangWarGoingOn() {
  141:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::GangWarGoingOn));
  142  }

  161  void CGangWars::MakeEnemyGainInfluenceInZone(int GangID, int GangDensityIncreaser) {
  162:     plugin::CallDynGlobal<int, int>(gaddrof(CGangWars::MakeEnemyGainInfluenceInZone), GangID, GangDensityIncreaser);
  163  }

  168  bool CGangWars::MakePlayerGainInfluenceInZone(float remove_mult) {
  169:     return plugin::CallAndReturnDynGlobal<bool, float>(gaddrof(CGangWars::MakePlayerGainInfluenceInZone), remove_mult);
  170  }

  175  bool CGangWars::PedStreamedInForThisGang(int gangID) {
  176:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGangWars::PedStreamedInForThisGang), gangID);
  177  }

  182  bool CGangWars::PickStreamedInPedForThisGang(int gangID, int *outPedID) {
  183:     return plugin::CallAndReturnDynGlobal<bool, int, int *>(gaddrof(CGangWars::PickStreamedInPedForThisGang), gangID, outPedID);
  184  }

  189  bool CGangWars::PickZoneToAttack() {
  190:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::PickZoneToAttack));
  191  }

  203  int CGangWars::ReleasePedsInAttackWave(bool IsEndOfWar, bool RestoreGangPedsAcquaintance) {
  204:     return plugin::CallAndReturnDynGlobal<int, bool, bool>(gaddrof(CGangWars::ReleasePedsInAttackWave), IsEndOfWar, RestoreGangPedsAcquaintance);
  205  }

  217  void CGangWars::SetGangWarsActive(bool bActive) {
  218:     plugin::CallDynGlobal<bool>(gaddrof(CGangWars::SetGangWarsActive), bActive);
  219  }

  224  void CGangWars::SetSpecificZoneToTriggerGangWar(int zoneId) {
  225:     plugin::CallDynGlobal<int>(gaddrof(CGangWars::SetSpecificZoneToTriggerGangWar), zoneId);
  226  }

  245  void CGangWars::StrengthenPlayerInfluenceInZone(int GroveDensityIncreaser) {
  246:     plugin::CallDynGlobal<int>(gaddrof(CGangWars::StrengthenPlayerInfluenceInZone), GroveDensityIncreaser);
  247  }

  259  void CGangWars::TellGangMembersTo(int bIsGangWarEnding) {
  260:     plugin::CallDynGlobal<int>(gaddrof(CGangWars::TellGangMembersTo), bIsGangWarEnding);
  261  }

  266  void CGangWars::TellStreamingWhichGangsAreNeeded(int *GangsBitFlags) {
  267:     plugin::CallDynGlobal<int *>(gaddrof(CGangWars::TellStreamingWhichGangsAreNeeded), GangsBitFlags);
  268  }

plugin_sa\game_sa\CGangWarsSaveStructure.cpp:
  14  void CGangWarsSaveStructure::Construct() {
  15:     plugin::CallMethodDynGlobal<CGangWarsSaveStructure *>(gaddrof(CGangWarsSaveStructure::Construct), this);
  16  }

  21  void CGangWarsSaveStructure::Extract() {
  22:     plugin::CallMethodDynGlobal<CGangWarsSaveStructure *>(gaddrof(CGangWarsSaveStructure::Extract), this);
  23  }

plugin_sa\game_sa\CGenericGameStorage.cpp:
   30  bool CGenericGameStorage::CheckDataNotCorrupt(int saveID, char *saveGameFilename) {
   31:     return plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CGenericGameStorage::CheckDataNotCorrupt), saveID, saveGameFilename);
   32  }

   37  bool CGenericGameStorage::CheckSlotDataValid(int saveID, bool unused) {
   38:     return plugin::CallAndReturnDynGlobal<bool, int, bool>(gaddrof(CGenericGameStorage::CheckSlotDataValid), saveID, unused);
   39  }

   58  bool CGenericGameStorage::GenericLoad(bool *arg1) {
   59:     return plugin::CallAndReturnDynGlobal<bool, bool *>(gaddrof(CGenericGameStorage::GenericLoad), arg1);
   60  }

   65  bool CGenericGameStorage::GenericSave(int unused) {
   66:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGenericGameStorage::GenericSave), unused);
   67  }

   72  int CGenericGameStorage::GetCurrentVersionNumber() {
   73:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CGenericGameStorage::GetCurrentVersionNumber));
   74  }

   79  char *CGenericGameStorage::GetNameOfSavedGame(int saveID) {
   80:     return plugin::CallAndReturnDynGlobal<char *, int>(gaddrof(CGenericGameStorage::GetNameOfSavedGame), saveID);
   81  }

   86  char *CGenericGameStorage::GetNameOfSavedGame_Alt(int saveID) {
   87:     return plugin::CallAndReturnDynGlobal<char *, int>(gaddrof(CGenericGameStorage::GetNameOfSavedGame_Alt), saveID);
   88  }

   93  int CGenericGameStorage::GetSavedRadioStationPosition() {
   94:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CGenericGameStorage::GetSavedRadioStationPosition));
   95  }

  114  bool CGenericGameStorage::LoadWorkBuffer() {
  115:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGenericGameStorage::LoadWorkBuffer));
  116  }

  121  void CGenericGameStorage::MakeValidSaveName(int saveNum) {
  122:     plugin::CallDynGlobal<int>(gaddrof(CGenericGameStorage::MakeValidSaveName), saveNum);
  123  }

  128  bool CGenericGameStorage::OpenFileForReading(char *saveGameFilename, unsigned int *saveID) {
  129:     return plugin::CallAndReturnDynGlobal<bool, char *, unsigned int *>(gaddrof(CGenericGameStorage::OpenFileForReading), saveGameFilename, saveID);
  130  }

  135  bool CGenericGameStorage::OpenFileForWriting() {
  136:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGenericGameStorage::OpenFileForWriting));
  137  }

  142  void CGenericGameStorage::ReportError(eSaveLoadBlocks block, eSaveLoadError errorType) {
  143:     plugin::CallDynGlobal<eSaveLoadBlocks, eSaveLoadError>(gaddrof(CGenericGameStorage::ReportError),block,errorType);
  144  }

  149  char CGenericGameStorage::RestoreForStartLoad() {
  150:     return plugin::CallAndReturnDynGlobal<char>(gaddrof(CGenericGameStorage::RestoreForStartLoad));
  151  }

  156  bool CGenericGameStorage::SaveWorkBuffer(bool a1) {
  157:     return plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CGenericGameStorage::SaveWorkBuffer), a1);
  158  }

  163  bool CGenericGameStorage::_LoadDataFromWorkBuffer(void *pData, int size) {
  164:     return plugin::CallAndReturnDynGlobal<bool, void *, int>(gaddrof(CGenericGameStorage::_LoadDataFromWorkBuffer), pData, size);
  165  }

  170  bool CGenericGameStorage::_SaveDataToWorkBuffer(void *pData, int Size) {
  171:     return plugin::CallAndReturnDynGlobal<bool, void *, int>(gaddrof(CGenericGameStorage::_SaveDataToWorkBuffer), pData, Size);
  172  }

plugin_sa\game_sa\CGridRef.cpp:
  16  char *CGridRef::GetAreaName(unsigned char sectorX, unsigned char sectorY) {
  17:     return plugin::CallAndReturnDynGlobal<char *, unsigned char, unsigned char>(gaddrof(CGridRef::GetAreaName), sectorX, sectorY);
  18  }

  23  unsigned int CGridRef::GetArtistBugstarID(unsigned char sectorX, unsigned char sectorY) {
  24:     return plugin::CallAndReturnDynGlobal<unsigned int, unsigned char, unsigned char>(gaddrof(CGridRef::GetArtistBugstarID), sectorX, sectorY);
  25  }

  30  void CGridRef::GetGridRefPositions(CVector posn, unsigned char *outSectorX, unsigned char *outSectorY) {
  31:     plugin::CallDynGlobal<CVector, unsigned char *, unsigned char *>(gaddrof_o(CGridRef::GetGridRefPositions, void (*)(CVector, unsigned char *, unsigned char *)), posn, outSectorX, outSectorY);
  32  }

  37  void CGridRef::GetGridRefPositions(unsigned char *outSectorX, unsigned char *outSectorY) {
  38:     plugin::CallDynGlobal<unsigned char *, unsigned char *>(gaddrof_o(CGridRef::GetGridRefPositions, void (*)(unsigned char *, unsigned char *)), outSectorX, outSectorY);
  39  }

plugin_sa\game_sa\CHud.cpp:
   78  void CHud::Draw() {
   79:     plugin::Call<0x58FAE0>();
   80  }

   83  void CHud::DrawAfterFade() {
   84:     plugin::Call<0x58D490>();
   85  }

   88  void CHud::DrawAreaName() {
   89:     plugin::Call<0x58AA50>();
   90  }

   93  void CHud::DrawBustedWastedMessage() {
   94:     plugin::Call<0x58CA50>();
   95  }

   98  void CHud::DrawCrossHairs() {
   99:     plugin::Call<0x58E020>();
  100  }

  103  float CHud::DrawFadeState(DRAW_FADE_STATE fadeState, int arg1) {
  104:     return plugin::CallAndReturn<float, 0x58D580, DRAW_FADE_STATE, int>(fadeState, arg1);
  105  }

  108  void CHud::DrawHelpText() {
  109:     plugin::Call<0x58B6E0>();
  110  }

  113  void CHud::DrawMissionTimers() {
  114:     plugin::Call<0x58B180>();
  115  }

  118  void CHud::DrawMissionTitle() {
  119:     plugin::Call<0x58D240>();
  120  }

  123  void CHud::DrawOddJobMessage(unsigned char priority) {
  124:     plugin::Call<0x58CC80, unsigned char>(priority);
  125  }

  128  void CHud::DrawRadar() {
  129:     plugin::Call<0x58A330>();
  130  }

  133  void CHud::DrawScriptText(unsigned char priority) {
  134:     plugin::Call<0x58C080, unsigned char>(priority);
  135  }

  138  void CHud::DrawSubtitles() {
  139:     plugin::Call<0x58C250>();
  140  }

  143  void CHud::DrawSuccessFailedMessage() {
  144:     plugin::Call<0x58C6A0>();
  145  }

  148  void CHud::DrawVehicleName() {
  149:     plugin::Call<0x58AEA0>();
  150  }

  153  void CHud::DrawVitalStats() {
  154:     plugin::Call<0x589650>();
  155  }

  158  void CHud::GetRidOfAllHudMessages(unsigned char arg0) {
  159:     plugin::Call<0x588A50, unsigned char>(arg0);
  160  }

  163  float CHud::GetYPosBasedOnHealth(unsigned char playerId, float pos, char offset) {
  164:     return plugin::CallAndReturn<float, 0x588B60, unsigned char, float, signed>(playerId, pos, offset);
  165  }

  167  bool CHud::HelpMessageDisplayed() {
  168:     return plugin::CallAndReturn<bool, 0x588B50>();
  169  }

  172  void CHud::Initialise() {
  173:     plugin::Call<0x5BA850>();
  174  }

  177  void CHud::ReInitialise() {
  178:     plugin::Call<0x588880>();
  179  }

  182  void CHud::ResetWastedText() {
  183:     plugin::Call<0x589070>();
  184  }

  187  void CHud::SetBigMessage(char* text, unsigned short style) {
  188:     plugin::Call<0x588FC0, char*, unsigned short>(text, style);
  189  }

  192  void CHud::SetHelpMessage(char const* text, bool quickMessage, bool permanent, bool addToBrief) {
  193:     plugin::Call<0x588BE0, char const*, bool, bool, bool>(text, quickMessage, permanent, addToBrief);
  194  }

  197  void CHud::SetHelpMessageStatUpdate(unsigned char state, unsigned short statId, float diff, float max) {
  198:     plugin::Call<0x588D40, unsigned char, unsigned short, float, float>(state, statId, diff, max);
  199  }

  201  void CHud::SetHelpMessageWithNumber(char const* text, int number, bool quickMessage, bool permanent) {
  202:     plugin::Call<0x588E30, char const*, int, bool, bool>(text, number, quickMessage, permanent);
  203  }

  206  void CHud::SetMessage(char* text) {
  207:     plugin::Call<0x588F60, char*>(text);
  208  }

  211  void CHud::SetVehicleName(char* name) {
  212:     plugin::Call<0x588F50, char*>(name);
  213  }

  216  void CHud::SetZoneName(char* name, unsigned char displayState) {
  217:     plugin::Call<0x588BB0, char*, unsigned char>(name, displayState);
  218  }

  221  void CHud::Shutdown() {
  222:     plugin::Call<0x588850>();
  223  }

  226  void CHud::DrawAmmo(CPed* ped, int x, int y, float alpha) {
  227:     plugin::Call<0x5893B0, CPed*, int, int, float>(ped, x, y, alpha);
  228  }

  231  void CHud::DrawPlayerInfo() {
  232:     plugin::Call<0x58EAF0>();
  233  }

  236  void CHud::DrawTripSkip() {
  237:     plugin::Call<0x58A160>();
  238  }

  241  void CHud::DrawWanted() {
  242:     plugin::Call<0x58D9A0>();
  243  }

  246  void CHud::DrawWeaponIcon(CPed* ped, int x, int y, float alpha) {
  247:     plugin::Call<0x58D7D0, CPed*, int, int, float>(ped, x, y, alpha);
  248  }

  251  void CHud::RenderArmorBar(int playerId, int x, int y) {
  252:     plugin::Call<0x5890A0, int, int, int>(playerId, x, y);
  253  }

  256  void CHud::RenderBreathBar(int playerId, int x, int y) {
  257:     plugin::Call<0x589190, int, int, int>(playerId, x, y);
  258  }

  261  void CHud::RenderHealthBar(int playerId, int x, int y) {
  262:     plugin::Call<0x589270, int, int, int>(playerId, x, y);
  263  }

plugin_sa\game_sa\CIplStore.cpp:
   24  int CIplStore::AddIplSlot(char const* name) {
   25:     return plugin::CallAndReturn<int, 0x405AC0, char const*>(name);
   26  }

   29  void CIplStore::AddIplsNeededAtPosn(CVector const& posn) {
   30:     plugin::Call<0x4045B0, CVector const&>(posn);
   31  }

   34  void CIplStore::ClearIplsNeededAtPosn() {
   35:     plugin::Call<0x4045E0>();
   36  }

   39  void CIplStore::EnableDynamicStreaming(int iplSlotIndex, bool enable) {
   40:     plugin::Call<0x404D30, int, bool>(iplSlotIndex, enable);
   41  }

   44  void CIplStore::EnsureIplsAreInMemory(CVector const& posn) {
   45:     plugin::Call<0x4053F0, CVector const&>(posn);
   46  }

   49  int CIplStore::FindIplSlot(char const* name) {
   50:     return plugin::CallAndReturn<int, 0x404AC0, char const*>(name);
   51  }

   54  CRect* CIplStore::GetBoundingBox(int iplSlotIndex) {
   55:     return plugin::CallAndReturn<CRect*, 0x404C70, int>(iplSlotIndex);
   56  }

   59  int* CIplStore::GetIplEntityIndexArray(int arrayIndex) {
   60:     return plugin::CallAndReturn<int*, 0x4047B0, int>(arrayIndex);
   61  }

   64  char* CIplStore::GetIplName(int iplSlotIndex) {
   65:     return plugin::CallAndReturn<char*, 0x404A60, int>(iplSlotIndex);
   66  }

   69  int CIplStore::GetNewIplEntityIndexArray(int entitiesCount) {
   70:     return plugin::CallAndReturn<int, 0x404780, int>(entitiesCount);
   71  }

   74  bool CIplStore::HaveIplsLoaded(CVector const& coords, int playerNumber) {
   75:     return plugin::CallAndReturn<bool, 0x405600, CVector const&, int>(coords, playerNumber);
   76  }

   79  void CIplStore::IncludeEntity(int iplSlotIndex, CEntity* entity) {
   80:     plugin::Call<0x404C90, int, CEntity*>(iplSlotIndex, entity);
   81  }

   84  void CIplStore::Initialise() {
   85:     plugin::Call<0x405EC0>();
   86  }

   89  bool CIplStore::Load() {
   90:     return plugin::CallAndReturn<bool, 0x5D54A0>();
   91  }

   94  void CIplStore::LoadAllRemainingIpls() {
   95:     plugin::Call<0x405780>();
   96  }

   99  bool CIplStore::LoadIpl(int iplSlotIndex, unsigned char* data, int dataSize) {
  100:     return plugin::CallAndReturn<bool, 0x406080, int, unsigned char*, int>(iplSlotIndex, data, dataSize);
  101  }

  104  bool CIplStore::LoadIplBoundingBox(int iplSlotIndex, unsigned char* data, int dataSize) {
  105:     return plugin::CallAndReturn<bool, 0x405C00, int, unsigned char*, int>(iplSlotIndex, data, dataSize);
  106  }

  109  void CIplStore::LoadIpls(CVector posn, bool arg1) {
  110:     plugin::Call<0x405170, CVector, bool>(posn, arg1);
  111  }

  114  void CIplStore::RemoveAllIpls() {
  115:     plugin::Call<0x405720>();
  116  }

  119  void CIplStore::RemoveIpl(int iplSlotIndex) {
  120:     plugin::Call<0x404B20, int>(iplSlotIndex);
  121  }

  124  void CIplStore::RemoveIplAndIgnore(int iplSlotIndex) {
  125:     plugin::Call<0x405890, int>(iplSlotIndex);
  126  }

  129  void CIplStore::RemoveIplSlot(int iplSlotIndex) {
  130:     plugin::Call<0x405B60, int>(iplSlotIndex);
  131  }

  134  void CIplStore::RemoveIplWhenFarAway(int iplSlotIndex) {
  135:     plugin::Call<0x4058D0, int>(iplSlotIndex);
  136  }

  139  void CIplStore::RemoveRelatedIpls(int entityArraysIndex) {
  140:     plugin::Call<0x405110, int>(entityArraysIndex);
  141  }

  144  void CIplStore::RequestIplAndIgnore(int iplSlotIndex) {
  145:     plugin::Call<0x405850, int>(iplSlotIndex);
  146  }

  149  void CIplStore::RequestIpls(CVector const& posn, int playerNumber) {
  150:     plugin::Call<0x405520, CVector const&, int>(posn, playerNumber);
  151  }

  154  bool CIplStore::Save() {
  155:     return plugin::CallAndReturn<bool, 0x5D5420>();
  156  }

  159  void CIplStore::SetIplsRequired(CVector const& posn, int playerNumber) {
  160:     plugin::Call<0x404700, CVector const&, int>(posn, playerNumber);
  161  }

  164  void CIplStore::SetIsInterior(int iplSlotIndex, bool isInterior) {
  165:     plugin::Call<0x404A90, int, bool>(iplSlotIndex, isInterior);
  166  }

  169  int CIplStore::SetupRelatedIpls(char const* iplName, int entityArraysIndex, CEntity** instances) {
  170:     return plugin::CallAndReturn<int, 0x404DE0, char const*, int, CEntity**>(iplName, entityArraysIndex, instances);
  171  }

  174  void CIplStore::Shutdown() {
  175:     plugin::Call<0x405FA0>();
  176  }

  179  void SetIfInteriorIplIsRequired(CVector2D const& posn, void* data) {
  180:     plugin::Call<0x4045F0, CVector2D const&, void*>(posn, data);
  181  }

  184  void SetIfIplIsRequired(CVector2D const& posn, void* data) {
  185:     plugin::Call<0x404660, CVector2D const&, void*>(posn, data);
  186  }

  189  void SetIfIplIsRequiredReducedBB(CVector2D const& posn, void* data) {
  190:     plugin::Call<0x404690, CVector2D const&, void*>(posn, data);
  191  }

plugin_sa\game_sa\CLoadedCarGroup.cpp:
  10  void CLoadedCarGroup::SortBasedOnUsage() {
  11: 	plugin::CallMethod<0x611E10, CLoadedCarGroup *>(this);
  12  }

  15  int CLoadedCarGroup::RemoveMember(int modelindex) {
  16: 	return plugin::CallMethodAndReturn<int, 0x611BD0, CLoadedCarGroup *, int>(this, modelindex);
  17  }

  20  int CLoadedCarGroup::PickRandomCar(bool arg1, bool arg2) {
  21: 	return plugin::CallMethodAndReturn<int, 0x611C50, CLoadedCarGroup *, bool, bool>(this, arg1, arg2);
  22  }

  25  int CLoadedCarGroup::PickLeastUsedModel(int minRefs) {
  26: 	return plugin::CallMethodAndReturn<int, 0x611E90, CLoadedCarGroup *, int>(this, minRefs);
  27  }

  30  int CLoadedCarGroup::GetMember(int count) {
  31: 	return plugin::CallMethodAndReturn<int, 0x611C20, CLoadedCarGroup *, int>(this, count);
  32  }

  35  unsigned int CLoadedCarGroup::CountMembers() {
  36: 	return plugin::CallMethodAndReturn<unsigned int, 0x611C30, CLoadedCarGroup *>(this);
  37  }

  40  void CLoadedCarGroup::Clear() {
  41: 	plugin::CallMethod<0x611B90, CLoadedCarGroup *>(this);
  42  }

  45  void CLoadedCarGroup::AddMember(int member) {
  46: 	plugin::CallMethod<0x611BB0, CLoadedCarGroup *, int>(this, member);
  47  }

plugin_sa\game_sa\CLoadingScreen.cpp:
   32  void CLoadingScreen::Shutdown() {
   33:     plugin::Call<0x58FF10>();
   34  }

   37  void CLoadingScreen::RenderSplash() {
   38:     plugin::Call<0x58FF60>();
   39  }

   42  void CLoadingScreen::LoadSplashes(unsigned char bStarting, unsigned char bNvidia) {
   43:     plugin::Call<0x5900B0, unsigned char, unsigned char>(bStarting, bNvidia);
   44  }

   47  void CLoadingScreen::DisplayMessage(char const* message) {
   48:     plugin::Call<0x590220, char const*>(message);
   49  }

   52  void CLoadingScreen::SetLoadingBarMsg(char const* msg1, char const* msg2) {
   53:     plugin::Call<0x590240, char const*, char const*>(msg1, msg2);
   54  }

   57  double CLoadingScreen::GetClockTime(bool bIgnorePauseTime) {
   58:     return plugin::CallAndReturn<double, 0x590280, bool>(bIgnorePauseTime);
   59  }

   62  void CLoadingScreen::Init(bool unusedflag, bool bLoaded) {
   63:     plugin::Call<0x5902B0, bool, bool>(unusedflag, bLoaded);
   64  }

   67  void CLoadingScreen::Continue() {
   68:     plugin::Call<0x590320>();
   69  }

   72  void CLoadingScreen::RenderLoadingBar() {
   73:     plugin::Call<0x590370>();
   74  }

   77  void CLoadingScreen::DisplayNextSplash() {
   78:     plugin::Call<0x5904D0>();
   79  }

   82  void CLoadingScreen::StartFading() {
   83:     plugin::Call<0x590530>();
   84  }

   87  void CLoadingScreen::DisplayPCScreen() {
   88:     plugin::Call<0x590570>();
   89  }

   92  void CLoadingScreen::Update() {
   93:     plugin::Call<0x5905E0>();
   94  }

   97  void CLoadingScreen::DoPCTitleFadeOut() {
   98:     plugin::Call<0x590990>();
   99  }

  102  void CLoadingScreen::DoPCTitleFadeIn() {
  103:     plugin::Call<0x590860>();
  104  }

  107  void CLoadingScreen::DoPCScreenChange(unsigned int bFinish) {
  108:     plugin::Call<0x590AC0, unsigned int>(bFinish);
  109  }

  112  void CLoadingScreen::NewChunkLoaded() {
  113:     plugin::Call<0x590D00>();
  114  }

plugin_sa\game_sa\CMatrix.cpp:
  166  void CMatrix::Scale(float scale) {
  167:     plugin::CallMethod<0x459350, CMatrix *, float>(this, scale);
  168  }

  170  void CMatrix::Scale(float x, float y, float z) {
  171:     plugin::CallMethod<0x459350, CMatrix *, float, float, float>(this, x, y, z);
  172  }

plugin_sa\game_sa\CMatrixLink.cpp:
  20  void CMatrixLink::Insert(CMatrixLink *where) {
  21:     plugin::CallMethodDynGlobal<CMatrixLink *, CMatrixLink *>(gaddrof(CMatrixLink::Insert), this, where);
  22  }

  27  void CMatrixLink::Remove() {
  28:     plugin::CallMethodDynGlobal<CMatrixLink *>(gaddrof(CMatrixLink::Remove), this);
  29  }

plugin_sa\game_sa\CMenuManager.cpp:
   26  CMenuManager::CMenuManager() {
   27:     plugin::CallMethod<0x574350, CMenuManager*>(this);
   28  }

   30  CMenuManager::~CMenuManager() {
   31:     plugin::CallMethod<0x579440, CMenuManager*>(this);
   32  }

   34  char CMenuManager::AdditionalOptionInput(char input, char enter) {
   35:     return plugin::CallMethodAndReturn<char, 0x5773D0, CMenuManager*, char, char>(this, input, enter);
   36  }

   38  void CMenuManager::CentreMousePointer() {
   39:     plugin::CallMethod<0x57C520, CMenuManager*>(this);
   40  }

   42  bool CMenuManager::CheckCodesForControls(int code) {
   43:     return plugin::CallMethodAndReturn<char, 0x57DB20, CMenuManager*, int>(this, code);
   44  }

   46  bool CMenuManager::CheckFrontEndDownInput() {
   47:     return plugin::CallMethodAndReturn<char, 0x5738B0, CMenuManager*>(this);
   48  }

   50  bool CMenuManager::CheckFrontEndLeftInput() {
   51:     return plugin::CallMethodAndReturn<char, 0x573920, CMenuManager*>(this);
   52  }

   54  bool CMenuManager::CheckFrontEndRightInput() {
   55:     return plugin::CallMethodAndReturn<char, 0x573990, CMenuManager*>(this);
   56  }

   58  bool CMenuManager::CheckFrontEndUpInput() {
   59:     return plugin::CallMethodAndReturn<char, 0x573840, CMenuManager*>(this);
   60  }

   62  bool CMenuManager::CheckHover(float x1, float x2, float y1, float y2) {
   63:     return plugin::CallMethodAndReturn<bool, 0x57C4F0, CMenuManager*>(this, x1, x2, y1, y2);
   64  }

   66  bool CMenuManager::CheckMissionPackValidMenu() {
   67:     return plugin::CallMethodAndReturn<char, 0x57D720, CMenuManager*>(this);
   68  }

   70  bool CMenuManager::CheckRedefineControlInput() {
   71:     return plugin::CallMethodAndReturn<char, 0x57E4D0, CMenuManager*>(this);
   72  }

   74  void CMenuManager::CheckSliderMovement(float input) {
   75:     plugin::CallMethod<0x57E4D0, CMenuManager*>(this, input);
   76  }

   78  void CMenuManager::DisplayHelperText(char* text) {
   79:     plugin::CallMethod<0x57E4D0, CMenuManager*>(this, text);
   80  }

   82  int CMenuManager::DisplaySlider(float posX, float posY, float beginHeight, float endHeight, float distBetweenRects, float filledAmount, CRGBA const& colour) {
   83:     return plugin::CallMethodAndReturn<int, 0x576860, CMenuManager*>(this, posX, posY, beginHeight, endHeight, distBetweenRects, filledAmount, colour);
   84  }

   86  signed int CMenuManager::DoSettingsBeforeStartingAGame() {
   87:     return plugin::CallMethodAndReturn<signed int, 0x573330, CMenuManager*>(this);
   88  }

   90  char CMenuManager::DrawBackground() {
   91:     return plugin::CallMethodAndReturn<char, 0x57B750, CMenuManager*>(this);
   92  }

   94  char CMenuManager::DrawControllerScreenExtraText(int unk) {
   95:     return plugin::CallMethodAndReturn<char, 0x57D8D0, CMenuManager*>(this, unk);
   96  }

   98  char CMenuManager::DrawControllerSetupScreen() {
   99:     return plugin::CallMethodAndReturn<char, 0x57F300, CMenuManager*>(this);
  100  }

  102  void CMenuManager::DrawFrontEnd() {
  103:     plugin::CallMethod<0x57C290, CMenuManager*>(this);
  104  }

  106  void CMenuManager::DrawQuitGameScreen(int unused) {
  107:     plugin::CallMethod<0x57D860, CMenuManager*>(this, unused);
  108  }

  110  void CMenuManager::DrawStandardMenu(bool header) {
  111:     plugin::CallMethod<0x5794A0, CMenuManager*>(this, header);
  112  }

  114  void CMenuManager::DrawWindow(const CRect& coords, const char* pKey, unsigned char nColour, CRGBA backColor, bool Unused, bool bBackground) {
  115:     plugin::CallMethod<0x573EE0, CMenuManager*>(this, coords, pKey, nColour, backColor, Unused, bBackground);
  116  }

  118  void CMenuManager::DrawWindowedText(float x1, float y1, float x2, float y2, char* gxt, int align) {
  119:     plugin::CallMethod<0x578F50, CMenuManager*>(this, x1, y1, x2, y2, gxt, align);
  120  }

  122  unsigned char CMenuManager::GetNumberOfMenuOptions() {
  123:     return plugin::CallMethodAndReturn<unsigned char, 0x573E70, CMenuManager*>(this);
  124  }

  126  bool CMenuManager::HasLanguageChanged() {
  127:     return plugin::CallMethodAndReturn<bool, 0x573CD0, CMenuManager*>(this);
  128  }

  130  void CMenuManager::Initialise() {
  131:     plugin::CallMethod<0x5744D0, CMenuManager*>(this);
  132  }

  134  void CMenuManager::InitialiseChangedLanguageSettings(bool reInitControls) {
  135:     plugin::CallMethod<0x573260, CMenuManager*>(this, reInitControls);
  136  }

  138  int CMenuManager::JumpToGenericMessageScreen(char screen, char* header, char* action) {
  139:     return plugin::CallMethodAndReturn<int, 0x576AE0, CMenuManager*>(this, screen, header, action);
  140  }

  142  void CMenuManager::LoadAllTextures() {
  143:     plugin::CallMethod<0x572EC0, CMenuManager*>(this);
  144  }

  146  void CMenuManager::LoadSettings() {
  147:     plugin::CallMethod<0x57C8F0, CMenuManager*>(this);
  148  }

  150  void CMenuManager::MessageScreen(char* message, CRGBA const& col, bool frame) {
  151:     plugin::CallMethod<0x579330, CMenuManager*>(this, message, col, frame);
  152  }

  154  float CMenuManager::PrintBriefs() {
  155:     return plugin::CallMethodAndReturn<float, 0x576320, CMenuManager*>(this);
  156  }

  158  char CMenuManager::PrintMap() {
  159:     return plugin::CallMethodAndReturn<char, 0x575130, CMenuManager*>(this);
  160  }

  162  char CMenuManager::PrintRadioStationList() {
  163:     return plugin::CallMethodAndReturn<char, 0x5746F0, CMenuManager*>(this);
  164  }

  166  char CMenuManager::PrintStats() {
  167:     return plugin::CallMethodAndReturn<char, 0x574900, CMenuManager*>(this);
  168  }

  170  int CMenuManager::Process() {
  171:     return plugin::CallMethodAndReturn<int, 0x57B440, CMenuManager*>(this);
  172  }

  174  void CMenuManager::ProcessFileActions() {
  175:     plugin::CallMethod<0x578D60, CMenuManager*>(this);
  176  }

  178  void CMenuManager::ProcessMenuOptions(char input, char* exit, char enter) {
  179:     plugin::CallMethod<0x576FE0, CMenuManager*>(this, input, exit, enter);
  180  }

  182  void CMenuManager::ProcessMissionPackNewGame() {
  183:     plugin::CallMethod<0x57D520, CMenuManager*>(this);
  184  }

  186  char CMenuManager::ProcessPCMenuOptions(char input, char enter) {
  187:     return plugin::CallMethodAndReturn<char, 0x57CD50, CMenuManager*>(this, input, enter);
  188  }

  190  void CMenuManager::ProcessStreaming(bool all) {
  191:     plugin::CallMethod<0x573CF0, CMenuManager*>(this, all);
  192  }

  194  void CMenuManager::ProcessUserInput(char down, char up, char enter, char exit, char input) {
  195:     plugin::CallMethod<0x57B480, CMenuManager*>(this, down, up, enter, exit, input);
  196  }

  198  char CMenuManager::RedefineScreenUserInput(int enter, int exit) {
  199:     return plugin::CallMethodAndReturn<char, 0x57EF50, CMenuManager*>(this, enter, exit);
  200  }

  202  void CMenuManager::ResetHelperText() {
  203:     plugin::CallMethod<0x57CD30, CMenuManager*>(this);
  204  }

  206  void CMenuManager::SaveLoadFileError_SetUpErrorScreen() {
  207:     plugin::CallMethod<0x57C490, CMenuManager*>(this);
  208  }

  210  void CMenuManager::SaveSettings() {
  211:     plugin::CallMethod<0x57C660, CMenuManager*>(this);
  212  }

  214  int CMenuManager::SaveStatsToFile() {
  215:     return plugin::CallMethodAndReturn<int, 0x57DDE0, CMenuManager*>(this);
  216  }

  218  void CMenuManager::ScrollRadioStations(char input) {
  219:     plugin::CallMethod<0x573A00, CMenuManager*>(this, input);
  220  }

  222  char CMenuManager::SetDefaultPreferences(char page) {
  223:     return plugin::CallMethodAndReturn<char, 0x573AE0, CMenuManager*>(this, page);
  224  }

  226  void CMenuManager::SetFrontEndRenderStates() {
  227:     plugin::CallMethod<0x573A60, CMenuManager*>(this);
  228  }

  230  int CMenuManager::SetHelperText(int index) {
  231:     return plugin::CallMethodAndReturn<int, 0x57CD10, CMenuManager*>(this, index);
  232  }

  234  void CMenuManager::SmallMessageScreen(char* message) {
  235:     plugin::CallMethod<0x574010, CMenuManager*>(this, message);
  236  }

  238  float CMenuManager::StretchX(float x) {
  239:     return plugin::CallMethodAndReturn<float, 0x5733E0, CMenuManager*>(this, x);
  240  }

  242  float CMenuManager::StretchY(float y) {
  243:     return plugin::CallMethodAndReturn<float, 0x573410, CMenuManager*>(this, y);
  244  }

  246  void CMenuManager::SwapTexturesRound(bool force) {
  247:     plugin::CallMethod<0x5730A0, CMenuManager*>(this, force);
  248  }

  250  void CMenuManager::SwitchMenuOnAndOff() {
  251:     plugin::CallMethod<0x576B70, CMenuManager*>(this);
  252  }

  254  char CMenuManager::SwitchToNewScreen(char page) {
  255:     return plugin::CallMethodAndReturn<char, 0x573680, CMenuManager*>(this, page);
  256  }

  258  void CMenuManager::UnloadTextures() {
  259:     plugin::CallMethod<0x574630, CMenuManager*>(this);
  260  }

  262  void CMenuManager::UserInput() {
  263:     plugin::CallMethod<0x57FD70, CMenuManager*>(this);
  264  }

plugin_sa\game_sa\CMirrors.cpp:
  21  void CMirrors::BeforeConstructRenderList() {
  22:     plugin::Call<0x726DF0>();
  23  }

  26  void CMirrors::BeforeMainRender() {
  27:     plugin::Call<0x727140>();
  28  }

  31  void CMirrors::BuildCamMatrix(CMatrix* mat, CVector pointA, CVector pointB) {
  32:     plugin::Call<0x723150, CMatrix*, CVector, CVector>(mat, pointA, pointB);
  33  }

  36  void CMirrors::BuildCameraMatrixForScreens(CMatrix* mat) {
  37:     plugin::Call<0x7266B0, CMatrix*>(mat);
  38  }

  41  void CMirrors::CreateBuffer() {
  42:     plugin::Call<0x7230A0>();
  43  }

  46  void CMirrors::Init() {
  47:     plugin::Call<0x723000>();
  48  }

  51  void CMirrors::RenderMirrorBuffer() {
  52:     plugin::Call<0x726090>();
  53  }

  56  void CMirrors::ShutDown() {
  57:     plugin::Call<0x723050>();
  58  }

plugin_sa\game_sa\CModelInfo.cpp:
  185  CBaseModelInfo *CModelInfo::GetModelInfo(int index) {
  186:     return plugin::CallAndReturn<CBaseModelInfo *, 0x403DA0, int>(index);
  187  }

plugin_sa\game_sa\CModelInfoAccelerator.cpp:
  10  void CModelInfoAccelerator::Init() {
  11:     plugin::CallMethod<0x4C6A80, CModelInfoAccelerator *>(this);
  12  }

  15  void CModelInfoAccelerator::AddModelInfoId(unsigned short modelId) {
  16:     plugin::CallMethod<0x4C6AA0, CModelInfoAccelerator *, unsigned short>(this, modelId);
  17  }

  20  unsigned short CModelInfoAccelerator::GetNextModelInfoId() {
  21:     return plugin::CallMethodAndReturn<unsigned short, 0x4C6AC0, CModelInfoAccelerator *>(this);
  22  }

  25  void CModelInfoAccelerator::AllocModelInfoIds() {
  26:     plugin::CallMethod<0x4C6AE0, CModelInfoAccelerator *>(this);
  27  }

  30  void CModelInfoAccelerator::FreeModelInfoIds() {
  31:     plugin::CallMethod<0x4C6B10, CModelInfoAccelerator *>(this);
  32  }

  35  void CModelInfoAccelerator::GetEntry(CBaseModelInfo** arg0, int* arg1, char* arg2) {
  36:     plugin::CallMethod<0x4C6B30, CModelInfoAccelerator *, CBaseModelInfo**, int*, char*>(this, arg0, arg1, arg2);
  37  }

  40  void CModelInfoAccelerator::End(char* arg0) {
  41:     plugin::CallMethod<0x4C6B40, CModelInfoAccelerator *, char*>(this, arg0);
  42  }

  45  CModelInfoAccelerator::CModelInfoAccelerator() {
  46:     plugin::CallMethod<0x4C6B50, CModelInfoAccelerator *>(this);
  47  }

  50  bool CModelInfoAccelerator::GetModelInfoIdFile() {
  51:     return plugin::CallMethodAndReturn<bool, 0x4C6B70, CModelInfoAccelerator *>(this);
  52  }

  55  void CModelInfoAccelerator::EndOfLoadPhase() {
  56:     plugin::CallMethod<0x4C6BD0, CModelInfoAccelerator *>(this);
  57  }

  60  bool CModelInfoAccelerator::Begin(char* filePath) {
  61:     return plugin::CallMethodAndReturn<bool, 0x4C6C20, CModelInfoAccelerator *, char*>(this, filePath);
  62  }

plugin_sa\game_sa\CMotionBlurStreaks.cpp:
  14  void CMotionBlurStreaks::Update() {
  15:     plugin::Call<0x7240C0>();
  16  }

  19  void CMotionBlurStreaks::Render() {
  20:     plugin::Call<0x7240E0>();
  21  }

  24  void CMotionBlurStreaks::RegisterStreak(unsigned int id, unsigned char red, unsigned char green, unsigned char blue, CVector leftPoint, CVector rightPoint) {
  25:     plugin::Call<0x721DC0, unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(id, red, green, blue, leftPoint, rightPoint);
  26  }

  29  void CMotionBlurStreaks::Init() {
  30:     plugin::Call<0x721D90>();
  31  }

plugin_sa\game_sa\COctTree.cpp:
  19  bool COctTree::InsertTree(unsigned char colorRed, unsigned char colorGreen, unsigned char colorBlue) {
  20:     return plugin::CallVirtualMethodAndReturn<bool, 0, COctTree *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);
  21  }

  24  void COctTree::FillPalette(unsigned char* colors) {
  25:     plugin::CallVirtualMethod<1, COctTree *, unsigned char*>(this, colors);
  26  }

  29  COctTree::COctTree() {
  30:     plugin::CallMethod<0x5A6DB0, COctTree *>(this);
  31  }

  34  unsigned int COctTree::FindNearestColour(unsigned char colorRed, unsigned char colorGreen, unsigned char colorBlue) {
  35:     return plugin::CallMethodAndReturn<unsigned int, 0x5A71E0, COctTree *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);
  36  }

  39  void COctTree::InitPool(void* data, int dataSize) {
  40:     plugin::CallMethod<0x5A7460, COctTree *, void*, int>(this, data, dataSize);
  41  }

  44  unsigned int COctTree::NoOfChildren() {
  45:     return plugin::CallMethodAndReturn<unsigned int, 0x5A6DE0, COctTree *>(this);
  46  }

  49  void COctTree::ReduceTree() {
  50:     plugin::CallMethod<0x5A7040, COctTree *>(this);
  51  }

  54  void COctTree::RemoveChildren() {
  55:     plugin::CallMethod<0x5A74F0, COctTree *>(this);
  56  }

  59  void COctTree::ShutdownPool() {
  60:     plugin::CallMethod<0x5A6F70, COctTree *>(this);
  61  }

  64  void COctTree::empty() {
  65:     plugin::CallMethod<0x5A6FC0, COctTree *>(this);
  66  }

  69  void COctTree::operator delete(void* data) {
  70:     plugin::Call<0x5A7420, void*>(data);
  71  }

  74  void* COctTree::operator new(unsigned int size) {
  75:     return plugin::CallAndReturn<void*, 0x5A7410, unsigned int>(size);
  76  }

plugin_sa\game_sa\COctTreeBase.cpp:
  10  COctTreeBase::COctTreeBase() : COctTree(plugin::dummy) {
  11:     plugin::CallMethod<0x5A7570, COctTreeBase *>(this);
  12  }

  15  void COctTreeBase::Init(int numBranches) {
  16:     plugin::CallMethod<0x5A7260, COctTreeBase *, int>(this, numBranches);
  17  }

  20  bool COctTreeBase::Insert(unsigned char colorRed, unsigned char colorGreen, unsigned char colorBlue) {
  21:     return plugin::CallMethodAndReturn<bool, 0x5A7750, COctTreeBase *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);
  22  }

  25  void COctTreeBase::ReduceBranches(int newBranchesCount) {
  26:     plugin::CallMethod<0x5A7840, COctTreeBase *, int>(this, newBranchesCount);
  27  }

plugin_sa\game_sa\common.cpp:
  392  RpAtomic* RemoveRefsCB(RpAtomic* atomic, void* _IGNORED_ data) {
  393:     return plugin::CallAndReturn<RpAtomic*, 0x7226D0, RpAtomic*, void*>(atomic, data);
  394  }

  397  void RemoveRefsForAtomic(RpClump* clump) {
  398:     plugin::Call<0x7226F0, RpClump*>(clump);
  399  }

  403  CAnimBlendClumpData* RpAnimBlendAllocateData(RpClump* clump) {
  404:     return plugin::CallAndReturn<CAnimBlendClumpData*, 0x4D5F50, RpClump*>(clump);
  405  }

  408  CAnimBlendAssociation* RpAnimBlendClumpAddAssociation(RpClump* clump, CAnimBlendAssociation* association, unsigned int flags, float startTime, float blendAmount) {
  409:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6790, RpClump*, CAnimBlendAssociation*, unsigned int, float, float>(clump, association, flags, startTime, blendAmount);
  410  }

  413  CAnimBlendAssociation* RpAnimBlendClumpExtractAssociations(RpClump* clump) {
  414:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6BE0, RpClump*>(clump);
  415  }

  418  void RpAnimBlendClumpFillFrameArray(RpClump* clump, AnimBlendFrameData** frameData) {
  419:     plugin::Call<0x4D64A0, RpClump*, AnimBlendFrameData**>(clump, frameData);
  420  }

  423  AnimBlendFrameData* RpAnimBlendClumpFindBone(RpClump* clump, unsigned int id) {
  424:     return plugin::CallAndReturn<AnimBlendFrameData*, 0x4D6400, RpClump*, unsigned int>(clump, id);
  425  }

  428  AnimBlendFrameData* RpAnimBlendClumpFindFrame(RpClump* clump, char const* name) {
  429:     return plugin::CallAndReturn<AnimBlendFrameData*, 0x4D62A0, RpClump*, char const*>(clump, name);
  430  }

  433  AnimBlendFrameData* RpAnimBlendClumpFindFrameFromHashKey(RpClump* clump, unsigned int key) {
  434:     return plugin::CallAndReturn<AnimBlendFrameData*, 0x4D6370, RpClump*, unsigned int>(clump, key);
  435  }

  438  CAnimBlendAssociation* RpAnimBlendClumpGetAssociation(RpClump* clump, bool arg1, CAnimBlendHierarchy* hierarchy) {
  439:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D68E0, RpClump*, bool, CAnimBlendHierarchy*>(clump, arg1, hierarchy);
  440  }

  443  CAnimBlendAssociation* RpAnimBlendClumpGetAssociation(RpClump* clump, char const* name) {
  444:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6870, RpClump*, char const*>(clump, name);
  445  }

  448  CAnimBlendAssociation* RpAnimBlendClumpGetAssociation(RpClump* clump, unsigned int animId) {
  449:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D68B0, RpClump*, unsigned int>(clump, animId);
  450  }

  453  CAnimBlendAssociation* RpAnimBlendClumpGetFirstAssociation(RpClump* clump) {
  454:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D15E0, RpClump*>(clump);
  455  }

  458  CAnimBlendAssociation* RpAnimBlendClumpGetFirstAssociation(RpClump* clump, unsigned int flags) {
  459:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6A70, RpClump*, unsigned int>(clump, flags);
  460  }

  463  CAnimBlendAssociation* RpAnimBlendClumpGetMainAssociation(RpClump* clump, CAnimBlendAssociation** pAssociation, float* blendAmount) {
  464:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6910, RpClump*, CAnimBlendAssociation**, float*>(clump, pAssociation, blendAmount);
  465  }

  468  CAnimBlendAssociation* RpAnimBlendClumpGetMainAssociation_N(RpClump* clump, int n) {
  469:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6A30, RpClump*, int>(clump, n);
  470  }

  473  CAnimBlendAssociation* RpAnimBlendClumpGetMainPartialAssociation(RpClump* clump) {
  474:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D69A0, RpClump*>(clump);
  475  }

  478  CAnimBlendAssociation* RpAnimBlendClumpGetMainPartialAssociation_N(RpClump* clump, int n) {
  479:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D69F0, RpClump*, int>(clump, n);
  480  }

  483  unsigned int RpAnimBlendClumpGetNumAssociations(RpClump* clump) {
  484:     return plugin::CallAndReturn<unsigned int, 0x4D6B60, RpClump*>(clump);
  485  }

  488  unsigned int RpAnimBlendClumpGetNumNonPartialAssociations(RpClump* clump) {
  489:     return plugin::CallAndReturn<unsigned int, 0x4D6BB0, RpClump*>(clump);
  490  }

  493  unsigned int RpAnimBlendClumpGetNumPartialAssociations(RpClump* clump) {
  494:     return plugin::CallAndReturn<unsigned int, 0x4D6B80, RpClump*>(clump);
  495  }

  498  void RpAnimBlendClumpGiveAssociations(RpClump* clump, CAnimBlendAssociation* association) {
  499:     plugin::Call<0x4D6C30, RpClump*, CAnimBlendAssociation*>(clump, association);
  500  }

  503  void RpAnimBlendClumpInit(RpClump* clump) {
  504:     plugin::Call<0x4D6720, RpClump*>(clump);
  505  }

  508  bool RpAnimBlendClumpIsInitialized(RpClump* clump) {
  509:     return plugin::CallAndReturn<bool, 0x4D6760, RpClump*>(clump);
  510  }

  513  void RpAnimBlendClumpPauseAllAnimations(RpClump* clump) {
  514:     plugin::Call<0x4D6B00, RpClump*>(clump);
  515  }

  518  void RpAnimBlendClumpRemoveAllAssociations(RpClump* clump) {
  519:     plugin::Call<0x4D6C00, RpClump*>(clump);
  520  }

  523  void RpAnimBlendClumpRemoveAssociations(RpClump* clump, unsigned int flags) {
  524:     plugin::Call<0x4D6820, RpClump*, unsigned int>(clump, flags);
  525  }

  528  void RpAnimBlendClumpSetBlendDeltas(RpClump* clump, unsigned int flags, float delta) {
  529:     plugin::Call<0x4D67E0, RpClump*, unsigned int, float>(clump, flags, delta);
  530  }

  533  void RpAnimBlendClumpUnPauseAllAnimations(RpClump* clump) {
  534:     plugin::Call<0x4D6B30, RpClump*>(clump);
  535  }

  538  void RpAnimBlendClumpUpdateAnimations(RpClump* clump, float step, bool onScreen) {
  539:     plugin::Call<0x4D34F0, RpClump*, float, bool>(clump, step, onScreen);
  540  }

  543  RtAnimAnimation* RpAnimBlendCreateAnimationForHierarchy(RpHAnimHierarchy* hierarchy) {
  544:     return plugin::CallAndReturn<RtAnimAnimation*, 0x4D60E0, RpHAnimHierarchy*>(hierarchy);
  545  }

  548  char* RpAnimBlendFrameGetName(RwFrame* frame) {
  549:     return plugin::CallAndReturn<char*, 0x4D5EF0, RwFrame*>(frame);
  550  }

  553  void RpAnimBlendFrameSetName(RwFrame* frame, char* name) {
  554:     plugin::Call<0x4D5F00, RwFrame*, char*>(frame, name);
  555  }

  558  CAnimBlendAssociation* RpAnimBlendGetNextAssociation(CAnimBlendAssociation* association) {
  559:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6AB0, CAnimBlendAssociation*>(association);
  560  }

  563  CAnimBlendAssociation* RpAnimBlendGetNextAssociation(CAnimBlendAssociation* association, unsigned int flags) {
  564:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6AD0, CAnimBlendAssociation*, unsigned int>(association, flags);
  565  }

  568  void RpAnimBlendKeyFrameInterpolate(void* voidOut, void* voidIn1, void* voidIn2, float time, void* customData) {
  569:     plugin::Call<0x4D60C0, void*, void*, void*, float, void*>(voidOut, voidIn1, voidIn2, time, customData);
  570  }

  573  bool RpAnimBlendPluginAttach() {
  574:     return plugin::CallAndReturn<bool, 0x4D6150>();
  575  }

  577  void AsciiToGxtChar(char const *src, char *dst) {
  578:     plugin::Call<0x718600, char const *, char *>(src, dst);
  579  }

  585  	assert(pszPath && pszPath[0]);
  586: 	plugin::Call<0x005A4150>(pRaster, pszPath);
  587  }

  589  bool DoRWStuffStartOfFrame(short topRed, short topGreen, short topBlue, short bottomRed, short bottomGreen, short bottomBlue, short alpha) {
  590:     return plugin::CallAndReturn<bool, 0x53D690>(topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue, alpha);
  591  }

  593  void DoRWStuffEndOfFrame() {
  594:     plugin::Call<0x53D840>();
  595  }

  597  void RsCameraShowRaster(RwCamera* camera) {
  598:     plugin::Call<0x619440>(camera);
  599  }

plugin_sa\game_sa\COnscreenCounterEntry.cpp:
  14  void COnscreenCounterEntry::ProcessForDisplayCounter(int type) {
  15:     plugin::CallMethodDynGlobal<COnscreenCounterEntry *, int>(gaddrof(COnscreenCounterEntry::ProcessForDisplayCounter), this, type);
  16  }

  21  void COnscreenCounterEntry::SetColourID(unsigned char ColourID) {
  22:     plugin::CallMethodDynGlobal<COnscreenCounterEntry *, unsigned char>(gaddrof(COnscreenCounterEntry::SetColourID), this, ColourID);
  23  }

plugin_sa\game_sa\COnscreenTimer.cpp:
  14  void COnscreenTimer::AddClock(unsigned int varId, char *gxt, bool bTimerDirection) {
  15:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, char *, bool>(gaddrof(COnscreenTimer::AddClock), this, varId, gxt, bTimerDirection);
  16  }

  21  void COnscreenTimer::AddCounter(int varId, short type, char *gxt, unsigned short counterIndex) {
  22:     plugin::CallMethodDynGlobal<COnscreenTimer *, int, short, char *, unsigned short>(gaddrof(COnscreenTimer::AddCounter), this, varId, type, gxt, counterIndex);
  23  }

  28  void COnscreenTimer::AddCounterCounter(unsigned int varId, unsigned int maxValue, char *gxt, unsigned short lineId) {
  29:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned int, char *, unsigned short>(gaddrof(COnscreenTimer::AddCounterCounter), this, varId, maxValue, gxt, lineId);
  30  }

  35  int COnscreenTimer::ClearClock(unsigned int varId) {
  36:     return plugin::CallMethodAndReturnDynGlobal<int, COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearClock), this, varId);
  37  }

  42  void COnscreenTimer::ClearCounter(unsigned int varId) {
  43:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearCounter), this, varId);
  44  }

  49  void COnscreenTimer::Init() {
  50:     plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Init), this);
  51  }

  56  void COnscreenTimer::Process() {
  57:     plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Process), this);
  58  }

  63  void COnscreenTimer::ProcessForDisplay() {
  64:     plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::ProcessForDisplay), this);
  65  }

  70  void COnscreenTimer::SetClockBeepCountdownSecs(unsigned int varID, unsigned int time) {
  71:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned int>(gaddrof(COnscreenTimer::SetClockBeepCountdownSecs), this, varID, time);
  72  }

  77  void COnscreenTimer::SetCounterColourID(unsigned int varID, unsigned char ColourID) {
  78:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned char>(gaddrof(COnscreenTimer::SetCounterColourID), this, varID, ColourID);
  79  }

  84  void COnscreenTimer::SetCounterFlashWhenFirstDisplayed(unsigned int varId, unsigned char bFlashWhenFirstDisplayed) {
  85:     plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned char>(gaddrof(COnscreenTimer::SetCounterFlashWhenFirstDisplayed), this, varId, bFlashWhenFirstDisplayed);
  86  }

plugin_sa\game_sa\COnscreenTimerEntry.cpp:
  14  void COnscreenTimerEntry::Process() {
  15:     plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::Process), this);
  16  }

  21  void COnscreenTimerEntry::ProcessForDisplayClock() {
  22:     plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayClock), this);
  23  }

plugin_sa\game_sa\CPad.cpp:
   17  {
   18:     plugin::CallMethod<0x541D80, CPad*>(this);
   19  }

   22  void CPad::UpdateMouse() {
   23:     plugin::CallMethod<0x53F3C0, CPad *>(this);
   24  }

   27  void CPad::ReconcileTwoControllersInput(CControllerState const& controllerA, CControllerState const& controllerB) {
   28:     plugin::CallMethod<0x53F530, CPad *, CControllerState const&, CControllerState const&>(this, controllerA, controllerB);
   29  }

   32  void CPad::SetDrunkInputDelay(int delay) {
   33:     plugin::CallMethod<0x53F910, CPad *, int>(this, delay);
   34  }

   37  void CPad::StartShake(short time, unsigned char frequency, unsigned int arg2) {
   38:     plugin::CallMethod<0x53F920, CPad *, short, unsigned char, unsigned int>(this, time, frequency, arg2);
   39  }

   42  void CPad::StartShake_Distance(short time, unsigned char frequency, float x, float y, float z) {
   43:     plugin::CallMethod<0x53F9A0, CPad *, short, unsigned char, float, float, float>(this, time, frequency, x, y, z);
   44  }

   47  void CPad::StartShake_Train(float x, float y) {
   48:     plugin::CallMethod<0x53FA70, CPad *, float, float>(this, x, y);
   49  }

   52  void CPad::ProcessPCSpecificStuff() {
   53:     plugin::CallMethod<0x53FB40, CPad *>(this);
   54  }

   57  void CPad::StopShaking(short arg0) {
   58:     plugin::CallMethod<0x53FB50, CPad *, short>(this, arg0);
   59  }

   62  CPad* CPad::GetPad(int padNumber) {
   63:     return plugin::CallAndReturn<CPad*, 0x53FB70, int>(padNumber);
   64  }

   67  short CPad::GetSteeringLeftRight() {
   68:     return plugin::CallMethodAndReturn<short, 0x53FB80, CPad *>(this);
   69  }

   72  short CPad::GetSteeringUpDown() {
   73:     return plugin::CallMethodAndReturn<short, 0x53FBD0, CPad *>(this);
   74  }

   77  short CPad::GetPedWalkLeftRight() {
   78:     return plugin::CallMethodAndReturn<short, 0x53FC90, CPad *>(this);
   79  }

   82  short CPad::GetPedWalkUpDown() {
   83:     return plugin::CallMethodAndReturn<short, 0x53FD30, CPad *>(this);
   84  }

   87  bool CPad::GetLookLeft() {
   88:     return plugin::CallMethodAndReturn<bool, 0x53FDD0, CPad *>(this);
   89  }

   92  bool CPad::GetLookRight() {
   93:     return plugin::CallMethodAndReturn<bool, 0x53FE10, CPad *>(this);
   94  }

   97  bool CPad::GetLookBehindForCar() {
   98:     return plugin::CallMethodAndReturn<bool, 0x53FE70, CPad *>(this);
   99  }

  102  bool CPad::GetLookBehindForPed() {
  103:     return plugin::CallMethodAndReturn<bool, 0x53FEC0, CPad *>(this);
  104  }

  107  bool CPad::GetHorn() {
  108:     return plugin::CallMethodAndReturn<bool, 0x53FEE0, CPad *>(this);
  109  }

  112  bool CPad::HornJustDown() {
  113:     return plugin::CallMethodAndReturn<bool, 0x53FF30, CPad *>(this);
  114  }

  117  bool CPad::GetHydraulicJump() {
  118:     return plugin::CallMethodAndReturn<bool, 0x53FF70, CPad *>(this);
  119  }

  122  short CPad::GetCarGunFired() {
  123:     return plugin::CallMethodAndReturn<short, 0x53FF90, CPad *>(this);
  124  }

  127  short CPad::CarGunJustDown() {
  128:     return plugin::CallMethodAndReturn<short, 0x53FFE0, CPad *>(this);
  129  }

  132  short CPad::GetHandBrake() {
  133:     return plugin::CallMethodAndReturn<short, 0x540040, CPad *>(this);
  134  }

  137  short CPad::GetBrake() {
  138:     return plugin::CallMethodAndReturn<short, 0x540080, CPad *>(this);
  139  }

  142  bool CPad::GetExitVehicle() {
  143:     return plugin::CallMethodAndReturn<bool, 0x5400D0, CPad *>(this);
  144  }

  147  bool CPad::ExitVehicleJustDown() {
  148:     return plugin::CallMethodAndReturn<bool, 0x540120, CPad *>(this);
  149  }

  152  unsigned char CPad::GetMeleeAttack() {
  153:     return plugin::CallMethodAndReturn<unsigned char, 0x540340, CPad *>(this, 0);
  154  }

  157  unsigned char CPad::MeleeAttackJustDown() {
  158:     return plugin::CallMethodAndReturn<unsigned char, 0x540390, CPad *>(this);
  159  }

  162  short CPad::GetAccelerate() {
  163:     return plugin::CallMethodAndReturn<short, 0x5403F0, CPad *>(this);
  164  }

  167  bool CPad::GetAccelerateJustDown() {
  168:     return plugin::CallMethodAndReturn<bool, 0x540440, CPad *>(this);
  169  }

  172  bool CPad::NextStationJustUp() {
  173:     return plugin::CallMethodAndReturn<bool, 0x5405B0, CPad *>(this);
  174  }

  177  bool CPad::LastStationJustUp() {
  178:     return plugin::CallMethodAndReturn<bool, 0x5405E0, CPad *>(this);
  179  }

  182  bool CPad::CycleWeaponLeftJustDown() {
  183:     return plugin::CallMethodAndReturn<bool, 0x540610, CPad *>(this);
  184  }

  187  bool CPad::CycleWeaponRightJustDown() {
  188:     return plugin::CallMethodAndReturn<bool, 0x540640, CPad *>(this);
  189  }

  192  bool CPad::GetTarget() {
  193:     return plugin::CallMethodAndReturn<bool, 0x540670, CPad *>(this);
  194  }

  197  bool CPad::GetDuck() {
  198:     return plugin::CallMethodAndReturn<bool, 0x540700, CPad *>(this);
  199  }

  202  bool CPad::DuckJustDown() {
  203:     return plugin::CallMethodAndReturn<bool, 0x540720, CPad *>(this);
  204  }

  207  bool CPad::GetJump() {
  208:     return plugin::CallMethodAndReturn<bool, 0x540750, CPad *>(this);
  209  }

  212  bool CPad::JumpJustDown() {
  213:     return plugin::CallMethodAndReturn<bool, 0x540770, CPad *>(this);
  214  }

  217  bool CPad::GetSprint() {
  218:     return plugin::CallMethodAndReturn<bool, 0x5407A0, CPad *>(this);
  219  }

  222  bool CPad::SprintJustDown() {
  223:     return plugin::CallMethodAndReturn<bool, 0x5407F0, CPad *>(this);
  224  }

  227  bool CPad::ShiftTargetLeftJustDown() {
  228:     return plugin::CallMethodAndReturn<bool, 0x540850, CPad *>(this);
  229  }

  232  bool CPad::ShiftTargetRightJustDown() {
  233:     return plugin::CallMethodAndReturn<bool, 0x540880, CPad *>(this);
  234  }

  237  short CPad::GetDisplayVitalStats(CPed* ped) {
  238:     return plugin::CallMethodAndReturn<short, 0x5408B0, CPad *, CPed*>(this, ped);
  239  }

  242  bool CPad::CollectPickupJustDown() {
  243:     return plugin::CallMethodAndReturn<bool, 0x540A70, CPad *>(this);
  244  }

  247  bool CPad::GetForceCameraBehindPlayer() {
  248:     return plugin::CallMethodAndReturn<bool, 0x540AE0, CPad *>(this);
  249  }

  252  bool CPad::SniperZoomIn() {
  253:     return plugin::CallMethodAndReturn<bool, 0x540B30, CPad *>(this);
  254  }

  257  bool CPad::SniperZoomOut() {
  258:     return plugin::CallMethodAndReturn<bool, 0x540B80, CPad *>(this);
  259  }

  262  bool CPad::GetGroupControlForward() {
  263:     return plugin::CallMethodAndReturn<bool, 0x541190, CPad *>(this);
  264  }

  267  bool CPad::GetGroupControlBack() {
  268:     return plugin::CallMethodAndReturn<bool, 0x5411B0, CPad *>(this);
  269  }

  272  bool CPad::ConversationYesJustDown() {
  273:     return plugin::CallMethodAndReturn<bool, 0x5411D0, CPad *>(this);
  274  }

  277  bool CPad::ConversationNoJustDown() {
  278:     return plugin::CallMethodAndReturn<bool, 0x541200, CPad *>(this);
  279  }

  282  bool CPad::GroupControlForwardJustDown() {
  283:     return plugin::CallMethodAndReturn<bool, 0x541230, CPad *>(this);
  284  }

  287  bool CPad::GroupControlBackJustDown() {
  288:     return plugin::CallMethodAndReturn<bool, 0x541260, CPad *>(this);
  289  }

  292  void CPad::Clear(bool enablePlayerControls, bool resetPhase) {
  293:     plugin::CallMethod<0x541A70, CPad *, bool, bool>(this, enablePlayerControls, resetPhase);
  294  }

  297  void CPad::UpdatePads() {
  298:     plugin::Call<0x541DD0>();
  299  }

  301  void CPad::ClearMouseHistory() {
  302:     plugin::Call<0x541BD0>();
  303  }

plugin_sa\game_sa\CPathNode.cpp:
  15      CVector ret_posn;
  16:     plugin::CallMethodDynGlobal<CPathNode *, CVector *>(gaddrof(CPathNode::GetNodeCoors), this, &ret_posn);
  17      return ret_posn;

plugin_sa\game_sa\CPedClothesDesc.cpp:
  12  void CPedClothesDesc::Initialise() {
  13:     plugin::CallMethod<0x5A78F0, CPedClothesDesc *>(this);
  14  }

  17  void CPedClothesDesc::SetModel(unsigned int modelid, int eClothesModelPart) {
  18:     plugin::CallMethod<0x5A7910, CPedClothesDesc *, unsigned int, int>(this, modelid, eClothesModelPart);
  19  }

  22  void CPedClothesDesc::SetModel(char const* model, int eClothesModelPart) {
  23:     plugin::CallMethod<0x5A7920, CPedClothesDesc *, char const*, int>(this, model, eClothesModelPart);
  24  }

  27  bool CPedClothesDesc::GetIsWearingBalaclava() {
  28:     return plugin::CallMethodAndReturn<bool, 0x5A7950, CPedClothesDesc *>(this);
  29  }

  32  bool CPedClothesDesc::HasVisibleNewHairCut(int arg1) {
  33:     return plugin::CallMethodAndReturn<bool, 0x5A7970, CPedClothesDesc *, int>(this, arg1);
  34  }

  37  bool CPedClothesDesc::HasVisibleTattoo() {
  38:     return plugin::CallMethodAndReturn<bool, 0x5A79D0, CPedClothesDesc *>(this);
  39  }

  42  CPedClothesDesc::CPedClothesDesc() {
  43:     plugin::CallMethod<0x5A8020, CPedClothesDesc *>(this);
  44  }

  47  void CPedClothesDesc::SetTextureAndModel(unsigned int texture, unsigned int model, int eClothesTexturePart) {
  48:     plugin::CallMethod<0x5A8050, CPedClothesDesc *, unsigned int, unsigned int, int>(this, texture, model, eClothesTexturePart);
  49  }

  52  void CPedClothesDesc::SetTextureAndModel(char const* texturename, char const* modelname, int eClothesTexturePart) {
  53:     plugin::CallMethod<0x5A8080, CPedClothesDesc *, char const*, char const*, int>(this, texturename, modelname, eClothesTexturePart);
  54  }

plugin_sa\game_sa\CPedGroup.cpp:
  20  float CPedGroup::FindDistanceToFurthestMember() {
  21:     return plugin::CallMethodAndReturnDynGlobal<float, CPedGroup *>(gaddrof(CPedGroup::FindDistanceToFurthestMember), this);
  22  }

  27  float CPedGroup::FindDistanceToNearestMember(CPed **ppOutNearestMember) {
  28:     return plugin::CallMethodAndReturnDynGlobal<float, CPedGroup *, CPed **>(gaddrof(CPedGroup::FindDistanceToNearestMember), this, ppOutNearestMember);
  29  }

  34  void CPedGroup::Flush() {
  35:     plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::Flush), this);
  36  }

  41  CPed *CPedGroup::GetClosestGroupPed(CPed *ped, float *pOutDistance) {
  42:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroup *, CPed *, float *>(gaddrof(CPedGroup::GetClosestGroupPed), this, ped, pOutDistance);
  43  }

  48  bool CPedGroup::IsAnyoneUsingCar(CVehicle const *vehicle) {
  49:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroup *, CVehicle const *>(gaddrof(CPedGroup::IsAnyoneUsingCar), this, vehicle);
  50  }

  55  void CPedGroup::PlayerGaveCommand_Attack(CPed *playerPed, CPed *ped) {
  56:     plugin::CallMethodDynGlobal<CPedGroup *, CPed *, CPed *>(gaddrof(CPedGroup::PlayerGaveCommand_Attack), this, playerPed, ped);
  57  }

  62  void CPedGroup::PlayerGaveCommand_Gather(CPed *ped) {
  63:     plugin::CallMethodDynGlobal<CPedGroup *, CPed *>(gaddrof(CPedGroup::PlayerGaveCommand_Gather), this, ped);
  64  }

  69  void CPedGroup::Process() {
  70:     plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::Process), this);
  71  }

  76  void CPedGroup::RemoveAllFollowers() {
  77:     plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::RemoveAllFollowers), this);
  78  }

  83  void CPedGroup::Teleport(CVector const *Pos) {
  84:     plugin::CallMethodDynGlobal<CPedGroup *, CVector const *>(gaddrof(CPedGroup::Teleport), this, Pos);
  85  }

plugin_sa\game_sa\CPedGroupIntelligence.cpp:
   20  bool CPedGroupIntelligence::AddEvent(CEvent *event) {
   21:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CEvent *>(gaddrof(CPedGroupIntelligence::AddEvent), this, event);
   22  }

   27  void CPedGroupIntelligence::ComputeDefaultTasks(CPed *ped) {
   28:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::ComputeDefaultTasks), this, ped);
   29  }

   34  void *CPedGroupIntelligence::ComputeEventResponseTasks() {
   35:     return plugin::CallMethodAndReturnDynGlobal<void *, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ComputeEventResponseTasks), this);
   36  }

   41  void CPedGroupIntelligence::ComputeScriptCommandTasks() {
   42:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ComputeScriptCommandTasks), this);
   43  }

   48  void CPedGroupIntelligence::FlushTasks(CPedTaskPair *taskpair, CPed *ped) {
   49:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedTaskPair *, CPed *>(gaddrof(CPedGroupIntelligence::FlushTasks), this, taskpair, ped);
   50  }

   55  CTask *CPedGroupIntelligence::GetTask(CPed *ped, CPedTaskPair const *taskpair) {
   56:     return plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *, CPedTaskPair const *>(gaddrof(CPedGroupIntelligence::GetTask), this, ped, taskpair);
   57  }

   62  CTask *CPedGroupIntelligence::GetTaskDefault(CPed *ped) {
   63:     return plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskDefault), this, ped);
   64  }

   69  CTask *CPedGroupIntelligence::GetTaskScriptCommand(CPed *ped) {
   70:     return plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskScriptCommand), this, ped);
   71  }

   76  CTask *CPedGroupIntelligence::GetTaskSecondary(CPed *ped) {
   77:     return plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskSecondary), this, ped);
   78  }

   83  signed int CPedGroupIntelligence::GetTaskSecondarySlot(CPed *ped) {
   84:     return plugin::CallMethodAndReturnDynGlobal<signed int, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskSecondarySlot), this, ped);
   85  }

   90  bool CPedGroupIntelligence::IsCurrentEventValid() {
   91:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::IsCurrentEventValid), this);
   92  }

   97  bool CPedGroupIntelligence::IsGroupResponding() {
   98:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::IsGroupResponding), this);
   99  }

  104  void CPedGroupIntelligence::Process() {
  105:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::Process), this);
  106  }

  111  void CPedGroupIntelligence::ProcessIgnorePlayerGroup() {
  112:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ProcessIgnorePlayerGroup), this);
  113  }

  118  void CPedGroupIntelligence::ReportAllBarScriptTasksFinished() {
  119:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ReportAllBarScriptTasksFinished), this);
  120  }

  125  void CPedGroupIntelligence::ReportAllTasksFinished(CPedTaskPair *taskpair) {
  126:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedTaskPair *>(gaddrof_o(CPedGroupIntelligence::ReportAllTasksFinished, void (CPedGroupIntelligence::*)(CPedTaskPair *)), this, taskpair);
  127  }

  132  void CPedGroupIntelligence::ReportAllTasksFinished() {
  133:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof_o(CPedGroupIntelligence::ReportAllTasksFinished, void (CPedGroupIntelligence::*)()), this);
  134  }

  139  bool CPedGroupIntelligence::ReportFinishedTask(CPed const *ped, CTask const *task, CPedTaskPair *taskpair) {
  140:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CPed const *, CTask const *, CPedTaskPair *>(gaddrof_o(CPedGroupIntelligence::ReportFinishedTask, bool (CPedGroupIntelligence::*)(CPed const *, CTask const *, CPedTaskPair *)), this, ped, task, taskpair);
  141  }

  146  bool CPedGroupIntelligence::ReportFinishedTask(CPed const *ped, CTask const *task) {
  147:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CPed const *, CTask const *>(gaddrof_o(CPedGroupIntelligence::ReportFinishedTask, bool (CPedGroupIntelligence::*)(CPed const *, CTask const *)), this, ped, task);
  148  }

  153  void CPedGroupIntelligence::SetDefaultTask(CPed *ped, CTask const *task) {
  154:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *>(gaddrof(CPedGroupIntelligence::SetDefaultTask), this, ped, task);
  155  }

  160  void CPedGroupIntelligence::SetDefaultTaskAllocator(CPedGroupDefaultTaskAllocator const *PedGroupDefaultTaskAllocator) {
  161:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedGroupDefaultTaskAllocator const *>(gaddrof(CPedGroupIntelligence::SetDefaultTaskAllocator), this, PedGroupDefaultTaskAllocator);
  162  }

  167  void CPedGroupIntelligence::SetDefaultTaskAllocatorType(int nPedGroupTaskAllocator) {
  168:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetDefaultTaskAllocatorType), this, nPedGroupTaskAllocator);
  169  }

  174  void CPedGroupIntelligence::SetEventResponseTask(CPed *ped, bool arg3, CTask const *task1, bool arg5, CTask const *task2, int arg7) {
  175:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, bool, CTask const *, bool, CTask const *, int>(gaddrof(CPedGroupIntelligence::SetEventResponseTask), this, ped, arg3, task1, arg5, task2, arg7);
  176  }

  181  int CPedGroupIntelligence::SetEventResponseTaskAllocator(int a2) {
  182:     return plugin::CallMethodAndReturnDynGlobal<int, CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetEventResponseTaskAllocator), this, a2);
  183  }

  188  int CPedGroupIntelligence::SetGroupDecisionMakerType(int a2) {
  189:     return plugin::CallMethodAndReturnDynGlobal<int, CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetGroupDecisionMakerType), this, a2);
  190  }

  195  void CPedGroupIntelligence::SetPrimaryTaskAllocator(CTaskAllocator *taskAllocator) {
  196:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CTaskAllocator *>(gaddrof(CPedGroupIntelligence::SetPrimaryTaskAllocator), this, taskAllocator);
  197  }

  202  void CPedGroupIntelligence::SetScriptCommandTask(CPed *ped, CTask const *task) {
  203:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *>(gaddrof(CPedGroupIntelligence::SetScriptCommandTask), this, ped, task);
  204  }

  209  void CPedGroupIntelligence::SetTask(CPed *ped, CTask const *task, CPedTaskPair *taskpair, int arg5, bool arg6) {
  210:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *, CPedTaskPair *, int, bool>(gaddrof(CPedGroupIntelligence::SetTask), this, ped, task, taskpair, arg5, arg6);
  211  }

plugin_sa\game_sa\CPedGroupMembership.cpp:
   26  void CPedGroupMembership::AddFollower(CPed *ped) {
   27:     plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *>(gaddrof(CPedGroupMembership::AddFollower), this, ped);
   28  }

   33  void CPedGroupMembership::AddMember(CPed *member, int memberID) {
   34:     plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *, int>(gaddrof(CPedGroupMembership::AddMember), this, member, memberID);
   35  }

   40  void CPedGroupMembership::AppointNewLeader() {
   41:     plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::AppointNewLeader), this);
   42  }

   47  int CPedGroupMembership::CountMembers() {
   48:     return plugin::CallMethodAndReturnDynGlobal<int, CPedGroupMembership *>(gaddrof(CPedGroupMembership::CountMembers), this);
   49  }

   54  int CPedGroupMembership::CountMembersExcludingLeader() {
   55:     return plugin::CallMethodAndReturnDynGlobal<int, CPedGroupMembership *>(gaddrof(CPedGroupMembership::CountMembersExcludingLeader), this);
   56  }

   61  void CPedGroupMembership::Flush() {
   62:     plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::Flush), this);
   63  }

   68  void CPedGroupMembership::From(CPedGroupMembership const *obj) {
   69:     plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(gaddrof(CPedGroupMembership::From), this, obj);
   70  }

   75  CPed *CPedGroupMembership::GetLeader() {
   76:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroupMembership *>(gaddrof(CPedGroupMembership::GetLeader), this);
   77  }

   82  CPed *CPedGroupMembership::GetMember(int memberId) {
   83:     return plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::GetMember), this, memberId);
   84  }

   89  bool CPedGroupMembership::IsFollower(CPed const *ped) {
   90:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsFollower), this, ped);
   91  }

   96  bool CPedGroupMembership::IsLeader(CPed const *ped) {
   97:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsLeader), this, ped);
   98  }

  103  bool CPedGroupMembership::IsMember(CPed const *ped) {
  104:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsMember), this, ped);
  105  }

  110  void CPedGroupMembership::Process() {
  111:     plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::Process), this);
  112  }

  117  void CPedGroupMembership::RemoveAllFollowers(bool bCreatedByGameOnly) {
  118:     plugin::CallMethodDynGlobal<CPedGroupMembership *, bool>(gaddrof(CPedGroupMembership::RemoveAllFollowers), this, bCreatedByGameOnly);
  119  }

  124  void CPedGroupMembership::RemoveMember(int memberID) {
  125:     plugin::CallMethodDynGlobal<CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::RemoveMember), this, memberID);
  126  }

  131  char CPedGroupMembership::RemoveNFollowers(int count) {
  132:     return plugin::CallMethodAndReturnDynGlobal<char, CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::RemoveNFollowers), this, count);
  133  }

  138  void CPedGroupMembership::SetLeader(CPed *ped) {
  139:     plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *>(gaddrof(CPedGroupMembership::SetLeader), this, ped);
  140  }

  145  signed int CPedGroupMembership::GetObjectForPedToHold() {
  146:     return plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CPedGroupMembership::GetObjectForPedToHold));
  147  }

plugin_sa\game_sa\CPedGroupPlacer.cpp:
  17  bool CPedGroupPlacer::PlaceChatGroup(ePedType pedtype, int numOfPeds, CVector const *origin, int unused) {
  18:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceChatGroup), this, pedtype, numOfPeds, origin, unused);
  19  }

  24  bool CPedGroupPlacer::PlaceFormationGroup(ePedType pedtype, int numOfPeds, CVector const *origin, int unused) {
  25:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceFormationGroup), this, pedtype, numOfPeds, origin, unused);
  26  }

  31  bool CPedGroupPlacer::PlaceGroup(ePedType pedtype, int numOfPeds, CVector const *origin, int nGroupPlacerType) {
  32:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceGroup), this, pedtype, numOfPeds, origin, nGroupPlacerType);
  33  }

  38  bool CPedGroupPlacer::PlaceRandomGroup(ePedType pedtype, int numOfPeds, CVector *origin, int unused) {
  39:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector *, int>(gaddrof(CPedGroupPlacer::PlaceRandomGroup), this, pedtype, numOfPeds, origin, unused);
  40  }

plugin_sa\game_sa\CPedGroups.cpp:
  20  signed int CPedGroups::AddGroup() {
  21:     return plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CPedGroups::AddGroup));
  22  }

  27  bool CPedGroups::AreInSameGroup(CPed *ped1, CPed *ped2) {
  28:     return plugin::CallAndReturnDynGlobal<bool, CPed *, CPed *>(gaddrof(CPedGroups::AreInSameGroup), ped1, ped2);
  29  }

  41  signed int CPedGroups::GetGroupId(CPedGroup *pedgrp) {
  42:     return plugin::CallAndReturnDynGlobal<signed int, CPedGroup *>(gaddrof(CPedGroups::GetGroupId), pedgrp);
  43  }

  48  char *CPedGroups::GetPedsGroup(CPed *ped) {
  49:     return plugin::CallAndReturnDynGlobal<char *, CPed *>(gaddrof(CPedGroups::GetPedsGroup), ped);
  50  }

  62  bool CPedGroups::IsGroupLeader(CPed *ped) {
  63:     return plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CPedGroups::IsGroupLeader), ped);
  64  }

  69  char CPedGroups::IsInPlayersGroup(CPed *a1) {
  70:     return plugin::CallAndReturnDynGlobal<char, CPed *>(gaddrof(CPedGroups::IsInPlayersGroup), a1);
  71  }

  90  void CPedGroups::RemoveAllFollowersFromGroup(int groupID) {
  91:     plugin::CallDynGlobal<int>(gaddrof(CPedGroups::RemoveAllFollowersFromGroup), groupID);
  92  }

  97  void CPedGroups::RemoveGroup(int groupID) {
  98:     plugin::CallDynGlobal<int>(gaddrof(CPedGroups::RemoveGroup), groupID);
  99  }

plugin_sa\game_sa\CPedIK.cpp:
  11  void CPedIK::RotateTorso(AnimBlendFrameData* bone, LimbOrientation& orientation, bool flag) {
  12: 	plugin::CallMethod<0x5FDDB0, CPedIK *, AnimBlendFrameData*, LimbOrientation&, bool>(this, bone, orientation, flag);
  13  }

  16  bool CPedIK::PointGunInDirection(float Z_angle, float arg2, bool flag, float arg4) {
  17: 	return plugin::CallMethodAndReturn<bool, 0x5FDC00, CPedIK *, float, float, bool, float>(this, Z_angle, arg2, flag, arg4);
  18  }

  21  void CPedIK::PointGunAtPosition(CVector const& posn, float arg2) {
  22: 	plugin::CallMethod<0x5FDE20, CPedIK *, CVector const&, float>(this, posn, arg2);
  23  }

  26  RwMatrixTag* CPedIK::GetWorldMatrix(RwFrame* frame, RwMatrixTag* transformMat) {
  27: 	return plugin::CallAndReturn<RwMatrixTag*, 0x5FD8F0, RwFrame*, RwMatrixTag*>(frame, transformMat);
  28  }

  31  {
  32:     return plugin::CallAndReturn<MoveLimbResult, 0x5FDA60, LimbOrientation&, float, float, LimbMovementInfo &>(TorsoOrien, yaw, pitch, LimbMoveInfo);

  38  {
  39:     return plugin::CallAndReturn<MoveLimbResult, 0x5FDB60, LimbOrientation&, float, float, LimbMovementInfo &, float>(TorsoOrien, yaw, pitch, LimbMoveInfo, fNormalize);

plugin_sa\game_sa\CPedIntelligence.cpp:
   10  void CPedIntelligence::SetPedDecisionMakerType(int newtype) {
   11: 	plugin::CallMethod<0x600B50, CPedIntelligence *, int>(this, newtype);
   12  }

   15  void CPedIntelligence::SetPedDecisionMakerTypeInGroup(int newtype) {
   16: 	plugin::CallMethod<0x600BB0, CPedIntelligence *, int>(this, newtype);
   17  }

   20  void CPedIntelligence::RestorePedDecisionMakerType() {
   21: 	plugin::CallMethod<0x600BC0, CPedIntelligence *>(this);
   22  }

   25  void CPedIntelligence::SetHearingRange(float range) {
   26: 	plugin::CallMethod<0x600BE0, CPedIntelligence *, float>(this, range);
   27  }

   30  void CPedIntelligence::SetSeeingRange(float range) {
   31: 	plugin::CallMethod<0x600BF0, CPedIntelligence *, float>(this, range);
   32  }

   35  bool CPedIntelligence::IsInHearingRange(CVector const& posn) {
   36: 	return plugin::CallMethodAndReturn<bool, 0x600C00, CPedIntelligence *, CVector const&>(this, posn);
   37  }

   40  bool CPedIntelligence::IsInSeeingRange(CVector const& posn) {
   41: 	return plugin::CallMethodAndReturn<bool, 0x600C60, CPedIntelligence *, CVector const&>(this, posn);
   42  }

   45  bool CPedIntelligence::FindRespectedFriendInInformRange() {
   46: 	return plugin::CallMethodAndReturn<bool, 0x600CF0, CPedIntelligence *>(this);
   47  }

   50  bool CPedIntelligence::IsRespondingToEvent(int event) {
   51: 	return plugin::CallMethodAndReturn<bool, 0x600DB0, CPedIntelligence *, int>(this, event);
   52  }

   55  void CPedIntelligence::AddTaskPhysResponse(CTask* task, bool arg2) {
   56: 	plugin::CallMethod<0x600DC0, CPedIntelligence *, CTask*, bool>(this, task, arg2);
   57  }

   60  void CPedIntelligence::AddTaskEventResponseTemp(CTask* task, bool arg2) {
   61: 	plugin::CallMethod<0x600DE0, CPedIntelligence *, CTask*, bool>(this, task, arg2);
   62  }

   65  void CPedIntelligence::AddTaskEventResponseNonTemp(CTask* task, bool arg2) {
   66: 	plugin::CallMethod<0x600E00, CPedIntelligence *, CTask*, bool>(this, task, arg2);
   67  }

   70  void CPedIntelligence::AddTaskPrimaryMaybeInGroup(CTask* task, bool arg2) {
   71: 	plugin::CallMethod<0x600E20, CPedIntelligence *, CTask*, bool>(this, task, arg2);
   72  }

   75  CTask* CPedIntelligence::FindTaskByType(int type) {
   76: 	return plugin::CallMethodAndReturn<CTask*, 0x600EE0, CPedIntelligence *, int>(this, type);
   77  }

   80  CTaskSimpleFight* CPedIntelligence::GetTaskFighting() {
   81: 	return plugin::CallMethodAndReturn<CTaskSimpleFight*, 0x600F30, CPedIntelligence *>(this);
   82  }

   85  CTaskSimpleUseGun* CPedIntelligence::GetTaskUseGun() {
   86: 	return plugin::CallMethodAndReturn<CTaskSimpleUseGun*, 0x600F70, CPedIntelligence *>(this);
   87  }

   90  CTaskSimpleThrowProjectile* CPedIntelligence::GetTaskThrow() {
   91: 	return plugin::CallMethodAndReturn<CTaskSimpleThrowProjectile*, 0x600FB0, CPedIntelligence *>(this);
   92  }

   95  CTaskSimpleHoldEntity* CPedIntelligence::GetTaskHold(bool arg1) {
   96: 	return plugin::CallMethodAndReturn<CTaskSimpleHoldEntity*, 0x600FF0, CPedIntelligence *, bool>(this, arg1);
   97  }

  100  CTaskSimpleSwim* CPedIntelligence::GetTaskSwim() {
  101: 	return plugin::CallMethodAndReturn<CTaskSimpleSwim*, 0x601070, CPedIntelligence *>(this);
  102  }

  105  CTaskSimpleDuck* CPedIntelligence::GetTaskDuck(bool arg1) {
  106: 	return plugin::CallMethodAndReturn<CTaskSimpleDuck*, 0x6010A0, CPedIntelligence *, bool>(this, arg1);
  107  }

  110  CTaskSimpleJetPack* CPedIntelligence::GetTaskJetPack() {
  111: 	return plugin::CallMethodAndReturn<CTaskSimpleJetPack*, 0x601110, CPedIntelligence *>(this);
  112  }

  115  CTaskSimpleInAir* CPedIntelligence::GetTaskInAir() {
  116: 	return plugin::CallMethodAndReturn<CTaskSimpleInAir*, 0x601150, CPedIntelligence *>(this);
  117  }

  120  CTaskSimpleClimb* CPedIntelligence::GetTaskClimb() {
  121: 	return plugin::CallMethodAndReturn<CTaskSimpleClimb*, 0x601180, CPedIntelligence *>(this);
  122  }

  125  bool CPedIntelligence::GetUsingParachute() {
  126: 	return plugin::CallMethodAndReturn<bool, 0x6011B0, CPedIntelligence *>(this);
  127  }

  130  void CPedIntelligence::SetTaskDuckSecondary(unsigned short arg1) {
  131: 	plugin::CallMethod<0x601230, CPedIntelligence *, unsigned short>(this, arg1);
  132  }

  135  void CPedIntelligence::ClearTaskDuckSecondary() {
  136: 	plugin::CallMethod<0x601390, CPedIntelligence *>(this);
  137  }

  140  void CPedIntelligence::ClearTasks(bool arg1, bool arg2) {
  141: 	plugin::CallMethod<0x601420, CPedIntelligence *, bool, bool>(this, arg1, arg2);
  142  }

  145  void CPedIntelligence::FlushImmediately(bool arg1) {
  146: 	plugin::CallMethod<0x601640, CPedIntelligence *, bool>(this, arg1);
  147  }

  150  C2dEffect* CPedIntelligence::GetEffectInUse() {
  151: 	return plugin::CallMethodAndReturn<C2dEffect*, 0x6018D0, CPedIntelligence *>(this);
  152  }

  155  void CPedIntelligence::SetEffectInUse(C2dEffect* arg1) {
  156: 	plugin::CallMethod<0x6018E0, CPedIntelligence *, C2dEffect*>(this, arg1);
  157  }

  160  void CPedIntelligence::ProcessAfterProcCol() {
  161: 	plugin::CallMethod<0x6018F0, CPedIntelligence *>(this);
  162  }

  165  void CPedIntelligence::ProcessAfterPreRender() {
  166: 	plugin::CallMethod<0x6019B0, CPedIntelligence *>(this);
  167  }

  170  void CPedIntelligence::ProcessEventHandler() {
  171: 	plugin::CallMethod<0x601BB0, CPedIntelligence *>(this);
  172  }

  175  bool CPedIntelligence::IsFriendlyWith(CPed const& ped) {
  176: 	return plugin::CallMethodAndReturn<bool, 0x601BC0, CPedIntelligence *, CPed const&>(this, ped);
  177  }

  180  bool CPedIntelligence::IsThreatenedBy(CPed const& ped) {
  181: 	return plugin::CallMethodAndReturn<bool, 0x601C30, CPedIntelligence *, CPed const&>(this, ped);
  182  }

  185  bool CPedIntelligence::Respects(CPed const& ped) {
  186: 	return plugin::CallMethodAndReturn<bool, 0x601C90, CPedIntelligence *, CPed const&>(this, ped);
  187  }

  190  bool CPedIntelligence::IsInACarOrEnteringOne() {
  191: 	return plugin::CallMethodAndReturn<bool, 0x601CC0, CPedIntelligence *>(this);
  192  }

  195  bool CPedIntelligence::AreFriends(CPed const& ped1, CPed const& ped2) {
  196: 	return plugin::CallAndReturn<bool, 0x601D10, CPed const&, CPed const&>(ped1, ped2);
  197  }

  200  bool CPedIntelligence::IsPedGoingSomewhereOnFoot() {
  201: 	return plugin::CallMethodAndReturn<bool, 0x601D50, CPedIntelligence *>(this);
  202  }

  205  int* CPedIntelligence::GetMoveStateFromGoToTask() {
  206: 	return plugin::CallMethodAndReturn<int*, 0x601D70, CPedIntelligence *>(this);
  207  }

  210  void CPedIntelligence::FlushIntelligence() {
  211: 	plugin::CallMethod<0x601DA0, CPedIntelligence *>(this);
  212  }

  215  bool CPedIntelligence::TestForStealthKill(CPed* pPed, bool arg2) {
  216: 	return plugin::CallMethodAndReturn<bool, 0x601E00, CPedIntelligence *, CPed*, bool>(this, pPed, arg2);
  217  }

  220  void CPedIntelligence::RecordEventForScript(int EventID, int EventPriority) {
  221: 	plugin::CallMethod<0x602050, CPedIntelligence *, int, int>(this, EventID, EventPriority);
  222  }

  225  bool CPedIntelligence::HasInterestingEntites() {
  226: 	return plugin::CallMethodAndReturn<bool, 0x602080, CPedIntelligence *>(this);
  227  }

  230  bool CPedIntelligence::IsInterestingEntity(CEntity* pEntity) {
  231: 	return plugin::CallMethodAndReturn<bool, 0x6020A0, CPedIntelligence *, CEntity*>(this, pEntity);
  232  }

  235  void CPedIntelligence::LookAtInterestingEntities() {
  236: 	plugin::CallMethod<0x6020D0, CPedIntelligence *>(this);
  237  }

  240  void CPedIntelligence::RemoveAllInterestingEntities() {
  241: 	plugin::CallMethod<0x602320, CPedIntelligence *>(this);
  242  }

  245  bool CPedIntelligence::IsPedGoingForCarDoor() {
  246: 	return plugin::CallMethodAndReturn<bool, 0x602350, CPedIntelligence *>(this);
  247  }

  250  float CPedIntelligence::CanSeeEntityWithLights(CEntity const* pEntity, bool arg2) {
  251: 	return plugin::CallMethodAndReturn<float, 0x605550, CPedIntelligence *, CEntity const*, bool>(this, pEntity, arg2);
  252  }

  255  void CPedIntelligence::ProcessStaticCounter() {
  256: 	plugin::CallMethod<0x605650, CPedIntelligence *>(this);
  257  }

  260  void CPedIntelligence::ProcessFirst() {
  261: 	plugin::CallMethod<0x6073A0, CPedIntelligence *>(this);
  262  }

  265  void CPedIntelligence::Process() {
  266: 	plugin::CallMethod<0x608260, CPedIntelligence *>(this);
  267  }

  270  void CPedIntelligence::operator delete(void* arg1) {
  271: 	plugin::Call<0x6074E0, void*>(arg1);
  272  }

plugin_sa\game_sa\CPedList.cpp:
  14  void CPedList::BuildListFromGroup_NoLeader(CPedGroupMembership *pedGroupMemberShip) {
  15:     plugin::CallMethodDynGlobal<CPedList *, CPedGroupMembership *>(gaddrof(CPedList::BuildListFromGroup_NoLeader), this, pedGroupMemberShip);
  16  }

  21  void CPedList::BuildListFromGroup_NotInCar_NoLeader(CPedGroupMembership *pedGroupMembership) {
  22:     plugin::CallMethodDynGlobal<CPedList *, CPedGroupMembership *>(gaddrof(CPedList::BuildListFromGroup_NotInCar_NoLeader), this, pedGroupMembership);
  23  }

  28  void CPedList::BuildListOfPedsOfPedType(int pedtype) {
  29:     plugin::CallMethodDynGlobal<CPedList *, int>(gaddrof(CPedList::BuildListOfPedsOfPedType), this, pedtype);
  30  }

  35  void CPedList::Empty() {
  36:     plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::Empty), this);
  37  }

  42  void CPedList::ExtractPedsWithGuns(CPedList *pedlist) {
  43:     plugin::CallMethodDynGlobal<CPedList *, CPedList *>(gaddrof(CPedList::ExtractPedsWithGuns), this, pedlist);
  44  }

  49  void CPedList::FillUpHoles() {
  50:     plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::FillUpHoles), this);
  51  }

  56  void CPedList::RemovePedsAttackingPedType(int pedtype) {
  57:     plugin::CallMethodDynGlobal<CPedList *, int>(gaddrof(CPedList::RemovePedsAttackingPedType), this, pedtype);
  58  }

  63  void CPedList::RemovePedsThatDontListenToPlayer() {
  64:     plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::RemovePedsThatDontListenToPlayer), this);
  65  }

plugin_sa\game_sa\CPedPlacement.cpp:
  14  bool CPedPlacement::FindZCoorForPed(CVector *pos) {
  15:     return plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPedPlacement::FindZCoorForPed), pos);
  16  }

  21  bool CPedPlacement::IsPositionClearForPed(CVector const *pos, float radius, int maxNumObjects, CEntity **pObjectList, unsigned char bCheckVehicles, unsigned char bCheckPeds, unsigned char bCheckObjects) {
  22:     return plugin::CallAndReturnDynGlobal<bool, CVector const *, float, int, CEntity **, unsigned char, unsigned char, unsigned char>(gaddrof(CPedPlacement::IsPositionClearForPed), pos, radius, maxNumObjects, pObjectList, bCheckVehicles, bCheckPeds, bCheckObjects);
  23  }

  28  CVehicle *CPedPlacement::IsPositionClearOfCars(CVector const *pos) {
  29:     return plugin::CallAndReturnDynGlobal<CVehicle *, CVector const *>(gaddrof_o(CPedPlacement::IsPositionClearOfCars, CVehicle *(*)(CVector const *)), pos);
  30  }

  35  CVehicle *CPedPlacement::IsPositionClearOfCars(CPed const *ped) {
  36:     return plugin::CallAndReturnDynGlobal<CVehicle *, CPed const *>(gaddrof_o(CPedPlacement::IsPositionClearOfCars, CVehicle *(*)(CPed const *)), ped);
  37  }

plugin_sa\game_sa\CPedTaskPair.cpp:
  14  void CPedTaskPair::Flush() {
  15:     plugin::CallMethodDynGlobal<CPedTaskPair *>(gaddrof(CPedTaskPair::Flush), this);
  16  }

plugin_sa\game_sa\CPickup.cpp:
  10  void CPickup::SetPosn(float x, float y, float z) {
  11:     plugin::CallMethod<0x454960, CPickup *, float, float, float>(this, x, y, z);
  12  }

  16      CVector result;
  17:     plugin::CallMethod<0x4549A0, CPickup *, CVector*>(this, &result);
  18      return result;

  22  float CPickup::GetXCoord() {
  23:     return plugin::CallMethodAndReturn<float, 0x4549F0, CPickup *>(this);
  24  }

  27  float CPickup::GetYCoord() {
  28:     return plugin::CallMethodAndReturn<float, 0x454A10, CPickup *>(this);
  29  }

  32  float CPickup::GetZCoord() {
  33:     return plugin::CallMethodAndReturn<float, 0x454A30, CPickup *>(this);
  34  }

  37  void CPickup::ExtractAmmoFromPickup(CPlayerPed* playerPed) {
  38:     plugin::CallMethod<0x454BE0, CPickup *, CPlayerPed*>(this, playerPed);
  39  }

  42  bool CPickup::IsVisible() {
  43:     return plugin::CallMethodAndReturn<bool, 0x454C70, CPickup *>(this);
  44  }

  47  void CPickup::GetRidOfObjects() {
  48:     plugin::CallMethod<0x454CF0, CPickup *>(this);
  49  }

  52  bool CPickup::PickUpShouldBeInvisible() {
  53:     return plugin::CallMethodAndReturn<bool, 0x454D20, CPickup *>(this);
  54  }

  57  void CPickup::FindTextIndexForString(char* message) {
  58:     plugin::Call<0x455500, char*>(message);
  59  }

  62  char const *CPickup::FindStringForTextIndex(int index) {
  63:     return plugin::CallAndReturn<char const *, 0x455540, int>(index);
  64  }

  67  void CPickup::Remove() {
  68:     plugin::CallMethod<0x4556C0, CPickup *>(this);
  69  }

  72  void CPickup::GiveUsAPickUpObject(CObject** pObject, int objectPoolSlotIndex) {
  73:     plugin::CallMethod<0x4567E0, CPickup *, CObject**, int>(this, pObject, objectPoolSlotIndex);
  74  }

  77  bool CPickup::Update(CPlayerPed* playerPed, CVehicle* vehicle, int playerId) {
  78:     return plugin::CallMethodAndReturn<bool,0x457410, CPickup *, CPlayerPed*, CVehicle*, int>(this, playerPed, vehicle, playerId);
  79  }

  82  void CPickup::ProcessGunShot(CVector* origin, CVector* target) {
  83:     plugin::CallMethod<0x4588B0, CPickup *, CVector*, CVector*>(this, origin, target);
  84  }

plugin_sa\game_sa\CPickups.cpp:
   27  void CPickups::AddToCollectedPickupsArray(int handle) {
   28:     plugin::Call<0x455240, int>(handle);
   29  }

   32  void CPickups::CreatePickupCoorsCloseToCoors(float in_x, float in_y, float in_z, float* out_x, float* out_y, float* out_z) {
   33:     plugin::Call<0x458A80, float, float, float, float*, float*, float*>(in_x, in_y, in_z, out_x, out_y, out_z);
   34  }

   37  void CPickups::CreateSomeMoney(CVector coors, int amount) {
   38:     plugin::Call<0x458970, CVector, int>(coors, amount);
   39  }

   42  void CPickups::DetonateMinesHitByGunShot(CVector* shotOrigin, CVector* shotTarget) {
   43:     plugin::Call<0x4590C0, CVector*, CVector*>(shotOrigin, shotTarget);
   44  }

   47  void CPickups::DoCollectableEffects(CEntity* entity) {
   48:     plugin::Call<0x455E20, CEntity*>(entity);
   49  }

   52  void CPickups::DoMineEffects(CEntity* entity) {
   53:     plugin::Call<0x4560E0, CEntity*>(entity);
   54  }

   57  void CPickups::DoMoneyEffects(CEntity* entity) {
   58:     plugin::Call<0x454E80, CEntity*>(entity);
   59  }

   62  void CPickups::DoPickUpEffects(CEntity* entity) {
   63:     plugin::Call<0x455720, CEntity*>(entity);
   64  }

   67  CPickup* CPickups::FindPickUpForThisObject(CObject* object) {
   68:     return plugin::CallAndReturn<CPickup*, 0x4551C0, CObject*>(object);
   69  }

   72  int CPickups::GenerateNewOne(CVector coors, unsigned int modelId, unsigned char pickupType, unsigned int ammo, unsigned int moneyPerDay, bool isEmpty, char* message) {
   73:     return plugin::CallAndReturn<int, 0x456F20, CVector, unsigned int, unsigned char, unsigned int, unsigned int, bool, char*>(coors, modelId, pickupType, ammo, moneyPerDay, isEmpty, message);
   74  }

   77  int CPickups::GenerateNewOne_WeaponType(CVector coors, eWeaponType weaponType, unsigned char pickupType, unsigned int ammo, bool isEmpty, char* message) {
   78:     return plugin::CallAndReturn<int, 0x457380, CVector, eWeaponType, unsigned char, unsigned int, bool, char*>(coors, weaponType, pickupType, ammo, isEmpty, message);
   79  }

   82  int CPickups::GetActualPickupIndex(int pickupIndex) {
   83:     return plugin::CallAndReturn<int, 0x4552A0, int>(pickupIndex);
   84  }

   87  int CPickups::GetNewUniquePickupIndex(int pickupIndex) {
   88:     return plugin::CallAndReturn<int, 0x456A30, int>(pickupIndex);
   89  }

   92  int CPickups::GetUniquePickupIndex(int pickupIndex) {
   93:     return plugin::CallAndReturn<int, 0x455280, int>(pickupIndex);
   94  }

   97  bool CPickups::GivePlayerGoodiesWithPickUpMI(unsigned short modelId, int playerId) {
   98:     return plugin::CallAndReturn<bool, 0x4564F0, unsigned short, int>(modelId, playerId);
   99  }

  102  void CPickups::Init() {
  103:     plugin::Call<0x454A70>();
  104  }

  107  bool CPickups::IsPickUpPickedUp(int pickupHandle) {
  108:     return plugin::CallAndReturn<bool, 0x454B40, int>(pickupHandle);
  109  }

  112  bool CPickups::Load() {
  113:     return plugin::CallAndReturn<bool, 0x5D35A0>();
  114  }

  117  int CPickups::ModelForWeapon(eWeaponType weaponType) {
  118:     return plugin::CallAndReturn<int, 0x454AC0, eWeaponType>(weaponType);
  119  }

  122  void CPickups::PassTime(unsigned int time) {
  123:     plugin::Call<0x455200, unsigned int>(time);
  124  }

  127  void CPickups::PickedUpHorseShoe() {
  128:     plugin::Call<0x455390>();
  129  }

  132  void CPickups::PickedUpOyster() {
  133:     plugin::Call<0x4552D0>();
  134  }

  137  void CPickups::PictureTaken() {
  138:     plugin::Call<0x456A70>();
  139  }

  142  bool CPickups::PlayerCanPickUpThisWeaponTypeAtThisMoment(eWeaponType weaponType) {
  143:     return plugin::CallAndReturn<bool, 0x4554C0, eWeaponType>(weaponType);
  144  }

  147  void CPickups::ReInit() {
  148:     plugin::Call<0x456E60>();
  149  }

  152  void CPickups::RemoveMissionPickUps() {
  153:     plugin::Call<0x456DE0>();
  154  }

  157  void CPickups::RemovePickUp(int pickupHandle) {
  158:     plugin::Call<0x4573D0, int>(pickupHandle);
  159  }

  162  void CPickups::RemovePickUpsInArea(float cornerA_x, float cornerA_y, float cornerA_z, float cornerB_x, float cornerB_y, float cornerB_z) {
  163:     plugin::Call<0x456D30, float, float, float, float, float, float>(cornerA_x, cornerA_y, cornerA_z, cornerB_x, cornerB_y, cornerB_z);
  164  }

  167  void CPickups::RemovePickupObjects() {
  168:     plugin::Call<0x455470>();
  169  }

  172  void CPickups::RemoveUnnecessaryPickups(CVector const& posn, float radius) {
  173:     plugin::Call<0x4563A0, CVector const&, float>(posn, radius);
  174  }

  177  void CPickups::RenderPickUpText() {
  178:     plugin::Call<0x455000>();
  179  }

  182  bool CPickups::Save() {
  183:     return plugin::CallAndReturn<bool, 0x5D3540>();
  184  }

  187  bool CPickups::TestForPickupsInBubble(CVector posn, float radius) {
  188:     return plugin::CallAndReturn<bool, 0x456450, CVector, float>(posn, radius);
  189  }

  192  bool CPickups::TryToMerge_WeaponType(CVector posn, eWeaponType weaponType, unsigned char pickupType, unsigned int ammo, bool _IGNORED_ arg4) {
  193:     return plugin::CallAndReturn<bool, 0x4555A0, CVector, eWeaponType, unsigned char, unsigned int, bool>(posn, weaponType, pickupType, ammo, arg4);
  194  }

  197  void CPickups::Update() {
  198:     plugin::Call<0x458DE0>();
  199  }

  202  void CPickups::UpdateMoneyPerDay(int pickupHandle, unsigned short money) {
  203:     plugin::Call<0x455680, int, unsigned short>(pickupHandle, money);
  204  }

  207  int CPickups::WeaponForModel(int modelId) {
  208:     return plugin::CallAndReturn<int, 0x454AE0, int>(modelId);
  209  }

  212  void ModifyStringLabelForControlSetting(char* stringLabel) {
  213:     plugin::Call<0x454B70, char*>(stringLabel);
  214  }

plugin_sa\game_sa\CPlayerInfo.cpp:
  10  {
  11:     plugin::CallMethod<0x571920, CPlayerInfo*>(this);
  12  }

plugin_sa\game_sa\CPlayerPed.cpp:
   14  CPlayerPed::CPlayerPed(int playerId, bool bGroupCreated) : CPed(plugin::dummy) {
   15:     plugin::CallMethod<0x60D5B0, CPlayerPed *, int, bool>(this, playerId, bGroupCreated);
   16  }

   19  void CPlayerPed::RemovePlayerPed(int playerId) {
   20:     plugin::Call<0x6094A0, int>(playerId);
   21  }

   24  void CPlayerPed::DeactivatePlayerPed(int playerId) {
   25:     plugin::Call<0x609520, int>(playerId);
   26  }

   29  void CPlayerPed::ReactivatePlayerPed(int playerId) {
   30:     plugin::Call<0x609540, int>(playerId);
   31  }

   34  CPad* CPlayerPed::GetPadFromPlayer() {
   35:     return plugin::CallMethodAndReturn<CPad*, 0x609560, CPlayerPed *>(this);
   36  }

   39  bool CPlayerPed::CanPlayerStartMission() {
   40:     return plugin::CallMethodAndReturn<bool, 0x609590, CPlayerPed *>(this);
   41  }

   44  bool CPlayerPed::IsHidden() {
   45:     return plugin::CallMethodAndReturn<bool, 0x609620, CPlayerPed *>(this);
   46  }

   49  void CPlayerPed::ReApplyMoveAnims() {
   50:     plugin::CallMethod<0x609650, CPlayerPed *>(this);
   51  }

   54  bool CPlayerPed::DoesPlayerWantNewWeapon(eWeaponType weaponType, bool arg1) {
   55:     return plugin::CallMethodAndReturn<bool, 0x609710, CPlayerPed *, eWeaponType, bool>(this, weaponType, arg1);
   56  }

   59  void CPlayerPed::ProcessPlayerWeapon(CPad* pad) {
   60:     plugin::CallMethod<0x6097F0, CPlayerPed *, CPad*>(this, pad);
   61  }

   64  void CPlayerPed::PickWeaponAllowedFor2Player() {
   65:     plugin::CallMethod<0x609800, CPlayerPed *>(this);
   66  }

   69  void CPlayerPed::UpdateCameraWeaponModes(CPad* pad) {
   70:     plugin::CallMethod<0x609830, CPlayerPed *, CPad*>(this, pad);
   71  }

   74  void CPlayerPed::ProcessAnimGroups() {
   75:     plugin::CallMethod<0x6098F0, CPlayerPed *>(this);
   76  }

   79  void CPlayerPed::ClearWeaponTarget() {
   80:     plugin::CallMethod<0x609C80, CPlayerPed *>(this);
   81  }

   84  float CPlayerPed::GetWeaponRadiusOnScreen() {
   85:     return plugin::CallMethodAndReturn<float, 0x609CD0, CPlayerPed *>(this);
   86  }

   89  bool CPlayerPed::PedCanBeTargettedVehicleWise(CPed* ped) {
   90:     return plugin::CallAndReturn<bool, 0x609D90, CPed*>(ped);
   91  }

   94  float CPlayerPed::FindTargetPriority(CEntity* entity) {
   95:     return plugin::CallMethodAndReturn<float, 0x609DE0, CPlayerPed *, CEntity*>(this, entity);
   96  }

   99  void CPlayerPed::Clear3rdPersonMouseTarget() {
  100:     plugin::CallMethod<0x609ED0, CPlayerPed *>(this);
  101  }

  104  void CPlayerPed::Busted() {
  105:     plugin::CallMethod<0x609EF0, CPlayerPed *>(this);
  106  }

  109  void CPlayerPed::SetWantedLevel(int level) {
  110:     plugin::CallMethod<0x609F10, CPlayerPed *, int>(this, level);
  111  }

  114  void CPlayerPed::SetWantedLevelNoDrop(int level) {
  115:     plugin::CallMethod<0x609F30, CPlayerPed *, int>(this, level);
  116  }

  119  void CPlayerPed::CheatWantedLevel(int level) {
  120:     plugin::CallMethod<0x609F50, CPlayerPed *, int>(this, level);
  121  }

  124  bool CPlayerPed::CanIKReachThisTarget(CVector posn, CWeapon* weapon, bool arg2) {
  125:     return plugin::CallMethodAndReturn<bool, 0x609F80, CPlayerPed *, CVector, CWeapon*, bool>(this, posn, weapon, arg2);
  126  }

  129  CPlayerInfo* CPlayerPed::GetPlayerInfoForThisPlayerPed() {
  130:     return plugin::CallMethodAndReturn<CPlayerInfo*, 0x609FF0, CPlayerPed *>(this);
  131  }

  134  void CPlayerPed::DoStuffToGoOnFire() {
  135:     plugin::CallMethod<0x60A020, CPlayerPed *>(this);
  136  }

  139  void CPlayerPed::AnnoyPlayerPed(bool arg0) {
  140:     plugin::CallMethod<0x60A040, CPlayerPed *, bool>(this, arg0);
  141  }

  144  void CPlayerPed::ClearAdrenaline() {
  145:     plugin::CallMethod<0x60A070, CPlayerPed *>(this);
  146  }

  149  void CPlayerPed::DisbandPlayerGroup() {
  150:     plugin::CallMethod<0x60A0A0, CPlayerPed *>(this);
  151  }

  154  void CPlayerPed::MakeGroupRespondToPlayerTakingDamage(CEventDamage const& damageEvent) {
  155:     plugin::CallMethod<0x60A110, CPlayerPed *, CEventDamage const&>(this, damageEvent);
  156  }

  159  void CPlayerPed::TellGroupToStartFollowingPlayer(bool arg0, bool arg1, bool arg2) {
  160:     plugin::CallMethod<0x60A1D0, CPlayerPed *, bool, bool, bool>(this, arg0, arg1, arg2);
  161  }

  164  void CPlayerPed::MakePlayerGroupDisappear() {
  165:     plugin::CallMethod<0x60A440, CPlayerPed *>(this);
  166  }

  169  void CPlayerPed::MakePlayerGroupReappear() {
  170:     plugin::CallMethod<0x60A4B0, CPlayerPed *>(this);
  171  }

  174  void CPlayerPed::ResetSprintEnergy() {
  175:     plugin::CallMethod<0x60A530, CPlayerPed *>(this);
  176  }

  179  bool CPlayerPed::HandleSprintEnergy(bool arg0, float arg1) {
  180:     return plugin::CallMethodAndReturn<bool, 0x60A550, CPlayerPed *, bool, float>(this, arg0, arg1);
  181  }

  184  float CPlayerPed::ControlButtonSprint(eSprintType sprintType) {
  185:     return plugin::CallMethodAndReturn<float, 0x60A610, CPlayerPed *, eSprintType>(this, sprintType);
  186  }

  189  float CPlayerPed::GetButtonSprintResults(eSprintType sprintType) {
  190:     return plugin::CallMethodAndReturn<float, 0x60A820, CPlayerPed *, eSprintType>(this, sprintType);
  191  }

  194  void CPlayerPed::ResetPlayerBreath() {
  195:     plugin::CallMethod<0x60A8A0, CPlayerPed *>(this);
  196  }

  199  void CPlayerPed::HandlePlayerBreath(bool arg0, float arg1) {
  200:     plugin::CallMethod<0x60A8D0, CPlayerPed *, bool, float>(this, arg0, arg1);
  201  }

  204  void CPlayerPed::SetRealMoveAnim() {
  205:     plugin::CallMethod<0x60A9C0, CPlayerPed *>(this);
  206  }

  209  void CPlayerPed::MakeChangesForNewWeapon(eWeaponType weaponType) {
  210:     plugin::CallMethod<0x60B460, CPlayerPed *, eWeaponType>(this, weaponType);
  211  }

  214  bool LOSBlockedBetweenPeds(CEntity* entity1, CEntity* entity2) {
  215:     return plugin::CallAndReturn<bool, 0x60B550, CEntity*, CEntity*>(entity1, entity2);
  216  }

  219  void CPlayerPed::Compute3rdPersonMouseTarget(bool meleeWeapon) {
  220:     plugin::CallMethod<0x60B650, CPlayerPed *, bool>(this, meleeWeapon);
  221  }

  224  void CPlayerPed::DrawTriangleForMouseRecruitPed() {
  225:     plugin::CallMethod<0x60BA80, CPlayerPed *>(this);
  226  }

  229  bool CPlayerPed::DoesTargetHaveToBeBroken(CEntity* entity, CWeapon* weapon) {
  230:     return plugin::CallMethodAndReturn<bool, 0x60C0C0, CPlayerPed *, CEntity*, CWeapon*>(this, entity, weapon);
  231  }

  234  void CPlayerPed::KeepAreaAroundPlayerClear() {
  235:     plugin::CallMethod<0x60C1E0, CPlayerPed *>(this);
  236  }

  239  void CPlayerPed::SetPlayerMoveBlendRatio(CVector* arg0) {
  240:     plugin::CallMethod<0x60C520, CPlayerPed *, CVector*>(this, arg0);
  241  }

  244  CPed* CPlayerPed::FindPedToAttack() {
  245:     return plugin::CallMethodAndReturn<CPed*, 0x60C5F0, CPlayerPed *>(this);
  246  }

  249  void CPlayerPed::ForceGroupToAlwaysFollow(bool enable) {
  250:     plugin::CallMethod<0x60C7C0, CPlayerPed *, bool>(this, enable);
  251  }

  254  void CPlayerPed::ForceGroupToNeverFollow(bool enable) {
  255:     plugin::CallMethod<0x60C800, CPlayerPed *, bool>(this, enable);
  256  }

  259  void CPlayerPed::MakeThisPedJoinOurGroup(CPed* ped) {
  260:     plugin::CallMethod<0x60C840, CPlayerPed *, CPed*>(this, ped);
  261  }

  264  bool CPlayerPed::PlayerWantsToAttack() {
  265:     return plugin::CallMethodAndReturn<bool, 0x60CC50, CPlayerPed *>(this);
  266  }

  269  void CPlayerPed::SetInitialState(bool bGroupCreated) {
  270:     plugin::CallMethod<0x60CD20, CPlayerPed *, bool>(this, bGroupCreated);
  271  }

  274  void CPlayerPed::MakeChangesForNewWeapon(int weaponSlot) {
  275:     plugin::CallMethod<0x60D000, CPlayerPed *, int>(this, weaponSlot);
  276  }

  279  void CPlayerPed::EvaluateTarget(CEntity* target, CEntity** outTarget, float* outTargetPriority, float maxDistance, float arg4, bool arg5) {
  280:     plugin::CallMethod<0x60D020, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5);
  281  }

  284  void CPlayerPed::EvaluateNeighbouringTarget(CEntity* target, CEntity** outTarget, float* outTargetPriority, float maxDistance, float arg4, bool arg5) {
  285:     plugin::CallMethod<0x60D1C0, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5);
  286  }

  289  void CPlayerPed::ProcessGroupBehaviour(CPad* pad) {
  290:     plugin::CallMethod<0x60D350, CPlayerPed *, CPad*>(this, pad);
  291  }

  294  bool CPlayerPed::PlayerHasJustAttackedSomeone() {
  295:     return plugin::CallMethodAndReturn<bool, 0x60D5A0, CPlayerPed *>(this);
  296  }

  299  void CPlayerPed::SetupPlayerPed(int playerId) {
  300:     plugin::Call<0x60D790, int>(playerId);
  301  }

  304  void CPlayerPed::ProcessWeaponSwitch(CPad* pad) {
  305:     plugin::CallMethod<0x60D850, CPlayerPed *, CPad*>(this, pad);
  306  }

  309  bool CPlayerPed::FindWeaponLockOnTarget() {
  310:     return plugin::CallMethodAndReturn<bool, 0x60DC50, CPlayerPed *>(this);
  311  }

  314  bool CPlayerPed::FindNextWeaponLockOnTarget(CEntity* arg0, bool arg1) {
  315:     return plugin::CallMethodAndReturn<bool, 0x60E530, CPlayerPed *, CEntity*, bool>(this, arg0, arg1);
  316  }

  319  int CPlayerPed::GetWantedLevel() {
  320:     return plugin::CallMethodAndReturn<int, 0x41BE60, CPlayerPed *>(this);
  321  }

plugin_sa\game_sa\CPointLights.cpp:
  18  void CPointLights::Init() {
  19:     plugin::Call<0x6FFB40>();
  20  }

  23  float CPointLights::GenerateLightsAffectingObject(CVector const* point, float* totalLighting, CEntity* entity) {
  24:     return plugin::CallAndReturn<float, 0x6FFBB0, CVector const*, float*, CEntity*>(point, totalLighting, entity);
  25  }

  28  float CPointLights::GetLightMultiplier(CVector const* point) {
  29:     return plugin::CallAndReturn<float, 0x6FFE70, CVector const*>(point);
  30  }

  33  void CPointLights::RemoveLightsAffectingObject() {
  34:     plugin::Call<0x6FFFE0>();
  35  }

  38  bool CPointLights::ProcessVerticalLineUsingCache(CVector point, float* outZ) {
  39:     return plugin::CallAndReturn<bool, 0x6FFFF0, CVector, float*>(point, outZ);
  40  }

  43  void CPointLights::AddLight(unsigned char lightType, CVector point, CVector direction, float radius, float red, float green, float blue, unsigned char fogType, bool generateExtraShadows, CEntity* entityAffected) {
  44:     plugin::Call<0x7000E0, unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool, CEntity*>(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows, entityAffected);
  45  }

  48  void CPointLights::RenderFogEffect() {
  49:     plugin::Call<0x7002D0>();
  50  }

plugin_sa\game_sa\CPointList.cpp:
  14  void CPointList::Empty() {
  15:     plugin::CallMethodDynGlobal<CPointList *>(gaddrof(CPointList::Empty), this);
  16  }

plugin_sa\game_sa\CPools.cpp:
   21  int CPools::CheckBuildingAtomics() {
   22:     return plugin::CallAndReturn<int, 0x550170>();
   23  }

   26  void CPools::CheckPoolsEmpty() {
   27:     plugin::Call<0x551950>();
   28  }

   31  CObject* CPools::GetObject(int handle) {
   32:     return plugin::CallAndReturn<CObject*, 0x550050, int>(handle);
   33  }

   36  int CPools::GetObjectRef(CObject* object) {
   37:     return plugin::CallAndReturn<int, 0x550020, CObject*>(object);
   38  }

   41  CPed* CPools::GetPed(int handle) {
   42:     return plugin::CallAndReturn<CPed*, 0x54FF90, int>(handle);
   43  }

   46  int CPools::GetPedRef(CPed* ped) {
   47:     return plugin::CallAndReturn<int, 0x54FF60, CPed*>(ped);
   48  }

   51  CVehicle* CPools::GetVehicle(int handle) {
   52:     return plugin::CallAndReturn<CVehicle*, 0x54FFF0, int>(handle);
   53  }

   56  int CPools::GetVehicleRef(CVehicle* vehicle) {
   57:     return plugin::CallAndReturn<int, 0x54FFC0, CVehicle*>(vehicle);
   58  }

   61  void CPools::Initialise() {
   62:     plugin::Call<0x550F10>();
   63  }

   66  bool CPools::Load() {
   67:     return plugin::CallAndReturn<bool, 0x5D0890>();
   68  }

   71  bool CPools::LoadObjectPool() {
   72:     return plugin::CallAndReturn<bool, 0x5D4A40>();
   73  }

   76  bool CPools::LoadPedPool() {
   77:     return plugin::CallAndReturn<bool, 0x5D2D70>();
   78  }

   81  bool CPools::LoadVehiclePool() {
   82:     return plugin::CallAndReturn<bool, 0x5D2A20>();
   83  }

   86  void CPools::MakeSureSlotInObjectPoolIsEmpty(int slot) {
   87:     plugin::Call<0x550080, int>(slot);
   88  }

   91  bool CPools::Save() {
   92:     return plugin::CallAndReturn<bool, 0x5D0880>();
   93  }

   96  bool CPools::SaveObjectPool() {
   97:     return plugin::CallAndReturn<bool, 0x5D4940>();
   98  }

  101  bool CPools::SavePedPool() {
  102:     return plugin::CallAndReturn<bool, 0x5D4B40>();
  103  }

  106  bool CPools::SaveVehiclePool() {
  107:     return plugin::CallAndReturn<bool, 0x5D4800>();
  108  }

  111  void CPools::ShutDown() {
  112:     plugin::Call<0x5519F0>();
  113  }

plugin_sa\game_sa\CPopCycle.cpp:
  38  bool CPopCycle::FindNewPedType(ePedType* arg1, int* modelindex, bool arg3, bool arg4) {
  39: 	return plugin::CallAndReturn<bool, 0x60FBD0, ePedType*, int*, bool, bool>(arg1, modelindex, arg3, arg4);
  40  }

  43  float CPopCycle::GetCurrentPercOther_Peds() {
  44: 	return plugin::CallAndReturn<float, 0x610310>();
  45  }

  48  void CPopCycle::Initialise() {
  49: 	plugin::Call<0x5BC090>();
  50  }

  53  bool CPopCycle::IsPedAppropriateForCurrentZone(int modelindex) {
  54: 	return plugin::CallAndReturn<bool, 0x610150, int>(modelindex);
  55  }

  58  bool CPopCycle::IsPedInGroup(int modelIndex, int PopCycle_Group) {
  59: 	return plugin::CallAndReturn<bool, 0x610210, int, int>(modelIndex, PopCycle_Group);
  60  }

  63  bool CPopCycle::PedIsAcceptableInCurrentZone(int modelIndex) {
  64: 	return plugin::CallAndReturn<bool, 0x610720, int>(modelIndex);
  65  }

  68  int CPopCycle::PickARandomGroupOfOtherPeds() {
  69: 	return plugin::CallAndReturn<int, 0x610420>();
  70  }

  73  void CPopCycle::PlayerKilledADealer() {
  74: 	plugin::Call<0x610490>();
  75  }

  78  void CPopCycle::Update() {
  79: 	plugin::Call<0x610BF0>();
  80  }

  83  void CPopCycle::UpdateAreaDodgyness() {
  84: 	plugin::Call<0x610560>();
  85  }

  88  void CPopCycle::UpdateDealerStrengths() {
  89: 	plugin::Call<0x6104B0>();
  90  }

  93  void CPopCycle::UpdatePercentages() {
  94: 	plugin::Call<0x610770>();
  95  }

plugin_sa\game_sa\CProjectileInfo.cpp:
  15  void CProjectileInfo::Initialise() {
  16:     plugin::Call<0x737B40>();
  17  }

  20  void CProjectileInfo::RemoveFXSystem(unsigned char bInstantly) {
  21:     plugin::Call<0x737B80, unsigned char>(bInstantly);
  22  }

  25  void CProjectileInfo::Shutdown() {
  26:     plugin::Call<0x737BC0>();
  27  }

  30  CProjectileInfo* CProjectileInfo::GetProjectileInfo(int infoId) {
  31:     return plugin::CallAndReturn<CProjectileInfo*, 0x737BF0, int>(infoId);
  32  }

  35  void CProjectileInfo::RemoveNotAdd(CEntity* creator, eWeaponType weaponType, CVector posn) {
  36:     plugin::Call<0x737C00, CEntity*, eWeaponType, CVector>(creator, weaponType, posn);
  37  }

  40  bool CProjectileInfo::AddProjectile(CEntity* creator, eWeaponType weaponType, CVector posn, float force, CVector* direction, CEntity* victim) {
  41:     return plugin::CallAndReturn<bool, 0x737C80, CEntity*, eWeaponType, CVector, float, CVector*, CEntity*>(creator, weaponType, posn, force, direction, victim);
  42  }

  45  void CProjectileInfo::RemoveDetonatorProjectiles() {
  46:     plugin::Call<0x738860>();
  47  }

  50  void CProjectileInfo::RemoveProjectile(CProjectileInfo* projectileInfo, CProjectile* projectileObject) {
  51:     plugin::Call<0x7388F0, CProjectileInfo*, CProjectile*>(projectileInfo, projectileObject);
  52  }

  55  void CProjectileInfo::Update() {
  56:     plugin::Call<0x738B20>();
  57  }

  60  bool CProjectileInfo::IsProjectileInRange(float x1, float y1, float z1, float x2, float y2, float z2, bool bDestroy) {
  61:     return plugin::CallAndReturn<bool, 0x739860, float, float, float, float, float, float, bool>(x1, y1, z1, x2, y2, z2, bDestroy);
  62  }

  65  void CProjectileInfo::RemoveAllProjectiles() {
  66:     plugin::Call<0x7399B0>();
  67  }

  70  bool CProjectileInfo::RemoveIfThisIsAProjectile(CObject* object) {
  71:     return plugin::CallAndReturn<bool, 0x739A40, CObject*>(object);
  72  }

plugin_sa\game_sa\CPtrList.cpp:
  10  unsigned int CPtrList::CountElements() {
  11:     return plugin::CallMethodAndReturn<unsigned int, 0x5521B0, CPtrList *>(this);
  12  }

  15  bool CPtrList::IsMemberOfList(void* memberNode) {
  16:     return plugin::CallMethodAndReturn<bool, 0x5521D0, CPtrList *, void*>(this, memberNode);
  17  }

plugin_sa\game_sa\CPtrListDoubleLink.cpp:
  10  void CPtrListDoubleLink::Flush() {
  11:     plugin::CallMethod<0x552470, CPtrListDoubleLink *>(this);
  12  }

  15  void CPtrListDoubleLink::AddItem(void* item) {
  16:     plugin::CallMethod<0x533670, CPtrListDoubleLink *, void*>(this, item);
  17  }

  20  void CPtrListDoubleLink::DeleteItem(void* item) {
  21:     plugin::CallMethod<0x5336B0, CPtrListDoubleLink *, void*>(this, item);
  22  }

plugin_sa\game_sa\CPtrListSingleLink.cpp:
  10  void CPtrListSingleLink::Flush() {
  11:     plugin::CallMethod<0x552400, CPtrListSingleLink *>(this);
  12  }

  15  void CPtrListSingleLink::AddItem(void* item) {
  16:     plugin::CallMethod<0x5335E0, CPtrListSingleLink *, void*>(this, item);
  17  }

  20  void CPtrListSingleLink::DeleteItem(void* item) {
  21:     plugin::CallMethod<0x533610, CPtrListSingleLink *, void*>(this, item);
  22  }

plugin_sa\game_sa\CPtrNodeDoubleLink.cpp:
  10  void* CPtrNodeDoubleLink::operator new(unsigned int size) {
  11:     return plugin::CallAndReturn<void*, 0x5523C0, unsigned int>(size);
  12  }

  15  void CPtrNodeDoubleLink::operator delete(void* data) {
  16:     plugin::Call<0x5523D0, void*>(data);
  17  }

plugin_sa\game_sa\CPtrNodeSingleLink.cpp:
  10  void* CPtrNodeSingleLink::operator new(unsigned int size) {
  11:     return plugin::CallAndReturn<void*, 0x552380, unsigned int>(size);
  12  }

  15  void CPtrNodeSingleLink::operator delete(void* data) {
  16:     plugin::Call<0x552390, void*>(data);
  17  }

plugin_sa\game_sa\CQuadTreeNode.cpp:
  10  void CQuadTreeNode::AddItem(void* item, CRect const& rect) {
  11:     plugin::CallMethod<0x552CD0, CQuadTreeNode *, void*, CRect const&>(this, item, rect);
  12  }

  15  CQuadTreeNode::CQuadTreeNode(CRect const& rect, int startLevel) {
  16:     plugin::CallMethod<0x552830, CQuadTreeNode *, CRect const&, int>(this, rect, startLevel);
  17  }

  20  void CQuadTreeNode::DeleteItem(void* item) {
  21:     plugin::CallMethod<0x552A40, CQuadTreeNode *, void*>(this, item);
  22  }

  25  void CQuadTreeNode::DeleteItem(void* item, CRect const& rect) {
  26:     plugin::CallMethod<0x552A90, CQuadTreeNode *, void*, CRect const&>(this, item, rect);
  27  }

  30  int CQuadTreeNode::FindSector(CRect const& rect) {
  31:     return plugin::CallMethodAndReturn<int, 0x5525A0, CQuadTreeNode *, CRect const&>(this, rect);
  32  }

  35  int CQuadTreeNode::FindSector(CVector2D const& posn) {
  36:     return plugin::CallMethodAndReturn<int, 0x552640, CQuadTreeNode *, CVector2D const&>(this, posn);
  37  }

  40  void CQuadTreeNode::ForAllMatching(CRect const& rect, void(*callback)(CRect const&, void *)) {
  41:     plugin::CallMethod<0x552980, CQuadTreeNode *, CRect const&, void(*)(CRect const&, void *)>(this, rect, callback);
  42  }

  45  void CQuadTreeNode::ForAllMatching(CVector2D const& posn, void(*callback)(CVector2D const&, void *)) {
  46:     plugin::CallMethod<0x5529F0, CQuadTreeNode *, CVector2D const&, void(*)(CVector2D const&, void *)>(this, posn, callback);
  47  }

  50  void CQuadTreeNode::GetAll(CPtrListSingleLink& list) {
  51:     plugin::CallMethod<0x552870, CQuadTreeNode *, CPtrListSingleLink&>(this, list);
  52  }

  55  void CQuadTreeNode::GetAllMatching(CRect const& rect, CPtrListSingleLink& list) {
  56:     plugin::CallMethod<0x5528C0, CQuadTreeNode *, CRect const&, CPtrListSingleLink&>(this, rect, list);
  57  }

  60  void CQuadTreeNode::GetAllMatching(CVector2D const& posn, CPtrListSingleLink& list) {
  61:     plugin::CallMethod<0x552930, CQuadTreeNode *, CVector2D const&, CPtrListSingleLink&>(this, posn, list);
  62  }

  65  bool CQuadTreeNode::InSector(CRect const& rect, int sector) {
  66:     return plugin::CallMethodAndReturn<bool, 0x5526A0, CQuadTreeNode *, CRect const&, int>(this, rect, sector);
  67  }

  70  void CQuadTreeNode::InitPool() {
  71:     plugin::CallMethod<0x552C00, CQuadTreeNode *>(this);
  72  }

  75  void CQuadTreeNode::operator delete(void* data) {
  76:     plugin::Call<0x552C90, void*>(data);
  77  }

  80  void* CQuadTreeNode::operator new(unsigned int size) {
  81:     return plugin::CallAndReturn<void*, 0x552C80, unsigned int>(size);
  82  }

  85  CQuadTreeNode::~CQuadTreeNode() {
  86:     plugin::CallMethod<0x552520, CQuadTreeNode *>(this);
  87  }

plugin_sa\game_sa\CRegisteredMotionBlurStreak.cpp:
   9  void CRegisteredMotionBlurStreak::Update() {
  10:     plugin::CallMethod<0x721EE0, CRegisteredMotionBlurStreak *>(this);
  11  }

  14  void CRegisteredMotionBlurStreak::Render() {
  15:     plugin::CallMethod<0x721F70, CRegisteredMotionBlurStreak *>(this);
  16  }

plugin_sa\game_sa\CRenderer.cpp:
   37  void CRenderer::Init() {
   38:     plugin::Call<0x5531C0>();
   39  }

   42  void CRenderer::Shutdown() {
   43:     plugin::Call<0x5531D0>();
   44  }

   47  void CRenderer::RenderFadingInEntities() {
   48:     plugin::Call<0x5531E0>();
   49  }

   52  void CRenderer::RenderFadingInUnderwaterEntities() {
   53:     plugin::Call<0x553220>();
   54  }

   57  void CRenderer::RenderOneRoad(CEntity* entity) {
   58:     plugin::Call<0x553230, CEntity*>(entity);
   59  }

   62  void CRenderer::RenderOneNonRoad(CEntity* entity) {
   63:     plugin::Call<0x553260, CEntity*>(entity);
   64  }

   67  void CRenderer::RemoveVehiclePedLights(CPhysical* entity) {
   68:     plugin::Call<0x553390, CPhysical*>(entity);
   69  }

   72  void CRenderer::AddEntityToRenderList(CEntity* entity, float distance) {
   73:     plugin::Call<0x5534B0, CEntity*, float>(entity, distance);
   74  }

   77  void CRenderer::ScanSectorList_ListModels(int sector_x, int sector_y) {
   78:     plugin::Call<0x5535D0, int, int>(sector_x, sector_y);
   79  }

   82  void CRenderer::ScanSectorList_ListModelsVisible(int sector_x, int sector_y) {
   83:     plugin::Call<0x553650, int, int>(sector_x, sector_y);
   84  }

   87  tRenderListEntry* CRenderer::GetLodRenderListBase() {
   88:     return plugin::CallAndReturn<tRenderListEntry*, 0x5536D0>();
   89  }

   92  tRenderListEntry* CRenderer::GetLodDontRenderListBase() {
   93:     return plugin::CallAndReturn<tRenderListEntry*, 0x5536E0>();
   94  }

   97  void CRenderer::ResetLodRenderLists() {
   98:     plugin::Call<0x5536F0>();
   99  }

  102  void CRenderer::AddToLodRenderList(CEntity* entity, float distance) {
  103:     plugin::Call<0x553710, CEntity*, float>(entity, distance);
  104  }

  107  void CRenderer::AddToLodDontRenderList(CEntity* entity, float distance) {
  108:     plugin::Call<0x553740, CEntity*, float>(entity, distance);
  109  }

  112  void CRenderer::ProcessLodRenderLists() {
  113:     plugin::Call<0x553770>();
  114  }

  117  void CRenderer::PreRender() {
  118:     plugin::Call<0x553910>();
  119  }

  122  void CRenderer::RenderRoads() {
  123:     plugin::Call<0x553A10>();
  124  }

  127  void CRenderer::RenderEverythingBarRoads() {
  128:     plugin::Call<0x553AA0>();
  129  }

  132  void CRenderer::RenderFirstPersonVehicle() {
  133:     plugin::Call<0x553D00>();
  134  }

  137  bool CRenderer::SetupLightingForEntity(CEntity* entity) {
  138:     return plugin::CallAndReturn<bool, 0x553E40, CEntity*>(entity);
  139  }

  142  int CRenderer::SetupMapEntityVisibility(CEntity* entity, CBaseModelInfo* modelInfo, float distance, bool arg3) {
  143:     return plugin::CallAndReturn<int, 0x553F60, CEntity*, CBaseModelInfo*, float, bool>(entity, modelInfo, distance, arg3);
  144  }

  147  int CRenderer::SetupEntityVisibility(CEntity* entity, float& outDistance) {
  148:     return plugin::CallAndReturn<int, 0x554230, CEntity*, float&>(entity, outDistance);
  149  }

  152  int CRenderer::SetupBigBuildingVisibility(CEntity* entity, float& outDistance) {
  153:     return plugin::CallAndReturn<int, 0x554650, CEntity*, float&>(entity, outDistance);
  154  }

  157  void CRenderer::ScanSectorList(int sector_x, int sector_y) {
  158:     plugin::Call<0x554840, int, int>(sector_x, sector_y);
  159  }

  162  void CRenderer::ScanBigBuildingList(int sector_x, int sector_y) {
  163:     plugin::Call<0x554B10, int, int>(sector_x, sector_y);
  164  }

  167  int CRenderer::GetObjectsInFrustum(CEntity** outEntities, float distance, RwMatrixTag* transformMat) {
  168:     return plugin::CallAndReturn<int, 0x554C60, CEntity**, float, RwMatrixTag*>(outEntities, distance, transformMat);
  169  }

  172  bool CRenderer::ShouldModelBeStreamed(CEntity* entity, CVector const& origin, float farClip) {
  173:     return plugin::CallAndReturn<bool, 0x554EB0, CEntity*, CVector const&, float>(entity, origin, farClip);
  174  }

  177  void CRenderer::ScanWorld() {
  178:     plugin::Call<0x554FE0>();
  179  }

  182  void CRenderer::ScanPtrList_RequestModels(CPtrList& ptrList) {
  183:     plugin::Call<0x555680, CPtrList&>(ptrList);
  184  }

  187  void CRenderer::ConstructRenderList() {
  188:     plugin::Call<0x5556E0>();
  189  }

  192  void CRenderer::ScanSectorList_RequestModels(int sector_x, int sector_y) {
  193:     plugin::Call<0x555900, int, int>(sector_x, sector_y);
  194  }

  197  void CRenderer::RequestObjectsInFrustum(RwMatrixTag* transformMat, int modelRequesFlags) {
  198:     plugin::Call<0x555960, RwMatrixTag*, int>(transformMat, modelRequesFlags);
  199  }

  202  void CRenderer::RequestObjectsInDirection(CVector const& posn, float angle, int modelRequesFlags) {
  203:     plugin::Call<0x555CB0, CVector const&, float, int>(posn, angle, modelRequesFlags);
  204  }

  207  void CRenderer::SetupScanLists(int sector_x, int sector_y) {
  208:     plugin::Call<0x553540, int, int>(sector_x, sector_y);
  209  }

plugin_sa\game_sa\CRoadBlocks.cpp:
  19  void CRoadBlocks::RegisterScriptRoadBlock(CVector *cornerA, CVector *cornerB, byte type) {      
  20:     plugin::CallDynGlobal<CVector *, CVector *, byte>(gaddrof(CRoadBlocks::RegisterScriptRoadBlock), cornerA, cornerB, type);
  21  }

  26  void CRoadBlocks::ClearScriptRoadBlocks() {
  27:     plugin::CallDynGlobal<>(gaddrof(CRoadBlocks::ClearScriptRoadBlocks));
  28  }

  33  void CRoadBlocks::Init() {
  34:     plugin::CallDynGlobal<>(gaddrof(CRoadBlocks::Init));
  35  }

  40  void CRoadBlocks::GenerateRoadBlockCopsForCar(CVehicle * car, int pedsPositionsType, byte type) {      
  41:     plugin::CallDynGlobal<CVehicle *, int, byte>(gaddrof(CRoadBlocks::GenerateRoadBlockCopsForCar), car, pedsPositionsType, type);
  42  }

  47  void CRoadBlocks::CreateRoadBlockBetween2Points(CVector *a, CVector *b, byte type) {      
  48:     plugin::CallDynGlobal<CVector *, CVector *, byte>(gaddrof(CRoadBlocks::CreateRoadBlockBetween2Points), a, b, type);
  49  }

  54  void CRoadBlocks::GenerateRoadBlocks() {      
  55:     plugin::CallDynGlobal<>(gaddrof(CRoadBlocks::GenerateRoadBlocks));
  56  }

plugin_sa\game_sa\CRunningScript.cpp:
   16  void CRunningScript::AddScriptToList(CRunningScript **queuelist) {
   17:     plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript **>(gaddrof(CRunningScript::AddScriptToList), this, queuelist);
   18  }

   23  void CRunningScript::CarInAreaCheckCommand(int commandID) {
   24:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CarInAreaCheckCommand), this, commandID);
   25  }

   30  void CRunningScript::CharInAngledAreaCheckCommand(int commandID) {
   31:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CharInAngledAreaCheckCommand), this, commandID);
   32  }

   37  void CRunningScript::CharInAreaCheckCommand(int commandID) {
   38:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CharInAreaCheckCommand), this, commandID);
   39  }

   44  tScriptParam CRunningScript::CollectNextParameterWithoutIncreasingPC() {
   45:     return plugin::CallMethodAndReturnDynGlobal<tScriptParam, CRunningScript *>(gaddrof(CRunningScript::CollectNextParameterWithoutIncreasingPC), this);
   46  }

   51  void CRunningScript::CollectParameters(short count) {
   52:     plugin::CallMethodDynGlobal<CRunningScript *, short>(gaddrof(CRunningScript::CollectParameters), this, count);
   53  }

   58  void CRunningScript::DoDeatharrestCheck() {
   59:     plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::DoDeatharrestCheck), this);
   60  }

   65  void CRunningScript::FlameInAngledAreaCheckCommand(int commandID) {
   66:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::FlameInAngledAreaCheckCommand), this, commandID);
   67  }

   72  void CRunningScript::GetCorrectPedModelIndexForEmergencyServiceType(ePedType pedType, int *pModelId) {
   73:     plugin::CallMethodDynGlobal<CRunningScript *, ePedType, int *>(gaddrof(CRunningScript::GetCorrectPedModelIndexForEmergencyServiceType), this, pedType, pModelId);
   74  }

   79  short CRunningScript::GetIndexOfGlobalVariable() {
   80:     return plugin::CallMethodAndReturnDynGlobal<short, CRunningScript *>(gaddrof(CRunningScript::GetIndexOfGlobalVariable), this);
   81  }

   86  short CRunningScript::GetPadState(unsigned short playerIndex, unsigned short buttonID) {
   87:     return plugin::CallMethodAndReturnDynGlobal<short, CRunningScript *, unsigned short, unsigned short>(gaddrof(CRunningScript::GetPadState), this, playerIndex, buttonID);
   88  }

   93  void *CRunningScript::GetPointerToLocalArrayElement(int off, unsigned short idx, unsigned char mul) {
   94:     return plugin::CallMethodAndReturnDynGlobal<void*,CRunningScript *, int, unsigned short, unsigned char>(gaddrof(CRunningScript::GetPointerToLocalArrayElement), this, off, idx, mul);
   95  }

  100  void *CRunningScript::GetPointerToLocalVariable(int varId) {
  101:     return plugin::CallMethodAndReturnDynGlobal<void* ,CRunningScript *, int>(gaddrof(CRunningScript::GetPointerToLocalVariable), this, varId);
  102  }

  107  tScriptParam *CRunningScript::GetPointerToScriptVariable(unsigned char variableType) {
  108:     return plugin::CallMethodAndReturnDynGlobal<tScriptParam *, CRunningScript *, unsigned char>(gaddrof(CRunningScript::GetPointerToScriptVariable), this, variableType);
  109  }

  114  void CRunningScript::GivePedScriptedTask(int pedHandle, CTask *task, int commandID) {
  115:     plugin::CallMethodDynGlobal<CRunningScript *, int, CTask *, int>(gaddrof(CRunningScript::GivePedScriptedTask), this, pedHandle, task, commandID);
  116  }

  121  void CRunningScript::Init() {
  122:     plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::Init), this);
  123  }

  128  bool CRunningScript::IsPedDead(CPed *pPed) {
  129:     return plugin::CallMethodAndReturnDynGlobal<bool, CRunningScript *, CPed *>(gaddrof(CRunningScript::IsPedDead), this, pPed);
  130  }

  135  void CRunningScript::LocateCarCommand(int commandID) {
  136:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCarCommand), this, commandID);
  137  }

  142  void CRunningScript::LocateCharCarCommand(int commandID) {
  143:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCarCommand), this, commandID);
  144  }

  149  void CRunningScript::LocateCharCharCommand(int commandID) {
  150:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCharCommand), this, commandID);
  151  }

  156  void CRunningScript::LocateCharCommand(int commandID) {
  157:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCommand), this, commandID);
  158  }

  163  void CRunningScript::LocateCharObjectCommand(int commandID) {
  164:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharObjectCommand), this, commandID);
  165  }

  170  void CRunningScript::LocateObjectCommand(int commandID) {
  171:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateObjectCommand), this, commandID);
  172  }

  177  void CRunningScript::ObjectInAngledAreaCheckCommand(int commandID) {
  178:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ObjectInAngledAreaCheckCommand), this, commandID);
  179  }

  184  void CRunningScript::ObjectInAreaCheckCommand(int commandID) {
  185:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ObjectInAreaCheckCommand), this, commandID);
  186  }

  191  void CRunningScript::PlayAnimScriptCommand(int commandID) {
  192:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::PlayAnimScriptCommand), this, commandID);
  193  }

  198  void CRunningScript::Process() {
  199:     plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::Process), this);
  200  }

  205  char CRunningScript::ProcessCommands0To99(int commandID) {
  206:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands0To99), this, commandID);
  207  }

  212  char CRunningScript::ProcessCommands1000To1099(int commandID) {
  213:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1000To1099), this, commandID);
  214  }

  219  char CRunningScript::ProcessCommands100To199(int commandID) {
  220:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands100To199), this, commandID);
  221  }

  226  char CRunningScript::ProcessCommands1100To1199(int commandID) {
  227:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1100To1199), this, commandID);
  228  }

  233  char CRunningScript::ProcessCommands1200To1299(int commandID) {
  234:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1200To1299), this, commandID);
  235  }

  240  char CRunningScript::ProcessCommands1300To1399(int commandID) {
  241:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1300To1399), this, commandID);
  242  }

  247  char CRunningScript::ProcessCommands1400To1499(int commandID) {
  248:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1400To1499), this, commandID);
  249  }

  254  char CRunningScript::ProcessCommands1500To1599(int commandID) {
  255:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1500To1599), this, commandID);
  256  }

  261  char CRunningScript::ProcessCommands1600To1699(int commandID) {
  262:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1600To1699), this, commandID);
  263  }

  268  char CRunningScript::ProcessCommands1700To1799(int commandID) {
  269:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1700To1799), this, commandID);
  270  }

  275  char CRunningScript::ProcessCommands1800To1899(int commandID) {
  276:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1800To1899), this, commandID);
  277  }

  282  char CRunningScript::ProcessCommands1900To1999(int commandID) {
  283:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1900To1999), this, commandID);
  284  }

  289  char CRunningScript::ProcessCommands2000To2099(int commandID) {
  290:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2000To2099), this, commandID);
  291  }

  296  char CRunningScript::ProcessCommands200To299(int commandID) {
  297:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands200To299), this, commandID);
  298  }

  303  char CRunningScript::ProcessCommands2100To2199(int commandID) {
  304:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2100To2199), this, commandID);
  305  }

  310  char CRunningScript::ProcessCommands2200To2299(int commandID) {
  311:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2200To2299), this, commandID);
  312  }

  317  char CRunningScript::ProcessCommands2300To2399(int commandID) {
  318:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2300To2399), this, commandID);
  319  }

  324  char CRunningScript::ProcessCommands2400To2499(int commandID) {
  325:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2400To2499), this, commandID);
  326  }

  331  char CRunningScript::ProcessCommands2500To2599(int commandID) {
  332:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2500To2599), this, commandID);
  333  }

  338  char CRunningScript::ProcessCommands2600To2699(int commandID) {
  339:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2600To2699), this, commandID);
  340  }

  345  char CRunningScript::ProcessCommands300To399(int commandID) {
  346:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands300To399), this, commandID);
  347  }

  352  char CRunningScript::ProcessCommands400To499(int commandID) {
  353:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands400To499), this, commandID);
  354  }

  359  char CRunningScript::ProcessCommands500To599(int commandID) {
  360:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands500To599), this, commandID);
  361  }

  366  char CRunningScript::ProcessCommands600To699(int commandID) {
  367:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands600To699), this, commandID);
  368  }

  373  char CRunningScript::ProcessCommands700To799(int commandID) {
  374:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands700To799), this, commandID);
  375  }

  380  char CRunningScript::ProcessCommands800To899(int commandID) {
  381:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands800To899), this, commandID);
  382  }

  387  char CRunningScript::ProcessCommands900To999(int commandID) {
  388:     return plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands900To999), this, commandID);
  389  }

  394  void CRunningScript::ProcessOneCommand() {
  395:     plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::ProcessOneCommand), this);
  396  }

  401  void CRunningScript::ReadArrayInformation(int move, unsigned short *pOffset, int *pIdx) {
  402:     plugin::CallMethodDynGlobal<CRunningScript *, int, unsigned short *, int *>(gaddrof(CRunningScript::ReadArrayInformation), this, move, pOffset, pIdx);
  403  }

  408  void CRunningScript::ReadParametersForNewlyStartedScript(CRunningScript *pNewScript) {
  409:     plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript *>(gaddrof(CRunningScript::ReadParametersForNewlyStartedScript), this, pNewScript);
  410  }

  415  void CRunningScript::ReadTextLabelFromScript(char *pBuffer, unsigned char nBufferLength) {
  416:     plugin::CallMethodDynGlobal<CRunningScript *, char *, unsigned char>(gaddrof(CRunningScript::ReadTextLabelFromScript), this, pBuffer, nBufferLength);
  417  }

  422  void CRunningScript::RemoveScriptFromList(CRunningScript **queuelist) {
  423:     plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript **>(gaddrof(CRunningScript::RemoveScriptFromList), this, queuelist);
  424  }

  429  void CRunningScript::ScriptTaskPickUpObject(int commandID) {
  430:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ScriptTaskPickUpObject), this, commandID);
  431  }

  436  void CRunningScript::SetCharCoordinates(CPed *pPed, float x_coord, float y_coord, float z_coord, bool bWarpGang, bool bOffset) {
  437:     plugin::CallMethodDynGlobal<CRunningScript *, CPed *, float, float, float, bool, bool>(gaddrof(CRunningScript::SetCharCoordinates), this, pPed, x_coord, y_coord, z_coord, bWarpGang, bOffset);
  438  }

  443  void CRunningScript::ShutdownThisScript() {
  444:     plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::ShutdownThisScript), this);
  445  }

  450  void CRunningScript::StoreParameters(short count) {
  451:     plugin::CallMethodDynGlobal<CRunningScript *, short>(gaddrof(CRunningScript::StoreParameters), this, count);
  452  }

  457  bool CRunningScript::ThisIsAValidRandomPed(ePedType pedType, bool civilian, bool gang, bool criminal) {
  458:     return plugin::CallMethodAndReturnDynGlobal<bool, CRunningScript *, ePedType, bool, bool, bool>(gaddrof(CRunningScript::ThisIsAValidRandomPed), this, pedType, civilian, gang, criminal);
  459  }

  464  void CRunningScript::UpdateCompareFlag(bool state) {
  465:     plugin::CallMethodDynGlobal<CRunningScript *, bool>(gaddrof(CRunningScript::UpdateCompareFlag), this, state);
  466  }

  471  void CRunningScript::UpdatePC(int newIP) {
  472:     plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::UpdatePC), this, newIP);
  473  }

plugin_sa\game_sa\CScriptResourceManager.cpp:
  14  void CScriptResourceManager::AddToResourceManager(int modelID, unsigned int ResourceType, CRunningScript *pScript) {
  15:     plugin::CallMethodDynGlobal<CScriptResourceManager *, int, unsigned int, CRunningScript *>(gaddrof(CScriptResourceManager::AddToResourceManager), this, modelID, ResourceType, pScript);
  16  }

  21  bool CScriptResourceManager::HasResourceBeenRequested(int ModelId, unsigned int a4) {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CScriptResourceManager *, int, unsigned int>(gaddrof(CScriptResourceManager::HasResourceBeenRequested), this, ModelId, a4);
  23  }

  28  bool CScriptResourceManager::RemoveFromResourceManager(int modelID, unsigned int ResourceType, CRunningScript *pScript) {
  29:     return plugin::CallMethodAndReturnDynGlobal<bool, CScriptResourceManager *, int, unsigned int, CRunningScript *>(gaddrof(CScriptResourceManager::RemoveFromResourceManager), this, modelID, ResourceType, pScript);
  30  }

plugin_sa\game_sa\CScriptsForBrains.cpp:
   17  void CScriptsForBrains::AddNewScriptBrain(short ImgIndex, short Model, unsigned short Priority, signed char attachType, signed char Type, float Radius) {
   18:     plugin::CallMethodDynGlobal<CScriptsForBrains *, short, short, unsigned short, signed char, signed char, float>(gaddrof(CScriptsForBrains::AddNewScriptBrain), this, ImgIndex, Model, Priority, attachType, Type, Radius);
   19  }

   24  void CScriptsForBrains::AddNewStreamedScriptBrainForCodeUse(short a2, char *a3, signed char attachtype) {
   25:     plugin::CallMethodDynGlobal<CScriptsForBrains *, short, char *, signed char>(gaddrof(CScriptsForBrains::AddNewStreamedScriptBrainForCodeUse), this, a2, a3, attachtype);
   26  }

   31  void CScriptsForBrains::CheckIfNewEntityNeedsScript(CEntity *pEntity, signed char attachType, void *unused) {
   32:     plugin::CallMethodDynGlobal<CScriptsForBrains *, CEntity *, signed char, void *>(gaddrof(CScriptsForBrains::CheckIfNewEntityNeedsScript), this, pEntity, attachType, unused);
   33  }

   38  signed short CScriptsForBrains::GetIndexOfScriptBrainWithThisName(char const *name, signed char Attachtype) {
   39:     return plugin::CallMethodAndReturnDynGlobal<signed short, CScriptsForBrains *, char const *, signed char>(gaddrof(CScriptsForBrains::GetIndexOfScriptBrainWithThisName), this, name, Attachtype);
   40  }

   45  bool CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded(char const *name) {
   46:     return plugin::CallMethodAndReturnDynGlobal<bool, CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded), this, name);
   47  }

   52  void CScriptsForBrains::Init() {
   53:     plugin::CallMethodDynGlobal<CScriptsForBrains *>(gaddrof(CScriptsForBrains::Init), this);
   54  }

   59  bool CScriptsForBrains::IsObjectWithinBrainActivationRange(CObject *entity, CVector const *point) {
   60:     return plugin::CallMethodAndReturnDynGlobal<bool, CScriptsForBrains *, CObject *, CVector const *>(gaddrof(CScriptsForBrains::IsObjectWithinBrainActivationRange), this, entity, point);
   61  }

   66  void CScriptsForBrains::MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded(char const *name) {
   67:     plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded), this, name);
   68  }

   73  void CScriptsForBrains::RequestAttractorScriptBrainWithThisName(char const *name) {
   74:     plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::RequestAttractorScriptBrainWithThisName), this, name);
   75  }

   80  void CScriptsForBrains::StartAttractorScriptBrainWithThisName(char const *name, CEntity *pEntity, unsigned char bHasAScriptBrain) {
   81:     plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *, CEntity *, unsigned char>(gaddrof(CScriptsForBrains::StartAttractorScriptBrainWithThisName), this, name, pEntity, bHasAScriptBrain);
   82  }

   87  void CScriptsForBrains::StartNewStreamedScriptBrain(unsigned char index, CEntity *pEntity, unsigned char bHasAScriptBrain) {
   88:     plugin::CallMethodDynGlobal<CScriptsForBrains *, unsigned char, CEntity *, unsigned char>(gaddrof(CScriptsForBrains::StartNewStreamedScriptBrain), this, index, pEntity, bHasAScriptBrain);
   89  }

   94  void CScriptsForBrains::StartOrRequestNewStreamedScriptBrain(unsigned char index, CEntity *pEntity, signed char attachType, unsigned char bAddToWaitingArray) {
   95:     plugin::CallMethodDynGlobal<CScriptsForBrains *, unsigned char, CEntity *, signed char, unsigned char>(gaddrof(CScriptsForBrains::StartOrRequestNewStreamedScriptBrain), this, index, pEntity, attachType, bAddToWaitingArray);
   96  }

  101  void CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName(char const *name, CEntity *pEntity, signed char attachType) {
  102:     plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *, CEntity *, signed char>(gaddrof(CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName), this, name, pEntity, attachType);
  103  }

  108  void CScriptsForBrains::SwitchAllObjectBrainsWithThisID(signed char ID, bool bStatus) {
  109:     plugin::CallMethodDynGlobal<CScriptsForBrains *, signed char, bool>(gaddrof(CScriptsForBrains::SwitchAllObjectBrainsWithThisID), this, ID, bStatus);
  110  }

plugin_sa\game_sa\CSetPiece.cpp:
   10  CCopPed* CSetPiece::TryToGenerateCopPed(CVector2D posn) {
   11:     return plugin::CallMethodAndReturn<CCopPed*, 0x499690, CSetPiece *, CVector2D>(this, posn);
   12  }

   16      CVector2D result;
   17:     plugin::CallMethod<0x4997A0, CSetPiece *, CVector2D*>(this, &result);
   18      return result;

   23      CVector2D result;
   24:     plugin::CallMethod<0x4997E0, CSetPiece *, CVector2D*>(this, &result);
   25      return result;

   30      CVector2D result;
   31:     plugin::CallMethod<0x499820, CSetPiece *, CVector2D*>(this, &result);
   32      return result;

   37      CVector2D result;
   38:     plugin::CallMethod<0x499860, CSetPiece *, CVector2D*>(this, &result);
   39      return result;

   43  CVehicle* CSetPiece::TryToGenerateCopCar(CVector2D posn, CVector2D target) {
   44:     return plugin::CallMethodAndReturn<CVehicle*, 0x4998A0, CSetPiece *, CVector2D, CVector2D>(this, posn, target);
   45  }

   48  void CSetPiece::Update() {
   49:     plugin::CallMethod<0x499A80, CSetPiece *>(this);
   50  }

   53  void CSetPiece::SetCornerA(CVector2D coord) {
   54:     plugin::CallMethod<0x499120, CSetPiece *, CVector2D>(this, coord);
   55  }

   58  void CSetPiece::SetCornerB(CVector2D coord) {
   59:     plugin::CallMethod<0x499150, CSetPiece *, CVector2D>(this, coord);
   60  }

   63  void CSetPiece::SetSpawnCoord1(CVector2D coord) {
   64:     plugin::CallMethod<0x499180, CSetPiece *, CVector2D>(this, coord);
   65  }

   68  void CSetPiece::SetSpawnCoord2(CVector2D coord) {
   69:     plugin::CallMethod<0x4991B0, CSetPiece *, CVector2D>(this, coord);
   70  }

   73  void CSetPiece::SetTargetCoord1(CVector2D coord) {
   74:     plugin::CallMethod<0x4991E0, CSetPiece *, CVector2D>(this, coord);
   75  }

   78  void CSetPiece::SetTargetCoord2(CVector2D coord) {
   79:     plugin::CallMethod<0x499210, CSetPiece *, CVector2D>(this, coord);
   80  }

   83  float CSetPiece::GetCornerAX() {
   84:     return plugin::CallMethodAndReturn<float, 0x499240, CSetPiece *>(this);
   85  }

   88  float CSetPiece::GetCornerAY() {
   89:     return plugin::CallMethodAndReturn<float, 0x499260, CSetPiece *>(this);
   90  }

   93  float CSetPiece::GetCornerBX() {
   94:     return plugin::CallMethodAndReturn<float, 0x499280, CSetPiece *>(this);
   95  }

   98  float CSetPiece::GetCornerBY() {
   99:     return plugin::CallMethodAndReturn<float, 0x4992A0, CSetPiece *>(this);
  100  }

  103  float CSetPiece::GetSpawnCoord1X() {
  104:     return plugin::CallMethodAndReturn<float, 0x4992C0, CSetPiece *>(this);
  105  }

  108  float CSetPiece::GetSpawnCoord1Y() {
  109:     return plugin::CallMethodAndReturn<float, 0x4992E0, CSetPiece *>(this);
  110  }

  113  float CSetPiece::GetSpawnCoord2X() {
  114:     return plugin::CallMethodAndReturn<float, 0x499300, CSetPiece *>(this);
  115  }

  118  float CSetPiece::GetSpawnCoord2Y() {
  119:     return plugin::CallMethodAndReturn<float, 0x499320, CSetPiece *>(this);
  120  }

  123  float CSetPiece::GetTargetCoord1X() {
  124:     return plugin::CallMethodAndReturn<float, 0x499340, CSetPiece *>(this);
  125  }

  128  float CSetPiece::GetTargetCoord1Y() {
  129:     return plugin::CallMethodAndReturn<float, 0x499360, CSetPiece *>(this);
  130  }

  133  float CSetPiece::GetTargetCoord2X() {
  134:     return plugin::CallMethodAndReturn<float, 0x499380, CSetPiece *>(this);
  135  }

  138  float CSetPiece::GetTargetCoord2Y() {
  139:     return plugin::CallMethodAndReturn<float, 0x4993A0, CSetPiece *>(this);
  140  }

  143  CSetPiece::CSetPiece() {
  144:     plugin::CallMethod<0x4993C0, CSetPiece *>(this);
  145  }

plugin_sa\game_sa\CSetPieces.cpp:
  14  void CSetPieces::AddOne(unsigned char type, CVector2D cornerA, CVector2D cornerB, CVector2D spawnCoord1, CVector2D targetCoord1, CVector2D spawnCoord2, CVector2D targetCoord2) {
  15:     plugin::Call<0x499500, unsigned char, CVector2D, CVector2D, CVector2D, CVector2D, CVector2D, CVector2D>(type, cornerA, cornerB, spawnCoord1, targetCoord1, spawnCoord2, targetCoord2);
  16  }

  19  void CSetPieces::Init() {
  20:     plugin::Call<0x4994F0>();
  21  }

  24  bool CSetPieces::Load() {
  25:     return plugin::CallAndReturn<bool, 0x5D3CA0>();
  26  }

  29  bool CSetPieces::Save() {
  30:     return plugin::CallAndReturn<bool, 0x5D3C70>();
  31  }

  34  void CSetPieces::Update() {
  35:     plugin::Call<0x49AA00>();
  36  }

plugin_sa\game_sa\CShinyTexts.cpp:
  15  void CShinyTexts::Init() {
  16:     plugin::Call<0x7221B0>();
  17  }

  20  void CShinyTexts::RenderOutGeometryBuffer() {
  21:     plugin::Call<0x7221C0>();
  22  }

  25  void CShinyTexts::Render() {
  26:     plugin::Call<0x724890>();
  27  }

  30  void CShinyTexts::RegisterOne(CVector cornerAA, CVector cornerBA, CVector cornerBB, CVector cornerAB, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, float maxDistance) {
  31:     plugin::Call<0x724B60, CVector, CVector, CVector, CVector, float, float, float, float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, float>(cornerAA, cornerBA, cornerBB, cornerAB, u1, v1, u2, v2, u3, v3, u4, v4, red, green, blue, alpha, maxDistance);
  32  }

plugin_sa\game_sa\CShotInfo.cpp:
  14  void CShotInfo::Initialise() {
  15:     plugin::Call<0x739B60>();
  16  }

  19  void CShotInfo::Shutdown() {
  20:     plugin::Call<0x739C20>();
  21  }

  24  bool CShotInfo::AddShot(CEntity* creator, eWeaponType weaponType, CVector origin, CVector target) {
  25:     return plugin::CallAndReturn<bool, 0x739C30, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, origin, target);
  26  }

  29  bool CShotInfo::GetFlameThrowerShotPosn(unsigned char shotId, CVector* outPosn) {
  30:     return plugin::CallAndReturn<bool, 0x739DE0, unsigned char, CVector*>(shotId, outPosn);
  31  }

  34  void CShotInfo::Update() {
  35:     plugin::Call<0x739E60>();
  36  }

plugin_sa\game_sa\CSpecialFX.cpp:
  16  void CSpecialFX::AddWeaponStreak(int weaponType) {
  17:     plugin::Call<0x7233F0, int>(weaponType);
  18  }

  21  void CSpecialFX::Init() {
  22:     plugin::Call<0x7268F0>();
  23  }

  26  void CSpecialFX::Render() {
  27:     plugin::Call<0x726AD0>();
  28  }

  31  void CSpecialFX::Render2DFXs() {
  32:     plugin::Call<0x721660>();
  33  }

  36  void CSpecialFX::ReplayStarted() {
  37:     plugin::Call<0x721D30>();
  38  }

  41  void CSpecialFX::Shutdown() {
  42:     plugin::Call<0x723390>();
  43  }

  46  void CSpecialFX::Update() {
  47:     plugin::Call<0x726AA0>();
  48  }

plugin_sa\game_sa\CSpecialPlateHandler.cpp:
  10  void CSpecialPlateHandler::Init() {
  11:     plugin::CallMethod<0x6F2D10, CSpecialPlateHandler *>(this);
  12  }

  15  int CSpecialPlateHandler::Find(int carGenId, char* outText) {
  16:     return plugin::CallMethodAndReturn<int, 0x6F2D30, CSpecialPlateHandler *, int, char*>(this, carGenId, outText);
  17  }

  20  void CSpecialPlateHandler::Add(int carGenId, char* plateText) {
  21:     plugin::CallMethod<0x6F2D90, CSpecialPlateHandler *, int, char*>(this, carGenId, plateText);
  22  }

  25  void CSpecialPlateHandler::Remove(int plateTextId) {
  26:     plugin::CallMethod<0x6F2DD0, CSpecialPlateHandler *, int>(this, plateTextId);
  27  }

plugin_sa\game_sa\CStats.cpp:
   38  char* CStats::GetStatID(unsigned short stat) {
   39:     return plugin::CallAndReturn<char*, 0x558DE0, unsigned short>(stat);
   40  }

   43  bool CStats::GetStatType(unsigned short stat) {
   44:     return plugin::CallAndReturn<bool, 0x558E30, unsigned short>(stat);
   45  }

   48  float CStats::GetStatValue(unsigned short stat) {
   49:     return plugin::CallAndReturn<float, 0x558E40, unsigned short>(stat);
   50  }

   53  char CStats::GetTimesMissionAttempted(unsigned char missionId) {
   54:     return plugin::CallAndReturn<char, 0x558E70, unsigned char>(missionId);
   55  }

   58  void CStats::RegisterMissionAttempted(unsigned char missionId) {
   59:     plugin::Call<0x558E80, unsigned char>(missionId);
   60  }

   63  void CStats::RegisterMissionPassed(unsigned char missionId) {
   64:     plugin::Call<0x558EA0, unsigned char>(missionId);
   65  }

   68  bool CStats::PopulateFavoriteRadioStationList() {
   69:     return plugin::CallAndReturn<bool, 0x558EC0>();
   70  }

   73  int *CStats::GetFullFavoriteRadioStationList() {
   74:     return plugin::CallAndReturn<int*, 0x558F90>();
   75  }

   78  int CStats::FindMostFavoriteRadioStation() {
   79:     return plugin::CallAndReturn<int, 0x558FA0>();
   80  }

   83  int CStats::FindLeastFavoriteRadioStation() {
   84:     return plugin::CallAndReturn<int, 0x559010>();
   85  }

   88  int CStats::FindCriminalRatingNumber() {
   89:     return plugin::CallAndReturn<int, 0x559080>();
   90  }

   93  float CStats::GetPercentageProgress() {
   94:     return plugin::CallAndReturn<float, 0x5591E0>();
   95  }

   98  void CStats::BuildStatLine(char* line, void* pValue1, int metrics, void* pValue2, int type) {
   99:     plugin::Call<0x559230, char*, void*, int, void*, int>(line, pValue1, metrics, pValue2, type);
  100  }

  103  int CStats::ConvertToMins(int value) {
  104:     return plugin::CallAndReturn<int, 0x559540, int>(value);
  105  }

  108  int CStats::ConvertToSecs(int value) {
  109:     return plugin::CallAndReturn<int, 0x559560, int>(value);
  110  }

  113  bool CStats::SafeToShowThisStat(unsigned char stat) {
  114:     return plugin::CallAndReturn<bool, 0x559590, unsigned char>(stat);
  115  }

  118  bool CStats::CheckForThreshold(float* pValue, float range) {
  119:     return plugin::CallAndReturn<bool, 0x5595F0, float*, float>(pValue, range);
  120  }

  123  bool CStats::IsStatCapped(unsigned short stat) {
  124:     return plugin::CallAndReturn<bool, 0x559630, unsigned short>(stat);
  125  }

  128  void CStats::ProcessReactionStatsOnDecrement(unsigned char stat) {
  129:     plugin::Call<0x559730, unsigned char>(stat);
  130  }

  133  void CStats::CheckForStatsMessage() {
  134:     plugin::Call<0x559760>();
  135  }

  138  void CStats::LoadStatUpdateConditions() {
  139:     plugin::Call<0x559860>();
  140  }

  143  void CStats::LoadActionReactionStats() {
  144:     plugin::Call<0x5599B0>();
  145  }

  148  int CStats::FindMaxNumberOfGroupMembers() {
  149:     return plugin::CallAndReturn<int, 0x559A50>();
  150  }

  153  float CStats::GetFatAndMuscleModifier(eStatModAbilities statMod) {
  154:     return plugin::CallAndReturn<float, 0x559AF0, eStatModAbilities>(statMod);
  155  }

  158  void CStats::DecrementStat(unsigned short stat, float value) {
  159:     plugin::Call<0x559FA0, unsigned short, float>(stat, value);
  160  }

  163  void CStats::SetStatValue(unsigned short stat, float value) {
  164:     plugin::Call<0x55A070, unsigned short, float>(stat, value);
  165  }

  168  void CStats::RegisterFastestTime(int stat, int time) {
  169:     plugin::Call<0x55A0B0, int, int>(stat, time);
  170  }

  173  void CStats::RegisterBestPosition(int stat, int position) {
  174:     plugin::Call<0x55A160, int, int>(stat, position);
  175  }

  178  char* CStats::FindCriminalRatingString() {
  179:     return plugin::CallAndReturn<char*, 0x55A210>();
  180  }

  183  int CStats::ConstructStatLine(int arg0, unsigned char arg1) {
  184:     return plugin::CallAndReturn<int, 0x55A780, int, unsigned char>(arg0, arg1);
  185  }

  188  void CStats::ProcessReactionStatsOnIncrement(unsigned char stat) {
  189:     plugin::Call<0x55B900, unsigned char>(stat);
  190  }

  193  void CStats::DisplayScriptStatUpdateMessage(unsigned char state, unsigned int stat, float value) {
  194:     plugin::Call<0x55B980, unsigned char, unsigned int, float>(state, stat, value);
  195  }

  198  void CStats::UpdateRespectStat(unsigned char arg0) {
  199:     plugin::Call<0x55BC50, unsigned char>(arg0);
  200  }

  203  void CStats::UpdateSexAppealStat() {
  204:     plugin::Call<0x55BF20>();
  205  }

  208  void CStats::Init() {
  209:     plugin::Call<0x55C0C0>();
  210  }

  213  void CStats::IncrementStat(unsigned short stat, float value) {
  214:     plugin::Call<0x55C180, unsigned short, float>(stat, value);
  215  }

  218  void CStats::SetNewRecordStat(unsigned short stat, float value) {
  219:     plugin::Call<0x55C410, unsigned short, float>(stat, value);
  220  }

  223  void CStats::UpdateFatAndMuscleStats(unsigned int value) {
  224:     plugin::Call<0x55C470, unsigned int>(value);
  225  }

  228  void CStats::UpdateStatsWhenSprinting() {
  229:     plugin::Call<0x55C660>();
  230  }

  233  void CStats::UpdateStatsWhenRunning() {
  234:     plugin::Call<0x55C6F0>();
  235  }

  238  void CStats::UpdateStatsWhenCycling(bool arg0, CBmx* bmx) {
  239:     plugin::Call<0x55C780, bool, CBmx*>(arg0, bmx);
  240  }

  243  void CStats::UpdateStatsWhenSwimming(bool arg0, bool arg1) {
  244:     plugin::Call<0x55C990, bool, bool>(arg0, arg1);
  245  }

  248  void CStats::UpdateStatsWhenDriving(CVehicle* vehicle) {
  249:     plugin::Call<0x55CAC0, CVehicle*>(vehicle);
  250  }

  253  void CStats::UpdateStatsWhenFlying(CVehicle* vehicle) {
  254:     plugin::Call<0x55CC00, CVehicle*>(vehicle);
  255  }

  258  void CStats::UpdateStatsWhenOnMotorBike(CBike* bike) {
  259:     plugin::Call<0x55CD60, CBike*>(bike);
  260  }

  263  void CStats::UpdateStatsWhenWeaponHit(int weaponType) {
  264:     plugin::Call<0x55CEB0, int>(weaponType);
  265  }

  268  void CStats::UpdateStatsWhenFighting() {
  269:     plugin::Call<0x55CFA0>();
  270  }

  273  void CStats::UpdateStatsOnRespawn() {
  274:     plugin::Call<0x55CFC0>();
  275  }

  278  void CStats::UpdateStatsAddToHealth(unsigned int addToHealth) {
  279:     plugin::Call<0x55D030, unsigned int>(addToHealth);
  280  }

  283  void CStats::ModifyStat(unsigned short stat, float value) {
  284:     plugin::Call<0x55D090, unsigned short, float>(stat, value);
  285  }

  288  bool CStats::Save() {
  289:     return plugin::CallAndReturn<bool, 0x5D3B40>();
  290  }

  293  bool CStats::Load() {
  294:     return plugin::CallAndReturn<bool, 0x5D3BF0>();
  295  }

plugin_sa\game_sa\CStreamedScripts.cpp:
  14  signed int CStreamedScripts::FindStreamedScript(char const *scriptname) {
  15:     return plugin::CallMethodAndReturnDynGlobal<signed int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::FindStreamedScript), this, scriptname);
  16  }

  21  signed int CStreamedScripts::FindStreamedScriptQuiet(char const *scriptName) {
  22:     return plugin::CallMethodAndReturnDynGlobal<signed int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::FindStreamedScriptQuiet), this, scriptName);
  23  }

  28  signed short CStreamedScripts::GetProperIndexFromIndexUsedByScript(short scmIndex) {
  29:     return plugin::CallMethodAndReturnDynGlobal<signed short, CStreamedScripts *, short>(gaddrof(CStreamedScripts::GetProperIndexFromIndexUsedByScript), this, scmIndex);
  30  }

  35  char const *CStreamedScripts::GetStreamedScriptFilename(unsigned short index) {
  36:     return plugin::CallMethodAndReturnDynGlobal<char const *, CStreamedScripts *, unsigned short>(gaddrof(CStreamedScripts::GetStreamedScriptFilename), this, index);
  37  }

  42  unsigned short CStreamedScripts::GetStreamedScriptWithThisStartAddress(unsigned char *dataPtr) {
  43:     return plugin::CallMethodAndReturnDynGlobal<unsigned short, CStreamedScripts *, unsigned char *>(gaddrof(CStreamedScripts::GetStreamedScriptWithThisStartAddress), this, dataPtr);
  44  }

  49  void CStreamedScripts::Initialise() {
  50:     plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::Initialise), this);
  51  }

  56  void CStreamedScripts::LoadStreamedScript(RwStream *stream, int index) {
  57:     plugin::CallMethodDynGlobal<CStreamedScripts *, RwStream *, int>(gaddrof(CStreamedScripts::LoadStreamedScript), this, stream, index);
  58  }

  63  void CStreamedScripts::ReInitialise() {
  64:     plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::ReInitialise), this);
  65  }

  70  void CStreamedScripts::ReadStreamedScriptData() {
  71:     plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::ReadStreamedScriptData), this);
  72  }

  77  int CStreamedScripts::RegisterScript(char const *scriptName) {
  78:     return plugin::CallMethodAndReturnDynGlobal<int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::RegisterScript), this, scriptName);
  79  }

  84  void CStreamedScripts::RemoveStreamedScriptFromMemory(int index) {
  85:     plugin::CallMethodDynGlobal<CStreamedScripts *, int>(gaddrof(CStreamedScripts::RemoveStreamedScriptFromMemory), this, index);
  86  }

  91  CRunningScript *CStreamedScripts::StartNewStreamedScript(int index) {
  92:     return plugin::CallMethodAndReturnDynGlobal<CRunningScript *, CStreamedScripts *, int>(gaddrof(CStreamedScripts::StartNewStreamedScript), this, index);
  93  }

plugin_sa\game_sa\CStreaming.cpp:
   62  void *CStreaming::AddEntity(CEntity *a2) {
   63:     return plugin::CallAndReturnDynGlobal<void *, CEntity *>(gaddrof(CStreaming::AddEntity), a2);
   64  }

   69  int CStreaming::AddImageToList(char const *lpFileName, bool bNotPlayerImg) {
   70:     return plugin::CallAndReturnDynGlobal<int, char const *, bool>(gaddrof(CStreaming::AddImageToList), lpFileName, bNotPlayerImg);
   71  }

   76  void CStreaming::AddLodsToRequestList(CVector const *Posn, unsigned int Streamingflags) {
   77:     plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddLodsToRequestList), Posn, Streamingflags);
   78  }

   83  void CStreaming::AddModelsToRequestList(CVector const *posn, unsigned int StreamingFlags) {
   84:     plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddModelsToRequestList), posn, StreamingFlags);
   85  }

   90  bool CStreaming::AddToLoadedVehiclesList() {
   91:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::AddToLoadedVehiclesList));
   92  }

   97  bool CStreaming::AreAnimsUsedByRequestedModels(int AnimFileIndex) {
   98:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreAnimsUsedByRequestedModels), AnimFileIndex);
   99  }

  104  bool CStreaming::AreTexturesUsedByRequestedModels(int txdIndex) {
  105:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreTexturesUsedByRequestedModels), txdIndex);
  106  }

  111  void CStreaming::ClearFlagForAll(unsigned int eStreamingFlag) {
  112:     plugin::CallDynGlobal<unsigned int>(gaddrof(CStreaming::ClearFlagForAll), eStreamingFlag);
  113  }

  118  void CStreaming::ClearSlots(int NumOfSlots) {
  119:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::ClearSlots), NumOfSlots);
  120  }

  125  char CStreaming::ConvertBufferToObject(char *pFileContect, int index, int ChannelIndex) {
  126:     return plugin::CallAndReturnDynGlobal<char, char *, int, int>(gaddrof(CStreaming::ConvertBufferToObject), pFileContect, index, ChannelIndex);
  127  }

  139  bool CStreaming::DeleteLeastUsedEntityRwObject(bool bNotOnScreen, unsigned int StreamingFlags) {
  140:     return plugin::CallAndReturnDynGlobal<bool, bool, unsigned int>(gaddrof(CStreaming::DeleteLeastUsedEntityRwObject), bNotOnScreen, StreamingFlags);
  141  }

  146  void CStreaming::DeleteRwObjectsAfterDeath(CVector const *PlayerPosn) {
  147:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteRwObjectsAfterDeath), PlayerPosn);
  148  }

  153  void CStreaming::DeleteRwObjectsBehindCamera(int memoryToCleanInBytes) {
  154:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::DeleteRwObjectsBehindCamera), memoryToCleanInBytes);
  155  }

  160  bool CStreaming::DeleteRwObjectsBehindCameraInSectorList(CPtrList *List, int memoryToCleanInBytes) {
  161:     return plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsBehindCameraInSectorList), List, memoryToCleanInBytes);
  162  }

  167  void CStreaming::DeleteRwObjectsInSectorList(CPtrList *PtrList, int arg2, int arg3) {
  168:     plugin::CallDynGlobal<CPtrList *, int, int>(gaddrof(CStreaming::DeleteRwObjectsInSectorList), PtrList, arg2, arg3);
  169  }

  174  char CStreaming::DeleteRwObjectsNotInFrustumInSectorList(CPtrList *List, int memoryToCleanInBytes) {
  175:     return plugin::CallAndReturnDynGlobal<char, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsNotInFrustumInSectorList), List, memoryToCleanInBytes);
  176  }

  181  void CStreaming::DisableCopBikes(bool bDisable) {
  182:     plugin::CallDynGlobal<bool>(gaddrof(CStreaming::DisableCopBikes), bDisable);
  183  }

  188  int CStreaming::FindMIPedSlotForInterior(int RandFactor) {
  189:     return plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CStreaming::FindMIPedSlotForInterior), RandFactor);
  190  }

  195  bool CStreaming::FinishLoadingLargeFile(char *FileName, int modelIndex) {
  196:     return plugin::CallAndReturnDynGlobal<bool, char *, int>(gaddrof(CStreaming::FinishLoadingLargeFile), FileName, modelIndex);
  197  }

  202  bool CStreaming::FlushChannels() {
  203:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::FlushChannels));
  204  }

  209  bool CStreaming::FlushRequestList() {
  210:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::FlushRequestList));
  211  }

  216  void CStreaming::ForceLayerToRead(int arg1) {
  217:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::ForceLayerToRead), arg1);
  218  }

  223  int CStreaming::GetDefaultCabDriverModel() {
  224:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultCabDriverModel));
  225  }

  230  int CStreaming::GetDefaultCopCarModel(unsigned int bIncludeCopBike) {
  231:     return plugin::CallAndReturnDynGlobal<int, unsigned int>(gaddrof(CStreaming::GetDefaultCopCarModel), bIncludeCopBike);
  232  }

  237  int CStreaming::GetDefaultCopModel() {
  238:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultCopModel));
  239  }

  244  int CStreaming::GetDefaultFiremanModel() {
  245:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultFiremanModel));
  246  }

  251  int CStreaming::GetDefaultMedicModel() {
  252:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultMedicModel));
  253  }

  258  signed int CStreaming::GetDiscInDrive() {
  259:     return plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CStreaming::GetDiscInDrive));
  260  }

  265  int CStreaming::GetNextFileOnCd(int pos, bool bNotPriority) {
  266:     return plugin::CallAndReturnDynGlobal<int, int, bool>(gaddrof(CStreaming::GetNextFileOnCd), pos, bNotPriority);
  267  }

  272  bool CStreaming::HasSpecialCharLoaded(int slot) {
  273:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasSpecialCharLoaded), slot);
  274  }

  279  bool CStreaming::HasVehicleUpgradeLoaded(int ModelIndex) {
  280:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasVehicleUpgradeLoaded), ModelIndex);
  281  }

  321  void CStreaming::InstanceLoadedModels(CVector const *posn) {
  322:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::InstanceLoadedModels), posn);
  323  }

  328  bool CStreaming::IsCarModelNeededInCurrentZone(int VehicleModelIndex) {
  329:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsCarModelNeededInCurrentZone), VehicleModelIndex);
  330  }

  335  bool CStreaming::IsInitialised() {
  336:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::IsInitialised));
  337  }

  342  bool CStreaming::IsObjectInCdImage(int ModelInex) {
  343:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsObjectInCdImage), ModelInex);
  344  }

  349  bool CStreaming::IsVeryBusy() {
  350:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::IsVeryBusy));
  351  }

  363  void CStreaming::LoadAllRequestedModels(bool bOnlyPriorityRequests) {
  364:     plugin::CallDynGlobal<bool>(gaddrof(CStreaming::LoadAllRequestedModels), bOnlyPriorityRequests);
  365  }

  370  void CStreaming::LoadCdDirectory(char const *ArchiveName, int archiveID) {
  371:     plugin::CallDynGlobal<char const *, int>(gaddrof_o(CStreaming::LoadCdDirectory, void (*)(char const *, int)), ArchiveName, archiveID);
  372  }

  412  void CStreaming::LoadScene(CVector const *Posn) {
  413:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadScene), Posn);
  414  }

  419  void CStreaming::LoadSceneCollision(CVector const *Posn) {
  420:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadSceneCollision), Posn);
  421  }

  426  void CStreaming::LoadZoneVehicle(CVector const *posn) {
  427:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadZoneVehicle), posn);
  428  }

  433  void CStreaming::MakeSpaceFor(int memoryToCleanInBytes) {
  434:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::MakeSpaceFor), memoryToCleanInBytes);
  435  }

  440  void CStreaming::PossiblyStreamCarOutAfterCreation(int modelId) {
  441:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::PossiblyStreamCarOutAfterCreation), modelId);
  442  }

  447  void CStreaming::ProcessEntitiesInSectorList(CPtrList *list, float posn_x, float posn_y, float min_posn_x, float min_posn_y, float max_posn_x, float max_posn_y, float distance, unsigned int Streamingflags) {
  448:     plugin::CallDynGlobal<CPtrList *, float, float, float, float, float, float, float, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, float, float, float, float, float, float, float, unsigned int)), list, posn_x, posn_y, min_posn_x, min_posn_y, max_posn_x, max_posn_y, distance, Streamingflags);
  449  }

  454  void CStreaming::ProcessEntitiesInSectorList(CPtrList *list, unsigned int streamingFlags) {
  455:     plugin::CallDynGlobal<CPtrList *, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, unsigned int)), list, streamingFlags);
  456  }

  461  bool CStreaming::ProcessLoadingChannel(int channelIndex) {
  462:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::ProcessLoadingChannel), channelIndex);
  463  }

  475  unsigned int CStreaming::ReInit() {
  476:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CStreaming::ReInit));
  477  }

  510  void CStreaming::RemoveBuildingsNotInArea(int AreaCode) {
  511:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveBuildingsNotInArea), AreaCode);
  512  }

  517  void CStreaming::RemoveCarModel(int modelIndex) {
  518:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveCarModel), modelIndex);
  519  }

  538  void CStreaming::RemoveEntity(CLink<CEntity*> *streamingLink) {
  539:     plugin::CallDynGlobal<CLink<CEntity*> *>(gaddrof(CStreaming::RemoveEntity), streamingLink);
  540  }

  552  bool CStreaming::RemoveLeastUsedModel(unsigned int StreamingFlags) {
  553:     return plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CStreaming::RemoveLeastUsedModel), StreamingFlags);
  554  }

  559  bool CStreaming::RemoveLoadedVehicle() {
  560:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedVehicle));
  561  }

  566  bool CStreaming::RemoveLoadedZoneModel() {
  567:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedZoneModel));
  568  }

  573  void CStreaming::RemoveModel(int Modelindex) {
  574:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveModel), Modelindex);
  575  }

  580  unsigned int CStreaming::RemoveUnusedModelsInLoadedList() {
  581:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CStreaming::RemoveUnusedModelsInLoadedList));
  582  }

  587  void CStreaming::RenderEntity(CLink<CEntity*> *streamingLink) {
  588:     plugin::CallDynGlobal<CLink<CEntity*> *>(gaddrof(CStreaming::RenderEntity), streamingLink);
  589  }

  594  void CStreaming::RequestBigBuildings(CVector const *posn) {
  595:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::RequestBigBuildings), posn);
  596  }

  601  void CStreaming::RequestFile(int index, int offset, int size, int imgId, int streamingFlags) {
  602:     plugin::CallDynGlobal<int, int, int, int, int>(gaddrof(CStreaming::RequestFile), index, offset, size, imgId, streamingFlags);
  603  }

  608  void CStreaming::RequestFilesInChannel(int channelId) {
  609:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestFilesInChannel), channelId);
  610  }

  615  void CStreaming::RequestModel(int dwModelId, int Streamingflags) {
  616:     plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestModel), dwModelId, Streamingflags);
  617  }

  622  void CStreaming::RequestModelStream(int streamNum) {
  623:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestModelStream), streamNum);
  624  }

  629  void CStreaming::RequestPlayerSection(int modelIndex, char const *string, int streamingFlags) {
  630:     plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestPlayerSection), modelIndex, string, streamingFlags);
  631  }

  636  void CStreaming::RequestSpecialChar(int slot, char const *Name, int streamingFlags) {
  637:     plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialChar), slot, Name, streamingFlags);
  638  }

  643  void CStreaming::RequestSpecialModel(int slot, char const*name, int StreamingFlags) {
  644:     plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialModel), slot, name, StreamingFlags);
  645  }

  650  void CStreaming::RequestTxdModel(int TxdModelID, int Streamingflags) {
  651:     plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestTxdModel), TxdModelID, Streamingflags);
  652  }

  657  void CStreaming::RequestVehicleUpgrade(int modelIndex, int StreamingFlags) {
  658:     plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestVehicleUpgrade), modelIndex, StreamingFlags);
  659  }

  664  void CStreaming::RetryLoadFile(int streamNum) {
  665:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RetryLoadFile), streamNum);
  666  }

  678  void CStreaming::SetLoadVehiclesInLoadScene(bool bEnable) {
  679:     plugin::CallDynGlobal<bool>(gaddrof(CStreaming::SetLoadVehiclesInLoadScene), bEnable);
  680  }

  685  void CStreaming::SetMissionDoesntRequireAnim(int slot) {
  686:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireAnim), slot);
  687  }

  692  void CStreaming::SetMissionDoesntRequireModel(int modelIndex) {
  693:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireModel), modelIndex);
  694  }

  699  void CStreaming::SetMissionDoesntRequireSpecialChar(int slot) {
  700:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireSpecialChar), slot);
  701  }

  706  void CStreaming::SetModelIsDeletable(int modelIndex) {
  707:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelIsDeletable), modelIndex);
  708  }

  713  void CStreaming::SetModelTxdIsDeletable(int modelIndex) {
  714:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelTxdIsDeletable), modelIndex);
  715  }

  720  void CStreaming::SetSpecialCharIsDeletable(int slot) {
  721:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetSpecialCharIsDeletable), slot);
  722  }

  741  bool CStreaming::StreamAmbulanceAndMedic(bool bStreamForAccident) {
  742:     return plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CStreaming::StreamAmbulanceAndMedic), bStreamForAccident);
  743  }

  748  void CStreaming::StreamCopModels(int townID) {
  749:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::StreamCopModels), townID);
  750  }

  755  bool CStreaming::StreamFireEngineAndFireman(bool bStreamForFire) {
  756:     return plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CStreaming::StreamFireEngineAndFireman), bStreamForFire);
  757  }

  769  void CStreaming::StreamPedsForInterior(int interiorType) {
  770:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::StreamPedsForInterior), interiorType);
  771  }

  776  void CStreaming::StreamPedsIntoRandomSlots(int *pModelID) {
  777:     plugin::CallDynGlobal<int *>(gaddrof(CStreaming::StreamPedsIntoRandomSlots), pModelID);
  778  }

  790  void CStreaming::StreamVehiclesAndPeds_Always(CVector const *posn) {
  791:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamVehiclesAndPeds_Always), posn);
  792  }

  797  void CStreaming::StreamZoneModels(CVector const *posn) {
  798:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels), posn);
  799  }

  804  void CStreaming::StreamZoneModels_Gangs(CVector const *unused) {
  805:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels_Gangs), unused);
  806  }

  825  bool CStreaming::WeAreTryingToPhaseVehicleOut(int modelIndex) {
  826:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::WeAreTryingToPhaseVehicleOut), modelIndex);
  827  }

plugin_sa\game_sa\CStreamingInfo.cpp:
  16  void CStreamingInfo::AddToList(CStreamingInfo *listStart) {
  17:     plugin::CallMethodDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::AddToList), this, listStart);
  18  }

  23  unsigned int CStreamingInfo::GetCdPosn() {
  24:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CStreamingInfo *>(gaddrof(CStreamingInfo::GetCdPosn), this);
  25  }

  30  bool CStreamingInfo::GetCdPosnAndSize(unsigned int *CdPosn, unsigned int *CdSize) {
  31:     return plugin::CallMethodAndReturnDynGlobal<bool, CStreamingInfo *, unsigned int *, unsigned int *>(gaddrof(CStreamingInfo::GetCdPosnAndSize), this, CdPosn, CdSize);
  32  }

  37  unsigned int CStreamingInfo::GetCdSize() {
  38:     return plugin::CallMethodAndReturnDynGlobal<unsigned int, CStreamingInfo *>(gaddrof(CStreamingInfo::GetCdSize), this);
  39  }

  44  CStreamingInfo *CStreamingInfo::GetNext() {
  45:     return plugin::CallMethodAndReturnDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::GetNext), this);
  46  }

  51  CStreamingInfo *CStreamingInfo::GetPrev() {
  52:     return plugin::CallMethodAndReturnDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::GetPrev), this);
  53  }

  58  bool CStreamingInfo::InList() {
  59:     return plugin::CallMethodAndReturnDynGlobal<bool, CStreamingInfo *>(gaddrof(CStreamingInfo::InList), this);
  60  }

  65  void CStreamingInfo::Init() {
  66:     plugin::CallMethodDynGlobal<CStreamingInfo *>(gaddrof(CStreamingInfo::Init), this);
  67  }

  72  void CStreamingInfo::RemoveFromList() {
  73:     plugin::CallMethodDynGlobal<CStreamingInfo *>(gaddrof(CStreamingInfo::RemoveFromList), this);
  74  }

  79  void CStreamingInfo::SetCdPosnAndSize(unsigned int CdPosn, unsigned int CdSize) {
  80:     plugin::CallMethodDynGlobal<CStreamingInfo *, unsigned int, unsigned int>(gaddrof(CStreamingInfo::SetCdPosnAndSize), this, CdPosn, CdSize);
  81  }

plugin_sa\game_sa\CStuckCarCheck.cpp:
  14  void CStuckCarCheck::AddCarToCheck(int carHandle, float distance, unsigned int time, unsigned char a5, unsigned char bStuck, unsigned char bFlipped, unsigned char bWarp, signed char pathID) {
  15:     plugin::CallMethodDynGlobal<CStuckCarCheck *, int, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, signed char>(gaddrof(CStuckCarCheck::AddCarToCheck), this, carHandle, distance, time, a5, bStuck, bFlipped, bWarp, pathID);
  16  }

  21  bool CStuckCarCheck::AttemptToWarpVehicle(CVehicle *vehicle, CVector *origin, float orientation) {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, CVehicle *, CVector *, float>(gaddrof(CStuckCarCheck::AttemptToWarpVehicle), this, vehicle, origin, orientation);
  23  }

  28  void CStuckCarCheck::ClearStuckFlagForCar(int carHandle) {
  29:     plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::ClearStuckFlagForCar), this, carHandle);
  30  }

  35  bool CStuckCarCheck::HasCarBeenStuckForAWhile(int carHandle) {
  36:     return plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::HasCarBeenStuckForAWhile), this, carHandle);
  37  }

  42  void CStuckCarCheck::Init() {
  43:     plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Init), this);
  44  }

  49  bool CStuckCarCheck::IsCarInStuckCarArray(int carHandle) {
  50:     return plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::IsCarInStuckCarArray), this, carHandle);
  51  }

  56  void CStuckCarCheck::Process() {
  57:     plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Process), this);
  58  }

  63  void CStuckCarCheck::RemoveCarFromCheck(int carHandle) {
  64:     plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::RemoveCarFromCheck), this, carHandle);
  65  }

  70  void CStuckCarCheck::ResetArrayElement(unsigned short index) {
  71:     plugin::CallMethodDynGlobal<CStuckCarCheck *, unsigned short>(gaddrof(CStuckCarCheck::ResetArrayElement), this, index);
  72  }

plugin_sa\game_sa\CTaskComplex.cpp:
  10  {
  11:     plugin::CallMethod<0x61A3B0, CTaskComplex *>(this);
  12  }

plugin_sa\game_sa\CTaskComplexClimb.cpp:
  10  {
  11:     plugin::CallMethod<0x46A630, CTaskComplexClimb*>(this);
  12  }

plugin_sa\game_sa\CTaskComplexDie.cpp:
  12  {
  13:     plugin::CallMethod<0x630040, CTaskComplexDie*, eWeaponType, int, int, float, float, bool, bool, int, bool>(this, nWeaponType, animGroup, animID, fBlendDelta, fAnimSpeed, bBeingKilledByStealth,

plugin_sa\game_sa\CTaskComplexEnterBoatAsDriver.cpp:
  11  {
  12:     plugin::CallMethod<0x63B5E0, CTaskComplexEnterBoatAsDriver*, CVehicle*>(this, pTargetVehicle);
  13  }

plugin_sa\game_sa\CTaskComplexEnterCar.cpp:
  11  {
  12:     plugin::CallMethod<0x63A220, CTaskComplexEnterCar*, CVehicle*, bool, bool, bool, bool>(this, pTargetVehicle, bAsDriver, bQuitAfterOpeningDoor, bQuitAfterDraggingPedOut, bCarryOnAfterFallingOff);

plugin_sa\game_sa\CTaskComplexEnterCarAsDriver.cpp:
  10  {
  11:     plugin::CallMethod<0x6402F0, CTaskComplexEnterCarAsDriver*, CVehicle*>(this,pTargetVehicle);
  12  }

plugin_sa\game_sa\CTaskComplexEnterCarAsPassenger.cpp:
  10  {
  11:     plugin::CallMethod<0x640340, CTaskComplexEnterCarAsPassenger*, CVehicle*,int,bool>(this, pTargetVehicle,nTargetSeat,bCarryOnAfterFallingOff);

plugin_sa\game_sa\CTaskComplexFacial.cpp:
  11  {
  12:     plugin::CallMethod<0x690D20, CTaskComplexFacial*>(this);
  13  }

plugin_sa\game_sa\CTaskComplexJump.cpp:
  10  {
  11:     plugin::CallMethod<0x67A030, CTaskComplexJump*, unsigned int>(this, jumpType);
  12  }

plugin_sa\game_sa\CTaskComplexLeaveCar.cpp:
  11  {
  12:     plugin::CallMethod<0x63B8C0, CTaskComplexLeaveCar*, CVehicle*, int, int, bool, bool>(this, pTargetVehicle, nTargetDoor, nDelayTime, bSensibleLeaveCar, bForceGetOut);

plugin_sa\game_sa\CTaskComplexProstituteSolicit.cpp:
  10  CTaskComplexProstituteSolicit::CTaskComplexProstituteSolicit(CPed* pClient) : CTaskComplex(plugin::dummy) {
  11:     plugin::CallMethod<0x661A60, CTaskComplexProstituteSolicit *, CPed*>(this, pClient);
  12  }

  15  CTask* CTaskComplexProstituteSolicit::CreateSubTask(int taskId, CPed* pProstitute) {
  16:     return plugin::CallMethodAndReturn<CTask*, 0x666360, CTaskComplexProstituteSolicit *, int, CPed*>(this, taskId, pProstitute);
  17  }

  20  void CTaskComplexProstituteSolicit::GetRidOfPlayerProstitute() {
  21:     plugin::Call<0x661D30>();
  22  }

  25  bool CTaskComplexProstituteSolicit::IsTaskValid(CPed* pProstitute, CPed* pClient) {
  26:     return plugin::CallAndReturn<bool, 0x661BB0, CPed*, CPed*>(pProstitute, pClient);
  27  }

plugin_sa\game_sa\CTaskComplexSequence.cpp:
  10  {
  11:     plugin::CallMethod<0x632BD0, CTaskComplexSequence *>(this);
  12  }

  16  {
  17:     plugin::CallMethod<0x6389F0, CTaskComplexSequence *>(this);
  18  }

  21  {
  22:     return plugin::CallMethodAndReturn<bool, 0x632D10, CTaskComplexSequence *, CTask *>(this, pTask);
  23  }

plugin_sa\game_sa\CTaskComplexStuckInAir.cpp:
  11  {
  12:     plugin::CallMethod<0x67BA40, CTaskComplexStuckInAir*>(this);
  13  }

plugin_sa\game_sa\CTaskComplexSunbathe.cpp:
  11  {
  12:     plugin::CallMethod<0x631F80, CTaskComplexSunbathe*, CObject*, bool>(this, pTowel, bStartStanding);
  13  }

plugin_sa\game_sa\CTaskComplexUseMobilePhone.cpp:
  11  {
  12:     plugin::CallMethod<0x6348A0, CTaskComplexUseMobilePhone*, int>(this, nDuration);
  13  }

plugin_sa\game_sa\CTaskComplexWander.cpp:
  11  {
  12:     plugin::CallMethod<0x66F450, CTaskComplexWander*, int, unsigned char, bool, float>(this, MoveState, Dir, bWanderSensibly, TargetRadius);

plugin_sa\game_sa\CTaskComplexWanderStandard.cpp:
  11  {
  12:     plugin::CallMethod<0x48E4F0, CTaskComplexWanderStandard*, int, unsigned char, bool>(this, MoveState, Dir, bWanderSensibly);
  13  }

plugin_sa\game_sa\CTaskSimpleAnim.cpp:
  10  {
  11:     plugin::CallMethod<0x61A6C0, CTaskSimpleAnim*, bool>(this, bHoldLastFrame);
  12  }

plugin_sa\game_sa\CTaskSimpleCarSetPedInAsPassenger.cpp:
  11  {
  12:     plugin::CallMethod<0x646FE0, CTaskSimpleCarSetPedInAsPassenger*, CVehicle*, int, CTaskUtilityLineUpPedWithCar*>(this,pTargetVehicle, nTargetDoor, pUtility);

plugin_sa\game_sa\CTaskSimpleCarSetPedOut.cpp:
  11  {
  12:     plugin::CallMethod<0x6478B0, CTaskSimpleCarSetPedOut*, CVehicle*, int, bool>(this, pTargetVehicle, nTargetDoor, bSwitchOffEngine);
  13  }

plugin_sa\game_sa\CTaskSimpleChoking.cpp:
  11  {
  12:     plugin::CallMethod<0x6202C0, CTaskSimpleChoking*, CPed*, bool>(this, pAttacker, bIsTeargas);
  13  }

  16  {
  17:     plugin::CallMethod<0x620660, CTaskSimpleChoking*, CPed* , CPed* , bool>(this, pVictim, pAttacker, bIsTeargas);
  18  }

plugin_sa\game_sa\CTaskSimpleClimb.cpp:
  11  {
  12:     plugin::CallMethod<0x67A110, CTaskSimpleClimb*, CEntity*, const CVector&, float, unsigned char, eClimbHeights, bool>(this, pClimbEnt, vecTarget, fHeading, nSurfaceType, nHeight, bForceClimb);

plugin_sa\game_sa\CTaskSimpleDuck.cpp:
  11  {
  12:     plugin::CallMethod<0x691FC0, CTaskSimpleDuck*, eDuckControlTypes, unsigned short, short>(this, DuckControlType, nLengthOfDuck, nUseShotsWhizzingEvents);
  13  }

plugin_sa\game_sa\CTaskSimpleDuckToggle.cpp:
  10  {
  11:     plugin::CallMethod<0x62F690, CTaskSimpleDuckToggle*,int>(this, toggleType);
  12  }

plugin_sa\game_sa\CTaskSimpleFacial.cpp:
  11  {
  12:     plugin::CallMethod<0x690C70, CTaskSimpleFacial*, eFacialExpression, int>(this, nFacialExpress, nDuration);
  13  }

plugin_sa\game_sa\CTaskSimpleFight.cpp:
  11  {
  12:     plugin::CallMethod<0x61C470, CTaskSimpleFight*, CEntity*, int, unsigned int>(this, pTargetEntity, nCommand, nIdlePeriod);
  13  }

plugin_sa\game_sa\CTaskSimpleGangDriveBy.cpp:
  11  {
  12:     plugin::CallMethod<0x6217D0, CTaskSimpleGangDriveBy*, CEntity *, const CVector *, float, char, char, bool>(this, pTargetEntity, pVecTarget, fAbortRange, FrequencyPercentage, nDrivebyStyle, bSeatRHS);

plugin_sa\game_sa\CTaskSimpleIKChain.cpp:
  12  {
  13:     plugin::CallMethod<0x6339C0, CTaskSimpleIKChain*, char*, int, RwV3d, int, CEntity*, int, RwV3d, float, int, int>(this, idString, effectorBoneTag, effectorVec, pivotBoneTag, pEntity, offsetBoneTag, offsetPos, speed, time, blendTime);

plugin_sa\game_sa\CTaskSimpleIKLookAt.cpp:
  12  {
  13:     plugin::CallMethod<0x633E00, CTaskSimpleIKLookAt*, char*, CEntity*, int, int, RwV3d, bool, float, int, int>(this, idString, pEntity, time, offsetBoneTag, offsetPos, bUseTorso, speed, blendTime, m_priority);

plugin_sa\game_sa\CTaskSimpleIKManager.cpp:
  10  {
  11:     plugin::CallMethod<0x6337F0, CTaskSimpleIKManager*>(this);
  12  }

plugin_sa\game_sa\CTaskSimpleInAir.cpp:
  11  {
  12:     plugin::CallMethod<0x678CD0, CTaskSimpleInAir*, bool, bool, bool>(this, bUsingJumpGlide, bUsingFallGlide, bUsingClimbJump);

plugin_sa\game_sa\CTaskSimpleJetPack.cpp:
  27  {
  28:     plugin::CallMethod<0x67B4E0, CTaskSimpleJetPack*, const CVector*, float,int>(this, pVecTargetPos, fCruiseHeight, nHoverTime);
  29  }

plugin_sa\game_sa\CTaskSimpleJump.cpp:
  10  {
  11:     plugin::CallMethod<0x679AA0, CTaskSimpleJump*, bool>(this, bIsClimb);
  12  }

plugin_sa\game_sa\CTaskSimplePlayerOnFoot.cpp:
  10  {
  11:     plugin::CallMethod<0x685750, CTaskSimplePlayerOnFoot*>(this);
  12  }

plugin_sa\game_sa\CTaskSimpleRunAnim.cpp:
  11  {
  12:     plugin::CallMethod<0x61A8B0, CTaskSimpleRunAnim*, unsigned int, unsigned int, float, bool>(this, animGroup, animID, fBlendDelta, bHoldLastFrame);

  19  {
  20:     plugin::CallMethod<0x61A900, CTaskSimpleRunAnim*, unsigned int, unsigned int, float, unsigned int, char*, bool>(this, animGroup, animID, fBlendDelta, nTaskType, pTaskName, bHoldLastFrame);

plugin_sa\game_sa\CTaskSimpleRunNamedAnim.cpp:
  12  {
  13:     plugin::CallMethod<0x61A990, CTaskSimpleRunNamedAnim*, const char*, const char*, int, float, int, bool, bool, bool, bool>(this, pAnimName, pAnimGroupName, flags, fBlendDelta, nTime, bDontInterrupt, bRunInSequence, bOffsetPed, bHoldLastFrame);

plugin_sa\game_sa\CTaskSimpleStandStill.cpp:
  11  {
  12:      plugin::CallMethod<0x62F310, CTaskSimpleStandStill*, int, bool, bool, float>(this, nTime, Looped, bUseAnimIdleStance, fBlendData);

plugin_sa\game_sa\CTaskSimpleStealthKill.cpp:
  10  {
  11:     plugin::CallMethod<0x6225F0, CTaskSimpleStealthKill*, bool, CPed*, int>(this, bKeepTargetAlive, pTarget, nAssocGroupId);
  12  }

plugin_sa\game_sa\CTaskSimpleSwim.cpp:
  11  {
  12:     plugin::CallMethod<0x688930, CTaskSimpleSwim*, CVector const*, CPed*>(this,pPosn, pPed);
  13  }

plugin_sa\game_sa\CTaskSimpleThrowProjectile.cpp:
  11  {
  12:     plugin::CallMethod<0x61F660, CTaskSimpleThrowProjectile*, CEntity*, CVector>(this, pTarget, Posn);
  13  }

plugin_sa\game_sa\CTaskSimpleTriggerLookAt.cpp:
  11  {
  12:     plugin::CallMethod<0x6202C0, CTaskSimpleTriggerLookAt*, CEntity*, int, int, RwV3d, bool, float, int, int>(this, pEntity, time, offsetBoneTag, offsetPos, bUseTorso, speed, blendTime, priority);

plugin_sa\game_sa\CTaskSimpleUseGun.cpp:
  11  {
  12:     plugin::CallMethod<0x61DE60, CTaskSimpleUseGun*, CEntity*, CVector, unsigned char, unsigned short, bool>(this, pTargetEntity, vecTarget, nCommand, nBurstLength, bAimImmediate);

plugin_sa\game_sa\CTaskUtilityLineUpPedWithCar.cpp:
  14  CVector* CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor(int unused, CVehicle* pVehicle, float arg3, CAnimBlendAssociation* pAnimBlendAssoc) {
  15:     return plugin::CallMethodAndReturn<CVector*, 0x64FC10, CTaskUtilityLineUpPedWithCar *, int, CVehicle*, float, CAnimBlendAssociation*>(this, unused, pVehicle, arg3, pAnimBlendAssoc);
  16  }

  19  void CTaskUtilityLineUpPedWithCar::ProcessPed(CPed* pPed, CVehicle* pVehicle, CAnimBlendAssociation* pAnimBlendAssoc) {
  20:     plugin::CallMethod<0x6513A0, CTaskUtilityLineUpPedWithCar *, CPed*, CVehicle*, CAnimBlendAssociation*>(this, pPed, pVehicle, pAnimBlendAssoc);
  21  }

  24  RwV3d* CTaskUtilityLineUpPedWithCar::GetPositionToOpenCarDoor(int unused, CVehicle* pVehicle, float arg2, CAnimBlendAssociation* pAnimBlendAssoc) {
  25: 	return plugin::CallMethodAndReturn<RwV3d*, 0x650A80, CTaskUtilityLineUpPedWithCar *, int, CVehicle*, float, CAnimBlendAssociation*>(this, unused, pVehicle, arg2, pAnimBlendAssoc);
  26  }

plugin_sa\game_sa\CTheCarGenerators.cpp:
  20  signed int CTheCarGenerators::CreateCarGenerator(float x, float y, float z, float angle, int modelId, short color1, short color2, unsigned char forceSpawn, unsigned char alarm_chances, unsigned char doorLock_chances, unsigned short minDelay, unsigned short maxDelay, unsigned char iplId, unsigned char bOwnedbyplayer) {
  21:     return plugin::CallAndReturnDynGlobal<signed int, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short, unsigned char, unsigned char>(gaddrof(CTheCarGenerators::CreateCarGenerator), x, y, z, angle, modelId, color1, color2, forceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer);
  22  }

  48  void CTheCarGenerators::RemoveCarGenerators(unsigned char IplID) {
  49:     plugin::CallDynGlobal<unsigned char>(gaddrof(CTheCarGenerators::RemoveCarGenerators), IplID);
  50  }

plugin_sa\game_sa\CTheScripts.cpp:
  100  int CTheScripts::AddScriptCheckpoint(float at_X, float at_Y, float at_Z, float PointTo_X, float PointTo_Y, float PointTo_Z, float radius, int type) {
  101:     return plugin::CallAndReturnDynGlobal<int, float, float, float, float, float, float, float, int>(gaddrof(CTheScripts::AddScriptCheckpoint), at_X, at_Y, at_Z, PointTo_X, PointTo_Y, PointTo_Z, radius, type);
  102  }

  107  int CTheScripts::AddScriptEffectSystem(FxSystem_c *a1) {
  108:     return plugin::CallAndReturnDynGlobal<int, FxSystem_c *>(gaddrof(CTheScripts::AddScriptEffectSystem), a1);
  109  }

  114  int CTheScripts::AddScriptSearchLight(float startX, float startY, float startZ, CEntity *entity, float targetX, float targetY, float targetZ, float targetRadius, float baseRadius) {
  115:     return plugin::CallAndReturnDynGlobal<int, float, float, float, CEntity *, float, float, float, float, float>(gaddrof(CTheScripts::AddScriptSearchLight), startX, startY, startZ, entity, targetX, targetY, targetZ, targetRadius, baseRadius);
  116  }

  121  unsigned int CTheScripts::AddScriptSphere(unsigned int id, CVector posn, float radius) {
  122:     return plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, CVector, float>(gaddrof(CTheScripts::AddScriptSphere), id, posn, radius);
  123  }

  128  void CTheScripts::AddToBuildingSwapArray(CBuilding *a1, int newModelId, int oldModelId) {
  129:     plugin::CallDynGlobal<CBuilding *, int, int>(gaddrof(CTheScripts::AddToBuildingSwapArray), a1, newModelId, oldModelId);
  130  }

  135  void CTheScripts::AddToInvisibilitySwapArray(CEntity *a2, bool bVisible) {
  136:     plugin::CallDynGlobal<CEntity *, bool>(gaddrof(CTheScripts::AddToInvisibilitySwapArray), a2, bVisible);
  137  }

  142  void CTheScripts::AddToListOfConnectedLodObjects(CObject *pObject1, CObject *pObject2) {
  143:     plugin::CallDynGlobal<CObject *, CObject *>(gaddrof(CTheScripts::AddToListOfConnectedLodObjects), pObject1, pObject2);
  144  }

  149  void CTheScripts::AddToListOfSpecialAnimGroupsAttachedToCharModels(int modelid, char *ifpName) {
  150:     plugin::CallDynGlobal<int, char *>(gaddrof(CTheScripts::AddToListOfSpecialAnimGroupsAttachedToCharModels), modelid, ifpName);
  151  }

  156  double CTheScripts::AddToSwitchJumpTable(int switchValue, int switchLabelLocalAddress) {
  157:     return plugin::CallAndReturnDynGlobal<double, int, int>(gaddrof(CTheScripts::AddToSwitchJumpTable), switchValue, switchLabelLocalAddress);
  158  }

  163  void CTheScripts::AddToVehicleModelsBlockedByScript(int modelindex) {
  164:     plugin::CallDynGlobal<int>(gaddrof(CTheScripts::AddToVehicleModelsBlockedByScript), modelindex);
  165  }

  170  void CTheScripts::AddToWaitingForScriptBrainArray(CEntity *pEntity, short arg2) {
  171:     plugin::CallDynGlobal<CEntity *, short>(gaddrof(CTheScripts::AddToWaitingForScriptBrainArray), pEntity, arg2);
  172  }

  177  void CTheScripts::AttachSearchlightToSearchlightObject(int searchlightid, CObject *tower, CObject *housing, CObject *bulb, float offsetX, float offsetY, float offsetZ) {
  178:     plugin::CallDynGlobal<int, CObject *, CObject *, CObject *, float, float, float>(gaddrof(CTheScripts::AttachSearchlightToSearchlightObject), searchlightid, tower, housing, bulb, offsetX, offsetY, offsetZ);
  179  }

  184  char CTheScripts::CheckStreamedScriptVersion(RwStream *arg1, char *arg2) {
  185:     return plugin::CallAndReturnDynGlobal<char, RwStream *, char *>(gaddrof(CTheScripts::CheckStreamedScriptVersion), arg1, arg2);
  186  }

  191  void CTheScripts::CleanUpThisObject(CObject *pObject) {
  192:     plugin::CallDynGlobal<CObject *>(gaddrof(CTheScripts::CleanUpThisObject), pObject);
  193  }

  198  void CTheScripts::CleanUpThisPed(CPed *ped) {
  199:     plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::CleanUpThisPed), ped);
  200  }

  205  void CTheScripts::CleanUpThisVehicle(CVehicle *pVehicle) {
  206:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CTheScripts::CleanUpThisVehicle), pVehicle);
  207  }

  226  void CTheScripts::ClearSpaceForMissionEntity(CVector const &pos, CEntity *pEntity) {
  227:     plugin::CallDynGlobal<CVector const &, CEntity *>(gaddrof(CTheScripts::ClearSpaceForMissionEntity), pos, pEntity);
  228  }

  240  void CTheScripts::DrawDebugAngledSquare(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) {
  241:     plugin::CallDynGlobal<float, float, float, float, float, float, float, float>(gaddrof(CTheScripts::DrawDebugAngledSquare), x1, y1, x2, y2, x3, y3, x4, y4);
  242  }

  247  void CTheScripts::DrawDebugCube(float x1, float y1, float x2, float y2) {
  248:     plugin::CallDynGlobal<float, float, float, float>(gaddrof(CTheScripts::DrawDebugCube), x1, y1, x2, y2);
  249  }

  261  void CTheScripts::DrawScriptSpritesAndRectangles(char bDrawBeforeFade) {
  262:     plugin::CallDynGlobal<char>(gaddrof(CTheScripts::DrawScriptSpritesAndRectangles), bDrawBeforeFade);
  263  }

  268  signed int CTheScripts::GetActualScriptThingIndex(int index, unsigned char type) {
  269:     return plugin::CallAndReturnDynGlobal<signed int, int, unsigned char>(gaddrof(CTheScripts::GetActualScriptThingIndex), index, type);
  270  }

  275  unsigned int CTheScripts::GetNewUniqueScriptThingIndex(unsigned int index, char type) {
  276:     return plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, char>(gaddrof(CTheScripts::GetNewUniqueScriptThingIndex), index, type);
  277  }

  282  int CTheScripts::GetScriptIndexFromPointer(CRunningScript *thread) {
  283:     return plugin::CallAndReturnDynGlobal<int, CRunningScript *>(gaddrof(CTheScripts::GetScriptIndexFromPointer), thread);
  284  }

  289  unsigned int CTheScripts::GetUniqueScriptThingIndex(int playergroup, unsigned char type) {
  290:     return plugin::CallAndReturnDynGlobal<unsigned int, int, unsigned char>(gaddrof(CTheScripts::GetUniqueScriptThingIndex), playergroup, type);
  291  }

  296  bool CTheScripts::HasVehicleModelBeenBlockedByScript(int modelindex) {
  297:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CTheScripts::HasVehicleModelBeenBlockedByScript), modelindex);
  298  }

  303  void CTheScripts::HighlightImportantAngledArea(unsigned int markerid, float from_X, float from_Y, float to_X, float to_Y, float angledTo_X, float angledTo_Y, float angledFrom_X, float angledFrom_Y, float height) {
  304:     plugin::CallDynGlobal<unsigned int, float, float, float, float, float, float, float, float, float>(gaddrof(CTheScripts::HighlightImportantAngledArea), markerid, from_X, from_Y, to_X, to_Y, angledTo_X, angledTo_Y, angledFrom_X, angledFrom_Y, height);
  305  }

  310  void CTheScripts::HighlightImportantArea(int markerid, float from_X, float from_Y, float to_X, float to_Y, float height) {
  311:     plugin::CallDynGlobal<int, float, float, float, float, float>(gaddrof(CTheScripts::HighlightImportantArea), markerid, from_X, from_Y, to_X, to_Y, height);
  312  }

  331  void CTheScripts::InitialiseConnectLodObjects(unsigned short a1) {
  332:     plugin::CallDynGlobal<unsigned short>(gaddrof(CTheScripts::InitialiseConnectLodObjects), a1);
  333  }

  338  void CTheScripts::InitialiseSpecialAnimGroup(unsigned short a1) {
  339:     plugin::CallDynGlobal<unsigned short>(gaddrof(CTheScripts::InitialiseSpecialAnimGroup), a1);
  340  }

  352  bool CTheScripts::IsEntityWithinAnySearchLight(CEntity *pEntity, int *pIndex) {
  353:     return plugin::CallAndReturnDynGlobal<bool, CEntity *, int *>(gaddrof(CTheScripts::IsEntityWithinAnySearchLight), pEntity, pIndex);
  354  }

  359  bool CTheScripts::IsEntityWithinSearchLight(unsigned int index, CEntity *pEntity) {
  360:     return plugin::CallAndReturnDynGlobal<bool, unsigned int, CEntity *>(gaddrof(CTheScripts::IsEntityWithinSearchLight), index, pEntity);
  361  }

  366  bool CTheScripts::IsPedStopped(CPed *ped) {
  367:     return plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CTheScripts::IsPedStopped), ped);
  368  }

  373  bool CTheScripts::IsPlayerOnAMission() {
  374:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTheScripts::IsPlayerOnAMission));
  375  }

  380  bool CTheScripts::IsPointWithinSearchLight(CVector *pointPosn, int index) {
  381:     return plugin::CallAndReturnDynGlobal<bool, CVector *, int>(gaddrof(CTheScripts::IsPointWithinSearchLight), pointPosn, index);
  382  }

  387  bool CTheScripts::IsVehicleStopped(CVehicle *pVehicle) {
  388:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTheScripts::IsVehicleStopped), pVehicle);
  389  }

  401  void CTheScripts::MoveSearchLightBetweenTwoPoints(int index, float x1, float y1, float z1, float x2, float y2, float z2, float pathSpeed) {
  402:     plugin::CallDynGlobal<int, float, float, float, float, float, float, float>(gaddrof(CTheScripts::MoveSearchLightBetweenTwoPoints), index, x1, y1, z1, x2, y2, z2, pathSpeed);
  403  }

  408  void CTheScripts::MoveSearchLightToEntity(int index, CEntity *pEntity, float pathSpeed) {
  409:     plugin::CallDynGlobal<int, CEntity *, float>(gaddrof(CTheScripts::MoveSearchLightToEntity), index, pEntity, pathSpeed);
  410  }

  415  void CTheScripts::MoveSearchLightToPointAndStop(int index, float x, float y, float z, float pathSpeed) {
  416:     plugin::CallDynGlobal<int, float, float, float, float>(gaddrof(CTheScripts::MoveSearchLightToPointAndStop), index, x, y, z, pathSpeed);
  417  }

  471  void CTheScripts::RemoveFromVehicleModelsBlockedByScript(int modelindex) {
  472:     plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveFromVehicleModelsBlockedByScript), modelindex);
  473  }

  478  int CTheScripts::RemoveFromWaitingForScriptBrainArray(CEntity *a1, short modelIndex) {
  479:     return plugin::CallAndReturnDynGlobal<int, CEntity *, short>(gaddrof(CTheScripts::RemoveFromWaitingForScriptBrainArray), a1, modelIndex);
  480  }

  485  void CTheScripts::RemoveScriptCheckpoint(int arg1) {
  486:     plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptCheckpoint), arg1);
  487  }

  492  void CTheScripts::RemoveScriptEffectSystem(int arg1) {
  493:     plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptEffectSystem), arg1);
  494  }

  499  void CTheScripts::RemoveScriptSearchLight(unsigned int index) {
  500:     plugin::CallDynGlobal<unsigned int>(gaddrof(CTheScripts::RemoveScriptSearchLight), index);
  501  }

  506  void CTheScripts::RemoveScriptSphere(int index) {
  507:     plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptSphere), index);
  508  }

  520  void CTheScripts::RemoveThisPed(CPed *ped) {
  521:     plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::RemoveThisPed), ped);
  522  }

  541  bool CTheScripts::ScriptAttachAnimGroupToCharModel(int modelId, char *ifpName) {
  542:     return plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CTheScripts::ScriptAttachAnimGroupToCharModel), modelId, ifpName);
  543  }

  548  void CTheScripts::ScriptConnectLodsFunction(int objecthandle1, int objecthandle2) {
  549:     plugin::CallDynGlobal<int, int>(gaddrof(CTheScripts::ScriptConnectLodsFunction), objecthandle1, objecthandle2);
  550  }

  555  void CTheScripts::ScriptDebugCircle2D(float x, float y, float width, float height, CRGBA color) {
  556:     plugin::CallDynGlobal<float, float, float, float, CRGBA>(gaddrof(CTheScripts::ScriptDebugCircle2D), x, y, width, height, color);
  557  }

  562  CRunningScript *CTheScripts::StartNewScript(unsigned char *startIP) {
  563:     return plugin::CallAndReturnDynGlobal<CRunningScript *, unsigned char *>(gaddrof_o(CTheScripts::StartNewScript, CRunningScript *(*)(unsigned char *)), startIP);
  564  }

  569  int CTheScripts::StartNewScript(unsigned char *startIP, unsigned short index) {
  570:     return plugin::CallAndReturnDynGlobal<int, unsigned char *, unsigned short>(gaddrof_o(CTheScripts::StartNewScript, int(*)(unsigned char *, unsigned short)), startIP, index);
  571  }

  604  void CTheScripts::UseSwitchJumpTable(int *pSwitchLabelAddress) {
  605:     plugin::CallDynGlobal<int *>(gaddrof(CTheScripts::UseSwitchJumpTable), pSwitchLabelAddress);
  606  }

plugin_sa\game_sa\CTimeCycle.cpp:
  151  void CTimeCycle::AddOne(CBox& box, short farclip, int extracolor, float strength, float falloff, float lodDistMult) {
  152:     plugin::Call<0x55FF40, CBox&, short, int, float, float, float>(box, farclip, extracolor, strength, falloff, lodDistMult);
  153  }

  156  void CTimeCycle::CalcColoursForPoint(CVector point, CColourSet* pCurrentColourSet) {
  157:     plugin::Call<0x5603D0, CVector, CColourSet*>(point, pCurrentColourSet);
  158  }

  161  void CTimeCycle::FindFarClipForCoors(CVector cam_pos) {
  162:     plugin::Call<0x5616E0, CVector>(cam_pos);
  163  }

  166  void CTimeCycle::FindTimeCycleBox(CVector pos, CTimeCycleBox** outbox, float* interpolation, bool bCheckLod, bool bCheckFar, CTimeCycleBox* exclude) {
  167:     plugin::Call<0x55FFD0, CVector, CTimeCycleBox**, float*, bool, bool, CTimeCycleBox*>(pos, outbox, interpolation, bCheckLod, bCheckFar, exclude);
  168  }

  171  float CTimeCycle::GetAmbientBlue() {
  172:     return plugin::CallAndReturn<float, 0x560350>();
  173  }

  176  float CTimeCycle::GetAmbientBlue_BeforeBrightness() {
  177:     return plugin::CallAndReturn<float, 0x5603B0>();
  178  }

  181  float CTimeCycle::GetAmbientBlue_Obj() {
  182:     return plugin::CallAndReturn<float, 0x560380>();
  183  }

  186  float CTimeCycle::GetAmbientGreen() {
  187:     return plugin::CallAndReturn<float, 0x560340>();
  188  }

  191  float CTimeCycle::GetAmbientGreen_BeforeBrightness() {
  192:     return plugin::CallAndReturn<float, 0x5603A0>();
  193  }

  196  float CTimeCycle::GetAmbientGreen_Obj() {
  197:     return plugin::CallAndReturn<float, 0x560370>();
  198  }

  201  float CTimeCycle::GetAmbientRed() {
  202:     return plugin::CallAndReturn<float, 0x560330>();
  203  }

  206  float CTimeCycle::GetAmbientRed_BeforeBrightness() {
  207:     return plugin::CallAndReturn<float, 0x560390>();
  208  }

  211  float CTimeCycle::GetAmbientRed_Obj() {
  212:     return plugin::CallAndReturn<float, 0x560360>();
  213  }

  216  void CTimeCycle::InitForRestart() {
  217:     plugin::Call<0x5601F0>();
  218  }

  221  void CTimeCycle::Initialise() {
  222:     plugin::Call<0x5BBAC0>();
  223  }

  226  void CTimeCycle::SetConstantParametersForPostFX() {
  227:     plugin::Call<0x560210>();
  228  }

  231  void CTimeCycle::Shutdown() {
  232:     plugin::Call<0x5601E0>();
  233  }

  236  void CTimeCycle::StartExtraColour(int colour, bool bNoExtraColorInterior) {
  237:     plugin::Call<0x55FEC0, int, bool>(colour, bNoExtraColorInterior);
  238  }

  241  void CTimeCycle::StopExtraColour(bool bNoExtraColorInterior) {
  242:     plugin::Call<0x55FF20, bool>(bNoExtraColorInterior);
  243  }

  246  void CTimeCycle::Update() {
  247:     plugin::Call<0x561760>();
  248  }

plugin_sa\game_sa\CUpsideDownCarCheck.cpp:
  14  void CUpsideDownCarCheck::AddCarToCheck(int carHandle) {
  15:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::AddCarToCheck), this, carHandle);
  16  }

  21  bool CUpsideDownCarCheck::AreAnyCarsUpsideDown() {
  22:     return plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::AreAnyCarsUpsideDown), this);
  23  }

  28  char CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile(int carHandle) {
  29:     return plugin::CallMethodAndReturnDynGlobal<char, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile), this, carHandle);
  30  }

  35  void CUpsideDownCarCheck::Init() {
  36:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::Init), this);
  37  }

  42  void CUpsideDownCarCheck::RemoveCarFromCheck(int carHandle) {
  43:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::RemoveCarFromCheck), this, carHandle);
  44  }

  49  void CUpsideDownCarCheck::UpdateTimers() {
  50:     plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::UpdateTimers), this);
  51  }

  56  bool CUpsideDownCarCheck::IsCarUpsideDown(CVehicle *pVehicle) {
  57:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof_o(CUpsideDownCarCheck::IsCarUpsideDown, bool (*)(CVehicle *)), pVehicle);
  58  }

  63  bool CUpsideDownCarCheck::IsCarUpsideDown(int carhandle) {
  64:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof_o(CUpsideDownCarCheck::IsCarUpsideDown, bool (*)(int)), carhandle);
  65  }

plugin_sa\game_sa\CVisibilityPlugins.cpp:
   11  void CVisibilityPlugins::AtomicConstructor(void* object) {
   12:     plugin::Call<0x732150, void*>(object);
   13  }

   16  void CVisibilityPlugins::AtomicCopyConstructor(void* object, void const* originalObject) {
   17:     plugin::Call<0x732170, void*, void const*>(object, originalObject);
   18  }

   21  void* CVisibilityPlugins::AtomicDestructor(void* object) {
   22:     return plugin::CallAndReturn<void*, 0x7321A0, void*>(object);
   23  }

   26  int CVisibilityPlugins::CalculateFadingAtomicAlpha(CBaseModelInfo* pBaseModelInfo, CEntity* pEntity, float arg3) {
   27:     return plugin::CallAndReturn<int, 0x732500, CBaseModelInfo*, CEntity*, float>(pBaseModelInfo, pEntity, arg3);
   28  }

   31  void CVisibilityPlugins::ClearAtomicFlag(RpAtomic* pRpAtomic, int flag) {
   32:     plugin::Call<0x732310, RpAtomic*, int>(pRpAtomic, flag);
   33  }

   36  void CVisibilityPlugins::ClearAtomicFlag(RpAtomic* pRpAtomic, unsigned short flag) {
   37:     plugin::Call<0x732330, RpAtomic*, unsigned short>(pRpAtomic, flag);
   38  }

   41  void CVisibilityPlugins::ClearClumpForAllAtomicsFlag(RpClump* pRpClump, int flag) {
   42:     plugin::Call<0x732350, RpClump*, int>(pRpClump, flag);
   43  }

   46  void CVisibilityPlugins::ClumpConstructor(void* object) {
   47:     plugin::Call<0x732E10, void*>(object);
   48  }

   51  void CVisibilityPlugins::ClumpCopyConstructor(void* object, void const* originalObject) {
   52:     plugin::Call<0x732200, void*, void const*>(object, originalObject);
   53  }

   56  void* CVisibilityPlugins::ClumpDestructor(void* object) {
   57:     return plugin::CallAndReturn<void*, 0x732220, void*>(object);
   58  }

   61  int CVisibilityPlugins::DefaultVisibilityCB() {
   62:     return plugin::CallAndReturn<int, 0x732A30>();
   63  }

   66  void CVisibilityPlugins::FrameConstructor(void* object) {
   67:     plugin::Call<0x7321B0, void*>(object);
   68  }

   71  void CVisibilityPlugins::FrameCopyConstructor(void* object, void const* originalObject) {
   72:     plugin::Call<0x7321D0, void*, void const*>(object, originalObject);
   73  }

   76  void* CVisibilityPlugins::FrameDestructor(void* arg0, int arg1, int arg2) {
   77:     return plugin::CallAndReturn<void*, 0x7321F0, void*, int, int>(arg0, arg1, arg2);
   78  }

   81  bool CVisibilityPlugins::FrustumSphereCB(RpClump* pRpClump) {
   82:     return plugin::CallAndReturn<bool, 0x732A40, RpClump*>(pRpClump);
   83  }

   86  short CVisibilityPlugins::GetAtomicId(RpAtomic* pRpAtomic) {
   87:     return plugin::CallAndReturn<short, 0x732370, RpAtomic*>(pRpAtomic);
   88  }

   91  CAtomicModelInfo* CVisibilityPlugins::GetAtomicModelInfo(RpAtomic* pRpAtomic) {
   92:     return plugin::CallAndReturn<CAtomicModelInfo*, 0x732260, RpAtomic*>(pRpAtomic);
   93  }

   96  int CVisibilityPlugins::GetClumpAlpha(RpClump* pRpClump) {
   97:     return plugin::CallAndReturn<int, 0x732B20, RpClump*>(pRpClump);
   98  }

  101  CClumpModelInfo* CVisibilityPlugins::GetClumpModelInfo(RpClump* pRpClump) {
  102:     return plugin::CallAndReturn<CClumpModelInfo*, 0x732AC0, RpClump*>(pRpClump);
  103  }

  106  float CVisibilityPlugins::GetDistanceSquaredFromCamera(RwFrame* pRwFrame) {
  107:     return plugin::CallAndReturn<float, 0x732C80, RwFrame*>(pRwFrame);
  108  }

  111  float CVisibilityPlugins::GetDistanceSquaredFromCamera(RwV3d* pRwV3d) {
  112:     return plugin::CallAndReturn<float, 0x732CC0, RwV3d*>(pRwV3d);
  113  }

  116  float CVisibilityPlugins::GetDotProductWithCameraVector(RwMatrixTag* atomicMat, RwMatrixTag* rootMat,  unsigned int flags) {
  117:     return plugin::CallAndReturn<float, 0x7326D0, RwMatrixTag*, RwMatrixTag*, unsigned int>(atomicMat, rootMat, flags);
  118  }

  121  int CVisibilityPlugins::GetFrameHierarchyId(RwFrame* pRwFrame) {
  122:     return plugin::CallAndReturn<int, 0x732A20, RwFrame*>(pRwFrame);
  123  }

  126  short CVisibilityPlugins::GetModelInfoIndex(RpAtomic* pRpAtomic) {
  127:     return plugin::CallAndReturn<short, 0x732250, RpAtomic*>(pRpAtomic);
  128  }

  131  short CVisibilityPlugins::GetUserValue(RpAtomic* pRpAtomic) {
  132:     return plugin::CallAndReturn<short, 0x7323A0, RpAtomic*>(pRpAtomic);
  133  }

  136  void CVisibilityPlugins::InitAlphaAtomicList() {
  137:     plugin::Call<0x734530>();
  138  }

  141  void CVisibilityPlugins::InitAlphaEntityList() {
  142:     plugin::Call<0x734540>();
  143  }

  146  void CVisibilityPlugins::Initialise() {
  147:     plugin::Call<0x733A20>();
  148  }

  151  bool CVisibilityPlugins::InsertAtomicIntoReallyDrawLastList(RpAtomic* pRpAtomic, float arg2) {
  152:     return plugin::CallAndReturn<bool, 0x733E10, RpAtomic*, float>(pRpAtomic, arg2);
  153  }

  156  bool CVisibilityPlugins::InsertEntityIntoReallyDrawLastList(CEntity* pEntity, float arg2) {
  157:     return plugin::CallAndReturn<bool, 0x733E50, CEntity*, float>(pEntity, arg2);
  158  }

  161  bool CVisibilityPlugins::InsertEntityIntoSortedList(CEntity* pEntity, float distance) {
  162:     return plugin::CallAndReturn<bool, 0x734570, CEntity*, float>(pEntity, distance);
  163  }

  166  bool CVisibilityPlugins::IsAtomicVisible(RpAtomic* pRpAtomic) {
  167:     return plugin::CallAndReturn<bool, 0x732990, RpAtomic*>(pRpAtomic);
  168  }

  171  bool CVisibilityPlugins::IsClumpVisible(RpClump* pRpClump) {
  172:     return plugin::CallAndReturn<bool, 0x732AE0, RpClump*>(pRpClump);
  173  }

  176  bool CVisibilityPlugins::PluginAttach() {
  177:     return plugin::CallAndReturn<bool, 0x732E30>();
  178  }

  181  void CVisibilityPlugins::RenderAlphaAtomic(RpAtomic* pRpAtomic, int dwAlpha) {
  182:     plugin::Call<0x732480, RpAtomic*, int>(pRpAtomic, dwAlpha);
  183  }

  186  void CVisibilityPlugins::RenderAlphaAtomics() {
  187:     plugin::Call<0x733E90>();
  188  }

  191  void CVisibilityPlugins::RenderAtomicWithAlphaCB(RpAtomic* pRpAtomic, void* pData) {
  192:     plugin::Call<0x732660, RpAtomic*, void*>(pRpAtomic, pData);
  193  }

  196  void CVisibilityPlugins::RenderBoatAlphaAtomics() {
  197:     plugin::Call<0x733EC0>();
  198  }

  201  void CVisibilityPlugins::RenderEntity(void* entity, bool unused, float arg3) {
  202:     plugin::Call<0x732B40, void*, bool, float>(entity, unused, arg3);
  203  }

  206  void CVisibilityPlugins::RenderFadingAtomic(CBaseModelInfo* pBaseModelInfo, RpAtomic* pRpAtomic, int dwAlpha) {
  207:     plugin::Call<0x732610, CBaseModelInfo*, RpAtomic*, int>(pBaseModelInfo, pRpAtomic, dwAlpha);
  208  }

  211  void CVisibilityPlugins::RenderFadingClump(CBaseModelInfo* pBaseModelInfo, RpClump* pRpClump, int dwAlpha) {
  212:     plugin::Call<0x732680, CBaseModelInfo*, RpClump*, int>(pBaseModelInfo, pRpClump, dwAlpha);
  213  }

  216  void CVisibilityPlugins::RenderFadingClumpCB(RpAtomic* pRpAtomic) {
  217:     plugin::Call<0x733630, RpAtomic*>(pRpAtomic);
  218  }

  221  void CVisibilityPlugins::RenderFadingEntities() {
  222:     plugin::Call<0x733F10>();
  223  }

  226  void CVisibilityPlugins::RenderFadingUnderwaterEntities() {
  227:     plugin::Call<0x7337D0>();
  228  }

  231  void CVisibilityPlugins::RenderHeliRotorAlphaCB(RpAtomic* pRpAtomic) {
  232:     plugin::Call<0x7340B0, RpAtomic*>(pRpAtomic);
  233  }

  236  void CVisibilityPlugins::RenderHeliTailRotorAlphaCB(RpAtomic* pRpAtomic) {
  237:     plugin::Call<0x734170, RpAtomic*>(pRpAtomic);
  238  }

  241  void CVisibilityPlugins::RenderObjNormalAtomic(RpAtomic* pRpAtomic) {
  242:     plugin::Call<0x7323E0, RpAtomic*>(pRpAtomic);
  243  }

  246  void CVisibilityPlugins::RenderOrderedList(CLinkList<CVisibilityPlugins::AlphaObjectInfo>& AlphaObjectInfoList) {
  247:     plugin::Call <0x7337A0, CLinkList<CVisibilityPlugins::AlphaObjectInfo>&>(AlphaObjectInfoList);
  248  }

  251  void CVisibilityPlugins::RenderPedCB(RpAtomic* pRpAtomic) {
  252:     plugin::Call<0x7335B0, RpAtomic*>(pRpAtomic);
  253  }

  256  void CVisibilityPlugins::RenderPlayerCB(RpAtomic* pRpAtomic) {
  257:     plugin::Call<0x732870, RpAtomic*>(pRpAtomic);
  258  }

  261  void CVisibilityPlugins::RenderReallyDrawLastObjects() {
  262:     plugin::Call<0x733800>();
  263  }

  266  void CVisibilityPlugins::RenderTrainHiDetailAlphaCB(RpAtomic* pRpAtomic) {
  267:     plugin::Call<0x734240, RpAtomic*>(pRpAtomic);
  268  }

  271  void CVisibilityPlugins::RenderTrainHiDetailCB(RpAtomic* pRpAtomic) {
  272:     plugin::Call<0x733330, RpAtomic*>(pRpAtomic);
  273  }

  276  void CVisibilityPlugins::RenderVehicleHiDetailAlphaCB(RpAtomic* pRpAtomic) {
  277:     plugin::Call<0x733F80, RpAtomic*>(pRpAtomic);
  278  }

  281  void CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle(RpAtomic* pRpAtomic) {
  282:     plugin::Call<0x734370, RpAtomic*>(pRpAtomic);
  283  }

  286  void CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_Boat(RpAtomic* pRpAtomic) {
  287:     plugin::Call<0x7344A0, RpAtomic*>(pRpAtomic);
  288  }

  291  void CVisibilityPlugins::RenderVehicleHiDetailCB(RpAtomic* pRpAtomic) {
  292:     plugin::Call<0x733240, RpAtomic*>(pRpAtomic);
  293  }

  296  void CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle(RpAtomic* pRpAtomic) {
  297:     plugin::Call<0x733420, RpAtomic*>(pRpAtomic);
  298  }

  301  void CVisibilityPlugins::RenderVehicleHiDetailCB_Boat(RpAtomic* pRpAtomic) {
  302:     plugin::Call<0x733550, RpAtomic*>(pRpAtomic);
  303  }

  306  void CVisibilityPlugins::RenderVehicleLoDetailCB_Boat(RpAtomic* pRpAtomic) {
  307:     plugin::Call<0x7334F0, RpAtomic*>(pRpAtomic);
  308  }

  311  void CVisibilityPlugins::RenderVehicleReallyLowDetailCB(RpAtomic* pRpAtomic) {
  312:     plugin::Call<0x7331E0, RpAtomic*>(pRpAtomic);
  313  }

  316  void CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle(RpAtomic* pRpAtomic) {
  317:     plugin::Call<0x732820, RpAtomic*>(pRpAtomic);
  318  }

  321  void CVisibilityPlugins::RenderWeaponCB(RpAtomic* pRpAtomic) {
  322:     plugin::Call<0x733670, RpAtomic*>(pRpAtomic);
  323  }

  326  void CVisibilityPlugins::RenderWeaponPedsForPC() {
  327:     plugin::Call<0x732F30>();
  328  }

  331  void CVisibilityPlugins::SetAtomicFlag(RpAtomic* pRpAtomic, int flag) {
  332:     plugin::Call<0x7322D0, RpAtomic*, int>(pRpAtomic, flag);
  333  }

  336  void CVisibilityPlugins::SetAtomicFlag(RpAtomic* pRpAtomic, unsigned short flag) {
  337:     plugin::Call<0x7322B0, RpAtomic*, unsigned short>(pRpAtomic, flag);
  338  }

  341  void CVisibilityPlugins::SetAtomicId(RpAtomic* pRpAtomic, int id) {
  342:     plugin::Call<0x732230, RpAtomic*, int>(pRpAtomic, id);
  343  }

  346  void CVisibilityPlugins::SetAtomicRenderCallback(RpAtomic *pRpAtomic, RpAtomic * (*renderCB)(RpAtomic *)) {
  347:     plugin::Call<0x7328A0,RpAtomic*, RpAtomic * (*)(RpAtomic *)>(pRpAtomic,renderCB);
  348  }

  351  void CVisibilityPlugins::SetClumpAlpha(RpClump* pRpClump, int dwAlpha) {
  352:     plugin::Call<0x732B00, RpClump*, int>(pRpClump, dwAlpha);
  353  }

  356  void CVisibilityPlugins::SetClumpModelInfo(RpClump* pRpClump, CClumpModelInfo* pClumpModelInfo) {
  357:     plugin::Call<0x733750, RpClump*, CClumpModelInfo*>(pRpClump, pClumpModelInfo);
  358  }

  361  void CVisibilityPlugins::SetFrameHierarchyId(RwFrame* pRwFrame, int id) {
  362:     plugin::Call<0x732A00, RwFrame*, int>(pRwFrame, id);
  363  }

  366  void CVisibilityPlugins::SetRenderWareCamera(RwCamera* pRwCamera) {
  367:     plugin::Call<0x7328C0, RwCamera*>(pRwCamera);
  368  }

  371  void CVisibilityPlugins::SetUserValue(RpAtomic* pRpAtomic, unsigned short value) {
  372:     plugin::Call<0x732380, RpAtomic*, unsigned short>(pRpAtomic, value);
  373  }

  376  void CVisibilityPlugins::SetupVehicleVariables(RpClump* pRpClump) {
  377:     plugin::Call<0x733160, RpClump*>(pRpClump);
  378  }

  381  void CVisibilityPlugins::Shutdown() {
  382:     plugin::Call<0x732EB0>();
  383  }

  386  bool CVisibilityPlugins::VehicleVisibilityCB(RpClump* pRpClump) {
  387:     return plugin::CallAndReturn<bool, 0x7336F0, RpClump*>(pRpClump);
  388  }

  391  bool CVisibilityPlugins::VehicleVisibilityCB_BigVehicle(RpClump* pRpClump) {
  392:     return plugin::CallAndReturn<bool, 0x732AB0, RpClump*>(pRpClump);
  393  }

plugin_sa\game_sa\CWanted.cpp:
   14  void CWanted::InitialiseStaticVariables() {
   15:     plugin::Call<0x561C70>();
   16  }

   19  void CWanted::UpdateWantedLevel() {
   20:     plugin::CallMethod<0x561C90, CWanted *>(this);
   21  }

   24  void CWanted::SetMaximumWantedLevel(int level) {
   25:     plugin::Call<0x561E70, int>(level);
   26  }

   29  bool CWanted::AreMiamiViceRequired() {
   30:     return plugin::CallMethodAndReturn<bool, 0x561F30, CWanted *>(this);
   31  }

   34  bool CWanted::AreSwatRequired() {
   35:     return plugin::CallMethodAndReturn<bool, 0x561F40, CWanted *>(this);
   36  }

   39  bool CWanted::AreFbiRequired() {
   40:     return plugin::CallMethodAndReturn<bool, 0x561F60, CWanted *>(this);
   41  }

   44  bool CWanted::AreArmyRequired() {
   45:     return plugin::CallMethodAndReturn<bool, 0x561F80, CWanted *>(this);
   46  }

   49  int CWanted::NumOfHelisRequired() {
   50:     return plugin::CallMethodAndReturn<int, 0x561FA0, CWanted *>(this);
   51  }

   54  void CWanted::ResetPolicePursuit() {
   55:     plugin::Call<0x561FD0>();
   56  }

   59  void CWanted::ClearQdCrimes() {
   60:     plugin::CallMethod<0x561FE0, CWanted *>(this);
   61  }

   64  bool CWanted::AddCrimeToQ(eCrimeType crimeType, int crimeId, CVector const& posn, bool bAlreadyReported, bool bPoliceDontReallyCare) {
   65:     return plugin::CallMethodAndReturn<bool, 0x562000, CWanted *, eCrimeType, int, CVector const&, bool, bool>(this, crimeType, crimeId, posn, bAlreadyReported, bPoliceDontReallyCare);
   66  }

   69  void CWanted::ReportCrimeNow(eCrimeType crimeType, CVector const& posn, bool bPoliceDontReallyCare) {
   70:     plugin::CallMethod<0x562120, CWanted *, eCrimeType, CVector const&, bool>(this, crimeType, posn, bPoliceDontReallyCare);
   71  }

   74  void CWanted::RemovePursuitCop(CCopPed* cop, CCopPed** copsArray, unsigned char& copsCounter) {
   75:     plugin::Call<0x562300, CCopPed*, CCopPed**, unsigned char&>(cop, copsArray, copsCounter);
   76  }

   79  bool CWanted::IsInPursuit(CCopPed* cop) {
   80:     return plugin::CallMethodAndReturn<bool, 0x562330, CWanted *, CCopPed*>(this, cop);
   81  }

   84  void CWanted::UpdateEachFrame() {
   85:     plugin::Call<0x562360>();
   86  }

   89  void CWanted::Initialise() {
   90:     plugin::CallMethod<0x562390, CWanted *>(this);
   91  }

   94  void CWanted::Reset() {
   95:     plugin::CallMethod<0x562400, CWanted *>(this);
   96  }

   99  void CWanted::RegisterCrime(eCrimeType crimeType, CVector const& posn, unsigned int crimeId, bool bPoliceDontReallyCare) {
  100:     plugin::CallMethod<0x562410, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, posn, crimeId, bPoliceDontReallyCare);
  101  }

  104  void CWanted::RegisterCrime_Immediately(eCrimeType crimeType, CVector const& posn, unsigned int crimeId, bool bPoliceDontReallyCare) {
  105:     plugin::CallMethod<0x562430, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, posn, crimeId, bPoliceDontReallyCare);
  106  }

  109  void CWanted::SetWantedLevel(int level) {
  110:     plugin::CallMethod<0x562470, CWanted *, int>(this, level);
  111  }

  114  void CWanted::CheatWantedLevel(int level) {
  115:     plugin::CallMethod<0x562540, CWanted *, int>(this, level);
  116  }

  119  void CWanted::SetWantedLevelNoDrop(int level) {
  120:     plugin::CallMethod<0x562570, CWanted *, int>(this, level);
  121  }

  124  void CWanted::ClearWantedLevelAndGoOnParole() {
  125:     plugin::CallMethod<0x5625A0, CWanted *>(this);
  126  }

  129  int CWanted::WorkOutPolicePresence(CVector posn, float radius) {
  130:     return plugin::CallAndReturn<int, 0x5625F0, CVector, float>(posn, radius);
  131  }

  134  void CWanted::UpdateCrimesQ() {
  135:     plugin::CallMethod<0x562760, CWanted *>(this);
  136  }

  139  bool CWanted::IsClosestCop(CPed* ped, int numCopsToCheck) {
  140:     return plugin::CallMethodAndReturn<bool, 0x5627D0, CWanted *, CPed*, int>(this, ped, numCopsToCheck);
  141  }

  144  CCopPed* CWanted::ComputePursuitCopToDisplace(CCopPed* cop, CCopPed** copsArray) {
  145:     return plugin::CallAndReturn<CCopPed*, 0x562B00, CCopPed*, CCopPed**>(cop, copsArray);
  146  }

  149  void CWanted::RemovePursuitCop(CCopPed* cop) {
  150:     plugin::CallMethod<0x562C10, CWanted *, CCopPed*>(this, cop);
  151  }

  154  void CWanted::RemoveExcessPursuitCops() {
  155:     plugin::CallMethod<0x562C40, CWanted *>(this);
  156  }

  159  void CWanted::Update() {
  160:     plugin::CallMethod<0x562C90, CWanted *>(this);
  161  }

  164  bool CWanted::CanCopJoinPursuit(CCopPed* cop, unsigned char maxCopsCount, CCopPed** copsArray, unsigned char& copsCounter) {
  165:     return plugin::CallAndReturn<bool, 0x562F60, CCopPed*, unsigned char, CCopPed**, unsigned char&>(cop, maxCopsCount, copsArray, copsCounter);
  166  }

  169  bool CWanted::CanCopJoinPursuit(CCopPed* cop) {
  170:     return plugin::CallMethodAndReturn<bool, 0x562FB0, CWanted *, CCopPed*>(this, cop);
  171  }

  174  bool CWanted::SetPursuitCop(CCopPed* cop) {
  175:     return plugin::CallMethodAndReturn<bool, 0x563060, CWanted *, CCopPed*>(this, cop);
  176  }

plugin_sa\game_sa\CWeapon.cpp:
   23  void CWeapon::InitialiseWeapons() {
   24:     plugin::Call<0x73A300>();
   25  }

   28  void CWeapon::ShutdownWeapons() {
   29:     plugin::Call<0x73A330>();
   30  }

   33  void CWeapon::UpdateWeapons() {
   34:     plugin::Call<0x73A360>();
   35  }

   38  void CWeapon::Shutdown() {
   39:     plugin::CallMethod<0x73A380, CWeapon *>(this);
   40  }

   43  void CWeapon::AddGunshell(CEntity* creator, CVector const& position, CVector2D const& direction, float size) {
   44:     plugin::CallMethod<0x73A3E0, CWeapon *, CEntity*, CVector const&, CVector2D const&, float>(this, creator, position, direction, size);
   45  }

   48  void CWeapon::GenerateDamageEvent(CPed* victim, CEntity* creator, eWeaponType weaponType, int damageFactor, ePedPieceTypes pedPiece, int direction) {
   49:     plugin::Call<0x73A530, CPed*, CEntity*, eWeaponType, int, ePedPieceTypes, int>(victim, creator, weaponType, damageFactor, pedPiece, direction);
   50  }

   53  bool CWeapon::LaserScopeDot(CVector* outCoord, float* outSize) {
   54:     return plugin::CallMethodAndReturn<bool, 0x73A8D0, CWeapon *, CVector*, float*>(this, outCoord, outSize);
   55  }

   58  bool CWeapon::FireSniper(CPed* creator, CEntity* victim, CVector* target) {
   59:     return plugin::CallMethodAndReturn<bool, 0x73AAC0, CWeapon *, CPed*, CEntity*, CVector*>(this, creator, victim, target);
   60  }

   63  void CWeapon::Reload(CPed* owner) {
   64:     plugin::CallMethod<0x73AEB0, CWeapon *, CPed*>(this, owner);
   65  }

   68  void FireOneInstantHitRound(CVector* startPoint, CVector* endPoint, int intensity) {
   69:     plugin::Call<0x73AF00, CVector*, CVector*, int>(startPoint, endPoint, intensity);
   70  }

   73  bool CWeapon::IsTypeMelee() {
   74:     return plugin::CallMethodAndReturn<bool, 0x73B1C0, CWeapon *>(this);
   75  }

   78  bool CWeapon::IsType2Handed() {
   79:     return plugin::CallMethodAndReturn<bool, 0x73B1E0, CWeapon *>(this);
   80  }

   83  bool CWeapon::IsTypeProjectile() {
   84:     return plugin::CallMethodAndReturn<bool, 0x73B210, CWeapon *>(this);
   85  }

   88  bool CWeapon::CanBeUsedFor2Player(eWeaponType weaponType) {
   89:     return plugin::CallAndReturn<bool, 0x73B240, eWeaponType>(weaponType);
   90  }

   93  bool CWeapon::HasWeaponAmmoToBeUsed() {
   94:     return plugin::CallMethodAndReturn<bool, 0x73B2A0, CWeapon *>(this);
   95  }

   98  bool CWeapon::ProcessLineOfSight(CVector const& startPoint, CVector const& endPoint, CColPoint& outColPoint, CEntity*& outEntity, eWeaponType weaponType, CEntity* arg5, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool arg11, bool doIgnoreCameraCheck) {
   99:     return plugin::CallAndReturn<bool, 0x73B300, CVector const&, CVector const&, CColPoint&, CEntity*&, eWeaponType, CEntity*, bool, bool, bool, bool, bool, bool, bool>(startPoint, endPoint, outColPoint, outEntity, weaponType, arg5, buildings, vehicles, peds, objects, dummies, arg11, doIgnoreCameraCheck);
  100  }

  103  void CWeapon::StopWeaponEffect() {
  104:     plugin::CallMethod<0x73B360, CWeapon *>(this);
  105  }

  108  float CWeapon::TargetWeaponRangeMultiplier(CEntity* victim, CEntity* weaponOwner) {
  109:     return plugin::CallAndReturn<float, 0x73B380, CEntity*, CEntity*>(victim, weaponOwner);
  110  }

  113  CWeapon::CWeapon(eWeaponType weaponType, int ammo) {
  114:     plugin::CallMethod<0x73B430, CWeapon *, eWeaponType, int>(this, weaponType, ammo);
  115  }

  118  void CWeapon::Initialise(eWeaponType weaponType, int ammo, CPed* owner) {
  119:     plugin::CallMethod<0x73B4A0, CWeapon *, eWeaponType, int, CPed*>(this, weaponType, ammo, owner);
  120  }

  123  void CWeapon::DoBulletImpact(CEntity* owner, CEntity* victim, CVector* startPoint, CVector* endPoint, CColPoint* colPoint, int arg5) {
  124:     plugin::CallMethod<0x73B550, CWeapon *, CEntity*, CEntity*, CVector*, CVector*, CColPoint*, int>(this, owner, victim, startPoint, endPoint, colPoint, arg5);
  125  }

  128  bool CWeapon::TakePhotograph(CEntity* owner, CVector* point) {
  129:     return plugin::CallMethodAndReturn<bool, 0x73C1F0, CWeapon *, CEntity*, CVector*>(this, owner, point);
  130  }

  133  void CWeapon::SetUpPelletCol(int numPellets, CEntity* owner, CEntity* victim, CVector& point, CColPoint& colPoint, CMatrix& outMatrix) {
  134:     plugin::CallMethod<0x73C710, CWeapon *, int, CEntity*, CEntity*, CVector&, CColPoint&, CMatrix&>(this, numPellets, owner, victim, point, colPoint, outMatrix);
  135  }

  138  void CWeapon::FireInstantHitFromCar2(CVector startPoint, CVector endPoint, CVehicle* vehicle, CEntity* owner) {
  139:     plugin::CallMethod<0x73CBA0, CWeapon *, CVector, CVector, CVehicle*, CEntity*>(this, startPoint, endPoint, vehicle, owner);
  140  }

  143  void CWeapon::DoDoomAiming(CEntity* owner, CVector* start, CVector* end) {
  144:     plugin::Call<0x73CDC0, CEntity*, CVector*, CVector*>(owner, start, end);
  145  }

  148  void CWeapon::DoTankDoomAiming(CEntity* vehicle, CEntity* owner, CVector* startPoint, CVector* endPoint) {
  149:     plugin::Call<0x73D1E0, CEntity*, CEntity*, CVector*, CVector*>(vehicle, owner, startPoint, endPoint);
  150  }

  153  void CWeapon::DoDriveByAutoAiming(CEntity* owner, CVehicle* vehicle, CVector* startPoint, CVector* endPoint, bool canAimVehicles) {
  154:     plugin::Call<0x73D720, CEntity*, CVehicle*, CVector*, CVector*, bool>(owner, vehicle, startPoint, endPoint, canAimVehicles);
  155  }

  158  void CWeapon::Update(CPed* owner) {
  159:     plugin::CallMethod<0x73DB40, CWeapon *, CPed*>(this, owner);
  160  }

  163  bool CWeapon::CanBeUsedFor2Player() {
  164:     return plugin::CallMethodAndReturn<bool, 0x73DEF0, CWeapon *>(this);
  165  }

  168  void CWeapon::FindNearestTargetEntityWithScreenCoors(float screenX, float screenY, float range, CVector point, float* outX, float* outY) {
  169:     plugin::Call<0x73E240, float, float, float, CVector, float*, float*>(screenX, screenY, range, point, outX, outY);
  170  }

  173  float CWeapon::EvaluateTargetForHeatSeekingMissile(CEntity* entity, CVector& posn, CVector& direction, float distanceMultiplier, bool fromVehicle, CEntity* lastEntity) {
  174:     return plugin::CallAndReturn<float, 0x73E560, CEntity*, CVector&, CVector&, float, bool, CEntity*>(entity, posn, direction, distanceMultiplier, fromVehicle, lastEntity);
  175  }

  178  void CWeapon::DoWeaponEffect(CVector origin, CVector target) {
  179:     plugin::CallMethod<0x73E690, CWeapon *, CVector, CVector>(this, origin, target);
  180  }

  183  bool CWeapon::FireAreaEffect(CEntity* firingEntity, CVector* origin, CEntity* targetEntity, CVector* target) {
  184:     return plugin::CallMethodAndReturn<bool, 0x73E800, CWeapon *, CEntity*, CVector*, CEntity*, CVector*>(this, firingEntity, origin, targetEntity, target);
  185  }

  188  bool CWeapon::FireInstantHitFromCar(CVehicle* vehicle, bool leftSide, bool rightSide) {
  189:     return plugin::CallMethodAndReturn<bool, 0x73EC40, CWeapon *, CVehicle*, bool, bool>(this, vehicle, leftSide, rightSide);
  190  }

  193  bool CWeapon::CheckForShootingVehicleOccupant(CEntity** pCarEntity, CColPoint* colPoint, eWeaponType weaponType, CVector const& origin, CVector const& target) {
  194:     return plugin::CallAndReturn<bool, 0x73F480, CEntity**, CColPoint*, eWeaponType, CVector const&, CVector const&>(pCarEntity, colPoint, weaponType, origin, target);
  195  }

  198  CEntity* CWeapon::PickTargetForHeatSeekingMissile(CVector origin, CVector direction, float distanceMultiplier, CEntity* ignoreEntity, bool fromVehicle, CEntity* lastEntity) {
  199:     return plugin::CallAndReturn<CEntity*, 0x73F910, CVector, CVector, float, CEntity*, bool, CEntity*>(origin, direction, distanceMultiplier, ignoreEntity, fromVehicle, lastEntity);
  200  }

  203  void CWeapon::FireFromCar(CVehicle* vehicle, bool leftSide, bool rightSide) {
  204:     plugin::CallMethod<0x73FA20, CWeapon *, CVehicle*, bool, bool>(this, vehicle, leftSide, rightSide);
  205  }

  208  bool CWeapon::FireInstantHit(CEntity* firingEntity, CVector* origin, CVector* muzzlePosn, CEntity* targetEntity, CVector* target, CVector* originForDriveBy, bool arg6, bool muzzle) {
  209:     return plugin::CallMethodAndReturn<bool, 0x73FB10, CWeapon *, CEntity*, CVector*, CVector*, CEntity*, CVector*, CVector*, bool, bool>(this, firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy, arg6, muzzle);
  210  }

  213  bool CWeapon::FireProjectile(CEntity* firingEntity, CVector* origin, CEntity* targetEntity, CVector* target, float force) {
  214:     return plugin::CallMethodAndReturn<bool, 0x741360, CWeapon *, CEntity*, CVector*, CEntity*, CVector*, float>(this, firingEntity, origin, targetEntity, target, force);
  215  }

  218  bool CWeapon::FireM16_1stPerson(CEntity* owner) {
  219:     return plugin::CallMethodAndReturn<bool, 0x741C00, CWeapon *, CEntity*>(this, owner);
  220  }

  223  bool CWeapon::Fire(CEntity* firingEntity, CVector* origin, CVector* muzzlePosn, CEntity* targetEntity, CVector* target, CVector* originForDriveBy) {
  224:     return plugin::CallMethodAndReturn<bool, 0x742300, CWeapon *, CEntity*, CVector*, CVector*, CEntity*, CVector*, CVector*>(this, firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy);
  225  }

plugin_sa\game_sa\CWeaponEffects.cpp:
  15  CWeaponEffects::CWeaponEffects() {
  16:     plugin::CallMethod<0x742A90, CWeaponEffects *>(this);
  17  }

  20  CWeaponEffects::~CWeaponEffects() {
  21:     plugin::CallMethod<0x742AA0, CWeaponEffects *>(this);
  22  }

  25  void CWeaponEffects::Init() {
  26:     plugin::Call<0x742AB0>();
  27  }

  30  void CWeaponEffects::Shutdown() {
  31:     plugin::Call<0x742B80>();
  32  }

  35  bool CWeaponEffects::IsLockedOn(int crosshairId) {
  36:     return plugin::CallAndReturn<bool, 0x742BD0, int>(crosshairId);
  37  }

  40  void CWeaponEffects::MarkTarget(int crosshairId, CVector posn, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, float size, unsigned char arg7) {
  41:     plugin::Call<0x742BF0, int, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float, unsigned char>(crosshairId, posn, red, green, blue, alpha, size, arg7);
  42  }

  45  void CWeaponEffects::ClearCrossHair(int crosshairId) {
  46:     plugin::Call<0x742C60, int>(crosshairId);
  47  }

  50  void CWeaponEffects::ClearCrossHairs() {
  51:     plugin::Call<0x742C80>();
  52  }

  55  void CWeaponEffects::ClearCrossHairImmediately(int crosshairId) {
  56:     plugin::Call<0x742CA0, int>(crosshairId);
  57  }

  60  void CWeaponEffects::ClearCrossHairsImmediately() {
  61:     plugin::Call<0x742CC0>();
  62  }

  65  void CWeaponEffects::Render() {
  66:     plugin::Call<0x742CF0>();
  67  }

plugin_sa\game_sa\CWeather.cpp:
   50  void CWeather::AddRain() {
   51:     plugin::Call<0x72A9A0>();
   52  }

   55  void CWeather::AddSandStormParticles() {
   56:     plugin::Call<0x72A820>();
   57  }

   60  unsigned char* CWeather::FindWeatherTypesList() {
   61:     return plugin::CallAndReturn<unsigned char*, 0x72A520>();
   62  }

   65  void CWeather::ForceWeather(short weatherType) {
   66:     plugin::Call<0x72A4E0, short>(weatherType);
   67  }

   70  void CWeather::ForceWeatherNow(short weatherType) {
   71:     plugin::Call<0x72A4F0, short>(weatherType);
   72  }

   75  bool CWeather::ForecastWeather(int weatherType, int numSteps) {
   76:     return plugin::CallAndReturn<bool, 0x72A590, int, int>(weatherType, numSteps);
   77  }

   80  void CWeather::Init() {
   81:     plugin::Call<0x72A480>();
   82  }

   85  void CWeather::ReleaseWeather() {
   86:     plugin::Call<0x72A510>();
   87  }

   90  void CWeather::RenderRainStreaks() {
   91:     plugin::Call<0x72AF70>();
   92  }

   95  void CWeather::SetWeatherToAppropriateTypeNow() {
   96:     plugin::Call<0x72A790>();
   97  }

  100  void CWeather::Update() {
  101:     plugin::Call<0x72B850>();
  102  }

  105  void CWeather::UpdateInTunnelness() {
  106:     plugin::Call<0x72B630>();
  107  }

  110  void CWeather::UpdateWeatherRegion(CVector* posn) {
  111:     plugin::Call<0x72A640, CVector*>(posn);
  112  }

plugin_sa\game_sa\CWorld.cpp:
   46  void CWorld::ResetLineTestOptions() {
   47:     plugin::Call<0x5631C0>();
   48  }

   51  void CWorld::Initialise() {
   52:     plugin::Call<0x5631E0>();
   53  }

   56  void CWorld::Add(CEntity* entity) {
   57:     plugin::Call<0x563220, CEntity*>(entity);
   58  }

   61  void CWorld::Remove(CEntity* entity) {
   62:     plugin::Call<0x563280, CEntity*>(entity);
   63  }

   66  bool CWorld::ProcessVerticalLineSectorList(CPtrList& ptrList, CColLine const& colLine, CColPoint& colPoint, float& maxTouchDistance, CEntity*& outEntity, bool doSeeThroughCheck, CStoredCollPoly* collPoly) {
   67:     return plugin::CallAndReturn<bool, 0x5632B0, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, CStoredCollPoly*>(ptrList, colLine, colPoint, maxTouchDistance, outEntity, doSeeThroughCheck, collPoly);
   68  }

   71  void CWorld::CastShadowSectorList(CPtrList& ptrList, float arg1, float arg2, float arg3, float arg4) {
   72:     plugin::Call<0x563390, CPtrList&, float, float, float, float>(ptrList, arg1, arg2, arg3, arg4);
   73  }

   76  void CWorld::ProcessForAnimViewer() {
   77:     plugin::Call<0x5633D0>();
   78  }

   81  void CWorld::ProcessPedsAfterPreRender() {
   82:     plugin::Call<0x563430>();
   83  }

   86  void CWorld::ClearScanCodes() {
   87:     plugin::Call<0x563470>();
   88  }

   91  void CWorld::FindObjectsInRangeSectorList(CPtrList& arg0, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
   92:     plugin::Call<0x563500, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(arg0, point, radius, b2D, outCount, maxCount, outEntities);
   93  }

   96  void CWorld::FindObjectsOfTypeInRangeSectorList(unsigned int modelId, CPtrList& ptrList, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
   97:     plugin::Call<0x5635C0, unsigned int, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(modelId, ptrList, point, radius, b2D, outCount, maxCount, outEntities);
   98  }

  101  bool CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(CPtrList& ptrList, CColLine const& colLine, CEntity*& outEntity, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  102:     return plugin::CallAndReturn<bool, 0x5636A0, CPtrList&, CColLine const&, CEntity*&, bool, CStoredCollPoly*>(ptrList, colLine, outEntity, doSeeThroughCheck, outCollPoly);
  103  }

  106  void CWorld::RemoveStaticObjects() {
  107:     plugin::Call<0x563840>();
  108  }

  111  void CWorld::TestForBuildingsOnTopOfEachOther(CPtrList& ptrList) {
  112:     plugin::Call<0x563950, CPtrList&>(ptrList);
  113  }

  116  void CWorld::TestForUnusedModels(CPtrList& ptrList, int* models) {
  117:     plugin::Call<0x5639D0, CPtrList&, int*>(ptrList, models);
  118  }

  121  void CWorld::RemoveEntityInsteadOfProcessingIt(CEntity* entity) {
  122:     plugin::Call<0x563A10, CEntity*>(entity);
  123  }

  126  void CWorld::CallOffChaseForAreaSectorListVehicles(CPtrList& ptrList, float x1, float y1, float x2, float y2, float arg5, float arg6, float arg7, float arg8) {
  127:     plugin::Call<0x563A80, CPtrList&, float, float, float, float, float, float, float, float>(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
  128  }

  131  void CWorld::CallOffChaseForAreaSectorListPeds(CPtrList& ptrList, float x1, float y1, float x2, float y2, float arg5, float arg6, float arg7, float arg8) {
  132:     plugin::Call<0x563D00, CPtrList&, float, float, float, float, float, float, float, float>(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
  133  }

  136  bool CWorld::CameraToIgnoreThisObject(CEntity* entity) {
  137:     return plugin::CallAndReturn<bool, 0x563F40, CEntity*>(entity);
  138  }

  141  int CWorld::FindPlayerSlotWithPedPointer(void* ptr) {
  142:     return plugin::CallAndReturn<int, 0x563FA0, void*>(ptr);
  143  }

  146  int CWorld::FindPlayerSlotWithRemoteVehiclePointer(void* ptr) {
  147:     return plugin::CallAndReturn<int, 0x563FD0, void*>(ptr);
  148  }

  151  void CWorld::FindPlayerSlotWithVehiclePointer(CEntity* vehiclePtr) {
  152:     plugin::Call<0x564000, CEntity*>(vehiclePtr);
  153  }

  156  void CWorld::ShutDown() {
  157:     plugin::Call<0x564050>();
  158  }

  161  void CWorld::ClearForRestart() {
  162:     plugin::Call<0x564360>();
  163  }

  166  bool CWorld::ProcessVerticalLineSector_FillGlobeColPoints(CSector& sector, CRepeatSector& repeatSector, CColLine const& colLine, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  167:     return plugin::CallAndReturn<bool, 0x564420, CSector&, CRepeatSector&, CColLine const&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, repeatSector, colLine, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  168  }

  171  bool CWorld::ProcessVerticalLineSector(CSector& sector, CRepeatSector& repeatSector, CColLine const& colLine, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  172:     return plugin::CallAndReturn<bool, 0x564500, CSector&, CRepeatSector&, CColLine const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, repeatSector, colLine, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  173  }

  176  void CWorld::CastShadow(float x1, float y1, float x2, float y2) {
  177:     plugin::Call<0x564600, float, float, float, float>(x1, y1, x2, y2);
  178  }

  181  void CWorld::ProcessAttachedEntities() {
  182:     plugin::Call<0x5647F0>();
  183  }

  186  bool CWorld::GetIsLineOfSightSectorListClear(CPtrList& ptrList, CColLine const& colLine, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  187:     return plugin::CallAndReturn<bool, 0x564970, CPtrList&, CColLine const&, bool, bool>(ptrList, colLine, doSeeThroughCheck, doCameraIgnoreCheck);
  188  }

  191  void CWorld::FindObjectsInRange(CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  192:     plugin::Call<0x564A20, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  193  }

  196  void CWorld::FindObjectsOfTypeInRange(unsigned int modelId, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  197:     plugin::Call<0x564C70, unsigned int, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  198  }

  201  void CWorld::FindLodOfTypeInRange(unsigned int modelId, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  202:     plugin::Call<0x564ED0, unsigned int, CVector const&, float, bool, short*, short, CEntity**>(modelId, point, radius, b2D, outCount, maxCount, outEntities);
  203  }

  206  void CWorld::FindObjectsKindaCollidingSectorList(CPtrList& ptrList, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  207:     plugin::Call<0x565000, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(ptrList, point, radius, b2D, outCount, maxCount, outEntities);
  208  }

  211  void CWorld::FindObjectsIntersectingCubeSectorList(CPtrList& ptrList, CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities) {
  212:     plugin::Call<0x5650E0, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**>(ptrList, cornerA, cornerB, outCount, maxCount, outEntities);
  213  }

  216  void CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(CPtrList& ptrList, CBox const& box, CMatrix const& transform, CVector const& point, short* outCount, short maxCount, CEntity** outEntities) {
  217:     plugin::Call<0x565200, CPtrList&, CBox const&, CMatrix const&, CVector const&, short*, short, CEntity**>(ptrList, box, transform, point, outCount, maxCount, outEntities);
  218  }

  221  void CWorld::FindMissionEntitiesIntersectingCubeSectorList(CPtrList& ptrList, CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool vehiclesList, bool pedsList, bool objectsList) {
  222:     plugin::Call<0x565300, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(ptrList, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);
  223  }

  226  void CWorld::FindNearestObjectOfTypeSectorList(int modelId, CPtrList& ptrList, CVector const& point, float radius, bool b2D, CEntity** outEntities, float* outDistance) {
  227:     plugin::Call<0x565450, int, CPtrList&, CVector const&, float, bool, CEntity**, float*>(modelId, ptrList, point, radius, b2D, outEntities, outDistance);
  228  }

  231  void CWorld::RemoveReferencesToDeletedObject(CEntity* entity) {
  232:     plugin::Call<0x565510, CEntity*>(entity);
  233  }

  236  void CWorld::SetPedsOnFire(float x1, float y1, float x2, float y2, CEntity* fireCreator) {
  237:     plugin::Call<0x565610, float, float, float, float, CEntity*>(x1, y1, x2, y2, fireCreator);
  238  }

  241  void CWorld::SetPedsChoking(float x1, float y1, float x2, float y2, CEntity* gasCreator) {
  242:     plugin::Call<0x565800, float, float, float, float, CEntity*>(x1, y1, x2, y2, gasCreator);
  243  }

  246  void CWorld::SetCarsOnFire(float x1, float y1, float x2, float y2, CEntity* fireCreator) {
  247:     plugin::Call<0x5659F0, float, float, float, float, CEntity*>(x1, y1, x2, y2, fireCreator);
  248  }

  251  bool CWorld::SprayPaintWorld(CVector& posn, CVector& outDir, float radius, bool processTagAlphaState) {
  252:     return plugin::CallAndReturn<bool, 0x565B70, CVector&, CVector&, float, bool>(posn, outDir, radius, processTagAlphaState);
  253  }

  256  void CWorld::RemoveFallenPeds() {
  257:     plugin::Call<0x565CB0>();
  258  }

  261  void CWorld::RemoveFallenCars() {
  262:     plugin::Call<0x565E80>();
  263  }

  266  void CWorld::UseDetonator(CEntity* creator) {
  267:     plugin::Call<0x5660B0, CEntity*>(creator);
  268  }

  271  CEntity* CWorld::TestSphereAgainstSectorList(CPtrList& ptrList, CVector sphereCenter, float sphereRadius, CEntity* ignoreEntity, bool doCameraIgnoreCheck) {
  272:     return plugin::CallAndReturn<CEntity*, 0x566140, CPtrList&, CVector, float, CEntity*, bool>(ptrList, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);
  273  }

  276  void CWorld::PrintCarChanges() {
  277:     plugin::Call<0x566420>();
  278  }

  281  void CWorld::TestForBuildingsOnTopOfEachOther() {
  282:     plugin::Call<0x5664A0>();
  283  }

  286  void CWorld::TestForUnusedModels() {
  287:     plugin::Call<0x566510>();
  288  }

  291  void CWorld::ClearCarsFromArea(float x1, float y1, float z1, float x2, float y2, float z2) {
  292:     plugin::Call<0x566610, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
  293  }

  296  void CWorld::ClearPedsFromArea(float x1, float y1, float z1, float x2, float y2, float z2) {
  297:     plugin::Call<0x5667F0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
  298  }

  301  void CWorld::SetAllCarsCanBeDamaged(bool enable) {
  302:     plugin::Call<0x5668F0, bool>(enable);
  303  }

  306  void CWorld::ExtinguishAllCarFiresInArea(CVector point, float radius) {
  307:     plugin::Call<0x566950, CVector, float>(point, radius);
  308  }

  311  void CWorld::CallOffChaseForArea(float x1, float y1, float x2, float y2) {
  312:     plugin::Call<0x566A60, float, float, float, float>(x1, y1, x2, y2);
  313  }

  316  void CWorld::StopAllLawEnforcersInTheirTracks() {
  317:     plugin::Call<0x566C10>();
  318  }

  321  CVehicle* CWorld::FindUnsuspectingTargetCar(CVector point, CVector playerPosn) {
  322:     return plugin::CallAndReturn<CVehicle*, 0x566C90, CVector, CVector>(point, playerPosn);
  323  }

  326  CPed* CWorld::FindUnsuspectingTargetPed(CVector point, CVector playerPosn) {
  327:     return plugin::CallAndReturn<CPed*, 0x566DA0, CVector, CVector>(point, playerPosn);
  328  }

  331  bool CWorld::ProcessLineOfSightSectorList(CPtrList& ptrList, CColLine const& colLine, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool doSeeThroughCheck, bool doIgnoreCameraCheck, bool doShootThroughCheck) {
  332:     return plugin::CallAndReturn<bool, 0x566EE0, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool>(ptrList, colLine, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doIgnoreCameraCheck, doShootThroughCheck);
  333  }

  336  bool CWorld::ProcessVerticalLine(CVector const& origin, float distance, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  337:     return plugin::CallAndReturn<bool, 0x5674E0, CVector const&, float, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  338  }

  341  bool CWorld::ProcessVerticalLine_FillGlobeColPoints(CVector const& origin, float distance, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  342:     return plugin::CallAndReturn<bool, 0x567620, CVector const&, float, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  343  }

  346  void CWorld::TriggerExplosionSectorList(CPtrList& ptrList, CVector const& point, float radius, float visibleDistance, CEntity* victim, CEntity* creator, bool processVehicleBombTimer, float damage) {
  347:     plugin::Call<0x567750, CPtrList&, CVector const&, float, float, CEntity*, CEntity*, bool, float>(ptrList, point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage);
  348  }

  351  void CWorld::Process() {
  352:     plugin::Call<0x5684A0>();
  353  }

  356  bool CWorld::GetIsLineOfSightSectorClear(CSector& sector, CRepeatSector& repeatSector, CColLine const& colLine, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doIgnoreCameraCheck) {
  357:     return plugin::CallAndReturn<bool, 0x568AD0, CSector&, CRepeatSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, repeatSector, colLine, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doIgnoreCameraCheck);
  358  }

  361  void CWorld::FindObjectsKindaColliding(CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  362:     plugin::Call<0x568B80, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  363  }

  366  void CWorld::FindObjectsIntersectingCube(CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  367:     plugin::Call<0x568DD0, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  368  }

  371  void CWorld::FindObjectsIntersectingAngledCollisionBox(CBox const& box, CMatrix const& transform, CVector const& point, float x1, float y1, float x2, float y2, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  372:     plugin::Call<0x568FF0, CBox const&, CMatrix const&, CVector const&, float, float, float, float, short*, short, CEntity**, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  373  }

  376  void CWorld::FindMissionEntitiesIntersectingCube(CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool vehicles, bool peds, bool objects) {
  377:     plugin::Call<0x569240, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);
  378  }

  381  void CWorld::FindNearestObjectOfType(int modelId, CVector const& point, float radius, bool b2D, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  382:     plugin::Call<0x5693F0, int, CVector const&, float, bool, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, buildings, vehicles, peds, objects, dummies);
  383  }

  386  float CWorld::FindGroundZForCoord(float x, float y) {
  387:     return plugin::CallAndReturn<float, 0x569660, float, float>(x, y);
  388  }

  391  float CWorld::FindGroundZFor3DCoord(float x, float y, float z, bool* outResult, CEntity** outEntity) {
  392:     return plugin::CallAndReturn<float, 0x5696C0, float, float, float, bool*, CEntity**>(x, y, z, outResult, outEntity);
  393  }

  396  float CWorld::FindRoofZFor3DCoord(float x, float y, float z, bool* outResult) {
  397:     return plugin::CallAndReturn<float, 0x569750, float, float, float, bool*>(x, y, z, outResult);
  398  }

  401  float CWorld::FindLowestZForCoord(float x, float y) {
  402:     return plugin::CallAndReturn<float, 0x5697F0, float, float>(x, y);
  403  }

  406  void CWorld::RepositionOneObject(CEntity* object) {
  407:     plugin::Call<0x569850, CEntity*>(object);
  408  }

  411  CEntity* CWorld::TestSphereAgainstWorld(CVector sphereCenter, float sphereRadius, CEntity* arg2, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doCameraIgnoreCheck) {
  412:     return plugin::CallAndReturn<CEntity*, 0x569E20, CVector, float, CEntity*, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, arg2, buildings, vehicles, peds, objects, dummies, doCameraIgnoreCheck);
  413  }

  416  void CWorld::ClearExcitingStuffFromArea(CVector const& point, float radius, unsigned char bRemoveProjectilesAndShadows) {
  417:     plugin::Call<0x56A0D0, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);
  418  }

  421  bool CWorld::GetIsLineOfSightClear(CVector const& origin, CVector const& target, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  422:     return plugin::CallAndReturn<bool, 0x56A490, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  423  }

  426  bool CWorld::ProcessLineOfSightSector(CSector& sector, CRepeatSector& repeatSector, CColLine const& colLine, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck, bool doShootThroughCheck) {
  427:     return plugin::CallAndReturn<bool, 0x56B5E0, CSector&, CRepeatSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(sector, repeatSector, colLine, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
  428  }

  431  void CWorld::TriggerExplosion(CVector const& point, float radius, float visibleDistance, CEntity* victim, CEntity* creator, bool processVehicleBombTimer, float damage) {
  432:     plugin::Call<0x56B790, CVector const&, float, float, CEntity*, CEntity*, bool, float>(point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage);
  433  }

  436  void CWorld::SetWorldOnFire(float x, float y, float z, float radius, CEntity* fireCreator) {
  437:     plugin::Call<0x56B910, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
  438  }

  441  void CWorld::RepositionCertainDynamicObjects() {
  442:     plugin::Call<0x56B9C0>();
  443  }

  446  bool CWorld::ProcessLineOfSight(CVector const& origin, CVector const& target, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck, bool doShootThroughCheck) {
  447:     return plugin::CallAndReturn<bool, 0x56BA00, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
  448  }

  451  short GetCurrentScanCode() {
  452:     return plugin::CallAndReturn<short, 0x407250>();
  453  }

  456  CSector* GetSector(int x, int y) {
  457:     return plugin::CallAndReturn<CSector*, 0x407260, int, int>(x, y);
  458  }

  461  CRepeatSector* GetRepeatSector(int x, int y) {
  462:     return plugin::CallAndReturn<CRepeatSector*, 0x4072A0, int, int>(x, y);
  463  }

  466  CPtrListSingleLink* GetLodPtrList(int x, int y) {
  467:     return plugin::CallAndReturn<CPtrListSingleLink*, 0x4072C0, int, int>(x, y);
  468  }

  471  void SetNextScanCode() {
  472:     plugin::Call<0x4072E0>();
  473  }

plugin_sa\game_sa\D3DIndexDataBuffer.cpp:
  10  void D3DIndexDataBuffer::Clear() {
  11:     plugin::CallMethod<0x7301D0, D3DIndexDataBuffer *>(this);
  12  }

  15  void D3DIndexDataBuffer::Destroy() {
  16:     plugin::CallMethod<0x730200, D3DIndexDataBuffer *>(this);
  17  }

  20  unsigned int D3DIndexDataBuffer::GetTotalDataSize() {
  21:     return plugin::CallMethodAndReturn<unsigned int, 0x7303B0, D3DIndexDataBuffer *>(this);
  22  }

  25  void D3DIndexDataBuffer::Resize(unsigned int newCapacity) {
  26:     plugin::CallMethod<0x730330, D3DIndexDataBuffer *, unsigned int>(this, newCapacity);
  27  }

  30  void D3DIndexDataBuffer::Setup(unsigned int format, int _f4, unsigned int capacity) {
  31:     plugin::CallMethod<0x730190, D3DIndexDataBuffer *, unsigned int, int, unsigned int>(this, format, _f4, capacity);
  32  }

  36  IDirect3DIndexBuffer9* D3DIndexDataBuffer::Pop() {
  37:     return plugin::CallMethodAndReturn<IDirect3DIndexBuffer9*, 0x730250, D3DIndexDataBuffer *>(this);
  38  }

  41  IDirect3DIndexBuffer9* D3DIndexDataBuffer::Pop(unsigned int indexCount) {
  42:     return plugin::CallMethodAndReturn<IDirect3DIndexBuffer9*, 0x730270, D3DIndexDataBuffer *, unsigned int>(this, indexCount);
  43  }

  46  bool D3DIndexDataBuffer::Push(IDirect3DIndexBuffer9* indexBuffer) {
  47:     return plugin::CallMethodAndReturn<bool, 0x730300, D3DIndexDataBuffer *, IDirect3DIndexBuffer9*>(this, indexBuffer);
  48  }

  51  bool D3DIndexDataBuffer::PushWithoutIncreasingCounter(IDirect3DIndexBuffer9* indexBuffer) {
  52:     return plugin::CallMethodAndReturn<bool, 0x730B00, D3DIndexDataBuffer *, IDirect3DIndexBuffer9*>(this, indexBuffer);
  53  }

  56  void* D3DIndexDataBuffer::Pop() {
  57:     return plugin::CallMethodAndReturn<void*, 0x730250, D3DIndexDataBuffer *>(this);
  58  }

  61  void* D3DIndexDataBuffer::Pop(unsigned int indexCount) {
  62:     return plugin::CallMethodAndReturn<void*, 0x730270, D3DIndexDataBuffer *, unsigned int>(this, indexCount);
  63  }

  66  bool D3DIndexDataBuffer::Push(void* indexBuffer) {
  67:     return plugin::CallMethodAndReturn<bool, 0x730300, D3DIndexDataBuffer *, void*>(this, indexBuffer);
  68  }

  71  bool D3DIndexDataBuffer::PushWithoutIncreasingCounter(void* indexBuffer) {
  72:     return plugin::CallMethodAndReturn<bool, 0x730B00, D3DIndexDataBuffer *, void*>(this, indexBuffer);
  73  }

plugin_sa\game_sa\D3DResourceSystem.cpp:
  15  void D3DResourceSystem::CancelBuffering() {
  16:     plugin::Call<0x730900>();
  17  }

  20  unsigned int D3DResourceSystem::GetTotalIndexDataSize() {
  21:     return plugin::CallAndReturn<unsigned int, 0x7307F0>();
  22  }

  25  unsigned int D3DResourceSystem::GetTotalPixelsSize() {
  26:     return plugin::CallAndReturn<unsigned int, 0x730660>();
  27  }

  30  void D3DResourceSystem::Init() {
  31:     plugin::Call<0x730830>();
  32  }

  35  void D3DResourceSystem::SetUseD3DResourceBuffering(bool bUse) {
  36:     plugin::Call<0x730AC0, bool>(bUse);
  37  }

  40  void D3DResourceSystem::Shutdown() {
  41:     plugin::Call<0x730A00>();
  42  }

  45  void D3DResourceSystem::TidyUpD3DIndexBuffers(unsigned int count) {
  46:     plugin::Call<0x730740, unsigned int>(count);
  47  }

  50  void D3DResourceSystem::TidyUpD3DTextures(unsigned int count) {
  51:     plugin::Call<0x7305E0, unsigned int>(count);
  52  }

  56  HRESULT D3DResourceSystem::CreateIndexBuffer(unsigned int numIndices, unsigned int format, IDirect3DIndexBuffer9** ppIndexBuffer) {
  57:     return plugin::CallAndReturn<HRESULT, 0x7306A0, unsigned int, unsigned int, IDirect3DIndexBuffer9**>(numIndices, format, ppIndexBuffer);
  58  }

  61  HRESULT D3DResourceSystem::CreateTexture(int width, int height, unsigned int format, IDirect3DTexture9** ppTexture) {
  62:     return plugin::CallAndReturn<HRESULT, 0x730510, int, int, unsigned int, IDirect3DTexture9**>(width, height, format, ppTexture);
  63  }

  66  void D3DResourceSystem::DestroyIndexBuffer(IDirect3DIndexBuffer9* pIndexBuffer) {
  67:     plugin::Call<0x730D30, IDirect3DIndexBuffer9*>(pIndexBuffer);
  68  }

  71  void D3DResourceSystem::DestroyTexture(IDirect3DTexture9* pTexture) {
  72:     plugin::Call<0x730B70, IDirect3DTexture9*>(pTexture);
  73  }

  76  int D3DResourceSystem::CreateIndexBuffer(unsigned int numIndices, unsigned int format, void** ppIndexBuffer) {
  77:     return plugin::CallAndReturn<int, 0x7306A0, unsigned int, unsigned int, void**>(numIndices, format, ppIndexBuffer);
  78  }

  81  int D3DResourceSystem::CreateTexture(int width, int height, unsigned int format, void** ppTexture) {
  82:     return plugin::CallAndReturn<int, 0x730510, int, int, unsigned int, void**>(width, height, format, ppTexture);
  83  }

  86  void D3DResourceSystem::DestroyIndexBuffer(void* pIndexBuffer) {
  87:     plugin::Call<0x730D30, void*>(pIndexBuffer);
  88  }

  91  void D3DResourceSystem::DestroyTexture(void* pTexture) {
  92:     plugin::Call<0x730B70, void*>(pTexture);
  93  }

plugin_sa\game_sa\D3DTextureBuffer.cpp:
  10  void D3DTextureBuffer::Clear() {
  11:     plugin::CallMethod<0x72FEC0, D3DTextureBuffer *>(this);
  12  }

  15  void D3DTextureBuffer::Destroy() {
  16:     plugin::CallMethod<0x72FEF0, D3DTextureBuffer *>(this);
  17  }

  20  unsigned int D3DTextureBuffer::GetTotalDataSize() {
  21:     return plugin::CallMethodAndReturn<unsigned int, 0x7300A0, D3DTextureBuffer *>(this);
  22  }

  25  void D3DTextureBuffer::Resize(unsigned int newCapacity) {
  26:     plugin::CallMethod<0x730020, D3DTextureBuffer *, unsigned int>(this, newCapacity);
  27  }

  30  void D3DTextureBuffer::Setup(unsigned int format, int width, int bOneLevel, unsigned int capacity) {
  31:     plugin::CallMethod<0x72FE80, D3DTextureBuffer *, unsigned int, int, int, unsigned int>(this, format, width, bOneLevel, capacity);
  32  }

  36  IDirect3DTexture9* D3DTextureBuffer::Pop() {
  37:     return plugin::CallMethodAndReturn<IDirect3DTexture9*, 0x72FF40, D3DTextureBuffer *>(this);
  38  }

  41  IDirect3DTexture9* D3DTextureBuffer::Pop(unsigned int format, int width, int height, int bOneLevel) {
  42:     return plugin::CallMethodAndReturn<IDirect3DTexture9*, 0x72FF60, D3DTextureBuffer *, unsigned int, int, int, int>(this, format, width, height, bOneLevel);
  43  }

  46  bool D3DTextureBuffer::Push(IDirect3DTexture9* texture) {
  47:     return plugin::CallMethodAndReturn<bool, 0x72FFF0, D3DTextureBuffer *, IDirect3DTexture9*>(this, texture);
  48  }

  51  bool D3DTextureBuffer::PushWithoutIncreasingCounter(IDirect3DTexture9* texture) {
  52:     return plugin::CallMethodAndReturn<bool, 0x730AD0, D3DTextureBuffer *, IDirect3DTexture9*>(this, texture);
  53  }

  56  void* D3DTextureBuffer::Pop() {
  57:     return plugin::CallMethodAndReturn<void*, 0x72FF40, D3DTextureBuffer *>(this);
  58  }

  61  void* D3DTextureBuffer::Pop(unsigned int format, int width, int height, int bOneLevel) {
  62:     return plugin::CallMethodAndReturn<void*, 0x72FF60, D3DTextureBuffer *, unsigned int, int, int, int>(this, format, width, height, bOneLevel);
  63  }

  66  bool D3DTextureBuffer::Push(void* texture) {
  67:     return plugin::CallMethodAndReturn<bool, 0x72FFF0, D3DTextureBuffer *, void*>(this, texture);
  68  }

  71  bool D3DTextureBuffer::PushWithoutIncreasingCounter(void* texture) {
  72:     return plugin::CallMethodAndReturn<bool, 0x730AD0, D3DTextureBuffer *, void*>(this, texture);
  73  }

plugin_sa\game_sa\JPegCompress.cpp:
  10  	assert(pCamera == Scene.m_pRwCamera && "Required due to dirty Rockstar implementation");
  11: 	plugin::Call<0x005D0820>(pCamera, pszPath);
  12  }

  23  	assert(pCamera == Scene.m_pRwCamera && "Required due to dirty Rockstar implementation");
  24: 	plugin::Call<0x005D0740>(pCamera, pBuffer, pSize);
  25  }

  38  	assert(pBuffer == &FrontEndMenuManager.m_pJPegBuffer && "Required due to dirty Rockstar implementation");
  39: 	return plugin::CallAndReturn<RwBool, 0x005D07A0>(pRaster, pBuffer);
  40  }

plugin_sa\game_sa\List_c.cpp:
   6  List_c::List_c(void) {
   7: 	plugin::CallMethod<0x004A8DD0>(this);
   8  }

  12  List_c::~List_c(void) {
  13: 	plugin::CallMethod<0x004A8DE0>(this);
  14  }

  19  	assert(pItem);
  20: 	return plugin::CallMethod<0x004A8DF0, List_c *, ListItem_c *>(this, pItem);
  21  }

  26  	assert(pItem);
  27: 	return plugin::CallMethod<0x004A8E30, List_c *, ListItem_c *>(this, pItem);
  28  }

  35  ListItem_c * List_c::RemoveHead(void) {
  36: 	return plugin::CallMethodAndReturn<ListItem_c *, 0x004A8E70, List_c *>(this);
  37  }

  47  	assert(pItem);
  48: 	return plugin::CallMethodAndReturn<ListItem_c *, 0x004A9000, List_c *, ListItem_c *>(this, pItem);
  49  }

  53  ListItem_c * List_c::GetItemOffset(bool bFromHead, int iOffset) {
  54: 	return plugin::CallMethodAndReturn<ListItem_c *, 0x004A9010, List_c *, bool, int>(this, bFromHead, iOffset);
  55  }

plugin_sa\game_sa\ListItem_c.cpp:
   5  ListItem_c::ListItem_c(void) {
   6: 	plugin::CallMethod<0x004A8DB0>(this);
   7  }

  11  ListItem_c::~ListItem_c(void) {
  12: 	plugin::CallMethod<0x004A8DC0>(this);
  13  }

plugin_sa\game_sa\PipelinePlugin.cpp:
  12  RwBool PipelinePluginAttach(void) {
  13: 	return plugin::CallAndReturn<RwBool, 0x0072FBD0>();
  14  }

  19  	assert(pAtomic);
  20: 	return plugin::CallAndReturn<RwUInt32, 0x0072FC40>(pAtomic);
  21  }

  26  	assert(pAtomic);
  27: 	plugin::Call<0x0072FC50>(pAtomic, uPipelineID);
  28  }

plugin_sa\game_sa\RenderWare.cpp:
  3450  RsEventStatus RsEventHandler(RsEvent e, void* param) {
  3451:     return plugin::CallAndReturn<RsEventStatus, 0x619B60, RsEvent, void*>(e, param);
  3452  }

  3498  void _rwObjectHasFrameSetFrame(void *object, RwFrame *frame) {
  3499:     plugin::Call<0x804EF0, void *, RwFrame *>(object, frame);
  3500  }

  3502  void _rwObjectHasFrameReleaseFrame(void *object) {
  3503:     plugin::Call<0x804F40, void *>(object);
  3504  }

  3506  RpAtomic *_rpD3D9SkinVertexShaderMatrixUpdate(RwMatrix *matrices, RpAtomic *atomic, RpSkin *skin) {
  3507: 	return plugin::CallAndReturn<RpAtomic *, 0x7C78A0, RwMatrix *, RpAtomic *, RpSkin *>(matrices, atomic, skin);
  3508  }

  3510  void _rwD3D9SetStreams(RxD3D9VertexStream *streams, RwBool useOffsets) {
  3511: 	plugin::Call<0x7FA090, RxD3D9VertexStream *, RwBool>(streams, useOffsets);
  3512  }

  3514  RwBool _rwD3D9RenderStateVertexAlphaEnable(RwBool enable) {
  3515: 	return plugin::CallAndReturn<RwBool, 0x7FE0A0, RwBool>(enable);
  3516  }

  3518  RwBool _rwD3D9RenderStateIsVertexAlphaEnable() {
  3519: 	return plugin::CallAndReturn<RwBool, 0x7FE190>();
  3520  }

  3522  RwBool _rwD3D9CheckValidCameraTextureFormat(RwUInt32 format) {
  3523: 	return plugin::CallAndReturn<RwBool, 0x4CBE20, RwUInt32>(format);
  3524  }

  3526  void _rwD3D9SetVertexDeclaration(void *vertexDeclaration) {
  3527: 	plugin::Call<0x7F9F70, void *>(vertexDeclaration);
  3528  }

  3530  void _rwD3D9SetIndices(void *indices) {
  3531: 	plugin::Call<0x7FA1C0, void *>(indices);
  3532  }

  3534  void _rwD3D9DrawPrimitive(RwUInt32 primitiveType, RwUInt32 startIndex, RwUInt32 primitiveCount) {
  3535: 	plugin::Call<0x7FA360, RwUInt32, RwUInt32, RwUInt32>(primitiveType, startIndex, primitiveCount);
  3536  }

  3538  RwBool _rwStreamReadChunkHeader(RwStream *stream, RwUInt32 *pType, RwUInt32 *pLength, RwUInt32 *pVersion, RwUInt32 *pBuild) {
  3539:     return plugin::CallAndReturn<RwBool, 0x7ED0F0, RwStream *, RwUInt32 *, RwUInt32 *, RwUInt32 *, RwUInt32 *>(stream, pType, pLength, pVersion, pBuild);
  3540  }

plugin_sa\game_sa\meta\meta.CAnimBlendAssociation.h:
  666      SUPPORTED_10US stack_object() {
  667:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));
  668      }
  669      SUPPORTED_10US stack_object(CAnimBlendHierarchy &rhs) {
  670:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendHierarchy &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendHierarchy &)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), rhs);
  671      }
  672      SUPPORTED_10US stack_object(RpClump *clump, CAnimBlendHierarchy *hier) {
  673:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendAssociation, void(RpClump *, CAnimBlendHierarchy *)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), clump, hier);
  674      }
  675      SUPPORTED_10US stack_object(CAnimBlendAssociation &rhs) {
  676:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), rhs);
  677      }
  678      SUPPORTED_10US ~stack_object() {
  679:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(dtor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));
  680      }

  686      CAnimBlendAssociation *obj = reinterpret_cast<CAnimBlendAssociation *>(objData);
  687:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), obj);
  688      return obj;

  695      for (unsigned int i = 0; i < objCount; i++)
  696:         plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), &objArray[i]);
  697      return objArray;

  702      CAnimBlendAssociation *obj = reinterpret_cast<CAnimBlendAssociation *>(objData);
  703:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendHierarchy &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendHierarchy &)), obj, rhs);
  704      return obj;

  709      CAnimBlendAssociation *obj = reinterpret_cast<CAnimBlendAssociation *>(objData);
  710:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendAssociation, void(RpClump *, CAnimBlendHierarchy *)), obj, clump, hier);
  711      return obj;

  716      CAnimBlendAssociation *obj = reinterpret_cast<CAnimBlendAssociation *>(objData);
  717:     plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), obj, rhs);
  718      return obj;

  722      if (obj == nullptr) return;
  723:     plugin::CallVirtualMethod<0, CAnimBlendAssociation *, unsigned char>(obj, 1);
  724  }

  730      for (unsigned int i = 0; i < arraySize; i++)
  731:         plugin::CallVirtualMethod<0, CAnimBlendAssociation *, unsigned char>(&objArray[i], 1);
  732      operator delete(objData);

plugin_sa\game_sa\meta\meta.CAnimBlendStaticAssociation.h:
  136      SUPPORTED_10US stack_object() {
  137:         plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff));
  138      }
  139      SUPPORTED_10US stack_object(RpClump *clump, CAnimBlendHierarchy *hierarchy) {
  140:         plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendStaticAssociation, void(RpClump *, CAnimBlendHierarchy *)), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff), clump, hierarchy);
  141      }
  142      SUPPORTED_10US ~stack_object() {
  143:         plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(dtor_gaddr(CAnimBlendStaticAssociation), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff));
  144      }

  150      CAnimBlendStaticAssociation *obj = reinterpret_cast<CAnimBlendStaticAssociation *>(objData);
  151:     plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), obj);
  152      return obj;

  159      for (unsigned int i = 0; i < objCount; i++)
  160:         plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), &objArray[i]);
  161      return objArray;

  166      CAnimBlendStaticAssociation *obj = reinterpret_cast<CAnimBlendStaticAssociation *>(objData);
  167:     plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendStaticAssociation, void(RpClump *, CAnimBlendHierarchy *)), obj, clump, hierarchy);
  168      return obj;

  172      if (obj == nullptr) return;
  173:     plugin::CallVirtualMethod<0, CAnimBlendStaticAssociation *, unsigned char>(obj, 1);
  174  }

  177      if (objArray == nullptr) return;
  178:     plugin::CallVirtualMethod<0, CAnimBlendStaticAssociation *, unsigned char>(objArray, 3);
  179  }

plugin_sa\game_sa\meta\meta.CCamera.h:
  2148      SUPPORTED_10US stack_object() {
  2149:         plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));
  2150      }
  2151      SUPPORTED_10US ~stack_object() {
  2152:         plugin::CallMethodDynGlobal<CCamera *>(dtor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));
  2153      }

  2159      CCamera *obj = reinterpret_cast<CCamera *>(objData);
  2160:     plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), obj);
  2161      return obj;

  2168      for (unsigned int i = 0; i < objCount; i++)
  2169:         plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), &objArray[i]);
  2170      return objArray;

  2174      if (obj == nullptr) return;
  2175:     plugin::CallVirtualMethod<0, CCamera *, char>(obj, 1);
  2176  }

  2182      for (unsigned int i = 0; i < arraySize; i++)
  2183:         plugin::CallVirtualMethod<0, CCamera *, char>(&objArray[i], 1);
  2184      operator delete(objData);

plugin_sa\game_sa\meta\meta.CEntryExit.h:
  179      SUPPORTED_10US stack_object() {
  180:         plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), reinterpret_cast<CEntryExit *>(objBuff));
  181      }

  187      CEntryExit *obj = reinterpret_cast<CEntryExit *>(objData);
  188:     plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), obj);
  189      return obj;

  196      for (unsigned int i = 0; i < objCount; i++)
  197:         plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), &objArray[i]);
  198      return objArray;

plugin_sa\game_sa\meta\meta.CGangInfo.h:
  46      SUPPORTED_10US stack_object() {
  47:         plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));
  48      }
  49      SUPPORTED_10US ~stack_object() {
  50:         plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));
  51      }

  57      CGangInfo *obj = reinterpret_cast<CGangInfo *>(objData);
  58:     plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), obj);
  59      return obj;

  66      for (unsigned int i = 0; i < objCount; i++)
  67:         plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), &objArray[i]);
  68      return objArray;

  72      if (obj == nullptr) return;
  73:     plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), obj);
  74      operator delete(obj);

  81      for (unsigned int i = 0; i < arraySize; i++)
  82:         plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), &objArray[i]);
  83      operator delete(objData);

plugin_sa\game_sa\meta\meta.CMatrixLink.h:
   84      SUPPORTED_10US stack_object() {
   85:         plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), reinterpret_cast<CMatrixLink *>(objBuff));
   86      }
   87      SUPPORTED_10US ~stack_object() {
   88:         plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), reinterpret_cast<CMatrixLink *>(objBuff));
   89      }

   95      CMatrixLink *obj = reinterpret_cast<CMatrixLink *>(objData);
   96:     plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), obj);
   97      return obj;

  104      for (unsigned int i = 0; i < objCount; i++)
  105:         plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), &objArray[i]);
  106      return objArray;

  110      if (obj == nullptr) return;
  111:     plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), obj);
  112      operator delete(obj);

  119      for (unsigned int i = 0; i < arraySize; i++)
  120:         plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), &objArray[i]);
  121      operator delete(objData);

plugin_sa\game_sa\meta\meta.CPedGroup.h:
  214      SUPPORTED_10US stack_object() {
  215:         plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), reinterpret_cast<CPedGroup *>(objBuff));
  216      }
  217      SUPPORTED_10US ~stack_object() {
  218:         plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), reinterpret_cast<CPedGroup *>(objBuff));
  219      }

  225      CPedGroup *obj = reinterpret_cast<CPedGroup *>(objData);
  226:     plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), obj);
  227      return obj;

  234      for (unsigned int i = 0; i < objCount; i++)
  235:         plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), &objArray[i]);
  236      return objArray;

  240      if (obj == nullptr) return;
  241:     plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), obj);
  242      operator delete(obj);

  249      for (unsigned int i = 0; i < arraySize; i++)
  250:         plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), &objArray[i]);
  251      operator delete(objData);

plugin_sa\game_sa\meta\meta.CPedGroupIntelligence.h:
  601      SUPPORTED_10US stack_object() {
  602:         plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), reinterpret_cast<CPedGroupIntelligence *>(objBuff));
  603      }
  604      SUPPORTED_10US ~stack_object() {
  605:         plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), reinterpret_cast<CPedGroupIntelligence *>(objBuff));
  606      }

  612      CPedGroupIntelligence *obj = reinterpret_cast<CPedGroupIntelligence *>(objData);
  613:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), obj);
  614      return obj;

  621      for (unsigned int i = 0; i < objCount; i++)
  622:         plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), &objArray[i]);
  623      return objArray;

  627      if (obj == nullptr) return;
  628:     plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), obj);
  629      operator delete(obj);

  636      for (unsigned int i = 0; i < arraySize; i++)
  637:         plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), &objArray[i]);
  638      operator delete(objData);

plugin_sa\game_sa\meta\meta.CPedGroupMembership.h:
  539      SUPPORTED_10US stack_object() {
  540:         plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), reinterpret_cast<CPedGroupMembership *>(objBuff));
  541      }
  542      SUPPORTED_10US stack_object(CPedGroupMembership const *Obj) {
  543:         plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(ctor_gaddr_o(CPedGroupMembership, void(CPedGroupMembership const *)), reinterpret_cast<CPedGroupMembership *>(objBuff), Obj);
  544      }
  545      SUPPORTED_10US ~stack_object() {
  546:         plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), reinterpret_cast<CPedGroupMembership *>(objBuff));
  547      }

  553      CPedGroupMembership *obj = reinterpret_cast<CPedGroupMembership *>(objData);
  554:     plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), obj);
  555      return obj;

  562      for (unsigned int i = 0; i < objCount; i++)
  563:         plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), &objArray[i]);
  564      return objArray;

  569      CPedGroupMembership *obj = reinterpret_cast<CPedGroupMembership *>(objData);
  570:     plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(ctor_gaddr_o(CPedGroupMembership, void(CPedGroupMembership const *)), obj, Obj);
  571      return obj;

  575      if (obj == nullptr) return;
  576:     plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), obj);
  577      operator delete(obj);

  584      for (unsigned int i = 0; i < arraySize; i++)
  585:         plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), &objArray[i]);
  586      operator delete(objData);

plugin_vc\game_vc\C_PcSave.cpp:
  16  bool C_PcSave::DeleteSlot(int slot) {
  17:     return plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::DeleteSlot), this, slot);
  18  }

  23  bool C_PcSave::PcClassSaveRoutine(int file, unsigned char *data, unsigned int size) {
  24:     return plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int, unsigned char *, unsigned int>(gaddrof(C_PcSave::PcClassSaveRoutine), this, file, data, size);
  25  }

  30  void C_PcSave::PopulateSlotInfo() {
  31:     plugin::CallMethodDynGlobal<C_PcSave *>(gaddrof(C_PcSave::PopulateSlotInfo), this);
  32  }

  37  char C_PcSave::SaveSlot(int slot) {
  38:     return plugin::CallMethodAndReturnDynGlobal<char, C_PcSave *, int>(gaddrof(C_PcSave::SaveSlot), this, slot);
  39  }

  44  void C_PcSave::SetSaveDirectory(char const *path) {
  45:     plugin::CallDynGlobal<char const *>(gaddrof(C_PcSave::SetSaveDirectory), path);
  46  }

plugin_vc\game_vc\C3dMarker.cpp:
  14  void C3dMarker::AddMarker(unsigned int nId, unsigned short nType, float fSize, unsigned char bRed, unsigned char bGreen, unsigned char bBlue, unsigned char bAlpha, unsigned int nPulsePeriod, float fPulseFraction, unsigned short nRotateRate) {
  15:     plugin::CallMethodDynGlobal<C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned int, float, unsigned short>(gaddrof(C3dMarker::AddMarker), this, nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
  16  }

  21  void C3dMarker::Render() {
  22:     plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::Render), this);
  23  }

plugin_vc\game_vc\C3dMarkers.cpp:
  14  void C3dMarkers::PlaceMarkerSet(unsigned int id, unsigned short type, CVector& pos, float size, unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned short pulsePeriod, float pulseFraction, short rotateRate) {
  15:     plugin::Call<0x570270, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, pos, size, r, g, b, a, pulsePeriod, pulseFraction, rotateRate);
  16  }

plugin_vc\game_vc\CAnimBlendAssociation.cpp:
   9  CAnimBlendAssociation::~CAnimBlendAssociation() {
  10:     plugin::CallVirtualMethod<0, CAnimBlendAssociation *>(this, 1);
  11  }

plugin_vc\game_vc\CAnimManager.cpp:
  18  int CAnimManager::GetAnimationBlockIndex(const char *name) {
  19:     return plugin::CallAndReturn<int, 0x4059E0, char const*>(name);
  20  }

  22  CAnimBlock *CAnimManager::GetAnimationBlock(const char *name) {
  23:     return plugin::CallAndReturn<CAnimBlock*, 0x405A50, char const*>(name);
  24  }

  26  CAnimBlendAssociation *CAnimManager::BlendAnimation(RpClump *clump, int assocGroupId, int animationId, float clumpAssocBlendData) {
  27:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x405640, RpClump*, int, int, float>(clump, assocGroupId, animationId, clumpAssocBlendData);
  28  }

  30  CAnimBlendAssociation* CAnimManager::AddAnimation(RpClump * clump, int assocGroupId, int animationId) {
  31:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4058B0, RpClump*, int, int>(clump, assocGroupId, animationId);
  32  }

  34  CAnimBlendAssociation* CAnimManager::GetAnimAssociation(int assocGroupId, const char* name) {
  35:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x405940, int, const char*>(assocGroupId, name);
  36  }

  38  CAnimBlendAssociation* CAnimManager::GetAnimAssociation(int assocGroupId, int animationId) {
  39:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x405960, int, int>(assocGroupId, animationId);
  40  }

plugin_vc\game_vc\cAudioManager.cpp:
  11  CVehicle* cAudioManager::FindVehicleOfPlayer() {
  12: 	return plugin::CallAndReturn<CVehicle*, 0x5F5A60>();
  13  }

plugin_vc\game_vc\cAudioScriptObject.cpp:
  26  void cAudioScriptObject::LoadAllAudioScriptObjects(unsigned char *buffer, unsigned int size) {
  27:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(cAudioScriptObject::LoadAllAudioScriptObjects), buffer, size);
  28  }

  33  void cAudioScriptObject::SaveAllAudioScriptObjects(unsigned char *buffer, int *outSize) {
  34:     plugin::CallDynGlobal<unsigned char *, int *>(gaddrof(cAudioScriptObject::SaveAllAudioScriptObjects), buffer, outSize);
  35  }

plugin_vc\game_vc\CAutomobile.cpp:
   15  void CAutomobile::AddDamagedVehicleParticles() {
   16:     plugin::CallMethod<0x5920A0, CAutomobile *>(this);
   17  }

   20  bool CAutomobile::AddWheelDirtAndWater(CColPoint& colPoint, unsigned int arg1) {
   21:     return plugin::CallMethodAndReturn<bool, 0x591B90, CAutomobile *, CColPoint&, unsigned int>(this, colPoint, arg1);
   22  }

   25  void CAutomobile::BlowUpCarsInPath() {
   26:     plugin::CallMethod<0x5863D0, CAutomobile *>(this);
   27  }

   30  CAutomobile::CAutomobile(int modelIndex, unsigned char createdBy) : CVehicle(plugin::dummy) {
   31:     plugin::CallMethod<0x59E620, CAutomobile *, int, unsigned char>(this, modelIndex, createdBy);
   32  }

   35  void CAutomobile::ClearHeliOrientation() {
   36:     plugin::CallMethod<0x59B490, CAutomobile *>(this);
   37  }

   40  void CAutomobile::CloseBoot() {
   41:     plugin::CallMethod<0x585D80, CAutomobile *>(this);
   42  }

   45  void CAutomobile::DoDriveByShootings() {
   46:     plugin::CallMethod<0x5C97B0, CAutomobile *>(this);
   47  }

   50  void CAutomobile::DoHoverSuspensionRatios() {
   51:     plugin::CallMethod<0x585B60, CAutomobile *>(this);
   52  }

   55  void CAutomobile::FireTruckControl(float arg0) {
   56:     plugin::CallMethod<0x57AB30, CAutomobile *, float>(this, arg0);
   57  }

   60  void CAutomobile::Fix() {
   61:     plugin::CallMethod<0x588530, CAutomobile *>(this);
   62  }

   65  bool CAutomobile::HasCarStoppedBecauseOfLight() {
   66:     return plugin::CallMethodAndReturn<bool, 0x435570, CAutomobile *>(this);
   67  }

   70  void CAutomobile::HydraulicControl() {
   71:     plugin::CallMethod<0x59D260, CAutomobile *>(this);
   72  }

   75  CPed* CAutomobile::KnockPedOutCar(eWeaponType weapon, unsigned short arg1, CPed* ped) {
   76:     return plugin::CallMethodAndReturn<CPed*, 0x585F20, CAutomobile *, eWeaponType, unsigned short, CPed*>(this, weapon, arg1, ped);
   77  }

   80  void CAutomobile::PlaceOnRoadProperly() {
   81:     plugin::CallMethod<0x586110, CAutomobile *>(this);
   82  }

   85  void CAutomobile::PlayHornIfNecessary() {
   86:     plugin::CallMethod<0x5881F0, CAutomobile *>(this);
   87  }

   90  void CAutomobile::PopBoot() {
   91:     plugin::CallMethod<0x585E60, CAutomobile *>(this);
   92  }

   95  void CAutomobile::PopBootUsingPhysics() {
   96:     plugin::CallMethod<0x585E20, CAutomobile *>(this);
   97  }

  100  void CAutomobile::ProcessAutoBusDoors() {
  101:     plugin::CallMethod<0x586EC0, CAutomobile *>(this);
  102  }

  105  void CAutomobile::ProcessBuoyancy() {
  106:     plugin::CallMethod<0x599B30, CAutomobile *>(this);
  107  }

  110  void CAutomobile::ProcessSwingingDoor(int nodeIndex, eDoors door) {
  111:     plugin::CallMethod<0x592C40, CAutomobile *, int, eDoors>(this, nodeIndex, door);
  112  }

  115  bool CAutomobile::RcbanditCheck1CarWheels(CPtrList& ptrlist) {
  116:     return plugin::CallMethodAndReturn<bool, 0x5878E0, CAutomobile *, CPtrList&>(this, ptrlist);
  117  }

  120  bool CAutomobile::RcbanditCheckHitWheels() {
  121:     return plugin::CallMethodAndReturn<bool, 0x587B40, CAutomobile *>(this);
  122  }

  125  void CAutomobile::ReduceHornCounter() {
  126:     plugin::CallMethod<0x59AA90, CAutomobile *>(this);
  127  }

  130  CObject* CAutomobile::RemoveBonnetInPedCollision() {
  131:     return plugin::CallMethodAndReturn<CObject*, 0x592BA0, CAutomobile *>(this);
  132  }

  135  void CAutomobile::ScanForCrimes() {
  136:     plugin::CallMethod<0x588120, CAutomobile *>(this);
  137  }

  140  void CAutomobile::SetBumperDamage(int arg0, ePanels panel, bool withoutVisualEffect) {
  141:     plugin::CallMethod<0x59B370, CAutomobile *, int, ePanels, bool>(this, arg0, panel, withoutVisualEffect);
  142  }

  145  void CAutomobile::SetBusDoorTimer(unsigned int time, unsigned char arg1) {
  146:     plugin::CallMethod<0x587080, CAutomobile *, unsigned int, unsigned char>(this, time, arg1);
  147  }

  150  void CAutomobile::SetDoorDamage(int nodeIndex, eDoors door, bool withoutVisualEffect) {
  151:     plugin::CallMethod<0x59B150, CAutomobile *, int, eDoors, bool>(this, nodeIndex, door, withoutVisualEffect);
  152  }

  155  void CAutomobile::SetHeliOrientation(float angle) {
  156:     plugin::CallMethod<0x59B4A0, CAutomobile *, float>(this, angle);
  157  }

  160  void CAutomobile::SetPanelDamage(int nodeIndex, ePanels panel, bool createWindowGlass) {
  161:     plugin::CallMethod<0x59B2A0, CAutomobile *, int, ePanels, bool>(this, nodeIndex, panel, createWindowGlass);
  162  }

  165  void CAutomobile::SetTaxiLight(bool enable) {
  166:     plugin::CallMethod<0x5882F0, CAutomobile *, bool>(this, enable);
  167  }

  170  void CAutomobile::SetupDamageAfterLoad() {
  171:     plugin::CallMethod<0x588310, CAutomobile *>(this);
  172  }

  175  void CAutomobile::SetupSuspensionLines() {
  176:     plugin::CallMethod<0x59E2B0, CAutomobile *>(this);
  177  }

  180  CObject* CAutomobile::SpawnFlyingComponent(int nodeIndex, unsigned int collisionType) {
  181:     return plugin::CallMethodAndReturn<CObject*, 0x59AAA0, CAutomobile *, int, unsigned int>(this, nodeIndex, collisionType);
  182  }

  185  void CAutomobile::TankControl() {
  186:     plugin::CallMethod<0x5864C0, CAutomobile *>(this);
  187  }

  190  void CAutomobile::TellHeliToGoToCoors(float x, float y, float z, unsigned char arg3) {
  191:     plugin::CallMethod<0x59B4B0, CAutomobile *, float, float, float, unsigned char>(this, x, y, z, arg3);
  192  }

  195  void CAutomobile::TellPlaneToGoToCoors(float x, float y, float z, unsigned char arg3) {
  196:     plugin::CallMethod<0x59B420, CAutomobile *, float, float, float, unsigned char>(this, x, y, z, arg3);
  197  }

  200  void CAutomobile::VehicleDamage(float damageIntensity, int arg1) {
  201:     plugin::CallMethod<0x59B550, CAutomobile *, float, int>(this, damageIntensity, arg1);
  202  }

  205  void CAutomobile::dmgDrawCarCollidingParticles(CVector const& position, float force) {
  206:     plugin::CallMethod<0x59C480, CAutomobile *, CVector const&, float>(this, position, force);
  207  }

plugin_vc\game_vc\CBaseModelInfo.cpp:
  10  void CBaseModelInfo::Shutdown() {
  11:     plugin::CallVirtualMethod<1, CBaseModelInfo *>(this);
  12  }

  15  void CBaseModelInfo::DeleteRwObject() {
  16:     plugin::CallVirtualMethod<2, CBaseModelInfo *>(this);
  17  }

  20  RwObject* CBaseModelInfo::CreateInstance() {
  21:     return plugin::CallVirtualMethodAndReturn<RwObject*, 3, CBaseModelInfo *>(this);
  22  }

  25  RwObject* CBaseModelInfo::CreateInstance(RwMatrixTag* tranform) {
  26:     return plugin::CallVirtualMethodAndReturn<RwObject*, 4, CBaseModelInfo *, RwMatrixTag*>(this, tranform);
  27  }

  30  RwObject* CBaseModelInfo::GetRwObject() {
  31:     return plugin::CallVirtualMethodAndReturn<RwObject*, 5, CBaseModelInfo *>(this);
  32  }

  35  void CBaseModelInfo::SetAnimFile(char const* filename) {
  36:     plugin::CallVirtualMethod<6, CBaseModelInfo *, char const*>(this, filename);
  37  }

  40  void CBaseModelInfo::ConvertAnimFileIndex() {
  41:     plugin::CallVirtualMethod<7, CBaseModelInfo *>(this);
  42  }

  45  int CBaseModelInfo::GetAnimFileIndex() {
  46:     return plugin::CallVirtualMethodAndReturn<int, 8, CBaseModelInfo *>(this);
  47  }

  50  void CBaseModelInfo::RemoveRef() {
  51:     plugin::CallMethod<0x53F1A0, CBaseModelInfo *>(this);
  52  }

  55  void CBaseModelInfo::AddRef() {
  56:     plugin::CallMethod<0x53F1B0, CBaseModelInfo *>(this);
  57  }

  60  void CBaseModelInfo::RemoveTexDictionaryRef() {
  61:     plugin::CallMethod<0x53F1C0, CBaseModelInfo *>(this);
  62  }

  65  void CBaseModelInfo::AddTexDictionaryRef() {
  66:     plugin::CallMethod<0x53F1D0, CBaseModelInfo *>(this);
  67  }

  70  void CBaseModelInfo::ClearTexDictionary() {
  71:     plugin::CallMethod<0x53F1E0, CBaseModelInfo *>(this);
  72  }

  75  void CBaseModelInfo::SetTexDictionary(char* txdName) {
  76:     plugin::CallMethod<0x53F1F0, CBaseModelInfo *, char*>(this, txdName);
  77  }

  80  void CBaseModelInfo::Add2dEffect(C2dEffect* effect) {
  81:     plugin::CallMethod<0x53F220, CBaseModelInfo *, C2dEffect*>(this, effect);
  82  }

  85  C2dEffect* CBaseModelInfo::Get2dEffect(int effectNumber) {
  86:     return plugin::CallMethodAndReturn<C2dEffect*, 0x53F260, CBaseModelInfo *, int>(this, effectNumber);
  87  }

  89  CColModel * CBaseModelInfo::GetColModel() {
  90:     return plugin::CallMethodAndReturn<CColModel *, 0x4739B2, CBaseModelInfo *>(this);
  91  }

plugin_vc\game_vc\CBike.cpp:
  10  void CBike::AddDamagedVehicleParticles() {
  11:     plugin::CallMethod<0x60DD20, CBike *>(this);
  12  }

  15  bool CBike::AddWheelDirtAndWater(CColPoint& colPoint, unsigned int arg1) {
  16:     return plugin::CallMethodAndReturn<bool, 0x60D7F0, CBike *, CColPoint&, unsigned int>(this, colPoint, arg1);
  17  }

  20  CBike::CBike(int modelIndex, unsigned char createdBy) : CVehicle(plugin::dummy) {
  21:     plugin::CallMethod<0x615740, CBike *, int, unsigned char>(this, modelIndex, createdBy);
  22  }

  25  void CBike::CalculateLeanMatrix() {
  26:     plugin::CallMethod<0x609C90, CBike *>(this);
  27  }

  30  void CBike::DoDriveByShootings() {
  31:     plugin::CallMethod<0x5C91E0, CBike *>(this);
  32  }

  35  void CBike::Fix() {
  36:     plugin::CallMethod<0x609F00, CBike *>(this);
  37  }

  40  void CBike::GetCorrectedWorldDoorPosition(CVector& out, CVector arg1, CVector arg2) {
  41:     plugin::CallMethod<0x609720, CBike *, CVector&, CVector, CVector>(this, out, arg1, arg2);
  42  }

  45  CPed* CBike::KnockOffRider(eWeaponType arg0, unsigned char arg1, CPed* arg2, bool arg3) {
  46:     return plugin::CallMethodAndReturn<CPed*, 0x613920, CBike *, eWeaponType, unsigned char, CPed*, bool>(this, arg0, arg1, arg2, arg3);
  47  }

  50  void CBike::PlayHornIfNecessary() {
  51:     plugin::CallMethod<0x609E10, CBike *>(this);
  52  }

  55  void CBike::ProcessBuoyancy() {
  56:     plugin::CallMethod<0x613540, CBike *>(this);
  57  }

  60  void CBike::ReduceHornCounter() {
  61:     plugin::CallMethod<0x613910, CBike *>(this);
  62  }

  65  void CBike::SetupSuspensionLines() {
  66:     plugin::CallMethod<0x615080, CBike *>(this);
  67  }

  70  void CBike::VehicleDamage() {
  71:     plugin::CallMethod<0x614860, CBike *>(this);
  72  }

plugin_vc\game_vc\CBoat.cpp:
  13  void CBoat::AddWakePoint(CVector posn) {
  14:     plugin::CallMethod<0x59F580, CBoat *, CVector>(this, posn);
  15  }

  18  void CBoat::ApplyWaterResistance() {
  19:     plugin::CallMethod<0x59FB30, CBoat *>(this);
  20  }

  23  CBoat::CBoat(int modelIndex, unsigned char createdBy) : CVehicle(plugin::dummy) {
  24:     plugin::CallMethod<0x5A6470, CBoat *, int, unsigned char>(this, modelIndex, createdBy);
  25  }

  28  void CBoat::DoDriveByShootings() {
  29:     plugin::CallMethod<0x5C9540, CBoat *>(this);
  30  }

  33  void CBoat::FillBoatList() {
  34:     plugin::Call<0x59F360>();
  35  }

  38  void CBoat::PruneWakeTrail() {
  39:     plugin::CallMethod<0x59F6F0, CBoat *>(this);
  40  }

plugin_vc\game_vc\CBox.cpp:
  10  void CBox::Set(CVector const& vecMin, CVector const& vecMax) {
  11:     plugin::Call<0x410910, CVector const&, CVector const&>(vecMin, vecMax);
  12  }

plugin_vc\game_vc\CBrightLights.cpp:
  15  CBrightLight::CBrightLight() {
  16:     plugin::CallMethod<0x575140, CBrightLight *>(this);
  17  }

  20  void CBrightLights::RegisterOne(CVector posn, CVector right, CVector up, CVector at, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) {
  21:     plugin::Call<0x571820, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(posn, right, up, at, red, green, blue, alpha);
  22  }

  25  void CBrightLights::Render() {
  26:     plugin::Call<0x5719B0>();
  27  }

plugin_vc\game_vc\CBulletInfo.cpp:
  13  void CBulletInfo::AddBullet(CEntity* creator, eWeaponType weaponType, CVector position, CVector velocity) {
  14:     plugin::Call<0x5C47C0, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, position, velocity);
  15  }

  18  CBulletInfo::CBulletInfo() {
  19:     plugin::CallMethod<0x5C4B10, CBulletInfo *>(this);
  20  }

  23  void CBulletInfo::Initialise() {
  24:     plugin::Call<0x5C48C0>();
  25  }

  28  void CBulletInfo::Shutdown() {
  29:     plugin::Call<0x5C48A0>();
  30  }

  33  void CBulletInfo::TestForSniperBullet(float x1, float y1, float z1, float x2, float y2, float z2) {
  34:     plugin::Call<0x5C3B20, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
  35  }

  38  void CBulletInfo::Update() {
  39:     plugin::Call<0x5C3DE0>();
  40  }

plugin_vc\game_vc\CBulletTraces.cpp:
  16  void CBulletTraces::AddTrace(CVector *origin, CVector *target, float radius, unsigned int time, unsigned char transparency) {
  17:     plugin::CallDynGlobal<CVector *, CVector *, float, unsigned int, unsigned char>(gaddrof_o(CBulletTraces::AddTrace, void (*)(CVector *, CVector *, float, unsigned int, unsigned char)), origin, target, radius, time, transparency);
  18  }

  23  void CBulletTraces::AddTrace(CVector *origin, CVector *target, int weaponType, CEntity *entity) {
  24:     plugin::CallDynGlobal<CVector *, CVector *, int, CEntity *>(gaddrof_o(CBulletTraces::AddTrace, void (*)(CVector *, CVector *, int, CEntity *)), origin, target, weaponType, entity);
  25  }

plugin_vc\game_vc\cBuoyancy.cpp:
  11  bool cBuoyancy::ProcessBuoyancy(CPhysical* phys, float buoyancy, CVector* point, CVector* impulse) {
  12:     return plugin::CallMethodAndReturn<bool, 0x5AAC90, cBuoyancy*, CPhysical *, float, CVector*, CVector*>(this, phys, buoyancy, point, impulse);
  13  }

plugin_vc\game_vc\CCamera.cpp:
   18  void CCamera::AvoidTheGeometry(CVector const& Vector1, CVector const& Vector2, CVector& Vector3, float arg4) {
   19: 	plugin::CallMethod<0x473AA4, CCamera *, CVector const&, CVector const&, CVector&, float>(this, Vector1, Vector2, Vector3, arg4);
   20  }

   23  void CCamera::CalculateDerivedValues() {
   24: 	plugin::CallMethod<0x46C3B6, CCamera *>(this);
   25  }

   28  void CCamera::CamControl() {
   29: 	plugin::CallMethod<0x4700E7, CCamera *>(this);
   30  }

   33  void CCamera::CamShake(float arg1, float x_coord, float y_coord, float z_coord) {
   34: 	plugin::CallMethod<0x46FF21, CCamera *, float, float, float, float>(this, arg1, x_coord, y_coord, z_coord);
   35  }

   38  void CCamera::ClearPlayerWeaponMode() {
   39: 	plugin::CallMethod<0x46FE51, CCamera *>(this);
   40  }

   43  void CCamera::DeleteCutSceneCamDataMemory() {
   44: 	plugin::CallMethod<0x46FE25, CCamera *>(this);
   45  }

   48  void CCamera::DontProcessObbeCinemaCamera() {
   49: 	plugin::Call<0x46FE13>();
   50  }

   53  void CCamera::DrawBordersForWideScreen() {
   54: 	plugin::CallMethod<0x46FC1C, CCamera *>(this);
   55  }

   58  void CCamera::Fade(float timeToFade, short FadingDirection) {
   59: 	plugin::CallMethod<0x46FBCB, CCamera *, float, short>(this, timeToFade, FadingDirection);
   60  }

   63  bool CCamera::Find3rdPersonCamTargetVector(float arg1, CVector vector1, CVector& vector2, CVector& vector3) {
   64: 	return plugin::CallMethodAndReturn<bool, 0x46F890, CCamera *, float, CVector, CVector&, CVector&>(this, arg1, vector1, vector2, vector3);
   65  }

   68  float CCamera::Find3rdPersonQuickAimPitch() {
   69: 	return plugin::CallMethodAndReturn<float, 0x46F7C6, CCamera *>(this);
   70  }

   73  void CCamera::FinishCutscene() {
   74: 	plugin::CallMethod<0x46FB3C, CCamera *>(this);
   75  }

   78  bool CCamera::GetArrPosForVehicleType(int vehicleType, int& ArrPos) {
   79: 	return plugin::CallAndReturn<bool, 0x46F659, int, int&>(vehicleType, ArrPos);
   80  }

   83  int CCamera::GetCutSceneFinishTime() {
   84: 	return plugin::CallMethodAndReturn<int, 0x46F77E, CCamera *>(this);
   85  }

   88  bool CCamera::GetFading() {
   89: 	return plugin::CallMethodAndReturn<bool, 0x46F777, CCamera *>(this);
   90  }

   93  CVector* CCamera::GetGameCamPosition() {
   94: 	return plugin::CallMethodAndReturn<CVector*, 0x46F730, CCamera *>(this);
   95  }

   98  int CCamera::GetLookDirection() {
   99: 	return plugin::CallMethodAndReturn<int, 0x46F6CE, CCamera *>(this);
  100  }

  103  bool CCamera::GetLookingForwardFirstPerson() {
  104: 	return plugin::CallMethodAndReturn<bool, 0x46F6A9, CCamera *>(this);
  105  }

  108  bool CCamera::GetLookingLRBFirstPerson() {
  109: 	return plugin::CallMethodAndReturn<bool, 0x46F70B, CCamera *>(this);
  110  }

  113  float CCamera::GetPositionAlongSpline() {
  114: 	return plugin::CallMethodAndReturn<float, 0x46F652, CCamera *>(this);
  115  }

  118  bool CCamera::GetScreenFadeStatus() {
  119: 	return plugin::CallMethodAndReturn<bool, 0x46F737, CCamera *>(this);
  120  }

  123  void CCamera::GetScreenRect(CRect& Rect) {
  124: 	plugin::CallMethod<0x46FD5D, CCamera *, CRect&>(this, Rect);
  125  }

  128  bool CCamera::Get_Just_Switched_Status() {
  129: 	return plugin::CallMethodAndReturn<bool, 0x46F773, CCamera *>(this);
  130  }

  133  void CCamera::Init() {
  134: 	plugin::CallMethod<0x46F108, CCamera *>(this);
  135  }

  138  bool CCamera::IsItTimeForNewcam(int arg1, int timer) {
  139: 	return plugin::CallMethodAndReturn<bool, 0x46E2C4, CCamera *, int, int>(this, arg1, timer);
  140  }

  143  void CCamera::LoadPathSplines(int FilePtr) {
  144: 	plugin::Call<0x46E140, int>(FilePtr);
  145  }

  148  void CCamera::Process() {
  149: 	plugin::CallMethod<0x46C58C, CCamera *>(this);
  150  }

  153  void CCamera::ProcessFade() {
  154: 	plugin::CallMethod<0x46C278, CCamera *>(this);
  155  }

  158  void CCamera::ProcessMusicFade() {
  159: 	plugin::CallMethod<0x46C10D, CCamera *>(this);
  160  }

  163  void CCamera::ProcessObbeCinemaCameraCar() {
  164: 	plugin::CallMethod<0x46BFEE, CCamera *>(this);
  165  }

  168  void CCamera::ProcessObbeCinemaCameraHeli() {
  169: 	plugin::CallMethod<0x46BEE6, CCamera *>(this);
  170  }

  173  void CCamera::ProcessObbeCinemaCameraPed() {
  174: 	plugin::CallMethod<0x46BE18, CCamera *>(this);
  175  }

  178  void CCamera::RenderMotionBlur() {
  179: 	plugin::CallMethod<0x46BDE0, CCamera *>(this);
  180  }

  183  void CCamera::Restore() {
  184: 	plugin::CallMethod<0x46BC7D, CCamera *>(this);
  185  }

  188  void CCamera::RestoreWithJumpCut() {
  189: 	plugin::CallMethod<0x46BB24, CCamera *>(this);
  190  }

  193  void CCamera::SetCamCutSceneOffSet(CVector const& vecCutSceneOffset) {
  194: 	plugin::CallMethod<0x46BB03, CCamera *, CVector const&>(this, vecCutSceneOffset);
  195  }

  198  void CCamera::SetCamPositionForFixedMode(CVector const& vecFixedModeSource, CVector const& vecFixedModeUpOffSet) {
  199: 	plugin::CallMethod<0x46BA72, CCamera *, CVector const&, CVector const&>(this, vecFixedModeSource, vecFixedModeUpOffSet);
  200  }

  203  void CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString() {
  204: 	plugin::CallMethod<0x46BADE, CCamera *>(this);
  205  }

  208  void CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString() {
  209: 	plugin::CallMethod<0x46BAB9, CCamera *>(this);
  210  }

  213  void CCamera::SetFadeColour(unsigned char red, unsigned char green, unsigned char blue) {
  214: 	plugin::CallMethod<0x46BA35, CCamera *, unsigned char, unsigned char, unsigned char>(this, red, green, blue);
  215  }

  218  void CCamera::SetMotionBlur(int red, int green, int blue, int motionblur, int blurtype) {
  219: 	plugin::CallMethod<0x46BA00, CCamera *, int, int, int, int, int>(this, red, green, blue, motionblur, blurtype);
  220  }

  223  void CCamera::SetMotionBlurAlpha(int alpha) {
  224: 	plugin::CallMethod<0x46B9F3, CCamera *, int>(this, alpha);
  225  }

  228  void CCamera::SetNearClipScript(float fNearClipScript) {
  229: 	plugin::CallMethod<0x46B9E2, CCamera *, float>(this, fNearClipScript);
  230  }

  233  void CCamera::SetNewPlayerWeaponMode(short Mode, short MinZoom, short MaxZoom) {
  234: 	plugin::CallMethod<0x46B90D, CCamera *, short, short, short>(this, Mode, MinZoom, MaxZoom);
  235  }

  238  void CCamera::SetParametersForScriptInterpolation(float fScriptInterToStopMoving, float fScriptInterToCatchUp, unsigned int fScriptTimeForInterPolation) {
  239: 	plugin::CallMethod<0x46B8AE, CCamera *, float, float, unsigned int>(this, fScriptInterToStopMoving, fScriptInterToCatchUp, fScriptTimeForInterPolation);
  240  }

  243  void CCamera::SetRwCamera(RwCamera* pRwCam) {
  244: 	plugin::CallMethod<0x46B87A, CCamera *, RwCamera*>(this, pRwCam);
  245  }

  248  void CCamera::SetWideScreenOff() {
  249: 	plugin::CallMethod<0x46B863, CCamera *>(this);
  250  }

  253  void CCamera::SetWideScreenOn() {
  254: 	plugin::CallMethod<0x46B875, CCamera *>(this);
  255  }

  258  void CCamera::SetZoomValueCamStringScript(short mode) {
  259: 	plugin::CallMethod<0x46B743, CCamera *, short>(this, mode);
  260  }

  263  void CCamera::SetZoomValueFollowPedScript(short mode) {
  264: 	plugin::CallMethod<0x46B817, CCamera *, short>(this, mode);
  265  }

  268  void CCamera::StartTransition(short mode) {
  269: 	plugin::CallMethod<0x46AB08, CCamera *, short>(this, mode);
  270  }

  273  void CCamera::StartTransitionWhenNotFinishedInter(short mode) {
  274: 	plugin::CallMethod<0x46AAF5, CCamera *, short>(this, mode);
  275  }

  278  void CCamera::StoreValuesDuringInterPol(CVector& _SourceDuringInter, CVector& _TargetDuringInter, CVector& _UpDuringInter, float& _FOVDuringInter) {
  279: 	plugin::CallMethod<0x46AA01, CCamera *, CVector&, CVector&, CVector&, float&>(this, _SourceDuringInter, _TargetDuringInter, _UpDuringInter, _FOVDuringInter);
  280  }

  283  void CCamera::TakeControl(CEntity* pEntity, short mode, short _TypeOfSwitch, int _WhoIsInControlOfTheCamera) {
  284: 	plugin::CallMethod<0x46A4F8, CCamera *, CEntity*, short, short, int>(this, pEntity, mode, _TypeOfSwitch, _WhoIsInControlOfTheCamera);
  285  }

  288  void CCamera::TakeControlNoEntity(CVector const& vecFixedModeVector, short _TypeOfSwitch, int _WhoIsInControlOfTheCamera) {
  289: 	plugin::CallMethod<0x46A494, CCamera *, CVector const&, short, int>(this, vecFixedModeVector, _TypeOfSwitch, _WhoIsInControlOfTheCamera);
  290  }

  293  void CCamera::TakeControlWithSpline(short TypeOfSwitch) {
  294: 	plugin::CallMethod<0x46A46A, CCamera *, short>(this, TypeOfSwitch);
  295  }

  298  bool CCamera::TryToStartNewCamMode(int mode) {
  299: 	return plugin::CallMethodAndReturn<bool, 0x467AAD, CCamera *, int>(this, mode);
  300  }

  303  void CCamera::UpdateAimingCoors(CVector const& vecAimingTarget) {
  304: 	plugin::CallMethod<0x467A8C, CCamera *, CVector const&>(this, vecAimingTarget);
  305  }

  308  void CCamera::UpdateSoundDistances() {
  309: 	plugin::CallMethod<0x46A885, CCamera *>(this);
  310  }

  313  void CCamera::UpdateTargetEntity() {
  314: 	plugin::CallMethod<0x46A5A3, CCamera *>(this);
  315  }

  318  bool CCamera::Using1stPersonWeaponMode() {
  319: 	return plugin::CallMethodAndReturn<bool, 0x46B8E2, CCamera *>(this);
  320  }

plugin_vc\game_vc\CCarAI.cpp:
   14  void CCarAI::AddAmbulanceOccupants(CVehicle *vehicle) {
   15:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddAmbulanceOccupants), vehicle);
   16  }

   21  void CCarAI::AddFiretruckOccupants(CVehicle *vehicle) {
   22:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddFiretruckOccupants), vehicle);
   23  }

   28  void CCarAI::AddPoliceCarOccupants(CVehicle *vehicle) {
   29:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddPoliceCarOccupants), vehicle);
   30  }

   35  void CCarAI::CarHasReasonToStop(CVehicle *vehicle) {
   36:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::CarHasReasonToStop), vehicle);
   37  }

   42  eCarMission CCarAI::FindPoliceBoatMissionForWantedLevel() {
   43:     return plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceBoatMissionForWantedLevel));
   44  }

   49  eCarMission CCarAI::FindPoliceCarMissionForWantedLevel() {
   50:     return plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceCarMissionForWantedLevel));
   51  }

   56  int CCarAI::FindPoliceCarSpeedForWantedLevel(CVehicle *vehicle) {
   57:     return plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CCarAI::FindPoliceCarSpeedForWantedLevel), vehicle);
   58  }

   63  float CCarAI::GetCarToGoToCoors(CVehicle *vehicle, CVector *coors) {
   64:     return plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToGoToCoors), vehicle, coors);
   65  }

   70  float CCarAI::GetCarToParkAtCoors(CVehicle *vehicle, CVector *coors) {
   71:     return plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToParkAtCoors), vehicle, coors);
   72  }

   77  void CCarAI::MakeWayForCarWithSiren(CVehicle *vehicle) {
   78:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MakeWayForCarWithSiren), vehicle);
   79  }

   84  void CCarAI::MellowOutChaseSpeed(CVehicle *vehicle) {
   85:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeed), vehicle);
   86  }

   91  void CCarAI::MellowOutChaseSpeedBoat(CVehicle *vehicle) {
   92:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeedBoat), vehicle);
   93  }

   98  void CCarAI::TellCarToRamOtherCar(CVehicle *vehicle, CVehicle *ramVehicle) {
   99:     plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToRamOtherCar), vehicle, ramVehicle);
  100  }

  105  void CCarAI::TellOccupantsToFleeCar(CVehicle *vehicle) {
  106:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToFleeCar), vehicle);
  107  }

  112  void CCarAI::TellOccupantsToLeaveCar(CVehicle *vehicle) {
  113:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToLeaveCar), vehicle);
  114  }

  119  void CCarAI::UpdateCarAI(CVehicle *vehicle) {
  120:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::UpdateCarAI), vehicle);
  121  }

plugin_vc\game_vc\CCarCtrl.cpp:
   10  int CCarCtrl::AddToLoadedVehicleArray(int arg0, int arg1, int arg2) {
   11:     return plugin::CallAndReturn<int, 0x4267D0, int, int, int>(arg0, arg1, arg2);
   12  }

   15  int CCarCtrl::AddToVehicleArray(int arg0, int arg1) {
   16:     return plugin::CallAndReturn<int, 0x426820, int, int>(arg0, arg1);
   17  }

   20  int CCarCtrl::ChooseCarModel(int arg0) {
   21:     return plugin::CallAndReturn<int, 0x426AA0, int>(arg0);
   22  }

   25  int CCarCtrl::ChooseCarModelToLoad(int arg0) {
   26:     return plugin::CallAndReturn<int, 0x426A30, int>(arg0);
   27  }

   30  int CCarCtrl::ChooseCarRating(CZoneInfo* arg0) {
   31:     return plugin::CallAndReturn<int, 0x426D40, CZoneInfo*>(arg0);
   32  }

   35  int CCarCtrl::ChooseModel(CZoneInfo* arg0, int* arg1) {
   36:     return plugin::CallAndReturn<int, 0x426B40, CZoneInfo*, int*>(arg0, arg1);
   37  }

   40  int CCarCtrl::ChoosePoliceCarModel() {
   41:     return plugin::CallAndReturn<int, 0x426850>();
   42  }

   45  void CCarCtrl::ClearInterestingVehicleList() {
   46:     plugin::Call<0x41D300>();
   47  }

   50  void CCarCtrl::DragCarToPoint(CVehicle* vehicle, CVector* coords) {
   51:     plugin::Call<0x4208B0, CVehicle*, CVector*>(vehicle, coords);
   52  }

   55  float CCarCtrl::FindAngleToWeaveThroughTraffic(CVehicle* vehicle, CPhysical* physical, float arg2, float arg3) {
   56:     return plugin::CallAndReturn<float, 0x423C00, CVehicle*, CPhysical*, float, float>(vehicle, physical, arg2, arg3);
   57  }

   60  int CCarCtrl::FindLinksToGoWithTheseNodes(CVehicle* vehicle) {
   61:     return plugin::CallAndReturn<int, 0x41CC20, CVehicle*>(vehicle);
   62  }

   65  float CCarCtrl::FindMaximumSpeedForThisCarInTraffic(CVehicle* vehicle) {
   66:     return plugin::CallAndReturn<float, 0x425880, CVehicle*>(vehicle);
   67  }

   70  char CCarCtrl::FindPathDirection(int arg0, int arg1, int arg2) {
   71:     return plugin::CallAndReturn<char, 0x421DC0, int, int, int>(arg0, arg1, arg2);
   72  }

   75  void CCarCtrl::GenerateEmergencyServicesCar() {
   76:     plugin::Call<0x41C940>();
   77  }

   80  bool CCarCtrl::GenerateOneEmergencyServicesCar(unsigned int model, CVector driveToCoord) {
   81:     return plugin::CallAndReturn<bool, 0x41C460, unsigned int, CVector>(model, driveToCoord);
   82  }

   85  void CCarCtrl::GenerateOneRandomCar() {
   86:     plugin::Call<0x426DB0>();
   87  }

   90  void CCarCtrl::GenerateRandomCars() {
   91:     plugin::Call<0x4292A0>();
   92  }

   95  void CCarCtrl::Init() {
   96:     plugin::Call<0x4293D0>();
   97  }

  100  bool CCarCtrl::IsThisVehicleInteresting(CVehicle* vehicle) {
  101:     return plugin::CallAndReturn<bool, 0x41D350, CVehicle*>(vehicle);
  102  }

  105  void CCarCtrl::JoinCarWithRoadSystem(CVehicle* vehicle) {
  106:     plugin::Call<0x41D000, CVehicle*>(vehicle);
  107  }

  110  bool CCarCtrl::JoinCarWithRoadSystemGotoCoors(CVehicle* vehicle, CVector arg1, bool arg2) {
  111:     return plugin::CallAndReturn<bool, 0x41CEB0, CVehicle*, CVector, bool>(vehicle, arg1, arg2);
  112  }

  115  bool CCarCtrl::MapCouldMoveInThisArea(float arg0, float arg1) {
  116:     return plugin::CallAndReturn<bool, 0x41C2F0, float, float>(arg0, arg1);
  117  }

  120  char CCarCtrl::PickNextNodeAccordingStrategy(CVehicle* vehicle) {
  121:     return plugin::CallAndReturn<char, 0x422A10, CVehicle*>(vehicle);
  122  }

  125  int CCarCtrl::PickNextNodeRandomly(CVehicle* vehicle) {
  126:     return plugin::CallAndReturn<int, 0x421F70, CVehicle*>(vehicle);
  127  }

  130  int CCarCtrl::PickNextNodeToChaseCar(CVehicle* vehicle, float arg1, float arg2, CVehicle* arg3) {
  131:     return plugin::CallAndReturn<int, 0x4213A0, CVehicle*, float, float, CVehicle*>(vehicle, arg1, arg2, arg3);
  132  }

  135  bool CCarCtrl::PickNextNodeToFollowPath(CVehicle* vehicle) {
  136:     return plugin::CallAndReturn<bool, 0x420D50, CVehicle*>(vehicle);
  137  }

  140  void CCarCtrl::PossiblyRemoveVehicle(CVehicle* vehicle) {
  141:     plugin::Call<0x426030, CVehicle*>(vehicle);
  142  }

  145  void CCarCtrl::ReInit() {
  146:     plugin::Call<0x429320>();
  147  }

  150  void CCarCtrl::RegisterVehicleOfInterest(CVehicle* vehicle) {
  151:     plugin::Call<0x41D370, CVehicle*>(vehicle);
  152  }

  155  void CCarCtrl::RemoveCarsIfThePoolGetsFull() {
  156:     plugin::Call<0x4264C0>();
  157  }

  160  void CCarCtrl::RemoveDistantCars() {
  161:     plugin::Call<0x426640>();
  162  }

  165  void CCarCtrl::RemoveFromInterestingVehicleList(CVehicle* vehicle) {
  166:     plugin::Call<0x41D320, CVehicle*>(vehicle);
  167  }

  170  void CCarCtrl::RemoveFromLoadedVehicleArray(int arg0, int arg1) {
  171:     plugin::Call<0x426740, int, int>(arg0, arg1);
  172  }

  175  void CCarCtrl::ScanForPedDanger(CVehicle* vehicle) {
  176:     plugin::Call<0x4255E0, CVehicle*>(vehicle);
  177  }

  180  void CCarCtrl::SlowCarDownForCarsSectorList(CPtrList& ptrlist, CVehicle* vehicle, float arg2, float arg3, float arg4, float arg5, float* arg6, float arg7) {
  181:     plugin::Call<0x424B50, CPtrList&, CVehicle*, float, float, float, float, float*, float>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);
  182  }

  185  void CCarCtrl::SlowCarDownForOtherCar(CEntity* entity, CVehicle* vehicle, float* arg2, float arg3) {
  186:     plugin::Call<0x424780, CEntity*, CVehicle*, float*, float>(entity, vehicle, arg2, arg3);
  187  }

  190  void CCarCtrl::SlowCarDownForPedsSectorList(CPtrList& ptrlist, CVehicle* vehicle, float arg2, float arg3, float arg4, float arg5, float* arg6, float arg7) {
  191:     plugin::Call<0x424C70, CPtrList&, CVehicle*, float, float, float, float, float*, float>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);
  192  }

  195  void CCarCtrl::SlowCarOnRailsDownForTrafficAndLights(CVehicle* vehicle) {
  196:     plugin::Call<0x4254C0, CVehicle*>(vehicle);
  197  }

  200  void CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer(CVehicle* vehicle, float* arg1, float* arg2, float* arg3, bool* arg4) {
  201:     plugin::Call<0x41DFA0, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
  202  }

  205  void CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget(CVehicle* vehicle, float arg1, float arg2, float* arg3, float* arg4, float* arg5) {
  206:     plugin::Call<0x41E2D0, CVehicle*, float, float, float*, float*, float*>(vehicle, arg1, arg2, arg3, arg4, arg5);
  207  }

  210  void CCarCtrl::SteerAICarBlockingPlayerForwardAndBack(CVehicle* vehicle, float* arg1, float* arg2, float* arg3, bool* arg4) {
  211:     plugin::Call<0x41E520, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
  212  }

  215  void CCarCtrl::SteerAICarWithPhysics(CVehicle* vehicle) {
  216:     plugin::Call<0x420580, CVehicle*>(vehicle);
  217  }

  220  void CCarCtrl::SteerAICarWithPhysicsFollowPath(CVehicle* vehicle, float* arg1, float* arg2, float* arg3, bool* arg4) {
  221:     plugin::Call<0x41EEE0, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
  222  }

  225  void CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(CVehicle* vehicle, CPhysical* arg1, float arg2, float arg3, float* arg4, float* arg5, float* arg6, bool* arg7) {
  226:     plugin::Call<0x41EAB0, CVehicle*, CPhysical*, float, float, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  227  }

  230  void CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop(CVehicle* vehicle, float arg1, float arg2, float arg3, float arg4, float* arg5, float* arg6, float* arg7, bool* arg8) {
  231:     plugin::Call<0x41E830, CVehicle*, float, float, float, float, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  232  }

  235  void CCarCtrl::SteerAICarWithPhysics_OnlyMission(CVehicle* vehicle, float* arg1, float* arg2, float* arg3, bool* arg4) {
  236:     plugin::Call<0x41FD10, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
  237  }

  240  void CCarCtrl::SteerAIHeliTowardsTargetCoors(CAutomobile* automobile) {
  241:     plugin::Call<0x41D900, CAutomobile*>(automobile);
  242  }

  245  void CCarCtrl::SteerAIPlaneTowardsTargetCoors(CAutomobile* automobile) {
  246:     plugin::Call<0x41D410, CAutomobile*>(automobile);
  247  }

  250  void CCarCtrl::SwitchVehicleToRealPhysics(CVehicle* vehicle) {
  251:     plugin::Call<0x41D2D0, CVehicle*>(vehicle);
  252  }

  255  float CCarCtrl::TestCollisionBetween2MovingRects(CVehicle* vehicle, CVehicle* arg1, float arg2, float arg3, CVector* arg4, CVector* arg5, unsigned char arg6) {
  256:     return plugin::CallAndReturn<float, 0x424210, CVehicle*, CVehicle*, float, float, CVector*, CVector*, unsigned char>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6);
  257  }

  260  void CCarCtrl::UpdateCarCount(CVehicle* vehicle, unsigned char arg1) {
  261:     plugin::Call<0x41C350, CVehicle*, unsigned char>(vehicle, arg1);
  262  }

  265  void CCarCtrl::UpdateCarOnRails(CVehicle* vehicle) {
  266:     plugin::Call<0x425BF0, CVehicle*>(vehicle);
  267  }

  270  void CCarCtrl::WeaveThroughCarsSectorList(CPtrList& ptrlist, CVehicle* vehicle, CPhysical* arg2, float arg3, float arg4, float arg5, float arg6, float* arg7, float* arg8) {
  271:     plugin::Call<0x423490, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  272  }

  275  void CCarCtrl::WeaveThroughObjectsSectorList(CPtrList& ptrlist, CVehicle* vehicle, float arg2, float arg3, float arg4, float arg5, float* arg6, float* arg7) {
  276:     plugin::Call<0x422B00, CPtrList&, CVehicle*, float, float, float, float, float*, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);
  277  }

  280  void CCarCtrl::WeaveThroughPedsSectorList(CPtrList& ptrlist, CVehicle* vehicle, CPhysical* arg2, float arg3, float arg4, float arg5, float arg6, float* arg7, float* arg8) {
  281:     plugin::Call<0x4230F0, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  282  }

plugin_vc\game_vc\CCarGenerator.cpp:
  10  bool CCarGenerator::CheckForBlockage(int modelId) {
  11:     return plugin::CallMethodAndReturn<bool, 0x5A6FC0, CCarGenerator *, int>(this, modelId);
  12  }

  15  bool CCarGenerator::CheckIfWithinRangeOfAnyPlayers() {
  16:     return plugin::CallMethodAndReturn<bool, 0x5A6D00, CCarGenerator *>(this);
  17  }

  20  void CCarGenerator::DoInternalProcessing() {
  21:     plugin::CallMethod<0x5A71C0, CCarGenerator *>(this);
  22  }

  25  void CCarGenerator::Process() {
  26:     plugin::CallMethod<0x5A7130, CCarGenerator *>(this);
  27  }

  30  unsigned int CCarGenerator::Setup(float x, float y, float z, float angle, int modelId, short primaryColor, short secondaryColor, unsigned char forceSpawn, unsigned char alarm, unsigned char doorLock, unsigned short minDelay, unsigned short maxDelay) {
  31:     return plugin::CallMethodAndReturn<unsigned int, 0x5A70B0, CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(this, x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay);
  32  }

  35  void CCarGenerator::SwitchOff() {
  36:     plugin::CallMethod<0x5A7670, CCarGenerator *>(this);
  37  }

  40  void CCarGenerator::SwitchOn() {
  41:     plugin::CallMethod<0x5A7650, CCarGenerator *>(this);
  42  }

plugin_vc\game_vc\CCivilianPed.cpp:
  10  CCivilianPed::CCivilianPed(ePedType pedType, unsigned int modelIndex) : CPed(plugin::dummy) {
  11:     plugin::CallMethod<0x4EAE00, CCivilianPed *, ePedType, unsigned int>(this, pedType, modelIndex);
  12  }

  15  void CCivilianPed::CivilianAI() {
  16:     plugin::CallMethod<0x4E8E20, CCivilianPed *>(this);
  17  }

  20  void CCivilianPed::EnterVacantNearbyCars() {
  21:     plugin::CallMethod<0x4E99C0, CCivilianPed *>(this);
  22  }

  25  void CCivilianPed::UseNearbyAttractors() {
  26:     plugin::CallMethod<0x4E9E90, CCivilianPed *>(this);
  27  }

plugin_vc\game_vc\CClock.cpp:
  24  unsigned int CClock::GetGameClockMinutesUntil(unsigned char hours, unsigned char minutes) {
  25:     return plugin::CallAndReturnDynGlobal<unsigned int, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);
  26  }

  31  bool CClock::GetIsTimeInRange(unsigned char hourA, unsigned char hourB) {
  32:     return plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);
  33  }

  38  void CClock::Initialise(unsigned int milisecondsPerGameMinute) {
  39:     plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);
  40  }

  52  void CClock::SetGameClock(unsigned char hours, unsigned char minutes) {
  53:     plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes);
  54  }

plugin_vc\game_vc\CClouds.cpp:
  10  void CClouds::Init() {
  11:     plugin::Call<0x540FB0>();
  12  }

  15  void CClouds::Render() {
  16:     plugin::Call<0x53FC50>();
  17  }

  20  void CClouds::RenderBackground(short arg0, short arg1, short arg2, short arg3, short arg4, short arg5, short arg6) {
  21:     plugin::Call<0x53F650, short, short, short, short, short, short, short>(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
  22  }

  25  void CClouds::RenderHorizon() {
  26:     plugin::Call<0x53F380>();
  27  }

  30  void CClouds::Shutdown() {
  31:     plugin::Call<0x540F40>();
  32  }

  35  void CClouds::Update() {
  36:     plugin::Call<0x540E90>();
  37  }

plugin_vc\game_vc\CClumpModelInfo.cpp:
  10  void CClumpModelInfo::SetClump(RpClump* clump) {
  11:     plugin::CallVirtualMethod<9, CClumpModelInfo *, RpClump*>(this, clump);
  12  }

  14  CClumpModelInfo::CClumpModelInfo() {
  15:     plugin::CallMethod<0x5601C0, CClumpModelInfo *>(this);
  16  }

  19  void CClumpModelInfo::FillFrameArray(RpClump* clump, RwFrame** frames) {
  20:     plugin::Call<0x541100, RpClump*, RwFrame**>(clump, frames);
  21  }

  24  RwFrame* CClumpModelInfo::FindFrameFromIdCB(RwFrame* frame, void* searchData) {
  25:     return plugin::CallAndReturn<RwFrame*, 0x541160, RwFrame*, void*>(frame, searchData);
  26  }

  29  RwFrame* CClumpModelInfo::FindFrameFromNameCB(RwFrame* frame, void* searchData) {
  30:     return plugin::CallAndReturn<RwFrame*, 0x5411E0, RwFrame*, void*>(frame, searchData);
  31  }

  34  RwFrame* CClumpModelInfo::FindFrameFromNameWithoutIdCB(RwFrame* frame, void* searchData) {
  35:     return plugin::CallAndReturn<RwFrame*, 0x541190, RwFrame*, void*>(frame, searchData);
  36  }

  39  RwFrame* CClumpModelInfo::GetFrameFromId(RpClump* clump, int id) {
  40:     return plugin::CallAndReturn<RwFrame*, 0x541120, RpClump*, int>(clump, id);
  41  }

  44  void CClumpModelInfo::SetAtomicRendererCB(RpAtomic* atomic, void* renderFunc) {
  45:     plugin::Call<0x5412A0, RpAtomic*, void*>(atomic, renderFunc);
  46  }

  49  void CClumpModelInfo::SetFrameIds(RwObjectNameIdAssocation* data) {
  50:     plugin::CallMethod<0x541090, CClumpModelInfo *, RwObjectNameIdAssocation*>(this, data);
  51  }

  54  ClumpModelStore::~ClumpModelStore() {
  55:     plugin::CallMethod<0x560190, ClumpModelStore *>(this);
  56  }

plugin_vc\game_vc\CColBox.cpp:
  10  void CColBox::Set(CVector const& sup, CVector const& inf, unsigned char material, unsigned char flags) {
  11:     plugin::CallMethod<0x4108D0, CColBox *, CVector const&, CVector const&, unsigned char, unsigned char>(this, sup, inf, material, flags);
  12  }

  15  void CColBox::operator=(CColBox const& right) {
  16:     plugin::CallMethod<0x410890, CColBox *, CColBox const&>(this, right);
  17  }

plugin_vc\game_vc\CColLine.cpp:
  10  CColLine::CColLine(CVector const& start, CVector const& end) {
  11:     plugin::CallMethod<0x410940, CColLine *, CVector const&, CVector const&>(this, start, end);
  12  }

plugin_vc\game_vc\CColModel.cpp:
  10  CColModel::CColModel() {
  11:     plugin::CallMethod<0x417120, CColModel *>(this);
  12  }

  15  void CColModel::CalculateTrianglePlanes() {
  16:     plugin::CallMethod<0x416AE0, CColModel *>(this);
  17  }

  20  int CColModel::GetLinkPtr() {
  21:     return plugin::CallMethodAndReturn<int, 0x416A70, CColModel *>(this);
  22  }

  25  int CColModel::GetTrianglePoint(CVector& arg0, int arg1) {
  26:     return plugin::CallMethodAndReturn<int, 0x416B40, CColModel *, CVector&, int>(this, arg0, arg1);
  27  }

  30  void CColModel::RemoveCollisionVolumes() {
  31:     plugin::CallMethod<0x4169B0, CColModel *>(this);
  32  }

  35  void CColModel::RemoveTrianglePlanes() {
  36:     plugin::CallMethod<0x416AB0, CColModel *>(this);
  37  }

  40  void CColModel::operator delete(void* data) {
  41:     plugin::Call<0x4170E0, void*>(data);
  42  }

  45  void* CColModel::operator new(unsigned int size) {
  46:     return plugin::CallAndReturn<void*, 0x417100, unsigned int>(size);
  47  }

  50  void CColModel::operator=(CColModel const& arg0) {
  51:     plugin::CallMethod<0x416B80, CColModel *, CColModel const&>(this, arg0);
  52  }

plugin_vc\game_vc\CColSphere.cpp:
  10  bool CColSphere::IntersectRay(CVector const& rayStart, CVector const& rayEnd, CVector& intPoint1, CVector& intPoint2) {
  11:     return plugin::CallMethodAndReturn<bool, 0x417260, CColSphere *, CVector const&, CVector const&, CVector&, CVector&>(this, rayStart, rayEnd, intPoint1, intPoint2);
  12  }

  15  void CColSphere::Set(float radius, CVector const& center, unsigned char material, unsigned char flags) {
  16:     plugin::CallMethod<0x4173A0, CColSphere *, float, CVector const&, unsigned char, unsigned char>(this, radius, center, material, flags);
  17  }

plugin_vc\game_vc\CControllerState.cpp:
  14  bool CControllerState::CheckForInput() {
  15:     return plugin::CallMethodAndReturnDynGlobal<bool, CControllerState *>(gaddrof(CControllerState::CheckForInput), this);
  16  }

plugin_vc\game_vc\CCopPed.cpp:
  10  void CCopPed::ArrestPlayer() {
  11:     plugin::CallMethod<0x4EB470, CCopPed *>(this);
  12  }

  15  CCopPed::CCopPed(eCopType copType, int arg1) : CPed(plugin::dummy) {
  16:     plugin::CallMethod<0x4ED720, CCopPed *, eCopType, int>(this, copType, arg1);
  17  }

  20  void CCopPed::ClearPursuit() {
  21:     plugin::CallMethod<0x4EB770, CCopPed *>(this);
  22  }

  25  void CCopPed::CopAI() {
  26:     plugin::CallMethod<0x4EBC10, CCopPed *>(this);
  27  }

  30  void CCopPed::ProcessHeliSwat() {
  31:     plugin::CallMethod<0x4EB280, CCopPed *>(this);
  32  }

  35  void CCopPed::ProcessStingerCop() {
  36:     plugin::CallMethod<0x4EB010, CCopPed *>(this);
  37  }

  40  int CCopPed::ScanForCrimes() {
  41:     return plugin::CallMethodAndReturn<int, 0x4EBAD0, CCopPed *>(this);
  42  }

  45  void CCopPed::SetArrestPlayer(CPed* ped) {
  46:     plugin::CallMethod<0x4EB5F0, CCopPed *, CPed*>(this, ped);
  47  }

  50  void CCopPed::SetPursuit(bool arg0) {
  51:     plugin::CallMethod<0x4EB9C0, CCopPed *, bool>(this, arg0);
  52  }

plugin_vc\game_vc\CCoronas.cpp:
  18  void CCoronas::DoSunAndMoon() {
  19:     plugin::Call<0x542210>();
  20  }

  23  void CCoronas::UpdateCoronaCoors(unsigned int id, CVector const& posn, float farClip, float angle) {
  24:     plugin::Call<0x5423E0, unsigned int, CVector const&, float, float>(id, posn, farClip, angle);
  25  }

  28  void CCoronas::RegisterCorona(unsigned int coronaId, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, CVector const& pos, float radius, float farClip, RwTexture* texture, unsigned char flare, unsigned char reflection, unsigned char arg11, unsigned char arg12, float normalAngle, bool arg14, float arg15) {
  29:     plugin::Call<0x542490, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, RwTexture*, unsigned char, unsigned char, unsigned char, unsigned char, float, bool, float>(coronaId, red, green, blue, alpha, pos, radius, farClip, texture, flare, reflection, arg11, arg12, normalAngle, arg14, arg15);
  30  }

  33  void CCoronas::RegisterCorona(unsigned int coronaId, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, CVector const& pos, float radius, float farClip, unsigned char arg8, unsigned char flare, unsigned char reflection, unsigned char arg11, unsigned char arg12, float normalAngle, bool arg14, float arg15) {
  34:     plugin::Call<0x5427A0, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float, bool, float>(coronaId, red, green, blue, alpha, pos, radius, farClip, arg8, flare, reflection, arg11, arg12, normalAngle, arg14, arg15);
  35  }

  38  void CCoronas::Shutdown() {
  39:     plugin::Call<0x542800>();
  40  }

  43  void CCoronas::Init() {
  44:     plugin::Call<0x542830>();
  45  }

  48  void CCoronas::RenderSunReflection() {
  49:     plugin::Call<0x542970>();
  50  }

  53  void CCoronas::RenderReflections() {
  54:     plugin::Call<0x542FF0>();
  55  }

  58  void CCoronas::Render() {
  59:     plugin::Call<0x543500>();
  60  }

  63  void CCoronas::Update() {
  64:     plugin::Call<0x544130>();
  65  }

plugin_vc\game_vc\CCranes.cpp:
  14  int CCranes::AddThisOneCrane(CEntity *pEnity) {
  15:     return plugin::CallAndReturnDynGlobal<int, CEntity *>(gaddrof(CCranes::AddThisOneCrane), pEnity);
  16  }

  21  bool CCranes::DoesMilitaryCraneHaveThisOneAlready(unsigned short arg1) {
  22:     return plugin::CallAndReturnDynGlobal<bool, unsigned short>(gaddrof(CCranes::DoesMilitaryCraneHaveThisOneAlready), arg1);
  23  }

  35  bool CCranes::IsThisCarBeingCarriedByAnyCrane(CVehicle *pVehicle) {
  36:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingCarriedByAnyCrane), pVehicle);
  37  }

  42  bool CCranes::IsThisCarBeingTargettedByAnyCrane(CVehicle *pVehicle) {
  43:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingTargettedByAnyCrane), pVehicle);
  44  }

  49  void CCranes::RegisterCarForMilitaryCrane(unsigned short arg1) {
  50:     plugin::CallDynGlobal<unsigned short>(gaddrof(CCranes::RegisterCarForMilitaryCrane), arg1);
  51  }

plugin_vc\game_vc\CCutsceneObject.cpp:
  10  CCutsceneObject::CCutsceneObject() {
  11:     plugin::CallMethod<0x4E04D0, CCutsceneObject *>(this);
  12  }

  15  void CCutsceneObject::CreateShadow() {
  16:     plugin::CallMethod<0x4E03E0, CCutsceneObject *>(this);
  17  }

plugin_vc\game_vc\CCutsceneShadow.cpp:
  20  bool CCutsceneShadow::Create(RwObject *object, int rasterSize, bool resample, int blurPasses, bool gradient) {
  21:     return plugin::CallMethodAndReturnDynGlobal<bool, CCutsceneShadow *, RwObject *, int, bool, int, bool>(gaddrof(CCutsceneShadow::Create), this, object, rasterSize, resample, blurPasses, gradient);
  22  }

  27  void CCutsceneShadow::DrawBorderAroundTexture(RwRGBA const &color) {
  28:     plugin::CallMethodDynGlobal<CCutsceneShadow *, RwRGBA const &>(gaddrof(CCutsceneShadow::DrawBorderAroundTexture), this, color);
  29  }

  34  CShadowCamera *CCutsceneShadow::GetShadowCamera(int camType) {
  35:     return plugin::CallMethodAndReturnDynGlobal<CShadowCamera *, CCutsceneShadow *, int>(gaddrof(CCutsceneShadow::GetShadowCamera), this, camType);
  36  }

  41  RwTexture *CCutsceneShadow::GetShadowRwTexture() {
  42:     return plugin::CallMethodAndReturnDynGlobal<RwTexture *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::GetShadowRwTexture), this);
  43  }

  48  bool CCutsceneShadow::IsInitialized() {
  49:     return plugin::CallMethodAndReturnDynGlobal<bool, CCutsceneShadow *>(gaddrof(CCutsceneShadow::IsInitialized), this);
  50  }

  55  RwFrame *CCutsceneShadow::SetLightProperties(float angleY, float angleX, bool setLight) {
  56:     return plugin::CallMethodAndReturnDynGlobal<RwFrame *, CCutsceneShadow *, float, float, bool>(gaddrof(CCutsceneShadow::SetLightProperties), this, angleY, angleX, setLight);
  57  }

  62  RwRaster *CCutsceneShadow::Update() {
  63:     return plugin::CallMethodAndReturnDynGlobal<RwRaster *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::Update), this);
  64  }

  69  RwTexture *CCutsceneShadow::UpdateForCutscene() {
  70:     return plugin::CallMethodAndReturnDynGlobal<RwTexture *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::UpdateForCutscene), this);
  71  }

plugin_vc\game_vc\CDamageManager.cpp:
  10  bool CDamageManager::ApplyDamage(tComponent component, float intensity, float arg2) {
  11:     return plugin::CallMethodAndReturn<bool, 0x5A9650, CDamageManager *, tComponent, float, float>(this, component, intensity, arg2);
  12  }

  15  void CDamageManager::FuckCarCompletely() {
  16:     plugin::CallMethod<0x5A9600, CDamageManager *>(this);
  17  }

  20  bool CDamageManager::GetComponentGroup(tComponent component, tComponentGroup* group, unsigned char* damageCompId) {
  21:     return plugin::CallMethodAndReturn<bool, 0x5A98D0, CDamageManager *, tComponent, tComponentGroup*, unsigned char*>(this, component, group, damageCompId);
  22  }

  25  unsigned int CDamageManager::GetDoorStatus(eDoors door) {
  26:     return plugin::CallMethodAndReturn<unsigned int, 0x5A9810, CDamageManager *, eDoors>(this, door);
  27  }

  30  unsigned int CDamageManager::GetEngineStatus() {
  31:     return plugin::CallMethodAndReturn<unsigned int, 0x5A97E0, CDamageManager *>(this);
  32  }

  35  unsigned int CDamageManager::GetLightStatus(eLights light) {
  36:     return plugin::CallMethodAndReturn<unsigned int, 0x5A9870, CDamageManager *, eLights>(this, light);
  37  }

  40  unsigned int CDamageManager::GetPanelStatus(ePanels panel) {
  41:     return plugin::CallMethodAndReturn<unsigned int, 0x5A9850, CDamageManager *, ePanels>(this, panel);
  42  }

  45  unsigned int CDamageManager::GetWheelStatus(int wheel) {
  46:     return plugin::CallMethodAndReturn<unsigned int, 0x5A9830, CDamageManager *, int>(this, wheel);
  47  }

  50  bool CDamageManager::ProgressPanelDamage(unsigned char panel) {
  51:     return plugin::CallMethodAndReturn<bool, 0x5A9790, CDamageManager *, unsigned char>(this, panel);
  52  }

  55  void CDamageManager::ResetDamageStatus() {
  56:     plugin::CallMethod<0x5A9890, CDamageManager *>(this);
  57  }

  60  void CDamageManager::SetDoorStatus(eDoors door, unsigned int status) {
  61:     plugin::CallMethod<0x5A9820, CDamageManager *, eDoors, unsigned int>(this, door, status);
  62  }

  65  void CDamageManager::SetEngineStatus(unsigned int status) {
  66:     plugin::CallMethod<0x5A97F0, CDamageManager *, unsigned int>(this, status);
  67  }

  70  void CDamageManager::SetWheelStatus(int wheel, unsigned int status) {
  71:     plugin::CallMethod<0x5A9840, CDamageManager *, int, unsigned int>(this, wheel, status);
  72  }

plugin_vc\game_vc\CDarkel.cpp:
  30  void CDarkel::DealWithWeaponChangeAtEndOfFrenzy() {
  31:     plugin::Call<0x429910>();
  32  }

  35  void CDarkel::DrawMessages() {
  36:     plugin::Call<0x429FE0>();
  37  }

  40  bool CDarkel::FrenzyOnGoing() {
  41:     return plugin::CallAndReturn<bool, 0x429FC0>();
  42  }

  45  void CDarkel::Init() {
  46:     plugin::Call<0x42A7A0>();
  47  }

  50  short CDarkel::QueryModelsKilledByPlayer(int arg0) {
  51:     return plugin::CallAndReturn<short, 0x429AF0, int>(arg0);
  52  }

  55  short CDarkel::ReadStatus() {
  56:     return plugin::CallAndReturn<short, 0x429FD0>();
  57  }

  60  int CDarkel::RegisterCarBlownUpByPlayer(CVehicle* vehicle) {
  61:     return plugin::CallAndReturn<int, 0x429DF0, CVehicle*>(vehicle);
  62  }

  65  void CDarkel::RegisterKillByPlayer(CPed* ped, eWeaponType weaponType, bool arg2) {
  66:     plugin::Call<0x429E90, CPed*, eWeaponType, bool>(ped, weaponType, arg2);
  67  }

  70  void CDarkel::RegisterKillNotByPlayer(CPed* arg0, eWeaponType weaponType) {
  71:     plugin::Call<0x429E80, CPed*, eWeaponType>(arg0, weaponType);
  72  }

  75  void CDarkel::ResetModelsKilledByPlayer() {
  76:     plugin::Call<0x429B00>();
  77  }

  80  void CDarkel::ResetOnPlayerDeath() {
  81:     plugin::Call<0x429F90>();
  82  }

  85  void CDarkel::StartFrenzy(eWeaponType weaponType, int arg1, unsigned short arg2, int arg3, unsigned short* arg4, int arg5, int arg6, int arg7, bool arg8, bool arg9) {
  86:     plugin::Call<0x429B60, eWeaponType, int, unsigned short, int, unsigned short*, int, int, int, bool, bool>(weaponType, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
  87  }

  90  void CDarkel::Update() {
  91:     plugin::Call<0x42A650>();
  92  }

plugin_vc\game_vc\CDirectory.cpp:
  20  void CDirectory::AddItem(const CDirectory::DirectoryInfo *entry) {
  21:     plugin::CallMethodDynGlobal<CDirectory *, const CDirectory::DirectoryInfo *>(gaddrof(CDirectory::AddItem), this, entry);
  22  }

  27  bool CDirectory::FindItem(char const *name, unsigned int *outOffset, unsigned int *outSize) {
  28:     return plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *, unsigned int *, unsigned int *>(gaddrof(CDirectory::FindItem), this, name, outOffset, outSize);
  29  }

  34  void CDirectory::ReadDirFile(char const *filename) {
  35:     plugin::CallMethodDynGlobal<CDirectory *, char const *>(gaddrof(CDirectory::ReadDirFile), this, filename);
  36  }

  41  bool CDirectory::WriteDirFile(char const *filename) {
  42:     return plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *>(gaddrof(CDirectory::WriteDirFile), this, filename);
  43  }

plugin_vc\game_vc\cDMAudio.cpp:
  11  void cDMAudio::PlayFrontEndSound(unsigned short frontend, unsigned int volume) {
  12:     plugin::CallMethod<0x5F9960, cDMAudio*, unsigned short, unsigned int>(this, frontend, volume);
  13  }

  15  void cDMAudio::PlayLoadedMissionAudio(unsigned char slot) {
  16:     plugin::CallMethod<0x5F97B0, cDMAudio*, unsigned char>(this, slot);
  17  }

  19  void cDMAudio::ClearMissionAudio(unsigned char slot) {
  20:     plugin::CallMethod<0x5F9770, cDMAudio*, unsigned char>(this, slot);
  21  }

  23  void cDMAudio::PreloadMissionAudio(unsigned char slot, const char* missionAudio) {
  24:     plugin::CallMethod<0x5F9820, cDMAudio*, unsigned char, const char*>(this, slot, missionAudio);
  25  }

  27  void cDMAudio::PlayOneShot(int audioEntity, unsigned short shot, float volume) {
  28:     plugin::CallMethod<0x5F9DA0, cDMAudio*, int, unsigned short, float>(this, audioEntity, shot, volume);
  29  }

  31  void cDMAudio::SetRadioInCar(unsigned int radio) {
  32:     plugin::CallMethod<0x5F9730, cDMAudio*, unsigned int>(this, radio);
  33  }

  35  void cDMAudio::PlayFrontEndTrack(unsigned int track, char flag) {
  36:     plugin::CallMethod<0x5F9910, cDMAudio*, unsigned int, char>(this, track, flag);
  37  }

  39  void cDMAudio::StopFrontEndTrack() {
  40:     plugin::CallMethod<0x5F98F0, cDMAudio*>(this);
  41  }

  43  bool cDMAudio::IsMP3RadioChannelAvailable() {
  44:    return plugin::CallMethodAndReturn<bool, 0x5F9BB0, cDMAudio*>(this);
  45  }

plugin_vc\game_vc\CDraw.cpp:
  32  void CDraw::CalculateAspectRatio() {
  33:     plugin::Call<0x54A270>();
  34  }

  37  void CDraw::SetFOV(float fov) {
  38:     plugin::Call<0x54A2E0, float>(fov);
  39  }

plugin_vc\game_vc\CEmergencyPed.cpp:
  10  CEmergencyPed::CEmergencyPed(unsigned int emergencyType) : CPed(plugin::dummy) {
  11:     plugin::CallMethod<0x4EEB40, CEmergencyPed *, unsigned int>(this, emergencyType);
  12  }

  15  void CEmergencyPed::FiremanAI() {
  16:     plugin::CallMethod<0x4EDA80, CEmergencyPed *>(this);
  17  }

  20  void CEmergencyPed::MedicAI() {
  21:     plugin::CallMethod<0x4EDC90, CEmergencyPed *>(this);
  22  }

plugin_vc\game_vc\CEscalators.cpp:
  12  void CEscalators::AddOne(CVector const& arg0, CVector const& arg1, CVector const& arg2, CVector const& arg3, bool arg4) {
  13:     plugin::CallMethod<0x54B0A0, CEscalators *, CVector const&, CVector const&, CVector const&, CVector const&, bool>(this, arg0, arg1, arg2, arg3, arg4);
  14  }

  17  void CEscalators::Init() {
  18:     plugin::Call<0x54B460>();
  19  }

  22  void CEscalators::Shutdown() {
  23:     plugin::Call<0x54B3A0>();
  24  }

  27  void CEscalators::Update() {
  28:     plugin::CallMethod<0x54A9B0, CEscalators *>(this);
  29  }

plugin_vc\game_vc\CFileLoader.cpp:
   9  RpClump* CFileLoader::LoadAtomicFile2Return(const char* file) {
  10:     return plugin::CallAndReturn<RpClump*, 0x48D7C0, const char*>(file);
  11  }

plugin_vc\game_vc\CFileMgr.cpp:
  13  int CFileMgr::GetErrorReadWrite(int fileHandle) {
  14:     return plugin::CallAndReturn<int, 0x48DE90, int>(fileHandle);
  15  }

  18  int CFileMgr::CloseFile(int fileHandle) {
  19:     return plugin::CallAndReturn<int, 0x48DEA0, int>(fileHandle);
  20  }

  23  bool CFileMgr::ReadLine(int fileHandle, char* buffer, int maxSize) {
  24:     return plugin::CallAndReturn<bool, 0x48DEB0, int, char*, int>(fileHandle, buffer, maxSize);
  25  }

  28  bool CFileMgr::Seek(int fileHandle, int offset, int origin) {
  29:     return plugin::CallAndReturn<bool, 0x48DEE0, int, int, int>(fileHandle, offset, origin);
  30  }

  33  int CFileMgr::Write(int fileHandle, char* buffer, int size) {
  34:     return plugin::CallAndReturn<int, 0x48DF30, int, char*, int>(fileHandle, buffer, size);
  35  }

  38  int CFileMgr::Read(int fileHandle, char* buffer, int size) {
  39:     return plugin::CallAndReturn<int, 0x48DF50, int, char*, int>(fileHandle, buffer, size);
  40  }

  43  int CFileMgr::OpenFileForWriting(char const* filepath) {
  44:     return plugin::CallAndReturn<int, 0x48DF70, char const*>(filepath);
  45  }

  48  int CFileMgr::OpenFile(char const* filepath, char const* mode) {
  49:     return plugin::CallAndReturn<int, 0x48DF90, char const*, char const*>(filepath, mode);
  50  }

  53  int CFileMgr::LoadFile(char const* filepath, unsigned char* buffer, int size, char const* mode) {
  54:     return plugin::CallAndReturn<int, 0x48DFB0, char const*, unsigned char*, int, char const*>(filepath, buffer, size, mode);
  55  }

  58  void CFileMgr::SetDirMyDocuments() {
  59:     plugin::Call<0x48E020>();
  60  }

  63  void CFileMgr::SetDir(char const* dir) {
  64:     plugin::Call<0x48E030, char const*>(dir);
  65  }

  68  void CFileMgr::ChangeDir(char const* dir) {
  69:     plugin::Call<0x48E090, char const*>(dir);
  70  }

  73  void CFileMgr::Initialise() {
  74:     plugin::Call<0x48E100>();
  75  }

plugin_vc\game_vc\CFont.cpp:
   14  short CFont::character_code(unsigned char character) {
   15:     return plugin::CallAndReturn<short, 0x54FE50, unsigned char>(character);
   16  }

   19  int CFont::FindNewCharacter(short character) {
   20:     return plugin::CallAndReturn<int, 0x54FE70, short>(character);
   21  }

   24  void CFont::SetDropShadowPosition(short position) {
   25:     plugin::Call<0x54FF20, short>(position);
   26  }

   29  void CFont::SetDropColor(CRGBA color) {
   30:     plugin::Call<0x54FF30, CRGBA *>(&color);
   31  }

   34  void CFont::SetAlphaFade(float fade) {
   35:     plugin::Call<0x54FFC0, float>(fade);
   36  }

   39  void CFont::SetRightJustifyWrap(float wrap) {
   40:     plugin::Call<0x54FFD0, float>(wrap);
   41  }

   44  void CFont::SetFontStyle(short style) {
   45:     plugin::Call<0x54FFE0, short>(style);
   46  }

   49  void CFont::SetPropOn() {
   50:     plugin::Call<0x550020>();
   51  }

   54  void CFont::SetPropOff() {
   55:     plugin::Call<0x550030>();
   56  }

   59  void CFont::SetRightJustifyOff() {
   60:     plugin::Call<0x550040>();
   61  }

   64  void CFont::SetRightJustifyOn() {
   65:     plugin::Call<0x550060>();
   66  }

   69  void CFont::SetBackGroundOnlyTextOff() {
   70:     plugin::Call<0x550080>();
   71  }

   74  void CFont::SetBackGroundOnlyTextOn() {
   75:     plugin::Call<0x550090>();
   76  }

   79  void CFont::SetBackgroundColor(CRGBA color) {
   80:     plugin::Call<0x5500A0, CRGBA *>(&color);
   81  }

   84  void CFont::SetBackgroundOff() {
   85:     plugin::Call<0x5500D0>();
   86  }

   89  void CFont::SetBackgroundOn() {
   90:     plugin::Call<0x5500E0>();
   91  }

   94  void CFont::SetCentreSize(float size) {
   95:     plugin::Call<0x5500F0, float>(size);
   96  }

   99  void CFont::SetWrapx(float wrap) {
  100:     plugin::Call<0x550100, float>(wrap);
  101  }

  104  void CFont::SetCentreOff() {
  105:     plugin::Call<0x550110>();
  106  }

  109  void CFont::SetCentreOn() {
  110:     plugin::Call<0x550120>();
  111  }

  114  void CFont::SetJustifyOff() {
  115:     plugin::Call<0x550140>();
  116  }

  119  void CFont::SetJustifyOn() {
  120:     plugin::Call<0x550150>();
  121  }

  124  void CFont::SetColor(CRGBA color) {
  125:     plugin::Call<0x550170, CRGBA *>(&color);
  126  }

  129  void CFont::SetSlant(float slant) {
  130:     plugin::Call<0x550200, float>(slant);
  131  }

  134  void CFont::SetSlantRefPoint(float x, float y) {
  135:     plugin::Call<0x550210, float, float>(x, y);
  136  }

  139  void CFont::SetScale(float width, float height) {
  140:     plugin::Call<0x550230, float, float>(width, height);
  141  }

  144  void CFont::DrawFonts() {
  145:     plugin::Call<0x550250>();
  146  }

  149  void CFont::FilterOutTokensFromString(const wchar_t* str) {
  150:     plugin::Call<0x550260, const wchar_t*>(str);
  151  }

  154  wchar_t* CFont::ParseToken(wchar_t* str) {
  155:     return plugin::CallAndReturn<wchar_t*, 0x5502D0, wchar_t*>(str);
  156  }

  159  wchar_t* CFont::ParseToken(wchar_t* str, CRGBA& color, bool& flashing, bool& bold) {
  160:     return plugin::CallAndReturn<wchar_t*, 0x550510, wchar_t*, CRGBA&, bool&, bool&>(str, color, flashing, bold);
  161  }

  164  float CFont::GetStringWidth(const wchar_t* str, bool sentence) {
  165:     return plugin::CallAndReturn<float, 0x550650, const wchar_t*, bool>(str, sentence);
  166  }

  169  void CFont::GetTextRect(CRect* rect_out, float x, float y, const wchar_t* text) {
  170:     plugin::Call<0x550720, CRect*, float, float, const wchar_t*>(rect_out, x, y, text);
  171  }

  174  int CFont::GetNumberLines(float x, float y, const wchar_t* text) {
  175:     return plugin::CallAndReturn<int, 0x550C70, float, float, const wchar_t*>(x, y, text);
  176  }

  179  void CFont::PrintString(float x, float y, const wchar_t* text) {
  180:     plugin::Call<0x551040, float, float, const wchar_t*>(x, y, text);
  181  }

  184  void CFont::PrintStringFromBottom(float x, float y, const wchar_t* text) {
  185:     plugin::Call<0x551620, float, float, const wchar_t*>(x, y, text);
  186  }

  189  void CFont::PrintString(float x, float y, unsigned int arg2, const wchar_t* arg3, const wchar_t* arg4, float arg5) {
  190:     plugin::Call<0x5516C0, float, float, unsigned int, const wchar_t*, const wchar_t*, float>(x, y, arg2, arg3, arg4, arg5);
  191  }

  194  void CFont::RenderFontBuffer() {
  195:     plugin::Call<0x551A30>();
  196  }

  199  void CFont::PrintChar(float x, float y, short character) {
  200:     plugin::Call<0x551E70, float, float, short>(x, y, character);
  201  }

  204  void CFont::InitPerFrame() {
  205:     plugin::Call<0x5522B0>();
  206  }

  209  void CFont::Shutdown() {
  210:     plugin::Call<0x5522E0>();
  211  }

  214  void CFont::Initialise() {
  215:     plugin::Call<0x552310>();
  216  }

  219  void UnicodeMakeUpperCase(wchar_t* str_out, wchar_t const* str_in) {
  220:     plugin::Call<0x552470, wchar_t*, wchar_t const*>(str_out, str_in);
  221  }

  224  int UnicodeStrlen(wchar_t const* str) {
  225:     return plugin::CallAndReturn<int, 0x5524B0, wchar_t const*>(str);
  226  }

  229  void AsciiToUnicode(char const* str_ascii, wchar_t* str_unicode) {
  230:     plugin::Call<0x552500, char const*, wchar_t*>(str_ascii, str_unicode);
  231  }

plugin_vc\game_vc\CGame.cpp:
   26  bool CGame::CanSeeOutSideFromCurrArea() {
   27:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeOutSideFromCurrArea));
   28  }

   33  bool CGame::CanSeeWaterFromCurrArea() {
   34:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeWaterFromCurrArea));
   35  }

   61  bool CGame::Initialise(char const *datFile) {
   62:     return plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);
   63  }

   68  bool CGame::InitialiseOnceAfterRW() {
   69:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceAfterRW));
   70  }

   75  bool CGame::InitialiseOnceBeforeRW() {
   76:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));
   77  }

   82  bool CGame::InitialiseRenderWare() {
   83:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));
   84  }

  117  bool CGame::Shutdown() {
  118:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));
  119  }

  131  void CGame::TidyUpMemory(bool a1, bool clearD3Dmem) {
  132:     plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), a1, clearD3Dmem);
  133  }

  145  RsEventStatus AppEventHandler(RsEvent event, void *param) {
  146:     return plugin::CallAndReturnDynGlobal<RsEventStatus, RsEvent, void *>(gaddrof(AppEventHandler), event, param);
  147  }

  152  bool InitialiseGame() {
  153:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(InitialiseGame));
  154  }

  166  void Idle(void *param) {
  167:     plugin::CallDynGlobal<void *>(gaddrof(Idle), param);
  168  }

  201  void LoadingScreen(char const *title, char const *message, char const *screenName) {
  202:     plugin::CallDynGlobal<char const *, char const *, char const *>(gaddrof(LoadingScreen), title, message, screenName);
  203  }

  215  char const *GetLevelSplashScreen(int screenId) {
  216:     return plugin::CallAndReturnDynGlobal<char const *, int>(gaddrof(GetLevelSplashScreen), screenId);
  217  }

  222  char const *GetRandomSplashScreen() {
  223:     return plugin::CallAndReturnDynGlobal<char const *>(gaddrof(GetRandomSplashScreen));
  224  }

  236  CSprite2d *LoadSplash(char const *splashName) {
  237:     return plugin::CallAndReturnDynGlobal<CSprite2d *, char const *>(gaddrof(LoadSplash), splashName);
  238  }

  243  bool PluginAttach() {
  244:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(PluginAttach));
  245  }

  264  bool DoRWStuffStartOfFrame(short topR, short topG, short topB, short bottomR, short bottomG, short bottomB, short alpha) {
  265:     return plugin::CallAndReturnDynGlobal<bool, short, short, short, short, short, short, short>(gaddrof(DoRWStuffStartOfFrame), topR, topG, topB, bottomR, bottomG, bottomB, alpha);
  266  }

  278  void MatchModelString(char *modelName, int modelIndex) {
  279:     plugin::CallDynGlobal<char *, int>(gaddrof(MatchModelString), modelName, modelIndex);
  280  }

plugin_vc\game_vc\CGameLogic.cpp:
  10  void CGameLogic::InitAtStartOfGame() {
  11:     plugin::Call<0x42C480>();
  12  }

  15  void CGameLogic::Update() {
  16:     plugin::Call<0x42BB70>();
  17  }

  20  void CGameLogic::RestorePlayerStuffDuringResurrection(CPlayerPed* arg1, CVector arg2, float arg3) {
  21:     plugin::Call<0x42B900, CPlayerPed*, CVector, float>(arg1, arg2, arg3);
  22  }

  25  void CGameLogic::ClearShortCut() {
  26:     plugin::Call<0x42B730>();
  27  }

  30  void CGameLogic::UpdateShortCut() {
  31:     plugin::Call<0x42AE70>();
  32  }

  35  void CGameLogic::AfterDeathArrestSetUpShortCutTaxi() {
  36:     plugin::Call<0x42AC10>();
  37  }

  40  void CGameLogic::RemoveShortCutDropOffPointForMission() {
  41:     plugin::Call<0x42ADE0>();
  42  }

plugin_vc\game_vc\CGangs.cpp:
  15  void CGangs::SetWillAttackPlayerWithCops(ePedType pedtype, bool bAttackPlayerWithCops) {
  16:     plugin::Call<0x4EEF30, ePedType, bool>(pedtype, bAttackPlayerWithCops);
  17  }

  20  void CGangs::SetGangWeapons(short gangId, int weapon1_Id, int weapon2_Id) {
  21:     plugin::Call<0x4EED70, short, int, int>(gangId, weapon1_Id, weapon2_Id);
  22  }

  25  void CGangs::SetGangVehicleModel(short gangId, int vehicleModelId) {
  26:     plugin::Call<0x4EEDD0, short, int>(gangId, vehicleModelId);
  27  }

  30  void CGangs::SetGangPedModels(short gangId, int pedModel1_Id, int pedModel2_Id) {
  31:     plugin::Call<0x4EEDA0, short, int, int>(gangId, pedModel1_Id, pedModel2_Id);
  32  }

  35  void CGangs::SaveAllGangData(unsigned char* arg0, unsigned int* arg1) {
  36:     plugin::Call<0x4EECA0, unsigned char*, unsigned int*>(arg0, arg1);
  37  }

  40  void CGangs::Initialise() {
  41:     plugin::Call<0x4EEDF0>();
  42  }

  45  int CGangs::ChooseGangPedModel(short gangId) {
  46:     return plugin::CallAndReturn<int, 0x4EED20, short>(gangId);
  47  }

  50  bool CGangs::GetWillAttackPlayerWithCops(ePedType pedtype) {
  51:     return plugin::CallAndReturn<bool, 0x18BB48, ePedType>(pedtype);
  52  }

plugin_vc\game_vc\CGeneral.cpp:
  14  float CGeneral::GetATanOfXY(float x, float y) {
  15:     return plugin::CallAndReturnDynGlobal<float, float, float>(gaddrof(CGeneral::GetATanOfXY), x, y);
  16  }

  21  float CGeneral::GetAngleBetweenPoints(float x1, float y1, float x2, float y2) {
  22:     return plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetAngleBetweenPoints), x1, y1, x2, y2);
  23  }

  28  int CGeneral::GetNodeHeadingFromVector(float x, float y) {
  29:     return plugin::CallAndReturnDynGlobal<int, float, float>(gaddrof(CGeneral::GetNodeHeadingFromVector), x, y);
  30  }

  35  float CGeneral::GetRadianAngleBetweenPoints(float x1, float y1, float x2, float y2) {
  36:     return plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetRadianAngleBetweenPoints), x1, y1, x2, y2);
  37  }

  42  float CGeneral::LimitAngle(float angle) {
  43:     return plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitAngle), angle);
  44  }

  49  float CGeneral::LimitRadianAngle(float angle) {
  50:     return plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitRadianAngle), angle);
  51  }

  56  unsigned char CGeneral::SolveQuadratic(float a, float b, float c, float &x1, float &x2) {
  57:     return plugin::CallAndReturnDynGlobal<unsigned char, float, float, float, float &, float &>(gaddrof(CGeneral::SolveQuadratic), a, b, c, x1, x2);
  58  }

plugin_vc\game_vc\cHandlingDataMgr.cpp:
  12  cHandlingDataMgr::cHandlingDataMgr() {
  13:     plugin::CallMethod<0x5ABDC0, cHandlingDataMgr *>(this);
  14  }

  17  void cHandlingDataMgr::ConvertDataToGameUnits(tHandlingData* handling) {
  18:     plugin::CallMethod<0x5ABAA0, cHandlingDataMgr *, tHandlingData*>(this, handling);
  19  }

  22  int cHandlingDataMgr::FindExactWord(char* line, char* nameTable, int entrySize, int entryCount) {
  23:     return plugin::CallMethodAndReturn<int, 0x5ABD30, cHandlingDataMgr *, char*, char*, int, int>(this, line, nameTable, entrySize, entryCount);
  24  }

  27  tBoatHandlingData* cHandlingDataMgr::GetBoatPointer(unsigned char handlingId) {
  28:     return plugin::CallMethodAndReturn<tBoatHandlingData*, 0x5ABA40, cHandlingDataMgr *, unsigned char>(this, handlingId);
  29  }

  32  tFlyingHandlingData* cHandlingDataMgr::GetFlyingPointer(unsigned char handlingId) {
  33:     return plugin::CallMethodAndReturn<tFlyingHandlingData*, 0x5ABA70, cHandlingDataMgr *, unsigned char>(this, handlingId);
  34  }

  37  int cHandlingDataMgr::GetHandlingId(char const* name) {
  38:     return plugin::CallMethodAndReturn<int, 0x5ABCC0, cHandlingDataMgr *, char const*>(this, name);
  39  }

  42  void cHandlingDataMgr::Initialise() {
  43:     plugin::CallMethod<0x5ABA10, cHandlingDataMgr *>(this);
  44  }

  47  void cHandlingDataMgr::LoadHandlingData() {
  48:     plugin::CallMethod<0x5AAE20, cHandlingDataMgr *>(this);
  49  }

plugin_vc\game_vc\CHeli.cpp:
  16  CHeli::CHeli(int modelIndex, unsigned char createdBy) : CVehicle(plugin::dummy) {
  17:     plugin::CallMethod<0x5AF7F0, CHeli *, int, unsigned char>(this, modelIndex, createdBy);
  18  }

  21  void CHeli::InitHelis() {
  22:     plugin::Call<0x5AD4A0>();
  23  }

  26  void CHeli::PreRenderAlways() {
  27:     plugin::CallMethod<0x5AF2E0, CHeli *>(this);
  28  }

  31  bool CHeli::SendDownSwat() {
  32:     return plugin::CallMethodAndReturn<bool, 0x5ABE20, CHeli *>(this);
  33  }

  36  CObject* CHeli::SpawnFlyingComponent(int nodeIndex) {
  37:     return plugin::CallMethodAndReturn<CObject*, 0x5AC1E0, CHeli *, int>(this, nodeIndex);
  38  }

  41  bool CHeli::SpecialHeliPreRender() {
  42:     return plugin::CallAndReturn<bool, 0x5AC500>();
  43  }

  46  bool CHeli::TestBulletCollision(CVector* arg0, CVector* arg1, CVector* arg2, int arg3) {
  47:     return plugin::CallAndReturn<bool, 0x5AC6C0, CVector*, CVector*, CVector*, int>(arg0, arg1, arg2, arg3);
  48  }

  51  bool CHeli::TestRocketCollision(CVector* arg0) {
  52:     return plugin::CallAndReturn<bool, 0x5AC9A0, CVector*>(arg0);
  53  }

  56  bool CHeli::TestSniperCollision(CVector* origin, CVector* target) {
  57:     return plugin::CallAndReturn<bool, 0x5AC520, CVector*, CVector*>(origin, target);
  58  }

  61  void CHeli::UpdateHelis() {
  62:     plugin::Call<0x5ACDA0>();
  63  }

  66  void GenerateHeli(bool enable) {
  67:     plugin::Call<0x5ACB30, bool>(enable);
  68  }

  71  void StartCatalinaFlyBy() {
  72:     plugin::Call<0x5ACAF0>();
  73  }

  76  RwObject* GetHeliAtomicObjectCB(RwObject* object, void* data) {
  77:     return plugin::CallAndReturn<RwObject*, 0x5AC4E0, RwObject*, void*>(object, data);
  78  }

plugin_vc\game_vc\CHud.cpp:
   91  void CHud::DrawFadeState(DRAW_FADE_STATE fadeState, int a2) {
   92:     plugin::CallDynGlobal<DRAW_FADE_STATE, int>(gaddrof(CHud::DrawFadeState), fadeState, a2);
   93  }

  112  bool CHud::IsHelpMessageBeingDisplayed() {
  113:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CHud::IsHelpMessageBeingDisplayed));
  114  }

  133  void CHud::SetBigMessage(wchar_t const *message, unsigned short style) {
  134:     plugin::CallDynGlobal<wchar_t const *, unsigned short>(gaddrof_o(CHud::SetBigMessage, void (*)(wchar_t const *, unsigned short)), message, style);
  135  }

  140  void CHud::SetHelpMessage(wchar_t const *message, bool quickMessage, bool permanent) {
  141:     plugin::CallDynGlobal<wchar_t const *, bool, bool>(gaddrof_o(CHud::SetHelpMessage, void (*)(wchar_t const *, bool, bool)), message, quickMessage, permanent);
  142  }

  147  void CHud::SetMessage(wchar_t const *message) {
  148:     plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetMessage, void (*)(wchar_t const *)), message);
  149  }

  154  void CHud::SetPagerMessage(wchar_t const *message) {
  155:     plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetPagerMessage, void (*)(wchar_t const *)), message);
  156  }

  161  void CHud::SetVehicleName(wchar_t const *name) {
  162:     plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetVehicleName, void (*)(wchar_t const *)), name);
  163  }

  168  void CHud::SetZoneName(wchar_t const *name) {
  169:     plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetZoneName, void (*)(wchar_t const *)), name);
  170  }

plugin_vc\game_vc\CKeyboardState.cpp:
  14  void CKeyboardState::Clear() {
  15:     plugin::CallMethodDynGlobal<CKeyboardState *>(gaddrof(CKeyboardState::Clear), this);
  16  }

plugin_vc\game_vc\CMenuManager.cpp:
  13  void CMenuManager::MessageScreen(const char* pText, bool bFullscreen) {
  14:     plugin::CallMethod<0x498943, CMenuManager*, const char*, bool>(this, pText, bFullscreen);
  15  }

  27  void CMenuManager::DisplayHelperText(const char* text) {
  28:     plugin::CallMethod<0x48F429, CMenuManager*>(this, text);
  29  }

  31  void CMenuManager::SwitchToNewScreen(int screen) {
  32:     plugin::CallMethod<0x4983EF, CMenuManager*, int>(this, screen);
  33  }

  43  void CMenuManager::SwitchMenuOnAndOff() {
  44:     plugin::CallMethod<0x498E5F, CMenuManager*>(this);
  45  }

  47  void CMenuManager::CheckSliderMovement(char value) {
  48:     plugin::CallMethod<0x4982D3, CMenuManager*>(this);
  49  }

  51  void CMenuManager::Draw(int unk) {
  52:     plugin::CallMethod<0x49DF40, CMenuManager*>(this, unk);
  53  }

  55  void CMenuManager::UserInput() {
  56:     plugin::CallMethod<0x4965BA, CMenuManager*>(this);
  57  }

  59  void CMenuManager::PrintMap() {
  60:     plugin::CallMethod<0x49A5B7, CMenuManager*>(this);
  61  }

plugin_vc\game_vc\CMessages.cpp:
   12  void CMessages::AddBigMessage(wchar_t* pString, unsigned int time, unsigned short style) {
   13:     plugin::Call<0x584050, wchar_t*, unsigned int, unsigned short>(pString, time, style);
   14  }

   17  void CMessages::AddBigMessageQ(wchar_t* pString, unsigned int time, unsigned short style) {
   18:     plugin::Call<0x583F40, wchar_t*, unsigned int, unsigned short>(pString, time, style);
   19  }

   22  void CMessages::AddBigMessageWithNumber(wchar_t* pString, unsigned int time, unsigned short style, int number, int number2, int number3, int number4, int number5, int number6) {
   23:     plugin::Call<0x583350, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, style, number, number2, number3, number4, number5, number6);
   24  }

   27  void CMessages::AddMessage(wchar_t* pString, unsigned int time, unsigned short flag) {
   28:     plugin::Call<0x584410, wchar_t*, unsigned int, unsigned short>(pString, time, flag);
   29  }

   32  void CMessages::AddMessageJumpQ(wchar_t* pString, unsigned int time, unsigned short flag) {
   33:     plugin::Call<0x584300, wchar_t*, unsigned int, unsigned short>(pString, time, flag);
   34  }

   37  void CMessages::AddMessageJumpQWithNumber(wchar_t* pString, unsigned int time, unsigned short flag, int number, int number2, int number3, int number4, int number5, int number6) {
   38:     plugin::Call<0x583440, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, flag, number, number2, number3, number4, number5, number6);
   39  }

   42  void CMessages::AddMessageJumpQWithString(wchar_t* pString1, unsigned int time, unsigned short flag, wchar_t* pString2) {
   43:     plugin::Call<0x583220, wchar_t*, unsigned int, unsigned short, wchar_t*>(pString1, time, flag, pString2);
   44  }

   47  void CMessages::AddMessageWithNumber(wchar_t* pString, unsigned int time, unsigned short flag, int number, int number1, int number2, int number3, int number4, int number5) {
   48:     plugin::Call<0x583560, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, flag, number, number1, number2, number3, number4, number5);
   49  }

   52  void CMessages::AddToPreviousBriefArray(wchar_t* arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, wchar_t* arg8) {
   53:     plugin::Call<0x583DE0, wchar_t*, int, int, int, int, int, int, wchar_t*>(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
   54  }

   57  void CMessages::ClearAllMessagesDisplayedByGame() {
   58:     plugin::Call<0x582C70>();
   59  }

   62  void CMessages::ClearMessages() {
   63:     plugin::Call<0x5841E0>();
   64  }

   67  void CMessages::ClearSmallMessagesOnly() {
   68:     plugin::Call<0x584130>();
   69  }

   72  void CMessages::ClearThisBigPrint(wchar_t* pString) {
   73:     plugin::Call<0x582CF0, wchar_t*>(pString);
   74  }

   77  void CMessages::ClearThisPrint(wchar_t* pString) {
   78:     plugin::Call<0x582FA0, wchar_t*>(pString);
   79  }

   82  void CMessages::Display() {
   83:     plugin::Call<0x584550>();
   84  }

   87  unsigned short CMessages::GetWideStringLength(wchar_t* pString) {
   88:     return plugin::CallAndReturn<unsigned short, 0x5849A0, wchar_t*>(pString);
   89  }

   92  void CMessages::Init() {
   93:     plugin::Call<0x5849C0>();
   94  }

   97  void CMessages::InsertNumberInString(wchar_t* pString, int number, int number1, int number2, int number3, int number4, int number5, wchar_t* arg8) {
   98:     plugin::Call<0x583C80, wchar_t*, int, int, int, int, int, int, wchar_t*>(pString, number, number1, number2, number3, number4, number5, arg8);
   99  }

  102  void CMessages::InsertPlayerControlKeysInString(wchar_t* pString) {
  103:     plugin::Call<0x5836B0, wchar_t*>(pString);
  104  }

  107  void CMessages::InsertStringInString(wchar_t* pString1, wchar_t* pString2) {
  108:     plugin::Call<0x583AF0, wchar_t*, wchar_t*>(pString1, pString2);
  109  }

  112  void CMessages::Process() {
  113:     plugin::Call<0x584650>();
  114  }

  117  bool CMessages::WideStringCompare(wchar_t* pString1, wchar_t* pString2, unsigned short lengthToCompare) {
  118:     return plugin::CallAndReturn<bool, 0x5848D0, wchar_t*, wchar_t*, unsigned short>(pString1, pString2, lengthToCompare);
  119  }

  122  void CMessages::WideStringCopy(wchar_t* pString1, wchar_t* pString2, unsigned short lengthToCopy) {
  123:     plugin::Call<0x584940, wchar_t*, wchar_t*, unsigned short>(pString1, pString2, lengthToCopy);
  124  }

plugin_vc\game_vc\CModelInfo.cpp:
  18  CClumpModelInfo* CModelInfo::AddClumpModel(int index) {
  19:     return plugin::CallAndReturn<CClumpModelInfo*, 0x55F640, int>(index);
  20  }

  23  CPedModelInfo* CModelInfo::AddPedModel(int index) {
  24:     return plugin::CallAndReturn<CPedModelInfo*, 0x55F580, int>(index);
  25  }

  28  CSimpleModelInfo* CModelInfo::AddSimpleModel(int index) {
  29:     return plugin::CallAndReturn<CSimpleModelInfo*, 0x55F730, int>(index);
  30  }

  33  CTimeModelInfo* CModelInfo::AddTimeModel(int index) {
  34:     return plugin::CallAndReturn<CTimeModelInfo*, 0x55F6E0, int>(index);
  35  }

  38  CVehicleModelInfo* CModelInfo::AddVehicleModel(int index) {
  39:     return plugin::CallAndReturn<CVehicleModelInfo*, 0x55F5D0, int>(index);
  40  }

  43  CWeaponModelInfo* CModelInfo::AddWeaponModel(int index) {
  44:     return plugin::CallAndReturn<CWeaponModelInfo*, 0x55F690, int>(index);
  45  }

  48  void* CModelInfo::Get2dEffectStore() {
  49:     return plugin::CallAndReturn<void*, 0x55F570>();
  50  }

  53  CBaseModelInfo* CModelInfo::GetModelInfo(char const* name, int* index) {
  54:     return plugin::CallAndReturn<CBaseModelInfo*, 0x55F7D0, char const*, int*>(name, index);
  55  }

  58  CBaseModelInfo* CModelInfo::GetModelInfo(char const* name, int minIndex, int maxInedx) {
  59:     return plugin::CallAndReturn<CBaseModelInfo*, 0x55F780, char const*, int, int>(name, minIndex, maxInedx);
  60  }

  63  void CModelInfo::Initialise() {
  64:     plugin::Call<0x55FA40>();
  65  }

  68  bool CModelInfo::IsBikeModel(int index) {
  69:     return plugin::CallAndReturn<bool, 0x55F4E0, int>(index);
  70  }

  73  bool CModelInfo::IsBoatModel(int index) {
  74:     return plugin::CallAndReturn<bool, 0x55F540, int>(index);
  75  }

  78  bool CModelInfo::IsCarModel(int index) {
  79:     return plugin::CallAndReturn<bool, 0x55F510, int>(index);
  80  }

  83  void CModelInfo::ShutDown() {
  84:     plugin::Call<0x55F820>();
  85  }

plugin_vc\game_vc\CMotionBlurStreaks.cpp:
  14  void CMotionBlurStreaks::RegisterStreak(unsigned int id, unsigned char red, unsigned char green, unsigned char blue, CVector leftPoint, CVector rightPoint) {
  15:     plugin::Call<0x572800, unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(id, red, green, blue, leftPoint, rightPoint);
  16  }

  19  void CMotionBlurStreaks::Render() {
  20:     plugin::Call<0x572920>();
  21  }

plugin_vc\game_vc\CMousePointerStateHelper.cpp:
  17      CMouseControllerState ret_state;
  18:     plugin::CallMethodDynGlobal<CMousePointerStateHelper *, CMouseControllerState *>(gaddrof(CMousePointerStateHelper::GetMouseSetUp), this, &ret_state);
  19      return ret_state;

plugin_vc\game_vc\CMovie.cpp:
  10  CMovie::CMovie() {
  11:     plugin::CallMethod<0x606720, CMovie *>(this);
  12  }

plugin_vc\game_vc\CObject.cpp:
  12  CObject::CObject(CDummyObject* dummyObject) : CPhysical(plugin::dummy) {
  13:     plugin::CallMethod<0x4E40F0, CObject *, CDummyObject*>(this, dummyObject);
  14  }

  17  CObject::CObject(int arg0, bool arg1) : CPhysical(plugin::dummy) {
  18:     plugin::CallMethod<0x4E41B0, CObject *, int, bool>(this, arg0, arg1);
  19  }

  22  CObject::CObject() : CPhysical(plugin::dummy) {
  23:     plugin::CallMethod<0x4E4220, CObject *>(this);
  24  }

  27  bool CObject::CanBeDeleted() {
  28:     return plugin::CallMethodAndReturn<bool, 0x4E3E20, CObject *>(this);
  29  }

  32  void CObject::DeleteAllMissionObjects() {
  33:     plugin::Call<0x4E0820>();
  34  }

  37  void CObject::DeleteAllTempObjects() {
  38:     plugin::Call<0x4E08A0>();
  39  }

  42  void CObject::DeleteAllTempObjectsInArea(CVector point, float radius) {
  43:     plugin::Call<0x4E0720, CVector, float>(point, radius);
  44  }

  47  void CObject::Init() {
  48:     plugin::CallMethod<0x4E3E50, CObject *>(this);
  49  }

  52  void CObject::ObjectDamage(float damage) {
  53:     plugin::CallMethod<0x4E0990, CObject *, float>(this, damage);
  54  }

  57  void CObject::RefModelInfo(int modelIndex) {
  58:     plugin::CallMethod<0x4E0970, CObject *, int>(this, modelIndex);
  59  }

  62  void CObject::operator delete(void* data) {
  63:     plugin::Call<0x4E4030, void*>(data);
  64  }

  67  void* CObject::operator new(unsigned int size) {
  68:     return plugin::CallAndReturn<void*, 0x4E4070, unsigned int>(size);
  69  }

  72  void* CObject::operator new(unsigned int size, int arg1) {
  73:     return plugin::CallAndReturn<void*, 0x4E4050, unsigned int, int>(size, arg1);
  74  }

plugin_vc\game_vc\COcclusion.cpp:
  31  void COcclusion::AddOne(float x, float y, float z, float width, float length, float height, float angle) {
  32:     plugin::CallDynGlobal<float, float, float, float, float, float, float>(gaddrof(COcclusion::AddOne), x, y, z, width, length, height, angle);
  33  }

  45  bool COcclusion::IsAABoxOccluded(CVector pos, float width, float length, float height) {
  46:     return plugin::CallAndReturnDynGlobal<bool, CVector, float, float, float>(gaddrof(COcclusion::IsAABoxOccluded), pos, width, length, height);
  47  }

  52  bool COcclusion::IsPositionOccluded(CVector pos, float side) {
  53:     return plugin::CallAndReturnDynGlobal<bool, CVector, float>(gaddrof(COcclusion::IsPositionOccluded), pos, side);
  54  }

  66  bool COccluder::ProcessLineSegment(int corner1, int corner2, CActiveOccluder *occl) {
  67:     return plugin::CallMethodAndReturnDynGlobal<bool, COccluder *, int, int, CActiveOccluder *>(gaddrof(COccluder::ProcessLineSegment), this, corner1, corner2, occl);
  68  }

  73  bool COccluder::ProcessOneOccluder(CActiveOccluder *occl) {
  74:     return plugin::CallMethodAndReturnDynGlobal<bool, COccluder *, CActiveOccluder *>(gaddrof(COccluder::ProcessOneOccluder), this, occl);
  75  }

  80  bool DoesInfiniteLineTouchScreen(float lineX, float lineY, float lineDX, float lineDY) {
  81:     return plugin::CallAndReturnDynGlobal<bool, float, float, float, float>(gaddrof(DoesInfiniteLineTouchScreen), lineX, lineY, lineDX, lineDY);
  82  }

plugin_vc\game_vc\common.cpp:
   10  float FindPlayerHeading() {
   11:     return plugin::CallAndReturn<float, 0x4BBF70>();
   12  }

   15  CVector& FindPlayerCentreOfWorld_NoSniperShift() {
   16:     return plugin::CallAndReturn<CVector&, 0x4BC020>();
   17  }

   20  CVector& FindPlayerCentreOfWorld(int playerId) {
   21:     return plugin::CallAndReturn<CVector&, 0x4BC0A0, int>(playerId);
   22  }

   25  CPlayerPed* FindPlayerPed() {
   26:     return plugin::CallAndReturn<CPlayerPed*, 0x4BC120>();
   27  }

   30  CTrain* FindPlayerTrain() {
   31:     return plugin::CallAndReturn<CTrain*, 0x4BC140>();
   32  }

   35  CEntity* FindPlayerEntity() {
   36:     return plugin::CallAndReturn<CEntity*, 0x4BC1B0>();
   37  }

   40  CVehicle* FindPlayerVehicle() {
   41:     return plugin::CallAndReturn<CVehicle*, 0x4BC1E0>();
   42  }

   45  CVector& FindPlayerSpeed() {
   46:     return plugin::CallAndReturn<CVector&, 0x4BC210>();
   47  }

   51      CVector result;
   52:     plugin::Call<0x4BC240, CVector*>(&result);
   53      return result;

   57  RwTexture* GetFirstTexture(RwTexDictionary* texDictionary) {
   58:     return plugin::CallAndReturn<RwTexture*, 0x57F900, RwTexDictionary*>(texDictionary);
   59  }

   62  RwObject* GetFirstObject(RwFrame* frame) {
   63:     return plugin::CallAndReturn<RwObject*, 0x57F940, RwFrame*>(frame);
   64  }

   67  RpAtomic* GetFirstAtomic(RpClump* clump) {
   68:     return plugin::CallAndReturn<RpAtomic*, 0x57F980, RpClump*>(clump);
   69  }

   72  void SetAmbientColours(RwRGBAReal* colours) {
   73:     plugin::Call<0x57FAD0, RwRGBAReal*>(colours);
   74  }

   77  void SetAmbientColoursForPedsCarsAndObjects() {
   78:     plugin::Call<0x57FAF0>();
   79  }

   82  void SetAmbientColours() {
   83:     plugin::Call<0x57FB10>();
   84  }

   87  void SetFullAmbient() {
   88:     plugin::Call<0x57FB30>();
   89  }

   92  void ActivateDirectional() {
   93:     plugin::Call<0x57FB50>();
   94  }

   97  void DeActivateDirectional() {
   98:     plugin::Call<0x57FB60>();
   99  }

  102  void ReSetAmbientAndDirectionalColours() {
  103:     plugin::Call<0x57FB70>();
  104  }

  107  void SetBrightMarkerColours(float power) {
  108:     plugin::Call<0x57FBA0, float>(power);
  109  }

  112  void SetAmbientAndDirectionalColours(float power) {
  113:     plugin::Call<0x57FC50, float>(power);
  114  }

  117  void RemoveExtraDirectionalLights(RpWorld* world) {
  118:     plugin::Call<0x57FCD0, RpWorld*>(world);
  119  }

  122  void AddAnExtraDirectionalLight(RpWorld* world, float x, float y, float z, float red, float green, float blue) {
  123:     plugin::Call<0x57FD00, RpWorld*, float, float, float, float, float, float>(world, x, y, z, red, green, blue);
  124  }

  127  void WorldReplaceNormalLightsWithScorched(RpWorld* world, float intensity) {
  128:     plugin::Call<0x57FE40, RpWorld*, float>(world, intensity);
  129  }

  132  RpWorld* LightsDestroy(RpWorld* world) {
  133:     return plugin::CallAndReturn<RpWorld*, 0x57FE80, RpWorld*>(world);
  134  }

  137  RpWorld* LightsCreate(RpWorld* world) {
  138:     return plugin::CallAndReturn<RpWorld*, 0x57FF50, RpWorld*>(world);
  139  }

  142  void SetLightsWithTimeOfDayColour(RpWorld* world) {
  143:     plugin::Call<0x5800F0, RpWorld*>(world);
  144  }

  152  CAnimBlendClumpData* RpAnimBlendAllocateData(RpClump* clump) {
  153:     return plugin::CallAndReturn<CAnimBlendClumpData*, 0x407520, RpClump*>(clump);
  154  }

  156  void RpAnimBlendClumpFillFrameArray(RpClump* clump, AnimBlendFrameData** frameData) {
  157:     plugin::Call<0x407AC0, RpClump*, AnimBlendFrameData**>(clump, frameData);
  158  }

  160  CAnimBlendAssociation* RpAnimBlendClumpGetAssociation(RpClump* clump, unsigned int animId) {
  161:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x407780, RpClump*, unsigned int>(clump, animId);
  162  }

  164  CAnimBlendAssociation* RpAnimBlendClumpGetFirstAssociation(RpClump* clump) {
  165:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x402E20, RpClump*>(clump);
  166  }

  168  CAnimBlendAssociation* RpAnimBlendClumpGetFirstAssociation(RpClump* clump, unsigned int flags) {
  169:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4075F0, RpClump*, unsigned int>(clump, flags);
  170  }

  172  CAnimBlendAssociation* RpAnimBlendClumpGetMainAssociation(RpClump* clump, int n) {
  173:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x407660, RpClump*, int>(clump, n);
  174  }

  176  CAnimBlendAssociation* RpAnimBlendClumpGetMainPartialAssociation(RpClump* clump, int n) {
  177:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x407620, RpClump*, int>(clump, n);
  178  }

  180  void RpAnimBlendClumpInit(RpClump* clump) {
  181:     plugin::Call<0x407890, RpClump*>(clump);
  182  }

  184  bool RpAnimBlendClumpIsInitialized(RpClump* clump) {
  185:     return plugin::CallAndReturn<bool, 0x407870, RpClump*>(clump);
  186  }

  188  void RpAnimBlendClumpRemoveAllAssociations(RpClump* clump) {
  189:     plugin::Call<0x407800, RpClump*>(clump);
  190  }

  192  void RpAnimBlendClumpRemoveAssociations(RpClump* clump, unsigned int flags) {
  193:     plugin::Call<0x4077B0, RpClump*, unsigned int>(clump, flags);
  194  }

  196  void RpAnimBlendClumpSetBlendDeltas(RpClump* clump, unsigned int flags, float delta) {
  197:     plugin::Call<0x407830, RpClump*, unsigned int, float>(clump, flags, delta);
  198  }

  200  void RpAnimBlendClumpUpdateAnimations(RpClump* clump, float step, bool onScreen) {
  201:     plugin::Call<0x404690, RpClump*, float, bool>(clump, step, onScreen);
  202  }

  204  CAnimBlendAssociation* RpAnimBlendGetNextAssociation(CAnimBlendAssociation* association) {
  205:     return plugin::CallAndReturn<CAnimBlendAssociation*, 0x4075D0, CAnimBlendAssociation*>(association);
  206  }

  208  bool RpAnimBlendPluginAttach() {
  209:     return plugin::CallAndReturn<bool, 0x4074D0>();
  210  }

plugin_vc\game_vc\COnscreenTimer.cpp:
  10  void COnscreenTimer::AddClock(unsigned int arg0, char* arg1, bool arg2) {
  11:     plugin::CallMethod<0x434B30, COnscreenTimer *, unsigned int, char*, bool>(this, arg0, arg1, arg2);
  12  }

  15  void COnscreenTimer::AddCounter(unsigned int arg0, unsigned short arg1, char* arg2, unsigned short arg3) {
  16:     plugin::CallMethod<0x434AE0, COnscreenTimer *, unsigned int, unsigned short, char*, unsigned short>(this, arg0, arg1, arg2, arg3);
  17  }

  20  void COnscreenTimer::ClearClock(unsigned int arg0) {
  21:     plugin::CallMethod<0x434AA0, COnscreenTimer *, unsigned int>(this, arg0);
  22  }

  25  void COnscreenTimer::ClearCounter(unsigned int arg0) {
  26:     plugin::CallMethod<0x434A60, COnscreenTimer *, unsigned int>(this, arg0);
  27  }

  30  void COnscreenTimer::Init() {
  31:     plugin::CallMethod<0x434CE0, COnscreenTimer *>(this);
  32  }

  35  void COnscreenTimer::Process() {
  36:     plugin::CallMethod<0x434B90, COnscreenTimer *>(this);
  37  }

  40  void COnscreenTimer::ProcessForDisplay() {
  41:     plugin::CallMethod<0x434BD0, COnscreenTimer *>(this);
  42  }

  45  void COnscreenTimerEntry::Process() {
  46:     plugin::CallMethod<0x434DE0, COnscreenTimerEntry *>(this);
  47  }

plugin_vc\game_vc\CPad.cpp:
   34  void CPad::AddToPCCheatString(char character) {
   35:     plugin::CallMethodDynGlobal<CPad *, char>(gaddrof(CPad::AddToPCCheatString), this, character);
   36  }

   41  bool CPad::CarGunJustDown() {
   42:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CarGunJustDown), this);
   43  }

   48  bool CPad::ChangeStationJustDown() {
   49:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ChangeStationJustDown), this);
   50  }

   55  void CPad::Clear(char bDisablePlayerControls) {
   56:     plugin::CallMethodDynGlobal<CPad *, char>(gaddrof(CPad::Clear), this, bDisablePlayerControls);
   57  }

   62  bool CPad::CollectPickupJustDown() {
   63:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CollectPickupJustDown), this);
   64  }

   69  bool CPad::CycleCameraModeDownJustDown() {
   70:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeDownJustDown), this);
   71  }

   76  bool CPad::CycleCameraModeJustDown() {
   77:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeJustDown), this);
   78  }

   83  bool CPad::CycleCameraModeUpJustDown() {
   84:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeUpJustDown), this);
   85  }

   90  bool CPad::CycleWeaponLeftJustDown() {
   91:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleWeaponLeftJustDown), this);
   92  }

   97  bool CPad::CycleWeaponRightJustDown() {
   98:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleWeaponRightJustDown), this);
   99  }

  104  bool CPad::DuckJustDown() {
  105:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::DuckJustDown), this);
  106  }

  111  bool CPad::ExitVehicleJustDown() {
  112:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ExitVehicleJustDown), this);
  113  }

  118  bool CPad::ForceCameraBehindPlayer() {
  119:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ForceCameraBehindPlayer), this);
  120  }

  125  short CPad::GetAccelerate() {
  126:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAccelerate), this);
  127  }

  132  short CPad::GetAnalogueLeftRight() {
  133:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAnalogueLeftRight), this);
  134  }

  139  bool CPad::GetAnaloguePadDown() {
  140:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadDown), this);
  141  }

  146  bool CPad::GetAnaloguePadLeft() {
  147:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadLeft), this);
  148  }

  153  bool CPad::GetAnaloguePadLeftJustUp() {
  154:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadLeftJustUp), this);
  155  }

  160  bool CPad::GetAnaloguePadRight() {
  161:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadRight), this);
  162  }

  167  bool CPad::GetAnaloguePadRightJustUp() {
  168:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadRightJustUp), this);
  169  }

  174  bool CPad::GetAnaloguePadUp() {
  175:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadUp), this);
  176  }

  181  short CPad::GetAnalogueUpDown() {
  182:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAnalogueUpDown), this);
  183  }

  188  short CPad::GetBrake() {
  189:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetBrake), this);
  190  }

  195  bool CPad::GetCarGunFired() {
  196:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetCarGunFired), this);
  197  }

  202  short CPad::GetCarGunLeftRight() {
  203:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetCarGunLeftRight), this);
  204  }

  209  short CPad::GetCarGunUpDown() {
  210:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetCarGunUpDown), this);
  211  }

  216  bool CPad::GetExitVehicle() {
  217:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetExitVehicle), this);
  218  }

  223  short CPad::GetHandBrake() {
  224:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetHandBrake), this);
  225  }

  230  bool CPad::GetHorn() {
  231:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetHorn), this);
  232  }

  237  bool CPad::GetLookBehindForCar() {
  238:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookBehindForCar), this);
  239  }

  244  bool CPad::GetLookBehindForPed() {
  245:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookBehindForPed), this);
  246  }

  251  bool CPad::GetLookLeft() {
  252:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookLeft), this);
  253  }

  258  bool CPad::GetLookRight() {
  259:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookRight), this);
  260  }

  265  short CPad::GetPedWalkLeftRight() {
  266:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetPedWalkLeftRight), this);
  267  }

  272  short CPad::GetPedWalkUpDown() {
  273:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetPedWalkUpDown), this);
  274  }

  279  bool CPad::GetSprint() {
  280:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetSprint), this);
  281  }

  286  short CPad::GetSteeringLeftRight() {
  287:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetSteeringLeftRight), this);
  288  }

  293  short CPad::GetSteeringUpDown() {
  294:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetSteeringUpDown), this);
  295  }

  300  bool CPad::GetTarget() {
  301:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetTarget), this);
  302  }

  307  short CPad::GetWeapon() {
  308:     return plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetWeapon), this);
  309  }

  314  bool CPad::HornJustDown() {
  315:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::HornJustDown), this);
  316  }

  321  int CPad::InputHowLongAgo() {
  322:     return plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::InputHowLongAgo), this);
  323  }

  328  bool CPad::JumpJustDown() {
  329:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::JumpJustDown), this);
  330  }

  335  int CPad::LookAroundLeftRight() {
  336:     return plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::LookAroundLeftRight), this);
  337  }

  342  int CPad::LookAroundUpDown() {
  343:     return plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::LookAroundUpDown), this);
  344  }

  350      CControllerState ret_result;
  351:     plugin::CallMethodDynGlobal<CPad *, CControllerState *, CControllerState const &, CControllerState const &>(gaddrof(CPad::ReconcileTwoControllersInput), this, &ret_result, controller1, controller2);
  352      return ret_result;

  358  void CPad::ResetAverageWeapon() {
  359:     plugin::CallMethodDynGlobal<CPad *>(gaddrof(CPad::ResetAverageWeapon), this);
  360  }

  365  void CPad::SetDrunkInputDelay(int bEnable) {
  366:     plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::SetDrunkInputDelay), this, bEnable);
  367  }

  372  bool CPad::ShiftTargetLeftJustDown() {
  373:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ShiftTargetLeftJustDown), this);
  374  }

  379  bool CPad::ShiftTargetRightJustDown() {
  380:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ShiftTargetRightJustDown), this);
  381  }

  386  int CPad::SniperModeLookLeftRight() {
  387:     return plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::SniperModeLookLeftRight), this);
  388  }

  393  int CPad::SniperModeLookUpDown() {
  394:     return plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::SniperModeLookUpDown), this);
  395  }

  400  bool CPad::SniperZoomIn() {
  401:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::SniperZoomIn), this);
  402  }

  407  bool CPad::SniperZoomOut() {
  408:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::SniperZoomOut), this);
  409  }

  414  void CPad::StartShake(short duration, unsigned char frequency) {
  415:     plugin::CallMethodDynGlobal<CPad *, short, unsigned char>(gaddrof(CPad::StartShake), this, duration, frequency);
  416  }

  421  void CPad::StopShaking(int a1) {
  422:     plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::StopShaking), this, a1);
  423  }

  428  bool CPad::TargetJustDown() {
  429:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::TargetJustDown), this);
  430  }

  435  void CPad::Update(int a2) {
  436:     plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::Update), this, a2);
  437  }

  442  bool CPad::WeaponJustDown() {
  443:     return plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::WeaponJustDown), this);
  444  }

  463  void CPad::EditCodesForControls(int *outKeyCode, int a2) {
  464:     plugin::CallDynGlobal<int *, int>(gaddrof(CPad::EditCodesForControls), outKeyCode, a2);
  465  }

  477  CPad *CPad::GetPad(int padNumber) {
  478:     return plugin::CallAndReturnDynGlobal<CPad *, int>(gaddrof(CPad::GetPad), padNumber);
  479  }

plugin_vc\game_vc\CParticle.cpp:
  31  void CParticle::AddJetExplosion(CVector const &posn, float power, float size) {
  32:     plugin::CallDynGlobal<CVector const &, float, float>(gaddrof(CParticle::AddJetExplosion), posn, power, size);
  33  }

  38  CParticle *CParticle::AddParticle(tParticleType particleType, CVector const &posn, CVector const &direction, CEntity *entity, float size, RwRGBA const *color, int rotationSpeed, int rotation, int startFrame, int lifeSpan) {
  39:     return plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const *, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const *, int, int, int, int)), particleType, posn, direction, entity, size, color, rotationSpeed, rotation, startFrame, lifeSpan);
  40  }

  45  CParticle *CParticle::AddParticle(tParticleType particleType, CVector const &posn, CVector const &direction, CEntity *entity, float size, int rotationSpeed, int rotation, int startFrame, int lifeSpan) {
  46:     return plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int)), particleType, posn, direction, entity, size, rotationSpeed, rotation, startFrame, lifeSpan);
  47  }

  52  void CParticle::AddParticlesAlongLine(tParticleType particleType, CVector const *lineStart, CVector const *lineEnd, CVector const &direction, float step, CEntity *entity, float size, int rotationSpeed, int rotation, int startFrame, int lifeSpan) {
  53:     plugin::CallDynGlobal<tParticleType, CVector const *, CVector const *, CVector const &, float, CEntity *, float, int, int, int, int>(gaddrof(CParticle::AddParticlesAlongLine), particleType, lineStart, lineEnd, direction, step, entity, size, rotationSpeed, rotation, startFrame, lifeSpan);
  54  }

  66  void CParticle::HandleShootableBirdsStuff(CEntity *entity, CVector const &posn) {
  67:     plugin::CallDynGlobal<CEntity *, CVector const &>(gaddrof(CParticle::HandleShootableBirdsStuff), entity, posn);
  68  }

  87  void CParticle::RemovePSystem(tParticleType particleType) {
  88:     plugin::CallDynGlobal<tParticleType>(gaddrof(CParticle::RemovePSystem), particleType);
  89  }

  94  void CParticle::RemoveParticle(CParticle *particle, CParticle *previousParticle, tParticleSystemData *particleSystsem) {
  95:     plugin::CallDynGlobal<CParticle *, CParticle *, tParticleSystemData *>(gaddrof(CParticle::RemoveParticle), particle, previousParticle, particleSystsem);
  96  }

plugin_vc\game_vc\cParticleSystemMgr.cpp:
  16  void cParticleSystemMgr::Initialise() {
  17:     plugin::CallMethodDynGlobal<cParticleSystemMgr *>(gaddrof(cParticleSystemMgr::Initialise), this);
  18  }

  23  void cParticleSystemMgr::LoadParticleData() {
  24:     plugin::CallMethodDynGlobal<cParticleSystemMgr *>(gaddrof(cParticleSystemMgr::LoadParticleData), this);
  25  }

plugin_vc\game_vc\CPathFind.cpp:
  13  bool CPathFind::GeneratePedCreationCoors(float arg1, float arg2, float arg3, float arg4, float arg5, float arg6, CVector* ar7, int* arg8, int* arg9, float* arg10, CMatrix* arg11) {
  14:     return plugin::CallMethodAndReturn<bool, 0x437B10, CPathFind *, float, float, float, float, float, float, CVector*, int*, int*, float*, CMatrix*>(this, arg1, arg2, arg3, arg4, arg5, arg6, ar7, arg8, arg9, arg10, arg11);
  15  }

  18  bool CPathFind::GenerateCarCreationCoors(float arg1, float arg2, float arg3, float arg4, float arg5, float arg6, bool arg7, CVector* arg8, int* arg9, int* arg10, float* arg11, bool arg12) {
  19:     return plugin::CallMethodAndReturn<bool, 0x4382B0, CPathFind *, float, float, float, float, float, float, bool, CVector*, int*, int*, float*, bool>(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
  20  }

  23  int CPathFind::FindNodeClosestToCoors(CVector arg1, unsigned char arg2, float arg3, bool arg4, bool arg5, bool arg6, bool arg7) {
  24: 	return plugin::CallMethodAndReturn<int, 0x437150, CPathFind *, CVector, unsigned char, float, bool, bool, bool, bool>(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  25  }

plugin_vc\game_vc\CPed.cpp:
    10  void CPed::SetMoveAnim() {
    11:     plugin::CallVirtualMethod<18, CPed *>(this);
    12  }

    15  int CPed::AddInCarAnims(CVehicle* vehicle, bool arg1) {
    16:     return plugin::CallMethodAndReturn<int, 0x512520, CPed *, CVehicle*, bool>(this, vehicle, arg1);
    17  }

    20  void CPed::AddWeaponModel(int modelIndex) {
    21:     plugin::CallMethod<0x4FFE40, CPed *, int>(this, modelIndex);
    22  }

    25  char CPed::AimGun() {
    26:     return plugin::CallMethodAndReturn<char, 0x50B2C0, CPed *>(this);
    27  }

    30  void CPed::AnswerMobile() {
    31:     plugin::CallMethod<0x4F5710, CPed *>(this);
    32  }

    35  CEntity* CPed::AttachPedToEntity(CEntity* entity, float offsetX, float offsetY, float offsetZ, unsigned short position, float angle, eWeaponType weaponType) {
    36:     return plugin::CallMethodAndReturn<CEntity*, 0x4EF490, CPed *, CEntity*, float, float, float, unsigned short, float, eWeaponType>(this, entity, offsetX, offsetY, offsetZ, position, angle, weaponType);
    37  }

    40  unsigned int CPed::Attack() {
    41:     return plugin::CallMethodAndReturn<unsigned int, 0x52B070, CPed *>(this);
    42  }

    45  void CPed::Avoid() {
    46:     plugin::CallMethod<0x4FA2E0, CPed *>(this);
    47  }

    50  int CPed::BeingDraggedFromCar() {
    51:     return plugin::CallMethodAndReturn<int, 0x518250, CPed *>(this);
    52  }

    55  void CPed::BuildPedLists() {
    56:     plugin::CallMethod<0x50D4B0, CPed *>(this);
    57  }

    60  void CPed::BuyIceCream() {
    61:     plugin::CallMethod<0x4F10D0, CPed *>(this);
    62  }

    65  void CPed::CalculateNewOrientation() {
    66:     plugin::CallMethod<0x509F80, CPed *>(this);
    67  }

    70  void CPed::CalculateNewVelocity() {
    71:     plugin::CallMethod<0x50A640, CPed *>(this);
    72  }

    75  bool CPed::CanBeDamagedByThisGangMember(CPed* ped) {
    76:     return plugin::CallMethodAndReturn<bool, 0x50F130, CPed *, CPed*>(this, ped);
    77  }

    80  bool CPed::CanBeDeleted() {
    81:     return plugin::CallMethodAndReturn<bool, 0x4FFEF0, CPed *>(this);
    82  }

    85  bool CPed::CanBeDeletedEvenInVehicle() {
    86:     return plugin::CallMethodAndReturn<bool, 0x4FFEC0, CPed *>(this);
    87  }

    90  bool CPed::CanPedDriveOff() {
    91:     return plugin::CallMethodAndReturn<bool, 0x4EFC90, CPed *>(this);
    92  }

    95  bool CPed::CanPedJumpThis(CEntity* entity, CVector* arg1) {
    96:     return plugin::CallMethodAndReturn<bool, 0x4F0590, CPed *, CEntity*, CVector*>(this, entity, arg1);
    97  }

   100  bool CPed::CanSeeEntity(CEntity* entity, float limitAngle) {
   101:     return plugin::CallMethodAndReturn<bool, 0x51C870, CPed *, CEntity*, float>(this, entity, limitAngle);
   102  }

   105  bool CPed::CanSetPedState() {
   106:     return plugin::CallMethodAndReturn<bool, 0x5018D0, CPed *>(this);
   107  }

   110  bool CPed::CanStrafeOrMouseControl() {
   111:     return plugin::CallMethodAndReturn<bool, 0x501890, CPed *>(this);
   112  }

   115  bool CPed::CanWeRunAndFireWithWeapon() {
   116:     return plugin::CallMethodAndReturn<bool, 0x50B220, CPed *>(this);
   117  }

   120  unsigned int CPed::Chat() {
   121:     return plugin::CallMethodAndReturn<unsigned int, 0x4F6050, CPed *>(this);
   122  }

   125  bool CPed::CheckForExplosions(CVector2D& arg0) {
   126:     return plugin::CallMethodAndReturn<bool, 0x4F4950, CPed *, CVector2D&>(this, arg0);
   127  }

   130  char CPed::CheckForPointBlankPeds(CPed* ped) {
   131:     return plugin::CallMethodAndReturn<char, 0x52C670, CPed *, CPed*>(this, ped);
   132  }

   135  bool CPed::CheckIfInTheAir() {
   136:     return plugin::CallMethodAndReturn<bool, 0x4FD680, CPed *>(this);
   137  }

   140  int CPed::CheckThreatValidity() {
   141:     return plugin::CallMethodAndReturn<int, 0x50BD00, CPed *>(this);
   142  }

   145  int CPed::ChooseAttackAI(unsigned char arg0, bool arg1) {
   146:     return plugin::CallMethodAndReturn<int, 0x529460, CPed *, unsigned char, bool>(this, arg0, arg1);
   147  }

   150  int CPed::ChooseAttackPlayer(unsigned char arg0, bool arg1) {
   151:     return plugin::CallMethodAndReturn<int, 0x528AA0, CPed *, unsigned char, bool>(this, arg0, arg1);
   152  }

   155  void CPed::ClearAimFlag() {
   156:     plugin::CallMethod<0x50B4A0, CPed *>(this);
   157  }

   160  void CPed::ClearAll() {
   161:     plugin::CallMethod<0x509DF0, CPed *>(this);
   162  }

   165  void CPed::ClearAnswerMobile() {
   166:     plugin::CallMethod<0x4F58C0, CPed *>(this);
   167  }

   170  void CPed::ClearAttack() {
   171:     plugin::CallMethod<0x52D120, CPed *>(this);
   172  }

   175  void CPed::ClearAttackByRemovingAnim() {
   176:     plugin::CallMethod<0x52CF70, CPed *>(this);
   177  }

   180  void CPed::ClearChat() {
   181:     plugin::CallMethod<0x4F5FA0, CPed *>(this);
   182  }

   185  void CPed::ClearDuck(bool arg0) {
   186:     plugin::CallMethod<0x512A20, CPed *, bool>(this, arg0);
   187  }

   190  void CPed::ClearFollowPath() {
   191:     plugin::CallMethod<0x4F7920, CPed *>(this);
   192  }

   195  void CPed::ClearInvestigateEvent() {
   196:     plugin::CallMethod<0x526BA0, CPed *>(this);
   197  }

   200  void CPed::ClearLeader() {
   201:     plugin::CallMethod<0x521670, CPed *>(this);
   202  }

   205  void CPed::ClearLookFlag() {
   206:     plugin::CallMethod<0x50B9C0, CPed *>(this);
   207  }

   210  void CPed::ClearObjective() {
   211:     plugin::CallMethod<0x521720, CPed *>(this);
   212  }

   215  void CPed::ClearPointGunAt() {
   216:     plugin::CallMethod<0x52DBE0, CPed *>(this);
   217  }

   220  void CPed::ClearSeek() {
   221:     plugin::CallMethod<0x4FC450, CPed *>(this);
   222  }

   225  void CPed::ClearWaitState() {
   226:     plugin::CallMethod<0x4F3130, CPed *>(this);
   227  }

   230  void CPed::ClearWeapons() {
   231:     plugin::CallMethod<0x4FF740, CPed *>(this);
   232  }

   235  void CPed::CollideWithPed(CPed* ped) {
   236:     plugin::CallMethod<0x524920, CPed *, CPed*>(this, ped);
   237  }

   240  void CPed::CreateDeadPedMoney() {
   241:     plugin::CallMethod<0x43E2C0, CPed *>(this);
   242  }

   245  void CPed::CreateDeadPedPickupCoors(float* pX, float* pY, float* pZ) {
   246:     plugin::CallMethod<0x43DAC0, CPed *, float*, float*, float*>(this, pX, pY, pZ);
   247  }

   250  void CPed::CreateDeadPedWeaponPickups() {
   251:     plugin::CallMethod<0x43DF30, CPed *>(this);
   252  }

   255  void CPed::DeadPedMakesTyresBloody() {
   256:     plugin::CallMethod<0x587700, CPed *>(this);
   257  }

   260  void CPed::DettachPedFromEntity() {
   261:     plugin::CallMethod<0x4EF370, CPed *>(this);
   262  }

   265  void CPed::Dress() {
   266:     plugin::CallMethod<0x4EEFD0, CPed *>(this);
   267  }

   270  void CPed::DriveVehicle() {
   271:     plugin::CallMethod<0x522AA0, CPed *>(this);
   272  }

   275  void CPed::Duck() {
   276:     plugin::CallMethod<0x512A90, CPed *>(this);
   277  }

   280  void CPed::DuckAndCover() {
   281:     plugin::CallMethod<0x513340, CPed *>(this);
   282  }

   285  void CPed::EndFight(unsigned char arg0) {
   286:     plugin::CallMethod<0x5289A0, CPed *, unsigned char>(this, arg0);
   287  }

   290  void CPed::EnterCar() {
   291:     plugin::CallMethod<0x517BA0, CPed *>(this);
   292  }

   295  void CPed::ExitCar() {
   296:     plugin::CallMethod<0x516960, CPed *>(this);
   297  }

   300  bool CPed::FacePhone() {
   301:     return plugin::CallMethodAndReturn<bool, 0x4F5CA0, CPed *>(this);
   302  }

   305  void CPed::Fall() {
   306:     plugin::CallMethod<0x4FD740, CPed *>(this);
   307  }

   310  void CPed::Fight() {
   311:     plugin::CallMethod<0x529A00, CPed *>(this);
   312  }

   315  void CPed::FightHitPed(CPed* ped, CVector& arg1, CVector& arg2, short arg3) {
   316:     plugin::CallMethod<0x527800, CPed *, CPed*, CVector&, CVector&, short>(this, ped, arg1, arg2, arg3);
   317  }

   320  void CPed::FightStrike(CVector& arg0, bool arg1) {
   321:     plugin::CallMethod<0x5282E0, CPed *, CVector&, bool>(this, arg0, arg1);
   322  }

   325  bool CPed::FindBestCoordsFromNodes(CVector arg0, CVector* arg1) {
   326:     return plugin::CallMethodAndReturn<bool, 0x513DF0, CPed *, CVector, CVector*>(this, arg0, arg1);
   327  }

   330  void CPed::Flee() {
   331:     plugin::CallMethod<0x4FB130, CPed *>(this);
   332  }

   335  short CPed::FollowPath() {
   336:     return plugin::CallMethodAndReturn<short, 0x4F76C0, CPed *>(this);
   337  }

   340  int CPed::GetFormationPosition() {
   341:     return plugin::CallMethodAndReturn<int, 0x519E30, CPed *>(this);
   342  }

   345  int CPed::GetLocalDirection(CVector2D const& arg0) {
   346:     return plugin::CallMethodAndReturn<int, 0x5035F0, CPed *, CVector2D const&>(this, arg0);
   347  }

   350  int CPed::GetLocalPositionToOpenCarDoor(CVehicle* vehicle, unsigned int arg1, float arg2) {
   351:     return plugin::CallAndReturn<int, 0x512D10, CVehicle*, unsigned int, float>(vehicle, arg1, arg2);
   352  }

   355  int CPed::GetNearestDoor(CVehicle* vehicle, CVector& position) {
   356:     return plugin::CallMethodAndReturn<int, 0x5160E0, CPed *, CVehicle*, CVector&>(this, vehicle, position);
   357  }

   360  bool CPed::GetNearestPassengerDoor(CVehicle* vehicle, CVector& position) {
   361:     return plugin::CallMethodAndReturn<bool, 0x515CE0, CPed *, CVehicle*, CVector&>(this, vehicle, position);
   362  }

   365  bool CPed::GetNearestTrainDoor(CVehicle* vehicle, CVector& position) {
   366:     return plugin::CallMethodAndReturn<bool, 0x514A70, CPed *, CVehicle*, CVector&>(this, vehicle, position);
   367  }

   370  bool CPed::GetNearestTrainPedPosition(CVehicle* vehicle, CVector& position) {
   371:     return plugin::CallMethodAndReturn<bool, 0x514650, CPed *, CVehicle*, CVector&>(this, vehicle, position);
   372  }

   375  int CPed::GetNextPointOnRoute() {
   376:     return plugin::CallMethodAndReturn<int, 0x51C9E0, CPed *>(this);
   377  }

   380  int CPed::GetPositionToOpenCarDoor(CVehicle* vehicle, unsigned int arg1) {
   381:     return plugin::CallAndReturn<int, 0x5164D0, CVehicle*, unsigned int>(vehicle, arg1);
   382  }

   385  int CPed::GetPositionToOpenCarDoor(CVehicle* vehicle, unsigned int arg1, float arg2) {
   386:     return plugin::CallAndReturn<int, 0x513080, CVehicle*, unsigned int, float>(vehicle, arg1, arg2);
   387  }

   390  int CPed::GetWeaponSlot(eWeaponType weaponType) {
   391:     return plugin::CallMethodAndReturn<int, 0x4FFA10, CPed *, eWeaponType>(this, weaponType);
   392  }

   395  void CPed::GiveDelayedWeapon(eWeaponType weaponType, unsigned int ammo) {
   396:     plugin::CallMethod<0x4FFC30, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);
   397  }

   400  void CPed::GiveWeapon(eWeaponType weaponType, unsigned int ammo, bool likeUnused) {
   401:     plugin::CallMethod<0x4FFA30, CPed *, eWeaponType, unsigned int, bool>(this, weaponType, ammo, likeUnused);
   402  }

   405  void CPed::GrantAmmo(eWeaponType weaponType, unsigned int ammo) {
   406:     plugin::CallMethod<0x4FF840, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);
   407  }

   410  bool CPed::HasAttractor() {
   411:     return plugin::CallMethodAndReturn<bool, 0x4EF8A0, CPed *>(this);
   412  }

   415  bool CPed::HaveReachedNextPointOnRoute(float arg0) {
   416:     return plugin::CallMethodAndReturn<bool, 0x51C970, CPed *, float>(this, arg0);
   417  }

   420  void CPed::Idle() {
   421:     plugin::CallMethod<0x4FDEB0, CPed *>(this);
   422  }

   425  void CPed::InTheAir() {
   426:     plugin::CallMethod<0x4FD4D0, CPed *>(this);
   427  }

   430  void CPed::InflictDamage(void* arg0, eWeaponType weaponType, float arg2, ePedPieceTypes arg3, unsigned char arg4) {
   431:     plugin::CallMethod<0x525B20, CPed *, void*, eWeaponType, float, ePedPieceTypes, unsigned char>(this, arg0, weaponType, arg2, arg3, arg4);
   432  }

   435  void CPed::InformMyGangOfAttack(CEntity* entity) {
   436:     plugin::CallMethod<0x512950, CPed *, CEntity*>(this, entity);
   437  }

   440  void CPed::Initialise() {
   441:     plugin::Call<0x50D9F0>();
   442  }

   445  void CPed::InvestigateEvent() {
   446:     plugin::CallMethod<0x526C60, CPed *>(this);
   447  }

   450  bool CPed::IsGangMember() {
   451:     return plugin::CallMethodAndReturn<bool, 0x4F4910, CPed *>(this);
   452  }

   455  bool CPed::IsPedDoingDriveByShooting() {
   456:     return plugin::CallMethodAndReturn<bool, 0x5C84D0, CPed *>(this);
   457  }

   460  bool CPed::IsPedHeadAbovePos(float zPos) {
   461:     return plugin::CallMethodAndReturn<bool, 0x525960, CPed *, float>(this, zPos);
   462  }

   465  bool CPed::IsPedInControl() {
   466:     return plugin::CallMethodAndReturn<bool, 0x501950, CPed *>(this);
   467  }

   470  bool CPed::IsPedShootable() {
   471:     return plugin::CallMethodAndReturn<bool, 0x501930, CPed *>(this);
   472  }

   475  bool CPed::IsPlayer() {
   476:     return plugin::CallMethodAndReturn<bool, 0x4F4930, CPed *>(this);
   477  }

   480  bool CPed::IsPointerValid() {
   481:     return plugin::CallMethodAndReturn<bool, 0x4F4860, CPed *>(this);
   482  }

   486  bool CPed::IsRoomToBeCarJacked() {
   487:     return plugin::CallMethodAndReturn<bool, 0x512670, CPed *>(this);
   488  	

   492  void CPed::KillCharOnFootArmed(CVector& arg0, CVector& arg1, CVector& arg2) {
   493:     plugin::CallMethod<0x50FFC0, CPed *, CVector&, CVector&, CVector&>(this, arg0, arg1, arg2);
   494  }

   497  void CPed::KillCharOnFootMelee(CVector& arg0, CVector& arg1, CVector& arg2) {
   498:     plugin::CallMethod<0x50F170, CPed *, CVector&, CVector&, CVector&>(this, arg0, arg1, arg2);
   499  }

   502  void CPed::KillPedWithCar(CVehicle* vehicle, float arg1) {
   503:     plugin::CallMethod<0x523CD0, CPed *, CVehicle*, float>(this, vehicle, arg1);
   504  }

   507  void CPed::LineUpPedWithCar(unsigned int arg0) {
   508:     plugin::CallMethod<0x518AD0, CPed *, unsigned int>(this, arg0);
   509  }

   512  void CPed::LoadFightData() {
   513:     plugin::Call<0x527570>();
   514  }

   517  void CPed::LookForInterestingNodes() {
   518:     plugin::CallMethod<0x4F3540, CPed *>(this);
   519  }

   522  void CPed::LookForSexyCars() {
   523:     plugin::CallMethod<0x4F3EB0, CPed *>(this);
   524  }

   527  void CPed::LookForSexyPeds() {
   528:     plugin::CallMethod<0x4F4090, CPed *>(this);
   529  }

   532  bool CPed::MakePhonecall() {
   533:     return plugin::CallMethodAndReturn<bool, 0x4F5B40, CPed *>(this);
   534  }

   537  void CPed::MakeTyresMuddySectorList(CPtrList& ptrList) {
   538:     plugin::CallMethod<0x5870D0, CPed *, CPtrList&>(this, ptrList);
   539  }

   542  void CPed::MoveHeadToLook() {
   543:     plugin::CallMethod<0x50B700, CPed *>(this);
   544  }

   547  void CPed::Mug() {
   548:     plugin::CallMethod<0x4FCD30, CPed *>(this);
   549  }

   552  bool CPed::OurPedCanSeeThisOne(CEntity* entity, bool arg1) {
   553:     return plugin::CallMethodAndReturn<bool, 0x50D360, CPed *, CEntity*, bool>(this, entity, arg1);
   554  }

   557  void CPed::Pause() {
   558:     plugin::CallMethod<0x4FDE80, CPed *>(this);
   559  }

   562  void CPed::PedShuffle() {
   563:     plugin::CallMethod<0x51A2F0, CPed *>(this);
   564  }

   567  bool CPed::PlacePedOnDryLand() {
   568:     return plugin::CallMethodAndReturn<bool, 0x5256A0, CPed *>(this);
   569  }

   572  void CPed::PlayFootSteps() {
   573:     plugin::CallMethod<0x503680, CPed *>(this);
   574  }

   577  void CPed::PlayHitSound(CPed* ped) {
   578:     plugin::CallMethod<0x528850, CPed *, CPed*>(this, ped);
   579  }

   582  short CPed::PointGunAt() {
   583:     return plugin::CallMethodAndReturn<short, 0x52DCD0, CPed *>(this);
   584  }

   587  bool CPed::PositionAnyPedOutOfCollision() {
   588:     return plugin::CallMethodAndReturn<bool, 0x511840, CPed *>(this);
   589  }

   592  void CPed::PositionAttachedPed() {
   593:     plugin::CallMethod<0x4EF0A0, CPed *>(this);
   594  }

   597  bool CPed::PositionPedOutOfCollision() {
   598:     return plugin::CallMethodAndReturn<bool, 0x511B10, CPed *>(this);
   599  }

   602  bool CPed::PossiblyFindBetterPosToSeekCar(CVector* arg0, CVehicle* vehicle) {
   603:     return plugin::CallMethodAndReturn<bool, 0x4F0810, CPed *, CVector*, CVehicle*>(this, arg0, vehicle);
   604  }

   607  void CPed::ProcessBuoyancy() {
   608:     plugin::CallMethod<0x509460, CPed *>(this);
   609  }

   612  void CPed::ProcessObjective() {
   613:     plugin::CallMethod<0x51CA70, CPed *>(this);
   614  }

   617  void CPed::QuitEnteringCar() {
   618:     plugin::CallMethod<0x5179D0, CPed *>(this);
   619  }

   622  void CPed::ReactToAttack(CEntity* entity) {
   623:     plugin::CallMethod<0x51BDA0, CPed *, CEntity*>(this, entity);
   624  }

   627  void CPed::ReactToPointGun(CEntity* entity) {
   628:     plugin::CallMethod<0x51C1E0, CPed *, CEntity*>(this, entity);
   629  }

   632  void CPed::RegisterThreatWithGangPeds(CEntity* entity) {
   633:     plugin::CallMethod<0x514360, CPed *, CEntity*>(this, entity);
   634  }

   637  void CPed::RemoveDrivebyAnims() {
   638:     plugin::CallMethod<0x512480, CPed *>(this);
   639  }

   642  void CPed::RemoveInCarAnims(bool arg0) {
   643:     plugin::CallMethod<0x512440, CPed *, bool>(this, arg0);
   644  }

   647  void CPed::RemoveWeaponAnims(int likeUnused, float blendDelta) {
   648:     plugin::CallMethod<0x5229B0, CPed *, int, float>(this, likeUnused, blendDelta);
   649  }

   652  void CPed::RemoveWeaponModel(int modelIndex) {
   653:     plugin::CallMethod<0x4FFD80, CPed *, int>(this, modelIndex);
   654  }

   657  void CPed::RemoveWeaponWhenEnteringVehicle() {
   658:     plugin::CallMethod<0x4FF6A0, CPed *>(this);
   659  }

   662  void CPed::ReplaceWeaponWhenExitingVehicle() {
   663:     plugin::CallMethod<0x4FF5A0, CPed *>(this);
   664  }

   667  void CPed::RequestDelayedWeapon() {
   668:     plugin::CallMethod<0x4FFCE0, CPed *>(this);
   669  }

   672  void CPed::RestartNonPartialAnims() {
   673:     plugin::CallMethod<0x50CCF0, CPed *>(this);
   674  }

   677  void CPed::RestoreGunPosition() {
   678:     plugin::CallMethod<0x50B250, CPed *>(this);
   679  }

   682  void CPed::RestoreHeadPosition() {
   683:     plugin::CallMethod<0x50B650, CPed *>(this);
   684  }

   687  void CPed::RestoreHeadingRate() {
   688:     plugin::CallMethod<0x4F17D0, CPed *>(this);
   689  }

   692  void CPed::RestorePreviousObjective() {
   693:     plugin::CallMethod<0x520FE0, CPed *>(this);
   694  }

   697  void CPed::RestorePreviousState() {
   698:     plugin::CallMethod<0x50C600, CPed *>(this);
   699  }

   702  void CPed::Say(unsigned short arg0) {
   703:     plugin::CallMethod<0x5226B0, CPed *, unsigned short>(this, arg0);
   704  }

   707  void CPed::Say(unsigned short arg0, int arg1) {
   708:     plugin::CallMethod<0x4EEFA0, CPed *, unsigned short, int>(this, arg0, arg1);
   709  }

   712  void CPed::ScanForDelayedResponseThreats() {
   713:     plugin::CallMethod<0x50BD80, CPed *>(this);
   714  }

   717  void CPed::ScanForInterestingStuff() {
   718:     plugin::CallMethod<0x50AD50, CPed *>(this);
   719  }

   722  void CPed::ScanForThreats() {
   723:     plugin::CallMethod<0x50BE00, CPed *>(this);
   724  }

   727  bool CPed::Seek() {
   728:     return plugin::CallMethodAndReturn<bool, 0x4FBD00, CPed *>(this);
   729  }

   732  void CPed::SeekBoatPosition() {
   733:     plugin::CallMethod<0x512740, CPed *>(this);
   734  }

   737  void CPed::SeekCar() {
   738:     plugin::CallMethod<0x4F4AD0, CPed *>(this);
   739  }

   742  void CPed::SeekFollowingPath() {
   743:     plugin::CallMethod<0x4FA1C0, CPed *>(this);
   744  }

   747  bool CPed::SelectGunIfArmed() {
   748:     return plugin::CallMethodAndReturn<bool, 0x51C800, CPed *>(this);
   749  }

   752  void CPed::ServiceTalking() {
   753:     plugin::CallMethod<0x522850, CPed *>(this);
   754  }

   757  bool CPed::ServiceTalkingWhenDead() {
   758:     return plugin::CallMethodAndReturn<bool, 0x522990, CPed *>(this);
   759  }

   762  void CPed::SetAimFlag(CEntity* aimingTo) {
   763:     plugin::CallMethod<0x50B510, CPed *, CEntity*>(this, aimingTo);
   764  }

   767  void CPed::SetAimFlag(float heading) {
   768:     plugin::CallMethod<0x50B5B0, CPed *, float>(this, heading);
   769  }

   772  void CPed::SetAmmo(eWeaponType weaponType, unsigned int ammo) {
   773:     plugin::CallMethod<0x4FF780, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);
   774  }

   777  void CPed::SetAnimOffsetForEnterOrExitVehicle() {
   778:     plugin::Call<0x5155E0>();
   779  }

   782  void CPed::SetAnswerMobile() {
   783:     plugin::CallMethod<0x4F59C0, CPed *>(this);
   784  }

   787  void CPed::SetAttack(CEntity* entity) {
   788:     plugin::CallMethod<0x52D1C0, CPed *, CEntity*>(this, entity);
   789  }

   792  void CPed::SetAttackTimer(unsigned int time) {
   793:     plugin::CallMethod<0x4FCAB0, CPed *, unsigned int>(this, time);
   794  }

   797  void CPed::SetBeingDraggedFromCar(CVehicle* vehicle, unsigned int arg1, bool arg2) {
   798:     plugin::CallMethod<0x518430, CPed *, CVehicle*, unsigned int, bool>(this, vehicle, arg1, arg2);
   799  }

   802  void CPed::SetCarJack(CVehicle* vehicle) {
   803:     plugin::CallMethod<0x5188A0, CPed *, CVehicle*>(this, vehicle);
   804  }

   807  void CPed::SetCarJack_AllClear(CVehicle* vehicle, unsigned int arg1, unsigned int arg2) {
   808:     plugin::CallMethod<0x518690, CPed *, CVehicle*, unsigned int, unsigned int>(this, vehicle, arg1, arg2);
   809  }

   812  void CPed::SetChat(CEntity* entity, unsigned int arg1) {
   813:     plugin::CallMethod<0x4F6220, CPed *, CEntity*, unsigned int>(this, entity, arg1);
   814  }

   817  void CPed::SetCurrentWeapon(eWeaponType weaponType) {
   818:     plugin::CallMethod<0x4FF8E0, CPed *, eWeaponType>(this, weaponType);
   819  }

   822  void CPed::SetCurrentWeapon(int slot) {
   823:     plugin::CallMethod<0x4FF900, CPed *, int>(this, slot);
   824  }

   827  void CPed::SetDead() {
   828:     plugin::CallMethod<0x4F6430, CPed *>(this);
   829  }

   832  //void CPed::SetDie(AnimationId arg0, float arg1, float arg2) {
   833: //    plugin::CallMethod<0x4F65C0, CPed *, AnimationId, float, float>(this, arg0, arg1, arg2);
   834  //}

   837  void CPed::SetDirectionToWalkAroundObject(CEntity* entity) {
   838:     plugin::CallMethod<0x5019A0, CPed *, CEntity*>(this, entity);
   839  }

   842  void CPed::SetDirectionToWalkAroundVehicle(CVehicle* vehicle) {
   843:     plugin::CallMethod<0x5035B0, CPed *, CVehicle*>(this, vehicle);
   844  }

   847  void CPed::SetDuck(unsigned int arg0, bool arg1) {
   848:     plugin::CallMethod<0x512C10, CPed *, unsigned int, bool>(this, arg0, arg1);
   849  }

   852  void CPed::SetEnterCar(CVehicle* vehicle, unsigned int arg1) {
   853:     plugin::CallMethod<0x518080, CPed *, CVehicle*, unsigned int>(this, vehicle, arg1);
   854  }

   857  void CPed::SetEnterCar_AllClear(CVehicle* vehicle, unsigned int arg1, unsigned int arg2) {
   858:     plugin::CallMethod<0x517DE0, CPed *, CVehicle*, unsigned int, unsigned int>(this, vehicle, arg1, arg2);
   859  }

   862  void CPed::SetEvasiveDive(CPhysical* arg0, unsigned char arg1) {
   863:     plugin::CallMethod<0x4F6A20, CPed *, CPhysical*, unsigned char>(this, arg0, arg1);
   864  }

   867  void CPed::SetEvasiveStep(CPhysical* arg0, unsigned char arg1) {
   868:     plugin::CallMethod<0x4F7170, CPed *, CPhysical*, unsigned char>(this, arg0, arg1);
   869  }

   872  void CPed::SetExitBoat(CVehicle* boat) {
   873:     plugin::CallMethod<0x517670, CPed *, CVehicle*>(this, boat);
   874  }

   877  void CPed::SetExitCar(CVehicle* vehicle, unsigned int arg1) {
   878:     plugin::CallMethod<0x516C60, CPed *, CVehicle*, unsigned int>(this, vehicle, arg1);
   879  }

   882  //void CPed::SetFall(int arg0, AnimationId arg1, unsigned char arg2) {
   883: //    plugin::CallMethod<0x4FD9F0, CPed *, int, AnimationId, unsigned char>(this, arg0, arg1, arg2);
   884  //}

   887  void CPed::SetFlee(CEntity* arg0, int arg1) {
   888:     plugin::CallMethod<0x4FB820, CPed *, CEntity*, int>(this, arg0, arg1);
   889  }

   892  void CPed::SetFlee(CVector2D const& arg0, int arg1) {
   893:     plugin::CallMethod<0x4FBA90, CPed *, CVector2D const&, int>(this, arg0, arg1);
   894  }

   897  void CPed::SetFollowPath(CVector const& arg0, float arg1, eMoveState arg2, CEntity* arg3, CEntity* arg4, int arg5) {
   898:     plugin::CallMethod<0x4F9F60, CPed *, CVector const&, float, eMoveState, CEntity*, CEntity*, int>(this, arg0, arg1, arg2, arg3, arg4, arg5);
   899  }

   902  bool CPed::SetFollowPathDynamic() {
   903:     return plugin::CallMethodAndReturn<bool, 0x4F7990, CPed *>(this);
   904  }

   907  bool CPed::SetFollowPathStatic() {
   908:     return plugin::CallMethodAndReturn<bool, 0x4F99F0, CPed *>(this);
   909  }

   912  void CPed::SetFormation(eFormation arg0) {
   913:     plugin::CallMethod<0x51A020, CPed *, eFormation>(this, arg0);
   914  }

   917  void CPed::SetGetUp() {
   918:     plugin::CallMethod<0x4FCF60, CPed *>(this);
   919  }

   922  void CPed::SetIdle() {
   923:     plugin::CallMethod<0x4FDFD0, CPed *>(this);
   924  }

   927  void CPed::SetInTheAir() {
   928:     plugin::CallMethod<0x4FD610, CPed *>(this);
   929  }

   932  void CPed::SetInvestigateEvent(eEventType eventType, CVector2D arg1, float arg2, unsigned short arg3, float arg4) {
   933:     plugin::CallMethod<0x527490, CPed *, eEventType, CVector2D, float, unsigned short, float>(this, eventType, arg1, arg2, arg3, arg4);
   934  }

   937  void CPed::SetJump() {
   938:     plugin::CallMethod<0x4F03C0, CPed *>(this);
   939  }

   942  void CPed::SetLanding() {
   943:     plugin::CallMethod<0x4FD3A0, CPed *>(this);
   944  }

   947  void CPed::SetLeader(CPed* ped) {
   948:     plugin::CallMethod<0x4F07D0, CPed *, CPed*>(this, ped);
   949  }

   952  void CPed::SetLook(CEntity* entity) {
   953:     plugin::CallMethod<0x4FCB10, CPed *, CEntity*>(this, entity);
   954  }

   957  void CPed::SetLookFlag(CEntity* lookingTo, bool likeUnused, bool arg2) {
   958:     plugin::CallMethod<0x50BB70, CPed *, CEntity*, bool, bool>(this, lookingTo, likeUnused, arg2);
   959  }

   962  void CPed::SetLookFlag(float lookHeading, bool likeUnused, bool arg2) {
   963:     plugin::CallMethod<0x50BC40, CPed *, float, bool, bool>(this, lookHeading, likeUnused, arg2);
   964  }

   967  void CPed::SetLookTimer(unsigned int time) {
   968:     plugin::CallMethod<0x4FCAF0, CPed *, unsigned int>(this, time);
   969  }

   972  void CPed::SetMoveState(eMoveState moveState) {
   973:     plugin::CallMethod<0x50D110, CPed *, eMoveState>(this, moveState);
   974  }

   977  //void CPed::SetNewAttraction(CPedAttractor* arg0, CVector const& arg1, float arg2, float arg3, int arg4) {
   978: //    plugin::CallMethod<0x4EF7C0, CPed *, CPedAttractor*, CVector const&, float, float, int>(this, arg0, arg1, arg2, arg3, arg4);
   979  //}

   982  void CPed::SetObjective(eObjective objective) {
   983:     plugin::CallMethod<0x5224B0, CPed *, eObjective>(this, objective);
   984  }

   987  void CPed::SetObjective(eObjective objective, CVector arg1) {
   988:     plugin::CallMethod<0x521840, CPed *, eObjective, CVector>(this, objective, arg1);
   989  }

   992  void CPed::SetObjective(eObjective objective, float arg1, CVector const& arg2) {
   993:     plugin::CallMethod<0x5217E0, CPed *, eObjective, float, CVector const&>(this, objective, arg1, arg2);
   994  }

   997  void CPed::SetObjective(eObjective objective, short arg1, short arg2) {
   998:     plugin::CallMethod<0x521D10, CPed *, eObjective, short, short>(this, objective, arg1, arg2);
   999  }

  1002  void CPed::SetObjective(eObjective objective, void* arg1) {
  1003:     plugin::CallMethod<0x521F10, CPed *, eObjective, void*>(this, objective, arg1);
  1004  }

  1007  void CPed::SetObjectiveTimer(unsigned int time) {
  1008:     plugin::CallMethod<0x522660, CPed *, unsigned int>(this, time);
  1009  }

  1012  void CPed::SetPedPositionInCar() {
  1013:     plugin::CallMethod<0x4F42F0, CPed *>(this);
  1014  }

  1017  void CPed::SetPedStats(ePedStats statsType) {
  1018:     plugin::CallMethod<0x50D8E0, CPed *, ePedStats>(this, statsType);
  1019  }

  1022  void CPed::SetPointGunAt(CEntity* entity) {
  1023:     plugin::CallMethod<0x52DDF0, CPed *, CEntity*>(this, entity);
  1024  }

  1027  void CPed::SetRadioStation() {
  1028:     plugin::CallMethod<0x4EFBD0, CPed *>(this);
  1029  }

  1032  void CPed::SetSeek(CEntity* arg0, float arg1) {
  1033:     plugin::CallMethod<0x4FC570, CPed *, CEntity*, float>(this, arg0, arg1);
  1034  }

  1037  void CPed::SetSeek(CVector arg0, float arg1) {
  1038:     plugin::CallMethod<0x4FC740, CPed *, CVector, float>(this, arg0, arg1);
  1039  }

  1042  void CPed::SetSeekBoatPosition(CVehicle* boat) {
  1043:     plugin::CallMethod<0x512850, CPed *, CVehicle*>(this, boat);
  1044  }

  1047  void CPed::SetSeekCar(CVehicle* car, unsigned int arg1) {
  1048:     plugin::CallMethod<0x4F54D0, CPed *, CVehicle*, unsigned int>(this, car, arg1);
  1049  }

  1052  void CPed::SetShootTimer(unsigned int time) {
  1053:     plugin::CallMethod<0x4FCA90, CPed *, unsigned int>(this, time);
  1054  }

  1057  void CPed::SetSolicit(unsigned int arg0) {
  1058:     plugin::CallMethod<0x4F1400, CPed *, unsigned int>(this, arg0);
  1059  }

  1062  void CPed::SetStoredObjective() {
  1063:     plugin::CallMethod<0x522620, CPed *>(this);
  1064  }

  1067  void CPed::SetStoredState() {
  1068:     plugin::CallMethod<0x50CC40, CPed *>(this);
  1069  }

  1072  void CPed::SetWaitState(eWaitState waitState, void* arg1) {
  1073:     plugin::CallMethod<0x4F28A0, CPed *, eWaitState, void*>(this, waitState, arg1);
  1074  }

  1077  void CPed::SetWanderPath(char arg0) {
  1078:     plugin::CallMethod<0x4FACC0, CPed *, signed>(this, arg0);
  1079  }

  1082  void CPed::Solicit() {
  1083:     plugin::CallMethod<0x4F11D0, CPed *>(this);
  1084  }

  1087  void CPed::SortPeds(CPed** pedList, int arg1, int arg2) {
  1088:     plugin::CallMethod<0x50D120, CPed *, CPed**, int, int>(this, pedList, arg1, arg2);
  1089  }

  1092  void CPed::SpawnFlyingComponent(int arg0, char arg1) {
  1093:     plugin::CallMethod<0x5259F0, CPed *, int, char>(this, arg0, arg1);
  1094  }

  1097  void CPed::StartFightAttack(unsigned char arg0) {
  1098:     plugin::CallMethod<0x52AD70, CPed *, unsigned char>(this, arg0);
  1099  }

  1102  void CPed::StartFightDefend(unsigned char arg0, unsigned char arg1, unsigned char arg2) {
  1103:     plugin::CallMethod<0x52A340, CPed *, unsigned char, unsigned char, unsigned char>(this, arg0, arg1, arg2);
  1104  }

  1107  void CPed::StopNonPartialAnims() {
  1108:     plugin::CallMethod<0x50CD20, CPed *>(this);
  1109  }

  1112  bool CPed::TurnBody() {
  1113:     return plugin::CallMethodAndReturn<bool, 0x4FC970, CPed *>(this);
  1114  }

  1117  void CPed::Undress(char const* modelName) {
  1118:     plugin::CallMethod<0x4EF030, CPed *, char const*>(this, modelName);
  1119  }

  1122  void CPed::UpdateFromLeader() {
  1123:     plugin::CallMethod<0x521070, CPed *>(this);
  1124  }

  1127  void CPed::UpdatePosition() {
  1128:     plugin::CallMethod<0x50A040, CPed *>(this);
  1129  }

  1132  bool CPed::UseGroundColModel() {
  1133:     return plugin::CallMethodAndReturn<bool, 0x501900, CPed *>(this);
  1134  }

  1137  void CPed::Wait() {
  1138:     plugin::CallMethod<0x4F18A0, CPed *>(this);
  1139  }

  1142  void CPed::WanderPath() {
  1143:     plugin::CallMethod<0x4FA680, CPed *>(this);
  1144  }

  1147  void CPed::WarpPedIntoCar(CVehicle* vehicle) {
  1148:     plugin::CallMethod<0x4EF8B0, CPed *, CVehicle*>(this, vehicle);
  1149  }

  1152  void CPed::WarpPedToNearEntityOffScreen(CEntity* entity) {
  1153:     plugin::CallMethod<0x5110C0, CPed *, CEntity*>(this, entity);
  1154  }

  1157  void CPed::WarpPedToNearLeaderOffScreen() {
  1158:     plugin::CallMethod<0x511480, CPed *>(this);
  1159  }

  1162  bool CPed::WillChat(CPed* ped) {
  1163:     return plugin::CallMethodAndReturn<bool, 0x50AC70, CPed *, CPed*>(this, ped);
  1164  }

  1167  float CPed::WorkOutHeadingForMovingFirstPerson(float heading) {
  1168:     return plugin::CallMethodAndReturn<float, 0x50A530, CPed *, float>(this, heading);
  1169  }

  1172  void CPed::operator delete(void* data) {
  1173:     plugin::Call<0x50DA20, void*>(data);
  1174  }

  1177  void* CPed::operator new(unsigned int size) {
  1178:     return plugin::CallAndReturn<void*, 0x50DA60, unsigned int>(size);
  1179  }

  1182  void* CPed::operator new(unsigned int size, int arg1) {
  1183:     return plugin::CallAndReturn<void*, 0x50DA40, unsigned int, int>(size, arg1);
  1184  }

  1189  plugin::dummy, plugin::dummy, plugin::dummy, plugin::dummy, plugin::dummy, plugin::dummy, plugin::dummy } {
  1190:     plugin::CallMethod<0x50DC20, CPed *, ePedType>(this, pedType);
  1191  }

plugin_vc\game_vc\CPedAtmAttractor.cpp:
  20  ePedAttractorType CPedAtmAttractor::GetType() {
  21:     return plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedAtmAttractor *>(this);
  22  }

  27  void CPedAtmAttractor::UpdatePedStateOnDeparture(CPed *ped) {
  28:     plugin::CallVirtualMethod<3, CPedAtmAttractor *, CPed *>(this, ped);
  29  }

plugin_vc\game_vc\CPedAttractor.cpp:
  20  float CPedAttractor::GetHeadOfQueueWaitTime() {
  21:     return plugin::CallVirtualMethodAndReturn<float, 0, CPedAttractor *>(this);
  22  }

  30  bool CPedAttractor::IsAtHeadOfQueue(CPed *ped) {
  31:     return plugin::CallVirtualMethodAndReturn<bool, 4, CPedAttractor *, CPed *>(this, ped);
  32  }

  37  void CPedAttractor::ComputeAttractPos(int qid, CVector &pos) {
  38:     plugin::CallVirtualMethod<5, CPedAttractor *, int, CVector &>(this, qid, pos);
  39  }

  44  void CPedAttractor::ComputeAttractHeading(int qid, float &heading) {
  45:     plugin::CallVirtualMethod<6, CPedAttractor *, int, float &>(this, qid, heading);
  46  }

  51  bool CPedAttractor::BroadcastDeparture(CPed *ped) {
  52:     return plugin::CallVirtualMethodAndReturn<bool, 7, CPedAttractor *, CPed *>(this, ped);
  53  }

  58  bool CPedAttractor::BroadcastArrival(CPed *ped) {
  59:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::BroadcastArrival), this, ped);
  60  }

  65  bool CPedAttractor::DeRegisterPed(CPed *ped) {
  66:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::DeRegisterPed), this, ped);
  67  }

  72  int CPedAttractor::GetNoOfRegisteredPeds() {
  73:     return plugin::CallMethodAndReturnDynGlobal<int, CPedAttractor *>(gaddrof(CPedAttractor::GetNoOfRegisteredPeds), this);
  74  }

  79  bool CPedAttractor::RegisterPed(CPed *ped) {
  80:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::RegisterPed), this, ped);
  81  }

plugin_vc\game_vc\CPedAttractorManager.cpp:
   16  bool CPedAttractorManager::BroadcastArrival(CPed *ped, CPedAttractor *attr) {
   17:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof_o(CPedAttractorManager::BroadcastArrival, bool (CPedAttractorManager::*)(CPed *, CPedAttractor *)), this, ped, attr);
   18  }

   23  bool CPedAttractorManager::BroadcastDeparture(CPed *ped, CPedAttractor *attr) {
   24:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof_o(CPedAttractorManager::BroadcastDeparture, bool (CPedAttractorManager::*)(CPed *, CPedAttractor *)), this, ped, attr);
   25  }

   30  bool CPedAttractorManager::DeRegisterPed(CPed *ped, CPedAttractor *attr) {
   31:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof_o(CPedAttractorManager::DeRegisterPed, bool (CPedAttractorManager::*)(CPed *, CPedAttractor *)), this, ped, attr);
   32  }

   37  bool CPedAttractorManager::HasEmptySlot(C2dEffect const *effect) {
   38:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, C2dEffect const *>(gaddrof(CPedAttractorManager::HasEmptySlot), this, effect);
   39  }

   44  bool CPedAttractorManager::IsAtHeadOfQueue(CPed *ped, CPedAttractor *attr) {
   45:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof(CPedAttractorManager::IsAtHeadOfQueue), this, ped, attr);
   46  }

   51  bool CPedAttractorManager::IsInQueue(CPed *ped, CPedAttractor *attr) {
   52:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof(CPedAttractorManager::IsInQueue), this, ped, attr);
   53  }

   58  bool CPedAttractorManager::IsPedRegisteredWithEffect(CPed *ped) {
   59:     return plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *>(gaddrof(CPedAttractorManager::IsPedRegisteredWithEffect), this, ped);
   60  }

   65  CPedAttractor *CPedAttractorManager::RegisterPedWithAttractor(CPed *ped, C2dEffect *effect, CMatrix const &matrix) {
   66:     return plugin::CallMethodAndReturnDynGlobal<CPedAttractor *, CPedAttractorManager *, CPed *, C2dEffect *, CMatrix const &>(gaddrof(CPedAttractorManager::RegisterPedWithAttractor), this, ped, effect, matrix);
   67  }

   72  bool CPedAttractorManager::BroadcastArrival(CPed *ped, CPedAttractor *attr, std::vector<CPedAttractor *> &vecAttractors) {
   73:     return plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &>(gaddrof_o(CPedAttractorManager::BroadcastArrival, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &)), ped, attr, vecAttractors);
   74  }

   79  bool CPedAttractorManager::BroadcastDeparture(CPed *ped, CPedAttractor *attr, std::vector<CPedAttractor *> &vecAttractors) {
   80:     return plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &>(gaddrof_o(CPedAttractorManager::BroadcastDeparture, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &)), ped, attr, vecAttractors);
   81  }

   86  void CPedAttractorManager::ComputeEffectPos(C2dEffect const *effect, CMatrix const &matrix, CVector &pos) {
   87:     plugin::CallDynGlobal<C2dEffect const *, CMatrix const &, CVector &>(gaddrof(CPedAttractorManager::ComputeEffectPos), effect, matrix, pos);
   88  }

   93  bool CPedAttractorManager::DeRegisterPed(CPed *ped, CPedAttractor *attr, std::vector<CPedAttractor *> &vecAttractors) {
   94:     return plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &>(gaddrof_o(CPedAttractorManager::DeRegisterPed, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &)), ped, attr, vecAttractors);
   95  }

  100  bool CPedAttractorManager::IsApproachable(C2dEffect *effect, CMatrix const &matrix, int unk, CPed *ped) {
  101:     return plugin::CallAndReturnDynGlobal<bool, C2dEffect *, CMatrix const &, int, CPed *>(gaddrof(CPedAttractorManager::IsApproachable), effect, matrix, unk, ped);
  102  }

  107  CPedAttractor *CPedAttractorManager::RegisterPed(CPed *ped, C2dEffect *effect, CMatrix const &matrix, std::vector<CPedAttractor *> &vecAttractors) {
  108:     return plugin::CallAndReturnDynGlobal<CPedAttractor *, CPed *, C2dEffect *, CMatrix const &, std::vector<CPedAttractor *> &>(gaddrof(CPedAttractorManager::RegisterPed), ped, effect, matrix, vecAttractors);
  109  }

  114  CPedAttractorManager *GetPedAttractorManager() {
  115:     return plugin::CallAndReturnDynGlobal<CPedAttractorManager *>(gaddrof(GetPedAttractorManager));
  116  }

plugin_vc\game_vc\CPedIceCreamVanAttractor.cpp:
  17  ePedAttractorType CPedIceCreamVanAttractor::GetType() {
  18:     return plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedIceCreamVanAttractor *>(this);
  19  }

  21  void CPedIceCreamVanAttractor::UpdatePedStateOnDeparture(CPed *ped) {
  22:     plugin::CallVirtualMethod<3, CPedIceCreamVanAttractor *, CPed *>(this, ped);
  23  }

plugin_vc\game_vc\CPedIK.cpp:
  15  MoveLimbResult CPedIK::MoveLimb(LimbOrientation& limb, float yaw, float pitch, LimbMovementInfo& moveInfo) {
  16:     return plugin::CallMethodAndReturn<MoveLimbResult, 0x52F6E0, CPedIK*, LimbOrientation&, float, float, LimbMovementInfo&>(this, limb, yaw, pitch, moveInfo);
  17  }

  19  void CPedIK::GetComponentPosition(RwV3d& returnedPos, unsigned int boneIndex) {
  20:     plugin::CallMethod<0x52F9B0, CPedIK*, RwV3d&, unsigned int>(this, returnedPos, boneIndex);
  21  }

  23  void CPedIK::ExtractYawAndPitchWorld(RwMatrix* matrix, float* yaw, float* pitch) {
  24:     plugin::CallMethod<0x52F830, CPedIK*, RwMatrix*, float*, float*>(this, matrix, yaw, pitch);
  25  }

plugin_vc\game_vc\CPedModelInfo.cpp:
  10  void CPedModelInfo::AnimatePedColModelSkinned(RpClump* clump) {
  11:     plugin::CallMethod<0x566150, CPedModelInfo *, RpClump*>(this, clump);
  12  }

  15  void CPedModelInfo::AnimatePedColModelSkinnedWorld(RpClump* clump) {
  16:     plugin::CallMethod<0x566060, CPedModelInfo *, RpClump*>(this, clump);
  17  }

  20  void CPedModelInfo::CreateHitColModelSkinned(RpClump* clump) {
  21:     plugin::CallMethod<0x566300, CPedModelInfo *, RpClump*>(this, clump);
  22  }

  25  CPedModelInfo::CPedModelInfo() {
  26:     plugin::CallMethod<0x560120, CPedModelInfo *>(this);
  27  }

  30  CPedModelInfo::~CPedModelInfo() {
  31:     plugin::CallMethod<0x5600E0, CPedModelInfo *>(this);
  32  }

  35  PedModelStore::~PedModelStore() {
  36:     plugin::CallMethod<0x5600C0, PedModelStore *>(this);
  37  }

plugin_vc\game_vc\CPedPizzaAttractor.cpp:
  17  float CPedPizzaAttractor::GetHeadOfQueueWaitTime() {
  18:     return plugin::CallVirtualMethodAndReturn<float, 0, CPedPizzaAttractor *>(this);
  19  }

  24  ePedAttractorType CPedPizzaAttractor::GetType() {
  25:     return plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedPizzaAttractor *>(this);
  26  }

  28  void CPedPizzaAttractor::UpdatePedStateOnDeparture(CPed *ped) {
  29:     plugin::CallVirtualMethod<3, CPedPizzaAttractor *, CPed *>(this, ped);
  30  }

plugin_vc\game_vc\CPedPlacement.cpp:
  10  bool CPedPlacement::FindZCoorForPed(CVector* posn) {
  11:     return plugin::CallAndReturn<bool, 0x52FA60, CVector*>(posn);
  12  }

  15  bool CPedPlacement::IsPositionClearForPed(CVector const& posn, float arg1, int arg2, CEntity** entity) {
  16:     return plugin::CallAndReturn<bool, 0x52FBD0, CVector const&, float, int, CEntity**>(posn, arg1, arg2, entity);
  17  }

  20  bool CPedPlacement::IsPositionClearOfCars(CVector* posn) {
  21:     return plugin::CallAndReturn<bool, 0x52FBA0, CVector*>(posn);
  22  }

plugin_vc\game_vc\CPedSeatAttractor.cpp:
  17  ePedAttractorType CPedSeatAttractor::GetType() {
  18:     return plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedSeatAttractor *>(this);
  19  }

  21  void CPedSeatAttractor::UpdatePedStateOnDeparture(CPed *ped) {
  22:     plugin::CallVirtualMethod<3, CPedSeatAttractor *, CPed *>(this, ped);
  23  }

plugin_vc\game_vc\CPedShelterAttractor.cpp:
  19  ePedAttractorType CPedShelterAttractor::GetType() {
  20:     return plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedShelterAttractor *>(this);
  21  }

  23  void CPedShelterAttractor::UpdatePedStateOnDeparture(CPed *ped) {
  24:     plugin::CallVirtualMethod<3, CPedShelterAttractor *, CPed *>(this, ped);
  25  }

  30  bool CPedShelterAttractor::IsAtHeadOfQueue(CPed *ped) {
  31:     return plugin::CallVirtualMethodAndReturn<bool, 4, CPedShelterAttractor *, CPed *>(this, ped);
  32  }

  37  void CPedShelterAttractor::ComputeAttractPos(int qid, CVector &pos) {
  38:     plugin::CallVirtualMethod<5, CPedShelterAttractor *, int, CVector &>(this, qid, pos);
  39  }

  44  void CPedShelterAttractor::ComputeAttractHeading(int qid, float &heading) {
  45:     plugin::CallVirtualMethod<6, CPedShelterAttractor *, int, float &>(this, qid, heading);
  46  }

  51  bool CPedShelterAttractor::BroadcastDeparture(CPed *ped) {
  52:     return plugin::CallVirtualMethodAndReturn<bool, 7, CPedShelterAttractor *, CPed *>(this, ped);
  53  }

  59      CVector ret_displ;
  60:     plugin::CallDynGlobal<CVector *, int>(gaddrof(CPedShelterAttractor::GetDisplacement), &ret_displ, qid);
  61      return ret_displ;

plugin_vc\game_vc\CPedStats.cpp:
  15  void CPedStats::Initialise() {
  16:     plugin::Call<0x530260>();
  17  }

  20  void CPedStats::Shutdown() {
  21:     plugin::Call<0x530220>();
  22  }

  25  void CPedStats::LoadPedStats() {
  26:     plugin::Call<0x530020>();
  27  }

  30  unsigned int CPedStats::GetPedStatType(char* pedStatName) {
  31:     return plugin::CallAndReturn<unsigned int, 0x52FFC0, char*>(pedStatName);
  32  }

plugin_vc\game_vc\CPedStopAttractor.cpp:
  17  ePedAttractorType CPedStopAttractor::GetType() {
  18:     return plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedStopAttractor *>(this);
  19  }

  21  void CPedStopAttractor::UpdatePedStateOnDeparture(CPed *ped) {
  22:     plugin::CallVirtualMethod<3, CPedStopAttractor *, CPed *>(this, ped);
  23  }

plugin_vc\game_vc\CPedType.cpp:
  15  void CPedType::Initialise() {
  16:     plugin::Call<0x530F00>();
  17  }

  20  void CPedType::Shutdown() {
  21:     plugin::Call<0x530EC0>();
  22  }

  25  void CPedType::LoadPedData() {
  26:     plugin::Call<0x530B90>();
  27  }

  30  unsigned int CPedType::FindPedType(char* pedName) {
  31:     return plugin::CallAndReturn<unsigned int, 0x530860, char*>(pedName);
  32  }

  35  unsigned int CPedType::FindPedFlag(char* flagName) {
  36:     return plugin::CallAndReturn<unsigned int, 0x530480, char*>(flagName);
  37  }

  40  void CPedType::Save(unsigned char* bufferPointer, unsigned int* structSize) {
  41:     plugin::Call<0x5303D0, unsigned char*, unsigned int*>(bufferPointer, structSize);
  42  }

  45  void CPedType::Load(unsigned char* bufferPointer, unsigned int structSize) {
  46:     plugin::Call<0x530340, unsigned char*, unsigned int>(bufferPointer, structSize);
  47  }

plugin_vc\game_vc\CPhoneInfo.cpp:
  23  int CPhoneInfo::FindNearestFreePhone(CVector *point) {
  24:     return plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, CVector *>(gaddrof(CPhoneInfo::FindNearestFreePhone), this, point);
  25  }

  30  int CPhoneInfo::GrabPhone(float x, float y) {
  31:     return plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, float, float>(gaddrof(CPhoneInfo::GrabPhone), this, x, y);
  32  }

  37  void CPhoneInfo::Initialise() {
  38:     plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Initialise), this);
  39  }

  44  void CPhoneInfo::Load(unsigned char *bufferPointer, unsigned int structSize) {
  45:     plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int>(gaddrof(CPhoneInfo::Load), this, bufferPointer, structSize);
  46  }

  51  void CPhoneInfo::Save(unsigned char *bufferPointer, unsigned int *structSize) {
  52:     plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int *>(gaddrof(CPhoneInfo::Save), this, bufferPointer, structSize);
  53  }

  58  void CPhoneInfo::SetPhoneMessage_JustOnce(int index, wchar_t *text_1, wchar_t *text_2, wchar_t *text_3, wchar_t *text_4, wchar_t *text_5, wchar_t *text_6) {
  59:     plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_JustOnce), this, index, text_1, text_2, text_3, text_4, text_5, text_6);
  60  }

  65  void CPhoneInfo::Shutdown() {
  66:     plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Shutdown), this);
  67  }

  72  void CPhoneInfo::Update() {
  73:     plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Update), this);
  74  }

  79  void PhonePutDownCB(CAnimBlendAssociation *association, CPed *ped) {
  80:     plugin::CallDynGlobal<CAnimBlendAssociation *, CPed *>(gaddrof(PhonePutDownCB), association, ped);
  81  }

  86  void PhonePickUpCB(CAnimBlendAssociation *association, CPhone *phone) {
  87:     plugin::CallDynGlobal<CAnimBlendAssociation *, CPhone *>(gaddrof(PhonePickUpCB), association, phone);
  88  }

plugin_vc\game_vc\CPickups.cpp:
   31  int CPickup::GiveUsAPickUpObject(CObject** arg0, CObject** arg1, int arg2, int arg3) {
   32:     return plugin::CallMethodAndReturn<int, 0x43D3B0, CPickup *, CObject**, CObject**, int, int>(this, arg0, arg1, arg2, arg3);
   33  }

   36  void CPickup::Update(CPlayerPed* arg0, CVehicle* vehicle, int arg2) {
   37:     plugin::CallMethod<0x440030, CPickup *, CPlayerPed*, CVehicle*, int>(this, arg0, vehicle, arg2);
   38  }

   41  CPickup::CPickup() {
   42:     plugin::CallMethod<0x441F30, CPickup *>(this);
   43  }

   46  void CPickups::CreateSomeMoney(CVector posn, int arg1) {
   47:     plugin::Call<0x43E180, CVector, int>(posn, arg1);
   48  }

   51  void CPickups::DoCollectableEffects(CEntity* entity) {
   52:     plugin::Call<0x43ED40, CEntity*>(entity);
   53  }

   56  void CPickups::DoMineEffects(CEntity* entity) {
   57:     plugin::Call<0x43E840, CEntity*>(entity);
   58  }

   61  void CPickups::DoMoneyEffects(CEntity* entity) {
   62:     plugin::Call<0x43EAC0, CEntity*>(entity);
   63  }

   66  void CPickups::DoPickUpEffects(CEntity* entity) {
   67:     plugin::Call<0x43F050, CEntity*>(entity);
   68  }

   71  int CPickups::GenerateNewOne(CVector posn, unsigned int arg1, unsigned char arg2, unsigned int arg3, unsigned int arg4, bool arg5, char* msg) {
   72:     return plugin::CallAndReturn<int, 0x4418C0, CVector, unsigned int, unsigned char, unsigned int, unsigned int, bool, char*>(posn, arg1, arg2, arg3, arg4, arg5, msg);
   73  }

   76  int CPickups::GetActualPickupIndex(int handle) {
   77:     return plugin::CallAndReturn<int, 0x43D360, int>(handle);
   78  }

   81  bool CPickups::GivePlayerGoodiesWithPickUpMI(unsigned short model, int plrIndex) {
   82:     return plugin::CallAndReturn<bool, 0x43D910, unsigned short, int>(model, plrIndex);
   83  }

   86  void CPickups::Init() {
   87:     plugin::Call<0x441D30>();
   88  }

   91  bool CPickups::IsPickUpPickedUp(int handle) {
   92:     return plugin::CallAndReturn<bool, 0x441880, int>(handle);
   93  }

   96  void CPickups::Load(unsigned char* arg0, unsigned int arg1) {
   97:     plugin::Call<0x43CF40, unsigned char*, unsigned int>(arg0, arg1);
   98  }

  101  int CPickups::ModelForWeapon(eWeaponType weaponType) {
  102:     return plugin::CallAndReturn<int, 0x4418B0, eWeaponType>(weaponType);
  103  }

  106  void CPickups::PassTime(unsigned int time) {
  107:     plugin::Call<0x43D8C0, unsigned int>(time);
  108  }

  111  void CPickups::RemoveAllPickupsOfACertainWeaponGroupWithNoAmmo(eWeaponType weaponType) {
  112:     plugin::Call<0x43D240, eWeaponType>(weaponType);
  113  }

  116  void CPickups::RemovePickUp(int handle) {
  117:     plugin::Call<0x4417D0, int>(handle);
  118  }

  121  void CPickups::RemoveUnnecessaryPickups(CVector const& posn, float radius) {
  122:     plugin::Call<0x43E4C0, CVector const&, float>(posn, radius);
  123  }

  126  void CPickups::RenderPickUpText() {
  127:     plugin::Call<0x43E5E0>();
  128  }

  131  void CPickups::Save(unsigned char* arg0, unsigned int* arg1) {
  132:     plugin::Call<0x43D0D0, unsigned char*, unsigned int*>(arg0, arg1);
  133  }

  136  void CPickups::Update() {
  137:     plugin::Call<0x441BB0>();
  138  }

plugin_vc\game_vc\CPlane.cpp:
  10  CPlane::CPlane(int modelIndex, unsigned char createdBy) : CVehicle(plugin::dummy) {
  11:     plugin::CallMethod<0x5B2B50, CPlane *, int, unsigned char>(this, modelIndex, createdBy);
  12  }

  15  void CPlane::InitPlanes() {
  16:     plugin::Call<0x5B21E0>();
  17  }

  20  bool CPlane::Load() {
  21:     return plugin::CallAndReturn<bool, 0x5AFAD0>();
  22  }

  25  void CPlane::LoadPath(char const* arg0, int& arg1, float& arg2, bool arg3) {
  26:     plugin::Call<0x5B1FF0, char const*, int&, float&, bool>(arg0, arg1, arg2, arg3);
  27  }

  30  bool CPlane::Save() {
  31:     return plugin::CallAndReturn<bool, 0x5AFB80>();
  32  }

  35  void CPlane::Shutdown() {
  36:     plugin::Call<0x5B2160>();
  37  }

  40  bool CPlane::TestRocketCollision(CVector* arg0) {
  41:     return plugin::CallAndReturn<bool, 0x5AFC90, CVector*>(arg0);
  42  }

  45  void CPlane::UpdatePlanes() {
  46:     plugin::Call<0x5B19D0>();
  47  }

plugin_vc\game_vc\CPlayerPed.cpp:
   10  void CPlayerPed::AnnoyPlayerPed(bool arg0) {
   11:     plugin::CallMethod<0x531CF0, CPlayerPed *, bool>(this, arg0);
   12  }

   15  CPlayerPed::CPlayerPed() : CPed(plugin::dummy) {
   16:     plugin::CallMethod<0x5384B0, CPlayerPed *>(this);
   17  }

   20  void CPlayerPed::ClearAdrenaline() {
   21:     plugin::CallMethod<0x531CC0, CPlayerPed *>(this);
   22  }

   25  void CPlayerPed::ClearWeaponTarget() {
   26:     plugin::CallMethod<0x533B30, CPlayerPed *>(this);
   27  }

   30  void CPlayerPed::DeactivatePlayerPed(int playerId) {
   31:     plugin::Call<0x5383C0, int>(playerId);
   32  }

   35  void CPlayerPed::DoStuffToGoOnFire() {
   36:     plugin::CallMethod<0x531D20, CPlayerPed *>(this);
   37  }

   40  float CPlayerPed::DoWeaponSmoothSpray() {
   41:     return plugin::CallMethodAndReturn<float, 0x536410, CPlayerPed *>(this);
   42  }

   45  bool CPlayerPed::DoesPlayerWantNewWeapon(eWeaponType weaponType, bool enable) {
   46:     return plugin::CallMethodAndReturn<bool, 0x535240, CPlayerPed *, eWeaponType, bool>(this, weaponType, enable);
   47  }

   50  void CPlayerPed::EvaluateNeighbouringTarget(CEntity* target, CEntity** outTarget, float* outTargetPriority, float maxDistance, float arg4, bool arg5, bool arg6, bool arg7) {
   51:     plugin::CallMethod<0x5320B0, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool, bool, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6, arg7);
   52  }

   55  void CPlayerPed::EvaluateTarget(CEntity* target, CEntity** outTarget, float* outTargetPriority, float maxDistance, float arg4, bool arg5, bool arg6) {
   56:     plugin::CallMethod<0x532360, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6);
   57  }

   60  int CPlayerPed::FindMeleeAttackPoint(CPed* arg0, CVector& arg1, unsigned int& arg2) {
   61:     return plugin::CallMethodAndReturn<int, 0x531390, CPlayerPed *, CPed*, CVector&, unsigned int&>(this, arg0, arg1, arg2);
   62  }

   65  short CPlayerPed::FindNewAttackPoints() {
   66:     return plugin::CallMethodAndReturn<short, 0x531810, CPlayerPed *>(this);
   67  }

   70  bool CPlayerPed::FindNextWeaponLockOnTarget(CEntity* target, bool arg1) {
   71:     return plugin::CallMethodAndReturn<bool, 0x532590, CPlayerPed *, CEntity*, bool>(this, target, arg1);
   72  }

   75  bool CPlayerPed::FindWeaponLockOnTarget() {
   76:     return plugin::CallMethodAndReturn<bool, 0x533030, CPlayerPed *>(this);
   77  }

   80  CPlayerInfo* CPlayerPed::GetPlayerInfoForThisPlayerPed() {
   81:     return plugin::CallMethodAndReturn<CPlayerInfo*, 0x531D40, CPlayerPed *>(this);
   82  }

   85  void CPlayerPed::KeepAreaAroundPlayerClear() {
   86:     plugin::CallMethod<0x531D60, CPlayerPed *>(this);
   87  }

   90  void CPlayerPed::MakeChangesForNewWeapon(eWeaponType weaponType) {
   91:     plugin::CallMethod<0x534450, CPlayerPed *, eWeaponType>(this, weaponType);
   92  }

   95  void CPlayerPed::MakeChangesForNewWeapon(int weaponSlot) {
   96:     plugin::CallMethod<0x534580, CPlayerPed *, int>(this, weaponSlot);
   97  }

  100  void CPlayerPed::MakeObjectTargettable(int arg0, bool arg1) {
  101:     plugin::CallMethod<0x531FD0, CPlayerPed *, int, bool>(this, arg0, arg1);
  102  }

  105  void CPlayerPed::PlayIdleAnimations(CPad* pad) {
  106:     plugin::CallMethod<0x535D10, CPlayerPed *, CPad*>(this, pad);
  107  }

  110  void CPlayerPed::PlayerControl1stPersonRunAround(CPad* pad) {
  111:     plugin::CallMethod<0x5357D0, CPlayerPed *, CPad*>(this, pad);
  112  }

  115  void CPlayerPed::PlayerControlFighter(CPad* pad) {
  116:     plugin::CallMethod<0x535BB0, CPlayerPed *, CPad*>(this, pad);
  117  }

  120  void CPlayerPed::PlayerControlM16(CPad* pad) {
  121:     plugin::CallMethod<0x5352B0, CPlayerPed *, CPad*>(this, pad);
  122  }

  125  void CPlayerPed::PlayerControlSniper(CPad* pad) {
  126:     plugin::CallMethod<0x535550, CPlayerPed *, CPad*>(this, pad);
  127  }

  130  void CPlayerPed::PlayerControlZelda(CPad* pad) {
  131:     plugin::CallMethod<0x535F40, CPlayerPed *, CPad*>(this, pad);
  132  }

  135  void CPlayerPed::ProcessAnimGroups() {
  136:     plugin::CallMethod<0x533B80, CPlayerPed *>(this);
  137  }

  140  void CPlayerPed::ProcessPlayerWeapon(CPad* pad) {
  141:     plugin::CallMethod<0x534890, CPlayerPed *, CPad*>(this, pad);
  142  }

  145  void CPlayerPed::ProcessWeaponSwitch(CPad* pad) {
  146:     plugin::CallMethod<0x5345A0, CPlayerPed *, CPad*>(this, pad);
  147  }

  150  void CPlayerPed::ReApplyMoveAnims() {
  151:     plugin::CallMethod<0x5371B0, CPlayerPed *>(this);
  152  }

  155  void CPlayerPed::ReactivatePlayerPed(int playerId) {
  156:     plugin::Call<0x5383A0, int>(playerId);
  157  }

  160  void CPlayerPed::RemovePedFromMeleeList(CPed* ped) {
  161:     plugin::CallMethod<0x5312A0, CPlayerPed *, CPed*>(this, ped);
  162  }

  165  void CPlayerPed::SetInitialState() {
  166:     plugin::CallMethod<0x5381F0, CPlayerPed *>(this);
  167  }

  170  void CPlayerPed::SetNearbyPedsToInteractWithPlayer() {
  171:     plugin::CallMethod<0x530FB0, CPlayerPed *>(this);
  172  }

  175  void CPlayerPed::SetRealMoveAnim() {
  176:     plugin::CallMethod<0x536620, CPlayerPed *>(this);
  177  }

  180  void CPlayerPed::SetWantedLevel(int level) {
  181:     plugin::CallMethod<0x532090, CPlayerPed *, int>(this, level);
  182  }

  185  void CPlayerPed::SetWantedLevelNoDrop(int level) {
  186:     plugin::CallMethod<0x532070, CPlayerPed *, int>(this, level);
  187  }

  190  void CPlayerPed::SetupPlayerPed(int playerId) {
  191:     plugin::Call<0x5383E0, int>(playerId);
  192  }

  195  void CPlayerPed::UpdateMeleeAttackers() {
  196:     plugin::CallMethod<0x531600, CPlayerPed *>(this);
  197  }

  200  int CPlayerPed::GetWantedLevel() {
  201:     return plugin::CallMethodAndReturn<int, 0x599B20, CPlayerPed *>(this);
  202  }

plugin_vc\game_vc\CPlayerSkin.cpp:
  12  void CPlayerSkin::BeginFrontendSkinEdit() {
  13:     plugin::Call<0x627D10>();
  14  }

  17  void CPlayerSkin::EndFrontendSkinEdit() {
  18:     plugin::Call<0x627CE0>();
  19  }

  22  int CPlayerSkin::GetSkinTexture(char const* arg0) {
  23:     return plugin::CallAndReturn<int, 0x627E60, char const*>(arg0);
  24  }

  27  void CPlayerSkin::Initialise() {
  28:     plugin::Call<0x627FB0>();
  29  }

  32  void CPlayerSkin::RenderFrontendSkinEdit() {
  33:     plugin::Call<0x627BC0>();
  34  }

  37  void CPlayerSkin::Shutdown() {
  38:     plugin::Call<0x627FA0>();
  39  }

plugin_vc\game_vc\CPointLights.cpp:
  20  void CPointLights::AddLight(unsigned char lightType, CVector point, CVector direction, float range, float red, float green, float blue, unsigned char fogType, bool generateExtraShadows) {
  21:     plugin::CallDynGlobal<unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool>(gaddrof(CPointLights::AddLight), lightType, point, direction, range, red, green, blue, fogType, generateExtraShadows);
  22  }

  27  float CPointLights::GenerateLightsAffectingObject(CVector *point) {
  28:     return plugin::CallAndReturnDynGlobal<float, CVector *>(gaddrof(CPointLights::GenerateLightsAffectingObject), point);
  29  }

plugin_vc\game_vc\CPools.cpp:
   32  CObject *CPools::GetObject(int handle) {
   33:     return plugin::CallAndReturnDynGlobal<CObject *, int>(gaddrof(CPools::GetObject), handle);
   34  }

   39  int CPools::GetObjectRef(CObject *object) {
   40:     return plugin::CallAndReturnDynGlobal<int, CObject *>(gaddrof(CPools::GetObjectRef), object);
   41  }

   46  CPed *CPools::GetPed(int handle) {
   47:     return plugin::CallAndReturnDynGlobal<CPed *, int>(gaddrof(CPools::GetPed), handle);
   48  }

   53  int CPools::GetPedRef(CPed *ped) {
   54:     return plugin::CallAndReturnDynGlobal<int, CPed *>(gaddrof(CPools::GetPedRef), ped);
   55  }

   60  CVehicle *CPools::GetVehicle(int handle) {
   61:     return plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CPools::GetVehicle), handle);
   62  }

   67  int CPools::GetVehicleRef(CVehicle *vehicle) {
   68:     return plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CPools::GetVehicleRef), vehicle);
   69  }

   81  void CPools::LoadObjectPool(unsigned char *buffer, unsigned int size) {
   82:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadObjectPool), buffer, size);
   83  }

   88  void CPools::LoadPedPool(unsigned char *buffer, unsigned int size) {
   89:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadPedPool), buffer, size);
   90  }

   95  void CPools::LoadVehiclePool(unsigned char *buffer, unsigned int size) {
   96:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadVehiclePool), buffer, size);
   97  }

  102  void CPools::MakeSureSlotInObjectPoolIsEmpty(int slot) {
  103:     plugin::CallDynGlobal<int>(gaddrof(CPools::MakeSureSlotInObjectPoolIsEmpty), slot);
  104  }

  109  void CPools::SaveObjectPool(unsigned char *buffer, unsigned int *outSize) {
  110:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveObjectPool), buffer, outSize);
  111  }

  116  void CPools::SavePedPool(unsigned char *buffer, unsigned int *outSize) {
  117:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SavePedPool), buffer, outSize);
  118  }

  123  void CPools::SaveVehiclePool(unsigned char *buffer, unsigned int *outSize) {
  124:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveVehiclePool), buffer, outSize);
  125  }

plugin_vc\game_vc\CPopulation.cpp:
   36  CPed* CPopulation::AddDeadPedInFrontOfCar(CVector const& posn, CVehicle* vehicle) {
   37:     return plugin::CallAndReturn<CPed*, 0x53B180, CVector const&, CVehicle*>(posn, vehicle);
   38  }

   41  CPed* CPopulation::AddPed(ePedType pedType, unsigned int modelIndex, CVector const& posn, int arg3) {
   42:     return plugin::CallAndReturn<CPed*, 0x53B600, ePedType, unsigned int, CVector const&, int>(pedType, modelIndex, posn, arg3);
   43  }

   46  CPed* CPopulation::AddPedInCar(CVehicle* vehicle, bool driver) {
   47:     return plugin::CallAndReturn<CPed*, 0x53A8A0, CVehicle*, bool>(vehicle, driver);
   48  }

   51  void CPopulation::AddToPopulation(float arg0, float arg1, float arg2, float arg3) {
   52:     plugin::Call<0x53BA80, float, float, float, float>(arg0, arg1, arg2, arg3);
   53  }

   56  bool CPopulation::CanJeerAtStripper(int modelIndex) {
   57:     return plugin::CallAndReturn<bool, 0x53A670, int>(modelIndex);
   58  }

   61  bool CPopulation::CanSolicitPlayerInCar(int modelIndex) {
   62:     return plugin::CallAndReturn<bool, 0x53A6A0, int>(modelIndex);
   63  }

   66  bool CPopulation::CanSolicitPlayerOnFoot(int modelIndex) {
   67:     return plugin::CallAndReturn<bool, 0x53A6C0, int>(modelIndex);
   68  }

   71  void CPopulation::ChooseCivilianCoupleOccupations(int arg0, int& arg1, int& arg2) {
   72:     plugin::Call<0x53AE90, int, int&, int&>(arg0, arg1, arg2);
   73  }

   76  int CPopulation::ChooseCivilianOccupation(int arg0) {
   77:     return plugin::CallAndReturn<int, 0x53B070, int>(arg0);
   78  }

   81  int CPopulation::ChooseNextCivilianOccupation(int arg0) {
   82:     return plugin::CallAndReturn<int, 0x53AFD0, int>(arg0);
   83  }

   86  void CPopulation::ConvertAllObjectsToDummyObjects() {
   87:     plugin::Call<0x53D430>();
   88  }

   91  void CPopulation::ConvertToDummyObject(CObject* object) {
   92:     plugin::Call<0x53D290, CObject*>(object);
   93  }

   96  void CPopulation::ConvertToRealObject(CDummyObject* dummyObject) {
   97:     plugin::Call<0x53D340, CDummyObject*>(dummyObject);
   98  }

  101  void CPopulation::GeneratePedsAtStartOfGame() {
  102:     plugin::Call<0x53E3E0>();
  103  }

  106  void CPopulation::Initialise() {
  107:     plugin::Call<0x53EAF0>();
  108  }

  111  bool CPopulation::IsFemale(int modelIndex) {
  112:     return plugin::CallAndReturn<bool, 0x53AD50, int>(modelIndex);
  113  }

  116  bool CPopulation::IsMale(int modelIndex) {
  117:     return plugin::CallAndReturn<bool, 0x53ADF0, int>(modelIndex);
  118  }

  121  bool CPopulation::IsSkateable(CVector const& point) {
  122:     return plugin::CallAndReturn<bool, 0x53ACA0, CVector const&>(point);
  123  }

  126  bool CPopulation::IsSunbather(int modelIndex) {
  127:     return plugin::CallAndReturn<bool, 0x53A6F0, int>(modelIndex);
  128  }

  131  void CPopulation::LoadPedGroups() {
  132:     plugin::Call<0x53E9C0>();
  133  }

  136  void CPopulation::ManagePopulation() {
  137:     plugin::Call<0x53D690>();
  138  }

  141  void CPopulation::PlaceCouple(ePedType pedType1, int modelIndex1, ePedType pedType2, int modelIndex2, CVector posn) {
  142:     plugin::Call<0x5388F0, ePedType, int, ePedType, int, CVector>(pedType1, modelIndex1, pedType2, modelIndex2, posn);
  143  }

  146  void CPopulation::PlaceGangMembersInCircle(ePedType pedType, int modelIndex, CVector const& posn) {
  147:     plugin::Call<0x5397F0, ePedType, int, CVector const&>(pedType, modelIndex, posn);
  148  }

  151  void CPopulation::PlaceGangMembersInFormation(ePedType pedType, int modelIndex, CVector const& posn) {
  152:     plugin::Call<0x539FC0, ePedType, int, CVector const&>(pedType, modelIndex, posn);
  153  }

  156  void CPopulation::PlaceMallPedsAsStationaryGroup(CVector const& posn, int modelIndex) {
  157:     plugin::Call<0x538E90, CVector const&, int>(posn, modelIndex);
  158  }

  161  void CPopulation::RemovePed(CPed* ped) {
  162:     plugin::Call<0x53B160, CPed*>(ped);
  163  }

  166  void CPopulation::RemovePedsIfThePoolGetsFull() {
  167:     plugin::Call<0x53D560>();
  168  }

  171  bool CPopulation::TestSafeForRealObject(CDummyObject* dummyObject) {
  172:     return plugin::CallAndReturn<bool, 0x53CF80, CDummyObject*>(dummyObject);
  173  }

  176  void CPopulation::Update(bool generatePeds) {
  177:     plugin::Call<0x53E5F0, bool>(generatePeds);
  178  }

  181  void CPopulation::UpdatePedCount(ePedType pedType, unsigned char updateState) {
  182:     plugin::Call<0x53A720, ePedType, unsigned char>(pedType, updateState);
  183  }

plugin_vc\game_vc\CProjectile.cpp:
  10  CProjectile::CProjectile(int arg0) {
  11:     plugin::CallMethod<0x4E8D30, CProjectile *, int>(this, arg0);
  12  }

plugin_vc\game_vc\CProjectileInfo.cpp:
  12  void CProjectileInfo::Shutdown() {
  13:     plugin::Call<0x5C7C10>();
  14  }

  17  void CProjectileInfo::Update() {
  18:     plugin::Call<0x5C6A20>();
  19  }

  22  void CProjectileInfo::RemoveNotAdd(CEntity* pEntity, eWeaponType weapontype, CVector posn) {
  23:     plugin::Call<0x5C7180, CEntity*, eWeaponType, CVector>(pEntity, weapontype, posn);
  24  }

  27  bool CProjectileInfo::RemoveIfThisIsAProjectile(CObject* pObject) {
  28:     return plugin::CallAndReturn<bool, 0x5C6970, CObject*>(pObject);
  29  }

  32  void CProjectileInfo::RemoveDetonatorProjectiles() {
  33:     plugin::Call<0x5C71D0>();
  34  }

  37  void CProjectileInfo::RemoveAllProjectiles() {
  38:     plugin::Call<0x5C69D0>();
  39  }

  42  void CProjectileInfo::Initialise() {
  43:     plugin::Call<0x5C7C30>();
  44  }

  47  CProjectileInfo* CProjectileInfo::GetProjectileInfo(int ProjIndex) {
  48:     return plugin::CallAndReturn<CProjectileInfo*, 0x5C7BF0, int>(ProjIndex);
  49  }

  52  bool CProjectileInfo::AddProjectile(CEntity* pEntity, eWeaponType weapontype, CVector posn, float fPower) {
  53:     return plugin::CallAndReturn<bool, 0x5C7250, CEntity*, eWeaponType, CVector, float>(pEntity, weapontype, posn, fPower);
  54  }

plugin_vc\game_vc\CQuaternion.cpp:
  10  void CQuaternion::Get(RwMatrixTag* out) {
  11:     plugin::CallMethod<0x4DFD30, CQuaternion *, RwMatrixTag*>(this, out);
  12  }

  15  void CQuaternion::Set(RwV3d* axis, float angle) {
  16:     plugin::CallMethod<0x4DFE20, CQuaternion *, RwV3d*, float>(this, axis, angle);
  17  }

  20  void CQuaternion::Slerp(CQuaternion const& from, CQuaternion const& to, float halftheta, float sintheta_inv, float t) {
  21:     plugin::CallMethod<0x4DFBE0, CQuaternion *, CQuaternion const&, CQuaternion const&, float, float, float>(this, from, to, halftheta, sintheta_inv, t);
  22  }

plugin_vc\game_vc\CRadar.cpp:
   63  void CRadar::CalculateCachedSinCos() {
   64:     plugin::Call<0x4C3D80>();
   65  }

   67  void CRadar::ChangeBlipBrightness(int i, int bright) {
   68:     plugin::Call<0x4C38B0, int, int>(i, bright);
   69  }

   71  void CRadar::ChangeBlipColour(int i, unsigned int colour) {
   72:     plugin::Call<0x4C3930, int, unsigned int>(i, colour);
   73  }

   75  void CRadar::ChangeBlipDisplay(int i, eBlipDisplay display) {
   76:     plugin::Call<0x4C37E0, int, eBlipDisplay>(i, display);
   77  }

   79  void CRadar::ChangeBlipScale(int i, int scale) {
   80:     plugin::Call<0x4C3840, int, int>(i, scale);
   81  }

   83  void CRadar::ClearBlip(int i) {
   84:     plugin::Call<0x4C3990, int>(i);
   85  }

   87  void CRadar::ClearBlipForEntity(eBlipType type, int handle) {
   88:     plugin::Call<0x4C3A70, eBlipType, int>(type, handle);
   89  }

   91  int CRadar::ClipRadarPoly(CVector2D* out, CVector2D const* in) {
   92:     return plugin::CallAndReturn<int, 0x4C2280, CVector2D*, CVector2D const*>(out, in);
   93  }

   95  void CRadar::Draw3dMarkers() {
   96:     plugin::Call<0x4C3F20>();
   97  }

   99  void CRadar::DrawBlips() {
  100:     plugin::Call<0x4C4200>();
  101  }

  103  void CRadar::DrawCoordBlip(int i) {
  104:     plugin::Call<0x4C5680, int>(i);
  105  }

  107  void CRadar::DrawEntityBlip(int i) {
  108:     plugin::Call<0x4C5170, int>(i);
  109  }

  111  void CRadar::DrawLegend(int x, int y, int sprite) {
  112:     plugin::Call<0x4C4A10, int, int, int>(x, y, sprite);
  113  }

  115  void CRadar::DrawMap() {
  116:     plugin::Call<0x4C5C60 >();
  117  }

  119  void CRadar::DrawRadarMap() {
  120:     plugin::Call<0x4C17C0>();
  121  }

  123  void CRadar::DrawRadarMask() {
  124:     plugin::Call<0x4C1A20>();
  125  }

  127  void CRadar::DrawRadarSection(int x, int y) {
  128:     plugin::Call<0x4C1D60>();
  129  }

  131  void CRadar::DrawRadarSprite(unsigned short sprite, float x, float y, unsigned char alpha) {
  132:     plugin::Call<0x4C2D00, unsigned short, float, float, unsigned char>(sprite, x, y, alpha);
  133  }

  135  void CRadar::DrawRotatingRadarSprite(CSprite2d* sprite, float x, float y, float angle, unsigned char alpha) {
  136:     plugin::Call<0x4C2E70, CSprite2d*, float, float, float, unsigned char>(sprite, x, y, angle, alpha);
  137  }

  139  void CRadar::DrawYouAreHereSprite(float x, float y) {
  140:     plugin::Call<0x4C2980, float, float>(x, y);
  141  }

  143  int CRadar::GetActualBlipArrayIndex(int i) {
  144:     return plugin::CallAndReturn<int, 0x4C5D70, int>(i);
  145  }

  155  unsigned int CRadar::GetRadarTraceColour(unsigned int colour, bool bright) {
  156:     return plugin::CallAndReturn<unsigned int, 0x4C3050, unsigned int, bool>(colour, bright);
  157  }

  159  void CRadar::InitFrontEndMap() {
  160:     plugin::Call<0x4C5B30>();
  161  }

  163  void CRadar::Initialise() {
  164:     plugin::Call<0x4C6200>();
  165  }

  180  void CRadar::LoadAllRadarBlips(unsigned char* buf, unsigned int size) {
  181:     plugin::Call<0x4C15D0, unsigned char*, unsigned int>(buf, size);
  182  }

  184  void CRadar::LoadTextures() {
  185:     plugin::Call<0x4C5DC0>();
  186  }

  188  void CRadar::RemoveRadarSections() {
  189:     plugin::Call<0x4C2930>();
  190  }

  192  void CRadar::SaveAllRadarBlips(unsigned char* buf, unsigned int* size) {
  193:     plugin::Call<0x4C16B0, unsigned char*, unsigned int*>(buf, size);
  194  }

  196  void CRadar::SetBlipSprite(int i, int icon) {
  197:     plugin::Call<0x4C3780, int, int>(i, icon);
  198  }

  200  int CRadar::SetCoordBlip(eBlipType type, CVector const& pos, unsigned int colour, eBlipDisplay display) {
  201:     return plugin::CallAndReturn<int, 0x4C3C80, eBlipType, CVector const&, unsigned int, eBlipDisplay>(type, pos, colour, display);
  202  }

  204  void CRadar::SetEntityBlip(eBlipType type, int handle, unsigned int colour, eBlipDisplay display) {
  205:     plugin::Call<0x4C3B40, eBlipType, int, unsigned int, eBlipDisplay>(type, handle, colour, display);
  206  }

  208  int CRadar::SetShortRangeCoordBlip(eBlipType type, CVector const& pos, unsigned int color, eBlipDisplay display) {
  209:     return plugin::CallAndReturn<int, 0x4C3C00, eBlipType, CVector const&, unsigned int, eBlipDisplay>(type, pos, color, display);
  210  }

  230  void CRadar::ShowRadarMarker(CVector const& pos, unsigned int colour, float radius) {
  231:     plugin::Call<0x4C3100, CVector const&, unsigned int, float>(pos, colour, radius);
  232  }

  234  void CRadar::ShowRadarTraceWithHeight(float x, float y, unsigned int size, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, unsigned char type) {
  235:     plugin::Call<0x4C32F0, float, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char>(x, y, size, red, green, blue, alpha, type);
  236  }

  238  void CRadar::Shutdown() {
  239:     plugin::Call<0x4C6030>();
  240  }

  242  void CRadar::StreamRadarSections(int x, int y) {
  243:     plugin::Call<0x4C2870, int, int>(x, y);
  244  }

  246  void CRadar::StreamRadarSections(CVector const& pos) {
  247:     plugin::Call<0x4C1960, CVector const&>(pos);
  248  }

plugin_vc\game_vc\CRegisteredMotionBlurStreak.cpp:
  12  void CRegisteredMotionBlurStreak::Render() {
  13:     plugin::CallMethod<0x572660, CRegisteredMotionBlurStreak *>(this);
  14  }

  17  CRegisteredMotionBlurStreak::CRegisteredMotionBlurStreak() {
  18:     plugin::CallMethod<0x575150, CRegisteredMotionBlurStreak *>(this);
  19  }

plugin_vc\game_vc\CRestart.cpp:
  26  void CRestart::LoadAllRestartPoints(unsigned char* bufferPointer, unsigned int structSize) {
  27:     plugin::Call<0x4421D0, unsigned char*, unsigned int>(bufferPointer, structSize);
  28  }

  31  void CRestart::SaveAllRestartPoints(unsigned char* bufferPointer, unsigned int* structSize) {
  32:     plugin::Call<0x4425B0, unsigned char*, unsigned int*>(bufferPointer, structSize);
  33  }

  36  void CRestart::CancelOverrideRestart() {
  37:     plugin::Call<0x4429D0>();
  38  }

  41  void CRestart::OverrideNextRestart(CVector const& point, float angle) {
  42:     plugin::Call<0x4429E0, CVector const&, float>(point, angle);
  43  }

  46  void CRestart::FindClosestPoliceRestartPoint(CVector const& point, CVector* storedPoint, float* storedAngle) {
  47:     plugin::Call<0x442A10, CVector const&, CVector*, float*>(point, storedPoint, storedAngle);
  48  }

  51  void CRestart::FindClosestHospitalRestartPoint(CVector const& point, CVector* storedPoint, float* storedAngle) {
  52:     plugin::Call<0x442CD0, CVector const&, CVector*, float*>(point, storedPoint, storedAngle);
  53  }

  56  void CRestart::AddPoliceRestartPoint(CVector const& point, float angle) {
  57:     plugin::Call<0x442FC0, CVector const&, float>(point, angle);
  58  }

  61  void CRestart::AddHospitalRestartPoint(CVector const& point, float angle) {
  62:     plugin::Call<0x443010, CVector const&, float>(point, angle);
  63  }

  66  void CRestart::Initialise() {
  67:     plugin::Call<0x443060>();
  68  }

plugin_vc\game_vc\CRouteNode.cpp:
  19  void CRouteNode::AddRoutePoint(short route, CVector pos) {
  20:     plugin::CallDynGlobal<short, CVector>(gaddrof(CRouteNode::AddRoutePoint), route, pos);
  21  }

  27      CVector ret_pos;
  28:     plugin::CallDynGlobal<CVector *, short>(gaddrof(CRouteNode::GetPointPosition), &ret_pos, point);
  29      return ret_pos;

  35  short CRouteNode::GetRouteStart(short route) {
  36:     return plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteStart), route);
  37  }

  42  short CRouteNode::GetRouteThisPointIsOn(short point) {
  43:     return plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteThisPointIsOn), point);
  44  }

  56  void CRouteNode::RemoveRoute(short route) {
  57:     plugin::CallDynGlobal<short>(gaddrof(CRouteNode::RemoveRoute), route);
  58  }

plugin_vc\game_vc\CRubbish.cpp:
  30  void CRubbish::SetVisibility(bool bVisibility) {
  31:     plugin::CallDynGlobal<bool>(gaddrof(CRubbish::SetVisibility), bVisibility);
  32  }

  44  void CRubbish::StirUp(CVehicle *pVehicle) {
  45:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CRubbish::StirUp), pVehicle);
  46  }

plugin_vc\game_vc\CRunningScript.cpp:
  11  void CRunningScript::Init() {
  12:     plugin::CallMethod<0x450CF0, CRunningScript *>(this);
  13  }

  16  char CRunningScript::ProcessOneCommand() {
  17:     return plugin::CallMethodAndReturn<char, 0x44FBE0, CRunningScript *>(this);
  18  }

  21  void CRunningScript::CollectParameters(int* arg0, short count) {
  22:     plugin::CallMethod<0x451010, CRunningScript *, int*, short>(this, arg0, count);
  23  }

  26  void CRunningScript::UpdateCompareFlag(unsigned char flag) {
  27:     plugin::CallMethod<0x463F00, CRunningScript *, unsigned char>(this, flag);
  28  }

plugin_vc\game_vc\cSampleManager.cpp:
  11  bool cSampleManager::IsMP3RadioChannelAvailable() {
  12: 	return plugin::CallAndReturn<bool, 0x5D80E0>();
  13  }

plugin_vc\game_vc\CSceneEdit.cpp:
  39  bool CSceneEdit::SelectWeapon() {
  40:     return plugin::CallAndReturn<bool, 0x6032E0>();
  41  }

  44  bool CSceneEdit::SelectVehicle() {
  45:     return plugin::CallAndReturn<bool, 0x603520>();
  46  }

  49  bool CSceneEdit::SelectActor2() {
  50:     return plugin::CallAndReturn<bool, 0x603700>();
  51  }

  54  bool CSceneEdit::SelectActor() {
  55:     return plugin::CallAndReturn<bool, 0x603980>();
  56  }

  59  void CSceneEdit::PlayBack() {
  60:     plugin::Call<0x603C10>();
  61  }

  64  void CSceneEdit::ProcessCommand() {
  65:     plugin::Call<0x604500>();
  66  }

  69  void CSceneEdit::Draw() {
  70:     plugin::Call<0x605DB0>();
  71  }

  74  void CSceneEdit::Update() {
  75:     plugin::Call<0x606270>();
  76  }

  79  void CSceneEdit::ReInitialise() {
  80:     plugin::Call<0x6062F0>();
  81  }

  84  void CSceneEdit::InitPlayBack() {
  85:     plugin::Call<0x606470>();
  86  }

  89  void CSceneEdit::Initialise() {
  90:     plugin::Call<0x6065B0>();
  91  }

plugin_vc\game_vc\CShadowCamera.cpp:
  14  RwCamera *CShadowCamera::Create(int rasterSize) {
  15:     return plugin::CallMethodAndReturnDynGlobal<RwCamera *, CShadowCamera *, int>(gaddrof(CShadowCamera::Create), this, rasterSize);
  16  }

  21  void CShadowCamera::Destroy() {
  22:     plugin::CallMethodDynGlobal<CShadowCamera *>(gaddrof(CShadowCamera::Destroy), this);
  23  }

  28  RwRaster *CShadowCamera::DrawOutlineBorder(RwRGBA const &color) {
  29:     return plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRGBA const &>(gaddrof(CShadowCamera::DrawOutlineBorder), this, color);
  30  }

  35  void CShadowCamera::InvertRaster() {
  36:     plugin::CallMethodDynGlobal<CShadowCamera *>(gaddrof(CShadowCamera::InvertRaster), this);
  37  }

  42  RwRaster *CShadowCamera::MakeGradientRaster() {
  43:     return plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *>(gaddrof(CShadowCamera::MakeGradientRaster), this);
  44  }

  49  RwRaster *CShadowCamera::RasterBlur(RwRaster *raster, int numPasses) {
  50:     return plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *, int>(gaddrof(CShadowCamera::RasterBlur), this, raster, numPasses);
  51  }

  56  RwRaster *CShadowCamera::RasterGradient(RwRaster *raster) {
  57:     return plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *>(gaddrof(CShadowCamera::RasterGradient), this, raster);
  58  }

  63  RwRaster *CShadowCamera::RasterResample(RwRaster *raster) {
  64:     return plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *>(gaddrof(CShadowCamera::RasterResample), this, raster);
  65  }

  70  RwCamera *CShadowCamera::Update(RpAtomic *atomic) {
  71:     return plugin::CallMethodAndReturnDynGlobal<RwCamera *, CShadowCamera *, RpAtomic *>(gaddrof(CShadowCamera::Update), this, atomic);
  72  }

  77  RpAtomic *ShadowRenderCallBack(RpAtomic *atomic, void *data) {
  78:     return plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(ShadowRenderCallBack), atomic, data);
  79  }

plugin_vc\game_vc\CShinyTexts.cpp:
  15  CRegisteredShinyText::CRegisteredShinyText() {
  16:     plugin::CallMethod<0x575130, CRegisteredShinyText *>(this);
  17  }

  20  void CShinyTexts::Render() {
  21:     plugin::Call<0x571240>();
  22  }

plugin_vc\game_vc\CShotInfo.cpp:
  14  void CShotInfo::Initialise() {
  15:     plugin::Call<0x5C83B0>();
  16  }

  19  void CShotInfo::Shutdown() {
  20:     plugin::Call<0x5C8390>();
  21  }

  23  bool CShotInfo::AddShot(CEntity* creator, eWeaponType weaponType, CVector origin, CVector target) {
  24:     return plugin::CallAndReturn<bool, 0x5C8110, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, origin, target);
  25  }

  28  void CShotInfo::Update() {
  29:     plugin::Call<0x5C7E60>();
  30  }

plugin_vc\game_vc\CSimpleModelInfo.cpp:
  10  void CSimpleModelInfo::SetAtomic(int atomicIndex, RpAtomic* atomic) {
  11:     plugin::CallVirtualMethod<9, CSimpleModelInfo *, int, RpAtomic*>(this, atomicIndex, atomic);
  12  }

  15  RpAtomic* CSimpleModelInfo::GetAtomicFromDistance(float distance) {
  16:     return plugin::CallMethodAndReturn<RpAtomic*, 0x56F690, CSimpleModelInfo *, float>(this, distance);
  17  }

  20  float CSimpleModelInfo::GetLargestLodDistance() {
  21:     return plugin::CallMethodAndReturn<float, 0x56F660, CSimpleModelInfo *>(this);
  22  }

  25  RpAtomic* CSimpleModelInfo::GetLastAtomic(float distance) {
  26:     return plugin::CallMethodAndReturn<RpAtomic*, 0x56F620, CSimpleModelInfo *, float>(this, distance);
  27  }

  30  float CSimpleModelInfo::GetLodDistance(int lodIndex) {
  31:     return plugin::CallMethodAndReturn<float, 0x56F6F0, CSimpleModelInfo *, int>(this, lodIndex);
  32  }

  35  void CSimpleModelInfo::Init() {
  36:     plugin::CallMethod<0x56F770, CSimpleModelInfo *>(this);
  37  }

  40  void CSimpleModelInfo::SetLodDistances(float* distances) {
  41:     plugin::CallMethod<0x56F600, CSimpleModelInfo *, float*>(this, distances);
  42  }

  45  void CSimpleModelInfo::SetupBigBuilding(int minLineIndex, int maxLineIndex) {
  46:     plugin::CallMethod<0x56F420, CSimpleModelInfo *, int, int>(this, minLineIndex, maxLineIndex);
  47  }

  50  SimpleModelStore::~SimpleModelStore() {
  51:     plugin::CallMethod<0x5602A0, SimpleModelStore *>(this);
  52  }

plugin_vc\game_vc\CSprite.cpp:
  10      unsigned char red, unsigned char green, unsigned char blue, short intensity, float rhw, unsigned char alpha) {
  11:     plugin::Call<0x576FE0, float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(x, y, z, halfWidth, halfHeight, red, green, blue, intensity, rhw, alpha);
  12  }

  14  bool CSprite::CalcScreenCoors(RwV3d const& posn, RwV3d *out, float *w, float *h, bool checkMaxVisible) {
  15:     return plugin::CallAndReturn<bool, 0x5778B0, RwV3d const&, RwV3d *, float *, float *, bool>(posn, out, w, h, checkMaxVisible);
  16  }

plugin_vc\game_vc\CStinger.cpp:
  10  CStinger::CStinger() {
  11:     plugin::CallMethod<0x629B50, CStinger *>(this);
  12  }

  15  void CStinger::Deploy(CPed* pPed) {
  16:     plugin::CallMethod<0x628EF0, CStinger *, CPed*>(this, pPed);
  17  }

  20  void CStinger::CheckForBurstTyres() {
  21:     plugin::CallMethod<0x628F70, CStinger *>(this);
  22  }

  25  void CStinger::Init(CPed* pPed) {
  26:     plugin::CallMethod<0x6298D0, CStinger *, CPed*>(this, pPed);
  27  }

  30  void CStinger::Process() {
  31:     plugin::CallMethod<0x629380, CStinger *>(this);
  32  }

  35  void CStinger::Remove() {
  36:     plugin::CallMethod<0x629880, CStinger *>(this);
  37  }

  40  CStinger::~CStinger() {
  41:     plugin::CallMethod<0x629B40, CStinger *>(this);
  42  }

plugin_vc\game_vc\CStreaming.cpp:
   37  void CStreaming::AddModelsToRequestList(CVector const *pos, unsigned int streamingFlags) {
   38:     plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddModelsToRequestList), pos, streamingFlags);
   39  }

   44  bool CStreaming::AddToLoadedVehiclesList(int modelIndex) {
   45:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AddToLoadedVehiclesList), modelIndex);
   46  }

   51  bool CStreaming::AreAnimsUsedByRequestedModels(int animFileIndex) {
   52:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreAnimsUsedByRequestedModels), animFileIndex);
   53  }

   58  void CStreaming::ConvertBufferToObject(char *streamingBuffer, int modelIndex) {
   59:     plugin::CallDynGlobal<char *, int>(gaddrof(CStreaming::ConvertBufferToObject), streamingBuffer, modelIndex);
   60  }

   72  void CStreaming::DeleteFarAwayRwObjects(CVector const *pos) {
   73:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteFarAwayRwObjects), pos);
   74  }

   79  void CStreaming::DeleteRwObjectsAfterDeath(CVector const *pos) {
   80:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteRwObjectsAfterDeath), pos);
   81  }

   86  void CStreaming::DeleteRwObjectsBehindCamera(int maxStreamingMemAllowed) {
   87:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::DeleteRwObjectsBehindCamera), maxStreamingMemAllowed);
   88  }

   93  bool CStreaming::DeleteRwObjectsBehindCameraInSectorList(CPtrList *ptrList, int maxStreamingMemAllowed) {
   94:     return plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsBehindCameraInSectorList), ptrList, maxStreamingMemAllowed);
   95  }

  100  void CStreaming::DeleteRwObjectsInOverlapSectorList(CPtrList *ptrlist, int sectorX, int sectorY) {
  101:     plugin::CallDynGlobal<CPtrList *, int, int>(gaddrof(CStreaming::DeleteRwObjectsInOverlapSectorList), ptrlist, sectorX, sectorY);
  102  }

  107  bool CStreaming::DeleteRwObjectsNotInFrustumInSectorList(CPtrList *ptrList, int maxStreamingMemAllowed) {
  108:     return plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsNotInFrustumInSectorList), ptrList, maxStreamingMemAllowed);
  109  }

  114  void CStreaming::FinishLoadingLargeFile(char *streamingBuffer, int modelID) {
  115:     plugin::CallDynGlobal<char *, int>(gaddrof(CStreaming::FinishLoadingLargeFile), streamingBuffer, modelID);
  116  }

  135  unsigned int CStreaming::GetCdImageOffset(int CdPosn) {
  136:     return plugin::CallAndReturnDynGlobal<unsigned int, int>(gaddrof(CStreaming::GetCdImageOffset), CdPosn);
  137  }

  142  int CStreaming::GetNextFileOnCd(int CdOffset, bool bOnlyPriorityRequests) {
  143:     return plugin::CallAndReturnDynGlobal<int, int, bool>(gaddrof(CStreaming::GetNextFileOnCd), CdOffset, bOnlyPriorityRequests);
  144  }

  149  bool CStreaming::HasSpecialCharLoaded(int SpecialSlotID) {
  150:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasSpecialCharLoaded), SpecialSlotID);
  151  }

  184  void CStreaming::InstanceLoadedModels(CVector const *pos) {
  185:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::InstanceLoadedModels), pos);
  186  }

  191  bool CStreaming::IsObjectInCdImage(int modelIndex) {
  192:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsObjectInCdImage), modelIndex);
  193  }

  198  bool CStreaming::IsTxdUsedByRequestedModels(int txdIndex) {
  199:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsTxdUsedByRequestedModels), txdIndex);
  200  }

  205  void CStreaming::LoadAllRequestedModels(bool bOnlyPriorityRequests) {
  206:     plugin::CallDynGlobal<bool>(gaddrof(CStreaming::LoadAllRequestedModels), bOnlyPriorityRequests);
  207  }

  219  void CStreaming::LoadCdDirectory(char const *fileName, int id) {
  220:     plugin::CallDynGlobal<char const *, int>(gaddrof_o(CStreaming::LoadCdDirectory, void (*)(char const *, int)), fileName, id);
  221  }

  254  void CStreaming::LoadScene(CVector const *pos) {
  255:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadScene), pos);
  256  }

  261  void CStreaming::LoadSceneCollision(CVector const *pos) {
  262:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadSceneCollision), pos);
  263  }

  268  void CStreaming::MakeSpaceFor(int memoryToCleanSize) {
  269:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::MakeSpaceFor), memoryToCleanSize);
  270  }

  275  void CStreaming::MemoryCardLoad(unsigned char *buffer, unsigned int num) {
  276:     plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CStreaming::MemoryCardLoad), buffer, num);
  277  }

  282  void CStreaming::MemoryCardSave(unsigned char *text, unsigned int *num) {
  283:     plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CStreaming::MemoryCardSave), text, num);
  284  }

  289  void CStreaming::ProcessEntitiesInSectorList(CPtrList *a1, unsigned int Streamingflags) {
  290:     plugin::CallDynGlobal<CPtrList *, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, unsigned int)), a1, Streamingflags);
  291  }

  296  void CStreaming::ProcessEntitiesInSectorList(CPtrList *ptrList, float X1, float Y1, float X2, float Y2, float X3, float Y3, unsigned int Streamingflags) {
  297:     plugin::CallDynGlobal<CPtrList *, float, float, float, float, float, float, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, float, float, float, float, float, float, unsigned int)), ptrList, X1, Y1, X2, Y2, X3, Y3, Streamingflags);
  298  }

  303  bool CStreaming::ProcessLoadingChannel(int channelIndex) {
  304:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::ProcessLoadingChannel), channelIndex);
  305  }

  317  void CStreaming::RemoveBuildings(int levelID) {
  318:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveBuildings), levelID);
  319  }

  324  char CStreaming::RemoveBuildingsNotInArea(int LevelID) {
  325:     return plugin::CallAndReturnDynGlobal<char, int>(gaddrof(CStreaming::RemoveBuildingsNotInArea), LevelID);
  326  }

  338  void CStreaming::RemoveIslandsNotUsed(int levelID) {
  339:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveIslandsNotUsed), levelID);
  340  }

  345  bool CStreaming::RemoveLeastUsedModel(int streamingFlags) {
  346:     return plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::RemoveLeastUsedModel), streamingFlags);
  347  }

  352  bool CStreaming::RemoveLoadedVehicle() {
  353:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedVehicle));
  354  }

  359  bool CStreaming::RemoveLoadedZoneModel() {
  360:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedZoneModel));
  361  }

  366  void CStreaming::RemoveModel(int modelIndex) {
  367:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveModel), modelIndex);
  368  }

  373  void CStreaming::RemoveUnusedBigBuildings(int LevelID) {
  374:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveUnusedBigBuildings), LevelID);
  375  }

  380  void CStreaming::RemoveUnusedBuildings(int levelID) {
  381:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveUnusedBuildings), levelID);
  382  }

  394  void CStreaming::RequestBigBuildings(int levelID) {
  395:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestBigBuildings), levelID);
  396  }

  401  void CStreaming::RequestModel(int modelIndex, int Streamingflags) {
  402:     plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestModel), modelIndex, Streamingflags);
  403  }

  408  void CStreaming::RequestModelStream(int ChannelID) {
  409:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestModelStream), ChannelID);
  410  }

  415  void CStreaming::RequestSpecialChar(int SpecialSlotID, char const *Name, int streamingFlags) {
  416:     plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialChar), SpecialSlotID, Name, streamingFlags);
  417  }

  422  char CStreaming::RequestSpecialModel(int SpecialModelID, char *name, int StreamingFlags) {
  423:     return plugin::CallAndReturnDynGlobal<char, int, char *, int>(gaddrof(CStreaming::RequestSpecialModel), SpecialModelID, name, StreamingFlags);
  424  }

  429  void CStreaming::RetryLoadFile(int nChannel) {
  430:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::RetryLoadFile), nChannel);
  431  }

  436  void CStreaming::SetMissionDoesntRequireModel(int modelIndex) {
  437:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireModel), modelIndex);
  438  }

  443  void CStreaming::SetMissionDoesntRequireSpecialChar(int SpecialSlotID) {
  444:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireSpecialChar), SpecialSlotID);
  445  }

  450  void CStreaming::SetModelIsDeletable(int modelIndex) {
  451:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelIsDeletable), modelIndex);
  452  }

  457  void CStreaming::SetModelTxdIsDeletable(int modelIndex) {
  458:     plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelTxdIsDeletable), modelIndex);
  459  }

  478  void CStreaming::StreamZoneModels(CVector const *arg1) {
  479:     plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels), arg1);
  480  }

plugin_vc\game_vc\CText.cpp:
  11  wchar_t* CText::Get(char const* key) {
  12:     return plugin::CallMethodAndReturn<wchar_t*, 0x584F30, CText*, char const*>(this, key);
  13  }

plugin_vc\game_vc\CTheScripts.cpp:
   11  void CTheScripts::ClearSpaceForMissionEntity(CVector const& position, CEntity* entity) {
   12:     plugin::Call<0x45F180, CVector const&, CEntity*>(position, entity);
   13  }

   24  void CTheScripts::CleanUpThisObject(CObject *pObject) {
   25:     plugin::CallDynGlobal<CObject *>(gaddrof(CTheScripts::CleanUpThisObject), pObject);
   26  }

   31  void CTheScripts::CleanUpThisPed(CPed *pPed) {
   32:     plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::CleanUpThisPed), pPed);
   33  }

   38  void CTheScripts::CleanUpThisVehicle(CVehicle *pVehicle) {
   39:     plugin::CallDynGlobal<CVehicle *>(gaddrof(CTheScripts::CleanUpThisVehicle), pVehicle);
   40  }

   59  bool CTheScripts::IsPlayerOnAMission() {
   60:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTheScripts::IsPlayerOnAMission));
   61  }

   66  bool CTheScripts::IsPlayerStopped(CPlayerInfo *pPlayerIfo) {
   67:     return plugin::CallAndReturnDynGlobal<bool, CPlayerInfo *>(gaddrof(CTheScripts::IsPlayerStopped), pPlayerIfo);
   68  }

   73  bool CTheScripts::IsVehicleStopped(CVehicle *pPlayer) {
   74:     return plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTheScripts::IsVehicleStopped), pPlayer);
   75  }

  108  void CTheScripts::RemoveThisPed(CPed *pPed) {
  109:     plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::RemoveThisPed), pPed);
  110  }

  115  CRunningScript *CTheScripts::StartNewScript(int addr) {
  116:     return plugin::CallAndReturnDynGlobal<CRunningScript *, int>(gaddrof(CTheScripts::StartNewScript), addr);
  117  }

  122  CRunningScript *CTheScripts::StartTestScript() {
  123:     return plugin::CallAndReturnDynGlobal<CRunningScript *>(gaddrof(CTheScripts::StartTestScript));
  124  }

plugin_vc\game_vc\CTheZones.cpp:
   22  void CTheZones::CreateZone(char* name, eZoneType type, float posX1, float posY1, float posZ1, float posX2, float posY2, float posZ2, eLevelName island) {
   23:     plugin::Call<0x4DDB80, char*, eZoneType, float, float, float, float, float, float, eLevelName>(name, type, posX1, posY1, posZ1, posX2, posY2, posZ2, island);
   24  }

   27  CZone* CTheZones::FindAudioZone(CVector* point) {
   28:     return plugin::CallAndReturn<CZone*, 0x4DC370, CVector*>(point);
   29  }

   32  int CTheZones::FindInformationZoneForPosition(CVector const* pPoint) {
   33:     return plugin::CallAndReturn<int, 0x4DD160, CVector const*>(pPoint);
   34  }

   37  short CTheZones::FindNextZoneByLabelAndReturnIndex(char* name, eZoneType type) {
   38:     return plugin::CallAndReturn<short, 0x4DD4A0, char*, eZoneType>(name, type);
   39  }

   42  CZone* CTheZones::FindSmallestNavigationZoneForPosition(CVector const* pPoint, bool findDef, bool findNavig) {
   43:     return plugin::CallAndReturn<CZone*, 0x4DD060, CVector const*, bool, bool>(pPoint, findDef, findNavig);
   44  }

   47  short CTheZones::FindZoneByLabelAndReturnIndex(char* name, eZoneType type) {
   48:     return plugin::CallAndReturn<short, 0x4DD5F0, char*, eZoneType>(name, type);
   49  }

   53      eLevelName result;
   54:     plugin::CallAndReturn<eLevelName, 0x4DD300, eLevelName*, CVector const*>(&result, pPoint);
   55      return result;

   59  int CTheZones::GetNavigationZone(unsigned short arg0) {
   60:     return plugin::CallAndReturn<int, 0x4DCC20, unsigned short>(arg0);
   61  }

   64  CZone* CTheZones::GetZoneInfo(CVector const* pPoint, unsigned char arg1) {
   65:     return plugin::CallAndReturn<CZone*, 0x4DCEA0, CVector const*, unsigned char>(pPoint, arg1);
   66  }

   69  short CTheZones::GetZoneInfoForTimeOfDay(CVector const* pPoint, CZoneInfo* zoneInfo) {
   70:     return plugin::CallAndReturn<short, 0x4DC500, CVector const*, CZoneInfo*>(pPoint, zoneInfo);
   71  }

   74  void CTheZones::Init() {
   75:     plugin::Call<0x4DDFA0>();
   76  }

   79  void CTheZones::InitialiseAudioZoneArray() {
   80:     plugin::Call<0x4DC430>();
   81  }

   84  bool CTheZones::InsertZoneIntoZoneHierRecursive(CZone* currentZona, CZone* otherZone) {
   85:     return plugin::CallAndReturn<bool, 0x4DD9D0, CZone*, CZone*>(currentZona, otherZone);
   86  }

   89  void CTheZones::LoadAllZones(unsigned char* arg0, unsigned int arg1) {
   90:     plugin::Call<0x4DBCB0, unsigned char*, unsigned int>(arg0, arg1);
   91  }

   94  void CTheZones::LoadOneZone(CZone* pZone, unsigned char** arg1, unsigned int* arg2, eZoneType type) {
   95:     plugin::Call<0x4DBB80, CZone*, unsigned char**, unsigned int*, eZoneType>(pZone, arg1, arg2, type);
   96  }

   99  bool CTheZones::PointLiesWithinZone(CVector const* pPoint, CZone* pZone) {
  100:     return plugin::CallAndReturn<bool, 0x4DD750, CVector const*, CZone*>(pPoint, pZone);
  101  }

  104  char CTheZones::PostZoneCreation() {
  105:     return plugin::CallAndReturn<char, 0x4DDA90>();
  106  }

  109  void CTheZones::SaveAllZones(unsigned char* arg0, unsigned int* arg1) {
  110:     plugin::Call<0x4DC090, unsigned char*, unsigned int*>(arg0, arg1);
  111  }

  114  void CTheZones::SaveOneZone(CZone* pZone, unsigned char** arg1, unsigned int* arg2, eZoneType type) {
  115:     plugin::Call<0x4DBF30, CZone*, unsigned char**, unsigned int*, eZoneType>(pZone, arg1, arg2, type);
  116  }

  119  void CTheZones::SetPedGroup(unsigned short arg0, unsigned char arg1, unsigned short arg2) {
  120:     plugin::Call<0x4DCC30, unsigned short, unsigned char, unsigned short>(arg0, arg1, arg2);
  121  }

  124  void CTheZones::SetZoneCarInfo(int arg0, unsigned char arg1, short arg2, short arg3, short const* arg4) {
  125:     plugin::Call<0x4DCDF0, int, unsigned char, short, short, short const*>(arg0, arg1, arg2, arg3, arg4);
  126  }

  129  void CTheZones::SetZoneCivilianCarInfo(int arg0, unsigned char arg1, short const* arg2, short const* arg3) {
  130:     plugin::Call<0x4DCD40, int, unsigned char, short const*, short const*>(arg0, arg1, arg2, arg3);
  131  }

  134  void CTheZones::SetZonePedInfo(int arg0, unsigned char arg1, short arg2, short arg3, short arg4, short arg5, short arg6, short arg7, short arg8, short arg9, short arg10, short arg11, short arg12) {
  135:     plugin::Call<0x4DCC70, int, unsigned char, short, short, short, short, short, short, short, short, short, short, short>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
  136  }

  139  void CTheZones::Update() {
  140:     plugin::Call<0x4DDDF0>();
  141  }

  144  bool CTheZones::ZoneIsEntirelyContainedWithinOtherZone(CZone* currentZona, CZone* otherZone) {
  145:     return plugin::CallAndReturn<bool, 0x4DD7D0, CZone*, CZone*>(currentZona, otherZone);
  146  }

plugin_vc\game_vc\CTimeCycle.cpp:
  21  void CTimeCycle::StopExtraColour(bool arg1) {
  22:     plugin::CallDynGlobal<bool>(gaddrof(CTimeCycle::StopExtraColour), arg1);
  23  }

plugin_vc\game_vc\CTimeModelInfo.cpp:
  10  void CTimeModelInfo::FindOtherTimeModel() {
  11:     plugin::CallMethod<0x56F330, CTimeModelInfo *>(this);
  12  }

  15  TimeModelStore::~TimeModelStore() {
  16:     plugin::CallMethod<0x560240, TimeModelStore *>(this);
  17  }

plugin_vc\game_vc\CTimer.cpp:
  35  unsigned int CTimer::GetCurrentTimeInCycles() {
  36:     return plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CTimer::GetCurrentTimeInCycles));
  37  }

  42  int CTimer::GetCyclesPerMillisecond() {
  43:     return plugin::CallAndReturnDynGlobal<int>(gaddrof(CTimer::GetCyclesPerMillisecond));
  44  }

  49  bool CTimer::GetIsSlowMotionActive() {
  50:     return plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTimer::GetIsSlowMotionActive));
  51  }

plugin_vc\game_vc\CTrafficLights.cpp:
  14  void CTrafficLights::DisplayActualLight(CEntity *pEntity) {
  15:     plugin::CallDynGlobal<CEntity *>(gaddrof(CTrafficLights::DisplayActualLight), pEntity);
  16  }

  42  void CTrafficLights::ShouldCarStopForLight(CVehicle *arg1, bool arg2) {
  43:     plugin::CallDynGlobal<CVehicle *, bool>(gaddrof(CTrafficLights::ShouldCarStopForLight), arg1, arg2);
  44  }

plugin_vc\game_vc\CTrain.cpp:
  10  void CTrain::AddPassenger(CPed* ped) {
  11:     plugin::CallMethod<0x5B2C60, CTrain *, CPed*>(this, ped);
  12  }

  15  CTrain::CTrain(int modelIndex, unsigned char createdBy) : CVehicle(plugin::dummy) {
  16:     plugin::CallMethod<0x5B2D00, CTrain *, int, unsigned char>(this, modelIndex, createdBy);
  17  }

  20  void CTrain::InitTrains() {
  21:     plugin::Call<0x5B2CA0>();
  22  }

  25  void CTrain::Shutdown() {
  26:     plugin::Call<0x5B2C90>();
  27  }

  30  void CTrain::UpdateTrains() {
  31:     plugin::Call<0x5B2C80>();
  32  }

plugin_vc\game_vc\cTransmission.cpp:
  10  float cTransmission::CalculateDriveAcceleration(float const& gasPedal, unsigned char& currrentGear, float& arg2, float const& arg3, bool arg4) {
  11:     return plugin::CallMethodAndReturn<float, 0x5B2E20, cTransmission *, float const&, unsigned char&, float&, float const&, bool>(this, gasPedal, currrentGear, arg2, arg3, arg4);
  12  }

  15  void cTransmission::CalculateGearForSimpleCar(float velocity, unsigned char& currrentGear) {
  16:     plugin::CallMethod<0x5B2DC0, cTransmission *, float, unsigned char&>(this, velocity, currrentGear);
  17  }

  20  void cTransmission::InitGearRatios() {
  21:     plugin::CallMethod<0x5B3120, cTransmission *>(this);
  22  }

  25  cTransmission::cTransmission() {
  26:     plugin::CallMethod<0x5B3240, cTransmission *>(this);
  27  }

plugin_vc\game_vc\CTxdStore.cpp:
   12  TxdDef* CTxdStore::AddRef(int index) {
   13:     return plugin::CallAndReturn<TxdDef*, 0x580A60, int>(index);
   14  }

   17  int CTxdStore::AddTxdSlot(char const* name) {
   18:     return plugin::CallAndReturn<int, 0x580F00, char const*>(name);
   19  }

   22  void CTxdStore::Create(int index) {
   23:     plugin::Call<0x580B60, int>(index);
   24  }

   27  int CTxdStore::FindTxdSlot(char const* name) {
   28:     return plugin::CallAndReturn<int, 0x580D70, char const*>(name);
   29  }

   32  bool CTxdStore::FinishLoadTxd(int index, RwStream* stream) {
   33:     return plugin::CallAndReturn<bool, 0x580BA0, int, RwStream*>(index, stream);
   34  }

   37  void CTxdStore::GameShutdown() {
   38:     plugin::Call<0x580F40>();
   39  }

   42  int CTxdStore::GetNumRefs(int index) {
   43:     return plugin::CallAndReturn<int, 0x580990, int>(index);
   44  }

   47  int CTxdStore::GetTxdName(int index) {
   48:     return plugin::CallAndReturn<int, 0x580E50, int>(index);
   49  }

   52  bool CTxdStore::LoadTxd(int index, RwStream* stream) {
   53:     return plugin::CallAndReturn<bool, 0x580C60, int, RwStream*>(index, stream);
   54  }

   57  bool CTxdStore::LoadTxd(int index, char const* filename) {
   58:     return plugin::CallAndReturn<bool, 0x580CD0, int, char const*>(index, filename);
   59  }

   62  void CTxdStore::PopCurrentTxd() {
   63:     plugin::Call<0x580AA0>();
   64  }

   67  void CTxdStore::PushCurrentTxd() {
   68:     plugin::Call<0x580AC0>();
   69  }

   72  void CTxdStore::RemoveRef(int index) {
   73:     plugin::Call<0x580A10, int>(index);
   74  }

   77  TxdDef* CTxdStore::RemoveRefWithoutDelete(int index) {
   78:     return plugin::CallAndReturn<TxdDef*, 0x5809D0, int>(index);
   79  }

   82  void CTxdStore::RemoveTxd(int index) {
   83:     plugin::Call<0x580B10, int>(index);
   84  }

   87  void CTxdStore::RemoveTxdSlot(int index) {
   88:     plugin::Call<0x580E90, int>(index);
   89  }

   92  void CTxdStore::SetCurrentTxd(int index) {
   93:     plugin::Call<0x580AD0, int>(index);
   94  }

   97  void CTxdStore::Shutdown() {
   98:     plugin::Call<0x580FF0>();
   99  }

  102  bool CTxdStore::StartLoadTxd(int index, RwStream* stream) {
  103:     return plugin::CallAndReturn<bool, 0x580BF0, int, RwStream*>(index, stream);
  104  }

  107  void CTxdStore::Initialise() {
  108:     plugin::Call<0x581010>();
  109  }

plugin_vc\game_vc\CUserDisplay.cpp:
  13  void CUserDisplay::Init() {
  14:     plugin::Call<0x4D1490>();
  15  }

  18  void CUserDisplay::Process() {
  19:     plugin::Call<0x4D1400>();
  20  }

plugin_vc\game_vc\CVehicle.cpp:
   23  void CVehicle::ProcessControlInputs(unsigned char playerNum) {
   24:     plugin::CallVirtualMethod<18, CVehicle *, unsigned char>(this, playerNum);
   25  }

   28  void CVehicle::GetComponentWorldPosition(int componentId, CVector& posnOut) {
   29:     plugin::CallVirtualMethod<19, CVehicle *, int, CVector&>(this, componentId, posnOut);
   30  }

   33  bool CVehicle::IsComponentPresent(int componentId) {
   34:     return plugin::CallVirtualMethodAndReturn<bool, 20, CVehicle *, int>(this, componentId);
   35  }

   38  void CVehicle::SetComponentRotation(int componentId, CVector arg1) {
   39:     plugin::CallVirtualMethod<21, CVehicle *, int, CVector>(this, componentId, arg1);
   40  }

   43  void CVehicle::OpenDoor(int componentId, eDoors door, float doorOpenRatio) {
   44:     plugin::CallVirtualMethod<22, CVehicle *, int, eDoors, float>(this, componentId, door, doorOpenRatio);
   45  }

   48  void CVehicle::ProcessOpenDoor(unsigned int arg0, unsigned int arg1, float arg2) {
   49:     plugin::CallVirtualMethod<23, CVehicle *, unsigned int, unsigned int, float>(this, arg0, arg1, arg2);
   50  }

   53  bool CVehicle::IsDoorReady(eDoors door) {
   54:     return plugin::CallVirtualMethodAndReturn<bool, 24, CVehicle *, eDoors>(this, door);
   55  }

   58  bool CVehicle::IsDoorFullyOpen(eDoors door) {
   59:     return plugin::CallVirtualMethodAndReturn<bool, 25, CVehicle *, eDoors>(this, door);
   60  }

   63  bool CVehicle::IsDoorClosed(eDoors door) {
   64:     return plugin::CallVirtualMethodAndReturn<bool, 26, CVehicle *, eDoors>(this, door);
   65  }

   68  bool CVehicle::IsDoorMissing(eDoors door) {
   69:     return plugin::CallVirtualMethodAndReturn<bool, 27, CVehicle *, eDoors>(this, door);
   70  }

   73  bool CVehicle::IsDoorReady(unsigned int door) {
   74:     return plugin::CallVirtualMethodAndReturn<bool, 28, CVehicle *, unsigned int>(this, door);
   75  }

   78  bool CVehicle::IsDoorMissing(unsigned int door) {
   79:     return plugin::CallVirtualMethodAndReturn<bool, 29, CVehicle *, unsigned int>(this, door);
   80  }

   83  bool CVehicle::IsOpenTopCar() {
   84:     return plugin::CallVirtualMethodAndReturn<bool, 30, CVehicle *>(this);
   85  }

   88  void CVehicle::RemoveRefsToVehicle(CEntity* entity) {
   89:     plugin::CallVirtualMethod<31, CVehicle *, CEntity*>(this, entity);
   90  }

   93  void CVehicle::BlowUpCar(CEntity* damager) {
   94:     plugin::CallVirtualMethod<32, CVehicle *, CEntity*>(this, damager);
   95  }

   98  bool CVehicle::SetUpWheelColModel(CColModel* wheelCol) {
   99:     return plugin::CallVirtualMethodAndReturn<bool, 33, CVehicle *, CColModel*>(this, wheelCol);
  100  }

  103  bool CVehicle::BurstTyre(unsigned char tyreComponentId, bool bPhysicalEffect) {
  104:     return plugin::CallVirtualMethodAndReturn<bool, 34, CVehicle *, unsigned char, bool>(this, tyreComponentId, bPhysicalEffect);
  105  }

  108  bool CVehicle::IsRoomForPedToLeaveCar(unsigned int arg0, CVector* arg1) {
  109:     return plugin::CallVirtualMethodAndReturn<bool, 35, CVehicle *, unsigned int, CVector*>(this, arg0, arg1);
  110  }

  113  bool CVehicle::IsClearToDriveAway() {
  114:     return plugin::CallVirtualMethodAndReturn<bool, 36, CVehicle *>(this);
  115  }

  118  float CVehicle::GetHeightAboveRoad() {
  119:     return plugin::CallVirtualMethodAndReturn<float, 37, CVehicle *>(this);
  120  }

  123  void CVehicle::PlayCarHorn() {
  124:     plugin::CallVirtualMethod<38, CVehicle *>(this);
  125  }

  128  void CVehicle::ActivateBomb() {
  129:     plugin::CallMethod<0x5B79E0, CVehicle *>(this);
  130  }

  133  void CVehicle::ActivateBombWhenEntered() {
  134:     plugin::CallMethod<0x5B7950, CVehicle *>(this);
  135  }

  138  bool CVehicle::AddPassenger(CPed* passenger) {
  139:     return plugin::CallMethodAndReturn<bool, 0x5B8E60, CVehicle *, CPed*>(this, passenger);
  140  }

  143  bool CVehicle::AddPassenger(CPed* passenger, unsigned char seatNumber) {
  144:     return plugin::CallMethodAndReturn<bool, 0x5B8D50, CVehicle *, CPed*, unsigned char>(this, passenger, seatNumber);
  145  }

  148  void CVehicle::BladeColSectorList(CPtrList& ptrList, CColModel& colModel, CMatrix& matrix, short arg3, float arg4) {
  149:     plugin::CallMethod<0x5B4610, CVehicle *, CPtrList&, CColModel&, CMatrix&, short, float>(this, ptrList, colModel, matrix, arg3, arg4);
  150  }

  153  bool CVehicle::CanBeDeleted() {
  154:     return plugin::CallMethodAndReturn<bool, 0x5BA960, CVehicle *>(this);
  155  }

  158  bool CVehicle::CanDoorsBeDamaged() {
  159:     return plugin::CallMethodAndReturn<bool, 0x5B8440, CVehicle *>(this);
  160  }

  163  bool CVehicle::CanPedEnterCar() {
  164:     return plugin::CallMethodAndReturn<bool, 0x5B8370, CVehicle *>(this);
  165  }

  168  bool CVehicle::CanPedExitCar(bool arg0) {
  169:     return plugin::CallMethodAndReturn<bool, 0x5B8180, CVehicle *, bool>(this, arg0);
  170  }

  173  bool CVehicle::CanPedJumpOffBike() {
  174:     return plugin::CallMethodAndReturn<bool, 0x5B8130, CVehicle *>(this);
  175  }

  178  bool CVehicle::CanPedJumpOutCar() {
  179:     return plugin::CallMethodAndReturn<bool, 0x5B80C0, CVehicle *>(this);
  180  }

  183  bool CVehicle::CanPedOpenLocks(CPed* ped) {
  184:     return plugin::CallMethodAndReturn<bool, 0x5B8460, CVehicle *, CPed*>(this, ped);
  185  }

  188  bool CVehicle::CarHasRoof() {
  189:     return plugin::CallMethodAndReturn<bool, 0x5B7910, CVehicle *>(this);
  190  }

  193  void CVehicle::ChangeLawEnforcerState(unsigned char state) {
  194:     plugin::CallMethod<0x5B7D90, CVehicle *, unsigned char>(this, state);
  195  }

  198  void CVehicle::DoBladeCollision(CVector arg0, CMatrix& matrix, short arg2, float arg3, float arg4) {
  199:     plugin::CallMethod<0x5B5030, CVehicle *, CVector, CMatrix&, short, float, float>(this, arg0, matrix, arg2, arg3, arg4);
  200  }

  203  void CVehicle::DoFixedMachineGuns() {
  204:     plugin::CallMethod<0x5C9170, CVehicle *>(this);
  205  }

  208  void CVehicle::DoSunGlare() {
  209:     plugin::CallMethod<0x5B3CD0, CVehicle *>(this);
  210  }

  213  void CVehicle::ExtinguishCarFire() {
  214:     plugin::CallMethod<0x5B7A80, CVehicle *>(this);
  215  }

  218  int CVehicle::FindTyreNearestPoint(float x, float y) {
  219:     return plugin::CallMethodAndReturn<int, 0x5B96A0, CVehicle *, float, float>(this, x, y);
  220  }

  223  void CVehicle::FireFixedMachineGuns() {
  224:     plugin::CallMethod<0x5C8E40, CVehicle *>(this);
  225  }

  228  void CVehicle::FlyingControl(eFlightModel flightModel) {
  229:     plugin::CallMethod<0x5B54C0, CVehicle *, eFlightModel>(this, flightModel);
  230  }

  233  int CVehicle::GetVehicleAppearance() {
  234:     return plugin::CallMethodAndReturn<int, 0x5BAA80, CVehicle *>(this);
  235  }

  238  void CVehicle::HeliDustGenerate(CEntity* arg0, float arg1, float arg2, int arg3) {
  239:     plugin::Call<0x5B3250, CEntity*, float, float, int>(arg0, arg1, arg2, arg3);
  240  }

  243  void CVehicle::InflictDamage(CEntity* damager, eWeaponType weapon, float intensity, CVector coords) {
  244:     plugin::CallMethod<0x5B9020, CVehicle *, CEntity*, eWeaponType, float, CVector>(this, damager, weapon, intensity, coords);
  245  }

  248  bool CVehicle::IsDriver(CPed* ped) {
  249:     return plugin::CallMethodAndReturn<bool, 0x5B8670, CVehicle *, CPed*>(this, ped);
  250  }

  253  bool CVehicle::IsDriver(int modelIndex) {
  254:     return plugin::CallMethodAndReturn<bool, 0x5B8640, CVehicle *, int>(this, modelIndex);
  255  }

  258  bool CVehicle::IsLawEnforcementVehicle() {
  259:     return plugin::CallMethodAndReturn<bool, 0x5B7D60, CVehicle *>(this);
  260  }

  263  bool CVehicle::IsOnItsSide() {
  264:     return plugin::CallMethodAndReturn<bool, 0x5B84B0, CVehicle *>(this);
  265  }

  268  bool CVehicle::IsPassenger(CPed* ped) {
  269:     return plugin::CallMethodAndReturn<bool, 0x5B86D0, CVehicle *, CPed*>(this, ped);
  270  }

  273  bool CVehicle::IsPassenger(int modelIndex) {
  274:     return plugin::CallMethodAndReturn<bool, 0x5B86A0, CVehicle *, int>(this, modelIndex);
  275  }

  278  bool CVehicle::IsSphereTouchingVehicle(float x, float y, float z, float radius) {
  279:     return plugin::CallMethodAndReturn<bool, 0x5B7F00, CVehicle *, float, float, float, float>(this, x, y, z, radius);
  280  }

  283  bool CVehicle::IsUpsideDown() {
  284:     return plugin::CallMethodAndReturn<bool, 0x5B84F0, CVehicle *>(this);
  285  }

  288  bool CVehicle::IsVehicleNormal() {
  289:     return plugin::CallMethodAndReturn<bool, 0x5B7DF0, CVehicle *>(this);
  290  }

  293  void CVehicle::KillPedsInVehicle() {
  294:     plugin::CallMethod<0x5B8560, CVehicle *>(this);
  295  }

  298  void CVehicle::MakeNonDraggedPedsLeaveVehicle(CPed* arg0, CPed* arg1, CPlayerPed*& arg2, CCopPed*& arg3) {
  299:     plugin::CallMethod<0x5B3A30, CVehicle *, CPed*, CPed*, CPlayerPed*&, CCopPed*&>(this, arg0, arg1, arg2, arg3);
  300  }

  303  void CVehicle::ProcessBikeWheel(CVector& arg0, CVector& arg1, CVector& arg2, CVector& arg3, int arg4, float arg5, float arg6, float arg7, float arg8, char arg9, float* arg10, tWheelState* arg11, eBikeWheelSpecial arg12, unsigned short arg13) {
  304:     plugin::CallMethod<0x5B9770, CVehicle *, CVector&, CVector&, CVector&, CVector&, int, float, float, float, float, char, float*, tWheelState*, eBikeWheelSpecial, unsigned short>(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
  305  }

  308  void CVehicle::ProcessCarAlarm() {
  309:     plugin::CallMethod<0x5B8040, CVehicle *>(this);
  310  }

  313  void CVehicle::ProcessDelayedExplosion() {
  314:     plugin::CallMethod<0x5B8F50, CVehicle *>(this);
  315  }

  318  void CVehicle::ProcessWheel(CVector& arg0, CVector& arg1, CVector& arg2, CVector& arg3, int arg4, float arg5, float arg6, float arg7, char arg8, float* arg9, tWheelState* arg10, unsigned short arg11) {
  319:     plugin::CallMethod<0x5BA070, CVehicle *, CVector&, CVector&, CVector&, CVector&, int, float, float, float, char, float*, tWheelState*, unsigned short>(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
  320  }

  323  float CVehicle::ProcessWheelRotation(tWheelState wheelState, CVector const& arg1, CVector const& arg2, float arg3) {
  324:     return plugin::CallMethodAndReturn<float, 0x5BA900, CVehicle *, tWheelState, CVector const&, CVector const&, float>(this, wheelState, arg1, arg2, arg3);
  325  }

  328  void CVehicle::RemoveDriver(bool arg0) {
  329:     plugin::CallMethod<0x5B8920, CVehicle *, bool>(this, arg0);
  330  }

  333  void CVehicle::RemovePassenger(CPed* passenger) {
  334:     plugin::CallMethod<0x5B8CE0, CVehicle *, CPed*>(this, passenger);
  335  }

  338  void CVehicle::SetComponentAtomicAlpha(RpAtomic* atomic, int alpha) {
  339:     plugin::CallMethod<0x5B45D0, CVehicle *, RpAtomic*, int>(this, atomic, alpha);
  340  }

  343  void CVehicle::SetDriver(CPed* driver) {
  344:     plugin::CallMethod<0x5B89F0, CVehicle *, CPed*>(this, driver);
  345  }

  348  CPed* CVehicle::SetUpDriver() {
  349:     return plugin::CallMethodAndReturn<CPed*, 0x5B8870, CVehicle *>(this);
  350  }

  353  CPed* CVehicle::SetupPassenger(int arg0) {
  354:     return plugin::CallMethodAndReturn<CPed*, 0x5B8700, CVehicle *, int>(this, arg0);
  355  }

  358  bool CVehicle::ShufflePassengersToMakeSpace() {
  359:     return plugin::CallMethodAndReturn<bool, 0x5B7B10, CVehicle *>(this);
  360  }

  363  void CVehicle::UpdateClumpAlpha() {
  364:     plugin::CallMethod<0x5B4580, CVehicle *>(this);
  365  }

  368  void CVehicle::UpdatePassengerList() {
  369:     plugin::CallMethod<0x5B39F0, CVehicle *>(this);
  370  }

  373  bool CVehicle::UsesSiren() {
  374:     return plugin::CallMethodAndReturn<bool, 0x5B8520, CVehicle *>(this);
  375  }

plugin_vc\game_vc\CVehicleModelInfo.cpp:
   17  void CVehicleModelInfo::AvoidSameVehicleColour(unsigned char* prim, unsigned char* sec) {
   18:     plugin::CallMethod<0x579090, CVehicleModelInfo *, unsigned char*, unsigned char*>(this, prim, sec);
   19  }

   22  int CVehicleModelInfo::ChooseComponent() {
   23:     return plugin::CallMethodAndReturn<int, 0x579670, CVehicleModelInfo *>(this);
   24  }

   27  int CVehicleModelInfo::ChooseSecondComponent() {
   28:     return plugin::CallMethodAndReturn<int, 0x5794F0, CVehicleModelInfo *>(this);
   29  }

   32  void CVehicleModelInfo::ChooseVehicleColour(unsigned char& prim, unsigned char& sec) {
   33:     plugin::CallMethod<0x579190, CVehicleModelInfo *, unsigned char&, unsigned char&>(this, prim, sec);
   34  }

   37  RwObject* CVehicleModelInfo::ClearAtomicFlagCB(RwObject* object, void* data) {
   38:     return plugin::CallAndReturn<RwObject*, 0x579FD0, RwObject*, void*>(object, data);
   39  }

   42  RwFrame* CVehicleModelInfo::CollapseFramesCB(RwFrame* frame, void* data) {
   43:     return plugin::CallAndReturn<RwFrame*, 0x57A660, RwFrame*, void*>(frame, data);
   44  }

   47  void CVehicleModelInfo::DeleteVehicleColourTextures() {
   48:     plugin::Call<0x578C90>();
   49  }

   52  int CVehicleModelInfo::FindEditableMaterialList() {
   53:     return plugin::CallMethodAndReturn<int, 0x579390, CVehicleModelInfo *>(this);
   54  }

   57  RpAtomic* CVehicleModelInfo::GetEditableMaterialListCB(RpAtomic* atomic, void* data) {
   58:     return plugin::CallAndReturn<RpAtomic*, 0x579440, RpAtomic*, void*>(atomic, data);
   59  }

   62  RpMaterial* CVehicleModelInfo::GetEditableMaterialListCB(RpMaterial* material, void* data) {
   63:     return plugin::CallAndReturn<RpMaterial*, 0x579460, RpMaterial*, void*>(material, data);
   64  }

   67  RpMaterial* CVehicleModelInfo::GetMatFXEffectMaterialCB(RpMaterial* material, void* data) {
   68:     return plugin::CallAndReturn<RpMaterial*, 0x578BA0, RpMaterial*, void*>(material, data);
   69  }

   72  int CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors(int modelId) {
   73:     return plugin::CallAndReturn<int, 0x578A70, int>(modelId);
   74  }

   77  void CVehicleModelInfo::GetWheelPosn(int wheel, CVector& outVec) {
   78:     plugin::CallMethod<0x579AD0, CVehicleModelInfo *, int, CVector&>(this, wheel, outVec);
   79  }

   82  RpMaterial* CVehicleModelInfo::HasAlphaMaterialCB(RpMaterial* material, void* data) {
   83:     return plugin::CallAndReturn<RpMaterial*, 0x57A600, RpMaterial*, void*>(material, data);
   84  }

   87  RpAtomic* CVehicleModelInfo::HideAllComponentsAtomicCB(RpAtomic* atomic, void* data) {
   88:     return plugin::CallAndReturn<RpAtomic*, 0x57A620, RpAtomic*, void*>(atomic, data);
   89  }

   92  void CVehicleModelInfo::LoadEnvironmentMaps() {
   93:     plugin::Call<0x578C30>();
   94  }

   97  void CVehicleModelInfo::LoadVehicleColours() {
   98:     plugin::Call<0x578CC0>();
   99  }

  102  RpAtomic* CVehicleModelInfo::MoveObjectsCB(RwObject* object, void* data) {
  103:     return plugin::CallAndReturn<RpAtomic*, 0x57A640, RwObject*, void*>(object, data);
  104  }

  107  void CVehicleModelInfo::PreprocessHierarchy() {
  108:     plugin::CallMethod<0x579B10, CVehicleModelInfo *>(this);
  109  }

  112  RwObject* CVehicleModelInfo::SetAtomicFlagCB(RwObject* object, void* data) {
  113:     return plugin::CallAndReturn<RwObject*, 0x579FF0, RwObject*, void*>(object, data);
  114  }

  117  RpAtomic* CVehicleModelInfo::SetAtomicRendererCB(RpAtomic* atomic, void* data) {
  118:     return plugin::CallAndReturn<RpAtomic*, 0x57A4A0, RpAtomic*, void*>(atomic, data);
  119  }

  122  RpAtomic* CVehicleModelInfo::SetAtomicRendererCB_BigVehicle(RpAtomic* atomic, void* data) {
  123:     return plugin::CallAndReturn<RpAtomic*, 0x57A1E0, RpAtomic*, void*>(atomic, data);
  124  }

  127  RpAtomic* CVehicleModelInfo::SetAtomicRendererCB_Boat(RpAtomic* atomic, void* data) {
  128:     return plugin::CallAndReturn<RpAtomic*, 0x57A070, RpAtomic*, void*>(atomic, data);
  129  }

  132  RpAtomic* CVehicleModelInfo::SetAtomicRendererCB_Heli(RpAtomic* atomic, void* data) {
  133:     return plugin::CallAndReturn<RpAtomic*, 0x57A010, RpAtomic*, void*>(atomic, data);
  134  }

  137  RpAtomic* CVehicleModelInfo::SetAtomicRendererCB_RealHeli(RpAtomic* atomic, void* data) {
  138:     return plugin::CallAndReturn<RpAtomic*, 0x57A300, RpAtomic*, void*>(atomic, data);
  139  }

  142  RpMaterial* CVehicleModelInfo::SetDefaultEnvironmentMapCB(RpMaterial* material, void* data) {
  143:     return plugin::CallAndReturn<RpMaterial*, 0x578B40, RpMaterial*, void*>(material, data);
  144  }

  147  RpAtomic* CVehicleModelInfo::SetEnvironmentMapCB(RpAtomic* atomic, void* data) {
  148:     return plugin::CallAndReturn<RpAtomic*, 0x578AF0, RpAtomic*, void*>(atomic, data);
  149  }

  152  void CVehicleModelInfo::SetVehicleColour(unsigned char prim, unsigned char sec) {
  153:     plugin::CallMethod<0x579290, CVehicleModelInfo *, unsigned char, unsigned char>(this, prim, sec);
  154  }

  157  void CVehicleModelInfo::SetVehicleComponentFlags(RwFrame* component, unsigned int flags) {
  158:     plugin::CallMethod<0x579E80, CVehicleModelInfo *, RwFrame*, unsigned int>(this, component, flags);
  159  }

  162  void CVehicleModelInfo::ShutdownEnvironmentMaps() {
  163:     plugin::Call<0x578BD0>();
  164  }

  167  VehicleModelStore::~VehicleModelStore() {
  168:     plugin::CallMethod<0x560150, VehicleModelStore *>(this);
  169  }

  172  int GetListOfComponentsNotUsedByRules(unsigned int compRulesBits, int numExtras, int* variationsList) {
  173:     return plugin::CallAndReturn<int, 0x5799B0, unsigned int, int, int*>(compRulesBits, numExtras, variationsList);
  174  }

  177  int ChooseComponent(int rule, int compRulesBits) {
  178:     return plugin::CallAndReturn<int, 0x5797C0, int, int>(rule, compRulesBits);
  179  }

plugin_vc\game_vc\CVisibilityPlugins.cpp:
   9  void CVisibilityPlugins::SetAtomicRenderCallback(RpAtomic* atomic, RpAtomicCallBackRender cb) {
  10:     plugin::Call<0x581940>(atomic, cb);
  11  }

plugin_vc\game_vc\CWanted.cpp:
   13  bool CWanted::AddCrimeToQ(eCrimeType crimeType, int arg1, CVector const& arg2, bool arg3, bool arg4) {
   14:     return plugin::CallMethodAndReturn<bool, 0x4D1990, CWanted *, eCrimeType, int, CVector const&, bool, bool>(this, crimeType, arg1, arg2, arg3, arg4);
   15  }

   18  bool CWanted::AreArmyRequired() {
   19:     return plugin::CallMethodAndReturn<bool, 0x4D1E20, CWanted *>(this);
   20  }

   23  bool CWanted::AreFbiRequired() {
   24:     return plugin::CallMethodAndReturn<bool, 0x4D1E40, CWanted *>(this);
   25  }

   28  bool CWanted::AreMiamiViceRequired() {
   29:     return plugin::CallMethodAndReturn<bool, 0x4D1E80, CWanted *>(this);
   30  }

   33  bool CWanted::AreSwatRequired() {
   34:     return plugin::CallMethodAndReturn<bool, 0x4D1E60, CWanted *>(this);
   35  }

   38  void CWanted::CheatWantedLevel(int arg0) {
   39:     plugin::CallMethod<0x4D1F80, CWanted *, int>(this, arg0);
   40  }

   43  void CWanted::ClearQdCrimes() {
   44:     plugin::CallMethod<0x4D1A50, CWanted *>(this);
   45  }

   48  void CWanted::Initialise() {
   49:     plugin::CallMethod<0x4D2440, CWanted *>(this);
   50  }

   53  bool CWanted::NumOfHelisRequired() {
   54:     return plugin::CallMethodAndReturn<bool, 0x4D1DE0, CWanted *>(this);
   55  }

   58  void CWanted::RegisterCrime(eCrimeType crimeType, CVector const& arg1, unsigned int arg2, bool arg3) {
   59:     plugin::CallMethod<0x4D20F0, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, arg1, arg2, arg3);
   60  }

   63  void CWanted::RegisterCrime_Immediately(eCrimeType crimeType, CVector const& arg1, unsigned int arg2, bool arg3) {
   64:     plugin::CallMethod<0x4D20B0, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, arg1, arg2, arg3);
   65  }

   68  void CWanted::ReportCrimeNow(eCrimeType crimeType, CVector const& arg1, bool arg2) {
   69:     plugin::CallMethod<0x4D1610, CWanted *, eCrimeType, CVector const&, bool>(this, crimeType, arg1, arg2);
   70  }

   73  void CWanted::Reset() {
   74:     plugin::CallMethod<0x4D2420, CWanted *>(this);
   75  }

   78  void CWanted::ResetPolicePursuit() {
   79:     plugin::CallMethod<0x4D1D20, CWanted *>(this);
   80  }

   83  void CWanted::SetMaximumWantedLevel(int level) {
   84:     plugin::Call<0x4D1E90, int>(level);
   85  }

   88  void CWanted::SetWantedLevel(int level) {
   89:     plugin::CallMethod<0x4D1FA0, CWanted *, int>(this, level);
   90  }

   93  void CWanted::SetWantedLevelNoDrop(int arg0) {
   94:     plugin::CallMethod<0x4D1F50, CWanted *, int>(this, arg0);
   95  }

   98  void CWanted::Update() {
   99:     plugin::CallMethod<0x4D2260, CWanted *>(this);
  100  }

  103  void CWanted::UpdateWantedLevel() {
  104:     plugin::CallMethod<0x4D2110, CWanted *>(this);
  105  }

  108  void CWanted::WorkOutPolicePresence(CVector arg0, float arg1) {
  109:     plugin::Call<0x4D1B00, CVector, float>(arg0, arg1);
  110  }

plugin_vc\game_vc\CWaterCannons.cpp:
  14  CWaterCannon::CWaterCannon() {
  15:     plugin::CallMethod<0x57BE40, CWaterCannon *>(this);
  16  }

  19  void CWaterCannon::Init() {
  20:     plugin::CallMethod<0x57BCD0, CWaterCannon *>(this);
  21  }

  24  void CWaterCannon::PushPeds() {
  25:     plugin::CallMethod<0x57B2F0, CWaterCannon *>(this);
  26  }

  29  void CWaterCannon::Render() {
  30:     plugin::CallMethod<0x57B810, CWaterCannon *>(this);
  31  }

  34  void CWaterCannon::Update_OncePerFrame(short index) {
  35:     plugin::CallMethod<0x57BB90, CWaterCannon *, short>(this, index);
  36  }

  39  void CWaterCannons::Init() {
  40:     plugin::Call<0x57B2C0>();
  41  }

  44  void CWaterCannons::Render() {
  45:     plugin::Call<0x57B0E0>();
  46  }

  49  void CWaterCannons::Update() {
  50:     plugin::Call<0x57B120>();
  51  }

  54  void CWaterCannons::UpdateOne(unsigned int pCar, CVector* posn, CVector* moveSpeed) {
  55:     plugin::Call<0x57B160, unsigned int, CVector*, CVector*>(pCar, posn, moveSpeed);
  56  }

plugin_vc\game_vc\CWeaponEffects.cpp:
  16  CWeaponEffects::CWeaponEffects() {
  17:     plugin::CallMethod<0x5D5140, CWeaponEffects *>(this);
  18  }

  21  void CWeaponEffects::ClearCrossHair() {
  22:     plugin::Call<0x5D5050>();
  23  }

  26  void CWeaponEffects::Init() {
  27:     plugin::Call<0x5D50B0>();
  28  }

  31  void CWeaponEffects::MarkTarget(CVector pos, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, float size) {
  32:     plugin::Call<0x5D5060, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float>(pos, red, green, blue, alpha, size);
  33  }

  36  void CWeaponEffects::Render() {
  37:     plugin::Call<0x5D4E90>();
  38  }

  41  void CWeaponEffects::Shutdown() {
  42:     plugin::Call<0x5D5090>();
  43  }

plugin_vc\game_vc\CWeaponInfo.cpp:
  13  CWeaponInfo::CWeaponInfo() {
  14:     plugin::CallMethod<0x5D58D0, CWeaponInfo *>(this);
  15  }

  18  CWeaponInfo::~CWeaponInfo() {
  19:     plugin::CallMethod<0x5D58C0, CWeaponInfo *>(this);
  20  }

  23  eWeaponFire CWeaponInfo::FindWeaponFireType(char* name) {
  24:     return plugin::CallAndReturn<eWeaponFire, 0x5D5170, char*>(name);
  25  }

  28  CWeaponInfo* CWeaponInfo::GetWeaponInfo(eWeaponType weaponType) {
  29:     return plugin::CallAndReturn<CWeaponInfo*, 0x5D5710, eWeaponType>(weaponType);
  30  }

  33  void CWeaponInfo::Initialise() {
  34:     plugin::Call<0x5D5750>();
  35  }

  38  void CWeaponInfo::LoadWeaponData() {
  39:     plugin::Call<0x5D5250>();
  40  }

  43  void CWeaponInfo::Shutdown() {
  44:     plugin::Call<0x5D5730>();
  45  }

plugin_vc\game_vc\CWeaponModelInfo.cpp:
  10  int CWeaponModelInfo::GetWeaponInfo() {
  11:     return plugin::CallMethodAndReturn<int, 0x629C20, CWeaponModelInfo *>(this);
  12  }

  15  void CWeaponModelInfo::Init() {
  16:     plugin::CallMethod<0x629C70, CWeaponModelInfo *>(this);
  17  }

  20  int CWeaponModelInfo::SetWeaponInfo(int weaponType) {
  21:     return plugin::CallMethodAndReturn<int, 0x629C30, CWeaponModelInfo *, int>(this, weaponType);
  22  }

  25  WeaponModelStore::~WeaponModelStore() {
  26:     plugin::CallMethod<0x5601E0, WeaponModelStore *>(this);
  27  }

plugin_vc\game_vc\CWeather.cpp:
  22  void CWeather::AddRain() {
  23:     plugin::Call<0x57C900>();
  24  }

  27  void CWeather::AddSplashesDuringHurricane() {
  28:     plugin::Call<0x57D160>();
  29  }

  32  void CWeather::AddStreamAfterRain() {
  33:     plugin::Call<0x57D340>();
  34  }

  37  void CWeather::ForceWeather(short weather) {
  38:     plugin::Call<0x57D570, short>(weather);
  39  }

  42  void CWeather::ForceWeatherNow(short weather) {
  43:     plugin::Call<0x57D550, short>(weather);
  44  }

  47  void CWeather::Init() {
  48:     plugin::Call<0x57E040>();
  49  }

  52  void CWeather::ReleaseWeather() {
  53:     plugin::Call<0x57D540>();
  54  }

  57  void CWeather::RenderRainStreaks() {
  58:     plugin::Call<0x57BF40>();
  59  }

  62  void CWeather::Update() {
  63:     plugin::Call<0x57D580>();
  64  }

plugin_vc\game_vc\CWindModifiers.cpp:
  17  bool CWindModifiers::FindWindModifier(CVector pos, float *x, float *y) {
  18:     return plugin::CallAndReturnDynGlobal<bool, CVector, float *, float *>(gaddrof_o(CWindModifiers::FindWindModifier, bool (*)(CVector, float *, float *)), pos, x, y);
  19  }

  24  void CWindModifiers::RegisterOne(CVector pos, int type) {
  25:     plugin::CallDynGlobal<CVector, int>(gaddrof_o(CWindModifiers::RegisterOne, void (*)(CVector, int)), pos, type);
  26  }

plugin_vc\game_vc\CWorld.cpp:
   31  void CWorld::Add(CEntity* entity) {
   32:     plugin::Call<0x4DB3F0, CEntity*>(entity);
   33  }

   36  void CWorld::AddParticles() {
   37:     plugin::Call<0x4D4BB0>();
   38  }

   41  void CWorld::CallOffChaseForArea(float x1, float y1, float x2, float y2) {
   42:     plugin::Call<0x4D3200, float, float, float, float>(x1, y1, x2, y2);
   43  }

   46  void CWorld::CallOffChaseForAreaSectorListPeds(CPtrList& list, float x1, float y1, float x2, float y2, float arg5, float arg6, float arg7, float arg8) {
   47:     plugin::Call<0x4D2DF0, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
   48  }

   51  void CWorld::CallOffChaseForAreaSectorListVehicles(CPtrList& list, float x1, float y1, float x2, float y2, float arg5, float arg6, float arg7, float arg8) {
   52:     plugin::Call<0x4D2F50, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
   53  }

   56  void CWorld::ClearCarsFromArea(float x1, float y1, float z1, float x2, float y2, float z2) {
   57:     plugin::Call<0x4D3700, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
   58  }

   61  void CWorld::ClearExcitingStuffFromArea(CVector const& point, float radius, unsigned char bRemoveProjectilesAndShadows) {
   62:     plugin::Call<0x4D38F0, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);
   63  }

   66  void CWorld::ClearForRestart() {
   67:     plugin::Call<0x4DB4A0>();
   68  }

   71  void CWorld::ClearPedsFromArea(float x1, float y1, float z1, float x2, float y2, float z2) {
   72:     plugin::Call<0x4D35C0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
   73  }

   76  void CWorld::ClearScanCodes() {
   77:     plugin::Call<0x4D7460>();
   78  }

   81  void CWorld::ExtinguishAllCarFiresInArea(CVector point, float radius) {
   82:     plugin::Call<0x4D3480, CVector, float>(point, radius);
   83  }

   86  float CWorld::FindGroundZFor3DCoord(float x, float y, float z, bool* outResult) {
   87:     return plugin::CallAndReturn<float, 0x4D53A0, float, float, float, bool*>(x, y, z, outResult);
   88  }

   91  float CWorld::FindGroundZForCoord(float x, float y) {
   92:     return plugin::CallAndReturn<float, 0x4D5540, float, float>(x, y);
   93  }

   96  void CWorld::FindMissionEntitiesIntersectingCube(CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool vehicles, bool peds, bool objects) {
   97:     plugin::Call<0x4D5800, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);
   98  }

  101  void CWorld::FindMissionEntitiesIntersectingCubeSectorList(CPtrList& list, CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool vehiclesList, bool pedsList, bool objectsList) {
  102:     plugin::Call<0x4D56B0, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);
  103  }

  106  void CWorld::FindObjectsInRange(CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  107:     plugin::Call<0x4D6B90, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  108  }

  111  void CWorld::FindObjectsInRangeSectorList(CPtrList& list, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  112:     plugin::Call<0x4D6AD0, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
  113  }

  116  void CWorld::FindObjectsIntersectingAngledCollisionBox(CBox const& box, CMatrix const& transform, CVector const& point, float x1, float y1, float x2, float y2, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  117:     plugin::Call<0x4D5B90, CBox const&, CMatrix const&, CVector const&, float, float, float, float, short*, short, CEntity**, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  118  }

  121  void CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(CPtrList& list, CBox const& box, CMatrix const& transform, CVector const& point, short* outCount, short maxCount, CEntity** outEntities) {
  122:     plugin::Call<0x4D5A90, CPtrList&, CBox const&, CMatrix const&, CVector const&, short*, short, CEntity**>(list, box, transform, point, outCount, maxCount, outEntities);
  123  }

  126  void CWorld::FindObjectsIntersectingCube(CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  127:     plugin::Call<0x4D5FB0, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  128  }

  131  void CWorld::FindObjectsIntersectingCubeSectorList(CPtrList& list, CVector const& cornerA, CVector const& cornerB, short* outCount, short maxCount, CEntity** outEntities) {
  132:     plugin::Call<0x4D5EA0, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**>(list, cornerA, cornerB, outCount, maxCount, outEntities);
  133  }

  136  void CWorld::FindObjectsKindaColliding(CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  137:     plugin::Call<0x4D6370, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  138  }

  141  void CWorld::FindObjectsKindaCollidingSectorList(CPtrList& list, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  142:     plugin::Call<0x4D6280, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
  143  }

  146  void CWorld::FindObjectsOfTypeInRange(unsigned int modelId, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities, bool buildings, bool vehicles, bool peds, bool objects, bool dummies) {
  147:     plugin::Call<0x4D6770, unsigned int, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
  148  }

  151  void CWorld::FindObjectsOfTypeInRangeSectorList(unsigned int modelId, CPtrList& list, CVector const& point, float radius, bool b2D, short* outCount, short maxCount, CEntity** outEntities) {
  152:     plugin::Call<0x4D66A0, unsigned int, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(modelId, list, point, radius, b2D, outCount, maxCount, outEntities);
  153  }

  156  float CWorld::FindRoofZFor3DCoord(float x, float y, float z, bool* outResult) {
  157:     return plugin::CallAndReturn<float, 0x4D51D0, float, float, float, bool*>(x, y, z, outResult);
  158  }

  161  bool CWorld::GetIsLineOfSightClear(CVector const& origin, CVector const& target, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  162:     return plugin::CallAndReturn<bool, 0x4DA560, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  163  }

  166  bool CWorld::GetIsLineOfSightSectorClear(CSector& sector, CColLine const& line, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck) {
  167:     return plugin::CallAndReturn<bool, 0x4D6EC0, CSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
  168  }

  171  void CWorld::Initialise() {
  172:     plugin::Call<0x4DB9A0>();
  173  }

  176  bool CWorld::IsWanderPathClear(CVector const& origin, CVector const& target, float arg2, int arg3) {
  177:     return plugin::CallAndReturn<bool, 0x4D2620, CVector const&, CVector const&, float, int>(origin, target, arg2, arg3);
  178  }

  181  void CWorld::Process() {
  182:     plugin::Call<0x4D7500>();
  183  }

  186  bool CWorld::ProcessLineOfSight(CVector const& origin, CVector const& target, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck, bool doShootThroughCheck) {
  187:     return plugin::CallAndReturn<bool, 0x4D92D0, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
  188  }

  191  bool CWorld::ProcessLineOfSightSector(CSector& sector, CColLine const& line, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, bool doCameraIgnoreCheck, bool doShootThroughCheck) {
  192:     return plugin::CallAndReturn<bool, 0x4D9060, CSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
  193  }

  196  bool CWorld::ProcessLineOfSightSectorList(CPtrList& list, CColLine const& line, CColPoint& outColPoint, float& maxTouchDistance, CEntity*& outEntity, bool doSeeThroughCheck, bool doCameraIgnoreCheck, bool doShootThroughCheck) {
  197:     return plugin::CallAndReturn<bool, 0x4D8C60, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
  198  }

  201  bool CWorld::ProcessVerticalLine(CVector const& origin, float distance, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  202:     return plugin::CallAndReturn<bool, 0x4D8B00, CVector const&, float, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  203  }

  206  bool CWorld::ProcessVerticalLineSector(CSector& sector, CColLine const& line, CColPoint& outColPoint, CEntity*& outEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck, CStoredCollPoly* outCollPoly) {
  207:     return plugin::CallAndReturn<bool, 0x4D84D0, CSector&, CColLine const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
  208  }

  211  void CWorld::Remove(CEntity* entity) {
  212:     plugin::Call<0x4DB310, CEntity*>(entity);
  213  }

  216  void CWorld::RemoveFallenCars() {
  217:     plugin::Call<0x4D48A0>();
  218  }

  221  void CWorld::RemoveFallenPeds() {
  222:     plugin::Call<0x4D4A40>();
  223  }

  226  void CWorld::RemoveReferencesToDeletedObject(CEntity* entity) {
  227:     plugin::Call<0x4D5090, CEntity*>(entity);
  228  }

  231  void CWorld::RepositionCertainDynamicObjects() {
  232:     plugin::Call<0x4D4850>();
  233  }

  236  void CWorld::RepositionOneObject(CEntity* entity) {
  237:     plugin::Call<0x4D43A0, CEntity*>(entity);
  238  }

  241  void CWorld::SetAllCarsCanBeDamaged(bool enable) {
  242:     plugin::Call<0x4D3550, bool>(enable);
  243  }

  246  void CWorld::SetCarsOnFire(float x, float y, float z, float radius, CEntity* fireCreator) {
  247:     plugin::Call<0x4D4C30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
  248  }

  251  void CWorld::SetPedsChoking(float x, float y, float z, float radius, CEntity* gasCreator) {
  252:     plugin::Call<0x4D4D90, float, float, float, float, CEntity*>(x, y, z, radius, gasCreator);
  253  }

  256  void CWorld::SetPedsOnFire(float x, float y, float z, float radius, CEntity* fireCreator) {
  257:     plugin::Call<0x4D4F30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
  258  }

  261  void CWorld::ShutDown() {
  262:     plugin::Call<0x4DB590>();
  263  }

  266  void CWorld::StopAllLawEnforcersInTheirTracks() {
  267:     plugin::Call<0x4D25B0>();
  268  }

  271  CEntity* CWorld::TestSphereAgainstSectorList(CPtrList& list, CVector sphereCenter, float sphereRadius, CEntity* ignoreEntity, bool doCameraIgnoreCheck) {
  272:     return plugin::CallAndReturn<CEntity*, 0x4D3C40, CPtrList&, CVector, float, CEntity*, bool>(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);
  273  }

  276  CEntity* CWorld::TestSphereAgainstWorld(CVector sphereCenter, float sphereRadius, CEntity* ignoreEntity, bool buildings, bool vehicles, bool peds, bool objects, bool dummies, bool doSeeThroughCheck) {
  277:     return plugin::CallAndReturn<CEntity*, 0x4D3F40, CVector, float, CEntity*, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck);
  278  }

  281  void CWorld::TriggerExplosion(CVector const& point, float radius, float visibleDistance, CEntity* entity, bool processVehicleBombTimer) {
  282:     plugin::Call<0x4D82D0, CVector const&, float, float, CEntity*, bool>(point, radius, visibleDistance, entity, processVehicleBombTimer);
  283  }

  286  void CWorld::TriggerExplosionSectorList(CPtrList& list, CVector const& point, float radius, float visibleDistance, CEntity* entity, bool processVehicleBombTimer) {
  287:     plugin::Call<0x4D7B90, CPtrList&, CVector const&, float, float, CEntity*, bool>(list, point, radius, visibleDistance, entity, processVehicleBombTimer);
  288  }

  291  void CWorld::UseDetonator(CEntity* creator) {
  292:     plugin::Call<0x4D42F0, CEntity*>(creator);
  293  }

plugin_vc\game_vc\CZone.cpp:
  10  wchar_t* CZone::GetTranslatedName() {
  11:     return plugin::CallMethodAndReturn<wchar_t*, 0x4DE4B0, CZone*>(this);
  12  }

plugin_vc\game_vc\NodeName.cpp:
  16  char *GetFrameNodeName(RwFrame *frame) {
  17:     return plugin::CallAndReturnDynGlobal<char *, RwFrame *>(gaddrof(GetFrameNodeName), frame);
  18  }

  23  RwBool NodeNamePluginAttach() {
  24:     return plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(NodeNamePluginAttach));
  25  }

  30  RwInt32 NodeNameStreamGetSize(void const *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  31:     return plugin::CallAndReturnDynGlobal<RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamGetSize), object, offsetInObject, sizeInObject);
  32  }

  37  RwStream *NodeNameStreamRead(RwStream *stream, RwInt32 binaryLength, void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  38:     return plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void *, RwInt32, RwInt32>(gaddrof(NodeNameStreamRead), stream, binaryLength, object, offsetInObject, sizeInObject);
  39  }

  44  RwStream *NodeNameStreamWrite(RwStream *stream, RwInt32 binaryLength, void const *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  45:     return plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamWrite), stream, binaryLength, object, offsetInObject, sizeInObject);
  46  }

  51  void *NodeNameCopy(void *dstObject, void const *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  52:     return plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(NodeNameCopy), dstObject, srcObject, offsetInObject, sizeInObject);
  53  }

  58  void *NodeNameDestructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  59:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameDestructor), object, offsetInObject, sizeInObject);
  60  }

  65  void *NodeNameConstructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject) {
  66:     return plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameConstructor), object, offsetInObject, sizeInObject);
  67  }

plugin_vc\game_vc\meta\meta.cAudioScriptObject.h:
  157      SUPPORTED_10EN_11EN_STEAM stack_object() {
  158:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));
  159      }
  160      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  161:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));
  162      }

  166  SUPPORTED_10EN_11EN_STEAM inline cAudioScriptObject *operator_new<cAudioScriptObject>() {
  167:     void *objData = plugin::CallAndReturnDynGlobal<void *, unsigned int>(op_new_gaddr(cAudioScriptObject), sizeof(cAudioScriptObject));
  168      cAudioScriptObject *obj = reinterpret_cast<cAudioScriptObject *>(objData);
  169:     plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), obj);
  170      return obj;

  177      for (unsigned int i = 0; i < objCount; i++)
  178:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), &objArray[i]);
  179      return objArray;

  183      if (obj == nullptr) return;
  184:     plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), obj);
  185:     plugin::CallDynGlobal<void *>(op_delete_gaddr(cAudioScriptObject), obj);
  186  }

  192      for (unsigned int i = 0; i < arraySize; i++)
  193:         plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), &objArray[i]);
  194      operator delete(objData);

plugin_vc\game_vc\meta\meta.CBulletTrace.h:
  28      SUPPORTED_10EN_11EN_STEAM stack_object() {
  29:         plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), reinterpret_cast<CBulletTrace *>(objBuff));
  30      }

  36      CBulletTrace *obj = reinterpret_cast<CBulletTrace *>(objData);
  37:     plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), obj);
  38      return obj;

  45      for (unsigned int i = 0; i < objCount; i++)
  46:         plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), &objArray[i]);
  47      return objArray;

plugin_vc\game_vc\meta\meta.CCutsceneShadow.h:
  163      SUPPORTED_10EN_11EN_STEAM stack_object() {
  164:         plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), reinterpret_cast<CCutsceneShadow *>(objBuff));
  165      }
  166      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  167:         plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), reinterpret_cast<CCutsceneShadow *>(objBuff));
  168      }

  174      CCutsceneShadow *obj = reinterpret_cast<CCutsceneShadow *>(objData);
  175:     plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), obj);
  176      return obj;

  183      for (unsigned int i = 0; i < objCount; i++)
  184:         plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), &objArray[i]);
  185      return objArray;

  189      if (obj == nullptr) return;
  190:     plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), obj);
  191      operator delete(obj);

  198      for (unsigned int i = 0; i < arraySize; i++)
  199:         plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), &objArray[i]);
  200      operator delete(objData);

plugin_vc\game_vc\meta\meta.CDirectory.h:
  103      SUPPORTED_10EN stack_object(int entriesNum) {
  104:         plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), reinterpret_cast<CDirectory *>(objBuff), entriesNum);
  105      }
  106      SUPPORTED_10EN ~stack_object() {
  107:         plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), reinterpret_cast<CDirectory *>(objBuff));
  108      }

  114      CDirectory *obj = reinterpret_cast<CDirectory *>(objData);
  115:     plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), obj, entriesNum);
  116      return obj;

  120      if (obj == nullptr) return;
  121:     plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), obj);
  122      operator delete(obj);

  129      for (unsigned int i = 0; i < arraySize; i++)
  130:         plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), &objArray[i]);
  131      operator delete(objData);

plugin_vc\game_vc\meta\meta.CPad.h:
  1078      SUPPORTED_10EN_11EN_STEAM stack_object() {
  1079:         plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), reinterpret_cast<CPad *>(objBuff));
  1080      }
  1081      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  1082:         plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), reinterpret_cast<CPad *>(objBuff));
  1083      }

  1089      CPad *obj = reinterpret_cast<CPad *>(objData);
  1090:     plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), obj);
  1091      return obj;

  1098      for (unsigned int i = 0; i < objCount; i++)
  1099:         plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), &objArray[i]);
  1100      return objArray;

  1104      if (obj == nullptr) return;
  1105:     plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), obj);
  1106      operator delete(obj);

  1113      for (unsigned int i = 0; i < arraySize; i++)
  1114:         plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), &objArray[i]);
  1115      operator delete(objData);

plugin_vc\game_vc\meta\meta.CParticle.h:
  1333      SUPPORTED_10EN_11EN_STEAM stack_object() {
  1334:         plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));
  1335      }
  1336      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  1337:         plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));
  1338      }

  1344      CParticle *obj = reinterpret_cast<CParticle *>(objData);
  1345:     plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), obj);
  1346      return obj;

  1353      for (unsigned int i = 0; i < objCount; i++)
  1354:         plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), &objArray[i]);
  1355      return objArray;

  1359      if (obj == nullptr) return;
  1360:     plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), obj);
  1361      operator delete(obj);

  1368      for (unsigned int i = 0; i < arraySize; i++)
  1369:         plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), &objArray[i]);
  1370      operator delete(objData);

plugin_vc\game_vc\meta\meta.CPedAttractor.h:
  193      SUPPORTED_10EN_11EN_STEAM stack_object(C2dEffect *effect, CMatrix const &matrix, int maxPeds, float qDist, float waitTime, float approachTime, float distance, float headingDiff, float posDisp, float headDisp) {
  194:         plugin::CallMethodDynGlobal<CPedAttractor *, C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float>(ctor_gaddr_o(CPedAttractor, void(C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float)), reinterpret_cast<CPedAttractor *>(objBuff), effect, matrix, maxPeds, qDist, waitTime, approachTime, distance, headingDiff, posDisp, headDisp);
  195      }
  196      SUPPORTED_10EN_11EN_STEAM ~stack_object() {
  197:         plugin::CallMethodDynGlobal<CPedAttractor *>(dtor_gaddr(CPedAttractor), reinterpret_cast<CPedAttractor *>(objBuff));
  198      }

  204      CPedAttractor *obj = reinterpret_cast<CPedAttractor *>(objData);
  205:     plugin::CallMethodDynGlobal<CPedAttractor *, C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float>(ctor_gaddr_o(CPedAttractor, void(C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float)), obj, effect, matrix, maxPeds, qDist, waitTime, approachTime, distance, headingDiff, posDisp, headDisp);
  206      return obj;

  210      if (obj == nullptr) return;
  211:     plugin::CallVirtualMethod<1, CPedAttractor *, unsigned char>(obj, 1);
  212  }

  218      for (unsigned int i = 0; i < arraySize; i++)
  219:         plugin::CallVirtualMethod<1, CPedAttractor *, unsigned char>(&objArray[i], 1);
  220      operator delete(objData);

plugin_vc\game_vc\meta\meta.CPhone.h:
  43      SUPPORTED_10EN_11EN stack_object() {
  44:         plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));
  45      }
  46      SUPPORTED_10EN_11EN ~stack_object() {
  47:         plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));
  48      }

  54      CPhone *obj = reinterpret_cast<CPhone *>(objData);
  55:     plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), obj);
  56      return obj;

  63      for (unsigned int i = 0; i < objCount; i++)
  64:         plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), &objArray[i]);
  65      return objArray;

  69      if (obj == nullptr) return;
  70:     plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), obj);
  71      operator delete(obj);

  78      for (unsigned int i = 0; i < arraySize; i++)
  79:         plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), &objArray[i]);
  80      operator delete(objData);

plugin_vc\game_vc\meta\meta.CPhoneInfo.h:
  178      SUPPORTED_10EN_11EN ~stack_object() {
  179:         plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));
  180      }

  185      if (obj == nullptr) return;
  186:     plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), obj);
  187      operator delete(obj);

  194      for (unsigned int i = 0; i < arraySize; i++)
  195:         plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), &objArray[i]);
  196      operator delete(objData);

plugin_vc\game_vc\meta\meta.CPointLight.h:
  31      SUPPORTED_10EN_11EN_STEAM stack_object() {
  32:         plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), reinterpret_cast<CPointLight *>(objBuff));
  33      }

  39      CPointLight *obj = reinterpret_cast<CPointLight *>(objData);
  40:     plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), obj);
  41      return obj;

  48      for (unsigned int i = 0; i < objCount; i++)
  49:         plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), &objArray[i]);
  50      return objArray;

plugin_vc\game_vc\meta\meta.CRouteNode.h:
  118      SUPPORTED_10EN_11EN_STEAM stack_object() {
  119:         plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), reinterpret_cast<CRouteNode *>(objBuff));
  120      }

  126      CRouteNode *obj = reinterpret_cast<CRouteNode *>(objData);
  127:     plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), obj);
  128      return obj;

  135      for (unsigned int i = 0; i < objCount; i++)
  136:         plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), &objArray[i]);
  137      return objArray;

plugin_vc\game_vc\meta\meta.CWindModifiers.h:
  58      SUPPORTED_10EN_11EN_STEAM stack_object() {
  59:         plugin::CallMethodDynGlobal<CWindModifier *>(ctor_gaddr(CWindModifier), reinterpret_cast<CWindModifier *>(objBuff));
  60      }

  66      CWindModifier *obj = reinterpret_cast<CWindModifier *>(objData);
  67:     plugin::CallMethodDynGlobal<CWindModifier *>(ctor_gaddr(CWindModifier), obj);
  68      return obj;

  75      for (unsigned int i = 0; i < objCount; i++)
  76:         plugin::CallMethodDynGlobal<CWindModifier *>(ctor_gaddr(CWindModifier), &objArray[i]);
  77      return objArray;
