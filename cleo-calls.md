- plugin_III
  - game_III
    - [C_PcSave.cpp](#plugin_III\game_III\C_PcSave.cpp)
    - [C2dEffect.cpp](#plugin_III\game_III\C2dEffect.cpp)
    - [C3dMarker.cpp](#plugin_III\game_III\C3dMarker.cpp)
    - [C3dMarkers.cpp](#plugin_III\game_III\C3dMarkers.cpp)
    - [CAccidentManager.cpp](#plugin_III\game_III\CAccidentManager.cpp)
    - [CAnimBlendAssocGroup.cpp](#plugin_III\game_III\CAnimBlendAssocGroup.cpp)
    - [CAnimBlendAssociation.cpp](#plugin_III\game_III\CAnimBlendAssociation.cpp)
    - [CAnimBlendClumpData.cpp](#plugin_III\game_III\CAnimBlendClumpData.cpp)
    - [CAnimBlendHierarchy.cpp](#plugin_III\game_III\CAnimBlendHierarchy.cpp)
    - [CAnimBlendNode.cpp](#plugin_III\game_III\CAnimBlendNode.cpp)
    - [CAnimBlendSequence.cpp](#plugin_III\game_III\CAnimBlendSequence.cpp)
    - [CAnimManager.cpp](#plugin_III\game_III\CAnimManager.cpp)
    - [CAntenna.cpp](#plugin_III\game_III\CAntenna.cpp)
    - [CAntennas.cpp](#plugin_III\game_III\CAntennas.cpp)
    - [cAudioCollisionManager.cpp](#plugin_III\game_III\cAudioCollisionManager.cpp)
    - [CAudioHydrant.cpp](#plugin_III\game_III\CAudioHydrant.cpp)
    - [cAudioManager.cpp](#plugin_III\game_III\cAudioManager.cpp)
    - [cAudioScriptObject.cpp](#plugin_III\game_III\cAudioScriptObject.cpp)
    - [CAutomobile.cpp](#plugin_III\game_III\CAutomobile.cpp)
    - [CAutoPilot.cpp](#plugin_III\game_III\CAutoPilot.cpp)
    - [CBaseModelInfo.cpp](#plugin_III\game_III\CBaseModelInfo.cpp)
    - [CBoat.cpp](#plugin_III\game_III\CBoat.cpp)
    - [CBridge.cpp](#plugin_III\game_III\CBridge.cpp)
    - [CBrightLights.cpp](#plugin_III\game_III\CBrightLights.cpp)
    - [CBuilding.cpp](#plugin_III\game_III\CBuilding.cpp)
    - [CBulletInfo.cpp](#plugin_III\game_III\CBulletInfo.cpp)
    - [CBulletTrace.cpp](#plugin_III\game_III\CBulletTrace.cpp)
    - [CBulletTraces.cpp](#plugin_III\game_III\CBulletTraces.cpp)
    - [CCamera.cpp](#plugin_III\game_III\CCamera.cpp)
    - [CCarAI.cpp](#plugin_III\game_III\CCarAI.cpp)
    - [CCarCtrl.cpp](#plugin_III\game_III\CCarCtrl.cpp)
    - [CCarGenerator.cpp](#plugin_III\game_III\CCarGenerator.cpp)
    - [CCivilianPed.cpp](#plugin_III\game_III\CCivilianPed.cpp)
    - [CClock.cpp](#plugin_III\game_III\CClock.cpp)
    - [CClouds.cpp](#plugin_III\game_III\CClouds.cpp)
    - [CClumpModelInfo.cpp](#plugin_III\game_III\CClumpModelInfo.cpp)
    - [CColBox.cpp](#plugin_III\game_III\CColBox.cpp)
    - [CColLine.cpp](#plugin_III\game_III\CColLine.cpp)
    - [CCollision.cpp](#plugin_III\game_III\CCollision.cpp)
    - [CColModel.cpp](#plugin_III\game_III\CColModel.cpp)
    - [CColSphere.cpp](#plugin_III\game_III\CColSphere.cpp)
    - [CColTriangle.cpp](#plugin_III\game_III\CColTriangle.cpp)
    - [CColTrianglePlane.cpp](#plugin_III\game_III\CColTrianglePlane.cpp)
    - [CControllerState.cpp](#plugin_III\game_III\CControllerState.cpp)
    - [CCopPed.cpp](#plugin_III\game_III\CCopPed.cpp)
    - [CCoronas.cpp](#plugin_III\game_III\CCoronas.cpp)
    - [CCrane.cpp](#plugin_III\game_III\CCrane.cpp)
    - [CCranes.cpp](#plugin_III\game_III\CCranes.cpp)
    - [CCredits.cpp](#plugin_III\game_III\CCredits.cpp)
    - [CCurrentVehicle.cpp](#plugin_III\game_III\CCurrentVehicle.cpp)
    - [CCurves.cpp](#plugin_III\game_III\CCurves.cpp)
    - [CCutsceneHead.cpp](#plugin_III\game_III\CCutsceneHead.cpp)
    - [CCutsceneMgr.cpp](#plugin_III\game_III\CCutsceneMgr.cpp)
    - [CCutsceneObject.cpp](#plugin_III\game_III\CCutsceneObject.cpp)
    - [CDamageManager.cpp](#plugin_III\game_III\CDamageManager.cpp)
    - [CDarkel.cpp](#plugin_III\game_III\CDarkel.cpp)
    - [CDigitalClock.cpp](#plugin_III\game_III\CDigitalClock.cpp)
    - [CDirectory.cpp](#plugin_III\game_III\CDirectory.cpp)
    - [cDMAudio.cpp](#plugin_III\game_III\cDMAudio.cpp)
    - [CDoor.cpp](#plugin_III\game_III\CDoor.cpp)
    - [CDraw.cpp](#plugin_III\game_III\CDraw.cpp)
    - [CDummy.cpp](#plugin_III\game_III\CDummy.cpp)
    - [CEmergencyPed.cpp](#plugin_III\game_III\CEmergencyPed.cpp)
    - [CEntity.cpp](#plugin_III\game_III\CEntity.cpp)
    - [CEventList.cpp](#plugin_III\game_III\CEventList.cpp)
    - [CExplosion.cpp](#plugin_III\game_III\CExplosion.cpp)
    - [CFallingGlassPane.cpp](#plugin_III\game_III\CFallingGlassPane.cpp)
    - [CFileLoader.cpp](#plugin_III\game_III\CFileLoader.cpp)
    - [CFileMgr.cpp](#plugin_III\game_III\CFileMgr.cpp)
    - [CFire.cpp](#plugin_III\game_III\CFire.cpp)
    - [CFireManager.cpp](#plugin_III\game_III\CFireManager.cpp)
    - [CFont.cpp](#plugin_III\game_III\CFont.cpp)
    - [CFontDetails.cpp](#plugin_III\game_III\CFontDetails.cpp)
    - [CGame.cpp](#plugin_III\game_III\CGame.cpp)
    - [CGameLogic.cpp](#plugin_III\game_III\CGameLogic.cpp)
    - [CGangs.cpp](#plugin_III\game_III\CGangs.cpp)
    - [CGarage.cpp](#plugin_III\game_III\CGarage.cpp)
    - [CGarages.cpp](#plugin_III\game_III\CGarages.cpp)
    - [CGeneral.cpp](#plugin_III\game_III\CGeneral.cpp)
    - [CGlass.cpp](#plugin_III\game_III\CGlass.cpp)
    - [CHeli.cpp](#plugin_III\game_III\CHeli.cpp)
    - [CHud.cpp](#plugin_III\game_III\CHud.cpp)
    - [CInstance.cpp](#plugin_III\game_III\CInstance.cpp)
    - [CKeyboardState.cpp](#plugin_III\game_III\CKeyboardState.cpp)
    - [CLines.cpp](#plugin_III\game_III\CLines.cpp)
    - [CMatrix.cpp](#plugin_III\game_III\CMatrix.cpp)
    - [CMBlur.cpp](#plugin_III\game_III\CMBlur.cpp)
    - [CMenuManager.cpp](#plugin_III\game_III\CMenuManager.cpp)
    - [CMessages.cpp](#plugin_III\game_III\CMessages.cpp)
    - [CMissionCleanup.cpp](#plugin_III\game_III\CMissionCleanup.cpp)
    - [CMloModelInfo.cpp](#plugin_III\game_III\CMloModelInfo.cpp)
    - [CModelInfo.cpp](#plugin_III\game_III\CModelInfo.cpp)
    - [CMoneyMessage.cpp](#plugin_III\game_III\CMoneyMessage.cpp)
    - [CMotionBlurStreaks.cpp](#plugin_III\game_III\CMotionBlurStreaks.cpp)
    - [CMouseControllerState.cpp](#plugin_III\game_III\CMouseControllerState.cpp)
    - [CMousePointerStateHelper.cpp](#plugin_III\game_III\CMousePointerStateHelper.cpp)
    - [CMovingThing.cpp](#plugin_III\game_III\CMovingThing.cpp)
    - [cMusicManager.cpp](#plugin_III\game_III\cMusicManager.cpp)
    - [CObject.cpp](#plugin_III\game_III\CObject.cpp)
    - [CObjectData.cpp](#plugin_III\game_III\CObjectData.cpp)
    - [common.cpp](#plugin_III\game_III\common.cpp)
    - [COneSheet.cpp](#plugin_III\game_III\COneSheet.cpp)
    - [COnscreenTimer.cpp](#plugin_III\game_III\COnscreenTimer.cpp)
    - [COnscreenTimerEntry.cpp](#plugin_III\game_III\COnscreenTimerEntry.cpp)
    - [CPacManPickup.cpp](#plugin_III\game_III\CPacManPickup.cpp)
    - [CPacManPickups.cpp](#plugin_III\game_III\CPacManPickups.cpp)
    - [CPad.cpp](#plugin_III\game_III\CPad.cpp)
    - [CPager.cpp](#plugin_III\game_III\CPager.cpp)
    - [CParticle.cpp](#plugin_III\game_III\CParticle.cpp)
    - [CParticleObject.cpp](#plugin_III\game_III\CParticleObject.cpp)
    - [cParticleSystemMgr.cpp](#plugin_III\game_III\cParticleSystemMgr.cpp)
    - [CPathFind.cpp](#plugin_III\game_III\CPathFind.cpp)
    - [CPed.cpp](#plugin_III\game_III\CPed.cpp)
    - [CPedIK.cpp](#plugin_III\game_III\CPedIK.cpp)
    - [CPedModelInfo.cpp](#plugin_III\game_III\CPedModelInfo.cpp)
    - [CPedPath.cpp](#plugin_III\game_III\CPedPath.cpp)
    - [CPedPlacement.cpp](#plugin_III\game_III\CPedPlacement.cpp)
    - [CPedStats.cpp](#plugin_III\game_III\CPedStats.cpp)
    - [CPedType.cpp](#plugin_III\game_III\CPedType.cpp)
    - [CPhoneInfo.cpp](#plugin_III\game_III\CPhoneInfo.cpp)
    - [CPhysical.cpp](#plugin_III\game_III\CPhysical.cpp)
    - [CPickup.cpp](#plugin_III\game_III\CPickup.cpp)
    - [CPickups.cpp](#plugin_III\game_III\CPickups.cpp)
    - [CPlaceable.cpp](#plugin_III\game_III\CPlaceable.cpp)
    - [CPlaceName.cpp](#plugin_III\game_III\CPlaceName.cpp)
    - [CPlane.cpp](#plugin_III\game_III\CPlane.cpp)
    - [CPlayerInfo.cpp](#plugin_III\game_III\CPlayerInfo.cpp)
    - [CPlayerPed.cpp](#plugin_III\game_III\CPlayerPed.cpp)
    - [CPlayerSkin.cpp](#plugin_III\game_III\CPlayerSkin.cpp)
    - [CPointLights.cpp](#plugin_III\game_III\CPointLights.cpp)
    - [CPools.cpp](#plugin_III\game_III\CPools.cpp)
    - [CPopulation.cpp](#plugin_III\game_III\CPopulation.cpp)
    - [CProjectileInfo.cpp](#plugin_III\game_III\CProjectileInfo.cpp)
    - [CQuaternion.cpp](#plugin_III\game_III\CQuaternion.cpp)
    - [CRadar.cpp](#plugin_III\game_III\CRadar.cpp)
    - [CRange2D.cpp](#plugin_III\game_III\CRange2D.cpp)
    - [CRecordDataForChase.cpp](#plugin_III\game_III\CRecordDataForChase.cpp)
    - [CRecordDataForGame.cpp](#plugin_III\game_III\CRecordDataForGame.cpp)
    - [CRegisteredCorona.cpp](#plugin_III\game_III\CRegisteredCorona.cpp)
    - [CRegisteredMotionBlurStreak.cpp](#plugin_III\game_III\CRegisteredMotionBlurStreak.cpp)
    - [CRemote.cpp](#plugin_III\game_III\CRemote.cpp)
    - [CRestart.cpp](#plugin_III\game_III\CRestart.cpp)
    - [CRoadBlocks.cpp](#plugin_III\game_III\CRoadBlocks.cpp)
    - [CRouteNode.cpp](#plugin_III\game_III\CRouteNode.cpp)
    - [CRubbish.cpp](#plugin_III\game_III\CRubbish.cpp)
    - [CRunningScript.cpp](#plugin_III\game_III\CRunningScript.cpp)
    - [CSceneEdit.cpp](#plugin_III\game_III\CSceneEdit.cpp)
    - [CScrollBar.cpp](#plugin_III\game_III\CScrollBar.cpp)
    - [CShadows.cpp](#plugin_III\game_III\CShadows.cpp)
    - [CShinyTexts.cpp](#plugin_III\game_III\CShinyTexts.cpp)
    - [CShotInfo.cpp](#plugin_III\game_III\CShotInfo.cpp)
    - [CSimpleModelInfo.cpp](#plugin_III\game_III\CSimpleModelInfo.cpp)
    - [CSkidmarks.cpp](#plugin_III\game_III\CSkidmarks.cpp)
    - [CSpecialFX.cpp](#plugin_III\game_III\CSpecialFX.cpp)
    - [CSpecialParticleStuff.cpp](#plugin_III\game_III\CSpecialParticleStuff.cpp)
    - [CSprite.cpp](#plugin_III\game_III\CSprite.cpp)
    - [CSprite2d.cpp](#plugin_III\game_III\CSprite2d.cpp)
    - [CStats.cpp](#plugin_III\game_III\CStats.cpp)
    - [CStoredCar.cpp](#plugin_III\game_III\CStoredCar.cpp)
    - [CStreaming.cpp](#plugin_III\game_III\CStreaming.cpp)
    - [CStreamingInfo.cpp](#plugin_III\game_III\CStreamingInfo.cpp)
    - [CStuckCarCheck.cpp](#plugin_III\game_III\CStuckCarCheck.cpp)
    - [CSurfaceTable.cpp](#plugin_III\game_III\CSurfaceTable.cpp)
    - [CText.cpp](#plugin_III\game_III\CText.cpp)
    - [CTheCarGenerators.cpp](#plugin_III\game_III\CTheCarGenerators.cpp)
    - [CTheScripts.cpp](#plugin_III\game_III\CTheScripts.cpp)
    - [CTheZones.cpp](#plugin_III\game_III\CTheZones.cpp)
    - [CTimeModelInfo.cpp](#plugin_III\game_III\CTimeModelInfo.cpp)
    - [CTimer.cpp](#plugin_III\game_III\CTimer.cpp)
    - [CTowerClock.cpp](#plugin_III\game_III\CTowerClock.cpp)
    - [CTrafficLights.cpp](#plugin_III\game_III\CTrafficLights.cpp)
    - [CTrain.cpp](#plugin_III\game_III\CTrain.cpp)
    - [CTrainDoor.cpp](#plugin_III\game_III\CTrainDoor.cpp)
    - [cTransmission.cpp](#plugin_III\game_III\cTransmission.cpp)
    - [CTreadable.cpp](#plugin_III\game_III\CTreadable.cpp)
    - [CTxdStore.cpp](#plugin_III\game_III\CTxdStore.cpp)
    - [CUpsideDownCarCheck.cpp](#plugin_III\game_III\CUpsideDownCarCheck.cpp)
    - [CVehicle.cpp](#plugin_III\game_III\CVehicle.cpp)
    - [CVehicleModelInfo.cpp](#plugin_III\game_III\CVehicleModelInfo.cpp)
    - [CVisibilityPlugins.cpp](#plugin_III\game_III\CVisibilityPlugins.cpp)
    - [CWanted.cpp](#plugin_III\game_III\CWanted.cpp)
    - [CWaterCannon.cpp](#plugin_III\game_III\CWaterCannon.cpp)
    - [CWaterCannons.cpp](#plugin_III\game_III\CWaterCannons.cpp)
    - [CWeapon.cpp](#plugin_III\game_III\CWeapon.cpp)
    - [CWeaponEffects.cpp](#plugin_III\game_III\CWeaponEffects.cpp)
    - [CWeaponInfo.cpp](#plugin_III\game_III\CWeaponInfo.cpp)
    - [CWeather.cpp](#plugin_III\game_III\CWeather.cpp)
    - [CWorld.cpp](#plugin_III\game_III\CWorld.cpp)
    - [CXtraCompsModelInfo.cpp](#plugin_III\game_III\CXtraCompsModelInfo.cpp)
    - [CZone.cpp](#plugin_III\game_III\CZone.cpp)
    - [GenericGameStorage.cpp](#plugin_III\game_III\GenericGameStorage.cpp)
    - [NodeName.cpp](#plugin_III\game_III\NodeName.cpp)
    - [RenderBuffer.cpp](#plugin_III\game_III\RenderBuffer.cpp)
    - [RpAnimBlend.cpp](#plugin_III\game_III\RpAnimBlend.cpp)
    - [meta.C2deffectsModelInfo.h](#plugin_III\game_III\meta.C2deffectsModelInfo.h)
    - [meta.C3dMarker.h](#plugin_III\game_III\meta.C3dMarker.h)
    - [meta.CAccident.h](#plugin_III\game_III\meta.CAccident.h)
    - [meta.CAccidentManager.h](#plugin_III\game_III\meta.CAccidentManager.h)
    - [meta.CAnimBlendAssocGroup.h](#plugin_III\game_III\meta.CAnimBlendAssocGroup.h)
    - [meta.CAnimBlendAssociation.h](#plugin_III\game_III\meta.CAnimBlendAssociation.h)
    - [meta.CAnimBlendClumpData.h](#plugin_III\game_III\meta.CAnimBlendClumpData.h)
    - [meta.CAnimBlendHierarchy.h](#plugin_III\game_III\meta.CAnimBlendHierarchy.h)
    - [meta.CAnimBlendSequence.h](#plugin_III\game_III\meta.CAnimBlendSequence.h)
    - [meta.CAntenna.h](#plugin_III\game_III\meta.CAntenna.h)
    - [meta.cAudioCollision.h](#plugin_III\game_III\meta.cAudioCollision.h)
    - [meta.CAudioHydrant.h](#plugin_III\game_III\meta.CAudioHydrant.h)
    - [meta.cAudioScriptObject.h](#plugin_III\game_III\meta.cAudioScriptObject.h)
    - [meta.CBaseModelInfo.h](#plugin_III\game_III\meta.CBaseModelInfo.h)
    - [meta.CBrightLight.h](#plugin_III\game_III\meta.CBrightLight.h)
    - [meta.CBulletInfo.h](#plugin_III\game_III\meta.CBulletInfo.h)
    - [meta.CBulletTrace.h](#plugin_III\game_III\meta.CBulletTrace.h)
    - [meta.CCamera.h](#plugin_III\game_III\meta.CCamera.h)
    - [meta.CCarGenerator.h](#plugin_III\game_III\meta.CCarGenerator.h)
    - [meta.CColLine.h](#plugin_III\game_III\meta.CColLine.h)
    - [meta.CColPoint.h](#plugin_III\game_III\meta.CColPoint.h)
    - [meta.CCurrentVehicle.h](#plugin_III\game_III\meta.CCurrentVehicle.h)
    - [meta.CDate.h](#plugin_III\game_III\meta.CDate.h)
    - [meta.CDigitalClock.h](#plugin_III\game_III\meta.CDigitalClock.h)
    - [meta.CDirectory.h](#plugin_III\game_III\meta.CDirectory.h)
    - [meta.cDMAudio.h](#plugin_III\game_III\meta.cDMAudio.h)
    - [meta.CEntity.h](#plugin_III\game_III\meta.CEntity.h)
    - [meta.CEventList.h](#plugin_III\game_III\meta.CEventList.h)
    - [meta.CFallingGlassPane.h](#plugin_III\game_III\meta.CFallingGlassPane.h)
    - [meta.CFire.h](#plugin_III\game_III\meta.CFire.h)
    - [meta.CFireManager.h](#plugin_III\game_III\meta.CFireManager.h)
    - [meta.CGangInfo.h](#plugin_III\game_III\meta.CGangInfo.h)
    - [meta.CInstance.h](#plugin_III\game_III\meta.CInstance.h)
    - [meta.CMissionCleanup.h](#plugin_III\game_III\meta.CMissionCleanup.h)
    - [meta.CMoneyMessage.h](#plugin_III\game_III\meta.CMoneyMessage.h)
    - [meta.CMovie.h](#plugin_III\game_III\meta.CMovie.h)
    - [meta.CMovingThing.h](#plugin_III\game_III\meta.CMovingThing.h)
    - [meta.cMusicManager.h](#plugin_III\game_III\meta.cMusicManager.h)
    - [meta.CPacManPickup.h](#plugin_III\game_III\meta.CPacManPickup.h)
    - [meta.CParticle.h](#plugin_III\game_III\meta.CParticle.h)
    - [meta.CParticleObject.h](#plugin_III\game_III\meta.CParticleObject.h)
    - [meta.CPathNode.h](#plugin_III\game_III\meta.CPathNode.h)
    - [meta.CPhone.h](#plugin_III\game_III\meta.CPhone.h)
    - [meta.CPhoneInfo.h](#plugin_III\game_III\meta.CPhoneInfo.h)
    - [meta.CPickup.h](#plugin_III\game_III\meta.CPickup.h)
    - [meta.CPlaceable.h](#plugin_III\game_III\meta.CPlaceable.h)
    - [meta.CPlaceName.h](#plugin_III\game_III\meta.CPlaceName.h)
    - [meta.CRadar.h](#plugin_III\game_III\meta.CRadar.h)
    - [meta.CRegisteredCorona.h](#plugin_III\game_III\meta.CRegisteredCorona.h)
    - [meta.CRegisteredMotionBlurStreak.h](#plugin_III\game_III\meta.CRegisteredMotionBlurStreak.h)
    - [meta.CRegisteredShinyText.h](#plugin_III\game_III\meta.CRegisteredShinyText.h)
    - [meta.CRouteNode.h](#plugin_III\game_III\meta.CRouteNode.h)
    - [meta.CScrollBar.h](#plugin_III\game_III\meta.CScrollBar.h)
    - [meta.CShotInfo.h](#plugin_III\game_III\meta.CShotInfo.h)
    - [meta.CSkidmark.h](#plugin_III\game_III\meta.CSkidmark.h)
    - [meta.CSprite2d.h](#plugin_III\game_III\meta.CSprite2d.h)
    - [meta.CStoredCollPoly.h](#plugin_III\game_III\meta.CStoredCollPoly.h)
    - [meta.CStuckCarCheck.h](#plugin_III\game_III\meta.CStuckCarCheck.h)
    - [meta.CTempNode.h](#plugin_III\game_III\meta.CTempNode.h)
    - [meta.CText.h](#plugin_III\game_III\meta.CText.h)
    - [meta.CTowerClock.h](#plugin_III\game_III\meta.CTowerClock.h)
    - [meta.CTrainCamNode.h](#plugin_III\game_III\meta.CTrainCamNode.h)
    - [meta.CTrainDoor.h](#plugin_III\game_III\meta.CTrainDoor.h)
    - [meta.CWanted.h](#plugin_III\game_III\meta.CWanted.h)
    - [meta.CWaterCannon.h](#plugin_III\game_III\meta.CWaterCannon.h)
    - [meta.CWeapon.h](#plugin_III\game_III\meta.CWeapon.h)
- plugin_sa
  - game_sa
    - [C_PcSave.cpp](#plugin_sa\game_sa\C_PcSave.cpp)
    - [C3dMarker.cpp](#plugin_sa\game_sa\C3dMarker.cpp)
    - [C3dMarkers.cpp](#plugin_sa\game_sa\C3dMarkers.cpp)
    - [CAEAudioHardware.cpp](#plugin_sa\game_sa\CAEAudioHardware.cpp)
    - [CAECutsceneTrackManager.cpp](#plugin_sa\game_sa\CAECutsceneTrackManager.cpp)
    - [CAERadioTrackManager.cpp](#plugin_sa\game_sa\CAERadioTrackManager.cpp)
    - [CAEStreamThread.cpp](#plugin_sa\game_sa\CAEStreamThread.cpp)
    - [CAEWeaponAudioEntity.cpp](#plugin_sa\game_sa\CAEWeaponAudioEntity.cpp)
    - [CAnimatedBuilding.cpp](#plugin_sa\game_sa\CAnimatedBuilding.cpp)
    - [CAnimBlendAssocGroup.cpp](#plugin_sa\game_sa\CAnimBlendAssocGroup.cpp)
    - [CAnimBlendAssociation.cpp](#plugin_sa\game_sa\CAnimBlendAssociation.cpp)
    - [CAnimBlendClumpData.cpp](#plugin_sa\game_sa\CAnimBlendClumpData.cpp)
    - [CAnimBlendHierarchy.cpp](#plugin_sa\game_sa\CAnimBlendHierarchy.cpp)
    - [CAnimBlendNode.cpp](#plugin_sa\game_sa\CAnimBlendNode.cpp)
    - [CAnimBlendSequence.cpp](#plugin_sa\game_sa\CAnimBlendSequence.cpp)
    - [CAnimBlendStaticAssociation.cpp](#plugin_sa\game_sa\CAnimBlendStaticAssociation.cpp)
    - [CAnimManager.cpp](#plugin_sa\game_sa\CAnimManager.cpp)
    - [CAudioEngine.cpp](#plugin_sa\game_sa\CAudioEngine.cpp)
    - [CBaseModelInfo.cpp](#plugin_sa\game_sa\CBaseModelInfo.cpp)
    - [CBirds.cpp](#plugin_sa\game_sa\CBirds.cpp)
    - [CBouncingPanel.cpp](#plugin_sa\game_sa\CBouncingPanel.cpp)
    - [CBoundingBox.cpp](#plugin_sa\game_sa\CBoundingBox.cpp)
    - [CBrightLights.cpp](#plugin_sa\game_sa\CBrightLights.cpp)
    - [CBuilding.cpp](#plugin_sa\game_sa\CBuilding.cpp)
    - [CBulletInfo.cpp](#plugin_sa\game_sa\CBulletInfo.cpp)
    - [CBulletTrace.cpp](#plugin_sa\game_sa\CBulletTrace.cpp)
    - [CBulletTraces.cpp](#plugin_sa\game_sa\CBulletTraces.cpp)
    - [CCamera.cpp](#plugin_sa\game_sa\CCamera.cpp)
    - [CCarAI.cpp](#plugin_sa\game_sa\CCarAI.cpp)
    - [CCarCtrl.cpp](#plugin_sa\game_sa\CCarCtrl.cpp)
    - [CCarEnterExit.cpp](#plugin_sa\game_sa\CCarEnterExit.cpp)
    - [CCarGenerator.cpp](#plugin_sa\game_sa\CCarGenerator.cpp)
    - [CCarPathLink.cpp](#plugin_sa\game_sa\CCarPathLink.cpp)
    - [CCheat.cpp](#plugin_sa\game_sa\CCheat.cpp)
    - [CCheckpoint.cpp](#plugin_sa\game_sa\CCheckpoint.cpp)
    - [CCheckpoints.cpp](#plugin_sa\game_sa\CCheckpoints.cpp)
    - [CClock.cpp](#plugin_sa\game_sa\CClock.cpp)
    - [CClothes.cpp](#plugin_sa\game_sa\CClothes.cpp)
    - [CClothesBuilder.cpp](#plugin_sa\game_sa\CClothesBuilder.cpp)
    - [CClouds.cpp](#plugin_sa\game_sa\CClouds.cpp)
    - [CClumpModelInfo.cpp](#plugin_sa\game_sa\CClumpModelInfo.cpp)
    - [CColAccel.cpp](#plugin_sa\game_sa\CColAccel.cpp)
    - [CColDisk.cpp](#plugin_sa\game_sa\CColDisk.cpp)
    - [CCollision.cpp](#plugin_sa\game_sa\CCollision.cpp)
    - [CCollisionData.cpp](#plugin_sa\game_sa\CCollisionData.cpp)
    - [CColModel.cpp](#plugin_sa\game_sa\CColModel.cpp)
    - [CColourSet.cpp](#plugin_sa\game_sa\CColourSet.cpp)
    - [CControllerConfigManager.cpp](#plugin_sa\game_sa\CControllerConfigManager.cpp)
    - [CCover.cpp](#plugin_sa\game_sa\CCover.cpp)
    - [CCoverPoint.cpp](#plugin_sa\game_sa\CCoverPoint.cpp)
    - [CCredits.cpp](#plugin_sa\game_sa\CCredits.cpp)
    - [CCullZones.cpp](#plugin_sa\game_sa\CCullZones.cpp)
    - [CCustomCarEnvMapPipeline.cpp](#plugin_sa\game_sa\CCustomCarEnvMapPipeline.cpp)
    - [CCustomCarPlateMgr.cpp](#plugin_sa\game_sa\CCustomCarPlateMgr.cpp)
    - [CCutsceneMgr.cpp](#plugin_sa\game_sa\CCutsceneMgr.cpp)
    - [CDarkel.cpp](#plugin_sa\game_sa\CDarkel.cpp)
    - [CDate.cpp](#plugin_sa\game_sa\CDate.cpp)
    - [CDecisionSimple.cpp](#plugin_sa\game_sa\CDecisionSimple.cpp)
    - [CDirectory.cpp](#plugin_sa\game_sa\CDirectory.cpp)
    - [CDoor.cpp](#plugin_sa\game_sa\CDoor.cpp)
    - [CDraw.cpp](#plugin_sa\game_sa\CDraw.cpp)
    - [CEntryExit.cpp](#plugin_sa\game_sa\CEntryExit.cpp)
    - [CEntryExitManager.cpp](#plugin_sa\game_sa\CEntryExitManager.cpp)
    - [CExplosion.cpp](#plugin_sa\game_sa\CExplosion.cpp)
    - [CFileLoader.cpp](#plugin_sa\game_sa\CFileLoader.cpp)
    - [CFormation.cpp](#plugin_sa\game_sa\CFormation.cpp)
    - [CGame.cpp](#plugin_sa\game_sa\CGame.cpp)
    - [CGameLogic.cpp](#plugin_sa\game_sa\CGameLogic.cpp)
    - [CGangs.cpp](#plugin_sa\game_sa\CGangs.cpp)
    - [CGangWars.cpp](#plugin_sa\game_sa\CGangWars.cpp)
    - [CGangWarsSaveStructure.cpp](#plugin_sa\game_sa\CGangWarsSaveStructure.cpp)
    - [CGenericGameStorage.cpp](#plugin_sa\game_sa\CGenericGameStorage.cpp)
    - [CGridRef.cpp](#plugin_sa\game_sa\CGridRef.cpp)
    - [CHud.cpp](#plugin_sa\game_sa\CHud.cpp)
    - [CIplStore.cpp](#plugin_sa\game_sa\CIplStore.cpp)
    - [CLoadedCarGroup.cpp](#plugin_sa\game_sa\CLoadedCarGroup.cpp)
    - [CLoadingScreen.cpp](#plugin_sa\game_sa\CLoadingScreen.cpp)
    - [CMatrix.cpp](#plugin_sa\game_sa\CMatrix.cpp)
    - [CMatrixLink.cpp](#plugin_sa\game_sa\CMatrixLink.cpp)
    - [CMenuManager.cpp](#plugin_sa\game_sa\CMenuManager.cpp)
    - [CMirrors.cpp](#plugin_sa\game_sa\CMirrors.cpp)
    - [CModelInfo.cpp](#plugin_sa\game_sa\CModelInfo.cpp)
    - [CModelInfoAccelerator.cpp](#plugin_sa\game_sa\CModelInfoAccelerator.cpp)
    - [CMotionBlurStreaks.cpp](#plugin_sa\game_sa\CMotionBlurStreaks.cpp)
    - [COctTree.cpp](#plugin_sa\game_sa\COctTree.cpp)
    - [COctTreeBase.cpp](#plugin_sa\game_sa\COctTreeBase.cpp)
    - [common.cpp](#plugin_sa\game_sa\common.cpp)
    - [COnscreenCounterEntry.cpp](#plugin_sa\game_sa\COnscreenCounterEntry.cpp)
    - [COnscreenTimer.cpp](#plugin_sa\game_sa\COnscreenTimer.cpp)
    - [COnscreenTimerEntry.cpp](#plugin_sa\game_sa\COnscreenTimerEntry.cpp)
    - [CPad.cpp](#plugin_sa\game_sa\CPad.cpp)
    - [CPathNode.cpp](#plugin_sa\game_sa\CPathNode.cpp)
    - [CPedClothesDesc.cpp](#plugin_sa\game_sa\CPedClothesDesc.cpp)
    - [CPedGroup.cpp](#plugin_sa\game_sa\CPedGroup.cpp)
    - [CPedGroupIntelligence.cpp](#plugin_sa\game_sa\CPedGroupIntelligence.cpp)
    - [CPedGroupMembership.cpp](#plugin_sa\game_sa\CPedGroupMembership.cpp)
    - [CPedGroupPlacer.cpp](#plugin_sa\game_sa\CPedGroupPlacer.cpp)
    - [CPedGroups.cpp](#plugin_sa\game_sa\CPedGroups.cpp)
    - [CPedIK.cpp](#plugin_sa\game_sa\CPedIK.cpp)
    - [CPedIntelligence.cpp](#plugin_sa\game_sa\CPedIntelligence.cpp)
    - [CPedList.cpp](#plugin_sa\game_sa\CPedList.cpp)
    - [CPedPlacement.cpp](#plugin_sa\game_sa\CPedPlacement.cpp)
    - [CPedTaskPair.cpp](#plugin_sa\game_sa\CPedTaskPair.cpp)
    - [CPickup.cpp](#plugin_sa\game_sa\CPickup.cpp)
    - [CPickups.cpp](#plugin_sa\game_sa\CPickups.cpp)
    - [CPlayerInfo.cpp](#plugin_sa\game_sa\CPlayerInfo.cpp)
    - [CPlayerPed.cpp](#plugin_sa\game_sa\CPlayerPed.cpp)
    - [CPointLights.cpp](#plugin_sa\game_sa\CPointLights.cpp)
    - [CPointList.cpp](#plugin_sa\game_sa\CPointList.cpp)
    - [CPools.cpp](#plugin_sa\game_sa\CPools.cpp)
    - [CPopCycle.cpp](#plugin_sa\game_sa\CPopCycle.cpp)
    - [CProjectileInfo.cpp](#plugin_sa\game_sa\CProjectileInfo.cpp)
    - [CPtrList.cpp](#plugin_sa\game_sa\CPtrList.cpp)
    - [CPtrListDoubleLink.cpp](#plugin_sa\game_sa\CPtrListDoubleLink.cpp)
    - [CPtrListSingleLink.cpp](#plugin_sa\game_sa\CPtrListSingleLink.cpp)
    - [CPtrNodeDoubleLink.cpp](#plugin_sa\game_sa\CPtrNodeDoubleLink.cpp)
    - [CPtrNodeSingleLink.cpp](#plugin_sa\game_sa\CPtrNodeSingleLink.cpp)
    - [CQuadTreeNode.cpp](#plugin_sa\game_sa\CQuadTreeNode.cpp)
    - [CRegisteredMotionBlurStreak.cpp](#plugin_sa\game_sa\CRegisteredMotionBlurStreak.cpp)
    - [CRenderer.cpp](#plugin_sa\game_sa\CRenderer.cpp)
    - [CRoadBlocks.cpp](#plugin_sa\game_sa\CRoadBlocks.cpp)
    - [CRunningScript.cpp](#plugin_sa\game_sa\CRunningScript.cpp)
    - [CScriptResourceManager.cpp](#plugin_sa\game_sa\CScriptResourceManager.cpp)
    - [CScriptsForBrains.cpp](#plugin_sa\game_sa\CScriptsForBrains.cpp)
    - [CSetPiece.cpp](#plugin_sa\game_sa\CSetPiece.cpp)
    - [CSetPieces.cpp](#plugin_sa\game_sa\CSetPieces.cpp)
    - [CShinyTexts.cpp](#plugin_sa\game_sa\CShinyTexts.cpp)
    - [CShotInfo.cpp](#plugin_sa\game_sa\CShotInfo.cpp)
    - [CSpecialFX.cpp](#plugin_sa\game_sa\CSpecialFX.cpp)
    - [CSpecialPlateHandler.cpp](#plugin_sa\game_sa\CSpecialPlateHandler.cpp)
    - [CStats.cpp](#plugin_sa\game_sa\CStats.cpp)
    - [CStreamedScripts.cpp](#plugin_sa\game_sa\CStreamedScripts.cpp)
    - [CStreaming.cpp](#plugin_sa\game_sa\CStreaming.cpp)
    - [CStreamingInfo.cpp](#plugin_sa\game_sa\CStreamingInfo.cpp)
    - [CStuckCarCheck.cpp](#plugin_sa\game_sa\CStuckCarCheck.cpp)
    - [CTaskComplex.cpp](#plugin_sa\game_sa\CTaskComplex.cpp)
    - [CTaskComplexClimb.cpp](#plugin_sa\game_sa\CTaskComplexClimb.cpp)
    - [CTaskComplexDie.cpp](#plugin_sa\game_sa\CTaskComplexDie.cpp)
    - [CTaskComplexEnterBoatAsDriver.cpp](#plugin_sa\game_sa\CTaskComplexEnterBoatAsDriver.cpp)
    - [CTaskComplexEnterCar.cpp](#plugin_sa\game_sa\CTaskComplexEnterCar.cpp)
    - [CTaskComplexEnterCarAsDriver.cpp](#plugin_sa\game_sa\CTaskComplexEnterCarAsDriver.cpp)
    - [CTaskComplexEnterCarAsPassenger.cpp](#plugin_sa\game_sa\CTaskComplexEnterCarAsPassenger.cpp)
    - [CTaskComplexFacial.cpp](#plugin_sa\game_sa\CTaskComplexFacial.cpp)
    - [CTaskComplexJump.cpp](#plugin_sa\game_sa\CTaskComplexJump.cpp)
    - [CTaskComplexLeaveCar.cpp](#plugin_sa\game_sa\CTaskComplexLeaveCar.cpp)
    - [CTaskComplexProstituteSolicit.cpp](#plugin_sa\game_sa\CTaskComplexProstituteSolicit.cpp)
    - [CTaskComplexSequence.cpp](#plugin_sa\game_sa\CTaskComplexSequence.cpp)
    - [CTaskComplexStuckInAir.cpp](#plugin_sa\game_sa\CTaskComplexStuckInAir.cpp)
    - [CTaskComplexSunbathe.cpp](#plugin_sa\game_sa\CTaskComplexSunbathe.cpp)
    - [CTaskComplexUseMobilePhone.cpp](#plugin_sa\game_sa\CTaskComplexUseMobilePhone.cpp)
    - [CTaskComplexWander.cpp](#plugin_sa\game_sa\CTaskComplexWander.cpp)
    - [CTaskComplexWanderStandard.cpp](#plugin_sa\game_sa\CTaskComplexWanderStandard.cpp)
    - [CTaskSimpleAnim.cpp](#plugin_sa\game_sa\CTaskSimpleAnim.cpp)
    - [CTaskSimpleCarSetPedInAsPassenger.cpp](#plugin_sa\game_sa\CTaskSimpleCarSetPedInAsPassenger.cpp)
    - [CTaskSimpleCarSetPedOut.cpp](#plugin_sa\game_sa\CTaskSimpleCarSetPedOut.cpp)
    - [CTaskSimpleChoking.cpp](#plugin_sa\game_sa\CTaskSimpleChoking.cpp)
    - [CTaskSimpleClimb.cpp](#plugin_sa\game_sa\CTaskSimpleClimb.cpp)
    - [CTaskSimpleDuck.cpp](#plugin_sa\game_sa\CTaskSimpleDuck.cpp)
    - [CTaskSimpleDuckToggle.cpp](#plugin_sa\game_sa\CTaskSimpleDuckToggle.cpp)
    - [CTaskSimpleFacial.cpp](#plugin_sa\game_sa\CTaskSimpleFacial.cpp)
    - [CTaskSimpleFight.cpp](#plugin_sa\game_sa\CTaskSimpleFight.cpp)
    - [CTaskSimpleGangDriveBy.cpp](#plugin_sa\game_sa\CTaskSimpleGangDriveBy.cpp)
    - [CTaskSimpleIKChain.cpp](#plugin_sa\game_sa\CTaskSimpleIKChain.cpp)
    - [CTaskSimpleIKLookAt.cpp](#plugin_sa\game_sa\CTaskSimpleIKLookAt.cpp)
    - [CTaskSimpleIKManager.cpp](#plugin_sa\game_sa\CTaskSimpleIKManager.cpp)
    - [CTaskSimpleInAir.cpp](#plugin_sa\game_sa\CTaskSimpleInAir.cpp)
    - [CTaskSimpleJetPack.cpp](#plugin_sa\game_sa\CTaskSimpleJetPack.cpp)
    - [CTaskSimpleJump.cpp](#plugin_sa\game_sa\CTaskSimpleJump.cpp)
    - [CTaskSimplePlayerOnFoot.cpp](#plugin_sa\game_sa\CTaskSimplePlayerOnFoot.cpp)
    - [CTaskSimpleRunAnim.cpp](#plugin_sa\game_sa\CTaskSimpleRunAnim.cpp)
    - [CTaskSimpleRunNamedAnim.cpp](#plugin_sa\game_sa\CTaskSimpleRunNamedAnim.cpp)
    - [CTaskSimpleStandStill.cpp](#plugin_sa\game_sa\CTaskSimpleStandStill.cpp)
    - [CTaskSimpleStealthKill.cpp](#plugin_sa\game_sa\CTaskSimpleStealthKill.cpp)
    - [CTaskSimpleSwim.cpp](#plugin_sa\game_sa\CTaskSimpleSwim.cpp)
    - [CTaskSimpleThrowProjectile.cpp](#plugin_sa\game_sa\CTaskSimpleThrowProjectile.cpp)
    - [CTaskSimpleTriggerLookAt.cpp](#plugin_sa\game_sa\CTaskSimpleTriggerLookAt.cpp)
    - [CTaskSimpleUseGun.cpp](#plugin_sa\game_sa\CTaskSimpleUseGun.cpp)
    - [CTaskUtilityLineUpPedWithCar.cpp](#plugin_sa\game_sa\CTaskUtilityLineUpPedWithCar.cpp)
    - [CTheCarGenerators.cpp](#plugin_sa\game_sa\CTheCarGenerators.cpp)
    - [CTheScripts.cpp](#plugin_sa\game_sa\CTheScripts.cpp)
    - [CTimeCycle.cpp](#plugin_sa\game_sa\CTimeCycle.cpp)
    - [CUpsideDownCarCheck.cpp](#plugin_sa\game_sa\CUpsideDownCarCheck.cpp)
    - [CVisibilityPlugins.cpp](#plugin_sa\game_sa\CVisibilityPlugins.cpp)
    - [CWanted.cpp](#plugin_sa\game_sa\CWanted.cpp)
    - [CWeapon.cpp](#plugin_sa\game_sa\CWeapon.cpp)
    - [CWeaponEffects.cpp](#plugin_sa\game_sa\CWeaponEffects.cpp)
    - [CWeather.cpp](#plugin_sa\game_sa\CWeather.cpp)
    - [CWorld.cpp](#plugin_sa\game_sa\CWorld.cpp)
    - [D3DIndexDataBuffer.cpp](#plugin_sa\game_sa\D3DIndexDataBuffer.cpp)
    - [D3DResourceSystem.cpp](#plugin_sa\game_sa\D3DResourceSystem.cpp)
    - [D3DTextureBuffer.cpp](#plugin_sa\game_sa\D3DTextureBuffer.cpp)
    - [JPegCompress.cpp](#plugin_sa\game_sa\JPegCompress.cpp)
    - [List_c.cpp](#plugin_sa\game_sa\List_c.cpp)
    - [ListItem_c.cpp](#plugin_sa\game_sa\ListItem_c.cpp)
    - [PipelinePlugin.cpp](#plugin_sa\game_sa\PipelinePlugin.cpp)
    - [RenderWare.cpp](#plugin_sa\game_sa\RenderWare.cpp)
    - [meta.CAnimBlendAssociation.h](#plugin_sa\game_sa\meta.CAnimBlendAssociation.h)
    - [meta.CAnimBlendStaticAssociation.h](#plugin_sa\game_sa\meta.CAnimBlendStaticAssociation.h)
    - [meta.CCamera.h](#plugin_sa\game_sa\meta.CCamera.h)
    - [meta.CEntryExit.h](#plugin_sa\game_sa\meta.CEntryExit.h)
    - [meta.CGangInfo.h](#plugin_sa\game_sa\meta.CGangInfo.h)
    - [meta.CMatrixLink.h](#plugin_sa\game_sa\meta.CMatrixLink.h)
    - [meta.CPedGroup.h](#plugin_sa\game_sa\meta.CPedGroup.h)
    - [meta.CPedGroupIntelligence.h](#plugin_sa\game_sa\meta.CPedGroupIntelligence.h)
    - [meta.CPedGroupMembership.h](#plugin_sa\game_sa\meta.CPedGroupMembership.h)
- plugin_vc
  - game_vc
    - [C_PcSave.cpp](#plugin_vc\game_vc\C_PcSave.cpp)
    - [C3dMarker.cpp](#plugin_vc\game_vc\C3dMarker.cpp)
    - [C3dMarkers.cpp](#plugin_vc\game_vc\C3dMarkers.cpp)
    - [CAnimBlendAssociation.cpp](#plugin_vc\game_vc\CAnimBlendAssociation.cpp)
    - [CAnimManager.cpp](#plugin_vc\game_vc\CAnimManager.cpp)
    - [cAudioManager.cpp](#plugin_vc\game_vc\cAudioManager.cpp)
    - [cAudioScriptObject.cpp](#plugin_vc\game_vc\cAudioScriptObject.cpp)
    - [CAutomobile.cpp](#plugin_vc\game_vc\CAutomobile.cpp)
    - [CBaseModelInfo.cpp](#plugin_vc\game_vc\CBaseModelInfo.cpp)
    - [CBike.cpp](#plugin_vc\game_vc\CBike.cpp)
    - [CBoat.cpp](#plugin_vc\game_vc\CBoat.cpp)
    - [CBox.cpp](#plugin_vc\game_vc\CBox.cpp)
    - [CBrightLights.cpp](#plugin_vc\game_vc\CBrightLights.cpp)
    - [CBulletInfo.cpp](#plugin_vc\game_vc\CBulletInfo.cpp)
    - [CBulletTraces.cpp](#plugin_vc\game_vc\CBulletTraces.cpp)
    - [cBuoyancy.cpp](#plugin_vc\game_vc\cBuoyancy.cpp)
    - [CCamera.cpp](#plugin_vc\game_vc\CCamera.cpp)
    - [CCarAI.cpp](#plugin_vc\game_vc\CCarAI.cpp)
    - [CCarCtrl.cpp](#plugin_vc\game_vc\CCarCtrl.cpp)
    - [CCarGenerator.cpp](#plugin_vc\game_vc\CCarGenerator.cpp)
    - [CCivilianPed.cpp](#plugin_vc\game_vc\CCivilianPed.cpp)
    - [CClock.cpp](#plugin_vc\game_vc\CClock.cpp)
    - [CClouds.cpp](#plugin_vc\game_vc\CClouds.cpp)
    - [CClumpModelInfo.cpp](#plugin_vc\game_vc\CClumpModelInfo.cpp)
    - [CColBox.cpp](#plugin_vc\game_vc\CColBox.cpp)
    - [CColLine.cpp](#plugin_vc\game_vc\CColLine.cpp)
    - [CColModel.cpp](#plugin_vc\game_vc\CColModel.cpp)
    - [CColSphere.cpp](#plugin_vc\game_vc\CColSphere.cpp)
    - [CControllerState.cpp](#plugin_vc\game_vc\CControllerState.cpp)
    - [CCopPed.cpp](#plugin_vc\game_vc\CCopPed.cpp)
    - [CCoronas.cpp](#plugin_vc\game_vc\CCoronas.cpp)
    - [CCranes.cpp](#plugin_vc\game_vc\CCranes.cpp)
    - [CCutsceneObject.cpp](#plugin_vc\game_vc\CCutsceneObject.cpp)
    - [CCutsceneShadow.cpp](#plugin_vc\game_vc\CCutsceneShadow.cpp)
    - [CDamageManager.cpp](#plugin_vc\game_vc\CDamageManager.cpp)
    - [CDarkel.cpp](#plugin_vc\game_vc\CDarkel.cpp)
    - [CDirectory.cpp](#plugin_vc\game_vc\CDirectory.cpp)
    - [cDMAudio.cpp](#plugin_vc\game_vc\cDMAudio.cpp)
    - [CDraw.cpp](#plugin_vc\game_vc\CDraw.cpp)
    - [CEmergencyPed.cpp](#plugin_vc\game_vc\CEmergencyPed.cpp)
    - [CEscalators.cpp](#plugin_vc\game_vc\CEscalators.cpp)
    - [CFileLoader.cpp](#plugin_vc\game_vc\CFileLoader.cpp)
    - [CFileMgr.cpp](#plugin_vc\game_vc\CFileMgr.cpp)
    - [CFont.cpp](#plugin_vc\game_vc\CFont.cpp)
    - [CGame.cpp](#plugin_vc\game_vc\CGame.cpp)
    - [CGameLogic.cpp](#plugin_vc\game_vc\CGameLogic.cpp)
    - [CGangs.cpp](#plugin_vc\game_vc\CGangs.cpp)
    - [CGeneral.cpp](#plugin_vc\game_vc\CGeneral.cpp)
    - [cHandlingDataMgr.cpp](#plugin_vc\game_vc\cHandlingDataMgr.cpp)
    - [CHeli.cpp](#plugin_vc\game_vc\CHeli.cpp)
    - [CHud.cpp](#plugin_vc\game_vc\CHud.cpp)
    - [CKeyboardState.cpp](#plugin_vc\game_vc\CKeyboardState.cpp)
    - [CMenuManager.cpp](#plugin_vc\game_vc\CMenuManager.cpp)
    - [CMessages.cpp](#plugin_vc\game_vc\CMessages.cpp)
    - [CModelInfo.cpp](#plugin_vc\game_vc\CModelInfo.cpp)
    - [CMotionBlurStreaks.cpp](#plugin_vc\game_vc\CMotionBlurStreaks.cpp)
    - [CMousePointerStateHelper.cpp](#plugin_vc\game_vc\CMousePointerStateHelper.cpp)
    - [CMovie.cpp](#plugin_vc\game_vc\CMovie.cpp)
    - [CObject.cpp](#plugin_vc\game_vc\CObject.cpp)
    - [COcclusion.cpp](#plugin_vc\game_vc\COcclusion.cpp)
    - [common.cpp](#plugin_vc\game_vc\common.cpp)
    - [COnscreenTimer.cpp](#plugin_vc\game_vc\COnscreenTimer.cpp)
    - [CPad.cpp](#plugin_vc\game_vc\CPad.cpp)
    - [CParticle.cpp](#plugin_vc\game_vc\CParticle.cpp)
    - [cParticleSystemMgr.cpp](#plugin_vc\game_vc\cParticleSystemMgr.cpp)
    - [CPathFind.cpp](#plugin_vc\game_vc\CPathFind.cpp)
    - [CPed.cpp](#plugin_vc\game_vc\CPed.cpp)
    - [CPedAtmAttractor.cpp](#plugin_vc\game_vc\CPedAtmAttractor.cpp)
    - [CPedAttractor.cpp](#plugin_vc\game_vc\CPedAttractor.cpp)
    - [CPedAttractorManager.cpp](#plugin_vc\game_vc\CPedAttractorManager.cpp)
    - [CPedIceCreamVanAttractor.cpp](#plugin_vc\game_vc\CPedIceCreamVanAttractor.cpp)
    - [CPedIK.cpp](#plugin_vc\game_vc\CPedIK.cpp)
    - [CPedModelInfo.cpp](#plugin_vc\game_vc\CPedModelInfo.cpp)
    - [CPedPizzaAttractor.cpp](#plugin_vc\game_vc\CPedPizzaAttractor.cpp)
    - [CPedPlacement.cpp](#plugin_vc\game_vc\CPedPlacement.cpp)
    - [CPedSeatAttractor.cpp](#plugin_vc\game_vc\CPedSeatAttractor.cpp)
    - [CPedShelterAttractor.cpp](#plugin_vc\game_vc\CPedShelterAttractor.cpp)
    - [CPedStats.cpp](#plugin_vc\game_vc\CPedStats.cpp)
    - [CPedStopAttractor.cpp](#plugin_vc\game_vc\CPedStopAttractor.cpp)
    - [CPedType.cpp](#plugin_vc\game_vc\CPedType.cpp)
    - [CPhoneInfo.cpp](#plugin_vc\game_vc\CPhoneInfo.cpp)
    - [CPickups.cpp](#plugin_vc\game_vc\CPickups.cpp)
    - [CPlane.cpp](#plugin_vc\game_vc\CPlane.cpp)
    - [CPlayerPed.cpp](#plugin_vc\game_vc\CPlayerPed.cpp)
    - [CPlayerSkin.cpp](#plugin_vc\game_vc\CPlayerSkin.cpp)
    - [CPointLights.cpp](#plugin_vc\game_vc\CPointLights.cpp)
    - [CPools.cpp](#plugin_vc\game_vc\CPools.cpp)
    - [CPopulation.cpp](#plugin_vc\game_vc\CPopulation.cpp)
    - [CProjectile.cpp](#plugin_vc\game_vc\CProjectile.cpp)
    - [CProjectileInfo.cpp](#plugin_vc\game_vc\CProjectileInfo.cpp)
    - [CQuaternion.cpp](#plugin_vc\game_vc\CQuaternion.cpp)
    - [CRadar.cpp](#plugin_vc\game_vc\CRadar.cpp)
    - [CRegisteredMotionBlurStreak.cpp](#plugin_vc\game_vc\CRegisteredMotionBlurStreak.cpp)
    - [CRestart.cpp](#plugin_vc\game_vc\CRestart.cpp)
    - [CRouteNode.cpp](#plugin_vc\game_vc\CRouteNode.cpp)
    - [CRubbish.cpp](#plugin_vc\game_vc\CRubbish.cpp)
    - [CRunningScript.cpp](#plugin_vc\game_vc\CRunningScript.cpp)
    - [cSampleManager.cpp](#plugin_vc\game_vc\cSampleManager.cpp)
    - [CSceneEdit.cpp](#plugin_vc\game_vc\CSceneEdit.cpp)
    - [CShadowCamera.cpp](#plugin_vc\game_vc\CShadowCamera.cpp)
    - [CShinyTexts.cpp](#plugin_vc\game_vc\CShinyTexts.cpp)
    - [CShotInfo.cpp](#plugin_vc\game_vc\CShotInfo.cpp)
    - [CSimpleModelInfo.cpp](#plugin_vc\game_vc\CSimpleModelInfo.cpp)
    - [CSprite.cpp](#plugin_vc\game_vc\CSprite.cpp)
    - [CStinger.cpp](#plugin_vc\game_vc\CStinger.cpp)
    - [CStreaming.cpp](#plugin_vc\game_vc\CStreaming.cpp)
    - [CText.cpp](#plugin_vc\game_vc\CText.cpp)
    - [CTheScripts.cpp](#plugin_vc\game_vc\CTheScripts.cpp)
    - [CTheZones.cpp](#plugin_vc\game_vc\CTheZones.cpp)
    - [CTimeCycle.cpp](#plugin_vc\game_vc\CTimeCycle.cpp)
    - [CTimeModelInfo.cpp](#plugin_vc\game_vc\CTimeModelInfo.cpp)
    - [CTimer.cpp](#plugin_vc\game_vc\CTimer.cpp)
    - [CTrafficLights.cpp](#plugin_vc\game_vc\CTrafficLights.cpp)
    - [CTrain.cpp](#plugin_vc\game_vc\CTrain.cpp)
    - [cTransmission.cpp](#plugin_vc\game_vc\cTransmission.cpp)
    - [CTxdStore.cpp](#plugin_vc\game_vc\CTxdStore.cpp)
    - [CUserDisplay.cpp](#plugin_vc\game_vc\CUserDisplay.cpp)
    - [CVehicle.cpp](#plugin_vc\game_vc\CVehicle.cpp)
    - [CVehicleModelInfo.cpp](#plugin_vc\game_vc\CVehicleModelInfo.cpp)
    - [CVisibilityPlugins.cpp](#plugin_vc\game_vc\CVisibilityPlugins.cpp)
    - [CWanted.cpp](#plugin_vc\game_vc\CWanted.cpp)
    - [CWaterCannons.cpp](#plugin_vc\game_vc\CWaterCannons.cpp)
    - [CWeaponEffects.cpp](#plugin_vc\game_vc\CWeaponEffects.cpp)
    - [CWeaponInfo.cpp](#plugin_vc\game_vc\CWeaponInfo.cpp)
    - [CWeaponModelInfo.cpp](#plugin_vc\game_vc\CWeaponModelInfo.cpp)
    - [CWeather.cpp](#plugin_vc\game_vc\CWeather.cpp)
    - [CWindModifiers.cpp](#plugin_vc\game_vc\CWindModifiers.cpp)
    - [CWorld.cpp](#plugin_vc\game_vc\CWorld.cpp)
    - [CZone.cpp](#plugin_vc\game_vc\CZone.cpp)
    - [NodeName.cpp](#plugin_vc\game_vc\NodeName.cpp)
    - [meta.cAudioScriptObject.h](#plugin_vc\game_vc\meta.cAudioScriptObject.h)
    - [meta.CBulletTrace.h](#plugin_vc\game_vc\meta.CBulletTrace.h)
    - [meta.CCutsceneShadow.h](#plugin_vc\game_vc\meta.CCutsceneShadow.h)
    - [meta.CDirectory.h](#plugin_vc\game_vc\meta.CDirectory.h)
    - [meta.CPad.h](#plugin_vc\game_vc\meta.CPad.h)
    - [meta.CParticle.h](#plugin_vc\game_vc\meta.CParticle.h)
    - [meta.CPedAttractor.h](#plugin_vc\game_vc\meta.CPedAttractor.h)
    - [meta.CPhone.h](#plugin_vc\game_vc\meta.CPhone.h)
    - [meta.CPhoneInfo.h](#plugin_vc\game_vc\meta.CPhoneInfo.h)
    - [meta.CPointLight.h](#plugin_vc\game_vc\meta.CPointLight.h)
    - [meta.CRouteNode.h](#plugin_vc\game_vc\meta.CRouteNode.h)
    - [meta.CWindModifiers.h](#plugin_vc\game_vc\meta.CWindModifiers.h)

### plugin_III\game_III\C_PcSave.cpp

#### C_PcSave::DeleteSlot

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::DeleteSlot), this, slot);
0AA8: call_method_return 0x5922F0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]
</pre>

#### C_PcSave::PcClassSaveRoutine

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int, unsigned char *, unsigned int>(gaddrof(C_PcSave::PcClassSaveRoutine), this, file, data, size);
0AA8: call_method_return 0x591F80 struct [C_PcSave] num_params 3 pop 0 [file] [data] [size] func_ret [bool]
</pre>

#### C_PcSave::PopulateSlotInfo

<pre>
plugin::CallMethodDynGlobal<C_PcSave *>(gaddrof(C_PcSave::PopulateSlotInfo), this);
0AA6: call_method 0x592090 struct [C_PcSave] num_params 0 pop 0
</pre>

#### C_PcSave::SaveSlot

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::SaveSlot), this, slot);
0AA8: call_method_return 0x591EC0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]
</pre>

#### C_PcSave::SetSaveDirectory

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(C_PcSave::SetSaveDirectory), path);
</pre>

### plugin_III\game_III\C2dEffect.cpp

#### C2dEffect::Shutdown

<pre>
plugin::CallMethodDynGlobal<C2dEffect *>(gaddrof(C2dEffect::Shutdown), this);
0AA6: call_method 0x50B820 struct [C2dEffect] num_params 0 pop 0
</pre>

### plugin_III\game_III\C3dMarker.cpp

#### C3dMarker::AddMarker

<pre>
plugin::CallMethodDynGlobal<C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarker::AddMarker), this, nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
0AA6: call_method 0x51B070 struct [C3dMarker] num_params 10 pop 0 [nId] [nType] [fSize] [bRed] [bGreen] [bBlue] [bAlpha] [nPulsePeriod] [fPulseFraction] [nRotateRate]
</pre>

#### C3dMarker::DeleteMarkerObject

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::DeleteMarkerObject), this);
0AA6: call_method 0x51B170 struct [C3dMarker] num_params 0 pop 0
</pre>

#### C3dMarker::Render

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::Render), this);
0AA6: call_method 0x51B1B0 struct [C3dMarker] num_params 0 pop 0
</pre>

#### \*MarkerAtomicCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(MarkerAtomicCB), atomic, data);
</pre>

### plugin_III\game_III\C3dMarkers.cpp

#### C3dMarkers::PlaceMarker

<pre>
plugin::CallDynGlobal<unsigned int, unsigned short, CVector &, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarkers::PlaceMarker), nId, nType, point, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
</pre>

#### C3dMarkers::PlaceMarkerSet

<pre>
plugin::CallDynGlobal<unsigned int, unsigned short, CVector &, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarkers::PlaceMarkerSet), nId, nType, point, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
</pre>

### plugin_III\game_III\CAccidentManager.cpp

#### CAccidentManager::CountActiveAccidents

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned short, CAccidentManager *>(gaddrof(CAccidentManager::CountActiveAccidents), this);
0AA8: call_method_return 0x456880 struct [CAccidentManager] num_params 0 pop 0 func_ret [unsigned short]
</pre>

#### \*CAccidentManager::FindNearestAccident

<pre>
plugin::CallMethodAndReturnDynGlobal<CAccident *, CAccidentManager *, CVector, float *>(gaddrof(CAccidentManager::FindNearestAccident), this, pos, distance);
0AA8: call_method_return 0x456760 struct [*CAccidentManager] num_params 2 pop 0 [pos] [distance] func_ret [CAccident *]
</pre>

#### \*CAccidentManager::GetNextFreeAccident

<pre>
plugin::CallMethodAndReturnDynGlobal<CAccident *, CAccidentManager *>(gaddrof(CAccidentManager::GetNextFreeAccident), this);
0AA8: call_method_return 0x4565A0 struct [*CAccidentManager] num_params 0 pop 0 func_ret [CAccident *]
</pre>

#### CAccidentManager::ReportAccident

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *, CPed *>(gaddrof(CAccidentManager::ReportAccident), this, ped);
0AA6: call_method 0x4565D0 struct [CAccidentManager] num_params 1 pop 0 [ped]
</pre>

#### CAccidentManager::UnattendedAccidents

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAccidentManager *>(gaddrof(CAccidentManager::UnattendedAccidents), this);
0AA8: call_method_return 0x4568D0 struct [CAccidentManager] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAccidentManager::Update

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *>(gaddrof(CAccidentManager::Update), this);
0AA6: call_method 0x456710 struct [CAccidentManager] num_params 0 pop 0
</pre>

#### CAccidentManager::WorkToDoForMedics

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAccidentManager *>(gaddrof(CAccidentManager::WorkToDoForMedics), this);
0AA8: call_method_return 0x4568A0 struct [CAccidentManager] num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_III\game_III\CAnimBlendAssocGroup.cpp

#### \*CAnimBlendAssocGroup::CopyAnimation

<pre>
plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::CopyAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(char const *)), this, name);
0AA8: call_method_return 0x401420 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [name] func_ret [CAnimBlendAssociation *]
</pre>

#### \*CAnimBlendAssocGroup::CopyAnimation

<pre>
plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, unsigned int>(gaddrof_o(CAnimBlendAssocGroup::CopyAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(unsigned int)), this, id);
0AA8: call_method_return 0x401420 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [id] func_ret [CAnimBlendAssociation *]
</pre>

#### CAnimBlendAssocGroup::CreateAssociations

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::CreateAssociations, void (CAnimBlendAssocGroup::*)(char const *)), this, name);
0AA6: call_method 0x401220 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [name]
</pre>

#### CAnimBlendAssocGroup::CreateAssociations

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *, char const *, RpClump *, char **, int>(gaddrof_o(CAnimBlendAssocGroup::CreateAssociations, void (CAnimBlendAssocGroup::*)(char const *, RpClump *, char **, int)), this, blockName, clump, animNames, numAssocs);
0AA6: call_method 0x401220 struct [CAnimBlendAssocGroup] num_params 4 pop 0 [blockName] [clump] [animNames] [numAssocs]
</pre>

#### CAnimBlendAssocGroup::DestroyAssociations

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(gaddrof(CAnimBlendAssocGroup::DestroyAssociations), this);
0AA6: call_method 0x4012D0 struct [CAnimBlendAssocGroup] num_params 0 pop 0
</pre>

#### \*CAnimBlendAssocGroup::GetAnimation

<pre>
plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::GetAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(char const *)), this, name);
0AA8: call_method_return 0x4013D0 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [name] func_ret [CAnimBlendAssociation *]
</pre>

#### \*CAnimBlendAssocGroup::GetAnimation

<pre>
plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, unsigned int>(gaddrof_o(CAnimBlendAssocGroup::GetAnimation, CAnimBlendAssociation *(CAnimBlendAssocGroup::*)(unsigned int)), this, id);
0AA8: call_method_return 0x4013D0 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [id] func_ret [CAnimBlendAssociation *]
</pre>

#### strcmpIgnoringDigits

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *, char const *>(gaddrof(strcmpIgnoringDigits), s1, s2);
</pre>

#### \*GetModelFromName

<pre>
plugin::CallAndReturnDynGlobal<CBaseModelInfo *, char const *>(gaddrof(GetModelFromName), name);
</pre>

### plugin_III\game_III\CAnimBlendAssociation.cpp

#### CAnimBlendAssociation::AllocateAnimBlendNodeArray

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::AllocateAnimBlendNodeArray), this, n);
0AA6: call_method 0x4016A0 struct [CAnimBlendAssociation] num_params 1 pop 0 [n]
</pre>

#### CAnimBlendAssociation::FreeAnimBlendNodeArray

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::FreeAnimBlendNodeArray), this);
0AA6: call_method 0x4016F0 struct [CAnimBlendAssociation] num_params 0 pop 0
</pre>

#### \*CAnimBlendAssociation::GetNode

<pre>
plugin::CallMethodAndReturnDynGlobal<CAnimBlendNode *, CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::GetNode), this, index);
0AA8: call_method_return 0x4017B0 struct [*CAnimBlendAssociation] num_params 1 pop 0 [index] func_ret [CAnimBlendNode *]
</pre>

#### CAnimBlendAssociation::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(RpClump *, CAnimBlendHierarchy *)), this, clump, hier);
0AA6: call_method 0x401620 struct [CAnimBlendAssociation] num_params 2 pop 0 [clump] [hier]
</pre>

#### CAnimBlendAssociation::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendAssociation &)), this, assoc);
0AA6: call_method 0x401620 struct [CAnimBlendAssociation] num_params 1 pop 0 [assoc]
</pre>

#### CAnimBlendAssociation::SetBlend

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlend), this, amount, delta);
0AA6: call_method 0x4017E0 struct [CAnimBlendAssociation] num_params 2 pop 0 [amount] [delta]
</pre>

#### CAnimBlendAssociation::SetCurrentTime

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::SetCurrentTime), this, time);
0AA6: call_method 0x401700 struct [CAnimBlendAssociation] num_params 1 pop 0 [time]
</pre>

#### CAnimBlendAssociation::SetDeleteCallback

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetDeleteCallback), this, func, data);
0AA6: call_method 0x401800 struct [CAnimBlendAssociation] num_params 2 pop 0 [func] [data]
</pre>

#### CAnimBlendAssociation::SetFinishCallback

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetFinishCallback), this, func, data);
0AA6: call_method 0x401820 struct [CAnimBlendAssociation] num_params 2 pop 0 [func] [data]
</pre>

#### CAnimBlendAssociation::Start

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::Start), this, time);
0AA6: call_method 0x4017D0 struct [CAnimBlendAssociation] num_params 1 pop 0 [time]
</pre>

#### CAnimBlendAssociation::SyncAnimation

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::SyncAnimation), this, other);
0AA6: call_method 0x401780 struct [CAnimBlendAssociation] num_params 1 pop 0 [other]
</pre>

#### CAnimBlendAssociation::UpdateBlend

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::UpdateBlend), this, timeDelta);
0AA8: call_method_return 0x4032B0 struct [CAnimBlendAssociation] num_params 1 pop 0 [timeDelta] func_ret [bool]
</pre>

#### CAnimBlendAssociation::UpdateTime

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTime), this, timeDelta, relSpeed);
0AA6: call_method 0x4031F0 struct [CAnimBlendAssociation] num_params 2 pop 0 [timeDelta] [relSpeed]
</pre>

### plugin_III\game_III\CAnimBlendClumpData.cpp

#### CAnimBlendClumpData::ForAllFrames

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *>(gaddrof(CAnimBlendClumpData::ForAllFrames), this, func, data);
0AA6: call_method 0x401930 struct [CAnimBlendClumpData] num_params 2 pop 0 [func] [data]
</pre>

#### CAnimBlendClumpData::SetNumberOfBones

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *, int>(gaddrof(CAnimBlendClumpData::SetNumberOfBones), this, n);
0AA6: call_method 0x4018F0 struct [CAnimBlendClumpData] num_params 1 pop 0 [n]
</pre>

### plugin_III\game_III\CAnimBlendHierarchy.cpp

#### CAnimBlendHierarchy::CalcTotalTime

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::CalcTotalTime), this);
0AA6: call_method 0x4019E0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::RemoveAnimSequences

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveAnimSequences), this);
0AA6: call_method 0x401AB0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::RemoveQuaternionFlips

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveQuaternionFlips), this);
0AA6: call_method 0x401A80 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::RemoveUncompressedData

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveUncompressedData), this);
0AA6: call_method 0x401B00 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::SetName

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *, char const *>(gaddrof(CAnimBlendHierarchy::SetName), this, name);
0AA6: call_method 0x4019C0 struct [CAnimBlendHierarchy] num_params 1 pop 0 [name]
</pre>

#### CAnimBlendHierarchy::Shutdown

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::Shutdown), this);
0AA6: call_method 0x4019A0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::Uncompress

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::Uncompress), this);
0AA6: call_method 0x401AD0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

### plugin_III\game_III\CAnimBlendNode.cpp

#### CAnimBlendNode::CalcDeltas

<pre>
plugin::CallMethodDynGlobal<CAnimBlendNode *>(gaddrof(CAnimBlendNode::CalcDeltas), this);
0AA6: call_method 0x401E70 struct [CAnimBlendNode] num_params 0 pop 0
</pre>

#### CAnimBlendNode::FindKeyFrame

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *, float>(gaddrof(CAnimBlendNode::FindKeyFrame), this, t);
0AA8: call_method_return 0x4021B0 struct [CAnimBlendNode] num_params 1 pop 0 [t] func_ret [bool]
</pre>

#### CAnimBlendNode::GetCurrentTranslation

<pre>
plugin::CallMethodDynGlobal<CAnimBlendNode *, CVector &, float>(gaddrof(CAnimBlendNode::GetCurrentTranslation), this, trans, weight);
0AA6: call_method 0x401FE0 struct [CAnimBlendNode] num_params 2 pop 0 [trans] [weight]
</pre>

#### CAnimBlendNode::GetEndTranslation

<pre>
plugin::CallMethodDynGlobal<CAnimBlendNode *, CVector &, float>(gaddrof(CAnimBlendNode::GetEndTranslation), this, trans, weight);
0AA6: call_method 0x402110 struct [CAnimBlendNode] num_params 2 pop 0 [trans] [weight]
</pre>

#### CAnimBlendNode::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendNode *>(gaddrof(CAnimBlendNode::Init), this);
0AA6: call_method 0x401B10 struct [CAnimBlendNode] num_params 0 pop 0
</pre>

#### CAnimBlendNode::NextKeyFrame

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *>(gaddrof(CAnimBlendNode::NextKeyFrame), this);
0AA8: call_method_return 0x401DC0 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAnimBlendNode::Update

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *, CVector &, CQuaternion &, float>(gaddrof(CAnimBlendNode::Update), this, trans, rot, weight);
0AA8: call_method_return 0x401B30 struct [CAnimBlendNode] num_params 3 pop 0 [trans] [rot] [weight] func_ret [bool]
</pre>

### plugin_III\game_III\CAnimBlendSequence.cpp

#### CAnimBlendSequence::RemoveQuaternionFlips

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *>(gaddrof(CAnimBlendSequence::RemoveQuaternionFlips), this);
0AA6: call_method 0x4023A0 struct [CAnimBlendSequence] num_params 0 pop 0
</pre>

#### CAnimBlendSequence::SetName

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *, char const *>(gaddrof(CAnimBlendSequence::SetName), this, name);
0AA6: call_method 0x402330 struct [CAnimBlendSequence] num_params 1 pop 0 [name]
</pre>

#### CAnimBlendSequence::SetNumFrames

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *, int, bool>(gaddrof(CAnimBlendSequence::SetNumFrames), this, numFrames, translation);
0AA6: call_method 0x402350 struct [CAnimBlendSequence] num_params 2 pop 0 [numFrames] [translation]
</pre>

### plugin_III\game_III\CAnimManager.cpp

#### \*CAnimManager::AddAnimation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int, int>(gaddrof(CAnimManager::AddAnimation), clump, groupId, animId);
</pre>

#### \*CAnimManager::AddAnimationAndSync

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendAssociation *, int, int>(gaddrof(CAnimManager::AddAnimationAndSync), clump, association, groupId, animId);
</pre>

#### \*CAnimManager::BlendAnimation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int, int, float>(gaddrof(CAnimManager::BlendAnimation), clump, groupId, animId, delta);
</pre>

#### \*CAnimManager::CreateAnimAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, int>(gaddrof(CAnimManager::CreateAnimAssociation), groupId, animId);
</pre>

#### \*CAnimManager::GetAnimAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, int>(gaddrof_o(CAnimManager::GetAnimAssociation, CAnimBlendAssociation *(*)(int, int)), groupId, animId);
</pre>

#### \*CAnimManager::GetAnimAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, char const *>(gaddrof_o(CAnimManager::GetAnimAssociation, CAnimBlendAssociation *(*)(int, char const *)), groupId, name);
</pre>

#### \*CAnimManager::GetAnimGroupName

<pre>
plugin::CallAndReturnDynGlobal<char const *, int>(gaddrof(CAnimManager::GetAnimGroupName), groupId);
</pre>

#### \*CAnimManager::GetAnimation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendHierarchy *, char const *, CAnimBlock *>(gaddrof(CAnimManager::GetAnimation), name, animBlock);
</pre>

#### \*CAnimManager::GetAnimationBlock

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlock *, char const *>(gaddrof(CAnimManager::GetAnimationBlock), name);
</pre>

#### CAnimManager::LoadAnimFile

<pre>
plugin::CallDynGlobal<char const *>(gaddrof_o(CAnimManager::LoadAnimFile, void (*)(char const *)), name);
</pre>

#### CAnimManager::LoadAnimFile

<pre>
plugin::CallDynGlobal<int, bool>(gaddrof_o(CAnimManager::LoadAnimFile, void (*)(int, bool)), fileHandle, compress);
</pre>

#### CAnimManager::UncompressAnimation

<pre>
plugin::CallDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimManager::UncompressAnimation), hier);
</pre>

### plugin_III\game_III\CAntenna.cpp

#### CAntenna::Update

<pre>
plugin::CallMethodDynGlobal<CAntenna *, CVector, CVector>(gaddrof(CAntenna::Update), this, dir, pos);
0AA6: call_method 0x4F6830 struct [CAntenna] num_params 2 pop 0 [dir] [pos]
</pre>

### plugin_III\game_III\CAntennas.cpp

#### CAntennas::RegisterOne

<pre>
plugin::CallDynGlobal<unsigned int, CVector, CVector, float>(gaddrof(CAntennas::RegisterOne), id, dir, pos, length);
</pre>

### plugin_III\game_III\cAudioCollisionManager.cpp

#### cAudioCollisionManager::AddCollisionToRequestedQueue

<pre>
plugin::CallMethodDynGlobal<cAudioCollisionManager *>(gaddrof(cAudioCollisionManager::AddCollisionToRequestedQueue), this);
0AA6: call_method 0x5685E0 struct [cAudioCollisionManager] num_params 0 pop 0
</pre>

### plugin_III\game_III\CAudioHydrant.cpp

#### CAudioHydrant::Add

<pre>
plugin::CallDynGlobal<CParticleObject *>(gaddrof(CAudioHydrant::Add), object);
</pre>

#### CAudioHydrant::Remove

<pre>
plugin::CallDynGlobal<CParticleObject *>(gaddrof(CAudioHydrant::Remove), object);
</pre>

### plugin_III\game_III\cAudioManager.cpp

#### cAudioManager::cAudioManager

<pre>
plugin::CallMethod<0x579AB0, cAudioManager *>(this);
0AA6: call_method 0x579AB0 struct [cAudioManager] num_params 0 pop 0
</pre>

#### cAudioManager::~cAudioManager

<pre>
plugin::CallMethod<0x57A0A0, cAudioManager *>(this);
0AA6: call_method 0x57A0A0 struct [cAudioManager] num_params 0 pop 0
</pre>

#### cAudioManager::UsesSiren

<pre>
plugin::CallMethodAndReturn<bool, 0x56C3C0, cAudioManager *, unsigned int>(this, index);
0AA8: call_method_return 0x56C3C0 struct [cAudioManager] num_params 1 pop 0 [index] func_ret [bool]
</pre>

#### cAudioManager::UsesSirenSwitching

<pre>
plugin::CallMethodAndReturn<bool, 0x56C3F0, cAudioManager *, unsigned int>(this, index);
0AA8: call_method_return 0x56C3F0 struct [cAudioManager] num_params 1 pop 0 [index] func_ret [bool]
</pre>

### plugin_III\game_III\cAudioScriptObject.cpp

#### cAudioScriptObject::Reset

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(gaddrof(cAudioScriptObject::Reset), this);
0AA6: call_method 0x57C430 struct [cAudioScriptObject] num_params 0 pop 0
</pre>

#### cAudioScriptObject::LoadAllAudioScriptObjects

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(cAudioScriptObject::LoadAllAudioScriptObjects), buf, size);
</pre>

#### cAudioScriptObject::SaveAllAudioScriptObjects

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(cAudioScriptObject::SaveAllAudioScriptObjects), buf, size);
</pre>

#### PlayOneShotScriptObject

<pre>
plugin::CallDynGlobal<unsigned char, CVector const &>(gaddrof(PlayOneShotScriptObject), id, pos);
</pre>

### plugin_III\game_III\CAutomobile.cpp

#### CAutomobile::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CAutomobile *, unsigned int>(this, modelIndex);
</pre>

#### CAutomobile::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CAutomobile *>(this);
</pre>

#### CAutomobile::Teleport

<pre>
plugin::CallVirtualMethod<11, CAutomobile *, CVector>(this, pos);
</pre>

#### CAutomobile::PreRender

<pre>
plugin::CallVirtualMethod<12, CAutomobile *>(this);
</pre>

#### CAutomobile::Render

<pre>
plugin::CallVirtualMethod<13, CAutomobile *>(this);
</pre>

#### CAutomobile::ProcessEntityCollision

<pre>
plugin::CallVirtualMethod<17, CAutomobile *, CEntity *, CColPoint *>(this, entity, colPoint);
</pre>

#### CAutomobile::ProcessControlInputs

<pre>
plugin::CallVirtualMethod<18, CAutomobile *, unsigned char>(this, pad);
</pre>

#### CAutomobile::GetComponentWorldPosition

<pre>
plugin::CallVirtualMethod<19, CAutomobile *, int, CVector &>(this, component, pos);
</pre>

#### CAutomobile::IsComponentPresent

<pre>
plugin::CallVirtualMethodAndReturn<bool, 20, CAutomobile *, int>(this, component);
</pre>

#### CAutomobile::SetComponentRotation

<pre>
plugin::CallVirtualMethod<21, CAutomobile *, int, CVector>(this, component, rotation);
</pre>

#### CAutomobile::OpenDoor

<pre>
plugin::CallVirtualMethod<22, CAutomobile *, int, eDoors, float>(this, component, door, angle);
</pre>

#### CAutomobile::ProcessOpenDoor

<pre>
plugin::CallVirtualMethod<23, CAutomobile *, unsigned int, unsigned int, float>(this, component, anim, angle);
</pre>

#### CAutomobile::IsDoorReady

<pre>
plugin::CallVirtualMethodAndReturn<bool, 24, CAutomobile *, eDoors>(this, door);
</pre>

#### CAutomobile::IsDoorFullyOpen

<pre>
plugin::CallVirtualMethodAndReturn<bool, 25, CAutomobile *, eDoors>(this, door);
</pre>

#### CAutomobile::IsDoorClosed

<pre>
plugin::CallVirtualMethodAndReturn<bool, 26, CAutomobile *, eDoors>(this, door);
</pre>

#### CAutomobile::IsDoorMissing

<pre>
plugin::CallVirtualMethodAndReturn<bool, 27, CAutomobile *, eDoors>(this, door);
</pre>

#### CAutomobile::RemoveRefsToVehicle

<pre>
plugin::CallVirtualMethod<28, CAutomobile *, CEntity *>(this, entity);
</pre>

#### CAutomobile::BlowUpCar

<pre>
plugin::CallVirtualMethod<29, CAutomobile *, CEntity *>(this, culprit);
</pre>

#### CAutomobile::SetUpWheelColModel

<pre>
plugin::CallVirtualMethodAndReturn<bool, 30, CAutomobile *, CColModel *>(this, wheelCol);
</pre>

#### CAutomobile::BurstTyre

<pre>
plugin::CallVirtualMethod<31, CAutomobile *, unsigned char>(this, wheel);
</pre>

#### CAutomobile::IsRoomForPedToLeaveCar

<pre>
plugin::CallVirtualMethodAndReturn<bool, 32, CAutomobile *, unsigned int, CVector *>(this, component, doorOffset);
</pre>

#### CAutomobile::GetHeightAboveRoad

<pre>
plugin::CallVirtualMethodAndReturn<float, 33, CAutomobile *>(this);
</pre>

#### CAutomobile::PlayCarHorn

<pre>
plugin::CallVirtualMethod<34, CAutomobile *>(this);
</pre>

#### CAutomobile::AddDamagedVehicleParticles

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::AddDamagedVehicleParticles), this);
0AA6: call_method 0x535450 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::AddWheelDirtAndWater

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *, CColPoint &, unsigned int>(gaddrof(CAutomobile::AddWheelDirtAndWater), this, point, belowEffectSpeed);
0AA8: call_method_return 0x5357D0 struct [CAutomobile] num_params 2 pop 0 [point] [belowEffectSpeed] func_ret [bool]
</pre>

#### CAutomobile::BlowUpCarsInPath

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::BlowUpCarsInPath), this);
0AA6: call_method 0x53E000 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::DoDriveByShootings

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::DoDriveByShootings), this);
0AA6: call_method 0x564000 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::FireTruckControl

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::FireTruckControl), this);
0AA6: call_method 0x522590 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::Fix

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::Fix), this);
0AA6: call_method 0x53C240 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::GetAllWheelsOffGround

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::GetAllWheelsOffGround), this);
0AA8: call_method_return 0x53BC40 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAutomobile::HasCarStoppedBecauseOfLight

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::HasCarStoppedBecauseOfLight), this);
0AA8: call_method_return 0x42E220 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAutomobile::HideAllComps

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::HideAllComps), this);
0AA6: call_method 0x5300C0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::HydraulicControl

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::HydraulicControl), this);
0AA6: call_method 0x52D4E0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::PlaceOnRoadProperly

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::PlaceOnRoadProperly), this);
0AA6: call_method 0x53E090 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::PlayHornIfNecessary

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::PlayHornIfNecessary), this);
0AA6: call_method 0x53C4B0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ProcessAutoBusDoors

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ProcessAutoBusDoors), this);
0AA6: call_method 0x53D370 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ProcessBuoyancy

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ProcessBuoyancy), this);
0AA6: call_method 0x5308D0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ProcessSwingingDoor

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, int, eDoors>(gaddrof(CAutomobile::ProcessSwingingDoor), this, component, door);
0AA6: call_method 0x535250 struct [CAutomobile] num_params 2 pop 0 [component] [door]
</pre>

#### CAutomobile::RcbanditCheck1CarWheels

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *, CPtrList &>(gaddrof(CAutomobile::RcbanditCheck1CarWheels), this, list);
0AA8: call_method_return 0x53CBA0 struct [CAutomobile] num_params 1 pop 0 [list] func_ret [bool]
</pre>

#### CAutomobile::RcbanditCheckHitWheels

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::RcbanditCheckHitWheels), this);
0AA8: call_method_return 0x53C990 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAutomobile::ReduceHornCounter

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ReduceHornCounter), this);
0AA6: call_method 0x5308C0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### \*CAutomobile::RemoveBonnetInPedCollision

<pre>
plugin::CallMethodAndReturnDynGlobal<CObject *, CAutomobile *>(gaddrof(CAutomobile::RemoveBonnetInPedCollision), this);
0AA8: call_method_return 0x535320 struct [*CAutomobile] num_params 0 pop 0 func_ret [CObject *]
</pre>

#### CAutomobile::ResetSuspension

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ResetSuspension), this);
0AA6: call_method 0x5353A0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ScanForCrimes

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ScanForCrimes), this);
0AA6: call_method 0x53C4F0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::SetBumperDamage

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, int, ePanels, bool>(gaddrof(CAutomobile::SetBumperDamage), this, component, panel, noFlyingComponents);
0AA6: call_method 0x530120 struct [CAutomobile] num_params 3 pop 0 [component] [panel] [noFlyingComponents]
</pre>

#### CAutomobile::SetBusDoorTimer

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, unsigned int, unsigned char>(gaddrof(CAutomobile::SetBusDoorTimer), this, timer, type);
0AA6: call_method 0x53D320 struct [CAutomobile] num_params 2 pop 0 [timer] [type]
</pre>

#### CAutomobile::SetComponentVisibility

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, RwFrame *, unsigned int>(gaddrof(CAutomobile::SetComponentVisibility), this, frame, flag);
0AA6: call_method 0x5300E0 struct [CAutomobile] num_params 2 pop 0 [frame] [flag]
</pre>

#### CAutomobile::SetDoorDamage

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, int, eDoors, bool>(gaddrof(CAutomobile::SetDoorDamage), this, component, door, noFlyingComponents);
0AA6: call_method 0x530200 struct [CAutomobile] num_params 3 pop 0 [component] [door] [noFlyingComponents]
</pre>

#### CAutomobile::SetPanelDamage

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, int, ePanels, bool>(gaddrof(CAutomobile::SetPanelDamage), this, component, panel, noFlyingComponents);
0AA6: call_method 0x5301A0 struct [CAutomobile] num_params 3 pop 0 [component] [panel] [noFlyingComponents]
</pre>

#### CAutomobile::SetTaxiLight

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, bool>(gaddrof(CAutomobile::SetTaxiLight), this, enable);
0AA6: call_method 0x53C420 struct [CAutomobile] num_params 1 pop 0 [enable]
</pre>

#### CAutomobile::SetupDamageAfterLoad

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupDamageAfterLoad), this);
0AA6: call_method 0x53C310 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::SetupModelNodes

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupModelNodes), this);
0AA6: call_method 0x52D1B0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::SetupSuspensionLines

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupSuspensionLines), this);
0AA6: call_method 0x52D210 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ShowAllComps

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ShowAllComps), this);
0AA6: call_method 0x5300D0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### \*CAutomobile::SpawnFlyingComponent

<pre>
plugin::CallMethodAndReturnDynGlobal<CObject *, CAutomobile *, int, unsigned int>(gaddrof(CAutomobile::SpawnFlyingComponent), this, component, type);
0AA8: call_method_return 0x530300 struct [*CAutomobile] num_params 2 pop 0 [component] [type] func_ret [CObject *]
</pre>

#### CAutomobile::TankControl

<pre>
plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::TankControl), this);
0AA6: call_method 0x53D530 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::VehicleDamage

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, float, unsigned short>(gaddrof(CAutomobile::VehicleDamage), this, impulse, damagedPiece);
0AA6: call_method 0x52F390 struct [CAutomobile] num_params 2 pop 0 [impulse] [damagedPiece]
</pre>

#### CAutomobile::dmgDrawCarCollidingParticles

<pre>
plugin::CallMethodDynGlobal<CAutomobile *, CVector const &, float>(gaddrof(CAutomobile::dmgDrawCarCollidingParticles), this, pos, amount);
0AA6: call_method 0x52F030 struct [CAutomobile] num_params 2 pop 0 [pos] [amount]
</pre>

#### CAutomobile::SetAllTaxiLights

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CAutomobile::SetAllTaxiLights), enable);
</pre>

#### \*SetVehicleAtomicVisibilityCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(SetVehicleAtomicVisibilityCB), object, data);
</pre>

#### \*GetCurrentAtomicObjectCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetCurrentAtomicObjectCB), object, data);
</pre>

### plugin_III\game_III\CAutoPilot.cpp

#### CAutoPilot::ModifySpeed

<pre>
plugin::CallMethod<0x4137B0, CAutoPilot *, float>(this, speed);
0AA6: call_method 0x4137B0 struct [CAutoPilot] num_params 1 pop 0 [speed]
</pre>

#### CAutoPilot::RemoveOnePathNode

<pre>
plugin::CallMethod<0x413A00, CAutoPilot *>(this);
0AA6: call_method 0x413A00 struct [CAutoPilot] num_params 0 pop 0
</pre>

### plugin_III\game_III\CBaseModelInfo.cpp

#### CBaseModelInfo::Shutdown

<pre>
plugin::CallVirtualMethod<1, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::Add2dEffect

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *, C2dEffect *>(gaddrof(CBaseModelInfo::Add2dEffect), this, effect);
0AA6: call_method 0x4F6B20 struct [CBaseModelInfo] num_params 1 pop 0 [effect]
</pre>

#### CBaseModelInfo::AddRef

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::AddRef), this);
0AA6: call_method 0x4F6BA0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::AddTexDictionaryRef

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::AddTexDictionaryRef), this);
0AA6: call_method 0x4F6B80 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::ClearTexDictionary

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::ClearTexDictionary), this);
0AA6: call_method 0x4F6B70 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::DeleteCollisionModel

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::DeleteCollisionModel), this);
0AA6: call_method 0x4F6AC0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### \*CBaseModelInfo::Get2dEffect

<pre>
plugin::CallMethodAndReturnDynGlobal<C2dEffect *, CBaseModelInfo *, int>(gaddrof(CBaseModelInfo::Get2dEffect), this, effectNumber);
0AA8: call_method_return 0x4F6B00 struct [*CBaseModelInfo] num_params 1 pop 0 [effectNumber] func_ret [C2dEffect *]
</pre>

#### CBaseModelInfo::Init2dEffects

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::Init2dEffects), this);
0AA6: call_method 0x4F6AF0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::RemoveRef

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::RemoveRef), this);
0AA6: call_method 0x4F6BB0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::RemoveTexDictionaryRef

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::RemoveTexDictionaryRef), this);
0AA6: call_method 0x4F6B90 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::SetTexDictionary

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *, char const *>(gaddrof(CBaseModelInfo::SetTexDictionary), this, txdName);
0AA6: call_method 0x4F6B40 struct [CBaseModelInfo] num_params 1 pop 0 [txdName]
</pre>

### plugin_III\game_III\CBoat.cpp

#### CBoat::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CBoat *, unsigned int>(this, modelIndex);
</pre>

#### CBoat::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CBoat *>(this);
</pre>

#### CBoat::Teleport

<pre>
plugin::CallVirtualMethod<11, CBoat *, CVector>(this, point);
</pre>

#### CBoat::PreRender

<pre>
plugin::CallVirtualMethod<12, CBoat *>(this);
</pre>

#### CBoat::Render

<pre>
plugin::CallVirtualMethod<13, CBoat *>(this);
</pre>

#### CBoat::ProcessControlInputs

<pre>
plugin::CallVirtualMethod<18, CBoat *, unsigned char>(this, padNumber);
</pre>

#### CBoat::GetComponentWorldPosition

<pre>
plugin::CallVirtualMethod<19, CBoat *, int, CVector &>(this, component, pos);
</pre>

#### CBoat::IsComponentPresent

<pre>
plugin::CallVirtualMethodAndReturn<bool, 20, CBoat *, int>(this, component);
</pre>

#### CBoat::BlowUpCar

<pre>
plugin::CallVirtualMethod<29, CBoat *, CEntity *>(this, entity);
</pre>

#### CBoat::AddWakePoint

<pre>
plugin::CallMethodDynGlobal<CBoat *, CVector>(gaddrof(CBoat::AddWakePoint), this, point);
0AA6: call_method 0x542140 struct [CBoat] num_params 1 pop 0 [point]
</pre>

#### CBoat::ApplyWaterResistance

<pre>
plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::ApplyWaterResistance), this);
0AA6: call_method 0x541A30 struct [CBoat] num_params 0 pop 0
</pre>

#### CBoat::PruneWakeTrail

<pre>
plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::PruneWakeTrail), this);
0AA6: call_method 0x5420D0 struct [CBoat] num_params 0 pop 0
</pre>

#### CBoat::SetupModelNodes

<pre>
plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::SetupModelNodes), this);
0AA6: call_method 0x53E7D0 struct [CBoat] num_params 0 pop 0
</pre>

#### CBoat::IsSectorAffectedByWake

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector2D, float, CBoat **>(gaddrof(CBoat::IsSectorAffectedByWake), sector, size, apBoats);
</pre>

#### CBoat::IsVertexAffectedByWake

<pre>
plugin::CallAndReturnDynGlobal<float, CVector, CBoat *>(gaddrof(CBoat::IsVertexAffectedByWake), vecVertex, boat);
</pre>

#### \*GetBoatAtomicObjectCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetBoatAtomicObjectCB), object, data);
</pre>

### plugin_III\game_III\CBridge.cpp

#### CBridge::ShouldLightsBeFlashing

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CBridge::ShouldLightsBeFlashing));
</pre>

#### CBridge::ThisIsABridgeObjectMovingUp

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CBridge::ThisIsABridgeObjectMovingUp), modelIndex);
</pre>

### plugin_III\game_III\CBrightLights.cpp

#### CBrightLights::RegisterOne

<pre>
plugin::CallDynGlobal<CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(gaddrof(CBrightLights::RegisterOne), posn, right, up, at, red, green, blue, alpha);
</pre>

### plugin_III\game_III\CBuilding.cpp

#### CBuilding::GetIsATreadable

<pre>
plugin::CallVirtualMethodAndReturn<bool, 17, CBuilding *>(this);
</pre>

#### CBuilding::ReplaceWithNewModel

<pre>
plugin::CallMethodDynGlobal<CBuilding *, int>(gaddrof(CBuilding::ReplaceWithNewModel), this, modelIndex);
0AA6: call_method 0x405850 struct [CBuilding] num_params 1 pop 0 [modelIndex]
</pre>

### plugin_III\game_III\CBulletInfo.cpp

#### CBulletInfo::AddBullet

<pre>
plugin::CallDynGlobal<CEntity *, eWeaponType, CVector, CVector>(gaddrof(CBulletInfo::AddBullet), pSource, type, pos, speed);
</pre>

#### CBulletInfo::TestForSniperBullet

<pre>
plugin::CallAndReturnDynGlobal<bool, float, float, float, float, float, float>(gaddrof(CBulletInfo::TestForSniperBullet), x1, x2, y1, y2, z1, z2);
</pre>

### plugin_III\game_III\CBulletTrace.cpp

#### CBulletTrace::Update

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(gaddrof(CBulletTrace::Update), this);
0AA6: call_method 0x519270 struct [CBulletTrace] num_params 0 pop 0
</pre>

### plugin_III\game_III\CBulletTraces.cpp

#### CBulletTraces::AddTrace

<pre>
plugin::CallDynGlobal<CVector *, CVector *>(gaddrof(CBulletTraces::AddTrace), origin, target);
</pre>

### plugin_III\game_III\CCamera.cpp

#### CCamera::CalculateDerivedValues

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CalculateDerivedValues), this);
0AA6: call_method 0x46EEA0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::CamControl

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CamControl), this);
0AA6: call_method 0x468250 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::CamShake

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, float, float, float>(gaddrof(CCamera::CamShake), this, strength, x, y, z);
0AA6: call_method 0x46B200 struct [CCamera] num_params 4 pop 0 [strength] [x] [y] [z]
</pre>

#### CCamera::ClearPlayerWeaponMode

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ClearPlayerWeaponMode), this);
0AA6: call_method 0x46B350 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::DontProcessObbeCinemaCamera

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DontProcessObbeCinemaCamera), this);
0AA6: call_method 0x46B380 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::DrawBordersForWideScreen

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DrawBordersForWideScreen), this);
0AA6: call_method 0x46B430 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Fade

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, short>(gaddrof(CCamera::Fade), this, timeOut, direction);
0AA6: call_method 0x46B3A0 struct [CCamera] num_params 2 pop 0 [timeOut] [direction]
</pre>

#### CCamera::Find3rdPersonCamTargetVector

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, CVector, CVector &, CVector &>(gaddrof(CCamera::Find3rdPersonCamTargetVector), this, dist, pos, source, target);
0AA6: call_method 0x46B580 struct [CCamera] num_params 4 pop 0 [dist] [pos] [source] [target]
</pre>

#### CCamera::Find3rdPersonQuickAimPitch

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::Find3rdPersonQuickAimPitch), this);
0AA8: call_method_return 0x46B850 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::FinishCutscene

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::FinishCutscene), this);
0AA6: call_method 0x46B560 struct [CCamera] num_params 0 pop 0
</pre>

#### \*CCamera::GetCameraMatrix

<pre>
plugin::CallMethodAndReturnDynGlobal<CMatrix *, CCamera *>(gaddrof(CCamera::GetCameraMatrix), this);
0AA8: call_method_return 0x42C8B0 struct [*CCamera] num_params 0 pop 0 func_ret [CMatrix *]
</pre>

#### CCamera::GetCutSceneFinishTime

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::GetCutSceneFinishTime), this);
0AA8: call_method_return 0x46B920 struct [CCamera] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CCamera::GetFading

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetFading), this);
0AA8: call_method_return 0x46B970 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetFadingDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetFadingDirection), this);
0AA8: call_method_return 0x46B980 struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### \*CCamera::GetGameCamPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<CVector *, CCamera *>(gaddrof(CCamera::GetGameCamPosition), this);
0AA8: call_method_return 0x46BA10 struct [*CCamera] num_params 0 pop 0 func_ret [CVector *]
</pre>

#### CCamera::GetLookDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetLookDirection), this);
0AA8: call_method_return 0x46BA50 struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### CCamera::GetLookingForwardFirstPerson

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingForwardFirstPerson), this);
0AA8: call_method_return 0x46BA90 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetLookingLRBFirstPerson

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingLRBFirstPerson), this);
0AA8: call_method_return 0x46BA20 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetPositionAlongSpline

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetPositionAlongSpline), this);
0AA8: call_method_return 0x46BAC0 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::GetScreenFadeStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetScreenFadeStatus), this);
0AA8: call_method_return 0x46B9C0 struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### CCamera::Get_Just_Switched_Status

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Get_Just_Switched_Status), this);
0AA8: call_method_return 0x46B9B0 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::Init

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Init), this);
0AA6: call_method 0x46BAD0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::InitialiseCameraForDebugMode

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::InitialiseCameraForDebugMode), this);
0AA6: call_method 0x46BEB0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::IsItTimeForNewcam

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int, int>(gaddrof(CCamera::IsItTimeForNewcam), this, obbeMode, time);
0AA8: call_method_return 0x46BF10 struct [CCamera] num_params 2 pop 0 [obbeMode] [time] func_ret [bool]
</pre>

#### CCamera::IsSphereVisible

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float, CMatrix const *>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float, CMatrix const *)), this, center, radius, matrix);
0AA8: call_method_return 0x43D3B0 struct [CCamera] num_params 3 pop 0 [center] [radius] [matrix] func_ret [bool]
</pre>

#### CCamera::IsSphereVisible

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float)), this, center, radius);
0AA8: call_method_return 0x43D3B0 struct [CCamera] num_params 2 pop 0 [center] [radius] func_ret [bool]
</pre>

#### CCamera::LoadPathSplines

<pre>
plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::LoadPathSplines), this, file);
0AA6: call_method 0x46D1D0 struct [CCamera] num_params 1 pop 0 [file]
</pre>

#### CCamera::LoadTrainCamNodes

<pre>
plugin::CallMethodDynGlobal<CCamera *, char const *>(gaddrof(CCamera::LoadTrainCamNodes), this, name);
0AA6: call_method 0x46C9E0 struct [CCamera] num_params 1 pop 0 [name]
</pre>

#### CCamera::Process

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process), this);
0AA6: call_method 0x46D3F0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessFade

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessFade), this);
0AA6: call_method 0x46F080 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessMusicFade

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessMusicFade), this);
0AA6: call_method 0x46F1E0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraCar

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraCar), this);
0AA6: call_method 0x46F3E0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraPed

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPed), this);
0AA6: call_method 0x46F520 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessWideScreenOn

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessWideScreenOn), this);
0AA6: call_method 0x46F8E0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Process_Train_Camera_Control

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process_Train_Camera_Control), this);
0AA6: call_method 0x46F600 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RenderMotionBlur

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RenderMotionBlur), this);
0AA6: call_method 0x46F940 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Restore

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Restore), this);
0AA6: call_method 0x46F990 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RestoreWithJumpCut

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreWithJumpCut), this);
0AA6: call_method 0x46FAE0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetCamCutSceneOffSet

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const &>(gaddrof(CCamera::SetCamCutSceneOffSet), this, pos);
0AA6: call_method 0x46FC30 struct [CCamera] num_params 1 pop 0 [pos]
</pre>

#### CCamera::SetCamPositionForFixedMode

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const &, CVector const &>(gaddrof(CCamera::SetCamPositionForFixedMode), this, source, offset);
0AA6: call_method 0x46FCC0 struct [CCamera] num_params 2 pop 0 [source] [offset]
</pre>

#### CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString), this);
0AA6: call_method 0x46FC60 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString), this);
0AA6: call_method 0x46FC90 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetFadeColour

<pre>
plugin::CallMethodDynGlobal<CCamera *, unsigned char, unsigned char, unsigned char>(gaddrof(CCamera::SetFadeColour), this, red, green, blue);
0AA6: call_method 0x46FD00 struct [CCamera] num_params 3 pop 0 [red] [green] [blue]
</pre>

#### CCamera::SetMotionBlur

<pre>
plugin::CallMethodDynGlobal<CCamera *, int, int, int, int, int>(gaddrof(CCamera::SetMotionBlur), this, red, green, blue, value, type);
0AA6: call_method 0x46FD40 struct [CCamera] num_params 5 pop 0 [red] [green] [blue] [value] [type]
</pre>

#### CCamera::SetMotionBlurAlpha

<pre>
plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::SetMotionBlurAlpha), this, alpha);
0AA6: call_method 0x46FD80 struct [CCamera] num_params 1 pop 0 [alpha]
</pre>

#### CCamera::SetNearClipScript

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipScript), this, clip);
0AA6: call_method 0x46FD90 struct [CCamera] num_params 1 pop 0 [clip]
</pre>

#### CCamera::SetNewPlayerWeaponMode

<pre>
plugin::CallMethodDynGlobal<CCamera *, short, short, short>(gaddrof(CCamera::SetNewPlayerWeaponMode), this, mode, minZoom, maxZoom);
0AA6: call_method 0x46FDB0 struct [CCamera] num_params 3 pop 0 [mode] [minZoom] [maxZoom]
</pre>

#### CCamera::SetParametersForScriptInterpolation

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, float, unsigned int>(gaddrof(CCamera::SetParametersForScriptInterpolation), this, stopMoving, catchUp, time);
0AA6: call_method 0x46FDE0 struct [CCamera] num_params 3 pop 0 [stopMoving] [catchUp] [time]
</pre>

#### CCamera::SetPercentAlongCutScene

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetPercentAlongCutScene), this, percent);
0AA6: call_method 0x46FE20 struct [CCamera] num_params 1 pop 0 [percent]
</pre>

#### CCamera::SetRwCamera

<pre>
plugin::CallMethodDynGlobal<CCamera *, RwCamera *>(gaddrof(CCamera::SetRwCamera), this, rwCamera);
0AA6: call_method 0x46FEC0 struct [CCamera] num_params 1 pop 0 [rwCamera]
</pre>

#### CCamera::SetWideScreenOff

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOff), this);
0AA6: call_method 0x46FF10 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetWideScreenOn

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOn), this);
0AA6: call_method 0x46FF00 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetZoomValueCamStringScript

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueCamStringScript), this, dist);
0AA6: call_method 0x46FF90 struct [CCamera] num_params 1 pop 0 [dist]
</pre>

#### CCamera::SetZoomValueFollowPedScript

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueFollowPedScript), this, dist);
0AA6: call_method 0x46FF30 struct [CCamera] num_params 1 pop 0 [dist]
</pre>

#### CCamera::StartTransition

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransition), this, newMode);
0AA6: call_method 0x46FFF0 struct [CCamera] num_params 1 pop 0 [newMode]
</pre>

#### CCamera::StartTransitionWhenNotFinishedInter

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransitionWhenNotFinishedInter), this, mode);
0AA6: call_method 0x470D80 struct [CCamera] num_params 1 pop 0 [mode]
</pre>

#### CCamera::StoreValuesDuringInterPol

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector &, CVector &, CVector &, float *>(gaddrof(CCamera::StoreValuesDuringInterPol), this, source, target, up, fov);
0AA6: call_method 0x470DA0 struct [CCamera] num_params 4 pop 0 [source] [target] [up] [fov]
</pre>

#### CCamera::TakeControl

<pre>
plugin::CallMethodDynGlobal<CCamera *, CEntity *, short, short, int>(gaddrof(CCamera::TakeControl), this, target, mode, typeOfSwitch, controller);
0AA6: call_method 0x471500 struct [CCamera] num_params 4 pop 0 [target] [mode] [typeOfSwitch] [controller]
</pre>

#### CCamera::TakeControlNoEntity

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const &, short, int>(gaddrof(CCamera::TakeControlNoEntity), this, pos, typeOfSwitch, controller);
0AA6: call_method 0x4715B0 struct [CCamera] num_params 3 pop 0 [pos] [typeOfSwitch] [controller]
</pre>

#### CCamera::TakeControlWithSpline

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::TakeControlWithSpline), this, typeOfSwitch);
0AA6: call_method 0x471620 struct [CCamera] num_params 1 pop 0 [typeOfSwitch]
</pre>

#### CCamera::TryToStartNewCamMode

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int>(gaddrof(CCamera::TryToStartNewCamMode), this, obbeMode);
0AA8: call_method_return 0x471650 struct [CCamera] num_params 1 pop 0 [obbeMode] func_ret [bool]
</pre>

#### CCamera::UpdateAimingCoors

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const &>(gaddrof(CCamera::UpdateAimingCoors), this, coors);
0AA6: call_method 0x472F10 struct [CCamera] num_params 1 pop 0 [coors]
</pre>

#### CCamera::UpdateSoundDistances

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateSoundDistances), this);
0AA6: call_method 0x470EA0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::UpdateTargetEntity

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateTargetEntity), this);
0AA6: call_method 0x4712A0 struct [CCamera] num_params 0 pop 0
</pre>

#### CamShakeNoPos

<pre>
plugin::CallDynGlobal<CCamera *, float>(gaddrof(CamShakeNoPos), camera, strength);
</pre>

### plugin_III\game_III\CCarAI.cpp

#### CCarAI::AddAmbulanceOccupants

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddAmbulanceOccupants), vehicle);
</pre>

#### CCarAI::AddFiretruckOccupants

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddFiretruckOccupants), vehicle);
</pre>

#### CCarAI::AddPoliceCarOccupants

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddPoliceCarOccupants), vehicle);
</pre>

#### CCarAI::CarHasReasonToStop

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::CarHasReasonToStop), vehicle);
</pre>

#### CCarAI::FindPoliceCarMissionForWantedLevel

<pre>
plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceCarMissionForWantedLevel));
</pre>

#### CCarAI::FindPoliceCarSpeedForWantedLevel

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CCarAI::FindPoliceCarSpeedForWantedLevel), vehicle);
</pre>

#### CCarAI::FindSwitchDistanceClose

<pre>
plugin::CallAndReturnDynGlobal<float>(gaddrof(CCarAI::FindSwitchDistanceClose));
</pre>

#### CCarAI::FindSwitchDistanceFar

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarAI::FindSwitchDistanceFar), vehicle);
</pre>

#### CCarAI::GetCarToGoToCoors

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToGoToCoors), vehicle, coors);
</pre>

#### CCarAI::MakeWayForCarWithSiren

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MakeWayForCarWithSiren), vehicle);
</pre>

#### CCarAI::MellowOutChaseSpeed

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeed), vehicle);
</pre>

#### CCarAI::TellCarToBlockOtherCar

<pre>
plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToBlockOtherCar), vehicle, blockVehicle);
</pre>

#### CCarAI::TellCarToRamOtherCar

<pre>
plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToRamOtherCar), vehicle, ramVehicle);
</pre>

#### CCarAI::TellOccupantsToLeaveCar

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToLeaveCar), vehicle);
</pre>

#### CCarAI::UpdateCarAI

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::UpdateCarAI), vehicle);
</pre>

### plugin_III\game_III\CCarCtrl.cpp

#### CCarCtrl::AddToCarArray

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CCarCtrl::AddToCarArray), id, vehicleClass);
</pre>

#### CCarCtrl::ChooseCarModel

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::ChooseCarModel), vehicleClass);
</pre>

#### CCarCtrl::ChooseGangCarModel

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::ChooseGangCarModel), gang);
</pre>

#### CCarCtrl::ChooseModel

<pre>
plugin::CallAndReturnDynGlobal<int, CZoneInfo *, CVector *, int *>(gaddrof(CCarCtrl::ChooseModel), info, pos, outVehicleClass);
</pre>

#### CCarCtrl::ChoosePoliceCarModel

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CCarCtrl::ChoosePoliceCarModel));
</pre>

#### CCarCtrl::CountCarsOfType

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::CountCarsOfType), modelIndex);
</pre>

#### CCarCtrl::DragCarToPoint

<pre>
plugin::CallDynGlobal<CVehicle *, CVector *>(gaddrof(CCarCtrl::DragCarToPoint), vehicle, point);
</pre>

#### CCarCtrl::FindAngleToWeaveThroughTraffic

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *, CPhysical *, float, float>(gaddrof(CCarCtrl::FindAngleToWeaveThroughTraffic), vehicle, target, angleToTarget, angleForward);
</pre>

#### CCarCtrl::FindLinksToGoWithTheseNodes

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::FindLinksToGoWithTheseNodes), vehicle);
</pre>

#### CCarCtrl::FindMaxSteerAngle

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarCtrl::FindMaxSteerAngle), vehicle);
</pre>

#### CCarCtrl::FindMaximumSpeedForThisCarInTraffic

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarCtrl::FindMaximumSpeedForThisCarInTraffic), vehicle);
</pre>

#### CCarCtrl::FindPathDirection

<pre>
plugin::CallAndReturnDynGlobal<unsigned char, int, int, int>(gaddrof(CCarCtrl::FindPathDirection), prevNode, curNode, nextNode);
</pre>

#### CCarCtrl::FindSpeedMultiplier

<pre>
plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CCarCtrl::FindSpeedMultiplier), angleChange, minAngle, maxAngle, coef);
</pre>

#### CCarCtrl::GenerateOneEmergencyServicesCar

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned int, CVector>(gaddrof(CCarCtrl::GenerateOneEmergencyServicesCar), modelIndex, point);
</pre>

#### CCarCtrl::IsThisVehicleInteresting

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::IsThisVehicleInteresting), vehicle);
</pre>

#### CCarCtrl::JoinCarWithRoadSystem

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::JoinCarWithRoadSystem), vehicle);
</pre>

#### CCarCtrl::JoinCarWithRoadSystemGotoCoors

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *, CVector, bool>(gaddrof(CCarCtrl::JoinCarWithRoadSystemGotoCoors), vehicle, point, isProperNow);
</pre>

#### CCarCtrl::MapCouldMoveInThisArea

<pre>
plugin::CallAndReturnDynGlobal<bool, float, float>(gaddrof(CCarCtrl::MapCouldMoveInThisArea), x, y);
</pre>

#### CCarCtrl::PickNextNodeAccordingStrategy

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeAccordingStrategy), vehicle);
</pre>

#### CCarCtrl::PickNextNodeRandomly

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::PickNextNodeRandomly), vehicle);
</pre>

#### CCarCtrl::PickNextNodeToChaseCar

<pre>
plugin::CallDynGlobal<CVehicle *, float, float, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeToChaseCar), vehicle, targetX, targetY, target);
</pre>

#### CCarCtrl::PickNextNodeToFollowPath

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeToFollowPath), vehicle);
</pre>

#### CCarCtrl::PossiblyRemoveVehicle

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::PossiblyRemoveVehicle), vehicle);
</pre>

#### CCarCtrl::RegisterVehicleOfInterest

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::RegisterVehicleOfInterest), vehicle);
</pre>

#### CCarCtrl::RemoveFromInterestingVehicleList

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::RemoveFromInterestingVehicleList), vehicle);
</pre>

#### CCarCtrl::ScanForPedDanger

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::ScanForPedDanger), vehicle);
</pre>

#### CCarCtrl::SlowCarDownForCarsSectorList

<pre>
plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float>(gaddrof(CCarCtrl::SlowCarDownForCarsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pSpeed, curSpeed);
</pre>

#### CCarCtrl::SlowCarDownForOtherCar

<pre>
plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float>(gaddrof(CCarCtrl::SlowCarDownForOtherCar), entity, vehicle, pSpeed, curSpeed);
</pre>

#### CCarCtrl::SlowCarDownForPedsSectorList

<pre>
plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float>(gaddrof(CCarCtrl::SlowCarDownForPedsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pSpeed, curSpeed);
</pre>

#### CCarCtrl::SlowCarOnRailsDownForTrafficAndLights

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SlowCarOnRailsDownForTrafficAndLights), vehicle);
</pre>

#### CCarCtrl::SteerAIBoatWithPhysics

<pre>
plugin::CallDynGlobal<CBoat *>(gaddrof(CCarCtrl::SteerAIBoatWithPhysics), boat);
</pre>

#### CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget

<pre>
plugin::CallDynGlobal<CBoat *, float, float, float *, float *, float *>(gaddrof(CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget), boat, targetX, targetY, steerAngle, gasPedal, breakPedal);
</pre>

#### CCarCtrl::SteerAICarWithPhysics

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SteerAICarWithPhysics), vehicle);
</pre>

#### CCarCtrl::SteerAICarWithPhysicsFollowPath

<pre>
plugin::CallDynGlobal<CVehicle *, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsFollowPath), vehicle, steerAngle, gasPedal, breakPedal, bHandBrake);
</pre>

#### CCarCtrl::SteerAICarWithPhysicsHeadingForTarget

<pre>
plugin::CallDynGlobal<CVehicle *, CPhysical *, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsHeadingForTarget), vehicle, target, targetX, targetY, steerAngle, gasPedal, breakPedal, bHandBrake);
</pre>

#### CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget

<pre>
plugin::CallDynGlobal<CVehicle *, float, float, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget), vehicle, targetX, targetY, targetSpeedX, targetSpeedY, steerAngle, gasPedal, breakPedal, bHandBrake);
</pre>

#### CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop

<pre>
plugin::CallDynGlobal<CVehicle *, float, float, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop), vehicle, targetX, targetY, targetSpeedX, targetSpeedY, steerAngle, gasPedal, breakPedal, bHandBrake);
</pre>

#### CCarCtrl::SteerAICarWithPhysics_OnlyMission

<pre>
plugin::CallDynGlobal<CVehicle *, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysics_OnlyMission), vehicle, steerAngle, gasPedal, breakPedal, bHandBrake);
</pre>

#### CCarCtrl::SwitchVehicleToRealPhysics

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SwitchVehicleToRealPhysics), vehicle);
</pre>

#### CCarCtrl::TestCollisionBetween2MovingRects

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *, CVehicle *, float, float, CVector *, CVector *, unsigned char>(gaddrof(CCarCtrl::TestCollisionBetween2MovingRects), vehicleA, vehicleB, projectionX, projectionY, pForwardA, pForwardB, id);
</pre>

#### CCarCtrl::ThisRoadObjectCouldMove

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CCarCtrl::ThisRoadObjectCouldMove), objectModelIndex);
</pre>

#### CCarCtrl::UpdateCarCount

<pre>
plugin::CallDynGlobal<CVehicle *, bool>(gaddrof(CCarCtrl::UpdateCarCount), vehicle, remove);
</pre>

#### CCarCtrl::UpdateCarOnRails

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::UpdateCarOnRails), vehicle);
</pre>

#### CCarCtrl::WeaveForObject

<pre>
plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForObject), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);
</pre>

#### CCarCtrl::WeaveForOtherCar

<pre>
plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForOtherCar), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);
</pre>

#### CCarCtrl::WeaveForPed

<pre>
plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForPed), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);
</pre>

#### CCarCtrl::WeaveThroughCarsSectorList

<pre>
plugin::CallDynGlobal<CPtrList &, CVehicle *, CPhysical *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughCarsSectorList), list, vehicle, target, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);
</pre>

#### CCarCtrl::WeaveThroughObjectsSectorList

<pre>
plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughObjectsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);
</pre>

#### CCarCtrl::WeaveThroughPedsSectorList

<pre>
plugin::CallDynGlobal<CPtrList &, CVehicle *, CPhysical *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughPedsSectorList), list, vehicle, target, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);
</pre>

### plugin_III\game_III\CCarGenerator.cpp

#### CCarGenerator::CalcNextGen

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CCarGenerator *>(gaddrof(CCarGenerator::CalcNextGen), this);
0AA8: call_method_return 0x5426C0 struct [CCarGenerator] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CCarGenerator::CheckForBlockage

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckForBlockage), this);
0AA8: call_method_return 0x542DF0 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCarGenerator::CheckIfWithinRangeOfAnyPlayers

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckIfWithinRangeOfAnyPlayers), this);
0AA8: call_method_return 0x542E50 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCarGenerator::DoInternalProcessing

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::DoInternalProcessing), this);
0AA6: call_method 0x5426E0 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::Process

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::Process), this);
0AA6: call_method 0x542BB0 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::Setup

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(gaddrof(CCarGenerator::Setup), this, x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay);
0AA6: call_method 0x542C40 struct [CCarGenerator] num_params 12 pop 0 [x] [y] [z] [angle] [modelId] [primaryColor] [secondaryColor] [forceSpawn] [alarm] [doorLock] [minDelay] [maxDelay]
</pre>

#### CCarGenerator::SwitchOff

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOff), this);
0AA6: call_method 0x542690 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::SwitchOn

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOn), this);
0AA6: call_method 0x5426A0 struct [CCarGenerator] num_params 0 pop 0
</pre>

### plugin_III\game_III\CCivilianPed.cpp

#### CCivilianPed::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CCivilianPed *>(this);
</pre>

#### CCivilianPed::CivilianAI

<pre>
plugin::CallMethodDynGlobal<CCivilianPed *>(gaddrof(CCivilianPed::CivilianAI), this);
0AA6: call_method 0x4C07A0 struct [CCivilianPed] num_params 0 pop 0
</pre>

### plugin_III\game_III\CClock.cpp

#### CClock::GetGameClockMinutesUntil

<pre>
plugin::CallAndReturnDynGlobal<int, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);
</pre>

#### CClock::GetIsTimeInRange

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);
</pre>

#### CClock::Initialise

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);
</pre>

#### CClock::SetGameClock

<pre>
plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes);
</pre>

### plugin_III\game_III\CClouds.cpp

#### CClouds::RenderBackground

<pre>
plugin::CallDynGlobal<short, short, short, short, short, short, short>(gaddrof(CClouds::RenderBackground), redTop, greenTop, blueTop, redBottom, greenBottom, blueBottom, alpha);
</pre>

#### UseDarkBackground

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(UseDarkBackground));
</pre>

### plugin_III\game_III\CClumpModelInfo.cpp

#### CClumpModelInfo::DeleteRwObject

<pre>
plugin::CallVirtualMethod<2, CClumpModelInfo *>(this);
</pre>

#### \*CClumpModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 3, CClumpModelInfo *>(this);
</pre>

#### \*CClumpModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 4, CClumpModelInfo *, RwMatrix *>(this, matrix);
</pre>

#### \*CClumpModelInfo::GetRwObject

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 5, CClumpModelInfo *>(this);
</pre>

#### CClumpModelInfo::SetClump

<pre>
plugin::CallVirtualMethod<6, CClumpModelInfo *, RpClump *>(this, clump);
</pre>

#### CClumpModelInfo::SetFrameIds

<pre>
plugin::CallMethodDynGlobal<CClumpModelInfo *, RwObjectNameIdAssocation *>(gaddrof(CClumpModelInfo::SetFrameIds), this, id);
0AA6: call_method 0x4F8BB0 struct [CClumpModelInfo] num_params 1 pop 0 [id]
</pre>

#### CClumpModelInfo::FillFrameArray

<pre>
plugin::CallDynGlobal<RpClump *, RwFrame **>(gaddrof(CClumpModelInfo::FillFrameArray), clump, frames);
</pre>

#### \*CClumpModelInfo::FillFrameArrayCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FillFrameArrayCB), frame, data);
</pre>

#### \*CClumpModelInfo::FindFrameFromIdCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromIdCB), frame, data);
</pre>

#### \*CClumpModelInfo::FindFrameFromNameCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromNameCB), frame, data);
</pre>

#### \*CClumpModelInfo::FindFrameFromNameWithoutIdCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromNameWithoutIdCB), frame, data);
</pre>

#### \*CClumpModelInfo::GetFrameFromId

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RpClump *, int>(gaddrof(CClumpModelInfo::GetFrameFromId), clump, id);
</pre>

#### \*CClumpModelInfo::SetAtomicRendererCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CClumpModelInfo::SetAtomicRendererCB), atomic, data);
</pre>

### plugin_III\game_III\CColBox.cpp

#### CColBox::operator=

<pre>
plugin::CallMethodDynGlobal<CColBox *, CColBox const &>(gaddrof(CColBox::operator=), this, right);
0AA6: call_method 0x40B2E0 struct [CColBox] num_params 1 pop 0 [right]
</pre>

#### CColBox::Set

<pre>
plugin::CallMethodDynGlobal<CColBox *, CVector &, CVector &, unsigned char, unsigned char>(gaddrof(CColBox::Set), this, min, max, material, flag);
0AA6: call_method 0x40B2A0 struct [CColBox] num_params 4 pop 0 [min] [max] [material] [flag]
</pre>

### plugin_III\game_III\CColLine.cpp

#### CColLine::Set

<pre>
plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(gaddrof(CColLine::Set), this, start, end);
0AA6: call_method 0x40B350 struct [CColLine] num_params 2 pop 0 [start] [end]
</pre>

### plugin_III\game_III\CCollision.cpp

#### CCollision::Init

<pre>
plugin::Call<0x40B380>();
0AA5: call_function 0x40B380 num_params 0 pop 0
</pre>

#### CCollision::Shutdown

<pre>
plugin::Call<0x40B3A0>();
0AA5: call_function 0x40B3A0 num_params 0 pop 0
</pre>

#### CCollision::Update

<pre>
plugin::Call<0x40B3B0>();
0AA5: call_function 0x40B3B0 num_params 0 pop 0
</pre>

#### CCollision::LoadCollisionScreen

<pre>
plugin::Call<0x40B580, eLevelName>(levelName);
0AA5: call_function 0x40B580 num_params 1 pop 1 [levelName]
</pre>

#### CCollision::LoadCollisionWhenINeedIt

<pre>
plugin::Call<0x40B5B0, bool>(arg0);
0AA5: call_function 0x40B5B0 num_params 1 pop 1 [arg0]
</pre>

#### CCollision::SortOutCollisionAfterLoad

<pre>
plugin::Call<0x40B900>();
0AA5: call_function 0x40B900 num_params 0 pop 0
</pre>

#### CCollision::CalculateTrianglePlanes

<pre>
plugin::Call<0x40B960, CColModel*>(colModel);
0AA5: call_function 0x40B960 num_params 1 pop 1 [colModel]
</pre>

#### CCollision::ProcessSphereSphere

<pre>
plugin::CallAndReturn<bool, 0x40B9F0, CColSphere const&, CColSphere const&, CColPoint&, float&>(sphere1, sphere2, colPoint, maxTouchDistance);
0AA7: call_function_return 0x40B9F0 num_params 4 pop 4 [sphere1] [sphere2] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestSphereBox

<pre>
plugin::CallAndReturn<bool, 0x40BB70, CColSphere const&, CColBox const&>(sphere, box);
0AA7: call_function_return 0x40BB70 num_params 2 pop 2 [sphere] [box] func_ret [bool]
</pre>

#### CCollision::ProcessSphereBox

<pre>
plugin::CallAndReturn<bool, 0x40BC00, CColSphere const&, CColBox const&, CColPoint&, float&>(sphere, box, colPoint, maxTouchDistance);
0AA7: call_function_return 0x40BC00 num_params 4 pop 4 [sphere] [box] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestSphereTriangle

<pre>
plugin::CallAndReturn<bool, 0x40C580, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(sphere, verts, tri, triPlane);
0AA7: call_function_return 0x40C580 num_params 4 pop 4 [sphere] [verts] [tri] [triPlane] func_ret [bool]
</pre>

#### CCollision::ProcessSphereTriangle

<pre>
plugin::CallAndReturn<bool, 0x40CE30, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(sphere, verts, tri, triPlane, colPoint, maxTouchDistance);
0AA7: call_function_return 0x40CE30 num_params 6 pop 6 [sphere] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestLineSphere

<pre>
plugin::CallAndReturn<bool, 0x40DAA0, CColLine const&, CColSphere const&>(colLine, sphere);
0AA7: call_function_return 0x40DAA0 num_params 2 pop 2 [colLine] [sphere] func_ret [bool]
</pre>

#### CCollision::DistToLine

<pre>
plugin::CallAndReturn<float, 0x40DC70, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
0AA7: call_function_return 0x40DC70 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]
</pre>

#### CCollision::ProcessLineSphere

<pre>
plugin::CallAndReturn<bool, 0x40DE80, CColLine const&, CColSphere const&, CColPoint&, float&>(colLine, sphere, colPoint, depth);
0AA7: call_function_return 0x40DE80 num_params 4 pop 4 [colLine] [sphere] [colPoint] [depth] func_ret [bool]
</pre>

#### CCollision::TestLineBox

<pre>
plugin::CallAndReturn<bool, 0x40E130, CColLine const&, CColBox const&>(colLine, colBox);
0AA7: call_function_return 0x40E130 num_params 2 pop 2 [colLine] [colBox] func_ret [bool]
</pre>

#### CCollision::TestVerticalLineBox

<pre>
plugin::CallAndReturn<bool, 0x40E5C0, CColLine const&, CColBox const&>(colLine, colBox);
0AA7: call_function_return 0x40E5C0 num_params 2 pop 2 [colLine] [colBox] func_ret [bool]
</pre>

#### CCollision::ProcessLineBox

<pre>
plugin::CallAndReturn<bool, 0x40E670, CColLine const&, CColBox const&, CColPoint&, float&>(colLine, colBox, colPoint, maxTouchDistance);
0AA7: call_function_return 0x40E670 num_params 4 pop 4 [colLine] [colBox] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestLineTriangle

<pre>
plugin::CallAndReturn<bool, 0x40EC10, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(colLine, verts, tri, triPlane);
0AA7: call_function_return 0x40EC10 num_params 4 pop 4 [colLine] [verts] [tri] [triPlane] func_ret [bool]
</pre>

#### CCollision::ProcessLineTriangle

<pre>
plugin::CallAndReturn<bool, 0x40F140, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(colLine, verts, tri, triPlane, colPoint, maxTouchDistance);
0AA7: call_function_return 0x40F140 num_params 6 pop 6 [colLine] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x40F720, CColLine const&, CMatrix const&, CColModel&, bool>(colLine, transform, colModel, doSeeThroughCheck);
0AA7: call_function_return 0x40F720 num_params 4 pop 4 [colLine] [transform] [colModel] [doSeeThroughCheck] func_ret [bool]
</pre>

#### CCollision::ProcessLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x40F910, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool>(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck);
0AA7: call_function_return 0x40F910 num_params 6 pop 6 [colLine] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] func_ret [bool]
</pre>

#### CCollision::ProcessVerticalLineTriangle

<pre>
plugin::CallAndReturn<bool, 0x40FB50, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly*>(colLine, verts, tri, triPlane, colPoint, maxTouchDistance, colPoly);
0AA7: call_function_return 0x40FB50 num_params 7 pop 7 [colLine] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] [colPoly] func_ret [bool]
</pre>

#### CCollision::ProcessVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x410120, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, CStoredCollPoly*>(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, colPoly);
0AA7: call_function_return 0x410120 num_params 7 pop 7 [colLine] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] [colPoly] func_ret [bool]
</pre>

#### CCollision::IsStoredPolyStillValidVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x4105A0, CVector const&, float, CColPoint&, CStoredCollPoly*>(lineOrigin, lineDist, colPoint, colPoly);
0AA7: call_function_return 0x4105A0 num_params 4 pop 4 [lineOrigin] [lineDist] [colPoint] [colPoly] func_ret [bool]
</pre>

#### CCollision::ProcessColModels

<pre>
plugin::CallAndReturn<int, 0x410BE0, CMatrix const&, CColModel&, CMatrix const&, CColModel&, CColPoint*, CColPoint*, float*>(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance);
0AA7: call_function_return 0x410BE0 num_params 7 pop 7 [transform1] [colModel1] [transform2] [colModel2] [colPoint1] [colPoint2] [maxTouchDistance] func_ret [int]
</pre>

### plugin_III\game_III\CColModel.cpp

#### CColModel::CColModel

<pre>
plugin::CallMethodDynGlobal<CColModel *>(ctor_gaddr(CColModel), this);</pre>

#### CColModel::~CColModel

<pre>
plugin::CallMethodDynGlobal<CColModel *>(dtor_gaddr(CColModel), this);</pre>

#### CColModel::operator=

<pre>
plugin::CallMethodDynGlobal<CColModel *, CColModel const &>(gaddrof_o(CColModel::operator=, void (CColModel::*)(CColModel const &)), this, right);
0AA6: call_method 0x411710 struct [CColModel] num_params 1 pop 0 [right]
</pre>

#### CColModel::CalculateTrianglePlanes

<pre>
plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::CalculateTrianglePlanes), this);
0AA6: call_method 0x411CB0 struct [CColModel] num_params 0 pop 0
</pre>

#### \*CColModel::GetLinkPtr

<pre>
plugin::CallMethodAndReturnDynGlobal<CLink<CColModel *> *, CColModel *>(gaddrof(CColModel::GetLinkPtr), this);
0AA8: call_method_return 0x411D60 struct [*CColModel] num_params 0 pop 0 func_ret [CLink<CColModel *> *]
</pre>

#### CColModel::GetTrianglePoint

<pre>
plugin::CallMethodDynGlobal<CColModel *, CVector &, int>(gaddrof(CColModel::GetTrianglePoint), this, outVec, vertId);
0AA6: call_method 0x411C70 struct [CColModel] num_params 2 pop 0 [outVec] [vertId]
</pre>

#### CColModel::RemoveCollisionVolumes

<pre>
plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::RemoveCollisionVolumes), this);
0AA6: call_method 0x411D80 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::RemoveTrianglePlanes

<pre>
plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::RemoveTrianglePlanes), this);
0AA6: call_method 0x411D10 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::SetLinkPtr

<pre>
plugin::CallMethodDynGlobal<CColModel *, CLink<CColModel *> *>(gaddrof(CColModel::SetLinkPtr), this, link);
0AA6: call_method 0x411D40 struct [CColModel] num_params 1 pop 0 [link]
</pre>

### plugin_III\game_III\CColSphere.cpp

#### CColSphere::CColSphere

<pre>
plugin::CallMethodDynGlobal<CColSphere *>(ctor_gaddr(CColSphere), this);</pre>

#### CColSphere::Set

<pre>
plugin::CallMethodDynGlobal<CColSphere *, float, CVector &, unsigned char, unsigned char>(gaddrof(CColSphere::Set), this, radius, center, material, flag);
0AA6: call_method 0x411E40 struct [CColSphere] num_params 4 pop 0 [radius] [center] [material] [flag]
</pre>

### plugin_III\game_III\CColTriangle.cpp

#### CColTriangle::Set

<pre>
plugin::CallMethodDynGlobal<CColTriangle *, CompressedVector const *, int, int, int, unsigned char, unsigned char>(gaddrof(CColTriangle::Set), this, verts, vertA, vertB, vertC, material, flag);
0AA6: call_method 0x411E70 struct [CColTriangle] num_params 6 pop 0 [verts] [vertA] [vertB] [vertC] [material] [flag]
</pre>

### plugin_III\game_III\CColTrianglePlane.cpp

#### CColTrianglePlane::GetNormal

<pre>
plugin::CallMethodDynGlobal<CColTrianglePlane *, CVector &>(gaddrof(CColTrianglePlane::GetNormal), this, point);
0AA6: call_method 0x412140 struct [CColTrianglePlane] num_params 1 pop 0 [point]
</pre>

#### CColTrianglePlane::Set

<pre>
plugin::CallMethodDynGlobal<CColTrianglePlane *, CompressedVector const *, CColTriangle &>(gaddrof(CColTrianglePlane::Set), this, verts, tri);
0AA6: call_method 0x411EA0 struct [CColTrianglePlane] num_params 2 pop 0 [verts] [tri]
</pre>

### plugin_III\game_III\CControllerState.cpp

#### CControllerState::Clear

<pre>
plugin::CallMethod<0x4916C0, CControllerState *>(this);
0AA6: call_method 0x4916C0 struct [CControllerState] num_params 0 pop 0
</pre>

### plugin_III\game_III\CCopPed.cpp

#### CCopPed::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CCopPed *>(this);
</pre>

#### CCopPed::ArrestPlayer

<pre>
plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ArrestPlayer), this);
0AA6: call_method 0x4C2C90 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::ClearPursuit

<pre>
plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ClearPursuit), this);
0AA6: call_method 0x4C28C0 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::CopAI

<pre>
plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::CopAI), this);
0AA6: call_method 0x4C1B50 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::ScanForCrimes

<pre>
plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ScanForCrimes), this);
0AA6: call_method 0x4C26A0 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::SetArrestPlayer

<pre>
plugin::CallMethodDynGlobal<CCopPed *, CPed *>(gaddrof(CCopPed::SetArrestPlayer), this, player);
0AA6: call_method 0x4C2B00 struct [CCopPed] num_params 1 pop 0 [player]
</pre>

#### CCopPed::SetPursuit

<pre>
plugin::CallMethodDynGlobal<CCopPed *, bool>(gaddrof(CCopPed::SetPursuit), this, ignoreCopLimit);
0AA6: call_method 0x4C27D0 struct [CCopPed] num_params 1 pop 0 [ignoreCopLimit]
</pre>

### plugin_III\game_III\CCoronas.cpp

#### CCoronas::RegisterCorona

<pre>
plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof_o(CCoronas::RegisterCorona, void (*)(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float)), id, red, green, blue, alpha, coors, size, drawDist, coronaType, flareType, reflection, LOScheck, drawStreak, someAngle);
</pre>

#### CCoronas::RegisterCorona

<pre>
plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, RwTexture *, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof_o(CCoronas::RegisterCorona, void (*)(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, RwTexture *, unsigned char, unsigned char, unsigned char, unsigned char, float)), id, red, green, blue, alpha, coors, size, drawDist, texture, flareType, reflection, LOScheck, drawStreak, someAngle);
</pre>

#### CCoronas::UpdateCoronaCoors

<pre>
plugin::CallDynGlobal<unsigned int, CVector const &, float, float>(gaddrof(CCoronas::UpdateCoronaCoors), id, coors, drawDist, someAngle);
</pre>

### plugin_III\game_III\CCrane.cpp

#### CCrane::CalcHookCoordinates

<pre>
plugin::CallMethodDynGlobal<CCrane *, float *, float *, float *>(gaddrof(CCrane::CalcHookCoordinates), this, pX, pY, pZ);
0AA6: call_method 0x544F80 struct [CCrane] num_params 3 pop 0 [pX] [pY] [pZ]
</pre>

#### CCrane::DoesCranePickUpThisCarType

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, unsigned int>(gaddrof(CCrane::DoesCranePickUpThisCarType), this, vehicleModelIndex);
0AA8: call_method_return 0x544A90 struct [CCrane] num_params 1 pop 0 [vehicleModelIndex] func_ret [bool]
</pre>

#### CCrane::FindCarInSectorList

<pre>
plugin::CallMethodDynGlobal<CCrane *, CPtrList *>(gaddrof(CCrane::FindCarInSectorList), this, list);
0AA6: call_method 0x544850 struct [CCrane] num_params 1 pop 0 [list]
</pre>

#### CCrane::FindParametersForTarget

<pre>
plugin::CallMethodDynGlobal<CCrane *, float, float, float, float *, float *, float *>(gaddrof(CCrane::FindParametersForTarget), this, x, y, z, pAngle, pDistance, pHeight);
0AA6: call_method 0x544EF0 struct [CCrane] num_params 6 pop 0 [x] [y] [z] [pAngle] [pDistance] [pHeight]
</pre>

#### CCrane::GoTowardsHeightTarget

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, float, float>(gaddrof(CCrane::GoTowardsHeightTarget), this, targetHeight, speedMultiplier);
0AA8: call_method_return 0x544E50 struct [CCrane] num_params 2 pop 0 [targetHeight] [speedMultiplier] func_ret [bool]
</pre>

#### CCrane::GoTowardsTarget

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, float, float, float, float>(gaddrof(CCrane::GoTowardsTarget), this, angleToTarget, distanceToTarget, targetHeight, speedMultiplier);
0AA8: call_method_return 0x544C00 struct [CCrane] num_params 4 pop 0 [angleToTarget] [distanceToTarget] [targetHeight] [speedMultiplier] func_ret [bool]
</pre>

#### CCrane::RotateCarriedCarProperly

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCrane *>(gaddrof(CCrane::RotateCarriedCarProperly), this);
0AA8: call_method_return 0x544700 struct [CCrane] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCrane::SetHookMatrix

<pre>
plugin::CallMethodDynGlobal<CCrane *>(gaddrof(CCrane::SetHookMatrix), this);
0AA6: call_method 0x545000 struct [CCrane] num_params 0 pop 0
</pre>

#### CCrane::Update

<pre>
plugin::CallMethodDynGlobal<CCrane *>(gaddrof(CCrane::Update), this);
0AA6: call_method 0x543AC0 struct [CCrane] num_params 0 pop 0
</pre>

### plugin_III\game_III\CCranes.cpp

#### CCranes::ActivateCrane

<pre>
plugin::CallDynGlobal<float, float, float, float, float, float, float, float, bool, bool, float, float>(gaddrof(CCranes::ActivateCrane), infX, supX, infY, supY, dropOffX, dropOffY, dropOffZ, heading, isCrusher, isMilitary, posX, posY);
</pre>

#### CCranes::AddThisOneCrane

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CCranes::AddThisOneCrane), entity);
</pre>

#### CCranes::DeActivateCrane

<pre>
plugin::CallDynGlobal<float, float>(gaddrof(CCranes::DeActivateCrane), x, y);
</pre>

#### CCranes::DoesMilitaryCraneHaveThisOneAlready

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CCranes::DoesMilitaryCraneHaveThisOneAlready), vehicleModelIndex);
</pre>

#### CCranes::HaveAllCarsBeenCollectedByMilitaryCrane

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CCranes::HaveAllCarsBeenCollectedByMilitaryCrane));
</pre>

#### CCranes::IsThisCarBeingCarriedByAnyCrane

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingCarriedByAnyCrane), vehicle);
</pre>

#### CCranes::IsThisCarBeingTargettedByAnyCrane

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingTargettedByAnyCrane), vehicle);
</pre>

#### CCranes::IsThisCarPickedUp

<pre>
plugin::CallAndReturnDynGlobal<bool, float, float, CVehicle *>(gaddrof(CCranes::IsThisCarPickedUp), x, y, vehicle);
</pre>

#### CCranes::RegisterCarForMilitaryCrane

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CCranes::RegisterCarForMilitaryCrane), vehicleModelIndex);
</pre>

#### CCranes::Save

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CCranes::Save), buf, size);
</pre>

#### CranesLoad

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CranesLoad), buf, size);
</pre>

### plugin_III\game_III\CCredits.cpp

#### CCredits::AreCreditsDone

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CCredits::AreCreditsDone));
</pre>

#### CCredits::PrintCreditSpace

<pre>
plugin::CallDynGlobal<float, unsigned int *>(gaddrof(CCredits::PrintCreditSpace), space, line);
</pre>

#### CCredits::PrintCreditText

<pre>
plugin::CallDynGlobal<float, float, wchar_t *, unsigned int *, float>(gaddrof(CCredits::PrintCreditText), scaleX, scaleY, text, lineOffset, scrollOffset);
</pre>

### plugin_III\game_III\CCurrentVehicle.cpp

#### CCurrentVehicle::Display

<pre>
plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Display), this);
0AA6: call_method 0x4AD630 struct [CCurrentVehicle] num_params 0 pop 0
</pre>

#### CCurrentVehicle::Init

<pre>
plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Init), this);
0AA6: call_method 0x4AD5F0 struct [CCurrentVehicle] num_params 0 pop 0
</pre>

#### CCurrentVehicle::Process

<pre>
plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Process), this);
0AA6: call_method 0x4AD600 struct [CCurrentVehicle] num_params 0 pop 0
</pre>

### plugin_III\game_III\CCurves.cpp

#### CCurves::CalcCurvePoint

<pre>
plugin::CallDynGlobal<CVector *, CVector *, CVector *, CVector *, float, int, CVector *, CVector *>(gaddrof(CCurves::CalcCurvePoint), pPos1, pPos2, pDir1, pDir2, between, timeOnCurve, pOutPos, pOutDir);
</pre>

#### CCurves::CalcSpeedScaleFactor

<pre>
plugin::CallAndReturnDynGlobal<float, CVector *, CVector *, float, float, float, float>(gaddrof(CCurves::CalcSpeedScaleFactor), pPoint1, pPoint2, dir1X, dir1Y, dir2X, dir2Y);
</pre>

### plugin_III\game_III\CCutsceneHead.cpp

#### CCutsceneHead::CreateRwObject

<pre>
plugin::CallVirtualMethod<5, CCutsceneHead *>(this);
</pre>

#### CCutsceneHead::DeleteRwObject

<pre>
plugin::CallVirtualMethod<6, CCutsceneHead *>(this);
</pre>

#### CCutsceneHead::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CCutsceneHead *>(this);
</pre>

#### CCutsceneHead::Render

<pre>
plugin::CallVirtualMethod<13, CCutsceneHead *>(this);
</pre>

#### CCutsceneHead::PlayAnimation

<pre>
plugin::CallMethodDynGlobal<CCutsceneHead *, char const *>(gaddrof(CCutsceneHead::PlayAnimation), this, name);
0AA6: call_method 0x4BA6A0 struct [CCutsceneHead] num_params 1 pop 0 [name]
</pre>

### plugin_III\game_III\CCutsceneMgr.cpp

#### CCutsceneMgr::AddCutsceneHead

<pre>
plugin::CallAndReturn<CCutsceneHead*, 0x404CD0, CObject*, int>(object, modelIndex);
0AA7: call_function_return 0x404CD0 num_params 2 pop 2 [object] [modelIndex] func_ret [CCutsceneHead*]
</pre>

#### CCutsceneMgr::CreateCutsceneObject

<pre>
plugin::CallAndReturn<CCutsceneObject*, 0x404BE0, int>(modelIndex);
0AA7: call_function_return 0x404BE0 num_params 1 pop 1 [modelIndex] func_ret [CCutsceneObject*]
</pre>

#### CCutsceneMgr::DeleteCutsceneData

<pre>
plugin::Call<0x4048E0>();
0AA5: call_function 0x4048E0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::FinishCutscene

<pre>
plugin::Call<0x405140>();
0AA5: call_function 0x405140 num_params 0 pop 0
</pre>

#### CCutsceneMgr::GetCutsceneTimeInMilleseconds

<pre>
plugin::CallAndReturn<int, 0x4051B0>();
0AA7: call_function_return 0x4051B0 num_params 0 pop 0 func_ret [int]
</pre>

#### CCutsceneMgr::HasCutsceneFinished

<pre>
plugin::CallAndReturn<bool, 0x4051F0>();
0AA7: call_function_return 0x4051F0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCutsceneMgr::Initialise

<pre>
plugin::Call<0x4045D0>();
0AA5: call_function 0x4045D0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::LoadCutsceneData

<pre>
plugin::Call<0x404650, char const*>(cutsceneName);
0AA5: call_function 0x404650 num_params 1 pop 1 [cutsceneName]
</pre>

#### CCutsceneMgr::SetCutsceneAnim

<pre>
plugin::Call<0x404D20, char const*, CObject*>(animName, object);
0AA5: call_function 0x404D20 num_params 2 pop 2 [animName] [object]
</pre>

#### CCutsceneMgr::SetHeadAnim

<pre>
plugin::Call<0x404D80, char const*, CObject*>(animName, object);
0AA5: call_function 0x404D80 num_params 2 pop 2 [animName] [object]
</pre>

#### CCutsceneMgr::SetupCutsceneToStart

<pre>
plugin::Call<0x404DC0>();
0AA5: call_function 0x404DC0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::Shutdown

<pre>
plugin::Call<0x404630>();
0AA5: call_function 0x404630 num_params 0 pop 0
</pre>

#### CCutsceneMgr::Update

<pre>
plugin::Call<0x404EE0>();
0AA5: call_function 0x404EE0 num_params 0 pop 0
</pre>

#### FindCutsceneAudioTrackId

<pre>
plugin::CallAndReturn<int, 0x404530, char const*>(cutsceneName);
0AA7: call_function_return 0x404530 num_params 1 pop 1 [cutsceneName] func_ret [int]
</pre>

### plugin_III\game_III\CCutsceneObject.cpp

#### CCutsceneObject::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CCutsceneObject *, unsigned int>(this, modelIndex);
</pre>

#### CCutsceneObject::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CCutsceneObject *>(this);
</pre>

#### CCutsceneObject::PreRender

<pre>
plugin::CallVirtualMethod<12, CCutsceneObject *>(this);
</pre>

#### CCutsceneObject::Render

<pre>
plugin::CallVirtualMethod<13, CCutsceneObject *>(this);
</pre>

#### CCutsceneObject::SetupLighting

<pre>
plugin::CallVirtualMethodAndReturn<bool, 14, CCutsceneObject *>(this);
</pre>

#### CCutsceneObject::RemoveLighting

<pre>
plugin::CallVirtualMethod<15, CCutsceneObject *, bool>(this, resetWorldColors);
</pre>

### plugin_III\game_III\CDamageManager.cpp

#### CDamageManager::ApplyDamage

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDamageManager *, tComponent, float, float>(gaddrof(CDamageManager::ApplyDamage), this, component, damage, unused);
0AA8: call_method_return 0x545A80 struct [CDamageManager] num_params 3 pop 0 [component] [damage] [unused] func_ret [bool]
</pre>

#### CDamageManager::FuckCarCompletely

<pre>
plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::FuckCarCompletely), this);
0AA6: call_method 0x545B70 struct [CDamageManager] num_params 0 pop 0
</pre>

#### CDamageManager::GetComponentGroup

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDamageManager *, tComponent, tComponentGroup *, unsigned char *>(gaddrof(CDamageManager::GetComponentGroup), this, component, group, subComp);
0AA8: call_method_return 0x545790 struct [CDamageManager] num_params 3 pop 0 [component] [group] [subComp] func_ret [bool]
</pre>

#### CDamageManager::GetDoorStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetDoorStatus), this, door);
0AA8: call_method_return 0x545930 struct [CDamageManager] num_params 1 pop 0 [door] func_ret [int]
</pre>

#### CDamageManager::GetEngineStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *>(gaddrof(CDamageManager::GetEngineStatus), this);
0AA8: call_method_return 0x545960 struct [CDamageManager] num_params 0 pop 0 func_ret [int]
</pre>

#### CDamageManager::GetLightStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, eLights>(gaddrof(CDamageManager::GetLightStatus), this, light);
0AA8: call_method_return 0x545890 struct [CDamageManager] num_params 1 pop 0 [light] func_ret [int]
</pre>

#### CDamageManager::GetPanelStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetPanelStatus), this, panel);
0AA8: call_method_return 0x5458E0 struct [CDamageManager] num_params 1 pop 0 [panel] func_ret [int]
</pre>

#### CDamageManager::GetWheelStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetWheelStatus), this, wheel);
0AA8: call_method_return 0x545910 struct [CDamageManager] num_params 1 pop 0 [wheel] func_ret [int]
</pre>

#### CDamageManager::ProgressDoorDamage

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressDoorDamage), this, door);
0AA6: call_method 0x545970 struct [CDamageManager] num_params 1 pop 0 [door]
</pre>

#### CDamageManager::ProgressEngineDamage

<pre>
plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::ProgressEngineDamage), this);
0AA6: call_method 0x5459B0 struct [CDamageManager] num_params 0 pop 0
</pre>

#### CDamageManager::ProgressPanelDamage

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressPanelDamage), this, panel);
0AA6: call_method 0x545A00 struct [CDamageManager] num_params 1 pop 0 [panel]
</pre>

#### CDamageManager::ProgressWheelDamage

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressWheelDamage), this, wheel);
0AA6: call_method 0x545A40 struct [CDamageManager] num_params 1 pop 0 [wheel]
</pre>

#### CDamageManager::ResetDamageStatus

<pre>
plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::ResetDamageStatus), this);
0AA6: call_method 0x545850 struct [CDamageManager] num_params 0 pop 0
</pre>

#### CDamageManager::SetDoorStatus

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetDoorStatus), this, door, status);
0AA6: call_method 0x545920 struct [CDamageManager] num_params 2 pop 0 [door] [status]
</pre>

#### CDamageManager::SetEngineStatus

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, unsigned int>(gaddrof(CDamageManager::SetEngineStatus), this, status);
0AA6: call_method 0x545940 struct [CDamageManager] num_params 1 pop 0 [status]
</pre>

#### CDamageManager::SetLightStatus

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, eLights, unsigned int>(gaddrof(CDamageManager::SetLightStatus), this, light, status);
0AA6: call_method 0x545860 struct [CDamageManager] num_params 2 pop 0 [light] [status]
</pre>

#### CDamageManager::SetPanelStatus

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetPanelStatus), this, panel, status);
0AA6: call_method 0x5458B0 struct [CDamageManager] num_params 2 pop 0 [panel] [status]
</pre>

#### CDamageManager::SetWheelStatus

<pre>
plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetWheelStatus), this, wheel, status);
0AA6: call_method 0x545900 struct [CDamageManager] num_params 2 pop 0 [wheel] [status]
</pre>

### plugin_III\game_III\CDarkel.cpp

#### CDarkel::CalcFade

<pre>
plugin::CallAndReturnDynGlobal<unsigned char, unsigned int, unsigned int, unsigned int>(gaddrof(CDarkel::CalcFade), time, min, max);
</pre>

#### CDarkel::FrenzyOnGoing

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CDarkel::FrenzyOnGoing));
</pre>

#### CDarkel::QueryModelsKilledByPlayer

<pre>
plugin::CallAndReturnDynGlobal<unsigned short, int>(gaddrof(CDarkel::QueryModelsKilledByPlayer), modelId);
</pre>

#### CDarkel::ReadStatus

<pre>
plugin::CallAndReturnDynGlobal<eDarkelStatus>(gaddrof(CDarkel::ReadStatus));
</pre>

#### CDarkel::RegisterCarBlownUpByPlayer

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CDarkel::RegisterCarBlownUpByPlayer), vehicle);
</pre>

#### CDarkel::RegisterKillByPlayer

<pre>
plugin::CallDynGlobal<CPed *, eWeaponType, bool>(gaddrof(CDarkel::RegisterKillByPlayer), ped, weaponType, headShot);
</pre>

#### CDarkel::RegisterKillNotByPlayer

<pre>
plugin::CallDynGlobal<CPed *, eWeaponType>(gaddrof(CDarkel::RegisterKillNotByPlayer), ped, weaponType);
</pre>

#### CDarkel::StartFrenzy

<pre>
plugin::CallDynGlobal<eWeaponType, int, unsigned short, int, wchar_t *, int, int, int, bool, bool>(gaddrof(CDarkel::StartFrenzy), weaponType, time, kill, model, text, model2, model3, model4, standardSound, headShot);
</pre>

### plugin_III\game_III\CDigitalClock.cpp

#### CDigitalClock::Init

<pre>
plugin::CallMethodDynGlobal<CDigitalClock *, CVector, float, float, unsigned char, unsigned char, unsigned char, float, float>(gaddrof(CDigitalClock::Init), this, pos, sizeX, sizeY, red, green, blue, drawDistance, scale);
0AA6: call_method 0x5004F0 struct [CDigitalClock] num_params 8 pop 0 [pos] [sizeX] [sizeY] [red] [green] [blue] [drawDistance] [scale]
</pre>

#### CDigitalClock::Render

<pre>
plugin::CallMethodDynGlobal<CDigitalClock *>(gaddrof(CDigitalClock::Render), this);
0AA6: call_method 0x5005F0 struct [CDigitalClock] num_params 0 pop 0
</pre>

#### CDigitalClock::Update

<pre>
plugin::CallMethodDynGlobal<CDigitalClock *>(gaddrof(CDigitalClock::Update), this);
0AA6: call_method 0x500550 struct [CDigitalClock] num_params 0 pop 0
</pre>

#### \*CDigitalClock::GetString

<pre>
plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CDigitalClock::GetString));
</pre>

### plugin_III\game_III\CDirectory.cpp

#### CDirectory::AddItem

<pre>
plugin::CallMethodDynGlobal<CDirectory *, CDirectory::DirectoryInfo const &>(gaddrof(CDirectory::AddItem), this, entry);
0AA6: call_method 0x473600 struct [CDirectory] num_params 1 pop 0 [entry]
</pre>

#### CDirectory::FindItem

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *, unsigned int &, unsigned int &>(gaddrof(CDirectory::FindItem), this, name, outOffset, outSize);
0AA8: call_method_return 0x4736E0 struct [CDirectory] num_params 3 pop 0 [name] [outOffset] [outSize] func_ret [bool]
</pre>

#### CDirectory::ReadDirFile

<pre>
plugin::CallMethodDynGlobal<CDirectory *, char const *>(gaddrof(CDirectory::ReadDirFile), this, fileName);
0AA6: call_method 0x473630 struct [CDirectory] num_params 1 pop 0 [fileName]
</pre>

#### CDirectory::WriteDirFile

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *>(gaddrof(CDirectory::WriteDirFile), this, fileName);
0AA8: call_method_return 0x473690 struct [CDirectory] num_params 1 pop 0 [fileName] func_ret [bool]
</pre>

### plugin_III\game_III\cDMAudio.cpp

#### cDMAudio::ChangeMusicMode

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::ChangeMusicMode), this, mode);
0AA6: call_method 0x57CCF0 struct [cDMAudio] num_params 1 pop 0 [mode]
</pre>

#### cDMAudio::CheckForAnAudioFileOnCD

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::CheckForAnAudioFileOnCD), this);
0AA8: call_method_return 0x57CA70 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]
</pre>

#### cDMAudio::ClearMissionAudio

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ClearMissionAudio), this);
0AA6: call_method 0x57CE20 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::CreateEntity

<pre>
plugin::CallMethodAndReturnDynGlobal<int, cDMAudio *, eAudioType, void *>(gaddrof(cDMAudio::CreateEntity), this, type, data);
0AA8: call_method_return 0x57C7C0 struct [cDMAudio] num_params 2 pop 0 [type] [data] func_ret [int]
</pre>

#### cDMAudio::CreateLoopingScriptObject

<pre>
plugin::CallMethodAndReturnDynGlobal<int, cDMAudio *, cAudioScriptObject *>(gaddrof(cDMAudio::CreateLoopingScriptObject), this, object);
0AA8: call_method_return 0x57CB00 struct [cDMAudio] num_params 1 pop 0 [object] func_ret [int]
</pre>

#### cDMAudio::CreateOneShotScriptObject

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, cAudioScriptObject *>(gaddrof(cDMAudio::CreateOneShotScriptObject), this, object);
0AA6: call_method 0x57CB60 struct [cDMAudio] num_params 1 pop 0 [object]
</pre>

#### cDMAudio::DestroyAllGameCreatedEntities

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::DestroyAllGameCreatedEntities), this);
0AA6: call_method 0x57C870 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::DestroyEntity

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::DestroyEntity), this, audioEntity);
0AA6: call_method 0x57C7F0 struct [cDMAudio] num_params 1 pop 0 [audioEntity]
</pre>

#### cDMAudio::DestroyLoopingScriptObject

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::DestroyLoopingScriptObject), this, audioEntity);
0AA6: call_method 0x57CB40 struct [cDMAudio] num_params 1 pop 0 [audioEntity]
</pre>

#### \*cDMAudio::Get3DProviderName

<pre>
plugin::CallMethodAndReturnDynGlobal<char *, cDMAudio *, unsigned char>(gaddrof(cDMAudio::Get3DProviderName), this, id);
0AA8: call_method_return 0x57C970 struct [*cDMAudio] num_params 1 pop 0 [id] func_ret [char *]
</pre>

#### cDMAudio::GetCDAudioDriveLetter

<pre>
plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *>(gaddrof(cDMAudio::GetCDAudioDriveLetter), this);
0AA8: call_method_return 0x57CA90 struct [cDMAudio] num_params 0 pop 0 func_ret [char]
</pre>

#### cDMAudio::GetCurrent3DProviderIndex

<pre>
plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *>(gaddrof(cDMAudio::GetCurrent3DProviderIndex), this);
0AA8: call_method_return 0x57C990 struct [cDMAudio] num_params 0 pop 0 func_ret [char]
</pre>

#### cDMAudio::GetMissionAudioLoadingStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetMissionAudioLoadingStatus), this);
0AA8: call_method_return 0x57CD90 struct [cDMAudio] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### cDMAudio::GetNum3DProvidersAvailable

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetNum3DProvidersAvailable), this);
0AA8: call_method_return 0x57C950 struct [cDMAudio] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### cDMAudio::GetRadioInCar

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetRadioInCar), this);
0AA8: call_method_return 0x57CE40 struct [cDMAudio] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### cDMAudio::Initialise

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Initialise), this);
0AA6: call_method 0x57C760 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::IsAudioInitialised

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsAudioInitialised), this);
0AA8: call_method_return 0x57CAB0 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]
</pre>

#### cDMAudio::IsMP3RadioChannelAvailable

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsMP3RadioChannelAvailable), this);
0AA8: call_method_return 0x57C9F0 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]
</pre>

#### cDMAudio::IsMissionAudioSampleFinished

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsMissionAudioSampleFinished), this);
0AA8: call_method_return 0x57CE00 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]
</pre>

#### cDMAudio::PlayFrontEndSound

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned short, unsigned int>(gaddrof(cDMAudio::PlayFrontEndSound), this, frontend, volume);
0AA6: call_method 0x57CC20 struct [cDMAudio] num_params 2 pop 0 [frontend] [volume]
</pre>

#### cDMAudio::PlayFrontEndTrack

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char, unsigned char>(gaddrof(cDMAudio::PlayFrontEndTrack), this, track, frontendFlag);
0AA6: call_method 0x57CC80 struct [cDMAudio] num_params 2 pop 0 [track] [frontendFlag]
</pre>

#### cDMAudio::PlayLoadedMissionAudio

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::PlayLoadedMissionAudio), this);
0AA6: call_method 0x57CDE0 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::PlayOneShot

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, int, unsigned short, float>(gaddrof(cDMAudio::PlayOneShot), this, audioEntity, oneShot, volume);
0AA6: call_method 0x57C840 struct [cDMAudio] num_params 3 pop 0 [audioEntity] [oneShot] [volume]
</pre>

#### cDMAudio::PlayPreloadedCutSceneMusic

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::PlayPreloadedCutSceneMusic), this);
0AA6: call_method 0x57CD30 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::PlayRadioAnnouncement

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::PlayRadioAnnouncement), this, announcement);
0AA6: call_method 0x57CC60 struct [cDMAudio] num_params 1 pop 0 [announcement]
</pre>

#### cDMAudio::PlaySuspectLastSeen

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, float, float, float>(gaddrof(cDMAudio::PlaySuspectLastSeen), this, x, y, z);
0AA6: call_method 0x57CBB0 struct [cDMAudio] num_params 3 pop 0 [x] [y] [z]
</pre>

#### cDMAudio::PreloadCutSceneMusic

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::PreloadCutSceneMusic), this, track);
0AA6: call_method 0x57CD10 struct [cDMAudio] num_params 1 pop 0 [track]
</pre>

#### cDMAudio::PreloadMissionAudio

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, char *>(gaddrof(cDMAudio::PreloadMissionAudio), this, name);
0AA6: call_method 0x57CD70 struct [cDMAudio] num_params 1 pop 0 [name]
</pre>

#### cDMAudio::ReacquireDigitalHandle

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ReacquireDigitalHandle), this);
0AA6: call_method 0x57CA30 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::ReleaseDigitalHandle

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ReleaseDigitalHandle), this);
0AA6: call_method 0x57CA10 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::ReportCollision

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, CEntity *, CEntity *, unsigned char, unsigned char, float, float>(gaddrof(cDMAudio::ReportCollision), this, entityA, entityB, surfaceTypeA, surfaceTypeB, collisionPower, velocity);
0AA6: call_method 0x57CBE0 struct [cDMAudio] num_params 6 pop 0 [entityA] [entityB] [surfaceTypeA] [surfaceTypeB] [collisionPower] [velocity]
</pre>

#### cDMAudio::ReportCrime

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, eCrimeType, CVector const &>(gaddrof(cDMAudio::ReportCrime), this, crime, pos);
0AA6: call_method 0x57CAD0 struct [cDMAudio] num_params 2 pop 0 [crime] [pos]
</pre>

#### cDMAudio::ResetTimers

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned int>(gaddrof(cDMAudio::ResetTimers), this, time);
0AA6: call_method 0x57CCD0 struct [cDMAudio] num_params 1 pop 0 [time]
</pre>

#### cDMAudio::Service

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Service), this);
0AA6: call_method 0x57C7A0 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::SetCurrent3DProvider

<pre>
plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetCurrent3DProvider), this, which);
0AA8: call_method_return 0x57C9B0 struct [cDMAudio] num_params 1 pop 0 [which] func_ret [char]
</pre>

#### cDMAudio::SetDynamicAcousticModelingStatus

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetDynamicAcousticModelingStatus), this, status);
0AA6: call_method 0x57CA50 struct [cDMAudio] num_params 1 pop 0 [status]
</pre>

#### cDMAudio::SetEffectsFadeVol

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetEffectsFadeVol), this, volume);
0AA6: call_method 0x57C8F0 struct [cDMAudio] num_params 1 pop 0 [volume]
</pre>

#### cDMAudio::SetEffectsMasterVolume

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetEffectsMasterVolume), this, volume);
0AA6: call_method 0x57C890 struct [cDMAudio] num_params 1 pop 0 [volume]
</pre>

#### cDMAudio::SetEntityStatus

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, int, unsigned char>(gaddrof(cDMAudio::SetEntityStatus), this, audioEntity, status);
0AA6: call_method 0x57C810 struct [cDMAudio] num_params 2 pop 0 [audioEntity] [status]
</pre>

#### cDMAudio::SetMissionAudioLocation

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, float, float, float>(gaddrof(cDMAudio::SetMissionAudioLocation), this, x, y, z);
0AA6: call_method 0x57CDB0 struct [cDMAudio] num_params 3 pop 0 [x] [y] [z]
</pre>

#### cDMAudio::SetMusicFadeVol

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetMusicFadeVol), this, volume);
0AA6: call_method 0x57C920 struct [cDMAudio] num_params 1 pop 0 [volume]
</pre>

#### cDMAudio::SetMusicMasterVolume

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetMusicMasterVolume), this, volume);
0AA6: call_method 0x57C8C0 struct [cDMAudio] num_params 1 pop 0 [volume]
</pre>

#### cDMAudio::SetRadioChannel

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned char, int>(gaddrof(cDMAudio::SetRadioChannel), this, radio, pos);
0AA6: call_method 0x57CE80 struct [cDMAudio] num_params 2 pop 0 [radio] [pos]
</pre>

#### cDMAudio::SetRadioInCar

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, unsigned int>(gaddrof(cDMAudio::SetRadioInCar), this, radio);
0AA6: call_method 0x57CE60 struct [cDMAudio] num_params 1 pop 0 [radio]
</pre>

#### cDMAudio::SetSpeakerConfig

<pre>
plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::SetSpeakerConfig), this, config);
0AA6: call_method 0x57C9D0 struct [cDMAudio] num_params 1 pop 0 [config]
</pre>

#### cDMAudio::StopCutSceneMusic

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::StopCutSceneMusic), this);
0AA6: call_method 0x57CD50 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::StopFrontEndTrack

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::StopFrontEndTrack), this);
0AA6: call_method 0x57CCB0 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::Terminate

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Terminate), this);
0AA6: call_method 0x57C780 struct [cDMAudio] num_params 0 pop 0
</pre>

### plugin_III\game_III\CDoor.cpp

#### CDoor::CDoor

<pre>
plugin::CallMethod<0x52D150, CDoor *>(this);
0AA6: call_method 0x52D150 struct [CDoor] num_params 0 pop 0
</pre>

#### CDoor::GetAngleOpenRatio

<pre>
plugin::CallMethodAndReturn<float, 0x545F80, CDoor *>(this);
0AA8: call_method_return 0x545F80 struct [CDoor] num_params 0 pop 0 func_ret [float]
</pre>

#### CDoor::IsClosed

<pre>
plugin::CallMethodAndReturn<bool, 0x546060, CDoor *>(this);
0AA8: call_method_return 0x546060 struct [CDoor] num_params 0 pop 0 func_ret [bool]
</pre>

#### CDoor::IsFullyOpen

<pre>
plugin::CallMethodAndReturn<bool, 0x546090, CDoor *>(this);
0AA8: call_method_return 0x546090 struct [CDoor] num_params 0 pop 0 func_ret [bool]
</pre>

#### CDoor::Open

<pre>
plugin::CallMethod<0x545EF0, CDoor *, float>(this, angle);
0AA6: call_method 0x545EF0 struct [CDoor] num_params 1 pop 0 [angle]
</pre>

#### CDoor::Process

<pre>
plugin::CallMethod<0x545BD0, CDoor *, CVehicle*>(this, vehicle);
0AA6: call_method 0x545BD0 struct [CDoor] num_params 1 pop 0 [vehicle]
</pre>

#### CDoor::RetAngleWhenClosed

<pre>
plugin::CallMethodAndReturn<float, 0x545FE0, CDoor *>(this);
0AA8: call_method_return 0x545FE0 struct [CDoor] num_params 0 pop 0 func_ret [float]
</pre>

#### CDoor::RetAngleWhenOpen

<pre>
plugin::CallMethodAndReturn<float, 0x546020, CDoor *>(this);
0AA8: call_method_return 0x546020 struct [CDoor] num_params 0 pop 0 func_ret [float]
</pre>

### plugin_III\game_III\CDraw.cpp

#### CDraw::SetFOV

<pre>
plugin::CallDynGlobal<float>(gaddrof(CDraw::SetFOV), fovValue);
</pre>

### plugin_III\game_III\CDummy.cpp

#### CDummy::Add

<pre>
plugin::CallVirtualMethod<1, CDummy *>(this);
</pre>

#### CDummy::Remove

<pre>
plugin::CallVirtualMethod<2, CDummy *>(this);
</pre>

### plugin_III\game_III\CEmergencyPed.cpp

#### CEmergencyPed::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CEmergencyPed *>(this);
</pre>

#### CEmergencyPed::FiremanAI

<pre>
plugin::CallMethodDynGlobal<CEmergencyPed *>(gaddrof(CEmergencyPed::FiremanAI), this);
0AA6: call_method 0x4C3CE0 struct [CEmergencyPed] num_params 0 pop 0
</pre>

#### CEmergencyPed::InRange

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEmergencyPed *, CPed *>(gaddrof(CEmergencyPed::InRange), this, victim);
0AA8: call_method_return 0x4C3EC0 struct [CEmergencyPed] num_params 1 pop 0 [victim] func_ret [bool]
</pre>

#### CEmergencyPed::MedicAI

<pre>
plugin::CallMethodDynGlobal<CEmergencyPed *>(gaddrof(CEmergencyPed::MedicAI), this);
0AA6: call_method 0x4C30A0 struct [CEmergencyPed] num_params 0 pop 0
</pre>

### plugin_III\game_III\CEntity.cpp

#### CEntity::Add

<pre>
plugin::CallVirtualMethod<1, CEntity *>(this);
</pre>

#### CEntity::Remove

<pre>
plugin::CallVirtualMethod<2, CEntity *>(this);
</pre>

#### CEntity::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CEntity *, unsigned int>(this, modelIndex);
</pre>

#### CEntity::SetModelIndexNoCreate

<pre>
plugin::CallVirtualMethod<4, CEntity *, unsigned int>(this, modelIndex);
</pre>

#### CEntity::CreateRwObject

<pre>
plugin::CallVirtualMethod<5, CEntity *>(this);
</pre>

#### CEntity::DeleteRwObject

<pre>
plugin::CallVirtualMethod<6, CEntity *>(this);
</pre>

#### \*CEntity::GetBoundRect

<pre>
plugin::CallVirtualMethodAndReturn<CRect *, 7, CEntity *>(this);
</pre>

#### CEntity::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CEntity *>(this);
</pre>

#### CEntity::ProcessCollision

<pre>
plugin::CallVirtualMethod<9, CEntity *>(this);
</pre>

#### CEntity::ProcessShift

<pre>
plugin::CallVirtualMethod<10, CEntity *>(this);
</pre>

#### CEntity::Teleport

<pre>
plugin::CallVirtualMethod<11, CEntity *, CVector>(this, point);
</pre>

#### CEntity::PreRender

<pre>
plugin::CallVirtualMethod<12, CEntity *>(this);
</pre>

#### CEntity::Render

<pre>
plugin::CallVirtualMethod<13, CEntity *>(this);
</pre>

#### CEntity::SetupLighting

<pre>
plugin::CallVirtualMethodAndReturn<bool, 14, CEntity *>(this);
</pre>

#### CEntity::RemoveLighting

<pre>
plugin::CallVirtualMethod<15, CEntity *, bool>(this, resetWorldColors);
</pre>

#### CEntity::FlagToDestroyWhenNextProcessed

<pre>
plugin::CallVirtualMethod<16, CEntity *>(this);
</pre>

#### CEntity::AddSteamsFromGround

<pre>
plugin::CallMethodDynGlobal<CEntity *, CVector *>(gaddrof(CEntity::AddSteamsFromGround), this, unused);
0AA6: call_method 0x50CE40 struct [CEntity] num_params 1 pop 0 [unused]
</pre>

#### CEntity::AttachToRwObject

<pre>
plugin::CallMethodDynGlobal<CEntity *, RwObject *>(gaddrof(CEntity::AttachToRwObject), this, rwObject);
0AA6: call_method 0x473F10 struct [CEntity] num_params 1 pop 0 [rwObject]
</pre>

#### CEntity::DetachFromRwObject

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::DetachFromRwObject), this);
0AA6: call_method 0x473F60 struct [CEntity] num_params 0 pop 0
</pre>

#### \*CEntity::GetBoundCentre

<pre>
plugin::CallMethodAndReturnDynGlobal<CVector *, CEntity *>(gaddrof_o(CEntity::GetBoundCentre, CVector *(CEntity::*)()), this);
0AA8: call_method_return 0x4742C0 struct [*CEntity] num_params 0 pop 0 func_ret [CVector *]
</pre>

#### CEntity::GetBoundCentre

<pre>
plugin::CallMethodDynGlobal<CEntity *, CVector &>(gaddrof_o(CEntity::GetBoundCentre, void (CEntity::*)(CVector &)), this, out);
0AA6: call_method 0x4742C0 struct [CEntity] num_params 1 pop 0 [out]
</pre>

#### CEntity::GetBoundRadius

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CEntity *>(gaddrof(CEntity::GetBoundRadius), this);
0AA8: call_method_return 0x474310 struct [CEntity] num_params 0 pop 0 func_ret [float]
</pre>

#### CEntity::GetDistanceFromCentreOfMassToBaseOfModel

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CEntity *>(gaddrof(CEntity::GetDistanceFromCentreOfMassToBaseOfModel), this);
0AA8: call_method_return 0x4755C0 struct [CEntity] num_params 0 pop 0 func_ret [float]
</pre>

#### CEntity::GetIsOnScreen

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::GetIsOnScreen), this);
0AA8: call_method_return 0x474CC0 struct [CEntity] num_params 0 pop 0 func_ret [bool]
</pre>

#### CEntity::GetIsOnScreenComplex

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::GetIsOnScreenComplex), this);
0AA8: call_method_return 0x474D20 struct [CEntity] num_params 0 pop 0 func_ret [bool]
</pre>

#### CEntity::GetIsTouching

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntity *, CVector const &, float>(gaddrof(CEntity::GetIsTouching), this, posn, radius);
0AA8: call_method_return 0x474C10 struct [CEntity] num_params 2 pop 0 [posn] [radius] func_ret [bool]
</pre>

#### CEntity::IsVisible

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::IsVisible), this);
0AA8: call_method_return 0x474CA0 struct [CEntity] num_params 0 pop 0 func_ret [bool]
</pre>

#### CEntity::ModifyMatrixForBannerInWind

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ModifyMatrixForBannerInWind), this);
0AA6: call_method 0x475830 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::ModifyMatrixForTreeInWind

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ModifyMatrixForTreeInWind), this);
0AA6: call_method 0x475670 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::PreRenderForGlassWindow

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::PreRenderForGlassWindow), this);
0AA6: call_method 0x475A20 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::ProcessLightsForEntity

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ProcessLightsForEntity), this);
0AA6: call_method 0x4FA530 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::PruneReferences

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::PruneReferences), this);
0AA6: call_method 0x4A7530 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::RegisterReference

<pre>
plugin::CallMethodDynGlobal<CEntity *, CEntity **>(gaddrof(CEntity::RegisterReference), this, entity);
0AA6: call_method 0x4A7480 struct [CEntity] num_params 1 pop 0 [entity]
</pre>

#### CEntity::ResolveReferences

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ResolveReferences), this);
0AA6: call_method 0x4A74E0 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::SetState

<pre>
plugin::CallMethodDynGlobal<CEntity *, unsigned char>(gaddrof(CEntity::SetState), this, state);
0AA6: call_method 0x54A8A0 struct [CEntity] num_params 1 pop 0 [state]
</pre>

#### CEntity::SetupBigBuilding

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::SetupBigBuilding), this);
0AA6: call_method 0x4755E0 struct [CEntity] num_params 0 pop 0
</pre>

#### CEntity::UpdateRwFrame

<pre>
plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::UpdateRwFrame), this);
0AA6: call_method 0x474330 struct [CEntity] num_params 0 pop 0
</pre>

### plugin_III\game_III\CEventList.cpp

#### CEventList::ClearEvent

<pre>
plugin::CallDynGlobal<int>(gaddrof(CEventList::ClearEvent), event);
</pre>

#### CEventList::FindClosestEvent

<pre>
plugin::CallAndReturnDynGlobal<bool, eEventType, CVector, int *>(gaddrof(CEventList::FindClosestEvent), type, pos, event);
</pre>

#### CEventList::GetEvent

<pre>
plugin::CallAndReturnDynGlobal<bool, eEventType, int *>(gaddrof(CEventList::GetEvent), type, event);
</pre>

#### CEventList::RegisterEvent

<pre>
plugin::CallDynGlobal<eEventType, eEventEntity, CEntity *, CPed *, int>(gaddrof_o(CEventList::RegisterEvent, void (*)(eEventType, eEventEntity, CEntity *, CPed *, int)), type, entityType, entity, criminal, time);
</pre>

#### CEventList::RegisterEvent

<pre>
plugin::CallDynGlobal<eEventType, CVector, int>(gaddrof_o(CEventList::RegisterEvent, void (*)(eEventType, CVector, int)), type, pos, time);
</pre>

#### CEventList::ReportCrimeForEvent

<pre>
plugin::CallDynGlobal<eEventType, int, bool>(gaddrof(CEventList::ReportCrimeForEvent), type, crimeId, bPoliceDontReallyCare);
</pre>

### plugin_III\game_III\CExplosion.cpp

#### CExplosion::AddExplosion

<pre>
plugin::CallAndReturn<bool, 0x5591C0, CEntity*, CEntity*, eExplosionType, CVector const&, unsigned int>(victim, creator, explosionType, posn, time);
0AA7: call_function_return 0x5591C0 num_params 5 pop 5 [victim] [creator] [explosionType] [posn] [time] func_ret [bool]
</pre>

#### CExplosion::CExplosion

<pre>
plugin::CallMethod<0x55ADE0, CExplosion *>(this);
0AA6: call_method 0x55ADE0 struct [CExplosion] num_params 0 pop 0
</pre>

#### CExplosion::GetExplosionActiveCounter

<pre>
plugin::CallAndReturn<unsigned char, 0x559140, unsigned char>(index);
0AA7: call_function_return 0x559140 num_params 1 pop 1 [index] func_ret [unsigned char]
</pre>

#### CExplosion::GetExplosionPosition

<pre>
plugin::CallAndReturn<CVector*, 0x5591A0, unsigned char>(index);
0AA7: call_function_return 0x5591A0 num_params 1 pop 1 [index] func_ret [CVector*]
</pre>

#### CExplosion::Initialise

<pre>
plugin::Call<0x559030>();
0AA5: call_function 0x559030 num_params 0 pop 0
</pre>

#### CExplosion::RemoveAllExplosionsInArea

<pre>
plugin::Call<0x55AD40, CVector, float>(posn, radius);
0AA5: call_function 0x55AD40 num_params 2 pop 2 [posn] [radius]
</pre>

#### CExplosion::ResetExplosionActiveCounter

<pre>
plugin::Call<0x559160, unsigned char>(index);
0AA5: call_function 0x559160 num_params 1 pop 1 [index]
</pre>

#### CExplosion::Shutdown

<pre>
plugin::Call<0x559100>();
0AA5: call_function 0x559100 num_params 0 pop 0
</pre>

#### CExplosion::TestForExplosionInArea

<pre>
plugin::CallAndReturn<bool, 0x55AC80, eExplosionType, float, float, float, float, float, float>(explosionType, x1, y1, z1, x2, y2, z2);
0AA7: call_function_return 0x55AC80 num_params 7 pop 7 [explosionType] [x1] [y1] [z1] [x2] [y2] [z2] func_ret [bool]
</pre>

#### CExplosion::Update

<pre>
plugin::Call<0x55A0C0>();
0AA5: call_function 0x55A0C0 num_params 0 pop 0
</pre>

### plugin_III\game_III\CFallingGlassPane.cpp

#### CFallingGlassPane::Render

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(gaddrof(CFallingGlassPane::Render), this);
0AA6: call_method 0x5024C0 struct [CFallingGlassPane] num_params 0 pop 0
</pre>

#### CFallingGlassPane::Update

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(gaddrof(CFallingGlassPane::Update), this);
0AA6: call_method 0x502080 struct [CFallingGlassPane] num_params 0 pop 0
</pre>

### plugin_III\game_III\CFileLoader.cpp

#### CFileLoader::LoadLine

<pre>
plugin::CallAndReturn<char*, 0x4761D0, int>(fileHandle);
0AA7: call_function_return 0x4761D0 num_params 1 pop 1 [fileHandle] func_ret [char*]
</pre>

#### GetFilename

<pre>
plugin::CallAndReturn<char*, 0x476230, char const*>(filepath);
0AA7: call_function_return 0x476230 num_params 1 pop 1 [filepath] func_ret [char*]
</pre>

#### LoadingScreenLoadingFile

<pre>
plugin::Call<0x476250, char const*>(filepath);
0AA5: call_function 0x476250 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::LoadLevel

<pre>
plugin::Call<0x476290, char const*>(datFilePath);
0AA5: call_function 0x476290 num_params 1 pop 1 [datFilePath]
</pre>

#### CFileLoader::LoadCollisionFromDatFile

<pre>
plugin::Call<0x476520, unsigned int>(gameLevel);
0AA5: call_function 0x476520 num_params 1 pop 1 [gameLevel]
</pre>

#### CFileLoader::LoadTexDictionary

<pre>
plugin::CallAndReturn<RwTexDictionary *, 0x4765B0, char const*>(filepath);
0AA7: call_function_return 0x4765B0 num_params 1 pop 1 [filepath] func_ret [RwTexDictionary *]
</pre>

#### MoveTexturesCB

<pre>
plugin::CallAndReturn<RwTexture*, 0x476610, RwTexture*, void*>(texture, data);
0AA7: call_function_return 0x476610 num_params 2 pop 2 [texture] [data] func_ret [RwTexture*]
</pre>

#### CFileLoader::AddTexDictionaries

<pre>
plugin::Call<0x476630, RwTexDictionary*, RwTexDictionary*>(dst, src);
0AA5: call_function 0x476630 num_params 2 pop 2 [dst] [src]
</pre>

#### GetNameAndLOD

<pre>
plugin::Call<0x476650, char*, char*, unsigned int *>(nodeName, outName, outLodIndex);
0AA5: call_function 0x476650 num_params 3 pop 3 [nodeName] [outName] [outLodIndex]
</pre>

#### CFileLoader::FindRelatedModelInfoCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x4766C0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x4766C0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CFileLoader::LoadAtomicFile

<pre>
plugin::Call<0x476750, char const*>(filepath);
0AA5: call_function 0x476750 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::LoadAtomicFile2Return

<pre>
plugin::CallAndReturn<RpClump*, 0x4767C0, char const*>(filepath);
0AA7: call_function_return 0x4767C0 num_params 1 pop 1 [filepath] func_ret [RpClump*]
</pre>

#### CFileLoader::LoadClumpFile

<pre>
plugin::Call<0x476810, char const*>(filepath);
0AA5: call_function 0x476810 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::SetRelatedModelInfoCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x4768C0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x4768C0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CFileLoader::LoadAtomicFile

<pre>
plugin::CallAndReturn<bool, 0x476930, RwStream*, unsigned int>(stream, modelIndex);
0AA7: call_function_return 0x476930 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]
</pre>

#### CFileLoader::LoadClumpFile

<pre>
plugin::CallAndReturn<bool, 0x476990, RwStream*, unsigned int>(stream, modelIndex);
0AA7: call_function_return 0x476990 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]
</pre>

#### CFileLoader::StartLoadClumpFile

<pre>
plugin::CallAndReturn<bool, 0x476A20, RwStream*, unsigned int>(stream, modelIndex);
0AA7: call_function_return 0x476A20 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]
</pre>

#### CFileLoader::FinishLoadClumpFile

<pre>
plugin::CallAndReturn<bool, 0x476A70, RwStream*, unsigned int>(stream, modelIndex);
0AA7: call_function_return 0x476A70 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]
</pre>

#### CFileLoader::LoadObjectTypes

<pre>
plugin::Call<0x476AC0, char const*>(filepath);
0AA5: call_function 0x476AC0 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::ReloadPaths

<pre>
plugin::Call<0x476DB0, char const*>(filepath);
0AA5: call_function 0x476DB0 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::ReloadObjectTypes

<pre>
plugin::Call<0x476F30, char const*>(filepath);
0AA5: call_function 0x476F30 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::LoadObject

<pre>
plugin::Call<0x477040, char const*>(line);
0AA5: call_function 0x477040 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::ReloadObject

<pre>
plugin::Call<0x4772B0, char const*>(line);
0AA5: call_function 0x4772B0 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadTimeObject

<pre>
plugin::Call<0x4774B0, char const*>(line);
0AA5: call_function 0x4774B0 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadMLO

<pre>
plugin::Call<0x477750, char const*>(line);
0AA5: call_function 0x477750 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadMLOInstance

<pre>
plugin::Call<0x4777C0, int, char const*>(modelIndex, line);
0AA5: call_function 0x4777C0 num_params 2 pop 2 [modelIndex] [line]
</pre>

#### CFileLoader::LoadClumpObject

<pre>
plugin::Call<0x477920, char const*>(line);
0AA5: call_function 0x477920 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadVehicleObject

<pre>
plugin::Call<0x477990, char const*>(line);
0AA5: call_function 0x477990 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadPedObject

<pre>
plugin::Call<0x477DE0, char const*>(line);
0AA5: call_function 0x477DE0 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadPathHeader

<pre>
plugin::CallAndReturn<int, 0x477ED0, char const*, char*>(line, outPathType);
0AA7: call_function_return 0x477ED0 num_params 2 pop 2 [line] [outPathType] func_ret [int]
</pre>

#### CFileLoader::LoadPedPathNode

<pre>
plugin::Call<0x477F00, char const*, int, int>(line, id, index);
0AA5: call_function 0x477F00 num_params 3 pop 3 [line] [id] [index]
</pre>

#### CFileLoader::LoadCarPathNode

<pre>
plugin::Call<0x477FF0, char const*, int, int>(line, id, index);
0AA5: call_function 0x477FF0 num_params 3 pop 3 [line] [id] [index]
</pre>

#### CFileLoader::Load2dEffect

<pre>
plugin::Call<0x4780E0, char const*>(line);
0AA5: call_function 0x4780E0 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadScene

<pre>
plugin::Call<0x478370, char const*>(filepath);
0AA5: call_function 0x478370 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::LoadMapZones

<pre>
plugin::Call<0x478550, char const*>(filepath);
0AA5: call_function 0x478550 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::LoadObjectInstance

<pre>
plugin::Call<0x4786B0, char const*>(line);
0AA5: call_function 0x4786B0 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadPickup

<pre>
plugin::Call<0x4789C0, char const*>(line);
0AA5: call_function 0x4789C0 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadZone

<pre>
plugin::Call<0x478A00, char const*>(line);
0AA5: call_function 0x478A00 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadCullZone

<pre>
plugin::Call<0x478A90, char const*>(line);
0AA5: call_function 0x478A90 num_params 1 pop 1 [line]
</pre>

#### CFileLoader::LoadCollisionFile

<pre>
plugin::Call<0x478B20, char*>(filepath);
0AA5: call_function 0x478B20 num_params 1 pop 1 [filepath]
</pre>

#### CFileLoader::LoadCollisionModel

<pre>
plugin::Call<0x478C20, unsigned char*, CColModel&, char*>(buffer, outColModel, name);
0AA5: call_function 0x478C20 num_params 3 pop 3 [buffer] [outColModel] [name]
</pre>

### plugin_III\game_III\CFileMgr.cpp

#### CFileMgr::ChangeDir

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileMgr::ChangeDir), dir);
</pre>

#### CFileMgr::CloseFile

<pre>
plugin::CallAndReturnDynGlobal<int, FILESTREAM>(gaddrof(CFileMgr::CloseFile), fileHandle);
</pre>

#### CFileMgr::GetErrorReadWrite

<pre>
plugin::CallAndReturnDynGlobal<int, FILESTREAM>(gaddrof(CFileMgr::GetErrorReadWrite), fileHandle);
</pre>

#### CFileMgr::LoadTextFile

<pre>
plugin::CallAndReturnDynGlobal<FILESTREAM, char const *, unsigned char *, int, char const *>(gaddrof(CFileMgr::LoadTextFile), filePath, buf, size, mode);
</pre>

#### CFileMgr::OpenFile

<pre>
plugin::CallAndReturnDynGlobal<FILESTREAM, char const *, char const *>(gaddrof(CFileMgr::OpenFile), filePath, mode);
</pre>

#### CFileMgr::OpenFileForWriting

<pre>
plugin::CallAndReturnDynGlobal<FILESTREAM, char const *>(gaddrof(CFileMgr::OpenFileForWriting), filePath);
</pre>

#### CFileMgr::Read

<pre>
plugin::CallAndReturnDynGlobal<int, FILESTREAM, char *, int>(gaddrof(CFileMgr::Read), fileHandle, buf, size);
</pre>

#### CFileMgr::ReadLine

<pre>
plugin::CallAndReturnDynGlobal<bool, FILESTREAM, char *, int>(gaddrof(CFileMgr::ReadLine), fileHandle, buf, len);
</pre>

#### CFileMgr::Seek

<pre>
plugin::CallAndReturnDynGlobal<bool, FILESTREAM, int, int>(gaddrof(CFileMgr::Seek), fileHandle, offset, origin);
</pre>

#### CFileMgr::SetDir

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileMgr::SetDir), dir);
</pre>

#### CFileMgr::Write

<pre>
plugin::CallAndReturnDynGlobal<int, FILESTREAM, char *, int>(gaddrof(CFileMgr::Write), fileHandle, buf, size);
</pre>

### plugin_III\game_III\CFire.cpp

#### CFire::Extinguish

<pre>
plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::Extinguish), this);
0AA6: call_method 0x479D40 struct [CFire] num_params 0 pop 0
</pre>

#### CFire::ProcessFire

<pre>
plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::ProcessFire), this);
0AA6: call_method 0x4798D0 struct [CFire] num_params 0 pop 0
</pre>

#### CFire::ReportThisFire

<pre>
plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::ReportThisFire), this);
0AA6: call_method 0x4798B0 struct [CFire] num_params 0 pop 0
</pre>

### plugin_III\game_III\CFireManager.cpp

#### CFireManager::ExtinguishPoint

<pre>
plugin::CallMethodDynGlobal<CFireManager *, CVector, float>(gaddrof(CFireManager::ExtinguishPoint), this, point, range);
0AA6: call_method 0x479DB0 struct [CFireManager] num_params 2 pop 0 [point] [range]
</pre>

#### \*CFireManager::FindFurthestFire_NeverMindFireMen

<pre>
plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *, CVector, float, float>(gaddrof(CFireManager::FindFurthestFire_NeverMindFireMen), this, pos, minRange, maxRange);
0AA8: call_method_return 0x479430 struct [*CFireManager] num_params 3 pop 0 [pos] [minRange] [maxRange] func_ret [CFire *]
</pre>

#### \*CFireManager::FindNearestFire

<pre>
plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *, CVector, float *>(gaddrof(CFireManager::FindNearestFire), this, pos, pDistance);
0AA8: call_method_return 0x479340 struct [*CFireManager] num_params 2 pop 0 [pos] [pDistance] func_ret [CFire *]
</pre>

#### \*CFireManager::GetNextFreeFire

<pre>
plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *>(gaddrof(CFireManager::GetNextFreeFire), this);
0AA8: call_method_return 0x4792E0 struct [*CFireManager] num_params 0 pop 0 func_ret [CFire *]
</pre>

#### CFireManager::IsScriptFireExtinguished

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CFireManager *, short>(gaddrof(CFireManager::IsScriptFireExtinguished), this, fireIndex);
0AA8: call_method_return 0x479FC0 struct [CFireManager] num_params 1 pop 0 [fireIndex] func_ret [bool]
</pre>

#### CFireManager::RemoveAllScriptFires

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(gaddrof(CFireManager::RemoveAllScriptFires), this);
0AA6: call_method 0x47A000 struct [CFireManager] num_params 0 pop 0
</pre>

#### CFireManager::RemoveScriptFire

<pre>
plugin::CallMethodDynGlobal<CFireManager *, short>(gaddrof(CFireManager::RemoveScriptFire), this, fireIndex);
0AA6: call_method 0x479FE0 struct [CFireManager] num_params 1 pop 0 [fireIndex]
</pre>

#### CFireManager::SetScriptFireAudio

<pre>
plugin::CallMethodDynGlobal<CFireManager *, short, bool>(gaddrof(CFireManager::SetScriptFireAudio), this, fireIndex, state);
0AA6: call_method 0x47A040 struct [CFireManager] num_params 2 pop 0 [fireIndex] [state]
</pre>

#### CFireManager::StartFire

<pre>
plugin::CallMethodDynGlobal<CFireManager *, CVector, float, unsigned char>(gaddrof_o(CFireManager::StartFire, void (CFireManager::*)(CVector, float, unsigned char)), this, pos, strength, propagation);
0AA6: call_method 0x479590 struct [CFireManager] num_params 3 pop 0 [pos] [strength] [propagation]
</pre>

#### CFireManager::StartFire

<pre>
plugin::CallMethodDynGlobal<CFireManager *, CEntity *, CEntity *, float, unsigned char>(gaddrof_o(CFireManager::StartFire, void (CFireManager::*)(CEntity *, CEntity *, float, unsigned char)), this, entityOnFire, fleeFrom, strength, propagation);
0AA6: call_method 0x479590 struct [CFireManager] num_params 4 pop 0 [entityOnFire] [fleeFrom] [strength] [propagation]
</pre>

#### CFireManager::StartScriptFire

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CFireManager *, CVector const &, CEntity *, float, unsigned char>(gaddrof(CFireManager::StartScriptFire), this, pos, target, strength, propagation);
0AA8: call_method_return 0x479E60 struct [CFireManager] num_params 4 pop 0 [pos] [target] [strength] [propagation] func_ret [int]
</pre>

#### CFireManager::Update

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(gaddrof(CFireManager::Update), this);
0AA6: call_method 0x479310 struct [CFireManager] num_params 0 pop 0
</pre>

### plugin_III\game_III\CFont.cpp

#### CFont::DrawFonts

<pre>
plugin::Call<0x501B50>();
0AA5: call_function 0x501B50 num_params 0 pop 0
</pre>

#### CFont::GetNextSpace

<pre>
plugin::CallAndReturn<wchar_t*, 0x501960, const wchar_t*>(str);
0AA7: call_function_return 0x501960 num_params 1 pop 1 [str] func_ret [wchar_t*]
</pre>

#### CFont::GetNumberLines

<pre>
plugin::CallAndReturn<int, 0x501260, float, float, const wchar_t*>(x, y, text);
0AA7: call_function_return 0x501260 num_params 3 pop 3 [x] [y] [text] func_ret [int]
</pre>

#### CFont::GetStringWidth

<pre>
plugin::CallAndReturn<float, 0x5018A0, const wchar_t*, bool>(str, sentence);
0AA7: call_function_return 0x5018A0 num_params 2 pop 2 [str] [sentence] func_ret [float]
</pre>

#### CFont::GetTextRect

<pre>
plugin::CallAndReturn<CRect*, 0x5013B0, CRect*, float, float, const wchar_t*>(rect_out, x, y, text);
0AA7: call_function_return 0x5013B0 num_params 4 pop 4 [rect_out] [x] [y] [text] func_ret [CRect*]
</pre>

#### CFont::InitPerFrame

<pre>
plugin::Call<0x500BE0>();
0AA5: call_function 0x500BE0 num_params 0 pop 0
</pre>

#### CFont::Initialise

<pre>
plugin::Call<0x500A40>();
0AA5: call_function 0x500A40 num_params 0 pop 0
</pre>

#### CFont::ParseToken

<pre>
plugin::CallAndReturn<wchar_t*, 0x5019A0, wchar_t*>(str);
0AA7: call_function_return 0x5019A0 num_params 1 pop 1 [str] func_ret [wchar_t*]
</pre>

#### CFont::PrintChar

<pre>
plugin::Call<0x500C30, float, float, short>(x, y, character);
0AA5: call_function 0x500C30 num_params 3 pop 3 [x] [y] [character]
</pre>

#### CFont::PrintString

<pre>
plugin::Call<0x500F50, float, float, const wchar_t*>(x, y, text);
0AA5: call_function 0x500F50 num_params 3 pop 3 [x] [y] [text]
</pre>

#### CFont::PrintString

<pre>
plugin::Call<0x501730, float, float, const wchar_t*, const wchar_t*, float>(x, y, start, end, arg4);
0AA5: call_function 0x501730 num_params 5 pop 5 [x] [y] [start] [end] [arg4]
</pre>

#### CFont::SetAlphaFade

<pre>
plugin::Call<0x501DD0, float>(alpha);
0AA5: call_function 0x501DD0 num_params 1 pop 1 [alpha]
</pre>

#### CFont::SetBackGroundOnlyTextOff

<pre>
plugin::Call<0x501D40>();
0AA5: call_function 0x501D40 num_params 0 pop 0
</pre>

#### CFont::SetBackGroundOnlyTextOn

<pre>
plugin::Call<0x501D30>();
0AA5: call_function 0x501D30 num_params 0 pop 0
</pre>

#### CFont::SetBackgroundColor

<pre>
plugin::Call<0x501D00, CRGBA*>(&color);
0AA5: call_function 0x501D00 num_params 1 pop 1 [&color]
</pre>

#### CFont::SetBackgroundOff

<pre>
plugin::Call<0x501CF0>();
0AA5: call_function 0x501CF0 num_params 0 pop 0
</pre>

#### CFont::SetBackgroundOn

<pre>
plugin::Call<0x501CE0>();
0AA5: call_function 0x501CE0 num_params 0 pop 0
</pre>

#### CFont::SetCentreOff

<pre>
plugin::Call<0x501CB0>();
0AA5: call_function 0x501CB0 num_params 0 pop 0
</pre>

#### CFont::SetCentreOn

<pre>
plugin::Call<0x501C90>();
0AA5: call_function 0x501C90 num_params 0 pop 0
</pre>

#### CFont::SetCentreSize

<pre>
plugin::Call<0x501CD0, float>(size);
0AA5: call_function 0x501CD0 num_params 1 pop 1 [size]
</pre>

#### CFont::SetColor

<pre>
plugin::Call<0x501BD0, CRGBA*>(&color);
0AA5: call_function 0x501BD0 num_params 1 pop 1 [&color]
</pre>

#### CFont::SetDropColor

<pre>
plugin::Call<0x501DE0, CRGBA*>(&color);
0AA5: call_function 0x501DE0 num_params 1 pop 1 [&color]
</pre>

#### CFont::SetDropShadowPosition

<pre>
plugin::Call<0x501E70, short>(value);
0AA5: call_function 0x501E70 num_params 1 pop 1 [value]
</pre>

#### CFont::SetFontStyle

<pre>
plugin::Call<0x501DB0, short>(style);
0AA5: call_function 0x501DB0 num_params 1 pop 1 [style]
</pre>

#### CFont::SetJustifyOff

<pre>
plugin::Call<0x501C80>();
0AA5: call_function 0x501C80 num_params 0 pop 0
</pre>

#### CFont::SetJustifyOn

<pre>
plugin::Call<0x501C60>();
0AA5: call_function 0x501C60 num_params 0 pop 0
</pre>

#### CFont::SetPropOff

<pre>
plugin::Call<0x501D90>();
0AA5: call_function 0x501D90 num_params 0 pop 0
</pre>

#### CFont::SetPropOn

<pre>
plugin::Call<0x501DA0>();
0AA5: call_function 0x501DA0 num_params 0 pop 0
</pre>

#### CFont::SetRightJustifyOff

<pre>
plugin::Call<0x501D70>();
0AA5: call_function 0x501D70 num_params 0 pop 0
</pre>

#### CFont::SetRightJustifyOn

<pre>
plugin::Call<0x501D50>();
0AA5: call_function 0x501D50 num_params 0 pop 0
</pre>

#### CFont::SetRightJustifyWrap

<pre>
plugin::Call<0x501DC0, float>(value);
0AA5: call_function 0x501DC0 num_params 1 pop 1 [value]
</pre>

#### CFont::SetScale

<pre>
plugin::Call<0x501B80, float, float>(width, height);
0AA5: call_function 0x501B80 num_params 2 pop 2 [width] [height]
</pre>

#### CFont::SetSlant

<pre>
plugin::Call<0x501BC0, float>(value);
0AA5: call_function 0x501BC0 num_params 1 pop 1 [value]
</pre>

#### CFont::SetSlantRefPoint

<pre>
plugin::Call<0x501BA0, float, float>(x, y);
0AA5: call_function 0x501BA0 num_params 2 pop 2 [x] [y]
</pre>

#### CFont::SetWrapx

<pre>
plugin::Call<0x501CC0, float>(value);
0AA5: call_function 0x501CC0 num_params 1 pop 1 [value]
</pre>

#### CFont::Shutdown

<pre>
plugin::Call<0x500BA0>();
0AA5: call_function 0x500BA0 num_params 0 pop 0
</pre>

#### CFont::character_code

<pre>
plugin::CallAndReturn<short, 0x501E80, unsigned char>(character);
0AA7: call_function_return 0x501E80 num_params 1 pop 1 [character] func_ret [short]
</pre>

#### AsciiToUnicode

<pre>
plugin::Call<0x5009C0, char const*, wchar_t*>(str_ascii, str_unicode);
0AA5: call_function 0x5009C0 num_params 2 pop 2 [str_ascii] [str_unicode]
</pre>

#### UnicodeStrlen

<pre>
plugin::CallAndReturn<int, 0x500A20, wchar_t const*>(str);
0AA7: call_function_return 0x500A20 num_params 1 pop 1 [str] func_ret [int]
</pre>

### plugin_III\game_III\CFontDetails.cpp

#### CFontDetails::~CFontDetails

<pre>
plugin::CallMethod<0x501F10, CFontDetails *>(this);
0AA6: call_method 0x501F10 struct [CFontDetails] num_params 0 pop 0
</pre>

### plugin_III\game_III\CGame.cpp

#### CGame::DrasticTidyUpMemory

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CGame::DrasticTidyUpMemory), flushDraw);
</pre>

#### CGame::Initialise

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);
</pre>

#### CGame::InitialiseOnceAfterRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceAfterRW));
</pre>

#### CGame::InitialiseOnceBeforeRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));
</pre>

#### CGame::InitialiseRenderWare

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));
</pre>

#### CGame::Shutdown

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));
</pre>

#### CGame::TidyUpMemory

<pre>
plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), moveTextures, flushDraw);
</pre>

### plugin_III\game_III\CGameLogic.cpp

#### CGameLogic::PassTime

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CGameLogic::PassTime), time);
</pre>

#### CGameLogic::RestorePlayerStuffDuringResurrection

<pre>
plugin::CallDynGlobal<CPlayerPed *, CVector, float>(gaddrof(CGameLogic::RestorePlayerStuffDuringResurrection), player, pos, angle);
</pre>

#### CGameLogic::SortOutStreamingAndMemory

<pre>
plugin::CallDynGlobal<CVector const &>(gaddrof(CGameLogic::SortOutStreamingAndMemory), pos);
</pre>

### plugin_III\game_III\CGangs.cpp

#### CGangs::GetGangPedModelOverride

<pre>
plugin::CallAndReturnDynGlobal<char, short>(gaddrof(CGangs::GetGangPedModelOverride), gang);
</pre>

#### CGangs::LoadAllGangData

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CGangs::LoadAllGangData), buf, size);
</pre>

#### CGangs::SaveAllGangData

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CGangs::SaveAllGangData), buf, size);
</pre>

#### CGangs::SetGangPedModelOverride

<pre>
plugin::CallDynGlobal<short, char>(gaddrof(CGangs::SetGangPedModelOverride), gang, ovrd);
</pre>

#### CGangs::SetGangVehicleModel

<pre>
plugin::CallDynGlobal<short, int>(gaddrof(CGangs::SetGangVehicleModel), gang, model);
</pre>

#### CGangs::SetGangWeapons

<pre>
plugin::CallDynGlobal<short, int, int>(gaddrof(CGangs::SetGangWeapons), gang, weaponOne, weaponTwo);
</pre>

### plugin_III\game_III\CGarage.cpp

#### CGarage::BuildRotatedDoorMatrix

<pre>
plugin::CallMethod<0x4267C0, CGarage *, CEntity*, float>(this, door, angle);
0AA6: call_method 0x4267C0 struct [CGarage] num_params 2 pop 0 [door] [angle]
</pre>

#### CGarage::CalcDistToGarageRectangleSquared

<pre>
plugin::CallMethodAndReturn<float, 0x426F50, CGarage *, float, float>(this, x, y);
0AA8: call_method_return 0x426F50 struct [CGarage] num_params 2 pop 0 [x] [y] func_ret [float]
</pre>

#### CGarage::CalcSmallestDistToGarageDoorSquared

<pre>
plugin::CallMethodAndReturn<float, 0x426FE0, CGarage *, float, float>(this, x, y);
0AA8: call_method_return 0x426FE0 struct [CGarage] num_params 2 pop 0 [x] [y] func_ret [float]
</pre>

#### CGarage::CenterCarInGarage

<pre>
plugin::CallMethodAndReturn<bool, 0x428000, CGarage *, CVehicle*>(this, vehicle);
0AA8: call_method_return 0x428000 struct [CGarage] num_params 1 pop 0 [vehicle] func_ret [bool]
</pre>

#### CGarage::CountCarsWithCenterPointWithinGarage

<pre>
plugin::CallMethodAndReturn<int, 0x426130, CGarage *, CEntity*>(this, vehicle);
0AA8: call_method_return 0x426130 struct [CGarage] num_params 1 pop 0 [vehicle] func_ret [int]
</pre>

#### CGarage::DoesCraigNeedThisCar

<pre>
plugin::CallMethodAndReturn<bool, 0x426D90, CGarage *, int>(this, modelIndex);
0AA8: call_method_return 0x426D90 struct [CGarage] num_params 1 pop 0 [modelIndex] func_ret [bool]
</pre>

#### CGarage::EntityHasASphereWayOutsideGarage

<pre>
plugin::CallMethodAndReturn<bool, 0x425B30, CGarage *, CEntity*, float>(this, entity, radius);
0AA8: call_method_return 0x425B30 struct [CGarage] num_params 2 pop 0 [entity] [radius] func_ret [bool]
</pre>

#### CGarage::FindDoorsEntities

<pre>
plugin::CallMethod<0x427060, CGarage *>(this);
0AA6: call_method 0x427060 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::FindDoorsEntitiesSectorList

<pre>
plugin::CallMethodAndReturn<char, 0x427300, CGarage *, CPtrList&, bool>(this, list, arg1);
0AA8: call_method_return 0x427300 struct [CGarage] num_params 2 pop 0 [list] [arg1] func_ret [char]
</pre>

#### CGarage::HasCraigCollectedThisCar

<pre>
plugin::CallMethodAndReturn<bool, 0x426DF0, CGarage *, int>(this, modelIndex);
0AA8: call_method_return 0x426DF0 struct [CGarage] num_params 1 pop 0 [modelIndex] func_ret [bool]
</pre>

#### CGarage::IsAnyCarBlockingDoor

<pre>
plugin::CallMethodAndReturn<bool, 0x425FB0, CGarage *>(this);
0AA8: call_method_return 0x425FB0 struct [CGarage] num_params 0 pop 0 func_ret [bool]
</pre>

#### CGarage::IsAnyOtherCarTouchingGarage

<pre>
plugin::CallMethodAndReturn<bool, 0x425C90, CGarage *, CVehicle*>(this, vehicle);
0AA8: call_method_return 0x425C90 struct [CGarage] num_params 1 pop 0 [vehicle] func_ret [bool]
</pre>

#### CGarage::IsAnyOtherPedTouchingGarage

<pre>
plugin::CallMethodAndReturn<bool, 0x425E20, CGarage *, CPed*>(this, ped);
0AA8: call_method_return 0x425E20 struct [CGarage] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CGarage::IsEntityEntirelyInside

<pre>
plugin::CallMethodAndReturn<bool, 0x425370, CGarage *, CEntity*>(this, entity);
0AA8: call_method_return 0x425370 struct [CGarage] num_params 1 pop 0 [entity] func_ret [bool]
</pre>

#### CGarage::IsEntityEntirelyInside3D

<pre>
plugin::CallMethodAndReturn<bool, 0x4254F0, CGarage *, CEntity*, float>(this, entity, radius);
0AA8: call_method_return 0x4254F0 struct [CGarage] num_params 2 pop 0 [entity] [radius] func_ret [bool]
</pre>

#### CGarage::IsEntityEntirelyOutside

<pre>
plugin::CallMethodAndReturn<bool, 0x425740, CGarage *, CEntity*, float>(this, entity, radius);
0AA8: call_method_return 0x425740 struct [CGarage] num_params 2 pop 0 [entity] [radius] func_ret [bool]
</pre>

#### CGarage::IsEntityTouching3D

<pre>
plugin::CallMethodAndReturn<bool, 0x425950, CGarage *, CEntity*>(this, entity);
0AA8: call_method_return 0x425950 struct [CGarage] num_params 1 pop 0 [entity] func_ret [bool]
</pre>

#### CGarage::IsGarageEmpty

<pre>
plugin::CallMethodAndReturn<bool, 0x425890, CGarage *>(this);
0AA8: call_method_return 0x425890 struct [CGarage] num_params 0 pop 0 func_ret [bool]
</pre>

#### CGarage::IsPlayerOutsideGarage

<pre>
plugin::CallMethodAndReturn<bool, 0x425910, CGarage *>(this);
0AA8: call_method_return 0x425910 struct [CGarage] num_params 0 pop 0 func_ret [bool]
</pre>

#### CGarage::IsStaticPlayerCarEntirelyInside

<pre>
plugin::CallMethodAndReturn<bool, 0x4251C0, CGarage *>(this);
0AA8: call_method_return 0x4251C0 struct [CGarage] num_params 0 pop 0 func_ret [bool]
</pre>

#### CGarage::Load

<pre>
plugin::CallMethod<0x4288E0, CGarage *, unsigned char*, unsigned int>(this, bufferPointer, structSize);
0AA6: call_method 0x4288E0 struct [CGarage] num_params 2 pop 0 [bufferPointer] [structSize]
</pre>

#### CGarage::MarkThisCarAsCollectedForCraig

<pre>
plugin::CallMethodAndReturn<bool, 0x426E50, CGarage *, int>(this, modelIndex);
0AA8: call_method_return 0x426E50 struct [CGarage] num_params 1 pop 0 [modelIndex] func_ret [bool]
</pre>

#### CGarage::PlayerArrestedOrDied

<pre>
plugin::CallMethod<0x427FC0, CGarage *>(this);
0AA6: call_method 0x427FC0 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::RefreshDoorPointers

<pre>
plugin::CallMethod<0x426980, CGarage *, bool>(this, arg0);
0AA6: call_method 0x426980 struct [CGarage] num_params 1 pop 0 [arg0]
</pre>

#### CGarage::RemoveCarsBlockingDoorNotInside

<pre>
plugin::CallMethod<0x4261F0, CGarage *>(this);
0AA6: call_method 0x4261F0 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::RestoreCarsForThisHideOut

<pre>
plugin::CallMethodAndReturn<bool, 0x427A40, CGarage *, CStoredCar*>(this, car);
0AA8: call_method_return 0x427A40 struct [CGarage] num_params 1 pop 0 [car] func_ret [bool]
</pre>

#### CGarage::StoreAndRemoveCarsForThisHideOut

<pre>
plugin::CallMethod<0x427840, CGarage *, CStoredCar*, int>(this, car, count);
0AA6: call_method 0x427840 struct [CGarage] num_params 2 pop 0 [car] [count]
</pre>

#### CGarage::TidyUpGarage

<pre>
plugin::CallMethod<0x427C30, CGarage *>(this);
0AA6: call_method 0x427C30 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::TidyUpGarageClose

<pre>
plugin::CallMethod<0x427D90, CGarage *>(this);
0AA6: call_method 0x427D90 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::Update

<pre>
plugin::CallMethod<0x4222D0, CGarage *>(this);
0AA6: call_method 0x4222D0 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::UpdateCrusherAngle

<pre>
plugin::CallMethod<0x4268A0, CGarage *>(this);
0AA6: call_method 0x4268A0 struct [CGarage] num_params 0 pop 0
</pre>

#### CGarage::UpdateCrusherShake

<pre>
plugin::CallMethod<0x4268E0, CGarage *, float, float>(this, x, y);
0AA6: call_method 0x4268E0 struct [CGarage] num_params 2 pop 0 [x] [y]
</pre>

#### CGarage::UpdateDoorsHeight

<pre>
plugin::CallMethod<0x426730, CGarage *>(this);
0AA6: call_method 0x426730 struct [CGarage] num_params 0 pop 0
</pre>

### plugin_III\game_III\CGarages.cpp

#### CGarages::ActivateGarage

<pre>
plugin::Call<0x426C60, short>(index);
0AA5: call_function 0x426C60 num_params 1 pop 1 [index]
</pre>

#### CGarages::AddOne

<pre>
plugin::CallAndReturn<int, 0x421FA0, CVector, CVector, unsigned char, unsigned int>(pointFront, pointBack, type, vehicleModelIndex);
0AA7: call_function_return 0x421FA0 num_params 4 pop 4 [pointFront] [pointBack] [type] [vehicleModelIndex] func_ret [int]
</pre>

#### CGarages::CameraShouldBeOutside

<pre>
plugin::CallAndReturn<bool, 0x427BC0>();
0AA7: call_function_return 0x427BC0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CGarages::ChangeGarageType

<pre>
plugin::Call<0x4222A0, short, unsigned char, unsigned int>(index, type, vehicleModelIndex);
0AA5: call_function 0x4222A0 num_params 3 pop 3 [index] [type] [vehicleModelIndex]
</pre>

#### CGarages::CloseHideOutGaragesBeforeSave

<pre>
plugin::Call<0x428130>();
0AA5: call_function 0x428130 num_params 0 pop 0
</pre>

#### CGarages::CountCarsInHideoutGarage

<pre>
plugin::CallAndReturn<int, 0x4281E0, unsigned char>(type);
0AA7: call_function_return 0x4281E0 num_params 1 pop 1 [type] func_ret [int]
</pre>

#### CGarages::DeActivateGarage

<pre>
plugin::Call<0x426C40, short>(index);
0AA5: call_function 0x426C40 num_params 1 pop 1 [index]
</pre>

#### CGarages::FindDoorHeightForMI

<pre>
plugin::CallAndReturn<float, 0x427C10, unsigned int>(vehicleModelIndex);
0AA7: call_function_return 0x427C10 num_params 1 pop 1 [vehicleModelIndex] func_ret [float]
</pre>

#### CGarages::FindMaxNumStoredCarsForGarage

<pre>
plugin::CallAndReturn<int, 0x428230, unsigned char>(type);
0AA7: call_function_return 0x428230 num_params 1 pop 1 [type] func_ret [int]
</pre>

#### CGarages::GivePlayerDetonator

<pre>
plugin::Call<0x427BD0>();
0AA5: call_function 0x427BD0 num_params 0 pop 0
</pre>

#### CGarages::HasCarBeenCrushed

<pre>
plugin::CallAndReturn<bool, 0x4275A0, int>(vehicleModelIndex);
0AA7: call_function_return 0x4275A0 num_params 1 pop 1 [vehicleModelIndex] func_ret [bool]
</pre>

#### CGarages::HasCarBeenDroppedOffYet

<pre>
plugin::CallAndReturn<bool, 0x426C20, short>(index);
0AA7: call_function_return 0x426C20 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CGarages::HasImportExportGarageCollectedThisCar

<pre>
plugin::CallAndReturn<bool, 0x426CB0, short, int>(index, vehicleModelIndex);
0AA7: call_function_return 0x426CB0 num_params 2 pop 2 [index] [vehicleModelIndex] func_ret [bool]
</pre>

#### CGarages::HasResprayHappened

<pre>
plugin::CallAndReturn<bool, 0x4274F0, short>(index);
0AA7: call_function_return 0x4274F0 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CGarages::HasThisCarBeenCollected

<pre>
plugin::CallAndReturn<bool, 0x426D50, short, int>(index, vehicleModelIndex);
0AA7: call_function_return 0x426D50 num_params 2 pop 2 [index] [vehicleModelIndex] func_ret [bool]
</pre>

#### CGarages::Init

<pre>
plugin::Call<0x421C60>();
0AA5: call_function 0x421C60 num_params 0 pop 0
</pre>

#### CGarages::IsCarSprayable

<pre>
plugin::CallAndReturn<bool, 0x426700, CAutomobile*>(car);
0AA7: call_function_return 0x426700 num_params 1 pop 1 [car] func_ret [bool]
</pre>

#### CGarages::IsGarageClosed

<pre>
plugin::CallAndReturn<bool, 0x426D20, short>(index);
0AA7: call_function_return 0x426D20 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CGarages::IsGarageOpen

<pre>
plugin::CallAndReturn<bool, 0x426CF0, short>(index);
0AA7: call_function_return 0x426CF0 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CGarages::IsModelIndexADoor

<pre>
plugin::CallAndReturn<bool, 0x428D90, unsigned int>(modelIndexDoor);
0AA7: call_function_return 0x428D90 num_params 1 pop 1 [modelIndexDoor] func_ret [bool]
</pre>

#### CGarages::IsPointInAGarageCameraZone

<pre>
plugin::CallAndReturn<bool, 0x427AB0, CVector>(point);
0AA7: call_function_return 0x427AB0 num_params 1 pop 1 [point] func_ret [bool]
</pre>

#### CGarages::IsPointWithinAnyGarage

<pre>
plugin::CallAndReturn<bool, 0x428320, CVector&>(point);
0AA7: call_function_return 0x428320 num_params 1 pop 1 [point] func_ret [bool]
</pre>

#### CGarages::IsPointWithinHideOutGarage

<pre>
plugin::CallAndReturn<bool, 0x428260, CVector&>(point);
0AA7: call_function_return 0x428260 num_params 1 pop 1 [point] func_ret [bool]
</pre>

#### CGarages::IsThisCarWithinGarageArea

<pre>
plugin::CallAndReturn<bool, 0x427570, short, CEntity*>(index, entity);
0AA7: call_function_return 0x427570 num_params 2 pop 2 [index] [entity] func_ret [bool]
</pre>

#### CGarages::Load

<pre>
plugin::Call<0x428940, unsigned char*, unsigned int>(bufferPointer, structSize);
0AA5: call_function 0x428940 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CGarages::PlayerArrestedOrDied

<pre>
plugin::Call<0x427F60>();
0AA5: call_function 0x427F60 num_params 0 pop 0
</pre>

#### CGarages::PrintMessages

<pre>
plugin::Call<0x426310>();
0AA5: call_function 0x426310 num_params 0 pop 0
</pre>

#### CGarages::QueryCarsCollected

<pre>
plugin::CallAndReturn<int, 0x426CA0, short>(index);
0AA7: call_function_return 0x426CA0 num_params 1 pop 1 [index] func_ret [int]
</pre>

#### CGarages::Save

<pre>
plugin::Call<0x4284E0, unsigned char*, unsigned int*>(bufferPointer, structSize);
0AA5: call_function 0x4284E0 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CGarages::SetAllDoorsBackToOriginalHeight

<pre>
plugin::Call<0x4283D0>();
0AA5: call_function 0x4283D0 num_params 0 pop 0
</pre>

#### CGarages::SetGarageDoorToRotate

<pre>
plugin::Call<0x427510, short>(index);
0AA5: call_function 0x427510 num_params 1 pop 1 [index]
</pre>

#### CGarages::SetLeaveCameraForThisGarage

<pre>
plugin::Call<0x427550, short>(index);
0AA5: call_function 0x427550 num_params 1 pop 1 [index]
</pre>

#### CGarages::SetTargetCarForMissionGarage

<pre>
plugin::Call<0x426BD0, short, CAutomobile*>(index, car);
0AA5: call_function 0x426BD0 num_params 2 pop 2 [index] [car]
</pre>

#### CGarages::Shutdown

<pre>
plugin::Call<0x421E10>();
0AA5: call_function 0x421E10 num_params 0 pop 0
</pre>

#### CGarages::TriggerMessage

<pre>
plugin::Call<0x426B20, char*, short, unsigned short, short>(text, numberInString, time, numberInString2);
0AA5: call_function 0x426B20 num_params 4 pop 4 [text] [numberInString] [time] [numberInString2]
</pre>

#### CGarages::Update

<pre>
plugin::Call<0x421E40>();
0AA5: call_function 0x421E40 num_params 0 pop 0
</pre>

### plugin_III\game_III\CGeneral.cpp

#### CGeneral::GetATanOfXY

<pre>
plugin::CallAndReturnDynGlobal<float, float, float>(gaddrof(CGeneral::GetATanOfXY), x, y);
</pre>

#### CGeneral::GetAngleBetweenPoints

<pre>
plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetAngleBetweenPoints), x1, y1, x2, y2);
</pre>

#### CGeneral::GetNodeHeadingFromVector

<pre>
plugin::CallAndReturnDynGlobal<int, float, float>(gaddrof(CGeneral::GetNodeHeadingFromVector), x, y);
</pre>

#### CGeneral::GetRadianAngleBetweenPoints

<pre>
plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetRadianAngleBetweenPoints), x1, y1, x2, y2);
</pre>

#### CGeneral::LimitAngle

<pre>
plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitAngle), angle);
</pre>

#### CGeneral::LimitRadianAngle

<pre>
plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitRadianAngle), angle);
</pre>

### plugin_III\game_III\CGlass.cpp

#### CGlass::AskForObjectToBeRenderedInGlass

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CGlass::AskForObjectToBeRenderedInGlass), entity);
</pre>

#### CGlass::CalcAlphaWithNormal

<pre>
plugin::CallAndReturnDynGlobal<int, CVector *>(gaddrof(CGlass::CalcAlphaWithNormal), normal);
</pre>

#### \*CGlass::FindFreePane

<pre>
plugin::CallAndReturnDynGlobal<CFallingGlassPane *>(gaddrof(CGlass::FindFreePane));
</pre>

#### CGlass::GeneratePanesForWindow

<pre>
plugin::CallDynGlobal<unsigned int, CVector, CVector, CVector, CVector, CVector, float, bool, bool>(gaddrof(CGlass::GeneratePanesForWindow), type, pos, at, right, speed, point, moveSpeed, cracked, explosion);
</pre>

#### CGlass::RenderEntityInGlass

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CGlass::RenderEntityInGlass), entity);
</pre>

#### CGlass::WasGlassHitByBullet

<pre>
plugin::CallDynGlobal<CEntity *, CVector>(gaddrof(CGlass::WasGlassHitByBullet), entity, point);
</pre>

#### CGlass::WindowRespondsToCollision

<pre>
plugin::CallDynGlobal<CEntity *, float, CVector, CVector, bool>(gaddrof(CGlass::WindowRespondsToCollision), entity, amount, speed, point, explosion);
</pre>

#### CGlass::WindowRespondsToExplosion

<pre>
plugin::CallDynGlobal<CEntity *, CVector>(gaddrof(CGlass::WindowRespondsToExplosion), entity, point);
</pre>

#### CGlass::WindowRespondsToSoftCollision

<pre>
plugin::CallDynGlobal<CEntity *, float>(gaddrof(CGlass::WindowRespondsToSoftCollision), entity, amount);
</pre>

### plugin_III\game_III\CHeli.cpp

#### CHeli::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CHeli *, unsigned int>(this, modelIndex);
</pre>

#### CHeli::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CHeli *>(this);
</pre>

#### CHeli::PreRender

<pre>
plugin::CallVirtualMethod<12, CHeli *>(this);
</pre>

#### CHeli::Render

<pre>
plugin::CallVirtualMethod<13, CHeli *>(this);
</pre>

#### CHeli::PreRenderAlways

<pre>
plugin::CallMethodDynGlobal<CHeli *>(gaddrof(CHeli::PreRenderAlways), this);
0AA6: call_method 0x5477F0 struct [CHeli] num_params 0 pop 0
</pre>

#### \*CHeli::SpawnFlyingComponent

<pre>
plugin::CallMethodAndReturnDynGlobal<CObject *, CHeli *, int>(gaddrof(CHeli::SpawnFlyingComponent), this, component);
0AA8: call_method_return 0x54AE50 struct [*CHeli] num_params 1 pop 0 [component] func_ret [CObject *]
</pre>

#### CHeli::ActivateHeli

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CHeli::ActivateHeli), activate);
</pre>

#### \*CHeli::FindPointerToCatalinasHeli

<pre>
plugin::CallAndReturnDynGlobal<CHeli *>(gaddrof(CHeli::FindPointerToCatalinasHeli));
</pre>

#### CHeli::HasCatalinaBeenShotDown

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CHeli::HasCatalinaBeenShotDown));
</pre>

#### CHeli::TestBulletCollision

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *, CVector *, CVector *, int>(gaddrof(CHeli::TestBulletCollision), lineStart, lineEnd, bulletPos, damage);
</pre>

#### CHeli::TestRocketCollision

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CHeli::TestRocketCollision), coors);
</pre>

#### \*GenerateHeli

<pre>
plugin::CallAndReturnDynGlobal<CHeli *, bool>(gaddrof(GenerateHeli), catalina);
</pre>

#### \*GetHeliAtomicObjectCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetHeliAtomicObjectCB), object, data);
</pre>

### plugin_III\game_III\CHud.cpp

#### CHud::Draw

<pre>
plugin::Call<0x5052A0>();
0AA5: call_function 0x5052A0 num_params 0 pop 0
</pre>

#### CHud::DrawAfterFade

<pre>
plugin::Call<0x509030>();
0AA5: call_function 0x509030 num_params 0 pop 0
</pre>

#### CHud::GetRidOfAllHudMessages

<pre>
plugin::Call<0x504F90>();
0AA5: call_function 0x504F90 num_params 0 pop 0
</pre>

#### CHud::Initialise

<pre>
plugin::Call<0x5048F0>();
0AA5: call_function 0x5048F0 num_params 0 pop 0
</pre>

#### CHud::ReInitialise

<pre>
plugin::Call<0x504CC0>();
0AA5: call_function 0x504CC0 num_params 0 pop 0
</pre>

#### CHud::SetBigMessage

<pre>
plugin::Call<0x50A250, wchar_t *, char>(message, style);
0AA5: call_function 0x50A250 num_params 2 pop 2 [message] [style]
</pre>

#### CHud::SetHelpMessage

<pre>
plugin::Call<0x5051E0, wchar_t *, bool>(message, quick);
0AA5: call_function 0x5051E0 num_params 2 pop 2 [message] [quick]
</pre>

#### CHud::SetMessage

<pre>
plugin::Call<0x50A210, wchar_t *>(message);
0AA5: call_function 0x50A210 num_params 1 pop 1 [message]
</pre>

#### CHud::SetPagerMessage

<pre>
plugin::Call<0x50A320, wchar_t *>(message);
0AA5: call_function 0x50A320 num_params 1 pop 1 [message]
</pre>

#### CHud::SetVehicleName

<pre>
plugin::Call<0x505290, wchar_t *>(name);
0AA5: call_function 0x505290 num_params 1 pop 1 [name]
</pre>

#### CHud::SetZoneName

<pre>
plugin::Call<0x5051D0, wchar_t *>(name);
0AA5: call_function 0x5051D0 num_params 1 pop 1 [name]
</pre>

#### CHud::Shutdown

<pre>
plugin::Call<0x504C50>();
0AA5: call_function 0x504C50 num_params 0 pop 0
</pre>

### plugin_III\game_III\CInstance.cpp

#### CInstance::Shutdown

<pre>
plugin::CallMethodDynGlobal<CInstance *>(gaddrof(CInstance::Shutdown), this);
0AA6: call_method 0x50B850 struct [CInstance] num_params 0 pop 0
</pre>

### plugin_III\game_III\CKeyboardState.cpp

#### CKeyboardState::Clear

<pre>
plugin::CallMethod<0x491760, CKeyboardState *>(this);
0AA6: call_method 0x491760 struct [CKeyboardState] num_params 0 pop 0
</pre>

### plugin_III\game_III\CLines.cpp

#### CLines::RenderLineWithClipping

<pre>
plugin::CallDynGlobal<float, float, float, float, float, float, unsigned int, unsigned int>(gaddrof(CLines::RenderLineWithClipping), x1, y1, z1, x2, y2, z2, color1, color2);
</pre>

### plugin_III\game_III\CMatrix.cpp

#### CMatrix::CMatrix

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(ctor_gaddr(CMatrix), this);</pre>

#### CMatrix::CMatrix

<pre>
plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(ctor_gaddr_o(CMatrix, void(RwMatrix *, bool)), this, rwMatrix, deleteOnDetach);</pre>

#### CMatrix::CMatrix

<pre>
plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(ctor_gaddr_o(CMatrix, void(CMatrix const &)), this, matrix);</pre>

#### CMatrix::~CMatrix

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(dtor_gaddr(CMatrix), this);</pre>

#### CMatrix::operator+=

<pre>
plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof_o(CMatrix::operator+=, void (CMatrix::*)(CMatrix const &)), this, right);
0AA6: call_method 0x4B8F90 struct [CMatrix] num_params 1 pop 0 [right]
</pre>

#### CMatrix::operator=

<pre>
plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof_o(CMatrix::operator=, void (CMatrix::*)(CMatrix const &)), this, right);
0AA6: call_method 0x4B8F40 struct [CMatrix] num_params 1 pop 0 [right]
</pre>

#### CMatrix::Attach

<pre>
plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(gaddrof(CMatrix::Attach), this, rwMatrix, deleteOnDetach);
0AA6: call_method 0x4B8DD0 struct [CMatrix] num_params 2 pop 0 [rwMatrix] [deleteOnDetach]
</pre>

#### CMatrix::AttachRW

<pre>
plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(gaddrof(CMatrix::AttachRW), this, rwMatrix, deleteOnDetach);
0AA6: call_method 0x4B8E00 struct [CMatrix] num_params 2 pop 0 [rwMatrix] [deleteOnDetach]
</pre>

#### CMatrix::CopyOnlyMatrix

<pre>
plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof(CMatrix::CopyOnlyMatrix), this, matrix);
0AA6: call_method 0x4B8F70 struct [CMatrix] num_params 1 pop 0 [matrix]
</pre>

#### CMatrix::Detach

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Detach), this);
0AA6: call_method 0x4B8E30 struct [CMatrix] num_params 0 pop 0
</pre>

#### CMatrix::Reorthogonalise

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Reorthogonalise), this);
0AA6: call_method 0x4B9A80 struct [CMatrix] num_params 0 pop 0
</pre>

#### CMatrix::ResetOrientation

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::ResetOrientation), this);
0AA6: call_method 0x4B9070 struct [CMatrix] num_params 0 pop 0
</pre>

#### CMatrix::Rotate

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::Rotate), this, x, y, z);
0AA6: call_method 0x4B9770 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]
</pre>

#### CMatrix::RotateX

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::RotateX), this, angle);
0AA6: call_method 0x4B9510 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::RotateZ

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::RotateZ), this, angle);
0AA6: call_method 0x4B9640 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetRotate

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::SetRotate), this, x, y, z);
0AA6: call_method 0x4B93A0 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]
</pre>

#### CMatrix::SetRotateX

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateX), this, angle);
0AA6: call_method 0x4B9310 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetRotateXOnly

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateXOnly), this, angle);
0AA6: call_method 0x4B9160 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetRotateY

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateY), this, angle);
0AA6: call_method 0x4B9340 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetRotateYOnly

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateYOnly), this, angle);
0AA6: call_method 0x4B91F0 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetRotateZ

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateZ), this, angle);
0AA6: call_method 0x4B9370 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetRotateZOnly

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateZOnly), this, angle);
0AA6: call_method 0x4B9280 struct [CMatrix] num_params 1 pop 0 [angle]
</pre>

#### CMatrix::SetScale

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetScale), this, factor);
0AA6: call_method 0x4B90B0 struct [CMatrix] num_params 1 pop 0 [factor]
</pre>

#### CMatrix::SetTranslate

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof_o(CMatrix::SetTranslate, void (CMatrix::*)(float, float, float)), this, x, y, z);
0AA6: call_method 0x54A8C0 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]
</pre>

#### CMatrix::SetTranslate

<pre>
plugin::CallMethodDynGlobal<CMatrix *, CVector *>(gaddrof_o(CMatrix::SetTranslate, void (CMatrix::*)(CVector *)), this, pos);
0AA6: call_method 0x54A8C0 struct [CMatrix] num_params 1 pop 0 [pos]
</pre>

#### CMatrix::SetTranslateOnly

<pre>
plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::SetTranslateOnly), this, x, y, z);
0AA6: call_method 0x4CBA70 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]
</pre>

#### CMatrix::SetUnity

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::SetUnity), this);
0AA6: call_method 0x4B9010 struct [CMatrix] num_params 0 pop 0
</pre>

#### CMatrix::Update

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Update), this);
0AA6: call_method 0x4B8E50 struct [CMatrix] num_params 0 pop 0
</pre>

#### CMatrix::UpdateRW

<pre>
plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::UpdateRW), this);
0AA6: call_method 0x4B8EC0 struct [CMatrix] num_params 0 pop 0
</pre>

### plugin_III\game_III\CMBlur.cpp

#### CMBlur::CreateImmediateModeData

<pre>
plugin::CallDynGlobal<RwCamera *, RwRect *>(gaddrof(CMBlur::CreateImmediateModeData), cam, rect);
</pre>

#### CMBlur::MotionBlurClose

<pre>
plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(CMBlur::MotionBlurClose));
</pre>

#### CMBlur::MotionBlurOpen

<pre>
plugin::CallAndReturnDynGlobal<RwBool, RwCamera *>(gaddrof(CMBlur::MotionBlurOpen), cam);
</pre>

#### CMBlur::MotionBlurRender

<pre>
plugin::CallDynGlobal<RwCamera *, unsigned int, unsigned int, unsigned int, unsigned int, int, unsigned int>(gaddrof(CMBlur::MotionBlurRender), cam, red, green, blue, blur, type, blurAlpha);
</pre>

#### CMBlur::OverlayRender

<pre>
plugin::CallDynGlobal<RwCamera *, RwRaster *, RwRGBA, int, int>(gaddrof(CMBlur::OverlayRender), cam, raster, color, type, blurAlpha);
</pre>

### plugin_III\game_III\CMenuManager.cpp

#### CMenuManager::BuildStatLine

<pre>
plugin::CallMethod<0x483870, CMenuManager *, char *, float *, bool, float*>(this, text, stat, aFloat, stat2);
0AA6: call_method 0x483870 struct [CMenuManager] num_params 4 pop 0 [text] [stat] [aFloat] [stat2]
</pre>

#### CMenuManager::CentreMousePointer

<pre>
plugin::Call<0x48ACE0>();
0AA5: call_function 0x48ACE0 num_params 0 pop 0
</pre>

#### CMenuManager::CheckCodesForControls

<pre>
plugin::CallMethodAndReturn<int, 0x483870, CMenuManager *, int>(this, type);
0AA8: call_method_return 0x483870 struct [CMenuManager] num_params 1 pop 0 [type] func_ret [int]
</pre>

#### CMenuManager::CheckHover

<pre>
plugin::CallMethodAndReturn<bool, 0x48ACA0, CMenuManager *, int, int, int, int>(this, x1, x2, y1, y2);
0AA8: call_method_return 0x48ACA0 struct [CMenuManager] num_params 4 pop 0 [x1] [x2] [y1] [y2] func_ret [bool]
</pre>

#### CMenuManager::CheckSliderMovement

<pre>
plugin::CallMethod<0x48B210, CMenuManager *, int>(this, direction);
0AA6: call_method 0x48B210 struct [CMenuManager] num_params 1 pop 0 [direction]
</pre>

#### CMenuManager::CostructStatLine

<pre>
plugin::CallMethodAndReturn<int, 0x482800, CMenuManager *, int>(this, line);
0AA8: call_method_return 0x482800 struct [CMenuManager] num_params 1 pop 0 [line] func_ret [int]
</pre>

#### CMenuManager::DisplayHelperText

<pre>
plugin::CallMethod<0x48B490, CMenuManager *>(this);
0AA6: call_method 0x48B490 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::DisplaySlider

<pre>
plugin::CallMethodAndReturn<float, 0x00, CMenuManager *>(this);
0AA8: call_method_return 0x00 struct [CMenuManager] num_params 0 pop 0 func_ret [float]
</pre>

#### CMenuManager::DoSettingsBeforeStartingAGame

<pre>
plugin::CallMethod<0x48AB40, CMenuManager *>(this);
0AA6: call_method 0x48AB40 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::Draw

<pre>
plugin::CallMethod<0x47AE00, CMenuManager *>(this);
0AA6: call_method 0x47AE00 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::DrawControllerBound

<pre>
plugin::CallMethod<0x489710, CMenuManager *, int, int, int, char>(this, arg0, arg1, arg2, arg3);
0AA6: call_method 0x489710 struct [CMenuManager] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CMenuManager::DrawControllerScreenExtraText

<pre>
plugin::CallMethod<0x4892F0, CMenuManager *, int, int, int>(this, arg0, arg1, arg2);
0AA6: call_method 0x4892F0 struct [CMenuManager] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CMenuManager::DrawControllerSetupScreen

<pre>
plugin::CallMethod<0x481210, CMenuManager *>(this);
0AA6: call_method 0x481210 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::DrawFrontEnd

<pre>
plugin::CallMethod<0x47A540, CMenuManager *>(this);
0AA6: call_method 0x47A540 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::DrawFrontEndNormal

<pre>
plugin::CallMethod<0x47A5B0, CMenuManager *>(this);
0AA6: call_method 0x47A5B0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::DrawPlayerSetupScreen

<pre>
plugin::CallMethod<0x47F2B0, CMenuManager *>(this);
0AA6: call_method 0x47F2B0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::FadeIn

<pre>
plugin::CallMethodAndReturn<int, 0x48AC60, CMenuManager *, int>(this, alpha);
0AA8: call_method_return 0x48AC60 struct [CMenuManager] num_params 1 pop 0 [alpha] func_ret [int]
</pre>

#### CMenuManager::FilterOutColorMarkersFromString

<pre>
plugin::CallMethod<0x4889C0, CMenuManager *, char, CRGBA &>(this, s, color);
0AA6: call_method 0x4889C0 struct [CMenuManager] num_params 2 pop 0 [s] [color]
</pre>

#### CMenuManager::GetStartOptionsCntrlConfigScreens

<pre>
plugin::CallMethodAndReturn<int, 0x489270, CMenuManager *>(this);
0AA8: call_method_return 0x489270 struct [CMenuManager] num_params 0 pop 0 func_ret [int]
</pre>

#### CMenuManager::InitialiseChangedLanguageSettings

<pre>
plugin::Call<0x47A4D0>();
0AA5: call_function 0x47A4D0 num_params 0 pop 0
</pre>

#### CMenuManager::LoadAllTextures

<pre>
plugin::CallMethod<0x47A230, CMenuManager *>(this);
0AA6: call_method 0x47A230 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::LoadSettings

<pre>
plugin::CallMethod<0x488EE0, CMenuManager *>(this);
0AA6: call_method 0x488EE0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::MessageScreen

<pre>
plugin::Call<0x48B7E0, char *>(message);
0AA5: call_function 0x48B7E0 num_params 1 pop 1 [message]
</pre>

#### CMenuManager::PickNewPlayerColour

<pre>
plugin::Call<0x488C40>();
0AA5: call_function 0x488C40 num_params 0 pop 0
</pre>

#### CMenuManager::PrintBriefs

<pre>
plugin::CallMethod<0x484D60, CMenuManager *>(this);
0AA6: call_method 0x484D60 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::PrintErrorMessage

<pre>
plugin::Call<0x484F70>();
0AA5: call_function 0x484F70 num_params 0 pop 0
</pre>

#### CMenuManager::PrintStats

<pre>
plugin::CallMethod<0x482100, CMenuManager *>(this);
0AA6: call_method 0x482100 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::Process

<pre>
plugin::CallMethod<0x485100, CMenuManager *>(this);
0AA6: call_method 0x485100 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::ProcessButtonPresses

<pre>
plugin::CallMethod<0x4856F0, CMenuManager *>(this);
0AA6: call_method 0x4856F0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::ProcessOnOffMenuOptions

<pre>
plugin::CallMethod<0x48AE60, CMenuManager *>(this);
0AA6: call_method 0x48AE60 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::RequestFrontEndShutDown

<pre>
plugin::Call<0x488750>();
0AA5: call_function 0x488750 num_params 0 pop 0
</pre>

#### CMenuManager::RequestFrontEndStartUp

<pre>
plugin::Call<0x488770>();
0AA5: call_function 0x488770 num_params 0 pop 0
</pre>

#### CMenuManager::ResetHelperText

<pre>
plugin::CallMethod<0x48B470, CMenuManager *>(this);
0AA6: call_method 0x48B470 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SaveLoadFileError_SetUpErrorScreen

<pre>
plugin::CallMethod<0x488930, CMenuManager *>(this);
0AA6: call_method 0x488930 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SaveSettings

<pre>
plugin::CallMethod<0x488CC0, CMenuManager *>(this);
0AA6: call_method 0x488CC0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SetHelperText

<pre>
plugin::CallMethod<0x48B450, CMenuManager *, int>(this, text);
0AA6: call_method 0x48B450 struct [CMenuManager] num_params 1 pop 0 [text]
</pre>

#### CMenuManager::ShutdownJustMenu

<pre>
plugin::CallMethod<0x488920, CMenuManager *>(this);
0AA6: call_method 0x488920 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::StretchX

<pre>
plugin::CallMethodAndReturn<float, 0x48ABE0, CMenuManager *, float>(this, x);
0AA8: call_method_return 0x48ABE0 struct [CMenuManager] num_params 1 pop 0 [x] func_ret [float]
</pre>

#### CMenuManager::StretchY

<pre>
plugin::CallMethodAndReturn<float, 0x48AC20, CMenuManager *, float>(this, y);
0AA8: call_method_return 0x48AC20 struct [CMenuManager] num_params 1 pop 0 [y] func_ret [float]
</pre>

#### CMenuManager::SwitchMenuOnAndOff

<pre>
plugin::CallMethod<0x488790, CMenuManager *>(this);
0AA6: call_method 0x488790 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::UnloadTextures

<pre>
plugin::CallMethod<0x47A440, CMenuManager *>(this);
0AA6: call_method 0x47A440 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::WaitForUserCD

<pre>
plugin::CallMethod<0x48ADD0, CMenuManager *>(this);
0AA6: call_method 0x48ADD0 struct [CMenuManager] num_params 0 pop 0
</pre>

### plugin_III\game_III\CMessages.cpp

#### CMessages::Init

<pre>
plugin::Call<0x529310>();
0AA5: call_function 0x529310 num_params 0 pop 0
</pre>

#### CMessages::GetWideStringLength

<pre>
plugin::CallAndReturn<int, 0x529490, wchar_t*>(str);
0AA7: call_function_return 0x529490 num_params 1 pop 1 [str] func_ret [int]
</pre>

#### CMessages::WideStringCopy

<pre>
plugin::CallAndReturn<int, 0x5294B0, wchar_t*, wchar_t*, unsigned short>(dst, src, size);
0AA7: call_function_return 0x5294B0 num_params 3 pop 3 [dst] [src] [size] func_ret [int]
</pre>

#### CMessages::WideStringCompare

<pre>
plugin::CallAndReturn<bool, 0x529510, wchar_t*, wchar_t*, unsigned short>(str1, str2, size);
0AA7: call_function_return 0x529510 num_params 3 pop 3 [str1] [str2] [size] func_ret [bool]
</pre>

#### CMessages::Process

<pre>
plugin::Call<0x529580>();
0AA5: call_function 0x529580 num_params 0 pop 0
</pre>

#### CMessages::Display

<pre>
plugin::Call<0x529800>();
0AA5: call_function 0x529800 num_params 0 pop 0
</pre>

#### CMessages::AddMessage

<pre>
plugin::Call<0x529900, wchar_t*, unsigned int, unsigned short>(text, time, flag);
0AA5: call_function 0x529900 num_params 3 pop 3 [text] [time] [flag]
</pre>

#### CMessages::AddMessageJumpQ

<pre>
plugin::Call<0x529A10, wchar_t*, unsigned int, unsigned short>(text, time, flag);
0AA5: call_function 0x529A10 num_params 3 pop 3 [text] [time] [flag]
</pre>

#### CMessages::AddMessageSoon

<pre>
plugin::Call<0x529AF0, wchar_t*, unsigned int, unsigned short>(text, time, flag);
0AA5: call_function 0x529AF0 num_params 3 pop 3 [text] [time] [flag]
</pre>

#### CMessages::ClearMessages

<pre>
plugin::Call<0x529CE0>();
0AA5: call_function 0x529CE0 num_params 0 pop 0
</pre>

#### CMessages::ClearSmallMessagesOnly

<pre>
plugin::Call<0x529E00>();
0AA5: call_function 0x529E00 num_params 0 pop 0
</pre>

#### CMessages::AddBigMessage

<pre>
plugin::Call<0x529EB0, wchar_t*, unsigned int, unsigned short>(text, time, flag);
0AA5: call_function 0x529EB0 num_params 3 pop 3 [text] [time] [flag]
</pre>

#### CMessages::AddBigMessageQ

<pre>
plugin::Call<0x529F60, wchar_t*, unsigned int, unsigned short>(text, time, flag);
0AA5: call_function 0x529F60 num_params 3 pop 3 [text] [time] [flag]
</pre>

#### CMessages::AddToPreviousBriefArray

<pre>
plugin::Call<0x52A040, wchar_t*, int, int, int, int, int, int, wchar_t*>(text, n1, n2, n3, n4, n5, n6, str);
0AA5: call_function 0x52A040 num_params 8 pop 8 [text] [n1] [n2] [n3] [n4] [n5] [n6] [str]
</pre>

#### CMessages::InsertNumberInString

<pre>
plugin::Call<0x52A1A0, wchar_t*, int, int, int, int, int, int, wchar_t*>(src, n1, n2, n3, n4, n5, n6, dst);
0AA5: call_function 0x52A1A0 num_params 8 pop 8 [src] [n1] [n2] [n3] [n4] [n5] [n6] [dst]
</pre>

#### CMessages::InsertStringInString

<pre>
plugin::Call<0x52A300, wchar_t*, wchar_t*>(text, str);
0AA5: call_function 0x52A300 num_params 2 pop 2 [text] [str]
</pre>

#### CMessages::InsertPlayerControlKeysInString

<pre>
plugin::Call<0x52A490, wchar_t*>(text);
0AA5: call_function 0x52A490 num_params 1 pop 1 [text]
</pre>

#### CMessages::AddMessageWithNumber

<pre>
plugin::Call<0x52A850, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
0AA5: call_function 0x52A850 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]
</pre>

#### CMessages::AddMessageJumpQWithNumber

<pre>
plugin::Call<0x52A9A0, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
0AA5: call_function 0x52A9A0 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]
</pre>

#### CMessages::AddMessageSoonWithNumber

<pre>
plugin::Call<0x52AAC0, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
0AA5: call_function 0x52AAC0 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]
</pre>

#### CMessages::AddBigMessageWithNumber

<pre>
plugin::Call<0x52AD10, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
0AA5: call_function 0x52AD10 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]
</pre>

#### CMessages::AddBigMessageWithNumberQ

<pre>
plugin::Call<0x52AE00, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);
0AA5: call_function 0x52AE00 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]
</pre>

#### CMessages::AddMessageWithString

<pre>
plugin::Call<0x52AF30, wchar_t*, unsigned int, unsigned short, wchar_t*>(text, time, flag, str);
0AA5: call_function 0x52AF30 num_params 4 pop 4 [text] [time] [flag] [str]
</pre>

#### CMessages::AddMessageJumpQWithString

<pre>
plugin::Call<0x52B050, wchar_t*, unsigned int, unsigned short, wchar_t*>(text, time, flag, str);
0AA5: call_function 0x52B050 num_params 4 pop 4 [text] [time] [flag] [str]
</pre>

#### CMessages::ClearThisPrint

<pre>
plugin::Call<0x52B140, wchar_t*>(text);
0AA5: call_function 0x52B140 num_params 1 pop 1 [text]
</pre>

#### CMessages::ClearThisBigPrint

<pre>
plugin::Call<0x52B3C0, wchar_t*>(text);
0AA5: call_function 0x52B3C0 num_params 1 pop 1 [text]
</pre>

#### CMessages::ClearAllMessagesDisplayedByGame

<pre>
plugin::Call<0x52B670>();
0AA5: call_function 0x52B670 num_params 0 pop 0
</pre>

### plugin_III\game_III\CMissionCleanup.cpp

#### CMissionCleanup::AddEntityToList

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *, int, unsigned char>(gaddrof(CMissionCleanup::AddEntityToList), this, id, type);
0AA6: call_method 0x437BA0 struct [CMissionCleanup] num_params 2 pop 0 [id] [type]
</pre>

#### \*CMissionCleanup::FindFree

<pre>
plugin::CallMethodAndReturnDynGlobal<tCleanupEntity *, CMissionCleanup *>(gaddrof(CMissionCleanup::FindFree), this);
0AA8: call_method_return 0x437B80 struct [*CMissionCleanup] num_params 0 pop 0 func_ret [tCleanupEntity *]
</pre>

#### CMissionCleanup::Init

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *>(gaddrof(CMissionCleanup::Init), this);
0AA6: call_method 0x437AE0 struct [CMissionCleanup] num_params 0 pop 0
</pre>

#### CMissionCleanup::Process

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *>(gaddrof(CMissionCleanup::Process), this);
0AA6: call_method 0x437C10 struct [CMissionCleanup] num_params 0 pop 0
</pre>

#### CMissionCleanup::RemoveEntityFromList

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *, int, unsigned char>(gaddrof(CMissionCleanup::RemoveEntityFromList), this, id, type);
0AA6: call_method 0x437BD0 struct [CMissionCleanup] num_params 2 pop 0 [id] [type]
</pre>

### plugin_III\game_III\CMloModelInfo.cpp

#### CMloModelInfo::ConstructClump

<pre>
plugin::CallMethodDynGlobal<CMloModelInfo *>(gaddrof(CMloModelInfo::ConstructClump), this);
0AA6: call_method 0x50B1A0 struct [CMloModelInfo] num_params 0 pop 0
</pre>

### plugin_III\game_III\CModelInfo.cpp

#### \*CModelInfo::AddClumpModel

<pre>
plugin::CallAndReturnDynGlobal<CClumpModelInfo *, int>(gaddrof(CModelInfo::AddClumpModel), index);
</pre>

#### \*CModelInfo::AddMloModel

<pre>
plugin::CallAndReturnDynGlobal<CMloModelInfo *, int>(gaddrof(CModelInfo::AddMloModel), index);
</pre>

#### \*CModelInfo::AddPedModel

<pre>
plugin::CallAndReturnDynGlobal<CPedModelInfo *, int>(gaddrof(CModelInfo::AddPedModel), index);
</pre>

#### \*CModelInfo::AddSimpleModel

<pre>
plugin::CallAndReturnDynGlobal<CSimpleModelInfo *, int>(gaddrof(CModelInfo::AddSimpleModel), index);
</pre>

#### \*CModelInfo::AddTimeModel

<pre>
plugin::CallAndReturnDynGlobal<CTimeModelInfo *, int>(gaddrof(CModelInfo::AddTimeModel), index);
</pre>

#### \*CModelInfo::AddVehicleModel

<pre>
plugin::CallAndReturnDynGlobal<CVehicleModelInfo *, int>(gaddrof(CModelInfo::AddVehicleModel), index);
</pre>

#### \*CModelInfo::Get2dEffectStore

<pre>
plugin::CallAndReturnDynGlobal<CStore<C2dEffect, 2000> *>(gaddrof(CModelInfo::Get2dEffectStore));
</pre>

#### \*CModelInfo::GetMloInstanceStore

<pre>
plugin::CallAndReturnDynGlobal<CStore<CInstance, 1> *>(gaddrof(CModelInfo::GetMloInstanceStore));
</pre>

#### \*CModelInfo::GetModelInfo

<pre>
plugin::CallAndReturnDynGlobal<CBaseModelInfo *, char const *, int *>(gaddrof(CModelInfo::GetModelInfo), name, index);
</pre>

#### CModelInfo::IsBoatModel

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CModelInfo::IsBoatModel), index);
</pre>

#### CModelInfo::RemoveColModelsFromOtherLevels

<pre>
plugin::CallDynGlobal<eLevelName>(gaddrof(CModelInfo::RemoveColModelsFromOtherLevels), level);
</pre>

### plugin_III\game_III\CMoneyMessage.cpp

#### CMoneyMessage::Render

<pre>
plugin::CallMethodDynGlobal<CMoneyMessage *>(gaddrof(CMoneyMessage::Render), this);
0AA6: call_method 0x51AD90 struct [CMoneyMessage] num_params 0 pop 0
</pre>

### plugin_III\game_III\CMotionBlurStreaks.cpp

#### CMotionBlurStreaks::RegisterStreak

<pre>
plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(gaddrof(CMotionBlurStreaks::RegisterStreak), id, red, green, blue, leftPoint, rightPoint);
</pre>

### plugin_III\game_III\CMouseControllerState.cpp

#### CMouseControllerState::CMouseControllerState

<pre>
plugin::CallMethodDynGlobal<CMouseControllerState *>(ctor_gaddr(CMouseControllerState), this);</pre>

#### CMouseControllerState::Clear

<pre>
plugin::CallMethodDynGlobal<CMouseControllerState *>(gaddrof(CMouseControllerState::Clear), this);
0AA6: call_method 0x491BB0 struct [CMouseControllerState] num_params 0 pop 0
</pre>

### plugin_III\game_III\CMousePointerStateHelper.cpp

### plugin_III\game_III\CMovingThing.cpp

#### CMovingThing::AddToList

<pre>
plugin::CallMethodDynGlobal<CMovingThing *, CMovingThing *>(gaddrof(CMovingThing::AddToList), this, pThing);
0AA6: call_method 0x4FF320 struct [CMovingThing] num_params 1 pop 0 [pThing]
</pre>

#### CMovingThing::RemoveFromList

<pre>
plugin::CallMethodDynGlobal<CMovingThing *>(gaddrof(CMovingThing::RemoveFromList), this);
0AA6: call_method 0x4FF340 struct [CMovingThing] num_params 0 pop 0
</pre>

#### CMovingThing::Update

<pre>
plugin::CallMethodDynGlobal<CMovingThing *>(gaddrof(CMovingThing::Update), this);
0AA6: call_method 0x4FF290 struct [CMovingThing] num_params 0 pop 0
</pre>

### plugin_III\game_III\cMusicManager.cpp

#### cMusicManager::ChangeMusicMode

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::ChangeMusicMode), this, mode);
0AA6: call_method 0x57D310 struct [cMusicManager] num_params 1 pop 0 [mode]
</pre>

#### cMusicManager::ChangeRadioChannel

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::ChangeRadioChannel), this);
0AA8: call_method_return 0x57E130 struct [cMusicManager] num_params 0 pop 0 func_ret [bool]
</pre>

#### cMusicManager::ComputeAmbienceVol

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, unsigned char &>(gaddrof(cMusicManager::ComputeAmbienceVol), this, reset, outVolume);
0AA6: call_method 0x57DEA0 struct [cMusicManager] num_params 2 pop 0 [reset] [outVolume]
</pre>

#### cMusicManager::DisplayRadioStationName

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::DisplayRadioStationName), this);
0AA6: call_method 0x57E6D0 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::GetCarTuning

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetCarTuning), this);
0AA8: call_method_return 0x57E530 struct [cMusicManager] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### cMusicManager::GetNextCarTuning

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetNextCarTuning), this);
0AA8: call_method_return 0x57E5A0 struct [cMusicManager] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### cMusicManager::GetRadioInCar

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetRadioInCar), this);
0AA8: call_method_return 0x57D1D0 struct [cMusicManager] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### cMusicManager::GetTrackStartPos

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, cMusicManager *, unsigned char>(gaddrof(cMusicManager::GetTrackStartPos), this, track);
0AA8: call_method_return 0x57E450 struct [cMusicManager] num_params 1 pop 0 [track] func_ret [unsigned int]
</pre>

#### cMusicManager::Initialise

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Initialise), this);
0AA6: call_method 0x57CF70 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::PlayAnnouncement

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::PlayAnnouncement), this, announcement);
0AA6: call_method 0x57E430 struct [cMusicManager] num_params 1 pop 0 [announcement]
</pre>

#### cMusicManager::PlayFrontEndTrack

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, unsigned char>(gaddrof(cMusicManager::PlayFrontEndTrack), this, track, bPlayInFrontend);
0AA6: call_method 0x57E2E0 struct [cMusicManager] num_params 2 pop 0 [track] [bPlayInFrontend]
</pre>

#### cMusicManager::PlayPreloadedCutSceneMusic

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::PlayPreloadedCutSceneMusic), this);
0AA6: call_method 0x57E290 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::PlayerInCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::PlayerInCar), this);
0AA8: call_method_return 0x57E4B0 struct [cMusicManager] num_params 0 pop 0 func_ret [bool]
</pre>

#### cMusicManager::PreloadCutSceneMusic

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::PreloadCutSceneMusic), this, sound);
0AA6: call_method 0x57E210 struct [cMusicManager] num_params 1 pop 0 [sound]
</pre>

#### cMusicManager::ResetMusicAfterReload

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ResetMusicAfterReload), this);
0AA6: call_method 0x57CF30 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::ResetTimers

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned int>(gaddrof(cMusicManager::ResetTimers), this, time);
0AA6: call_method 0x57D420 struct [cMusicManager] num_params 1 pop 0 [time]
</pre>

#### cMusicManager::Service

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Service), this);
0AA6: call_method 0x57D440 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::ServiceAmbience

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceAmbience), this);
0AA6: call_method 0x57DCB0 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::ServiceAnnouncement

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::ServiceAnnouncement), this);
0AA8: call_method_return 0x57DFC0 struct [cMusicManager] num_params 0 pop 0 func_ret [bool]
</pre>

#### cMusicManager::ServiceFrontEndMode

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceFrontEndMode), this);
0AA6: call_method 0x57D530 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::ServiceGameMode

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceGameMode), this);
0AA6: call_method 0x57D690 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::ServiceTrack

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceTrack), this);
0AA6: call_method 0x57E100 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::SetRadioChannelByScript

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, int>(gaddrof(cMusicManager::SetRadioChannelByScript), this, station, position);
0AA6: call_method 0x57D180 struct [cMusicManager] num_params 2 pop 0 [station] [position]
</pre>

#### cMusicManager::SetRadioInCar

<pre>
plugin::CallMethodDynGlobal<cMusicManager *, unsigned int>(gaddrof(cMusicManager::SetRadioInCar), this, radioStation);
0AA6: call_method 0x57D2C0 struct [cMusicManager] num_params 1 pop 0 [radioStation]
</pre>

#### cMusicManager::StopCutSceneMusic

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::StopCutSceneMusic), this);
0AA6: call_method 0x57E2B0 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::StopFrontEndTrack

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::StopFrontEndTrack), this);
0AA6: call_method 0x57E3D0 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::Terminate

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Terminate), this);
0AA6: call_method 0x57D140 struct [cMusicManager] num_params 0 pop 0
</pre>

#### cMusicManager::UsesPoliceRadio

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *, CVehicle *>(gaddrof(cMusicManager::UsesPoliceRadio), this, vehicle);
0AA8: call_method_return 0x57E6A0 struct [cMusicManager] num_params 1 pop 0 [vehicle] func_ret [bool]
</pre>

### plugin_III\game_III\CObject.cpp

#### CObject::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CObject *>(this);
</pre>

#### CObject::Teleport

<pre>
plugin::CallVirtualMethod<11, CObject *, CVector>(this, pos);
</pre>

#### CObject::Render

<pre>
plugin::CallVirtualMethod<13, CObject *>(this);
</pre>

#### CObject::SetupLighting

<pre>
plugin::CallVirtualMethodAndReturn<bool, 14, CObject *>(this);
</pre>

#### CObject::RemoveLighting

<pre>
plugin::CallVirtualMethod<15, CObject *, bool>(this, resetWorldColors);
</pre>

#### CObject::CanBeDeleted

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CObject *>(gaddrof(CObject::CanBeDeleted), this);
0AA8: call_method_return 0x4BB010 struct [CObject] num_params 0 pop 0 func_ret [bool]
</pre>

#### CObject::Init

<pre>
plugin::CallMethodDynGlobal<CObject *>(gaddrof(CObject::Init), this);
0AA6: call_method 0x4BAEC0 struct [CObject] num_params 0 pop 0
</pre>

#### CObject::ObjectDamage

<pre>
plugin::CallMethodDynGlobal<CObject *, float>(gaddrof(CObject::ObjectDamage), this, amount);
0AA6: call_method 0x4BB240 struct [CObject] num_params 1 pop 0 [amount]
</pre>

#### CObject::RefModelInfo

<pre>
plugin::CallMethodDynGlobal<CObject *, int>(gaddrof(CObject::RefModelInfo), this, modelIndex);
0AA6: call_method 0x4BBD80 struct [CObject] num_params 1 pop 0 [modelIndex]
</pre>

#### CObject::DeleteAllTempObjectsInArea

<pre>
plugin::CallDynGlobal<CVector, float>(gaddrof(CObject::DeleteAllTempObjectsInArea), point, radius);
</pre>

### plugin_III\game_III\CObjectData.cpp

#### CObjectData::Initialise

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CObjectData::Initialise), fileName);
</pre>

#### CObjectData::SetObjectData

<pre>
plugin::CallDynGlobal<int, CObject &>(gaddrof(CObjectData::SetObjectData), modelIndex, object);
</pre>

### plugin_III\game_III\common.cpp

#### FindPlayerHeading

<pre>
plugin::CallAndReturn<float, 0x4A1220>();
0AA7: call_function_return 0x4A1220 num_params 0 pop 0 func_ret [float]
</pre>

#### FindPlayerCentreOfWorld_NoSniperShift

<pre>
plugin::CallAndReturn<CVector&, 0x4A11C0>();
0AA7: call_function_return 0x4A11C0 num_params 0 pop 0 func_ret [CVector&]
</pre>

#### FindPlayerCentreOfWorld

<pre>
plugin::CallAndReturn<CVector&, 0x4A1170, int>(playerId);
0AA7: call_function_return 0x4A1170 num_params 1 pop 1 [playerId] func_ret [CVector&]
</pre>

#### FindPlayerPed

<pre>
plugin::CallAndReturn<CPlayerPed*, 0x4A1150>();
0AA7: call_function_return 0x4A1150 num_params 0 pop 0 func_ret [CPlayerPed*]
</pre>

#### FindPlayerTrain

<pre>
plugin::CallAndReturn<CTrain*, 0x4A1120>();
0AA7: call_function_return 0x4A1120 num_params 0 pop 0 func_ret [CTrain*]
</pre>

#### FindPlayerEntity

<pre>
plugin::CallAndReturn<CEntity*, 0x4A10F0>();
0AA7: call_function_return 0x4A10F0 num_params 0 pop 0 func_ret [CEntity*]
</pre>

#### FindPlayerVehicle

<pre>
plugin::CallAndReturn<CVehicle*, 0x4A10C0>();
0AA7: call_function_return 0x4A10C0 num_params 0 pop 0 func_ret [CVehicle*]
</pre>

#### FindPlayerSpeed

<pre>
plugin::CallAndReturn<CVector&, 0x4A1090>();
0AA7: call_function_return 0x4A1090 num_params 0 pop 0 func_ret [CVector&]
</pre>

#### FindPlayerCoors

<pre>
plugin::CallAndReturn<CVector&, 0x4A1030>();
0AA7: call_function_return 0x4A1030 num_params 0 pop 0 func_ret [CVector&]
</pre>

#### GetFirstTexture

<pre>
plugin::CallAndReturn<RwTexture*, 0x5264E0, RwTexDictionary*>(texDictionary);
0AA7: call_function_return 0x5264E0 num_params 1 pop 1 [texDictionary] func_ret [RwTexture*]
</pre>

#### GetFirstObject

<pre>
plugin::CallAndReturn<RwObject*, 0x526460, RwFrame*>(frame);
0AA7: call_function_return 0x526460 num_params 1 pop 1 [frame] func_ret [RwObject*]
</pre>

#### GetFirstAtomic

<pre>
plugin::CallAndReturn<RpAtomic*, 0x526420, RpClump*>(clump);
0AA7: call_function_return 0x526420 num_params 1 pop 1 [clump] func_ret [RpAtomic*]
</pre>

#### SetAmbientColours

<pre>
plugin::Call<0x526FA0, RwRGBAReal*>(colours);
0AA5: call_function 0x526FA0 num_params 1 pop 1 [colours]
</pre>

#### SetAmbientColoursForPedsCarsAndObjects

<pre>
plugin::Call<0x526F80>();
0AA5: call_function 0x526F80 num_params 0 pop 0
</pre>

#### SetAmbientColours

<pre>
plugin::Call<0x526F60>();
0AA5: call_function 0x526F60 num_params 0 pop 0
</pre>

#### ActivateDirectional

<pre>
plugin::Call<0x526F50>();
0AA5: call_function 0x526F50 num_params 0 pop 0
</pre>

#### DeActivateDirectional

<pre>
plugin::Call<0x526F40>();
0AA5: call_function 0x526F40 num_params 0 pop 0
</pre>

#### ReSetAmbientAndDirectionalColours

<pre>
plugin::Call<0x526F10>();
0AA5: call_function 0x526F10 num_params 0 pop 0
</pre>

#### SetBrightMarkerColours

<pre>
plugin::Call<0x526E60, float>(power);
0AA5: call_function 0x526E60 num_params 1 pop 1 [power]
</pre>

#### SetAmbientAndDirectionalColours

<pre>
plugin::Call<0x526DE0, float>(power);
0AA5: call_function 0x526DE0 num_params 1 pop 1 [power]
</pre>

#### RemoveExtraDirectionalLights

<pre>
plugin::Call<0x526DB0, RpWorld*>(world);
0AA5: call_function 0x526DB0 num_params 1 pop 1 [world]
</pre>

#### AddAnExtraDirectionalLight

<pre>
plugin::Call<0x526C70, RpWorld*, float, float, float, float, float, float>(world, x, y, z, red, green, blue);
0AA5: call_function 0x526C70 num_params 7 pop 7 [world] [x] [y] [z] [red] [green] [blue]
</pre>

#### WorldReplaceNormalLightsWithScorched

<pre>
plugin::Call<0x526C10, RpWorld*, float>(world, intensity);
0AA5: call_function 0x526C10 num_params 2 pop 2 [world] [intensity]
</pre>

#### LightsDestroy

<pre>
plugin::CallAndReturn<RpWorld*, 0x526B40, RpWorld*>(world);
0AA7: call_function_return 0x526B40 num_params 1 pop 1 [world] func_ret [RpWorld*]
</pre>

#### LightsCreate

<pre>
plugin::CallAndReturn<RpWorld*, 0x5269A0, RpWorld*>(world);
0AA7: call_function_return 0x5269A0 num_params 1 pop 1 [world] func_ret [RpWorld*]
</pre>

#### SetLightsWithTimeOfDayColour

<pre>
plugin::Call<0x526510, RpWorld*>(world);
0AA5: call_function 0x526510 num_params 1 pop 1 [world]
</pre>

#### GetFirstChild

<pre>
plugin::CallAndReturn<RwFrame*, 0x5264A0, RwFrame*>(frame);
0AA7: call_function_return 0x5264A0 num_params 1 pop 1 [frame] func_ret [RwFrame*]
</pre>

#### GetFirstAtomicCallback

<pre>
plugin::CallAndReturn<RpAtomic*, 0x526410, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x526410 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### GetFirstObjectCallback

<pre>
plugin::CallAndReturn<RwObject*, 0x526450, RwObject*, void*>(object, data);
0AA7: call_function_return 0x526450 num_params 2 pop 2 [object] [data] func_ret [RwObject*]
</pre>

#### GetFirstFrameCallback

<pre>
plugin::CallAndReturn<RwFrame*, 0x526490, RwFrame*, void*>(frame, data);
0AA7: call_function_return 0x526490 num_params 2 pop 2 [frame] [data] func_ret [RwFrame*]
</pre>

#### GetFirstTextureCallback

<pre>
plugin::CallAndReturn<RwTexture*, 0x5264D0, RwTexture*, void*>(texture, data);
0AA7: call_function_return 0x5264D0 num_params 2 pop 2 [texture] [data] func_ret [RwTexture*]
</pre>

#### WorldReplaceScorchedLightsWithNormal

<pre>
plugin::Call<0x526C50, RpWorld*>(world);
0AA5: call_function 0x526C50 num_params 1 pop 1 [world]
</pre>

#### CreateDebugFont

<pre>
plugin::Call<0x526300>();
0AA5: call_function 0x526300 num_params 0 pop 0
</pre>

#### DestroyDebugFont

<pre>
plugin::Call<0x526310>();
0AA5: call_function 0x526310 num_params 0 pop 0
</pre>

#### FlushObrsPrintfs

<pre>
plugin::Call<0x526320>();
0AA5: call_function 0x526320 num_params 0 pop 0
</pre>

#### DefinedState

<pre>
plugin::Call<0x526330>();
0AA5: call_function 0x526330 num_params 0 pop 0
</pre>

#### RpAnimBlendClumpGetAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4055C0>(clump, animId);
0AA7: call_function_return 0x4055C0 num_params 2 pop 2 [clump] [animId] func_ret [CAnimBlendAssociation*]
</pre>

### plugin_III\game_III\COneSheet.cpp

#### COneSheet::AddToList

<pre>
plugin::CallMethodDynGlobal<COneSheet *, COneSheet *>(gaddrof(COneSheet::AddToList), this, list);
0AA6: call_method 0x512650 struct [COneSheet] num_params 1 pop 0 [list]
</pre>

#### COneSheet::RemoveFromList

<pre>
plugin::CallMethodDynGlobal<COneSheet *>(gaddrof(COneSheet::RemoveFromList), this);
0AA6: call_method 0x512670 struct [COneSheet] num_params 0 pop 0
</pre>

### plugin_III\game_III\COnscreenTimer.cpp

#### COnscreenTimer::AddClock

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, char *>(gaddrof(COnscreenTimer::AddClock), this, offset, gxt);
0AA6: call_method 0x429350 struct [COnscreenTimer] num_params 2 pop 0 [offset] [gxt]
</pre>

#### COnscreenTimer::AddCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned short, char *>(gaddrof(COnscreenTimer::AddCounter), this, offset, type, gxt);
0AA6: call_method 0x4293B0 struct [COnscreenTimer] num_params 3 pop 0 [offset] [type] [gxt]
</pre>

#### COnscreenTimer::ClearClock

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearClock), this, offset);
0AA6: call_method 0x429410 struct [COnscreenTimer] num_params 1 pop 0 [offset]
</pre>

#### COnscreenTimer::ClearCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearCounter), this, offset);
0AA6: call_method 0x429450 struct [COnscreenTimer] num_params 1 pop 0 [offset]
</pre>

#### COnscreenTimer::Init

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Init), this);
0AA6: call_method 0x429220 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::Process

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Process), this);
0AA6: call_method 0x429320 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::ProcessForDisplay

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::ProcessForDisplay), this);
0AA6: call_method 0x4292E0 struct [COnscreenTimer] num_params 0 pop 0
</pre>

### plugin_III\game_III\COnscreenTimerEntry.cpp

#### COnscreenTimerEntry::Process

<pre>
plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::Process), this);
0AA6: call_method 0x429160 struct [COnscreenTimerEntry] num_params 0 pop 0
</pre>

#### COnscreenTimerEntry::ProcessForDisplay

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplay), this);
0AA8: call_method_return 0x429110 struct [COnscreenTimerEntry] num_params 0 pop 0 func_ret [bool]
</pre>

#### COnscreenTimerEntry::ProcessForDisplayClock

<pre>
plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayClock), this);
0AA6: call_method 0x429080 struct [COnscreenTimerEntry] num_params 0 pop 0
</pre>

#### COnscreenTimerEntry::ProcessForDisplayCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayCounter), this);
0AA6: call_method 0x4290F0 struct [COnscreenTimerEntry] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPacManPickup.cpp

#### CPacManPickup::Update

<pre>
plugin::CallMethodDynGlobal<CPacManPickup *>(gaddrof(CPacManPickup::Update), this);
0AA6: call_method 0x4331B0 struct [CPacManPickup] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPacManPickups.cpp

#### CPacManPickups::GenerateOnePMPickUp

<pre>
plugin::CallDynGlobal<CVector>(gaddrof(CPacManPickups::GenerateOnePMPickUp), pos);
</pre>

#### CPacManPickups::GeneratePMPickUps

<pre>
plugin::CallDynGlobal<CVector, float, short, unsigned char>(gaddrof(CPacManPickups::GeneratePMPickUps), pos, scrambleMult, count, type);
</pre>

#### CPacManPickups::GeneratePMPickUpsForRace

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPacManPickups::GeneratePMPickUpsForRace), race);
</pre>

#### CPacManPickups::QueryPowerPillsCarriedByPlayer

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CPacManPickups::QueryPowerPillsCarriedByPlayer));
</pre>

#### CPacManPickups::QueryPowerPillsEatenInRace

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CPacManPickups::QueryPowerPillsEatenInRace));
</pre>

#### CPacManPickups::StartPacManRace

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPacManPickups::StartPacManRace), race);
</pre>

#### CPacManPickups::StartPacManScramble

<pre>
plugin::CallDynGlobal<CVector, float, short>(gaddrof(CPacManPickups::StartPacManScramble), pos, scrambleMult, count);
</pre>

### plugin_III\game_III\CPad.cpp

#### CPad::AddToPCCheatString

<pre>
plugin::CallMethod<0x492450, CPad *, char>(this, name);
0AA6: call_method 0x492450 struct [CPad] num_params 1 pop 0 [name]
</pre>

#### CPad::CPad

<pre>
plugin::CallMethod<0x494EE0, CPad *>(this);
0AA6: call_method 0x494EE0 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::CarGunJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x4934F0, CPad *>(this);
0AA8: call_method_return 0x4934F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ChangeStationJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493870, CPad *>(this);
0AA8: call_method_return 0x493870 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::Clear

<pre>
plugin::CallMethod<0x491A10, CPad *, bool>(this, enable);
0AA6: call_method 0x491A10 struct [CPad] num_params 1 pop 0 [enable]
</pre>

#### CPad::ClearMouseHistory

<pre>
plugin::CallMethod<0x491B50, CPad *>(this);
0AA6: call_method 0x491B50 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::CycleCameraModeDownJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493830, CPad *>(this);
0AA8: call_method_return 0x493830 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleCameraModeUpJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x4937D0, CPad *>(this);
0AA8: call_method_return 0x4937D0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleWeaponLeftJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493910, CPad *>(this);
0AA8: call_method_return 0x493910 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleWeaponRightJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493940, CPad *>(this);
0AA8: call_method_return 0x493940 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::DoCheats

<pre>
plugin::CallMethod<0x492F20, CPad *, short>(this, arg0);
0AA6: call_method 0x492F20 struct [CPad] num_params 1 pop 0 [arg0]
</pre>

#### CPad::DoCheats

<pre>
plugin::Call<0x492F00>();
0AA5: call_function 0x492F00 num_params 0 pop 0
</pre>

#### CPad::EditCodesForControls

<pre>
plugin::Call<0x494690, int*>(arg0);
0AA5: call_function 0x494690 num_params 1 pop 1 [arg0]
</pre>

#### CPad::EditString

<pre>
plugin::Call<0x4944B0, char*, int>(name, arg1);
0AA5: call_function 0x4944B0 num_params 2 pop 2 [name] [arg1]
</pre>

#### CPad::ExitVehicleJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493650, CPad *>(this);
0AA8: call_method_return 0x493650 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ForceCameraBehindPlayer

<pre>
plugin::CallMethodAndReturn<bool, 0x493D80, CPad *>(this);
0AA8: call_method_return 0x493D80 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAccelerate

<pre>
plugin::CallMethodAndReturn<short, 0x493780, CPad *>(this);
0AA8: call_method_return 0x493780 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetAnaloguePadDown

<pre>
plugin::CallAndReturn<bool, 0x493BA0>();
0AA7: call_function_return 0x493BA0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadLeft

<pre>
plugin::CallAndReturn<bool, 0x493C00>();
0AA7: call_function_return 0x493C00 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadLeftJustUp

<pre>
plugin::CallAndReturn<bool, 0x493CC0>();
0AA7: call_function_return 0x493CC0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadRight

<pre>
plugin::CallAndReturn<bool, 0x493C60>();
0AA7: call_function_return 0x493C60 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadRightJustUp

<pre>
plugin::CallAndReturn<bool, 0x493D20>();
0AA7: call_function_return 0x493D20 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadUp

<pre>
plugin::CallAndReturn<bool, 0x493B40>();
0AA7: call_function_return 0x493B40 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnalogueUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x493210, CPad *>(this);
0AA8: call_method_return 0x493210 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetBrake

<pre>
plugin::CallMethodAndReturn<short, 0x4935A0, CPad *>(this);
0AA8: call_method_return 0x4935A0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetCarGunFired

<pre>
plugin::CallMethodAndReturn<bool, 0x493490, CPad *>(this);
0AA8: call_method_return 0x493490 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetCarGunLeftRight

<pre>
plugin::CallMethodAndReturn<short, 0x4930C0, CPad *>(this);
0AA8: call_method_return 0x4930C0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetCarGunUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x493070, CPad *>(this);
0AA8: call_method_return 0x493070 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetExitVehicle

<pre>
plugin::CallMethodAndReturn<bool, 0x4935F0, CPad *>(this);
0AA8: call_method_return 0x4935F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetHandBrake

<pre>
plugin::CallMethodAndReturn<short, 0x493560, CPad *>(this);
0AA8: call_method_return 0x493560 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetHorn

<pre>
plugin::CallMethodAndReturn<bool, 0x493350, CPad *>(this);
0AA8: call_method_return 0x493350 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookBehindForCar

<pre>
plugin::CallMethodAndReturn<bool, 0x4932F0, CPad *>(this);
0AA8: call_method_return 0x4932F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookBehindForPed

<pre>
plugin::CallMethodAndReturn<bool, 0x493320, CPad *>(this);
0AA8: call_method_return 0x493320 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookLeft

<pre>
plugin::CallMethodAndReturn<bool, 0x493290, CPad *>(this);
0AA8: call_method_return 0x493290 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookRight

<pre>
plugin::CallMethodAndReturn<bool, 0x4932C0, CPad *>(this);
0AA8: call_method_return 0x4932C0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetPad

<pre>
plugin::CallAndReturn<CPad*, 0x492F60, int>(padNumber);
0AA7: call_function_return 0x492F60 num_params 1 pop 1 [padNumber] func_ret [CPad*]
</pre>

#### CPad::GetPedWalkLeftRight

<pre>
plugin::CallMethodAndReturn<short, 0x493110, CPad *>(this);
0AA8: call_method_return 0x493110 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetPedWalkUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x493190, CPad *>(this);
0AA8: call_method_return 0x493190 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetSprint

<pre>
plugin::CallMethodAndReturn<bool, 0x493A70, CPad *>(this);
0AA8: call_method_return 0x493A70 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetSteeringLeftRight

<pre>
plugin::CallMethodAndReturn<short, 0x492F70, CPad *>(this);
0AA8: call_method_return 0x492F70 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetSteeringUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x492FF0, CPad *>(this);
0AA8: call_method_return 0x492FF0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x493970, CPad *>(this);
0AA8: call_method_return 0x493970 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetWeapon

<pre>
plugin::CallMethodAndReturn<bool, 0x4936C0, CPad *>(this);
0AA8: call_method_return 0x4936C0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::HornJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x4933F0, CPad *>(this);
0AA8: call_method_return 0x4933F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::JumpJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493A40, CPad *>(this);
0AA8: call_method_return 0x493A40 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::LookAroundLeftRight

<pre>
plugin::CallMethodAndReturn<int, 0x493F80, CPad *>(this);
0AA8: call_method_return 0x493F80 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::LookAroundUpDown

<pre>
plugin::CallMethodAndReturn<int, 0x494130, CPad *>(this);
0AA8: call_method_return 0x494130 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::PrintErrorMessage

<pre>
plugin::Call<0x4942B0>();
0AA5: call_function 0x4942B0 num_params 0 pop 0
</pre>

#### CPad::ProcessPCSpecificStuff

<pre>
plugin::CallMethod<0x492C60, CPad *>(this);
0AA6: call_method 0x492C60 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::ReconcileTwoControllersInput

<pre>
plugin::CallMethod<0x491E60, CPad *, CControllerState const&, CControllerState const&>(this, controllerA, controllerB);
0AA6: call_method 0x491E60 struct [CPad] num_params 2 pop 0 [controllerA] [controllerB]
</pre>

#### CPad::ResetAverageWeapon

<pre>
plugin::CallMethod<0x494290, CPad *>(this);
0AA6: call_method 0x494290 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::ResetCheats

<pre>
plugin::Call<0x494450>();
0AA5: call_function 0x494450 num_params 0 pop 0
</pre>

#### CPad::ShiftTargetLeftJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493AE0, CPad *>(this);
0AA8: call_method_return 0x493AE0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ShiftTargetRightJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493B10, CPad *>(this);
0AA8: call_method_return 0x493B10 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SniperModeLookLeftRight

<pre>
plugin::CallMethodAndReturn<short, 0x493EE0, CPad *>(this);
0AA8: call_method_return 0x493EE0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::SniperModeLookUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x493F30, CPad *>(this);
0AA8: call_method_return 0x493F30 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::SniperZoomIn

<pre>
plugin::CallMethodAndReturn<bool, 0x493E00, CPad *>(this);
0AA8: call_method_return 0x493E00 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SniperZoomOut

<pre>
plugin::CallMethodAndReturn<bool, 0x493E70, CPad *>(this);
0AA8: call_method_return 0x493E70 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::StartShake

<pre>
plugin::CallMethod<0x492230, CPad *, short, unsigned char>(this, time, frequency);
0AA6: call_method 0x492230 struct [CPad] num_params 2 pop 0 [time] [frequency]
</pre>

#### CPad::StartShake_Distance

<pre>
plugin::CallMethod<0x492290, CPad *, short, unsigned char, float, float, float>(this, time, frequency, x, y, z);
0AA6: call_method 0x492290 struct [CPad] num_params 5 pop 0 [time] [frequency] [x] [y] [z]
</pre>

#### CPad::StartShake_Train

<pre>
plugin::CallMethod<0x492360, CPad *, float, float>(this, x, y);
0AA6: call_method 0x492360 struct [CPad] num_params 2 pop 0 [x] [y]
</pre>

#### CPad::StopPadsShaking

<pre>
plugin::Call<0x492F30>();
0AA5: call_function 0x492F30 num_params 0 pop 0
</pre>

#### CPad::StopShaking

<pre>
plugin::CallMethod<0x492F50, CPad *, short>(this, arg0);
0AA6: call_method 0x492F50 struct [CPad] num_params 1 pop 0 [arg0]
</pre>

#### CPad::TargetJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x4939D0, CPad *>(this);
0AA8: call_method_return 0x4939D0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::Update

<pre>
plugin::CallMethod<0x492C70, CPad *>(this);
0AA6: call_method 0x492C70 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::UpdateMouse

<pre>
plugin::CallMethod<0x491CA0, CPad *>(this);
0AA6: call_method 0x491CA0 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::UpdatePads

<pre>
plugin::Call<0x492720>();
0AA5: call_function 0x492720 num_params 0 pop 0
</pre>

#### CPad::WeaponJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x493700, CPad *>(this);
0AA8: call_method_return 0x493700 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::~CPad

<pre>
plugin::CallMethod<0x494ED0, CPad *>(this);
0AA6: call_method 0x494ED0 struct [CPad] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPager.cpp

#### CPager::Init

<pre>
plugin::CallMethod<0x52B6F0, CPager *>(this);
0AA6: call_method 0x52B6F0 struct [CPager] num_params 0 pop 0
</pre>

#### CPager::Process

<pre>
plugin::CallMethod<0x52B740, CPager *>(this);
0AA6: call_method 0x52B740 struct [CPager] num_params 0 pop 0
</pre>

#### CPager::Display

<pre>
plugin::CallMethod<0x52B890, CPager *>(this);
0AA6: call_method 0x52B890 struct [CPager] num_params 0 pop 0
</pre>

#### CPager::AddMessage

<pre>
plugin::CallMethod<0x52B940, CPager *, wchar_t*, unsigned short, unsigned short, unsigned short>(this, text, speed, priority, arg3);
0AA6: call_method 0x52B940 struct [CPager] num_params 4 pop 0 [text] [speed] [priority] [arg3]
</pre>

#### CPager::AddMessageWithNumber

<pre>
plugin::CallMethod<0x52BB50, CPager *, wchar_t*, int, int, int, int, int, int, unsigned short, unsigned short, unsigned short>(this, text, n1, n2, n3, n4, n5, n6, speed, priority, arg9);
0AA6: call_method 0x52BB50 struct [CPager] num_params 10 pop 0 [text] [n1] [n2] [n3] [n4] [n5] [n6] [speed] [priority] [arg9]
</pre>

#### CPager::ClearMessages

<pre>
plugin::CallMethod<0x52BE00, CPager *>(this);
0AA6: call_method 0x52BE00 struct [CPager] num_params 0 pop 0
</pre>

#### CPager::RestartCurrentMessage

<pre>
plugin::CallMethod<0x52BE50, CPager *>(this);
0AA6: call_method 0x52BE50 struct [CPager] num_params 0 pop 0
</pre>

### plugin_III\game_III\CParticle.cpp

#### CParticle::AddJetExplosion

<pre>
plugin::CallDynGlobal<CVector const &, float, float>(gaddrof(CParticle::AddJetExplosion), pos, power, size);
</pre>

#### \*CParticle::AddParticle

<pre>
plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int)), type, pos, direction, entity, size, rotationSpeed, rotation, currentFrame, lifeSpan);
</pre>

#### \*CParticle::AddParticle

<pre>
plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const &, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const &, int, int, int, int)), type, pos, direction, entity, size, color, rotationSpeed, rotation, currentFrame, lifeSpan);
</pre>

#### CParticle::AddYardieDoorSmoke

<pre>
plugin::CallDynGlobal<CVector const &, CMatrix const &>(gaddrof(CParticle::AddYardieDoorSmoke), pos, matrix);
</pre>

#### CParticle::RemovePSystem

<pre>
plugin::CallDynGlobal<tParticleType>(gaddrof(CParticle::RemovePSystem), type);
</pre>

#### CParticle::RemoveParticle

<pre>
plugin::CallDynGlobal<CParticle *, CParticle *, tParticleSystemData *>(gaddrof(CParticle::RemoveParticle), particle, previousParticle, particleSystem);
</pre>

### plugin_III\game_III\CParticleObject.cpp

#### CParticleObject::RemoveObject

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::RemoveObject), this);
0AA6: call_method 0x4BC9F0 struct [CParticleObject] num_params 0 pop 0
</pre>

#### CParticleObject::UpdateClose

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::UpdateClose), this);
0AA6: call_method 0x4BCA80 struct [CParticleObject] num_params 0 pop 0
</pre>

#### CParticleObject::UpdateFar

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::UpdateFar), this);
0AA6: call_method 0x4BF9F0 struct [CParticleObject] num_params 0 pop 0
</pre>

#### \*CParticleObject::AddObject

<pre>
plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, unsigned char)), type, pos, remove);
</pre>

#### \*CParticleObject::AddObject

<pre>
plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, float, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, float, unsigned char)), type, pos, size, remove);
</pre>

#### \*CParticleObject::AddObject

<pre>
plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, CVector const &, float, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, CVector const &, float, unsigned char)), type, pos, target, size, remove);
</pre>

#### \*CParticleObject::AddObject

<pre>
plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, CVector const &, float, unsigned int, RwRGBA const &, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject *(*)(unsigned short, CVector const &, CVector const &, float, unsigned int, RwRGBA const &, unsigned char)), type, pos, target, size, lifeTime, color, remove);
</pre>

#### CParticleObject::LoadParticle

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CParticleObject::LoadParticle), buffer, size);
</pre>

#### CParticleObject::MoveToList

<pre>
plugin::CallDynGlobal<CParticleObject **, CParticleObject **, CParticleObject *>(gaddrof(CParticleObject::MoveToList), from, to, object);
</pre>

#### CParticleObject::SaveParticle

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CParticleObject::SaveParticle), buffer, size);
</pre>

### plugin_III\game_III\cParticleSystemMgr.cpp

#### cParticleSystemMgr::cParticleSystemMgr

<pre>
plugin::CallMethod<0x50FCB0, cParticleSystemMgr *>(this);
0AA6: call_method 0x50FCB0 struct [cParticleSystemMgr] num_params 0 pop 0
</pre>

#### cParticleSystemMgr::Initialise

<pre>
plugin::CallMethod<0x50FCD0, cParticleSystemMgr *>(this);
0AA6: call_method 0x50FCD0 struct [cParticleSystemMgr] num_params 0 pop 0
</pre>

#### cParticleSystemMgr::LoadParticleData

<pre>
plugin::CallMethod<0x50FDF0, cParticleSystemMgr *>(this);
0AA6: call_method 0x50FDF0 struct [cParticleSystemMgr] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPathFind.cpp

#### CPathFind::AddNodeToList

<pre>
plugin::CallMethodDynGlobal<CPathFind *, CPathNode *, int>(gaddrof(CPathFind::AddNodeToList), this, node, listId);
0AA6: call_method 0x42CBE0 struct [CPathFind] num_params 2 pop 0 [node] [listId]
</pre>

#### CPathFind::AllocatePathFindInfoMem

<pre>
plugin::CallMethodDynGlobal<CPathFind *, short>(gaddrof(CPathFind::AllocatePathFindInfoMem), this, numPathGroups);
0AA6: call_method 0x42D580 struct [CPathFind] num_params 1 pop 0 [numPathGroups]
</pre>

#### CPathFind::CalcNodeCoors

<pre>
plugin::CallMethodDynGlobal<CPathFind *, short, short, short, int, CVector *>(gaddrof(CPathFind::CalcNodeCoors), this, x, y, z, id, out);
0AA6: call_method 0x429560 struct [CPathFind] num_params 5 pop 0 [x] [y] [z] [id] [out]
</pre>

#### CPathFind::CalcRoadDensity

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, float, float>(gaddrof(CPathFind::CalcRoadDensity), this, x, y);
0AA8: call_method_return 0x42C990 struct [CPathFind] num_params 2 pop 0 [x] [y] func_ret [float]
</pre>

#### CPathFind::CountFloodFillGroups

<pre>
plugin::CallMethodDynGlobal<CPathFind *, unsigned char>(gaddrof(CPathFind::CountFloodFillGroups), this, type);
0AA6: call_method 0x42B810 struct [CPathFind] num_params 1 pop 0 [type]
</pre>

#### CPathFind::DoPathSearch

<pre>
plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CVector, int, CVector, CPathNode **, short *, short, CVehicle *, float *, float, int>(gaddrof(CPathFind::DoPathSearch), this, type, start, startNodeId, target, nodes, numNodes, maxNumNodes, vehicle, dist, distLimit, forcedTargetNode);
0AA6: call_method 0x42B040 struct [CPathFind] num_params 11 pop 0 [type] [start] [startNodeId] [target] [nodes] [numNodes] [maxNumNodes] [vehicle] [dist] [distLimit] [forcedTargetNode]
</pre>

#### CPathFind::FindNextNodeWandering

<pre>
plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CVector, CPathNode **, CPathNode **, unsigned char, unsigned char *>(gaddrof(CPathFind::FindNextNodeWandering), this, type, coors, lastNode, nextNode, curDir, nextDir);
0AA6: call_method 0x42B9F0 struct [CPathFind] num_params 6 pop 0 [type] [coors] [lastNode] [nextNode] [curDir] [nextDir]
</pre>

#### CPathFind::FindNodeClosestToCoors

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPathFind *, CVector, unsigned char, float, bool, bool>(gaddrof(CPathFind::FindNodeClosestToCoors), this, coors, type, distLimit, ignoreDisabled, ignoreBetweenLevels);
0AA8: call_method_return 0x42CC30 struct [CPathFind] num_params 5 pop 0 [coors] [type] [distLimit] [ignoreDisabled] [ignoreBetweenLevels] func_ret [int]
</pre>

#### CPathFind::FindNodeClosestToCoorsFavourDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPathFind *, CVector, unsigned char, float, float>(gaddrof(CPathFind::FindNodeClosestToCoorsFavourDirection), this, coors, type, dirX, dirY);
0AA8: call_method_return 0x42CDC0 struct [CPathFind] num_params 4 pop 0 [coors] [type] [dirX] [dirY] func_ret [int]
</pre>

#### CPathFind::FindNodeOrientationForCarPlacement

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, unsigned int>(gaddrof(CPathFind::FindNodeOrientationForCarPlacement), this, nodeId);
0AA8: call_method_return 0x42CFC0 struct [CPathFind] num_params 1 pop 0 [nodeId] func_ret [float]
</pre>

#### CPathFind::FindNodeOrientationForCarPlacementFacingDestination

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, unsigned int, float, float, bool>(gaddrof(CPathFind::FindNodeOrientationForCarPlacementFacingDestination), this, nodeId, x, y, towards);
0AA8: call_method_return 0x42D060 struct [CPathFind] num_params 4 pop 0 [nodeId] [x] [y] [towards] func_ret [float]
</pre>

#### \*CPathFind::FindRoadObjectClosestToCoors

<pre>
plugin::CallMethodAndReturnDynGlobal<CTreadable *, CPathFind *, CVector, unsigned char>(gaddrof(CPathFind::FindRoadObjectClosestToCoors), this, coors, type);
0AA8: call_method_return 0x42D2A0 struct [*CPathFind] num_params 2 pop 0 [coors] [type] func_ret [CTreadable *]
</pre>

#### CPathFind::GeneratePedCreationCoors

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, float, float, float, float, float, float, CVector *, int *, int *, float *, CMatrix *>(gaddrof(CPathFind::GeneratePedCreationCoors), this, x, y, minDist, maxDist, minDistOffScreen, maxDistOffScreen, posn, pNode1, pNode2, positionBetweenNodes, camMatrix);
0AA8: call_method_return 0x42C1E0 struct [CPathFind] num_params 11 pop 0 [x] [y] [minDist] [maxDist] [minDistOffScreen] [maxDistOffScreen] [posn] [pNode1] [pNode2] [positionBetweenNodes] [camMatrix] func_ret [bool]
</pre>

#### CPathFind::Init

<pre>
plugin::CallMethodDynGlobal<CPathFind *>(gaddrof(CPathFind::Init), this);
0AA6: call_method 0x4294A0 struct [CPathFind] num_params 0 pop 0
</pre>

#### CPathFind::Load

<pre>
plugin::CallMethodDynGlobal<CPathFind *, unsigned char *, unsigned int>(gaddrof(CPathFind::Load), this, buf, size);
0AA6: call_method 0x42E550 struct [CPathFind] num_params 2 pop 0 [buf] [size]
</pre>

#### CPathFind::MarkRoadsBetweenLevelsInArea

<pre>
plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float>(gaddrof(CPathFind::MarkRoadsBetweenLevelsInArea), this, x1, x2, y1, y2, z1, z2);
0AA6: call_method 0x42DF50 struct [CPathFind] num_params 6 pop 0 [x1] [x2] [y1] [y2] [z1] [z2]
</pre>

#### CPathFind::MarkRoadsBetweenLevelsNodeAndNeighbours

<pre>
plugin::CallMethodDynGlobal<CPathFind *, int>(gaddrof(CPathFind::MarkRoadsBetweenLevelsNodeAndNeighbours), this, nodeId);
0AA6: call_method 0x42E140 struct [CPathFind] num_params 1 pop 0 [nodeId]
</pre>

#### CPathFind::NewGenerateCarCreationCoors

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, float, float, float, float, float, float, bool, CVector *, int *, int *, float *, bool>(gaddrof(CPathFind::NewGenerateCarCreationCoors), this, x, y, dirX, dirY, spawnDist, angleLimit, forward, posn, pNode1, pNode2, positionBetweenNodes, ignoreDisabled);
0AA8: call_method_return 0x42BF10 struct [CPathFind] num_params 12 pop 0 [x] [y] [dirX] [dirY] [spawnDist] [angleLimit] [forward] [posn] [pNode1] [pNode2] [positionBetweenNodes] [ignoreDisabled] func_ret [bool]
</pre>

#### CPathFind::PedMarkRoadsBetweenLevelsInArea

<pre>
plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float>(gaddrof(CPathFind::PedMarkRoadsBetweenLevelsInArea), this, x1, x2, y1, y2, z1, z2);
0AA6: call_method 0x42E040 struct [CPathFind] num_params 6 pop 0 [x1] [x2] [y1] [y2] [z1] [z2]
</pre>

#### CPathFind::PreparePathData

<pre>
plugin::CallMethodDynGlobal<CPathFind *>(gaddrof(CPathFind::PreparePathData), this);
0AA6: call_method 0x429610 struct [CPathFind] num_params 0 pop 0
</pre>

#### CPathFind::PreparePathDataForType

<pre>
plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CTempNode *, CPathInfoForObject *, float, CTempDetachedNode *, int>(gaddrof(CPathFind::PreparePathDataForType), this, type, tempNodes, info, maxDist, detachedNodes, numDetached);
0AA6: call_method 0x429C20 struct [CPathFind] num_params 6 pop 0 [type] [tempNodes] [info] [maxDist] [detachedNodes] [numDetached]
</pre>

#### CPathFind::RegisterMapObject

<pre>
plugin::CallMethodDynGlobal<CPathFind *, CTreadable *>(gaddrof(CPathFind::RegisterMapObject), this, mapObject);
0AA6: call_method 0x429540 struct [CPathFind] num_params 1 pop 0 [mapObject]
</pre>

#### CPathFind::RemoveBadStartNode

<pre>
plugin::CallMethodDynGlobal<CPathFind *, CVector, CPathNode **, short *>(gaddrof(CPathFind::RemoveBadStartNode), this, pos, nodes, nodeCount);
0AA6: call_method 0x42B790 struct [CPathFind] num_params 3 pop 0 [pos] [nodes] [nodeCount]
</pre>

#### CPathFind::RemoveNodeFromList

<pre>
plugin::CallMethodDynGlobal<CPathFind *, CPathNode *>(gaddrof(CPathFind::RemoveNodeFromList), this, node);
0AA6: call_method 0x42CBB0 struct [CPathFind] num_params 1 pop 0 [node]
</pre>

#### CPathFind::Save

<pre>
plugin::CallMethodDynGlobal<CPathFind *, unsigned char *, unsigned int *>(gaddrof(CPathFind::Save), this, buf, size);
0AA6: call_method 0x42E450 struct [CPathFind] num_params 2 pop 0 [buf] [size]
</pre>

#### CPathFind::SetLinksBridgeLights

<pre>
plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, bool>(gaddrof(CPathFind::SetLinksBridgeLights), this, x1, y1, x2, y2, enable);
0AA6: call_method 0x42E3B0 struct [CPathFind] num_params 5 pop 0 [x1] [y1] [x2] [y2] [enable]
</pre>

#### CPathFind::StoreNodeInfoCar

<pre>
plugin::CallMethodDynGlobal<CPathFind *, short, short, char, char, short, short, short, short, char, char>(gaddrof(CPathFind::StoreNodeInfoCar), this, id, node, type, next, x, y, z, width, numLeft, numRight);
0AA6: call_method 0x42D690 struct [CPathFind] num_params 10 pop 0 [id] [node] [type] [next] [x] [y] [z] [width] [numLeft] [numRight]
</pre>

#### CPathFind::StoreNodeInfoPed

<pre>
plugin::CallMethodDynGlobal<CPathFind *, short, short, char, char, short, short, short, short, bool>(gaddrof(CPathFind::StoreNodeInfoPed), this, id, node, type, next, x, y, z, width, crossing);
0AA6: call_method 0x42D7E0 struct [CPathFind] num_params 9 pop 0 [id] [node] [type] [next] [x] [y] [z] [width] [crossing]
</pre>

#### CPathFind::SwitchOffNodeAndNeighbours

<pre>
plugin::CallMethodDynGlobal<CPathFind *, int, bool>(gaddrof(CPathFind::SwitchOffNodeAndNeighbours), this, nodeId, disable);
0AA6: call_method 0x42DED0 struct [CPathFind] num_params 2 pop 0 [nodeId] [disable]
</pre>

#### CPathFind::SwitchPedRoadsOffInArea

<pre>
plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, bool>(gaddrof(CPathFind::SwitchPedRoadsOffInArea), this, x1, x2, y1, y2, z1, z2, disable);
0AA6: call_method 0x42DA50 struct [CPathFind] num_params 7 pop 0 [x1] [x2] [y1] [y2] [z1] [z2] [disable]
</pre>

#### CPathFind::SwitchRoadsInAngledArea

<pre>
plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, float, unsigned char, unsigned char>(gaddrof(CPathFind::SwitchRoadsInAngledArea), this, x1, y1, z1, x2, y2, z2, length, type, enable);
0AA6: call_method 0x42DB50 struct [CPathFind] num_params 9 pop 0 [x1] [y1] [z1] [x2] [y2] [z2] [length] [type] [enable]
</pre>

#### CPathFind::SwitchRoadsOffInArea

<pre>
plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, bool>(gaddrof(CPathFind::SwitchRoadsOffInArea), this, x1, x2, y1, y2, z1, z2, disable);
0AA6: call_method 0x42D960 struct [CPathFind] num_params 7 pop 0 [x1] [x2] [y1] [y2] [z1] [z2] [disable]
</pre>

#### CPathFind::TestCoorsCloseness

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CVector, unsigned char, CVector>(gaddrof(CPathFind::TestCoorsCloseness), this, target, type, start);
0AA8: call_method_return 0x42C8C0 struct [CPathFind] num_params 3 pop 0 [target] [type] [start] func_ret [bool]
</pre>

#### CPathFind::TestCrossesRoad

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CPathNode *, CPathNode *>(gaddrof(CPathFind::TestCrossesRoad), this, node1, node2);
0AA8: call_method_return 0x42E340 struct [CPathFind] num_params 2 pop 0 [node1] [node2] func_ret [bool]
</pre>

#### CPathFind::TestForPedTrafficLight

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CPathNode *, CPathNode *>(gaddrof(CPathFind::TestForPedTrafficLight), this, node1, node2);
0AA8: call_method_return 0x42E1B0 struct [CPathFind] num_params 2 pop 0 [node1] [node2] func_ret [bool]
</pre>

#### CPathFind::LoadPathFindData

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPathFind::LoadPathFindData));
</pre>

### plugin_III\game_III\CPed.cpp

#### CPed::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CPed *, unsigned int>(this, modelIndex);
</pre>

#### CPed::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CPed *>(this);
</pre>

#### CPed::Teleport

<pre>
plugin::CallVirtualMethod<11, CPed *, CVector>(this, pos);
</pre>

#### CPed::PreRender

<pre>
plugin::CallVirtualMethod<12, CPed *>(this);
</pre>

#### CPed::Render

<pre>
plugin::CallVirtualMethod<13, CPed *>(this);
</pre>

#### CPed::SetupLighting

<pre>
plugin::CallVirtualMethodAndReturn<bool, 14, CPed *>(this);
</pre>

#### CPed::RemoveLighting

<pre>
plugin::CallVirtualMethod<15, CPed *, bool>(this, resetWorldColors);
</pre>

#### CPed::FlagToDestroyWhenNextProcessed

<pre>
plugin::CallVirtualMethod<16, CPed *>(this);
</pre>

#### CPed::ProcessEntityCollision

<pre>
plugin::CallVirtualMethod<17, CPed *, CEntity *, CColPoint *>(this, entity, colPoint);
</pre>

#### CPed::SetMoveAnim

<pre>
plugin::CallVirtualMethod<18, CPed *>(this);
</pre>

#### CPed::AddWeaponModel

<pre>
plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::AddWeaponModel), this, modelIndex);
0AA6: call_method 0x4CF8F0 struct [CPed] num_params 1 pop 0 [modelIndex]
</pre>

#### CPed::AimGun

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::AimGun), this);
0AA6: call_method 0x4C6AA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ApplyHeadShot

<pre>
plugin::CallMethodDynGlobal<CPed *, eWeaponType, CVector, unsigned char>(gaddrof(CPed::ApplyHeadShot), this, type, pos, evenOnPlayer);
0AA6: call_method 0x4EB470 struct [CPed] num_params 3 pop 0 [type] [pos] [evenOnPlayer]
</pre>

#### CPed::Attack

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Attack), this);
0AA6: call_method 0x4E6BA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Avoid

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Avoid), this);
0AA6: call_method 0x4D2BB0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::BeingDraggedFromCar

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::BeingDraggedFromCar), this);
0AA6: call_method 0x4E07D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::BuildPedLists

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::BuildPedLists), this);
0AA6: call_method 0x4C5350 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CalculateNewOrientation

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CalculateNewOrientation), this);
0AA6: call_method 0x4C7EA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CalculateNewVelocity

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CalculateNewVelocity), this);
0AA6: call_method 0x4C73F0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CanBeDeleted

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanBeDeleted), this);
0AA8: call_method_return 0x4CF8B0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanPedDriveOff

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedDriveOff), this);
0AA8: call_method_return 0x4D7AC0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanPedJumpThis

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedJumpThis), this);
0AA8: call_method_return 0x4D72F0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanPedReturnToState

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedReturnToState), this);
0AA8: call_method_return 0x4CE760 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanSeeEntity

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *, float>(gaddrof(CPed::CanSeeEntity), this, entity, threshold);
0AA8: call_method_return 0x4DD820 struct [CPed] num_params 2 pop 0 [entity] [threshold] func_ret [bool]
</pre>

#### CPed::CanSetPedState

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanSetPedState), this);
0AA8: call_method_return 0x4CE7A0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanStrafeOrMouseControl

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanStrafeOrMouseControl), this);
0AA8: call_method_return 0x4CE7D0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Chat

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Chat), this);
0AA6: call_method 0x4D3AC0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CheckAroundForPossibleCollisions

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CheckAroundForPossibleCollisions), this);
0AA6: call_method 0x4D0490 struct [CPed] num_params 0 pop 0
</pre>

#### \*CPed::CheckForDeadPeds

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CPed *>(gaddrof(CPed::CheckForDeadPeds), this);
0AA8: call_method_return 0x4D4860 struct [*CPed] num_params 0 pop 0 func_ret [CPed *]
</pre>

#### CPed::CheckForExplosions

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector2D &>(gaddrof(CPed::CheckForExplosions), this, area);
0AA8: call_method_return 0x4D4650 struct [CPed] num_params 1 pop 0 [area] func_ret [bool]
</pre>

#### \*CPed::CheckForGunShots

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CPed *>(gaddrof(CPed::CheckForGunShots), this);
0AA8: call_method_return 0x4D47D0 struct [*CPed] num_params 0 pop 0 func_ret [CPed *]
</pre>

#### CPed::CheckForPointBlankPeds

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, CPed *>(gaddrof(CPed::CheckForPointBlankPeds), this, pedToVerify);
0AA8: call_method_return 0x4E6990 struct [CPed] num_params 1 pop 0 [pedToVerify] func_ret [unsigned char]
</pre>

#### CPed::CheckIfInTheAir

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CheckIfInTheAir), this);
0AA8: call_method_return 0x4D0BE0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::ClearAimFlag

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAimFlag), this);
0AA6: call_method 0x4C6A50 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAll

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAll), this);
0AA6: call_method 0x4C7F20 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAttack

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAttack), this);
0AA6: call_method 0x4E6790 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAttackByRemovingAnim

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAttackByRemovingAnim), this);
0AA6: call_method 0x4E67F0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearChat

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearChat), this);
0AA6: call_method 0x4D3C80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearDuck

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearDuck), this);
0AA6: call_method 0x4E4A30 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearFall

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearFall), this);
0AA6: call_method 0x4D0BB0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearFlee

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearFlee), this);
0AA6: call_method 0x4D1EA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearInvestigateEvent

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearInvestigateEvent), this);
0AA6: call_method 0x4EA360 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearLeader

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLeader), this);
0AA6: call_method 0x4D8E80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearLook

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLook), this);
0AA6: call_method 0x4D1360 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearLookFlag

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLookFlag), this);
0AA6: call_method 0x4C64F0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearObjective

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearObjective), this);
0AA6: call_method 0x4D8DF0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearPause

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearPause), this);
0AA6: call_method 0x4D0970 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearPointGunAt

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearPointGunAt), this);
0AA6: call_method 0x4E6180 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearSeek

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearSeek), this);
0AA6: call_method 0x4D1620 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearWeapons

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearWeapons), this);
0AA6: call_method 0x4CFB70 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CollideWithPed

<pre>
plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::CollideWithPed), this, collideWith);
0AA6: call_method 0x4EB9A0 struct [CPed] num_params 1 pop 0 [collideWith]
</pre>

#### CPed::CreateDeadPedMoney

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CreateDeadPedMoney), this);
0AA6: call_method 0x433490 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CreateDeadPedWeaponPickups

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CreateDeadPedWeaponPickups), this);
0AA6: call_method 0x433660 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Die

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Die), this);
0AA6: call_method 0x4D3A50 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::DoesLOSBulletHitPed

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, CColPoint &>(gaddrof(CPed::DoesLOSBulletHitPed), this, colPoint);
0AA8: call_method_return 0x4EB5C0 struct [CPed] num_params 1 pop 0 [colPoint] func_ret [unsigned char]
</pre>

#### CPed::Duck

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Duck), this);
0AA6: call_method 0x4E4A10 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::DuckAndCover

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::DuckAndCover), this);
0AA8: call_method_return 0x4E3EC0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::EndFight

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned char>(gaddrof(CPed::EndFight), this, endType);
0AA6: call_method 0x4E8D30 struct [CPed] num_params 1 pop 0 [endType]
</pre>

#### CPed::EnterCar

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::EnterCar), this);
0AA6: call_method 0x4E0D30 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::EnterTrain

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::EnterTrain), this);
0AA6: call_method 0x4E33B0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ExitCar

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ExitCar), this);
0AA6: call_method 0x4E18D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ExitTrain

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ExitTrain), this);
0AA6: call_method 0x4E36D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::FacePhone

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::FacePhone), this);
0AA8: call_method_return 0x4D3CC0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Fall

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Fall), this);
0AA6: call_method 0x4D0BC0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Fight

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Fight), this);
0AA6: call_method 0x4E7EE0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::FightStrike

<pre>
plugin::CallMethodDynGlobal<CPed *, CVector &>(gaddrof(CPed::FightStrike), this, touchedNodePos);
0AA6: call_method 0x4E8EC0 struct [CPed] num_params 1 pop 0 [touchedNodePos]
</pre>

#### CPed::FindBestCoordsFromNodes

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector, CVector *>(gaddrof(CPed::FindBestCoordsFromNodes), this, unused, bestCoords);
0AA8: call_method_return 0x4E3A90 struct [CPed] num_params 2 pop 0 [unused] [bestCoords] func_ret [bool]
</pre>

#### CPed::Flee

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Flee), this);
0AA6: call_method 0x4D1ED0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::FollowPath

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::FollowPath), this);
0AA6: call_method 0x4D3020 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ForceStoredObjective

<pre>
plugin::CallMethodDynGlobal<CPed *, eObjective>(gaddrof(CPed::ForceStoredObjective), this, objective);
0AA6: call_method 0x4D8250 struct [CPed] num_params 1 pop 0 [objective]
</pre>

#### \*CPed::GetFormationPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<CVector *, CPed *>(gaddrof(CPed::GetFormationPosition), this);
0AA8: call_method_return 0x4DF420 struct [*CPed] num_params 0 pop 0 func_ret [CVector *]
</pre>

#### CPed::GetLocalDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPed *, CVector2D const &>(gaddrof(CPed::GetLocalDirection), this, posOffset);
0AA8: call_method_return 0x4CCE20 struct [CPed] num_params 1 pop 0 [posOffset] func_ret [int]
</pre>

#### CPed::GetNearestDoor

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestDoor), this, vehicle, posToOpen);
0AA6: call_method 0x4E1CF0 struct [CPed] num_params 2 pop 0 [vehicle] [posToOpen]
</pre>

#### CPed::GetNearestPassengerDoor

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestPassengerDoor), this, vehicle, posToOpen);
0AA8: call_method_return 0x4E1F30 struct [CPed] num_params 2 pop 0 [vehicle] [posToOpen] func_ret [bool]
</pre>

#### CPed::GetNearestTrainDoor

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestTrainDoor), this, vehicle, doorPos);
0AA8: call_method_return 0x4E2D70 struct [CPed] num_params 2 pop 0 [vehicle] [doorPos] func_ret [bool]
</pre>

#### CPed::GetNearestTrainPedPosition

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestTrainPedPosition), this, vehicle, enterPos);
0AA6: call_method 0x4E2E50 struct [CPed] num_params 2 pop 0 [vehicle] [enterPos]
</pre>

#### CPed::GetNextPointOnRoute

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPed *>(gaddrof(CPed::GetNextPointOnRoute), this);
0AA8: call_method_return 0x4DD720 struct [CPed] num_params 0 pop 0 func_ret [short]
</pre>

#### CPed::GetPedRadioCategory

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, unsigned int>(gaddrof(CPed::GetPedRadioCategory), this, modelIndex);
0AA8: call_method_return 0x4D7B50 struct [CPed] num_params 1 pop 0 [modelIndex] func_ret [unsigned char]
</pre>

#### CPed::GetWeaponSlot

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPed *, eWeaponType>(gaddrof(CPed::GetWeaponSlot), this, type);
0AA8: call_method_return 0x4CFA40 struct [CPed] num_params 1 pop 0 [type] func_ret [int]
</pre>

#### CPed::GiveWeapon

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CPed *, eWeaponType, unsigned int>(gaddrof(CPed::GiveWeapon), this, type, ammo);
0AA8: call_method_return 0x4CF9B0 struct [CPed] num_params 2 pop 0 [type] [ammo] func_ret [unsigned int]
</pre>

#### CPed::GoToNearestDoor

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::GoToNearestDoor), this, vehicle);
0AA6: call_method 0x4E2220 struct [CPed] num_params 1 pop 0 [vehicle]
</pre>

#### CPed::GrantAmmo

<pre>
plugin::CallMethodDynGlobal<CPed *, eWeaponType, unsigned int>(gaddrof(CPed::GrantAmmo), this, type, ammo);
0AA6: call_method 0x4CFAD0 struct [CPed] num_params 2 pop 0 [type] [ammo]
</pre>

#### CPed::HaveReachedNextPointOnRoute

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, float>(gaddrof(CPed::HaveReachedNextPointOnRoute), this, distToCountReached);
0AA8: call_method_return 0x4DD7B0 struct [CPed] num_params 1 pop 0 [distToCountReached] func_ret [bool]
</pre>

#### CPed::Idle

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Idle), this);
0AA6: call_method 0x4D0690 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::InTheAir

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::InTheAir), this);
0AA6: call_method 0x4D0D10 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::InflictDamage

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *, eWeaponType, float, ePedPieceTypes, unsigned char>(gaddrof(CPed::InflictDamage), this, damagedBy, type, damage, pedPiece, direction);
0AA8: call_method_return 0x4EA420 struct [CPed] num_params 5 pop 0 [damagedBy] [type] [damage] [pedPiece] [direction] func_ret [bool]
</pre>

#### CPed::InformMyGangOfAttack

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::InformMyGangOfAttack), this, attacker);
0AA6: call_method 0x4E4AD0 struct [CPed] num_params 1 pop 0 [attacker]
</pre>

#### CPed::InvestigateEvent

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::InvestigateEvent), this);
0AA6: call_method 0x4E9B50 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::IsGangMember

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsGangMember), this);
0AA8: call_method_return 0x4D4910 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPedHeadAbovePos

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, float>(gaddrof(CPed::IsPedHeadAbovePos), this, zOffset);
0AA8: call_method_return 0x4EB670 struct [CPed] num_params 1 pop 0 [zOffset] func_ret [bool]
</pre>

#### CPed::IsPedInControl

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPedInControl), this);
0AA8: call_method_return 0x4CE6C0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPedShootable

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPedShootable), this);
0AA8: call_method_return 0x4CE710 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPlayer

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPlayer), this);
0AA8: call_method_return 0x4D48E0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPointerValid

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPointerValid), this);
0AA8: call_method_return 0x4D4930 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsRoomToBeCarJacked

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsRoomToBeCarJacked), this);
0AA8: call_method_return 0x4E4D90 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsTemporaryObjective

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, eObjective>(gaddrof(CPed::IsTemporaryObjective), this, objective);
0AA8: call_method_return 0x4D8290 struct [CPed] num_params 1 pop 0 [objective] func_ret [bool]
</pre>

#### CPed::KillPedWithCar

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, float>(gaddrof(CPed::KillPedWithCar), this, vehicle, impulse);
0AA6: call_method 0x4EC430 struct [CPed] num_params 2 pop 0 [vehicle] [impulse]
</pre>

#### CPed::LineUpPedWithCar

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::LineUpPedWithCar), this, phase);
0AA6: call_method 0x4DF940 struct [CPed] num_params 1 pop 0 [phase]
</pre>

#### CPed::LineUpPedWithTrain

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LineUpPedWithTrain), this);
0AA6: call_method 0x4E33D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Look

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Look), this);
0AA6: call_method 0x4D1380 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::LookForInterestingNodes

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::LookForInterestingNodes), this);
0AA8: call_method_return 0x4D5040 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::LookForSexyCars

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LookForSexyCars), this);
0AA6: call_method 0x4D4F50 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::LookForSexyPeds

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LookForSexyPeds), this);
0AA6: call_method 0x4D4DF0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::MakePhonecall

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::MakePhonecall), this);
0AA8: call_method_return 0x4D3E20 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::MoveHeadToLook

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::MoveHeadToLook), this);
0AA6: call_method 0x4C65B0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Mug

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Mug), this);
0AA6: call_method 0x4D11D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::OurPedCanSeeThisOne

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *>(gaddrof(CPed::OurPedCanSeeThisOne), this, entity);
0AA8: call_method_return 0x4C5700 struct [CPed] num_params 1 pop 0 [entity] func_ret [bool]
</pre>

#### CPed::Pause

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Pause), this);
0AA6: call_method 0x4D0980 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PlacePedOnDryLand

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::PlacePedOnDryLand), this);
0AA8: call_method_return 0x4EB6E0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::PlayFootSteps

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::PlayFootSteps), this);
0AA6: call_method 0x4CC6C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PlayHitSound

<pre>
plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::PlayHitSound), this, hitTo);
0AA6: call_method 0x4E8E20 struct [CPed] num_params 1 pop 0 [hitTo]
</pre>

#### CPed::PointGunAt

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::PointGunAt), this);
0AA6: call_method 0x4E60B0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PositionPedOutOfCollision

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::PositionPedOutOfCollision), this);
0AA8: call_method_return 0x4E4F30 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::PossiblyFindBetterPosToSeekCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector *, CVehicle *>(gaddrof(CPed::PossiblyFindBetterPosToSeekCar), this, pos, vehicle);
0AA8: call_method_return 0x4D6A00 struct [CPed] num_params 2 pop 0 [pos] [vehicle] func_ret [bool]
</pre>

#### CPed::ProcessBuoyancy

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ProcessBuoyancy), this);
0AA6: call_method 0x4C7FF0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ProcessObjective

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ProcessObjective), this);
0AA6: call_method 0x4D94E0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::QuitEnteringCar

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::QuitEnteringCar), this);
0AA6: call_method 0x4E0E00 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ReactToAttack

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::ReactToAttack), this, attacker);
0AA6: call_method 0x4DDEC0 struct [CPed] num_params 1 pop 0 [attacker]
</pre>

#### CPed::ReactToPointGun

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::ReactToPointGun), this, entWithGun);
0AA6: call_method 0x4DD980 struct [CPed] num_params 1 pop 0 [entWithGun]
</pre>

#### CPed::RegisterThreatWithGangPeds

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::RegisterThreatWithGangPeds), this, attacker);
0AA6: call_method 0x4E3870 struct [CPed] num_params 1 pop 0 [attacker]
</pre>

#### CPed::RemoveBodyPart

<pre>
plugin::CallMethodDynGlobal<CPed *, int, char>(gaddrof(CPed::RemoveBodyPart), this, nodeId, direction);
0AA6: call_method 0x4EAEE0 struct [CPed] num_params 2 pop 0 [nodeId] [direction]
</pre>

#### CPed::RemoveInCarAnims

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RemoveInCarAnims), this);
0AA6: call_method 0x4E4E20 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RemoveWeaponModel

<pre>
plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::RemoveWeaponModel), this, modelIndex);
0AA6: call_method 0x4CF980 struct [CPed] num_params 1 pop 0 [modelIndex]
</pre>

#### CPed::RestartNonPartialAnims

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestartNonPartialAnims), this);
0AA6: call_method 0x4C5D80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestoreGunPosition

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreGunPosition), this);
0AA6: call_method 0x4C6BB0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestoreHeadPosition

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreHeadPosition), this);
0AA6: call_method 0x4C6930 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestoreHeadingRate

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreHeadingRate), this);
0AA6: call_method 0x4D6540 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestorePreviousObjective

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestorePreviousObjective), this);
0AA6: call_method 0x4D9460 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestorePreviousState

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestorePreviousState), this);
0AA6: call_method 0x4C5E30 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RunToReportCrime

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, eCrimeType>(gaddrof(CPed::RunToReportCrime), this, type);
0AA8: call_method_return 0x4C10C0 struct [CPed] num_params 1 pop 0 [type] func_ret [bool]
</pre>

#### CPed::Say

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned short>(gaddrof(CPed::Say), this, audio);
0AA6: call_method 0x4E5A10 struct [CPed] num_params 1 pop 0 [audio]
</pre>

#### CPed::ScanForInterestingStuff

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ScanForInterestingStuff), this);
0AA6: call_method 0x4C6C10 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ScanForThreats

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CPed *>(gaddrof(CPed::ScanForThreats), this);
0AA8: call_method_return 0x4C5FE0 struct [CPed] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CPed::Seek

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::Seek), this);
0AA8: call_method_return 0x4D1640 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::SeekBoatPosition

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SeekBoatPosition), this);
0AA6: call_method 0x4E4C70 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SeekCar

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SeekCar), this);
0AA6: call_method 0x4D3F90 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SeekFollowingPath

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector *>(gaddrof(CPed::SeekFollowingPath), this, unused);
0AA8: call_method_return 0x4D2E70 struct [CPed] num_params 1 pop 0 [unused] func_ret [bool]
</pre>

#### CPed::SelectGunIfArmed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::SelectGunIfArmed), this);
0AA8: call_method_return 0x4DD920 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::ServiceTalking

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ServiceTalking), this);
0AA6: call_method 0x4E5870 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ServiceTalkingWhenDead

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::ServiceTalkingWhenDead), this);
0AA8: call_method_return 0x4E5850 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::SetAimFlag

<pre>
plugin::CallMethodDynGlobal<CPed *, float>(gaddrof_o(CPed::SetAimFlag, void (CPed::*)(float)), this, direction);
0AA6: call_method 0x4C69E0 struct [CPed] num_params 1 pop 0 [direction]
</pre>

#### CPed::SetAimFlag

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof_o(CPed::SetAimFlag, void (CPed::*)(CEntity *)), this, entity);
0AA6: call_method 0x4C69E0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetAmmo

<pre>
plugin::CallMethodDynGlobal<CPed *, eWeaponType, unsigned int>(gaddrof(CPed::SetAmmo), this, type, ammo);
0AA6: call_method 0x4CFB20 struct [CPed] num_params 2 pop 0 [type] [ammo]
</pre>

#### CPed::SetAttack

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetAttack), this, victim);
0AA6: call_method 0x4E6220 struct [CPed] num_params 1 pop 0 [victim]
</pre>

#### CPed::SetAttackTimer

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetAttackTimer), this, time);
0AA6: call_method 0x4D1300 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetBeingDraggedFromCar

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, bool>(gaddrof(CPed::SetBeingDraggedFromCar), this, vehicle, doorNode, quickJack);
0AA6: call_method 0x4E0640 struct [CPed] num_params 3 pop 0 [vehicle] [doorNode] [quickJack]
</pre>

#### CPed::SetBuyIceCream

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetBuyIceCream), this);
0AA6: call_method 0x4D6950 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetCarJack

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetCarJack), this, vehicle);
0AA6: call_method 0x4E0220 struct [CPed] num_params 1 pop 0 [vehicle]
</pre>

#### CPed::SetCarJack_AllClear

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, unsigned int>(gaddrof(CPed::SetCarJack_AllClear), this, vehicle, doorNode, doorFlag);
0AA6: call_method 0x4E03F0 struct [CPed] num_params 3 pop 0 [vehicle] [doorNode] [doorFlag]
</pre>

#### CPed::SetChat

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *, unsigned int>(gaddrof(CPed::SetChat), this, chatWith, time);
0AA6: call_method 0x4D3A60 struct [CPed] num_params 2 pop 0 [chatWith] [time]
</pre>

#### CPed::SetCurrentWeapon

<pre>
plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::SetCurrentWeapon), this, type);
0AA6: call_method 0x4CFA60 struct [CPed] num_params 1 pop 0 [type]
</pre>

#### CPed::SetDead

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetDead), this);
0AA6: call_method 0x4D3970 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetDie

<pre>
plugin::CallMethodDynGlobal<CPed *, int, float, float>(gaddrof(CPed::SetDie), this, animId, delta, speed);
0AA6: call_method 0x4D37D0 struct [CPed] num_params 3 pop 0 [animId] [delta] [speed]
</pre>

#### CPed::SetDirectionToWalkAroundObject

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetDirectionToWalkAroundObject), this, entity);
0AA6: call_method 0x4CCEB0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetDuck

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetDuck), this, time);
0AA6: call_method 0x4E4920 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetEnterCar

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetEnterCar), this, vehicle, unused);
0AA6: call_method 0x4E0920 struct [CPed] num_params 2 pop 0 [vehicle] [unused]
</pre>

#### CPed::SetEnterCar_AllClear

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, unsigned int>(gaddrof(CPed::SetEnterCar_AllClear), this, vehicle, doorNode, doorFlag);
0AA6: call_method 0x4E0A40 struct [CPed] num_params 3 pop 0 [vehicle] [doorNode] [doorFlag]
</pre>

#### CPed::SetEnterTrain

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetEnterTrain), this, train, unused);
0AA6: call_method 0x4E32D0 struct [CPed] num_params 2 pop 0 [train] [unused]
</pre>

#### CPed::SetEvasiveDive

<pre>
plugin::CallMethodDynGlobal<CPed *, CPhysical *, unsigned char>(gaddrof(CPed::SetEvasiveDive), this, reason, onlyRandomJump);
0AA6: call_method 0x4D33A0 struct [CPed] num_params 2 pop 0 [reason] [onlyRandomJump]
</pre>

#### CPed::SetEvasiveStep

<pre>
plugin::CallMethodDynGlobal<CPed *, CPhysical *, unsigned char>(gaddrof(CPed::SetEvasiveStep), this, reason, animType);
0AA6: call_method 0x4D30C0 struct [CPed] num_params 2 pop 0 [reason] [animType]
</pre>

#### CPed::SetExitCar

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetExitCar), this, vehicle, doorNode);
0AA6: call_method 0x4E1010 struct [CPed] num_params 2 pop 0 [vehicle] [doorNode]
</pre>

#### CPed::SetExitTrain

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetExitTrain), this, train);
0AA6: call_method 0x4E3640 struct [CPed] num_params 1 pop 0 [train]
</pre>

#### CPed::SetFall

<pre>
plugin::CallMethodDynGlobal<CPed *, int, int, unsigned char>(gaddrof(CPed::SetFall), this, extraTime, animId, evenIfNotInControl);
0AA6: call_method 0x4D09B0 struct [CPed] num_params 3 pop 0 [extraTime] [animId] [evenIfNotInControl]
</pre>

#### CPed::SetFlee

<pre>
plugin::CallMethodDynGlobal<CPed *, CVector2D const &, int>(gaddrof_o(CPed::SetFlee, void (CPed::*)(CVector2D const &, int)), this, from, time);
0AA6: call_method 0x4D1D70 struct [CPed] num_params 2 pop 0 [from] [time]
</pre>

#### CPed::SetFlee

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *, int>(gaddrof_o(CPed::SetFlee, void (CPed::*)(CEntity *, int)), this, fleeFrom, time);
0AA6: call_method 0x4D1D70 struct [CPed] num_params 2 pop 0 [fleeFrom] [time]
</pre>

#### CPed::SetFollowPath

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector>(gaddrof(CPed::SetFollowPath), this, dest);
0AA8: call_method_return 0x4D2EA0 struct [CPed] num_params 1 pop 0 [dest] func_ret [bool]
</pre>

#### CPed::SetFollowRoute

<pre>
plugin::CallMethodDynGlobal<CPed *, short, short>(gaddrof(CPed::SetFollowRoute), this, currentPoint, routeType);
0AA6: call_method 0x4DD690 struct [CPed] num_params 2 pop 0 [currentPoint] [routeType]
</pre>

#### CPed::SetFormation

<pre>
plugin::CallMethodDynGlobal<CPed *, eFormation>(gaddrof(CPed::SetFormation), this, formation);
0AA6: call_method 0x4DF3E0 struct [CPed] num_params 1 pop 0 [formation]
</pre>

#### CPed::SetGetUp

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetGetUp), this);
0AA6: call_method 0x4D0F20 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetIdle

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetIdle), this);
0AA6: call_method 0x4D0600 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetInTheAir

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetInTheAir), this);
0AA6: call_method 0x4D0CA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetInvestigateEvent

<pre>
plugin::CallMethodDynGlobal<CPed *, eEventType, CVector2D, float, unsigned short, float>(gaddrof(CPed::SetInvestigateEvent), this, type, pos, distanceToCountDone, time, angle);
0AA6: call_method 0x4E9A80 struct [CPed] num_params 5 pop 0 [type] [pos] [distanceToCountDone] [time] [angle]
</pre>

#### CPed::SetJump

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetJump), this);
0AA6: call_method 0x4D73D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetLanding

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetLanding), this);
0AA6: call_method 0x4D0E40 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetLeader

<pre>
plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::SetLeader), this, leader);
0AA6: call_method 0x4D72C0 struct [CPed] num_params 1 pop 0 [leader]
</pre>

#### CPed::SetLookFlag

<pre>
plugin::CallMethodDynGlobal<CPed *, float, bool>(gaddrof_o(CPed::SetLookFlag, void (CPed::*)(float, bool)), this, direction, keepTryingToLook);
0AA6: call_method 0x4C6460 struct [CPed] num_params 2 pop 0 [direction] [keepTryingToLook]
</pre>

#### CPed::SetLookFlag

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *, bool>(gaddrof_o(CPed::SetLookFlag, void (CPed::*)(CEntity *, bool)), this, target, keepTryingToLook);
0AA6: call_method 0x4C6460 struct [CPed] num_params 2 pop 0 [target] [keepTryingToLook]
</pre>

#### CPed::SetLookTimer

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetLookTimer), this, time);
0AA6: call_method 0x4D12E0 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetMoveState

<pre>
plugin::CallMethodDynGlobal<CPed *, eMoveState>(gaddrof(CPed::SetMoveState), this, state);
0AA6: call_method 0x4C5A30 struct [CPed] num_params 1 pop 0 [state]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethodDynGlobal<CPed *, eObjective>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective)), this, objective);
0AA6: call_method 0x4D8A90 struct [CPed] num_params 1 pop 0 [objective]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethodDynGlobal<CPed *, eObjective, void *>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, void *)), this, objective, entity);
0AA6: call_method 0x4D8A90 struct [CPed] num_params 2 pop 0 [objective] [entity]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethodDynGlobal<CPed *, eObjective, CVector, float>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, CVector, float)), this, objective, dest, safeDist);
0AA6: call_method 0x4D8A90 struct [CPed] num_params 3 pop 0 [objective] [dest] [safeDist]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethodDynGlobal<CPed *, eObjective, short, short>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, short, short)), this, objective, routePoint, routeType);
0AA6: call_method 0x4D8A90 struct [CPed] num_params 3 pop 0 [objective] [routePoint] [routeType]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethodDynGlobal<CPed *, eObjective, CVector>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, CVector)), this, objective, dest);
0AA6: call_method 0x4D8A90 struct [CPed] num_params 2 pop 0 [objective] [dest]
</pre>

#### CPed::SetObjectiveTimer

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetObjectiveTimer), this, time);
0AA6: call_method 0x4D81E0 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetPedPositionInCar

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetPedPositionInCar), this);
0AA6: call_method 0x4D4970 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetPedPositionInTrain

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetPedPositionInTrain), this);
0AA6: call_method 0x4E33C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetPedStats

<pre>
plugin::CallMethodDynGlobal<CPed *, ePedStats>(gaddrof(CPed::SetPedStats), this, stat);
0AA6: call_method 0x4C5330 struct [CPed] num_params 1 pop 0 [stat]
</pre>

#### CPed::SetPointGunAt

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetPointGunAt), this, entity);
0AA6: call_method 0x4E5F70 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetRadioStation

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetRadioStation), this);
0AA6: call_method 0x4D7BC0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetSeek

<pre>
plugin::CallMethodDynGlobal<CPed *, CVector, float>(gaddrof_o(CPed::SetSeek, void (CPed::*)(CVector, float)), this, pos, distanceToCountDone);
0AA6: call_method 0x4D15A0 struct [CPed] num_params 2 pop 0 [pos] [distanceToCountDone]
</pre>

#### CPed::SetSeek

<pre>
plugin::CallMethodDynGlobal<CPed *, CEntity *, float>(gaddrof_o(CPed::SetSeek, void (CPed::*)(CEntity *, float)), this, seeking, distanceToCountDone);
0AA6: call_method 0x4D15A0 struct [CPed] num_params 2 pop 0 [seeking] [distanceToCountDone]
</pre>

#### CPed::SetSeekBoatPosition

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetSeekBoatPosition), this, boat);
0AA6: call_method 0x4E4C00 struct [CPed] num_params 1 pop 0 [boat]
</pre>

#### CPed::SetSeekCar

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetSeekCar), this, vehicle, doorNode);
0AA6: call_method 0x4D3EF0 struct [CPed] num_params 2 pop 0 [vehicle] [doorNode]
</pre>

#### CPed::SetShootTimer

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetShootTimer), this, time);
0AA6: call_method 0x4D1340 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetSolicit

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetSolicit), this, time);
0AA6: call_method 0x4D6620 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetStoredObjective

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetStoredObjective), this);
0AA6: call_method 0x4D8220 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetStoredState

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetStoredState), this);
0AA6: call_method 0x4C5DB0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetWaitState

<pre>
plugin::CallMethodDynGlobal<CPed *, eWaitState, void *>(gaddrof(CPed::SetWaitState), this, state, time);
0AA6: call_method 0x4D58D0 struct [CPed] num_params 2 pop 0 [state] [time]
</pre>

#### CPed::SetWanderPath

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, char>(gaddrof(CPed::SetWanderPath), this, pathStateDest);
0AA8: call_method_return 0x4D2750 struct [CPed] num_params 1 pop 0 [pathStateDest] func_ret [bool]
</pre>

#### CPed::Solicit

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Solicit), this);
0AA6: call_method 0x4D6780 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SortPeds

<pre>
plugin::CallMethodDynGlobal<CPed *, CPed **, int, int>(gaddrof(CPed::SortPeds), this, list, min, max);
0AA6: call_method 0x4C57F0 struct [CPed] num_params 3 pop 0 [list] [min] [max]
</pre>

#### CPed::SpawnFlyingComponent

<pre>
plugin::CallMethodDynGlobal<CPed *, int, char>(gaddrof(CPed::SpawnFlyingComponent), this, nodeId, direction);
0AA6: call_method 0x4EB060 struct [CPed] num_params 2 pop 0 [nodeId] [direction]
</pre>

#### CPed::StartFightAttack

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned char>(gaddrof(CPed::StartFightAttack), this, buttonPressure);
0AA6: call_method 0x4E7530 struct [CPed] num_params 1 pop 0 [buttonPressure]
</pre>

#### CPed::StartFightDefend

<pre>
plugin::CallMethodDynGlobal<CPed *, unsigned char, unsigned char, unsigned char>(gaddrof(CPed::StartFightDefend), this, direction, hitLevel, strength);
0AA6: call_method 0x4E7780 struct [CPed] num_params 3 pop 0 [direction] [hitLevel] [strength]
</pre>

#### CPed::StopNonPartialAnims

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::StopNonPartialAnims), this);
0AA6: call_method 0x4C5D50 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::TurnBody

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::TurnBody), this);
0AA8: call_method_return 0x4D1390 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::UpdateFromLeader

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::UpdateFromLeader), this);
0AA6: call_method 0x4D8F30 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::UpdatePosition

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::UpdatePosition), this);
0AA6: call_method 0x4C7A00 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::UseGroundColModel

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::UseGroundColModel), this);
0AA8: call_method_return 0x4CE730 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Wait

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Wait), this);
0AA6: call_method 0x4D5D80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::WanderPath

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::WanderPath), this);
0AA6: call_method 0x4D28D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::WanderRange

<pre>
plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::WanderRange), this);
0AA6: call_method 0x4D26C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::WarpPedIntoCar

<pre>
plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::WarpPedIntoCar), this, vehicle);
0AA6: call_method 0x4D7D20 struct [CPed] num_params 1 pop 0 [vehicle]
</pre>

#### CPed::WarpPedToNearEntityOffScreen

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *>(gaddrof(CPed::WarpPedToNearEntityOffScreen), this, warpTo);
0AA8: call_method_return 0x4E5570 struct [CPed] num_params 1 pop 0 [warpTo] func_ret [bool]
</pre>

#### CPed::WarpPedToNearLeaderOffScreen

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::WarpPedToNearLeaderOffScreen), this);
0AA8: call_method_return 0x4E52A0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::WillChat

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CPed *>(gaddrof(CPed::WillChat), this, stranger);
0AA8: call_method_return 0x4C7340 struct [CPed] num_params 1 pop 0 [stranger] func_ret [bool]
</pre>

#### CPed::WorkOutHeadingForMovingFirstPerson

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CPed *, float>(gaddrof(CPed::WorkOutHeadingForMovingFirstPerson), this, offset);
0AA8: call_method_return 0x4C78F0 struct [CPed] num_params 1 pop 0 [offset] func_ret [float]
</pre>

#### CPed::FinishDieAnimCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishDieAnimCB), association, data);
</pre>

#### CPed::FinishFightMoveCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishFightMoveCB), association, data);
</pre>

#### CPed::FinishHitHeadCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishHitHeadCB), association, data);
</pre>

#### CPed::FinishJumpCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishJumpCB), association, data);
</pre>

#### CPed::FinishLaunchCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishLaunchCB), association, data);
</pre>

#### CPed::FinishedAttackCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishedAttackCB), association, data);
</pre>

#### CPed::FinishedWaitCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishedWaitCB), association, data);
</pre>

#### CPed::PedAnimAlignCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimAlignCB), association, data);
</pre>

#### CPed::PedAnimDoorCloseCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorCloseCB), association, data);
</pre>

#### CPed::PedAnimDoorCloseRollingCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorCloseRollingCB), association, data);
</pre>

#### CPed::PedAnimDoorOpenCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorOpenCB), association, data);
</pre>

#### CPed::PedAnimGetInCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimGetInCB), association, data);
</pre>

#### CPed::PedAnimPullPedOutCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimPullPedOutCB), association, data);
</pre>

#### CPed::PedAnimStepOutCarCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimStepOutCarCB), association, data);
</pre>

#### CPed::PedEvadeCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedEvadeCB), association, data);
</pre>

#### CPed::PedGetupCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedGetupCB), association, data);
</pre>

#### CPed::PedLandCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedLandCB), association, data);
</pre>

#### CPed::PedSetDraggedOutCarCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetDraggedOutCarCB), association, data);
</pre>

#### CPed::PedSetDraggedOutCarPositionCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetDraggedOutCarPositionCB), association, data);
</pre>

#### CPed::PedSetInCarCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetInCarCB), association, data);
</pre>

#### CPed::PedSetInTrainCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetInTrainCB), association, data);
</pre>

#### CPed::PedSetOutCarCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetOutCarCB), association, data);
</pre>

#### CPed::PedSetOutTrainCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetOutTrainCB), association, data);
</pre>

#### CPed::PedSetQuickDraggedOutCarPositionCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetQuickDraggedOutCarPositionCB), association, data);
</pre>

#### CPed::PedStaggerCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedStaggerCB), association, data);
</pre>

#### CPed::RestoreHeadingRateCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::RestoreHeadingRateCB), association, data);
</pre>

#### FinishFuckUCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(FinishFuckUCB), anim, data);
</pre>

#### particleProduceFootSplash

<pre>
plugin::CallDynGlobal<CPed *, CVector const &, float, int>(gaddrof(particleProduceFootSplash), ped, pos, size, times);
</pre>

#### particleProduceFootDust

<pre>
plugin::CallDynGlobal<CPed *, CVector const &, float, int>(gaddrof(particleProduceFootDust), ped, pos, size, times);
</pre>

#### \*RemoveAllModelCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(RemoveAllModelCB), object, data);
</pre>

#### AddYardieDoorSmoke

<pre>
plugin::CallDynGlobal<CVehicle *, unsigned int>(gaddrof(AddYardieDoorSmoke), vehicle, doorNode);
</pre>

#### CheckForPedsOnGroundToAttack

<pre>
plugin::CallAndReturnDynGlobal<int, CPed *, CPed **>(gaddrof(CheckForPedsOnGroundToAttack), attacker, pedOnGround);
</pre>

#### \*SetPedAtomicVisibilityCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(SetPedAtomicVisibilityCB), object, data);
</pre>

#### \*RecurseFrameChildrenVisibilityCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(RecurseFrameChildrenVisibilityCB), frame, data);
</pre>

#### \*CloneAtomicToFrameCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CloneAtomicToFrameCB), object, data);
</pre>

#### \*RecurseFrameChildrenToCloneCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(RecurseFrameChildrenToCloneCB), frame, data);
</pre>

### plugin_III\game_III\CPedIK.cpp

#### CPedIK::ExtractYawAndPitchLocal

<pre>
plugin::CallMethodDynGlobal<CPedIK *, RwMatrix *, float *, float *>(gaddrof(CPedIK::ExtractYawAndPitchLocal), this, matrix, yaw, pitch);
0AA6: call_method 0x4ED2C0 struct [CPedIK] num_params 3 pop 0 [matrix] [yaw] [pitch]
</pre>

#### CPedIK::ExtractYawAndPitchWorld

<pre>
plugin::CallMethodDynGlobal<CPedIK *, RwMatrix *, float *, float *>(gaddrof(CPedIK::ExtractYawAndPitchWorld), this, matrix, yaw, pitch);
0AA6: call_method 0x4ED140 struct [CPedIK] num_params 3 pop 0 [matrix] [yaw] [pitch]
</pre>

#### CPedIK::GetComponentPosition

<pre>
plugin::CallMethodDynGlobal<CPedIK *, RwV3d &, unsigned int>(gaddrof(CPedIK::GetComponentPosition), this, pos, node);
0AA6: call_method 0x4ED0F0 struct [CPedIK] num_params 2 pop 0 [pos] [node]
</pre>

#### CPedIK::Init

<pre>
plugin::CallMethodDynGlobal<CPedIK *, CPed *>(gaddrof(CPedIK::Init), this, ped);
0AA6: call_method 0x4ED010 struct [CPedIK] num_params 1 pop 0 [ped]
</pre>

#### CPedIK::LookAtPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, CVector const &>(gaddrof(CPedIK::LookAtPosition), this, pos);
0AA8: call_method_return 0x4ED590 struct [CPedIK] num_params 1 pop 0 [pos] func_ret [bool]
</pre>

#### CPedIK::LookInDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::LookInDirection), this, targetYaw, targetPitch);
0AA8: call_method_return 0x4ED620 struct [CPedIK] num_params 2 pop 0 [targetYaw] [targetPitch] func_ret [bool]
</pre>

#### CPedIK::MoveLimb

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CPedIK *, LimbOrientation &, float, float, LimbMovementInfo &>(gaddrof(CPedIK::MoveLimb), this, limb, targetYaw, targetPitch, moveInfo);
0AA8: call_method_return 0x4ED440 struct [CPedIK] num_params 4 pop 0 [limb] [targetYaw] [targetPitch] [moveInfo] func_ret [unsigned int]
</pre>

#### CPedIK::PointGunAtPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, CVector const &>(gaddrof(CPedIK::PointGunAtPosition), this, pos);
0AA8: call_method_return 0x4ED920 struct [CPedIK] num_params 1 pop 0 [pos] func_ret [bool]
</pre>

#### CPedIK::PointGunInDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::PointGunInDirection), this, targetYaw, targetPitch);
0AA8: call_method_return 0x4ED9B0 struct [CPedIK] num_params 2 pop 0 [targetYaw] [targetPitch] func_ret [bool]
</pre>

#### CPedIK::PointGunInDirectionUsingArm

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::PointGunInDirectionUsingArm), this, targetYaw, targetPitch);
0AA8: call_method_return 0x4EDB20 struct [CPedIK] num_params 2 pop 0 [targetYaw] [targetPitch] func_ret [bool]
</pre>

#### CPedIK::RestoreGunPosn

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *>(gaddrof(CPedIK::RestoreGunPosn), this);
0AA8: call_method_return 0x4EDD70 struct [CPedIK] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIK::RestoreLookAt

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *>(gaddrof(CPedIK::RestoreLookAt), this);
0AA8: call_method_return 0x4ED810 struct [CPedIK] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIK::RotateTorso

<pre>
plugin::CallMethodDynGlobal<CPedIK *, AnimBlendFrameData *, LimbOrientation &, bool>(gaddrof(CPedIK::RotateTorso), this, frameData, limb, changeRoll);
0AA6: call_method 0x4EDDB0 struct [CPedIK] num_params 3 pop 0 [frameData] [limb] [changeRoll]
</pre>

#### \*CPedIK::GetWorldMatrix

<pre>
plugin::CallAndReturnDynGlobal<RwMatrix *, RwFrame *, RwMatrix *>(gaddrof(CPedIK::GetWorldMatrix), frame, matrix);
</pre>

### plugin_III\game_III\CPedModelInfo.cpp

#### CPedModelInfo::DeleteRwObject

<pre>
plugin::CallVirtualMethod<2, CPedModelInfo *>(this);
</pre>

#### CPedModelInfo::SetClump

<pre>
plugin::CallVirtualMethod<6, CPedModelInfo *, RpClump *>(this, clump);
</pre>

#### CPedModelInfo::CreateHitColModel

<pre>
plugin::CallMethodDynGlobal<CPedModelInfo *>(gaddrof(CPedModelInfo::CreateHitColModel), this);
0AA6: call_method 0x5104D0 struct [CPedModelInfo] num_params 0 pop 0
</pre>

#### CPedModelInfo::SetLowDetailClump

<pre>
plugin::CallMethodDynGlobal<CPedModelInfo *, RpClump *>(gaddrof(CPedModelInfo::SetLowDetailClump), this, clump);
0AA6: call_method 0x510390 struct [CPedModelInfo] num_params 1 pop 0 [clump]
</pre>

### plugin_III\game_III\CPedPath.cpp

#### CPedPath::AddBlockade

<pre>
plugin::CallDynGlobal<CEntity *, CPedPathNode(*)[40], CVector *>(gaddrof(CPedPath::AddBlockade), entity, pathNodes, posn);
</pre>

#### CPedPath::AddBlockadeSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, CPedPathNode(*)[40], CVector *>(gaddrof(CPedPath::AddBlockadeSectorList), list, pathNodes, posn);
</pre>

#### CPedPath::AddNodeToList

<pre>
plugin::CallDynGlobal<CPedPathNode *, short, CPedPathNode *>(gaddrof(CPedPath::AddNodeToList), pNode, index, pList);
</pre>

#### CPedPath::AddNodeToPathList

<pre>
plugin::CallDynGlobal<CPedPathNode *, short, CPedPathNode *>(gaddrof(CPedPath::AddNodeToPathList), pNode, index, pNodeList);
</pre>

#### CPedPath::CalcPedRoute

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned char, CVector, CVector, CVector *, short *, short>(gaddrof(CPedPath::CalcPedRoute), pathType, position, destination, pointPoses, pointsFound, maxPoints);
</pre>

#### CPedPath::RemoveNodeFromList

<pre>
plugin::CallDynGlobal<CPedPathNode *>(gaddrof(CPedPath::RemoveNodeFromList), node);
</pre>

### plugin_III\game_III\CPedPlacement.cpp

#### CPedPlacement::FindZCoorForPed

<pre>
plugin::CallDynGlobal<CVector *>(gaddrof(CPedPlacement::FindZCoorForPed), position);
</pre>

#### CPedPlacement::IsPositionClearForPed

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPedPlacement::IsPositionClearForPed), position);
</pre>

#### \*CPedPlacement::IsPositionClearOfCars

<pre>
plugin::CallAndReturnDynGlobal<CEntity *, CVector *>(gaddrof(CPedPlacement::IsPositionClearOfCars), position);
</pre>

### plugin_III\game_III\CPedStats.cpp

#### CPedStats::GetPedStatType

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, char *>(gaddrof(CPedStats::GetPedStatType), name);
</pre>

### plugin_III\game_III\CPedType.cpp

#### CPedType::FindPedFlag

<pre>
plugin::CallAndReturn<unsigned int, 0x4EEF40, char*>(flagName);
0AA7: call_function_return 0x4EEF40 num_params 1 pop 1 [flagName] func_ret [unsigned int]
</pre>

#### CPedType::FindPedType

<pre>
plugin::CallAndReturn<unsigned int, 0x4EEC10, char*>(pedName);
0AA7: call_function_return 0x4EEC10 num_params 1 pop 1 [pedName] func_ret [unsigned int]
</pre>

#### CPedType::Initialise

<pre>
plugin::Call<0x4EE7E0>();
0AA5: call_function 0x4EE7E0 num_params 0 pop 0
</pre>

#### CPedType::Load

<pre>
plugin::Call<0x4EF3D0, unsigned char*, unsigned int>(bufferPointer, structSize);
0AA5: call_function 0x4EF3D0 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CPedType::LoadPedData

<pre>
plugin::Call<0x4EE8D0>();
0AA5: call_function 0x4EE8D0 num_params 0 pop 0
</pre>

#### CPedType::Save

<pre>
plugin::Call<0x4EF320, unsigned char*, unsigned int*>(bufferPointer, structSize);
0AA5: call_function 0x4EF320 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CPedType::Shutdown

<pre>
plugin::Call<0x4EE890>();
0AA5: call_function 0x4EE890 num_params 0 pop 0
</pre>

### plugin_III\game_III\CPhoneInfo.cpp

#### CPhoneInfo::FindNearestFreePhone

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, CVector *>(gaddrof(CPhoneInfo::FindNearestFreePhone), this, point);
0AA8: call_method_return 0x42F720 struct [CPhoneInfo] num_params 1 pop 0 [point] func_ret [int]
</pre>

#### CPhoneInfo::GrabPhone

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, float, float>(gaddrof(CPhoneInfo::GrabPhone), this, x, y);
0AA8: call_method_return 0x42FDB0 struct [CPhoneInfo] num_params 2 pop 0 [x] [y] func_ret [int]
</pre>

#### CPhoneInfo::HasMessageBeenDisplayed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, int>(gaddrof(CPhoneInfo::HasMessageBeenDisplayed), this, index);
0AA8: call_method_return 0x42FFF0 struct [CPhoneInfo] num_params 1 pop 0 [index] func_ret [bool]
</pre>

#### CPhoneInfo::Initialise

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Initialise), this);
0AA6: call_method 0x42F640 struct [CPhoneInfo] num_params 0 pop 0
</pre>

#### CPhoneInfo::IsMessageBeingDisplayed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, int>(gaddrof(CPhoneInfo::IsMessageBeingDisplayed), this, index);
0AA8: call_method_return 0x430030 struct [CPhoneInfo] num_params 1 pop 0 [index] func_ret [bool]
</pre>

#### CPhoneInfo::Load

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int>(gaddrof(CPhoneInfo::Load), this, buf, size);
0AA6: call_method 0x430120 struct [CPhoneInfo] num_params 2 pop 0 [buf] [size]
</pre>

#### CPhoneInfo::PhoneAtThisPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, CVector>(gaddrof(CPhoneInfo::PhoneAtThisPosition), this, point);
0AA8: call_method_return 0x42FD50 struct [CPhoneInfo] num_params 1 pop 0 [point] func_ret [bool]
</pre>

#### CPhoneInfo::Save

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int *>(gaddrof(CPhoneInfo::Save), this, buf, size);
0AA6: call_method 0x430060 struct [CPhoneInfo] num_params 2 pop 0 [buf] [size]
</pre>

#### CPhoneInfo::SetPhoneMessage_JustOnce

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_JustOnce), this, index, text_1, text_2, text_3, text_4, text_5, text_6);
0AA6: call_method 0x42FF90 struct [CPhoneInfo] num_params 7 pop 0 [index] [text_1] [text_2] [text_3] [text_4] [text_5] [text_6]
</pre>

#### CPhoneInfo::SetPhoneMessage_Repeatedly

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_Repeatedly), this, index, text_1, text_2, text_3, text_4, text_5, text_6);
0AA6: call_method 0x42FF30 struct [CPhoneInfo] num_params 7 pop 0 [index] [text_1] [text_2] [text_3] [text_4] [text_5] [text_6]
</pre>

#### CPhoneInfo::Shutdown

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Shutdown), this);
0AA6: call_method 0x42F710 struct [CPhoneInfo] num_params 0 pop 0
</pre>

#### CPhoneInfo::Update

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Update), this);
0AA6: call_method 0x42F7A0 struct [CPhoneInfo] num_params 0 pop 0
</pre>

#### PhonePickUpCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(PhonePickUpCB), association, data);
</pre>

#### PhonePutDownCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(PhonePutDownCB), association, data);
</pre>

### plugin_III\game_III\CPhysical.cpp

#### CPhysical::Add

<pre>
plugin::CallVirtualMethod<1, CPhysical *>(this);
</pre>

#### CPhysical::Remove

<pre>
plugin::CallVirtualMethod<2, CPhysical *>(this);
</pre>

#### \*CPhysical::GetBoundRect

<pre>
plugin::CallVirtualMethodAndReturn<CRect *, 7, CPhysical *>(this);
</pre>

#### CPhysical::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CPhysical *>(this);
</pre>

#### CPhysical::ProcessCollision

<pre>
plugin::CallVirtualMethod<9, CPhysical *>(this);
</pre>

#### CPhysical::ProcessShift

<pre>
plugin::CallVirtualMethod<10, CPhysical *>(this);
</pre>

#### CPhysical::ProcessEntityCollision

<pre>
plugin::CallVirtualMethod<17, CPhysical *, CEntity *, CColPoint *>(this, entity, colPoint);
</pre>

#### CPhysical::AddCollisionRecord

<pre>
plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::AddCollisionRecord), this, entity);
0AA6: call_method 0x497180 struct [CPhysical] num_params 1 pop 0 [entity]
</pre>

#### CPhysical::AddCollisionRecord_Treadable

<pre>
plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::AddCollisionRecord_Treadable), this, entity);
0AA6: call_method 0x4970C0 struct [CPhysical] num_params 1 pop 0 [entity]
</pre>

#### CPhysical::AddToMovingList

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::AddToMovingList), this);
0AA6: call_method 0x4958F0 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::ApplyAirResistance

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyAirResistance), this);
0AA6: call_method 0x495C20 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::ApplyCollision

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPhysical *, CColPoint &, float *, float *>(gaddrof(CPhysical::ApplyCollision), this, physical, colPoint, impulseA, impulseB);
0AA8: call_method_return 0x4973A0 struct [CPhysical] num_params 4 pop 0 [physical] [colPoint] [impulseA] [impulseB] func_ret [bool]
</pre>

#### CPhysical::ApplyCollisionAlt

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CEntity *, CColPoint &, float *, CVector &, CVector &>(gaddrof(CPhysical::ApplyCollisionAlt), this, entity, colPoint, impulse, moveSpeed, turnSpeed);
0AA8: call_method_return 0x4992A0 struct [CPhysical] num_params 5 pop 0 [entity] [colPoint] [impulse] [moveSpeed] [turnSpeed] func_ret [bool]
</pre>

#### CPhysical::ApplyFriction

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof_o(CPhysical::ApplyFriction, void (CPhysical::*)()), this);
0AA6: call_method 0x49A180 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::ApplyFriction

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CColPoint &>(gaddrof_o(CPhysical::ApplyFriction, bool (CPhysical::*)(float, CColPoint &)), this, adhesiveLimit, colPoint);
0AA8: call_method_return 0x49A180 struct [CPhysical] num_params 2 pop 0 [adhesiveLimit] [colPoint] func_ret [bool]
</pre>

#### CPhysical::ApplyFriction

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPhysical *, float, CColPoint &>(gaddrof_o(CPhysical::ApplyFriction, bool (CPhysical::*)(CPhysical *, float, CColPoint &)), this, physical, adhesiveLimit, colPoint);
0AA8: call_method_return 0x49A180 struct [CPhysical] num_params 3 pop 0 [physical] [adhesiveLimit] [colPoint] func_ret [bool]
</pre>

#### CPhysical::ApplyFrictionMoveForce

<pre>
plugin::CallMethodDynGlobal<CPhysical *, float, float, float>(gaddrof(CPhysical::ApplyFrictionMoveForce), this, jx, jy, jz);
0AA6: call_method 0x495D90 struct [CPhysical] num_params 3 pop 0 [jx] [jy] [jz]
</pre>

#### CPhysical::ApplyFrictionTurnForce

<pre>
plugin::CallMethodDynGlobal<CPhysical *, float, float, float, float, float, float>(gaddrof(CPhysical::ApplyFrictionTurnForce), this, jx, jy, jz, rx, ry, rz);
0AA6: call_method 0x495E10 struct [CPhysical] num_params 6 pop 0 [jx] [jy] [jz] [rx] [ry] [rz]
</pre>

#### CPhysical::ApplyGravity

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyGravity), this);
0AA6: call_method 0x495B50 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::ApplyMoveForce

<pre>
plugin::CallMethodDynGlobal<CPhysical *, float, float, float>(gaddrof(CPhysical::ApplyMoveForce), this, jx, jy, jz);
0AA6: call_method 0x4959A0 struct [CPhysical] num_params 3 pop 0 [jx] [jy] [jz]
</pre>

#### CPhysical::ApplyMoveSpeed

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyMoveSpeed), this);
0AA6: call_method 0x495B10 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::ApplySpringCollisionAlt

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CVector &, CVector &, float, float>(gaddrof(CPhysical::ApplySpringCollisionAlt), this, springConst, springDir, point, springRatio, bias);
0AA8: call_method_return 0x499890 struct [CPhysical] num_params 5 pop 0 [springConst] [springDir] [point] [springRatio] [bias] func_ret [bool]
</pre>

#### CPhysical::ApplySpringDampening

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CVector &, CVector &, CVector &>(gaddrof(CPhysical::ApplySpringDampening), this, damping, springDir, point, speed);
0AA8: call_method_return 0x499990 struct [CPhysical] num_params 4 pop 0 [damping] [springDir] [point] [speed] func_ret [bool]
</pre>

#### CPhysical::ApplyTurnForce

<pre>
plugin::CallMethodDynGlobal<CPhysical *, float, float, float, float, float, float>(gaddrof(CPhysical::ApplyTurnForce), this, jx, jy, jz, px, py, pz);
0AA6: call_method 0x495A10 struct [CPhysical] num_params 6 pop 0 [jx] [jy] [jz] [px] [py] [pz]
</pre>

#### CPhysical::ApplyTurnSpeed

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyTurnSpeed), this);
0AA6: call_method 0x497280 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::CheckCollision

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *>(gaddrof(CPhysical::CheckCollision), this);
0AA8: call_method_return 0x496E50 struct [CPhysical] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPhysical::CheckCollision_SimpleCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *>(gaddrof(CPhysical::CheckCollision_SimpleCar), this);
0AA8: call_method_return 0x496EB0 struct [CPhysical] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPhysical::GetHasCollidedWith

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CEntity *>(gaddrof(CPhysical::GetHasCollidedWith), this, entity);
0AA8: call_method_return 0x497240 struct [CPhysical] num_params 1 pop 0 [entity] func_ret [bool]
</pre>

#### CPhysical::ProcessCollisionSectorList

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPtrList *>(gaddrof(CPhysical::ProcessCollisionSectorList), this, list);
0AA8: call_method_return 0x49B620 struct [CPhysical] num_params 1 pop 0 [list] func_ret [bool]
</pre>

#### CPhysical::ProcessCollisionSectorList_SimpleCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CSector *>(gaddrof(CPhysical::ProcessCollisionSectorList_SimpleCar), this, sector);
0AA8: call_method_return 0x49E790 struct [CPhysical] num_params 1 pop 0 [sector] func_ret [bool]
</pre>

#### CPhysical::ProcessShiftSectorList

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPtrList *>(gaddrof(CPhysical::ProcessShiftSectorList), this, list);
0AA8: call_method_return 0x49DA10 struct [CPhysical] num_params 1 pop 0 [list] func_ret [bool]
</pre>

#### CPhysical::RemoveAndAdd

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::RemoveAndAdd), this);
0AA6: call_method 0x495540 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::RemoveFromMovingList

<pre>
plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::RemoveFromMovingList), this);
0AA6: call_method 0x495940 struct [CPhysical] num_params 0 pop 0
</pre>

#### CPhysical::RemoveRefsToEntity

<pre>
plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::RemoveRefsToEntity), this, entity);
0AA6: call_method 0x49F820 struct [CPhysical] num_params 1 pop 0 [entity]
</pre>

#### CPhysical::PlacePhysicalRelativeToOtherPhysical

<pre>
plugin::CallDynGlobal<CPhysical *, CPhysical *, CVector>(gaddrof(CPhysical::PlacePhysicalRelativeToOtherPhysical), other, physical, localPos);
</pre>

### plugin_III\game_III\CPickup.cpp

#### \*CPickup::GiveUsAPickUpObject

<pre>
plugin::CallMethodAndReturnDynGlobal<CObject *, CPickup *, int>(gaddrof(CPickup::GiveUsAPickUpObject), this, handle);
0AA8: call_method_return 0x433BA0 struct [*CPickup] num_params 1 pop 0 [handle] func_ret [CObject *]
</pre>

#### CPickup::Update

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPickup *, CPlayerPed *, CVehicle *, int>(gaddrof(CPickup::Update), this, player, vehicle, playerId);
0AA8: call_method_return 0x430860 struct [CPickup] num_params 3 pop 0 [player] [vehicle] [playerId] func_ret [bool]
</pre>

### plugin_III\game_III\CPickups.cpp

#### CPickups::AddToCollectedPickupsArray

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPickups::AddToCollectedPickupsArray), index);
</pre>

#### CPickups::DoCollectableEffects

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoCollectableEffects), entity);
</pre>

#### CPickups::DoMineEffects

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoMineEffects), entity);
</pre>

#### CPickups::DoMoneyEffects

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoMoneyEffects), entity);
</pre>

#### CPickups::DoPickUpEffects

<pre>
plugin::CallDynGlobal<CObject *>(gaddrof(CPickups::DoPickUpEffects), entity);
</pre>

#### CPickups::FindColourIndexForWeaponMI

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::FindColourIndexForWeaponMI), model);
</pre>

#### CPickups::GenerateNewOne

<pre>
plugin::CallAndReturnDynGlobal<int, CVector, unsigned int, unsigned char, unsigned int>(gaddrof(CPickups::GenerateNewOne), pos, modelIndex, type, quantity);
</pre>

#### CPickups::GenerateNewOne_WeaponType

<pre>
plugin::CallAndReturnDynGlobal<int, CVector, eWeaponType, unsigned char, unsigned int>(gaddrof(CPickups::GenerateNewOne_WeaponType), pos, weaponType, type, quantity);
</pre>

#### CPickups::GetActualPickupIndex

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::GetActualPickupIndex), index);
</pre>

#### CPickups::GetNewUniquePickupIndex

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::GetNewUniquePickupIndex), handle);
</pre>

#### CPickups::GivePlayerGoodiesWithPickUpMI

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned short, int>(gaddrof(CPickups::GivePlayerGoodiesWithPickUpMI), modelId, playerId);
</pre>

#### CPickups::IsPickUpPickedUp

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CPickups::IsPickUpPickedUp), handle);
</pre>

#### CPickups::Load

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPickups::Load), buf, size);
</pre>

#### CPickups::ModelForWeapon

<pre>
plugin::CallAndReturnDynGlobal<int, eWeaponType>(gaddrof(CPickups::ModelForWeapon), weaponType);
</pre>

#### CPickups::PassTime

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CPickups::PassTime), time);
</pre>

#### CPickups::RemovePickUp

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPickups::RemovePickUp), handle);
</pre>

#### CPickups::Save

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPickups::Save), buf, size);
</pre>

#### CPickups::WeaponForModel

<pre>
plugin::CallAndReturnDynGlobal<eWeaponType, int>(gaddrof(CPickups::WeaponForModel), model);
</pre>

### plugin_III\game_III\CPlaceable.cpp

#### &CPlaceable::GetPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<CVector &, CPlaceable *>(gaddrof(CPlaceable::GetPosition), this);
0AA8: call_method_return 0x4CBAC0 struct [&CPlaceable] num_params 0 pop 0 func_ret [CVector &]
</pre>

#### CPlaceable::IsWithinArea

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlaceable *, float, float, float, float>(gaddrof_o(CPlaceable::IsWithinArea, bool (CPlaceable::*)(float, float, float, float)), this, x1, y1, x2, y2);
0AA8: call_method_return 0x49FAF0 struct [CPlaceable] num_params 4 pop 0 [x1] [y1] [x2] [y2] func_ret [bool]
</pre>

#### CPlaceable::IsWithinArea

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlaceable *, float, float, float, float, float, float>(gaddrof_o(CPlaceable::IsWithinArea, bool (CPlaceable::*)(float, float, float, float, float, float)), this, x1, y1, z1, x2, y2, z2);
0AA8: call_method_return 0x49FAF0 struct [CPlaceable] num_params 6 pop 0 [x1] [y1] [z1] [x2] [y2] [z2] func_ret [bool]
</pre>

#### CPlaceable::SetHeading

<pre>
plugin::CallMethodDynGlobal<CPlaceable *, float>(gaddrof(CPlaceable::SetHeading), this, angle);
0AA6: call_method 0x49FA00 struct [CPlaceable] num_params 1 pop 0 [angle]
</pre>

#### CPlaceable::SetPosition

<pre>
plugin::CallMethodDynGlobal<CPlaceable *, float, float, float>(gaddrof(CPlaceable::SetPosition), this, x, y, z);
0AA6: call_method 0x4CBA50 struct [CPlaceable] num_params 3 pop 0 [x] [y] [z]
</pre>

### plugin_III\game_III\CPlaceName.cpp

#### CPlaceName::Display

<pre>
plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Display), this);
0AA6: call_method 0x4AD5B0 struct [CPlaceName] num_params 0 pop 0
</pre>

#### CPlaceName::Init

<pre>
plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Init), this);
0AA6: call_method 0x4AD4C0 struct [CPlaceName] num_params 0 pop 0
</pre>

#### CPlaceName::Process

<pre>
plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Process), this);
0AA6: call_method 0x4AD4E0 struct [CPlaceName] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPlane.cpp

#### CPlane::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CPlane *, unsigned int>(this, modelIndex);
</pre>

#### CPlane::DeleteRwObject

<pre>
plugin::CallVirtualMethod<6, CPlane *>(this);
</pre>

#### CPlane::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CPlane *>(this);
</pre>

#### CPlane::PreRender

<pre>
plugin::CallVirtualMethod<12, CPlane *>(this);
</pre>

#### CPlane::Render

<pre>
plugin::CallVirtualMethod<13, CPlane *>(this);
</pre>

#### CPlane::FlagToDestroyWhenNextProcessed

<pre>
plugin::CallVirtualMethod<16, CPlane *>(this);
</pre>

#### CPlane::HasCesnaBeenDestroyed

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasCesnaBeenDestroyed));
</pre>

#### CPlane::HasCesnaLanded

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasCesnaLanded));
</pre>

#### CPlane::HasDropOffCesnaBeenShotDown

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasDropOffCesnaBeenShotDown));
</pre>

#### \*CPlane::LoadPath

<pre>
plugin::CallAndReturnDynGlobal<CPlaneNode *, char const *, int *, float *, bool>(gaddrof(CPlane::LoadPath), filename, numNodes, totalLength, loop);
</pre>

#### CPlane::TestRocketCollision

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPlane::TestRocketCollision), coors);
</pre>

### plugin_III\game_III\CPlayerInfo.cpp

#### CPlayerInfo::ArrestPlayer

<pre>
plugin::CallMethod<0x4A1330, CPlayerInfo *>(this);
0AA6: call_method 0x4A1330 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::AwardMoneyForExplosion

<pre>
plugin::CallMethod<0x4A15F0, CPlayerInfo *, CVehicle*>(this, vehicle);
0AA6: call_method 0x4A15F0 struct [CPlayerInfo] num_params 1 pop 0 [vehicle]
</pre>

#### CPlayerInfo::BlowUpRCBuggy

<pre>
plugin::CallMethod<0x4A15C0, CPlayerInfo *>(this);
0AA6: call_method 0x4A15C0 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::CancelPlayerEnteringCars

<pre>
plugin::CallMethod<0x4A13B0, CPlayerInfo *, CVehicle*>(this, vehicle);
0AA6: call_method 0x4A13B0 struct [CPlayerInfo] num_params 1 pop 0 [vehicle]
</pre>

#### CPlayerInfo::Clear

<pre>
plugin::CallMethod<0x49FC10, CPlayerInfo *>(this);
0AA6: call_method 0x49FC10 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::DeletePlayerSkin

<pre>
plugin::CallMethod<0x4A1750, CPlayerInfo *>(this);
0AA6: call_method 0x4A1750 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::EvaluateCarPosition

<pre>
plugin::CallMethod<0x4A0EC0, CPlayerInfo *, CEntity*, CPed*, float, float*, CVehicle**>(this, entity, ped, radius, dist, vehicle);
0AA6: call_method 0x4A0EC0 struct [CPlayerInfo] num_params 5 pop 0 [entity] [ped] [radius] [dist] [vehicle]
</pre>

#### CPlayerInfo::FindClosestCarSectorList

<pre>
plugin::CallMethod<0x4A0CD0, CPlayerInfo *, CPtrList&, CPed*, float, float, float, float, float*, CVehicle**>(this, list, ped, conrerAX, cornerAY, cornerBX, cornerBY, dist, closestCar);
0AA6: call_method 0x4A0CD0 struct [CPlayerInfo] num_params 8 pop 0 [list] [ped] [conrerAX] [cornerAY] [cornerBX] [cornerBY] [dist] [closestCar]
</pre>

#### CPlayerInfo::GetPos

<pre>
plugin::CallMethodAndReturn<CVector*, 0x4A0FE0, CPlayerInfo *, CVector*>(this, point);
0AA8: call_method_return 0x4A0FE0 struct [CPlayerInfo] num_params 1 pop 0 [point] func_ret [CVector*]
</pre>

#### CPlayerInfo::IsPlayerInRemoteMode

<pre>
plugin::CallMethodAndReturn<bool, 0x4A0930, CPlayerInfo *>(this);
0AA8: call_method_return 0x4A0930 struct [CPlayerInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerInfo::IsRestartingAfterArrest

<pre>
plugin::CallMethodAndReturn<bool, 0x4A12C0, CPlayerInfo *>(this);
0AA8: call_method_return 0x4A12C0 struct [CPlayerInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerInfo::IsRestartingAfterDeath

<pre>
plugin::CallMethodAndReturn<bool, 0x4A12A0, CPlayerInfo *>(this);
0AA8: call_method_return 0x4A12A0 struct [CPlayerInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerInfo::KillPlayer

<pre>
plugin::CallMethod<0x4A12E0, CPlayerInfo *>(this);
0AA6: call_method 0x4A12E0 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::LoadPlayerInfo

<pre>
plugin::CallMethod<0x4A0B20, CPlayerInfo *, unsigned char*, unsigned int>(this, bufferPointer, structSize);
0AA6: call_method 0x4A0B20 struct [CPlayerInfo] num_params 2 pop 0 [bufferPointer] [structSize]
</pre>

#### CPlayerInfo::LoadPlayerSkin

<pre>
plugin::CallMethod<0x4A1700, CPlayerInfo *>(this);
0AA6: call_method 0x4A1700 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::MakePlayerSafe

<pre>
plugin::CallMethod<0x4A1400, CPlayerInfo *, bool>(this, safe);
0AA6: call_method 0x4A1400 struct [CPlayerInfo] num_params 1 pop 0 [safe]
</pre>

#### CPlayerInfo::PlayerFailedCriticalMission

<pre>
plugin::CallMethod<0x4A1380, CPlayerInfo *>(this);
0AA6: call_method 0x4A1380 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::Process

<pre>
plugin::CallMethod<0x49FD30, CPlayerInfo *>(this);
0AA6: call_method 0x49FD30 struct [CPlayerInfo] num_params 0 pop 0
</pre>

#### CPlayerInfo::SavePlayerInfo

<pre>
plugin::CallMethod<0x4A0960, CPlayerInfo *, unsigned char*, unsigned int*>(this, bufferPointer, structSize);
0AA6: call_method 0x4A0960 struct [CPlayerInfo] num_params 2 pop 0 [bufferPointer] [structSize]
</pre>

#### CPlayerInfo::SetPlayerSkin

<pre>
plugin::CallMethod<0x4A16D0, CPlayerInfo *, char const*>(this, skinName);
0AA6: call_method 0x4A16D0 struct [CPlayerInfo] num_params 1 pop 0 [skinName]
</pre>

#### CPlayerInfo::~CPlayerInfo

<pre>
plugin::CallMethod<0x4B5DC0, CPlayerInfo *>(this);
0AA6: call_method 0x4B5DC0 struct [CPlayerInfo] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPlayerPed.cpp

#### CPlayerPed::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CPlayerPed *>(this);
</pre>

#### CPlayerPed::SetMoveAnim

<pre>
plugin::CallVirtualMethod<18, CPlayerPed *>(this);
</pre>

#### CPlayerPed::AnnoyPlayerPed

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, bool>(gaddrof(CPlayerPed::AnnoyPlayerPed), this, annoyedByPassingEntity);
0AA6: call_method 0x4F3700 struct [CPlayerPed] num_params 1 pop 0 [annoyedByPassingEntity]
</pre>

#### CPlayerPed::ClearAdrenaline

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ClearAdrenaline), this);
0AA6: call_method 0x4F3730 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ClearWeaponTarget

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ClearWeaponTarget), this);
0AA6: call_method 0x4F28A0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DoStuffToGoOnFire

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::DoStuffToGoOnFire), this);
0AA6: call_method 0x4F36E0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DoWeaponSmoothSpray

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *>(gaddrof(CPlayerPed::DoWeaponSmoothSpray), this);
0AA8: call_method_return 0x4F1380 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::DoesTargetHaveToBeBroken

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CVector, CWeapon *>(gaddrof(CPlayerPed::DoesTargetHaveToBeBroken), this, target, weapon);
0AA8: call_method_return 0x4F3350 struct [CPlayerPed] num_params 2 pop 0 [target] [weapon] func_ret [bool]
</pre>

#### CPlayerPed::EvaluateNeighbouringTarget

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CEntity *, CEntity **, float *, float, float, bool>(gaddrof(CPlayerPed::EvaluateNeighbouringTarget), this, candidate, targetPtr, lastCloseness, distLimit, angleOffset, lookToLeft);
0AA6: call_method 0x4F2FA0 struct [CPlayerPed] num_params 6 pop 0 [candidate] [targetPtr] [lastCloseness] [distLimit] [angleOffset] [lookToLeft]
</pre>

#### CPlayerPed::EvaluateTarget

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CEntity *, CEntity **, float *, float, float, bool>(gaddrof(CPlayerPed::EvaluateTarget), this, candidate, targetPtr, lastCloseness, distLimit, angleOffset, priority);
0AA6: call_method 0x4F2B60 struct [CPlayerPed] num_params 6 pop 0 [candidate] [targetPtr] [lastCloseness] [distLimit] [angleOffset] [priority]
</pre>

#### CPlayerPed::FindNextWeaponLockOnTarget

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CEntity *, bool>(gaddrof(CPlayerPed::FindNextWeaponLockOnTarget), this, previousTarget, lookToLeft);
0AA8: call_method_return 0x4F2D50 struct [CPlayerPed] num_params 2 pop 0 [previousTarget] [lookToLeft] func_ret [bool]
</pre>

#### CPlayerPed::FindWeaponLockOnTarget

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *>(gaddrof(CPlayerPed::FindWeaponLockOnTarget), this);
0AA8: call_method_return 0x4F28D0 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### \*CPlayerPed::GetPlayerInfoForThisPlayerPed

<pre>
plugin::CallMethodAndReturnDynGlobal<CPlayerInfo *, CPlayerPed *>(gaddrof(CPlayerPed::GetPlayerInfoForThisPlayerPed), this);
0AA8: call_method_return 0x4F36C0 struct [*CPlayerPed] num_params 0 pop 0 func_ret [CPlayerInfo *]
</pre>

#### CPlayerPed::IsThisPedAttackingPlayer

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CPed *>(gaddrof(CPlayerPed::IsThisPedAttackingPlayer), this, ped);
0AA8: call_method_return 0x4F2D00 struct [CPlayerPed] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPlayerPed::KeepAreaAroundPlayerClear

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::KeepAreaAroundPlayerClear), this);
0AA6: call_method 0x4F3460 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::MakeChangesForNewWeapon

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, char>(gaddrof(CPlayerPed::MakeChangesForNewWeapon), this, weaponType);
0AA6: call_method 0x4F2560 struct [CPlayerPed] num_params 1 pop 0 [weaponType]
</pre>

#### CPlayerPed::MakeObjectTargettable

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::MakeObjectTargettable), this, handle);
0AA6: call_method 0x4F32B0 struct [CPlayerPed] num_params 1 pop 0 [handle]
</pre>

#### CPlayerPed::PlayerControl1stPersonRunAround

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControl1stPersonRunAround), this, pad);
0AA6: call_method 0x4F1970 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlFighter

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlFighter), this, pad);
0AA6: call_method 0x4F1810 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlM16

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlM16), this, pad);
0AA6: call_method 0x4F1DF0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlSniper

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlSniper), this, pad);
0AA6: call_method 0x4F1CF0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlZelda

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlZelda), this, pad);
0AA6: call_method 0x4F13C0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ProcessAnimGroups

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ProcessAnimGroups), this);
0AA6: call_method 0x4F2640 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ProcessPlayerWeapon

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::ProcessPlayerWeapon), this, pad);
0AA6: call_method 0x4F1EF0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ProcessWeaponSwitch

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::ProcessWeaponSwitch), this, pad);
0AA6: call_method 0x4F2310 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ReApplyMoveAnims

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ReApplyMoveAnims), this);
0AA6: call_method 0x4F07C0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::RestoreSprintEnergy

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, float>(gaddrof(CPlayerPed::RestoreSprintEnergy), this, restoreSpeed);
0AA6: call_method 0x4F1340 struct [CPlayerPed] num_params 1 pop 0 [restoreSpeed]
</pre>

#### CPlayerPed::RunningLand

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::RunningLand), this, pad);
0AA6: call_method 0x4F31D0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::SetInitialState

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::SetInitialState), this);
0AA6: call_method 0x4EFC40 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetRealMoveAnim

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::SetRealMoveAnim), this);
0AA6: call_method 0x4F0880 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetWantedLevel

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::SetWantedLevel), this, level);
0AA6: call_method 0x4F3190 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::SetWantedLevelNoDrop

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::SetWantedLevelNoDrop), this, level);
0AA6: call_method 0x4F31B0 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::UseSprintEnergy

<pre>
plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::UseSprintEnergy), this);
0AA6: call_method 0x4F12A0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DeactivatePlayerPed

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::DeactivatePlayerPed), playerId);
</pre>

#### CPlayerPed::ReactivatePlayerPed

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::ReactivatePlayerPed), playerId);
</pre>

#### CPlayerPed::SetupPlayerPed

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::SetupPlayerPed), playerId);
</pre>

### plugin_III\game_III\CPlayerSkin.cpp

#### \*CPlayerSkin::GetSkinTexture

<pre>
plugin::CallAndReturnDynGlobal<RwTexture *, char const *>(gaddrof(CPlayerSkin::GetSkinTexture), name);
</pre>

#### FindPlayerDff

<pre>
plugin::CallDynGlobal<unsigned int &, unsigned int &>(gaddrof(FindPlayerDff), offset, size);
</pre>

### plugin_III\game_III\CPointLights.cpp

#### CPointLights::AddLight

<pre>
plugin::Call<0x510790, unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool>(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows);
0AA5: call_function 0x510790 num_params 9 pop 9 [lightType] [point] [direction] [radius] [red] [green] [blue] [fogType] [generateExtraShadows]
</pre>

#### CPointLights::GenerateLightsAffectingObject

<pre>
plugin::CallAndReturn<float, 0x510960, CVector*>(point);
0AA7: call_function_return 0x510960 num_params 1 pop 1 [point] func_ret [float]
</pre>

#### CPointLights::RemoveLightsAffectingObject

<pre>
plugin::Call<0x510C20>();
0AA5: call_function 0x510C20 num_params 0 pop 0
</pre>

#### CPointLights::RenderFogEffect

<pre>
plugin::Call<0x510C30>();
0AA5: call_function 0x510C30 num_params 0 pop 0
</pre>

#### CPointLight::CPointLight

<pre>
plugin::CallMethod<0x511930, CPointLight *>(this);
0AA6: call_method 0x511930 struct [CPointLight] num_params 0 pop 0
</pre>

### plugin_III\game_III\CPools.cpp

#### \*CPools::GetBuildingPool

<pre>
plugin::CallAndReturnDynGlobal<CPool<CBuilding> *>(gaddrof(CPools::GetBuildingPool));
</pre>

#### CPools::GetCCutsceneHeadSize

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CPools::GetCCutsceneHeadSize));
</pre>

#### \*CPools::GetObject

<pre>
plugin::CallAndReturnDynGlobal<CObject *, int>(gaddrof(CPools::GetObject), handle);
</pre>

#### \*CPools::GetObjectPool

<pre>
plugin::CallAndReturnDynGlobal<CPool<CObject, CCutsceneObject> *>(gaddrof(CPools::GetObjectPool));
</pre>

#### CPools::GetObjectRef

<pre>
plugin::CallAndReturnDynGlobal<int, CObject *>(gaddrof(CPools::GetObjectRef), object);
</pre>

#### \*CPools::GetPed

<pre>
plugin::CallAndReturnDynGlobal<CPed *, int>(gaddrof(CPools::GetPed), handle);
</pre>

#### CPools::GetPedRef

<pre>
plugin::CallAndReturnDynGlobal<int, CPed *>(gaddrof(CPools::GetPedRef), ped);
</pre>

#### \*CPools::GetVehicle

<pre>
plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CPools::GetVehicle), handle);
</pre>

#### \*CPools::GetVehiclePool

<pre>
plugin::CallAndReturnDynGlobal<CPool<CVehicle, CAutomobile> *>(gaddrof(CPools::GetVehiclePool));
</pre>

#### CPools::GetVehicleRef

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CPools::GetVehicleRef), vehicle);
</pre>

#### CPools::LoadObjectPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadObjectPool), buffer, size);
</pre>

#### CPools::LoadPedPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadPedPool), buffer, size);
</pre>

#### CPools::LoadVehiclePool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadVehiclePool), buffer, size);
</pre>

#### CPools::MakeSureSlotInObjectPoolIsEmpty

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPools::MakeSureSlotInObjectPoolIsEmpty), slot);
</pre>

#### CPools::SaveObjectPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveObjectPool), buffer, outSize);
</pre>

#### CPools::SavePedPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SavePedPool), buffer, outSize);
</pre>

#### CPools::SaveVehiclePool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveVehiclePool), buffer, outSize);
</pre>

### plugin_III\game_III\CPopulation.cpp

#### \*CPopulation::AddPed

<pre>
plugin::CallAndReturnDynGlobal<CPed *, ePedType, unsigned int, CVector const &>(gaddrof(CPopulation::AddPed), pedType, modelIndexOrCopType, coors);
</pre>

#### \*CPopulation::AddPedInCar

<pre>
plugin::CallAndReturnDynGlobal<CPed *, CVehicle *>(gaddrof(CPopulation::AddPedInCar), vehicle);
</pre>

#### CPopulation::AddToPopulation

<pre>
plugin::CallDynGlobal<float, float, float, float>(gaddrof(CPopulation::AddToPopulation), minDist, maxDist, minDistOffScreen, maxDistOffScreen);
</pre>

#### CPopulation::ChooseCivilianOccupation

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPopulation::ChooseCivilianOccupation), group);
</pre>

#### CPopulation::ChooseGangOccupation

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPopulation::ChooseGangOccupation), gangId);
</pre>

#### CPopulation::ChoosePolicePedOccupation

<pre>
plugin::CallAndReturnDynGlobal<eCopType>(gaddrof(CPopulation::ChoosePolicePedOccupation));
</pre>

#### CPopulation::ConvertToDummyObject

<pre>
plugin::CallDynGlobal<CObject *>(gaddrof(CPopulation::ConvertToDummyObject), object);
</pre>

#### CPopulation::ConvertToRealObject

<pre>
plugin::CallDynGlobal<CDummyObject *>(gaddrof(CPopulation::ConvertToRealObject), dummy);
</pre>

#### CPopulation::DealWithZoneChange

<pre>
plugin::CallDynGlobal<eLevelName, eLevelName, bool>(gaddrof(CPopulation::DealWithZoneChange), oldLevel, newLevel, forceIndustrialZone);
</pre>

#### CPopulation::FindClosestZoneForCoors

<pre>
plugin::CallDynGlobal<CVector *, int *, eLevelName, eLevelName>(gaddrof(CPopulation::FindClosestZoneForCoors), coors, safeZoneOut, level1, level2);
</pre>

#### CPopulation::FindCollisionZoneForCoors

<pre>
plugin::CallDynGlobal<CVector *, int *, eLevelName *>(gaddrof(CPopulation::FindCollisionZoneForCoors), coors, safeZoneOut, levelOut);
</pre>

#### CPopulation::IsPointInSafeZone

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPopulation::IsPointInSafeZone), coors);
</pre>

#### CPopulation::PedCreationDistMultiplier

<pre>
plugin::CallAndReturnDynGlobal<float>(gaddrof(CPopulation::PedCreationDistMultiplier));
</pre>

#### CPopulation::RemovePed

<pre>
plugin::CallDynGlobal<CPed *>(gaddrof(CPopulation::RemovePed), ped);
</pre>

#### CPopulation::TestRoomForDummyObject

<pre>
plugin::CallAndReturnDynGlobal<bool, CObject *>(gaddrof(CPopulation::TestRoomForDummyObject), object);
</pre>

#### CPopulation::TestSafeForRealObject

<pre>
plugin::CallAndReturnDynGlobal<bool, CDummyObject *>(gaddrof(CPopulation::TestSafeForRealObject), dummy);
</pre>

#### CPopulation::UpdatePedCount

<pre>
plugin::CallDynGlobal<ePedType, bool>(gaddrof(CPopulation::UpdatePedCount), pedType, decrease);
</pre>

### plugin_III\game_III\CProjectileInfo.cpp

#### CProjectileInfo::AddProjectile

<pre>
plugin::CallAndReturn<bool, 0x55B030, CEntity*, eWeaponType, CVector, float>(creator, weaponType, posn, force);
0AA7: call_function_return 0x55B030 num_params 4 pop 4 [creator] [weaponType] [posn] [force] func_ret [bool]
</pre>

#### CProjectileInfo::CProjectileInfo

<pre>
plugin::CallMethod<0x55BC50, CProjectileInfo *>(this);
0AA6: call_method 0x55BC50 struct [CProjectileInfo] num_params 0 pop 0
</pre>

#### CProjectileInfo::GetProjectileInfo

<pre>
plugin::CallAndReturn<CProjectileInfo*, 0x55B010, int>(index);
0AA7: call_function_return 0x55B010 num_params 1 pop 1 [index] func_ret [CProjectileInfo*]
</pre>

#### CProjectileInfo::Initialise

<pre>
plugin::Call<0x55ADF0>();
0AA5: call_function 0x55ADF0 num_params 0 pop 0
</pre>

#### CProjectileInfo::IsProjectileInRange

<pre>
plugin::CallAndReturn<bool, 0x55BA50, float, float, float, float, float, float, bool>(x1, y1, z1, x2, y2, z2, bDestroy);
0AA7: call_function_return 0x55BA50 num_params 7 pop 7 [x1] [y1] [z1] [x2] [y2] [z2] [bDestroy] func_ret [bool]
</pre>

#### CProjectileInfo::RemoveAllProjectiles

<pre>
plugin::Call<0x55BB80>();
0AA5: call_function 0x55BB80 num_params 0 pop 0
</pre>

#### CProjectileInfo::RemoveIfThisIsAProjectile

<pre>
plugin::CallAndReturn<bool, 0x55BBD0, CObject*>(object);
0AA7: call_function_return 0x55BBD0 num_params 1 pop 1 [object] func_ret [bool]
</pre>

#### CProjectileInfo::RemoveNotAdd

<pre>
plugin::Call<0x55B770, CEntity*, eWeaponType, CVector>(creator, weaponType, posn);
0AA5: call_function 0x55B770 num_params 3 pop 3 [creator] [weaponType] [posn]
</pre>

#### CProjectileInfo::RemoveProjectile

<pre>
plugin::Call<0x55B700, CProjectileInfo*, CProjectile*>(info, projectileObject);
0AA5: call_function 0x55B700 num_params 2 pop 2 [info] [projectileObject]
</pre>

#### CProjectileInfo::Shutdown

<pre>
plugin::Call<0x55AFF0>();
0AA5: call_function 0x55AFF0 num_params 0 pop 0
</pre>

#### CProjectileInfo::Update

<pre>
plugin::Call<0x55B7C0>();
0AA5: call_function 0x55B7C0 num_params 0 pop 0
</pre>

### plugin_III\game_III\CQuaternion.cpp

#### CQuaternion::Get

<pre>
plugin::CallMethodDynGlobal<CQuaternion *, RwMatrix *>(gaddrof(CQuaternion::Get), this, matrix);
0AA6: call_method 0x4BA0D0 struct [CQuaternion] num_params 1 pop 0 [matrix]
</pre>

#### CQuaternion::Slerp

<pre>
plugin::CallMethodDynGlobal<CQuaternion *, CQuaternion const &, CQuaternion const &, float, float, float>(gaddrof(CQuaternion::Slerp), this, from, to, halftheta, sintheta_inv, t);
0AA6: call_method 0x4BA1C0 struct [CQuaternion] num_params 5 pop 0 [from] [to] [halftheta] [sintheta_inv] [t]
</pre>

### plugin_III\game_III\CRadar.cpp

#### CRadar::CalculateBlipAlpha

<pre>
plugin::CallAndReturnDynGlobal<unsigned char, float>(gaddrof(CRadar::CalculateBlipAlpha), distance);
</pre>

#### CRadar::ChangeBlipBrightness

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CRadar::ChangeBlipBrightness), i, bright);
</pre>

#### CRadar::ChangeBlipColour

<pre>
plugin::CallDynGlobal<int, unsigned int>(gaddrof(CRadar::ChangeBlipColour), i, colour);
</pre>

#### CRadar::ChangeBlipDisplay

<pre>
plugin::CallDynGlobal<int, eBlipDisplay>(gaddrof(CRadar::ChangeBlipDisplay), i, display);
</pre>

#### CRadar::ChangeBlipScale

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CRadar::ChangeBlipScale), i, scale);
</pre>

#### CRadar::ClearBlip

<pre>
plugin::CallDynGlobal<int>(gaddrof(CRadar::ClearBlip), i);
</pre>

#### CRadar::ClearBlipForEntity

<pre>
plugin::CallDynGlobal<eBlipType, int>(gaddrof(CRadar::ClearBlipForEntity), type, handle);
</pre>

#### CRadar::ClipRadarPoly

<pre>
plugin::CallAndReturnDynGlobal<int, CVector2D *, CVector2D const *>(gaddrof(CRadar::ClipRadarPoly), out, in);
</pre>

#### CRadar::DrawRadarSection

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CRadar::DrawRadarSection), x, y);
</pre>

#### CRadar::DrawRadarSprite

<pre>
plugin::CallDynGlobal<unsigned short, float, float, unsigned char>(gaddrof(CRadar::DrawRadarSprite), sprite, x, y, alpha);
</pre>

#### CRadar::DrawRotatingRadarSprite

<pre>
plugin::CallDynGlobal<CSprite2d *, float, float, float, unsigned char>(gaddrof(CRadar::DrawRotatingRadarSprite), sprite, x, y, angle, alpha);
</pre>

#### CRadar::GetActualBlipArrayIndex

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CRadar::GetActualBlipArrayIndex), i);
</pre>

#### CRadar::GetNewUniqueBlipIndex

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CRadar::GetNewUniqueBlipIndex), i);
</pre>

#### CRadar::GetRadarTraceColour

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, bool>(gaddrof(CRadar::GetRadarTraceColour), colour, bright);
</pre>

#### CRadar::LimitRadarPoint

<pre>
plugin::CallAndReturnDynGlobal<float, CVector2D &>(gaddrof(CRadar::LimitRadarPoint), point);
</pre>

#### CRadar::LoadAllRadarBlips

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CRadar::LoadAllRadarBlips), buf, size);
</pre>

#### CRadar::SaveAllRadarBlips

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CRadar::SaveAllRadarBlips), buf, size);
</pre>

#### CRadar::SetBlipSprite

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CRadar::SetBlipSprite), i, icon);
</pre>

#### CRadar::SetCoordBlip

<pre>
plugin::CallAndReturnDynGlobal<int, eBlipType, CVector, unsigned int, eBlipDisplay>(gaddrof(CRadar::SetCoordBlip), type, pos, colour, display);
</pre>

#### CRadar::SetEntityBlip

<pre>
plugin::CallDynGlobal<eBlipType, int, unsigned int, eBlipDisplay>(gaddrof(CRadar::SetEntityBlip), type, handle, colour, display);
</pre>

#### CRadar::SetRadarMarkerState

<pre>
plugin::CallDynGlobal<int, unsigned char>(gaddrof(CRadar::SetRadarMarkerState), i, flag);
</pre>

#### CRadar::ShowRadarMarker

<pre>
plugin::CallDynGlobal<CVector, unsigned int, float>(gaddrof(CRadar::ShowRadarMarker), pos, colour, radius);
</pre>

#### CRadar::ShowRadarTrace

<pre>
plugin::CallDynGlobal<float, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char>(gaddrof(CRadar::ShowRadarTrace), x, y, size, red, green, blue, alpha);
</pre>

#### CRadar::StreamRadarSections

<pre>
plugin::CallDynGlobal<int, int>(gaddrof_o(CRadar::StreamRadarSections, void (*)(int, int)), x, y);
</pre>

#### CRadar::StreamRadarSections

<pre>
plugin::CallDynGlobal<CVector const &>(gaddrof_o(CRadar::StreamRadarSections, void (*)(CVector const &)), pos);
</pre>

#### CRadar::TransformRadarPointToRealWorldSpace

<pre>
plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRadarPointToRealWorldSpace), out, in);
</pre>

#### CRadar::TransformRadarPointToScreenSpace

<pre>
plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRadarPointToScreenSpace), out, in);
</pre>

#### CRadar::TransformRealWorldPointToRadarSpace

<pre>
plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRealWorldPointToRadarSpace), out, in);
</pre>

#### CRadar::TransformRealWorldToTexCoordSpace

<pre>
plugin::CallDynGlobal<CVector2D &, CVector2D const &, int, int>(gaddrof(CRadar::TransformRealWorldToTexCoordSpace), out, in, x, y);
</pre>

#### ClipRadarTileCoords

<pre>
plugin::CallDynGlobal<int &, int &>(gaddrof(ClipRadarTileCoords), x, y);
</pre>

#### RequestMapSection

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(RequestMapSection), x, y);
</pre>

#### RemoveMapSection

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(RemoveMapSection), x, y);
</pre>

#### IsPointInsideRadar

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector2D const &>(gaddrof(IsPointInsideRadar), point);
</pre>

#### GetTextureCorners

<pre>
plugin::CallDynGlobal<int, int, CVector2D *>(gaddrof(GetTextureCorners), x, y, out);
</pre>

#### LineRadarBoxCollision

<pre>
plugin::CallAndReturnDynGlobal<int, CVector2D &, CVector2D const &, CVector2D const &>(gaddrof(LineRadarBoxCollision), out, lineStart, lineEnd);
</pre>

### plugin_III\game_III\CRange2D.cpp

#### \*CRange2D::GetRandomPointInRange

<pre>
plugin::CallMethodAndReturnDynGlobal<CVector2D *, CRange2D *>(gaddrof(CRange2D::GetRandomPointInRange), this);
0AA8: call_method_return 0x4A7270 struct [*CRange2D] num_params 0 pop 0 func_ret [CVector2D *]
</pre>

### plugin_III\game_III\CRecordDataForChase.cpp

#### CRecordDataForChase::GiveUsACar

<pre>
plugin::CallDynGlobal<int, CVector, float, CAutomobile **, unsigned char, unsigned char>(gaddrof(CRecordDataForChase::GiveUsACar), modelIndex, pos, angleZ, pCar, prim, sec);
</pre>

#### CRecordDataForChase::RemoveCarFromChase

<pre>
plugin::CallDynGlobal<int>(gaddrof(CRecordDataForChase::RemoveCarFromChase), index);
</pre>

#### CRecordDataForChase::RestoreInfoForCar

<pre>
plugin::CallDynGlobal<CAutomobile *, CCarStateEachFrame *, bool>(gaddrof(CRecordDataForChase::RestoreInfoForCar), car, carState, stop);
</pre>

#### CRecordDataForChase::RestoreInfoForMatrix

<pre>
plugin::CallDynGlobal<CMatrix &, CCarStateEachFrame *>(gaddrof(CRecordDataForChase::RestoreInfoForMatrix), matrix, carState);
</pre>

#### CRecordDataForChase::StartChaseScene

<pre>
plugin::CallDynGlobal<float>(gaddrof(CRecordDataForChase::StartChaseScene), startTime);
</pre>

#### CRecordDataForChase::StoreInfoForCar

<pre>
plugin::CallDynGlobal<CAutomobile *, CCarStateEachFrame *>(gaddrof(CRecordDataForChase::StoreInfoForCar), car, carState);
</pre>

#### \*CRecordDataForChase::TurnChaseCarIntoScriptCar

<pre>
plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CRecordDataForChase::TurnChaseCarIntoScriptCar), index);
</pre>

### plugin_III\game_III\CRecordDataForGame.cpp

#### CRecordDataForGame::CalcGameChecksum

<pre>
plugin::CallAndReturnDynGlobal<unsigned short>(gaddrof(CRecordDataForGame::CalcGameChecksum));
</pre>

#### \*CRecordDataForGame::PackCurrentPadValues

<pre>
plugin::CallAndReturnDynGlobal<unsigned char *, unsigned char *, CControllerState *, CControllerState *>(gaddrof(CRecordDataForGame::PackCurrentPadValues), buf, os, ns);
</pre>

#### \*CRecordDataForGame::UnPackCurrentPadValues

<pre>
plugin::CallAndReturnDynGlobal<unsigned char *, unsigned char *, unsigned char, CControllerState *>(gaddrof(CRecordDataForGame::UnPackCurrentPadValues), buf, total, state);
</pre>

### plugin_III\game_III\CRegisteredCorona.cpp

#### CRegisteredCorona::Update

<pre>
plugin::CallMethodDynGlobal<CRegisteredCorona *>(gaddrof(CRegisteredCorona::Update), this);
0AA6: call_method 0x4F8C40 struct [CRegisteredCorona] num_params 0 pop 0
</pre>

### plugin_III\game_III\CRegisteredMotionBlurStreak.cpp

#### CRegisteredMotionBlurStreak::Render

<pre>
plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(gaddrof(CRegisteredMotionBlurStreak::Render), this);
0AA6: call_method 0x519600 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0
</pre>

#### CRegisteredMotionBlurStreak::Update

<pre>
plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(gaddrof(CRegisteredMotionBlurStreak::Update), this);
0AA6: call_method 0x519580 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0
</pre>

### plugin_III\game_III\CRemote.cpp

#### CRemote::GivePlayerRemoteControlledCar

<pre>
plugin::CallDynGlobal<float, float, float, float, unsigned short>(gaddrof(CRemote::GivePlayerRemoteControlledCar), x, y, z, angle, modelIndex);
</pre>

### plugin_III\game_III\CRestart.cpp

#### CRestart::AddHospitalRestartPoint

<pre>
plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::AddHospitalRestartPoint), pos, heading);
</pre>

#### CRestart::AddPoliceRestartPoint

<pre>
plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::AddPoliceRestartPoint), pos, heading);
</pre>

#### CRestart::FindClosestHospitalRestartPoint

<pre>
plugin::CallDynGlobal<CVector const &, CVector *, float *>(gaddrof(CRestart::FindClosestHospitalRestartPoint), pos, outPos, outHeading);
</pre>

#### CRestart::FindClosestPoliceRestartPoint

<pre>
plugin::CallDynGlobal<CVector const &, CVector *, float *>(gaddrof(CRestart::FindClosestPoliceRestartPoint), pos, outPos, outHeading);
</pre>

#### CRestart::LoadAllRestartPoints

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CRestart::LoadAllRestartPoints), buf, size);
</pre>

#### CRestart::OverrideNextRestart

<pre>
plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::OverrideNextRestart), pos, heading);
</pre>

#### CRestart::SaveAllRestartPoints

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CRestart::SaveAllRestartPoints), buf, size);
</pre>

### plugin_III\game_III\CRoadBlocks.cpp

#### CRoadBlocks::GenerateRoadBlockCopsForCar

<pre>
plugin::CallDynGlobal<CVehicle *, int, short>(gaddrof(CRoadBlocks::GenerateRoadBlockCopsForCar), vehicle, roadBlockType, roadBlockNode);
</pre>

### plugin_III\game_III\CRouteNode.cpp

#### CRouteNode::AddRoutePoint

<pre>
plugin::CallDynGlobal<short, CVector>(gaddrof(CRouteNode::AddRoutePoint), route, pos);
</pre>

#### CRouteNode::GetRouteStart

<pre>
plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteStart), route);
</pre>

#### CRouteNode::GetRouteThisPointIsOn

<pre>
plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteThisPointIsOn), point);
</pre>

#### CRouteNode::RemoveRoute

<pre>
plugin::CallDynGlobal<short>(gaddrof(CRouteNode::RemoveRoute), route);
</pre>

### plugin_III\game_III\CRubbish.cpp

#### CRubbish::SetVisibility

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CRubbish::SetVisibility), visible);
</pre>

#### CRubbish::StirUp

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CRubbish::StirUp), vehicle);
</pre>

### plugin_III\game_III\CRunningScript.cpp

#### CRunningScript::Init

<pre>
plugin::CallMethod<0x4386C0, CRunningScript *>(this);
0AA6: call_method 0x4386C0 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::ProcessOneCommand

<pre>
plugin::CallMethodAndReturn<char, 0x439500, CRunningScript *>(this);
0AA8: call_method_return 0x439500 struct [CRunningScript] num_params 0 pop 0 func_ret [char]
</pre>

#### CRunningScript::CollectParameters

<pre>
plugin::CallMethod<0x4382E0, CRunningScript *, int*, short>(this, arg0, count);
0AA6: call_method 0x4382E0 struct [CRunningScript] num_params 2 pop 0 [arg0] [count]
</pre>

#### CRunningScript::UpdateCompareFlag

<pre>
plugin::CallMethod<0x44FD90, CRunningScript *, unsigned char>(this, flag);
0AA6: call_method 0x44FD90 struct [CRunningScript] num_params 1 pop 0 [flag]
</pre>

### plugin_III\game_III\CSceneEdit.cpp

#### CSceneEdit::LoadMovie

<pre>
plugin::Call<0x5850A0>();
0AA5: call_function 0x5850A0 num_params 0 pop 0
</pre>

#### CSceneEdit::SaveMovie

<pre>
plugin::Call<0x585110>();
0AA5: call_function 0x585110 num_params 0 pop 0
</pre>

#### CSceneEdit::Initialise

<pre>
plugin::Call<0x585170>();
0AA5: call_function 0x585170 num_params 0 pop 0
</pre>

#### CSceneEdit::InitPlayBack

<pre>
plugin::Call<0x5852C0>();
0AA5: call_function 0x5852C0 num_params 0 pop 0
</pre>

#### CSceneEdit::ReInitialise

<pre>
plugin::Call<0x5853F0>();
0AA5: call_function 0x5853F0 num_params 0 pop 0
</pre>

#### CSceneEdit::Update

<pre>
plugin::Call<0x585570>();
0AA5: call_function 0x585570 num_params 0 pop 0
</pre>

#### CSceneEdit::Draw

<pre>
plugin::Call<0x5855F0>();
0AA5: call_function 0x5855F0 num_params 0 pop 0
</pre>

#### CSceneEdit::ProcessCommand

<pre>
plugin::Call<0x585BB0>();
0AA5: call_function 0x585BB0 num_params 0 pop 0
</pre>

#### CSceneEdit::PlayBack

<pre>
plugin::Call<0x587200>();
0AA5: call_function 0x587200 num_params 0 pop 0
</pre>

#### CSceneEdit::ClearForNewCommand

<pre>
plugin::Call<0x587AF0>();
0AA5: call_function 0x587AF0 num_params 0 pop 0
</pre>

#### CSceneEdit::SelectActor

<pre>
plugin::CallAndReturn<bool, 0x587B30>();
0AA7: call_function_return 0x587B30 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::SelectActor2

<pre>
plugin::CallAndReturn<bool, 0x587DC0>();
0AA7: call_function_return 0x587DC0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::SelectVehicle

<pre>
plugin::CallAndReturn<bool, 0x588040>();
0AA7: call_function_return 0x588040 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::SelectWeapon

<pre>
plugin::CallAndReturn<bool, 0x588220>();
0AA7: call_function_return 0x588220 num_params 0 pop 0 func_ret [bool]
</pre>

#### NextValidModelId

<pre>
plugin::CallAndReturn<int, 0x585050, int, int>(currentModelIndex, PrevOrNextModelIndex);
0AA7: call_function_return 0x585050 num_params 2 pop 2 [currentModelIndex] [PrevOrNextModelIndex] func_ret [int]
</pre>

### plugin_III\game_III\CScrollBar.cpp

#### CScrollBar::Init

<pre>
plugin::CallMethodDynGlobal<CScrollBar *, CVector, unsigned char, float, float, float, unsigned char, unsigned char, unsigned char, float>(gaddrof(CScrollBar::Init), this, pos, type, sizeX, sizeY, sizeZ, red, green, blue, scale);
0AA6: call_method 0x4FF610 struct [CScrollBar] num_params 9 pop 0 [pos] [type] [sizeX] [sizeY] [sizeZ] [red] [green] [blue] [scale]
</pre>

#### CScrollBar::Render

<pre>
plugin::CallMethodDynGlobal<CScrollBar *>(gaddrof(CScrollBar::Render), this);
0AA6: call_method 0x4FFCE0 struct [CScrollBar] num_params 0 pop 0
</pre>

#### CScrollBar::Update

<pre>
plugin::CallMethodDynGlobal<CScrollBar *>(gaddrof(CScrollBar::Update), this);
0AA6: call_method 0x4FF6E0 struct [CScrollBar] num_params 0 pop 0
</pre>

#### \*CScrollBar::GetBridgeString

<pre>
plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CScrollBar::GetBridgeString));
</pre>

#### \*CScrollBar::GetTunnelString

<pre>
plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CScrollBar::GetTunnelString));
</pre>

### plugin_III\game_III\CShadows.cpp

#### CPermanentShadow::CPermanentShadow

<pre>
plugin::CallMethod<0x517900, CPermanentShadow *>(this);
0AA6: call_method 0x517900 struct [CPermanentShadow] num_params 0 pop 0
</pre>

#### CStaticShadow::CStaticShadow

<pre>
plugin::CallMethod<0x517910, CStaticShadow *>(this);
0AA6: call_method 0x517910 struct [CStaticShadow] num_params 0 pop 0
</pre>

#### CStaticShadow::Free

<pre>
plugin::CallMethod<0x516E70, CStaticShadow *>(this);
0AA6: call_method 0x516E70 struct [CStaticShadow] num_params 0 pop 0
</pre>

#### CPolyBunch::CPolyBunch

<pre>
plugin::CallMethod<0x517920, CPolyBunch *>(this);
0AA6: call_method 0x517920 struct [CPolyBunch] num_params 0 pop 0
</pre>

#### CRegisteredShadow::CRegisteredShadow

<pre>
plugin::CallMethod<0x517940, CRegisteredShadow *>(this);
0AA6: call_method 0x517940 struct [CRegisteredShadow] num_params 0 pop 0
</pre>

#### CShadows::RenderIndicatorShadow

<pre>
plugin::Call<0x517810, unsigned int, unsigned char, RwTexture*, CVector*, float, float, float, float, short>(id, shadowType, texture, posn, frontX, frontY, sideX, sideY, intensity);
0AA5: call_function 0x517810 num_params 9 pop 9 [id] [shadowType] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity]
</pre>

#### CShadows::Init

<pre>
plugin::Call<0x512AB0>();
0AA5: call_function 0x512AB0 num_params 0 pop 0
</pre>

#### CShadows::Shutdown

<pre>
plugin::Call<0x512F20>();
0AA5: call_function 0x512F20 num_params 0 pop 0
</pre>

#### CShadows::AddPermanentShadow

<pre>
plugin::Call<0x512FD0, unsigned char, RwTexture*, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, unsigned int, float>(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, time, upDistance);
0AA5: call_function 0x512FD0 num_params 14 pop 14 [type] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [time] [upDistance]
</pre>

#### CShadows::StoreStaticShadow

<pre>
plugin::Call<0x5130A0, unsigned int, unsigned char, RwTexture*, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, float, bool, float>(id, type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, drawDistance, temporaryShadow, upDistance);
0AA5: call_function 0x5130A0 num_params 17 pop 17 [id] [type] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [scale] [drawDistance] [temporaryShadow] [upDistance]
</pre>

#### CShadows::StoreShadowToBeRendered

<pre>
plugin::Call<0x513550, unsigned char, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char>(shadowTextureType, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue);
0AA5: call_function 0x513550 num_params 10 pop 10 [shadowTextureType] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue]
</pre>

#### CShadows::StoreShadowToBeRendered

<pre>
plugin::Call<0x513750, unsigned char, RwTexture*, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, bool, float>(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, drawOnWater, scale);
0AA5: call_function 0x513750 num_params 14 pop 14 [type] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [drawOnWater] [scale]
</pre>

#### CShadows::StoreShadowForCar

<pre>
plugin::Call<0x513830, CAutomobile*>(car);
0AA5: call_function 0x513830 num_params 1 pop 1 [car]
</pre>

#### CShadows::StoreCarLightShadow

<pre>
plugin::Call<0x513A70, CVehicle*, int, RwTexture*, CVector*, float, float, float, float, unsigned char, unsigned char, unsigned char, float>(vehicle, id, texture, posn, frontX, frontY, sideX, sideY, red, green, blue, maxViewAngle);
0AA5: call_function 0x513A70 num_params 12 pop 12 [vehicle] [id] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [red] [green] [blue] [maxViewAngle]
</pre>

#### CShadows::StoreShadowForPed

<pre>
plugin::Call<0x513C50, CPed*, float, float, float, float, float, float>(ped, displacementX, displacementY, frontX, frontY, sideX, sideY);
0AA5: call_function 0x513C50 num_params 7 pop 7 [ped] [displacementX] [displacementY] [frontX] [frontY] [sideX] [sideY]
</pre>

#### CShadows::StoreShadowForPedObject

<pre>
plugin::Call<0x513CB0, CEntity*, float, float, float, float, float, float>(entity, displacementX, displacementY, frontX, frontY, sideX, sideY);
0AA5: call_function 0x513CB0 num_params 7 pop 7 [entity] [displacementX] [displacementY] [frontX] [frontY] [sideX] [sideY]
</pre>

#### CShadows::StoreShadowForTree

<pre>
plugin::Call<0x513E00, CEntity*>(entity);
0AA5: call_function 0x513E00 num_params 1 pop 1 [entity]
</pre>

#### CShadows::StoreShadowForPole

<pre>
plugin::Call<0x513E10, CEntity*, float, float, float, float, float, unsigned int>(entity, offsetX, offsetY, offsetZ, poleHeight, poleWidth, localId);
0AA5: call_function 0x513E10 num_params 7 pop 7 [entity] [offsetX] [offsetY] [offsetZ] [poleHeight] [poleWidth] [localId]
</pre>

#### CShadows::SetRenderModeForShadowType

<pre>
plugin::Call<0x513FC0, unsigned char>(shadowType);
0AA5: call_function 0x513FC0 num_params 1 pop 1 [shadowType]
</pre>

#### CShadows::RenderStoredShadows

<pre>
plugin::Call<0x514010>();
0AA5: call_function 0x514010 num_params 0 pop 0
</pre>

#### CShadows::RenderStaticShadows

<pre>
plugin::Call<0x5145F0>();
0AA5: call_function 0x5145F0 num_params 0 pop 0
</pre>

#### CShadows::GeneratePolysForStaticShadow

<pre>
plugin::Call<0x514910, short>(staticShadowIndex);
0AA5: call_function 0x514910 num_params 1 pop 1 [staticShadowIndex]
</pre>

#### CShadows::CastShadowSectorList

<pre>
plugin::Call<0x514C90, CPtrList&, float, float, float, float, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, CPolyBunch**>(ptrList, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch);
0AA5: call_function 0x514C90 num_params 17 pop 17 [ptrList] [conrerAX] [cornerAY] [cornerBX] [cornerBY] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [scale] [ppPolyBunch]
</pre>

#### CShadows::CastShadowEntity

<pre>
plugin::Call<0x514E30, CEntity*, float, float, float, float, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, CPolyBunch**>(entity, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch);
0AA5: call_function 0x514E30 num_params 17 pop 17 [entity] [conrerAX] [cornerAY] [cornerBX] [cornerBY] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [scale] [ppPolyBunch]
</pre>

#### CShadows::UpdateStaticShadows

<pre>
plugin::Call<0x516BE0>();
0AA5: call_function 0x516BE0 num_params 0 pop 0
</pre>

#### CShadows::UpdatePermanentShadows

<pre>
plugin::Call<0x516C40>();
0AA5: call_function 0x516C40 num_params 0 pop 0
</pre>

#### CShadows::CalcPedShadowValues

<pre>
plugin::Call<0x516EB0, CVector, float*, float*, float*, float*, float*, float*>(sunPosn, displacementX, displacementY, frontX, frontY, sideX, sideY);
0AA5: call_function 0x516EB0 num_params 7 pop 7 [sunPosn] [displacementX] [displacementY] [frontX] [frontY] [sideX] [sideY]
</pre>

#### CShadows::RenderExtraPlayerShadows

<pre>
plugin::Call<0x516F90>();
0AA5: call_function 0x516F90 num_params 0 pop 0
</pre>

#### CShadows::TidyUpShadows

<pre>
plugin::Call<0x517570>();
0AA5: call_function 0x517570 num_params 0 pop 0
</pre>

### plugin_III\game_III\CShinyTexts.cpp

#### CShinyTexts::RegisterOne

<pre>
plugin::CallDynGlobal<CVector, CVector, CVector, CVector, float, float, float, float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof(CShinyTexts::RegisterOne), cornerAA, cornerAB, cornerBA, cornerBB, u1, v1, u2, v2, u3, v3, u4, v4, type, red, green, blue, maxDistance);
</pre>

### plugin_III\game_III\CShotInfo.cpp

#### CShotInfo::AddShot

<pre>
plugin::CallAndReturnDynGlobal<bool, CEntity *, eWeaponType, CVector, CVector>(gaddrof(CShotInfo::AddShot), sourceEntity, weaponType, startPos, endPos);
</pre>

### plugin_III\game_III\CSimpleModelInfo.cpp

#### CSimpleModelInfo::DeleteRwObject

<pre>
plugin::CallVirtualMethod<2, CSimpleModelInfo *>(this);
</pre>

#### \*CSimpleModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 3, CSimpleModelInfo *>(this);
</pre>

#### \*CSimpleModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 4, CSimpleModelInfo *, RwMatrix *>(this, matrix);
</pre>

#### \*CSimpleModelInfo::GetRwObject

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 5, CSimpleModelInfo *>(this);
</pre>

#### CSimpleModelInfo::FindRelatedModel

<pre>
plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::FindRelatedModel), this);
0AA6: call_method 0x517C00 struct [CSimpleModelInfo] num_params 0 pop 0
</pre>

#### \*CSimpleModelInfo::GetAtomicFromDistance

<pre>
plugin::CallMethodAndReturnDynGlobal<RpAtomic *, CSimpleModelInfo *, float>(gaddrof(CSimpleModelInfo::GetAtomicFromDistance), this, distance);
0AA8: call_method_return 0x517A00 struct [*CSimpleModelInfo] num_params 1 pop 0 [distance] func_ret [RpAtomic *]
</pre>

#### CSimpleModelInfo::GetLargestLodDistance

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::GetLargestLodDistance), this);
0AA8: call_method_return 0x517A60 struct [CSimpleModelInfo] num_params 0 pop 0 func_ret [float]
</pre>

#### CSimpleModelInfo::GetNearDistance

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::GetNearDistance), this);
0AA8: call_method_return 0x517A90 struct [CSimpleModelInfo] num_params 0 pop 0 func_ret [float]
</pre>

#### CSimpleModelInfo::IncreaseAlpha

<pre>
plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::IncreaseAlpha), this);
0AA6: call_method 0x517C60 struct [CSimpleModelInfo] num_params 0 pop 0
</pre>

#### CSimpleModelInfo::Init

<pre>
plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::Init), this);
0AA6: call_method 0x517990 struct [CSimpleModelInfo] num_params 0 pop 0
</pre>

#### CSimpleModelInfo::SetAtomic

<pre>
plugin::CallMethodDynGlobal<CSimpleModelInfo *, int, RpAtomic *>(gaddrof(CSimpleModelInfo::SetAtomic), this, number, atomic);
0AA6: call_method 0x517950 struct [CSimpleModelInfo] num_params 2 pop 0 [number] [atomic]
</pre>

#### CSimpleModelInfo::SetLodDistances

<pre>
plugin::CallMethodDynGlobal<CSimpleModelInfo *, float *>(gaddrof(CSimpleModelInfo::SetLodDistances), this, distance);
0AA6: call_method 0x517AA0 struct [CSimpleModelInfo] num_params 1 pop 0 [distance]
</pre>

#### CSimpleModelInfo::SetupBigBuilding

<pre>
plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::SetupBigBuilding), this);
0AA6: call_method 0x517B90 struct [CSimpleModelInfo] num_params 0 pop 0
</pre>

### plugin_III\game_III\CSkidmarks.cpp

#### CSkidmarks::RegisterOne

<pre>
plugin::CallDynGlobal<unsigned int, CVector, float, float, bool *, bool *>(gaddrof(CSkidmarks::RegisterOne), id, pos, fwdX, fwdY, isMuddy, isBloody);
</pre>

### plugin_III\game_III\CSpecialFX.cpp

#### \*LookForBatCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(LookForBatCB), object, data);
</pre>

### plugin_III\game_III\CSpecialParticleStuff.cpp

#### CSpecialParticleStuff::CreateFoamAroundObject

<pre>
plugin::CallDynGlobal<CMatrix *, float, float, float, int>(gaddrof(CSpecialParticleStuff::CreateFoamAroundObject), matrix, x, y, z, particles);
</pre>

#### CSpecialParticleStuff::UpdateBoatFoamAnimation

<pre>
plugin::CallDynGlobal<CMatrix *>(gaddrof(CSpecialParticleStuff::UpdateBoatFoamAnimation), matrix);
</pre>

### plugin_III\game_III\CSprite.cpp

#### CSprite::CalcHorizonCoors

<pre>
plugin::CallAndReturnDynGlobal<float>(gaddrof(CSprite::CalcHorizonCoors));
</pre>

#### CSprite::CalcScreenCoors

<pre>
plugin::CallAndReturnDynGlobal<bool, RwV3d const &, RwV3d *, float *, float *, bool>(gaddrof(CSprite::CalcScreenCoors), in, out, outW, outH, farClip);
</pre>

#### CSprite::RenderBufferedOneXLUSprite

<pre>
plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite), x, y, z, w, h, red, green, blue, alpha, rhw, intensity);
</pre>

#### CSprite::RenderBufferedOneXLUSprite2D

<pre>
plugin::CallDynGlobal<float, float, float, float, RwRGBA const &, short, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite2D), x, y, w, h, color, intensity, alpha);
</pre>

#### CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension

<pre>
plugin::CallDynGlobal<float, float, float, float, RwRGBA const &, short, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension), x, y, w, h, color, intensity, angle, alpha);
</pre>

#### CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours

<pre>
plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float, float, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours), x, y, z, w, h, red, green, blue, red2, green2, blue2, colx, coly, rhw, angle, intensity);
</pre>

#### CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect

<pre>
plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);
</pre>

#### CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension

<pre>
plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);
</pre>

#### CSprite::RenderOneXLUSprite

<pre>
plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(gaddrof(CSprite::RenderOneXLUSprite), x, y, z, w, h, red, green, blue, alpha, rhw, intensity);
</pre>

#### CSprite::RenderOneXLUSprite_Rotate_Aspect

<pre>
plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderOneXLUSprite_Rotate_Aspect), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);
</pre>

#### CSprite::Set6Vertices2D

<pre>
plugin::CallDynGlobal<RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite::Set6Vertices2D, void (*)(RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), vertex, rect, color1, color2, color3, color4);
</pre>

#### CSprite::Set6Vertices2D

<pre>
plugin::CallDynGlobal<RwIm2DVertex *, float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite::Set6Vertices2D, void (*)(RwIm2DVertex *, float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), vertex, x1, y1, x2, y2, x3, y3, x4, y4, color1, color2, color3, color4);
</pre>

### plugin_III\game_III\CSprite2d.cpp

#### CSprite2d::Delete

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(gaddrof(CSprite2d::Delete), this);
0AA6: call_method 0x51EA00 struct [CSprite2d] num_params 0 pop 0
</pre>

#### CSprite2d::Draw

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, float, float, float, float, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(float, float, float, float, CRGBA const &)), this, x, y, w, h, color);
0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 5 pop 0 [x] [y] [w] [h] [color]
</pre>

#### CSprite2d::Draw

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &, CRGBA const &)), this, rect, color);
0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 2 pop 0 [rect] [color]
</pre>

#### CSprite2d::Draw

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &, CRGBA const &, float, float, float, float, float, float, float, float)), this, rect, color, u1, v1, u2, v2, u3, v3, u4, v4);
0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 10 pop 0 [rect] [color] [u1] [v1] [u2] [v2] [u3] [v3] [u4] [v4]
</pre>

#### CSprite2d::Draw

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), this, rect, color1, color2, color3, color4);
0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 5 pop 0 [rect] [color1] [color2] [color3] [color4]
</pre>

#### CSprite2d::Draw

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, float, float, float, float, float, float, float, float, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(float, float, float, float, float, float, float, float, CRGBA const &)), this, x1, y1, x2, y2, x3, y3, x4, y4, color);
0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 9 pop 0 [x1] [y1] [x2] [y2] [x3] [y3] [x4] [y4] [color]
</pre>

#### CSprite2d::SetAddressing

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, RwTextureAddressMode>(gaddrof(CSprite2d::SetAddressing), this, modeUV);
0AA6: call_method 0x51EAA0 struct [CSprite2d] num_params 1 pop 0 [modeUV]
</pre>

#### CSprite2d::SetRenderState

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(gaddrof(CSprite2d::SetRenderState), this);
0AA6: call_method 0x51F950 struct [CSprite2d] num_params 0 pop 0
</pre>

#### CSprite2d::SetTexture

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, char *>(gaddrof_o(CSprite2d::SetTexture, void (CSprite2d::*)(char *)), this, name);
0AA6: call_method 0x51EA70 struct [CSprite2d] num_params 1 pop 0 [name]
</pre>

#### CSprite2d::SetTexture

<pre>
plugin::CallMethodDynGlobal<CSprite2d *, char *, char *>(gaddrof_o(CSprite2d::SetTexture, void (CSprite2d::*)(char *, char *)), this, name, maskName);
0AA6: call_method 0x51EA70 struct [CSprite2d] num_params 2 pop 0 [name] [maskName]
</pre>

#### CSprite2d::AddSpriteToBank

<pre>
plugin::CallDynGlobal<int, CRect const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof(CSprite2d::AddSpriteToBank), bank, rect, color, u1, v1, u2, v2, u3, v3, u4, v4);
</pre>

#### CSprite2d::DrawBank

<pre>
plugin::CallDynGlobal<int>(gaddrof(CSprite2d::DrawBank), bank);
</pre>

#### CSprite2d::DrawRect

<pre>
plugin::CallDynGlobal<CRect const &, CRGBA const &>(gaddrof_o(CSprite2d::DrawRect, void (*)(CRect const &, CRGBA const &)), rect, color);
</pre>

#### CSprite2d::DrawRect

<pre>
plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::DrawRect, void (*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), rect, color1, color2, color3, color4);
</pre>

#### CSprite2d::DrawRectXLU

<pre>
plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof(CSprite2d::DrawRectXLU), rect, color1, color2, color3, color4);
</pre>

#### CSprite2d::GetBank

<pre>
plugin::CallAndReturnDynGlobal<int, int, RwTexture *>(gaddrof(CSprite2d::GetBank), n, texture);
</pre>

#### CSprite2d::SetMaskVertices

<pre>
plugin::CallDynGlobal<int, float *>(gaddrof(CSprite2d::SetMaskVertices), numVerts, pos);
</pre>

#### CSprite2d::SetVertices

<pre>
plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, unsigned int>(gaddrof_o(CSprite2d::SetVertices, void (*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, unsigned int)), rect, color1, color2, color3, color4, bFar);
</pre>

#### CSprite2d::SetVertices

<pre>
plugin::CallDynGlobal<float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::SetVertices, void (*)(float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &)), x1, y1, x2, y2, x3, y3, x4, y4, color1, color2, color3, color4);
</pre>

#### CSprite2d::SetVertices

<pre>
plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::SetVertices, void (*)(CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float)), rect, color1, color2, color3, color4, u1, v1, u2, v2, u3, v3, u4, v4);
</pre>

#### CSprite2d::SetVertices

<pre>
plugin::CallDynGlobal<int, float *, float *, CRGBA const &>(gaddrof_o(CSprite2d::SetVertices, void (*)(int, float *, float *, CRGBA const &)), numVerts, pos, texCoors, color);
</pre>

#### CSprite2d::SetVertices

<pre>
plugin::CallDynGlobal<RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::SetVertices, void (*)(RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float)), vertices, rect, color1, color2, color3, color4, u1, v1, u2, v2, u3, v3, u4, v4);
</pre>

### plugin_III\game_III\CStats.cpp

#### CStats::AnotherCriminalCaught

<pre>
plugin::Call<0x4AB050>();
0AA5: call_function 0x4AB050 num_params 0 pop 0
</pre>

#### CStats::AnotherFireExtinguished

<pre>
plugin::Call<0x4AB080>();
0AA5: call_function 0x4AB080 num_params 0 pop 0
</pre>

#### CStats::AnotherKillFrenzyPassed

<pre>
plugin::Call<0x4AB240>();
0AA5: call_function 0x4AB240 num_params 0 pop 0
</pre>

#### CStats::AnotherLifeSavedWithAmbulance

<pre>
plugin::Call<0x4AB040>();
0AA5: call_function 0x4AB040 num_params 0 pop 0
</pre>

#### CStats::CheckPointReachedSuccessfully

<pre>
plugin::Call<0x4AB270>();
0AA5: call_function 0x4AB270 num_params 0 pop 0
</pre>

#### CStats::CheckPointReachedUnsuccessfully

<pre>
plugin::Call<0x4AB290>();
0AA5: call_function 0x4AB290 num_params 0 pop 0
</pre>

#### CStats::FindCriminalRatingNumber

<pre>
plugin::CallAndReturn<int, 0x4AB2A0>();
0AA7: call_function_return 0x4AB2A0 num_params 0 pop 0 func_ret [int]
</pre>

#### CStats::FindCriminalRatingString

<pre>
plugin::CallAndReturn<wchar_t*, 0x4AB090>();
0AA7: call_function_return 0x4AB090 num_params 0 pop 0 func_ret [wchar_t*]
</pre>

#### CStats::Init

<pre>
plugin::Call<0x4AAC60>();
0AA5: call_function 0x4AAC60 num_params 0 pop 0
</pre>

#### CStats::LoadStats

<pre>
plugin::Call<0x4AB670, unsigned char*, unsigned int>(bufferPointer, structSize);
0AA5: call_function 0x4AB670 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CStats::Register4x4MayhemTime

<pre>
plugin::Call<0x4AB020, int>(time);
0AA5: call_function 0x4AB020 num_params 1 pop 1 [time]
</pre>

#### CStats::Register4x4OneTime

<pre>
plugin::Call<0x4AAFC0, int>(time);
0AA5: call_function 0x4AAFC0 num_params 1 pop 1 [time]
</pre>

#### CStats::Register4x4ThreeTime

<pre>
plugin::Call<0x4AB000, int>(time);
0AA5: call_function 0x4AB000 num_params 1 pop 1 [time]
</pre>

#### CStats::Register4x4TwoTime

<pre>
plugin::Call<0x4AAFE0, int>(time);
0AA5: call_function 0x4AAFE0 num_params 1 pop 1 [time]
</pre>

#### CStats::RegisterElBurroTime

<pre>
plugin::Call<0x4AAFA0, int>(time);
0AA5: call_function 0x4AAFA0 num_params 1 pop 1 [time]
</pre>

#### CStats::RegisterFastestTime

<pre>
plugin::Call<0x4AAF50, int, int>(statID, time);
0AA5: call_function 0x4AAF50 num_params 2 pop 2 [statID] [time]
</pre>

#### CStats::RegisterHighestScore

<pre>
plugin::Call<0x4AAF80, int, int>(statID, score);
0AA5: call_function 0x4AAF80 num_params 2 pop 2 [statID] [score]
</pre>

#### CStats::RegisterLevelAmbulanceMission

<pre>
plugin::Call<0x4AB060, int>(level);
0AA5: call_function 0x4AB060 num_params 1 pop 1 [level]
</pre>

#### CStats::RegisterLongestFlightInDodo

<pre>
plugin::Call<0x4AB200, int>(distance);
0AA5: call_function 0x4AB200 num_params 1 pop 1 [distance]
</pre>

#### CStats::RegisterTimeTakenDefuseMission

<pre>
plugin::Call<0x4AB220, int>(time);
0AA5: call_function 0x4AB220 num_params 1 pop 1 [time]
</pre>

#### CStats::SaveStats

<pre>
plugin::Call<0x4AB3E0, unsigned char*, unsigned int*>(bufferPointer, structSize);
0AA5: call_function 0x4AB3E0 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CStats::SetTotalNumberKillFrenzies

<pre>
plugin::Call<0x4AB250, int>(number);
0AA5: call_function 0x4AB250 num_params 1 pop 1 [number]
</pre>

#### CStats::SetTotalNumberMissions

<pre>
plugin::Call<0x4AB260, int>(number);
0AA5: call_function 0x4AB260 num_params 1 pop 1 [number]
</pre>

### plugin_III\game_III\CStoredCar.cpp

#### \*CStoredCar::RestoreCar

<pre>
plugin::CallMethodAndReturnDynGlobal<CVehicle *, CStoredCar *>(gaddrof(CStoredCar::RestoreCar), this);
0AA8: call_method_return 0x427690 struct [*CStoredCar] num_params 0 pop 0 func_ret [CVehicle *]
</pre>

#### CStoredCar::StoreCar

<pre>
plugin::CallMethodDynGlobal<CStoredCar *, CVehicle *>(gaddrof(CStoredCar::StoreCar), this, vehicle);
0AA6: call_method 0x4275C0 struct [CStoredCar] num_params 1 pop 0 [vehicle]
</pre>

#### CStoredCar::SetExtras

<pre>
plugin::CallDynGlobal<char, char>(gaddrof(CStoredCar::SetExtras), first, second);
</pre>

### plugin_III\game_III\CStreaming.cpp

#### CStreaming::RequestModel

<pre>
plugin::Call<0x407EA0, int, int>(modelIndex, flags);
0AA5: call_function 0x407EA0 num_params 2 pop 2 [modelIndex] [flags]
</pre>

#### CStreaming::LoadRequestedModels

<pre>
plugin::Call<0x40A390>();
0AA5: call_function 0x40A390 num_params 0 pop 0
</pre>

#### CStreaming::Init

<pre>
plugin::Call<0x406430>();
0AA5: call_function 0x406430 num_params 0 pop 0
</pre>

#### CStreaming::FlushChannels

<pre>
plugin::Call<0x40A610>();
0AA5: call_function 0x40A610 num_params 0 pop 0
</pre>

#### CStreaming::FlushRequestList

<pre>
plugin::Call<0x40A680>();
0AA5: call_function 0x40A680 num_params 0 pop 0
</pre>

#### CStreaming::GetAvailableVehicleSlot

<pre>
plugin::CallAndReturn<int, 0x40B160>();
0AA7: call_function_return 0x40B160 num_params 0 pop 0 func_ret [int]
</pre>

#### CStreaming::IsTxdUsedByRequestedModels

<pre>
plugin::CallAndReturn<bool, 0x4094C0, int>(index);
0AA7: call_function_return 0x4094C0 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CStreaming::LoadAllRequestedModels

<pre>
plugin::Call<0x40A440, bool>(onlyQuickRequests);
0AA5: call_function 0x40A440 num_params 1 pop 1 [onlyQuickRequests]
</pre>

#### CStreaming::RemoveModel

<pre>
plugin::Call<0x408830, int>(modelIndex);
0AA5: call_function 0x408830 num_params 1 pop 1 [modelIndex]
</pre>

#### CStreaming::RemoveLeastUsedModel

<pre>
plugin::CallAndReturn<bool, 0x4089B0>();
0AA7: call_function_return 0x4089B0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CStreaming::RemoveLoadedVehicle

<pre>
plugin::CallAndReturn<bool, 0x40B180>();
0AA7: call_function_return 0x40B180 num_params 0 pop 0 func_ret [bool]
</pre>

#### CStreaming::RemoveAllUnusedModels

<pre>
plugin::Call<0x408940>();
0AA5: call_function 0x408940 num_params 0 pop 0
</pre>

#### CStreaming::RemoveCurrentZonesModels

<pre>
plugin::Call<0x40AD00>();
0AA5: call_function 0x40AD00 num_params 0 pop 0
</pre>

#### CStreaming::RemoveUnusedModelsInLoadedList

<pre>
plugin::Call<0x4089A0>();
0AA5: call_function 0x4089A0 num_params 0 pop 0
</pre>

#### CStreaming::RequestModelStream

<pre>
plugin::Call<0x40A060, int>(streamnum);
0AA5: call_function 0x40A060 num_params 1 pop 1 [streamnum]
</pre>

#### CStreaming::RequestSpecialChar

<pre>
plugin::Call<0x40ADA0, int, char const*, int>(index, txdname, modelrequestflag);
0AA5: call_function 0x40ADA0 num_params 3 pop 3 [index] [txdname] [modelrequestflag]
</pre>

#### CStreaming::RequestSpecialModel

<pre>
plugin::Call<0x40A890, int, char const*, int>(slot, name, modelrequestflag);
0AA5: call_function 0x40A890 num_params 3 pop 3 [slot] [name] [modelrequestflag]
</pre>

#### CStreaming::RequestSubway

<pre>
plugin::Call<0x407FD0>();
0AA5: call_function 0x407FD0 num_params 0 pop 0
</pre>

#### CStreaming::SetMissionDoesntRequireModel

<pre>
plugin::Call<0x40A820, int>(modelIndex);
0AA5: call_function 0x40A820 num_params 1 pop 1 [modelIndex]
</pre>

#### CStreaming::SetMissionDoesntRequireSpecialChar

<pre>
plugin::Call<0x40ADE0, int>(index);
0AA5: call_function 0x40ADE0 num_params 1 pop 1 [index]
</pre>

#### CStreaming::SetModelIsDeletable

<pre>
plugin::Call<0x40A790, int>(modelIndex);
0AA5: call_function 0x40A790 num_params 1 pop 1 [modelIndex]
</pre>

#### CStreaming::SetModelTxdIsDeletable

<pre>
plugin::Call<0x40A800, int>(modelIndex);
0AA5: call_function 0x40A800 num_params 1 pop 1 [modelIndex]
</pre>

#### CStreaming::Shutdown

<pre>
plugin::Call<0x406C80>();
0AA5: call_function 0x406C80 num_params 0 pop 0
</pre>

#### CStreaming::StreamVehiclesAndPeds

<pre>
plugin::Call<0x40AE60>();
0AA5: call_function 0x40AE60 num_params 0 pop 0
</pre>

#### CStreaming::Update

<pre>
plugin::Call<0x4076C0>();
0AA5: call_function 0x4076C0 num_params 0 pop 0
</pre>

#### CStreaming::UpdateMemoryUsed

<pre>
plugin::Call<0x4076B0>();
0AA5: call_function 0x4076B0 num_params 0 pop 0
</pre>

#### CStreaming::AddModelsToRequestList

<pre>
plugin::Call<0x4078F0, CVector const&>(point);
0AA5: call_function 0x4078F0 num_params 1 pop 1 [point]
</pre>

#### CStreaming::AddToLoadedVehiclesList

<pre>
plugin::Call<0x40B060, int>(vehicleId);
0AA5: call_function 0x40B060 num_params 1 pop 1 [vehicleId]
</pre>

#### CStreaming::ConvertBufferToObject

<pre>
plugin::CallAndReturn<bool, 0x409740, char*, int>(pFileContect, modelIndex);
0AA7: call_function_return 0x409740 num_params 2 pop 2 [pFileContect] [modelIndex] func_ret [bool]
</pre>

#### CStreaming::DeleteAllRwObjects

<pre>
plugin::Call<0x407390>();
0AA5: call_function 0x407390 num_params 0 pop 0
</pre>

#### CStreaming::DeleteFarAwayRwObjects

<pre>
plugin::Call<0x407070, CVector const&>(point);
0AA5: call_function 0x407070 num_params 1 pop 1 [point]
</pre>

#### CStreaming::DeleteRwObjectsAfterDeath

<pre>
plugin::Call<0x407400, CVector const&>(point);
0AA5: call_function 0x407400 num_params 1 pop 1 [point]
</pre>

#### CStreaming::DeleteRwObjectsBehindCamera

<pre>
plugin::Call<0x408A60, int>(size);
0AA5: call_function 0x408A60 num_params 1 pop 1 [size]
</pre>

#### CStreaming::DeleteRwObjectsBehindCameraInSectorList

<pre>
plugin::CallAndReturn<bool, 0x409340, CPtrList&, int>(list, size);
0AA7: call_function_return 0x409340 num_params 2 pop 2 [list] [size] func_ret [bool]
</pre>

#### CStreaming::DeleteRwObjectsInOverlapSectorList

<pre>
plugin::Call<0x4075A0, CPtrList&, int, int>(list, arg1, arg2);
0AA5: call_function 0x4075A0 num_params 3 pop 3 [list] [arg1] [arg2]
</pre>

#### CStreaming::DeleteRwObjectsInSectorList

<pre>
plugin::Call<0x407560, CPtrList&>(list);
0AA5: call_function 0x407560 num_params 1 pop 1 [list]
</pre>

#### CStreaming::DeleteRwObjectsNotInFrustumInSectorList

<pre>
plugin::CallAndReturn<bool, 0x4093C0, CPtrList&, int>(list, size);
0AA7: call_function_return 0x4093C0 num_params 2 pop 2 [list] [size] func_ret [bool]
</pre>

#### CStreaming::FinishLoadingLargeFile

<pre>
plugin::CallAndReturn<bool, 0x409580, char*, int>(FileName, modelIndex);
0AA7: call_function_return 0x409580 num_params 2 pop 2 [FileName] [modelIndex] func_ret [bool]
</pre>

#### CStreaming::GetCdImageOffset

<pre>
plugin::CallAndReturn<unsigned int, 0x409FF0, int>(arg0);
0AA7: call_function_return 0x409FF0 num_params 1 pop 1 [arg0] func_ret [unsigned int]
</pre>

#### CStreaming::GetNextFileOnCd

<pre>
plugin::CallAndReturn<int, 0x409E50, int, bool>(arg0, arg1);
0AA7: call_function_return 0x409E50 num_params 2 pop 2 [arg0] [arg1] func_ret [int]
</pre>

#### CStreaming::HasSpecialCharLoaded

<pre>
plugin::CallAndReturn<bool, 0x40ADC0, int>(modelIndex);
0AA7: call_function_return 0x40ADC0 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CStreaming::HaveAllBigBuildingsLoaded

<pre>
plugin::Call<0x408280, eLevelName>(levelName);
0AA5: call_function 0x408280 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::IHaveUsedStreamingMemory

<pre>
plugin::Call<0x409BD0>();
0AA5: call_function 0x409BD0 num_params 0 pop 0
</pre>

#### CStreaming::ImGonnaUseStreamingMemory

<pre>
plugin::Call<0x409BC0>();
0AA5: call_function 0x409BC0 num_params 0 pop 0
</pre>

#### CStreaming::IsObjectInCdImage

<pre>
plugin::CallAndReturn<bool, 0x407E70, int>(modelIndex);
0AA7: call_function_return 0x407E70 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CStreaming::LoadCdDirectory

<pre>
plugin::Call<0x406DA0, char const*, int>(archivename, archiveID);
0AA5: call_function 0x406DA0 num_params 2 pop 2 [archivename] [archiveID]
</pre>

#### CStreaming::LoadCdDirectory

<pre>
plugin::Call<0x406CC0>();
0AA5: call_function 0x406CC0 num_params 0 pop 0
</pre>

#### CStreaming::LoadInitialPeds

<pre>
plugin::Call<0x40AA00>();
0AA5: call_function 0x40AA00 num_params 0 pop 0
</pre>

#### CStreaming::LoadInitialVehicles

<pre>
plugin::Call<0x40ADF0>();
0AA5: call_function 0x40ADF0 num_params 0 pop 0
</pre>

#### CStreaming::LoadScene

<pre>
plugin::Call<0x40A6D0, CVector const&>(point);
0AA5: call_function 0x40A6D0 num_params 1 pop 1 [point]
</pre>

#### CStreaming::MakeSpaceFor

<pre>
plugin::Call<0x409B70, int>(size);
0AA5: call_function 0x409B70 num_params 1 pop 1 [size]
</pre>

#### CStreaming::MemoryCardLoad

<pre>
plugin::Call<0x40B250, unsigned char*, unsigned int>(arg0, arg1);
0AA5: call_function 0x40B250 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CStreaming::MemoryCardSave

<pre>
plugin::Call<0x40B210, unsigned char*, unsigned int*>(arg0, arg1);
0AA5: call_function 0x40B210 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CStreaming::ProcessEntitiesInSectorList

<pre>
plugin::Call<0x407DD0, CPtrList&>(list);
0AA5: call_function 0x407DD0 num_params 1 pop 1 [list]
</pre>

#### CStreaming::ProcessEntitiesInSectorList

<pre>
plugin::Call<0x407C50, CPtrList&, float, float, float, float, float, float>(list, x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x407C50 num_params 7 pop 7 [list] [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CStreaming::ProcessLoadingChannel

<pre>
plugin::CallAndReturn<bool, 0x409BE0, int>(channelindex);
0AA7: call_function_return 0x409BE0 num_params 1 pop 1 [channelindex] func_ret [bool]
</pre>

#### CStreaming::RemoveBigBuildings

<pre>
plugin::Call<0x408680, eLevelName>(levelName);
0AA5: call_function 0x408680 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RemoveBuildings

<pre>
plugin::Call<0x4083D0, eLevelName>(levelName);
0AA5: call_function 0x4083D0 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RemoveIslandsNotUsed

<pre>
plugin::Call<0x408780, eLevelName>(levelName);
0AA5: call_function 0x408780 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RemoveReferencedTxds

<pre>
plugin::CallAndReturn<bool, 0x409450, int>(arg0);
0AA7: call_function_return 0x409450 num_params 1 pop 1 [arg0] func_ret [bool]
</pre>

#### CStreaming::RemoveUnusedBigBuildings

<pre>
plugin::Call<0x408640, eLevelName>(levelName);
0AA5: call_function 0x408640 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RemoveUnusedBuildings

<pre>
plugin::Call<0x4083A0, eLevelName>(levelName);
0AA5: call_function 0x4083A0 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RequestBigBuildings

<pre>
plugin::Call<0x408190, eLevelName>(levelName);
0AA5: call_function 0x408190 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RequestIslands

<pre>
plugin::Call<0x408210, eLevelName>(levelName);
0AA5: call_function 0x408210 num_params 1 pop 1 [levelName]
</pre>

#### CStreaming::RetryLoadFile

<pre>
plugin::Call<0x4077F0, int>(streamnum);
0AA5: call_function 0x4077F0 num_params 1 pop 1 [streamnum]
</pre>

#### CStreaming::StreamZoneModels

<pre>
plugin::Call<0x40AA30, CVector const&>(point);
0AA5: call_function 0x40AA30 num_params 1 pop 1 [point]
</pre>

#### DeleteIsland

<pre>
plugin::Call<0x408740, CEntity*>(entity);
0AA5: call_function 0x408740 num_params 1 pop 1 [entity]
</pre>

### plugin_III\game_III\CStreamingInfo.cpp

#### CStreamingInfo::AddToList

<pre>
plugin::CallMethod<0x406380, CStreamingInfo *, CStreamingInfo*>(this, listStart);
0AA6: call_method 0x406380 struct [CStreamingInfo] num_params 1 pop 0 [listStart]
</pre>

#### CStreamingInfo::GetCdPosnAndSize

<pre>
plugin::CallMethodAndReturn<bool, 0x4063E0, CStreamingInfo *, unsigned int&, unsigned int&>(this, posn, size);
0AA8: call_method_return 0x4063E0 struct [CStreamingInfo] num_params 2 pop 0 [posn] [size] func_ret [bool]
</pre>

#### CStreamingInfo::GetCdSize

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x4063D0, CStreamingInfo *>(this);
0AA8: call_method_return 0x4063D0 struct [CStreamingInfo] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CStreamingInfo::RemoveFromList

<pre>
plugin::CallMethod<0x4063A0, CStreamingInfo *>(this);
0AA6: call_method 0x4063A0 struct [CStreamingInfo] num_params 0 pop 0
</pre>

#### CStreamingInfo::SetCdPosnAndSize

<pre>
plugin::CallMethod<0x406410, CStreamingInfo *, unsigned int, unsigned int>(this, posn, size);
0AA6: call_method 0x406410 struct [CStreamingInfo] num_params 2 pop 0 [posn] [size]
</pre>

### plugin_III\game_III\CStuckCarCheck.cpp

#### CStuckCarCheck::AddCarToCheck

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *, int, float, unsigned int>(gaddrof(CStuckCarCheck::AddCarToCheck), this, id, radius, time);
0AA6: call_method 0x4381C0 struct [CStuckCarCheck] num_params 3 pop 0 [id] [radius] [time]
</pre>

#### CStuckCarCheck::HasCarBeenStuckForAWhile

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::HasCarBeenStuckForAWhile), this, id);
0AA8: call_method_return 0x4382A0 struct [CStuckCarCheck] num_params 1 pop 0 [id] func_ret [bool]
</pre>

#### CStuckCarCheck::Init

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Init), this);
0AA6: call_method 0x438050 struct [CStuckCarCheck] num_params 0 pop 0
</pre>

#### CStuckCarCheck::Process

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Process), this);
0AA6: call_method 0x4380A0 struct [CStuckCarCheck] num_params 0 pop 0
</pre>

#### CStuckCarCheck::RemoveCarFromCheck

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::RemoveCarFromCheck), this, id);
0AA6: call_method 0x438240 struct [CStuckCarCheck] num_params 1 pop 0 [id]
</pre>

### plugin_III\game_III\CSurfaceTable.cpp

#### CSurfaceTable::GetAdhesionGroup

<pre>
plugin::CallAndReturnDynGlobal<int, unsigned char>(gaddrof(CSurfaceTable::GetAdhesionGroup), surfaceType);
</pre>

#### CSurfaceTable::GetAdhesiveLimit

<pre>
plugin::CallAndReturnDynGlobal<float, CColPoint &>(gaddrof(CSurfaceTable::GetAdhesiveLimit), colPoint);
</pre>

#### CSurfaceTable::GetWetMultiplier

<pre>
plugin::CallAndReturnDynGlobal<float, unsigned char>(gaddrof(CSurfaceTable::GetWetMultiplier), surfaceType);
</pre>

#### CSurfaceTable::Initialise

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CSurfaceTable::Initialise), fileName);
</pre>

### plugin_III\game_III\CText.cpp

#### \*CKeyArray::BinarySearch

<pre>
plugin::CallMethodAndReturnDynGlobal<CKeyEntry *, CKeyArray *, char const *, CKeyEntry *, short, short>(gaddrof(CKeyArray::BinarySearch), this, key, entries, low, high);
0AA8: call_method_return 0x52C060 struct [*CKeyArray] num_params 4 pop 0 [key] [entries] [low] [high] func_ret [CKeyEntry *]
</pre>

#### CKeyArray::Load

<pre>
plugin::CallMethodDynGlobal<CKeyArray *, unsigned int, unsigned char *, unsigned int *>(gaddrof(CKeyArray::Load), this, length, data, offset);
0AA6: call_method 0x52BE70 struct [CKeyArray] num_params 3 pop 0 [length] [data] [offset]
</pre>

#### \*CKeyArray::Search

<pre>
plugin::CallMethodAndReturnDynGlobal<wchar_t *, CKeyArray *, char const *>(gaddrof(CKeyArray::Search), this, key);
0AA8: call_method_return 0x52BFB0 struct [*CKeyArray] num_params 1 pop 0 [key] func_ret [wchar_t *]
</pre>

#### CKeyArray::Unload

<pre>
plugin::CallMethodDynGlobal<CKeyArray *>(gaddrof(CKeyArray::Unload), this);
0AA6: call_method 0x52BF60 struct [CKeyArray] num_params 0 pop 0
</pre>

#### CKeyArray::Update

<pre>
plugin::CallMethodDynGlobal<CKeyArray *, wchar_t *>(gaddrof(CKeyArray::Update), this, chars);
0AA6: call_method 0x52BF80 struct [CKeyArray] num_params 1 pop 0 [chars]
</pre>

#### CData::Load

<pre>
plugin::CallMethodDynGlobal<CData *, unsigned int, char *, int *>(gaddrof(CData::Load), this, length, data, offset);
0AA6: call_method 0x52C120 struct [CData] num_params 3 pop 0 [length] [data] [offset]
</pre>

#### CData::Unload

<pre>
plugin::CallMethodDynGlobal<CData *>(gaddrof(CData::Unload), this);
0AA6: call_method 0x52C200 struct [CData] num_params 0 pop 0
</pre>

#### \*CText::Get

<pre>
plugin::CallMethodAndReturnDynGlobal<wchar_t *, CText *, char const *>(gaddrof(CText::Get), this, key);
0AA8: call_method_return 0x52C5A0 struct [*CText] num_params 1 pop 0 [key] func_ret [wchar_t *]
</pre>

#### CText::GetUpperCase

<pre>
plugin::CallMethodAndReturnDynGlobal<wchar_t, CText *, wchar_t>(gaddrof(CText::GetUpperCase), this, c);
0AA8: call_method_return 0x52C220 struct [CText] num_params 1 pop 0 [c] func_ret [wchar_t]
</pre>

#### CText::Load

<pre>
plugin::CallMethodDynGlobal<CText *>(gaddrof(CText::Load), this);
0AA6: call_method 0x52C3C0 struct [CText] num_params 0 pop 0
</pre>

#### CText::Unload

<pre>
plugin::CallMethodDynGlobal<CText *>(gaddrof(CText::Unload), this);
0AA6: call_method 0x52C580 struct [CText] num_params 0 pop 0
</pre>

#### CText::UpperCase

<pre>
plugin::CallMethodDynGlobal<CText *, wchar_t *>(gaddrof(CText::UpperCase), this, s);
0AA6: call_method 0x52C2C0 struct [CText] num_params 1 pop 0 [s]
</pre>

#### \*UnicodeToAscii

<pre>
plugin::CallAndReturnDynGlobal<char *, wchar_t *>(gaddrof(UnicodeToAscii), src);
</pre>

#### \*UnicodeToAsciiForSaveLoad

<pre>
plugin::CallAndReturnDynGlobal<char *, wchar_t *>(gaddrof(UnicodeToAsciiForSaveLoad), src);
</pre>

#### TextCopy

<pre>
plugin::CallDynGlobal<wchar_t *, wchar_t const *>(gaddrof(TextCopy), dst, src);
</pre>

### plugin_III\game_III\CTheCarGenerators.cpp

#### CTheCarGenerators::CreateCarGenerator

<pre>
plugin::CallAndReturnDynGlobal<int, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(gaddrof(CTheCarGenerators::CreateCarGenerator), x, y, z, angle, modelId, colorPrim, colorSec, forceSpawn, alarm, doorLock, minDelay, maxDelay);
</pre>

#### CTheCarGenerators::LoadAllCarGenerators

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CTheCarGenerators::LoadAllCarGenerators), buffer, size);
</pre>

#### CTheCarGenerators::SaveAllCarGenerators

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CTheCarGenerators::SaveAllCarGenerators), buffer, size);
</pre>

### plugin_III\game_III\CTheScripts.cpp

#### CTheScripts::Init

<pre>
plugin::Call<0x438790>();
0AA5: call_function 0x438790 num_params 0 pop 0
</pre>

#### CTheScripts::IsPedStopped

<pre>
plugin::CallAndReturn<bool, 0x454670, CPed*>(ped);
0AA7: call_function_return 0x454670 num_params 1 pop 1 [ped] func_ret [bool]
</pre>

#### CTheScripts::IsPlayerOnAMission

<pre>
plugin::CallAndReturn<bool, 0x439410>();
0AA7: call_function_return 0x439410 num_params 0 pop 0 func_ret [bool]
</pre>

#### CTheScripts::IsPlayerStopped

<pre>
plugin::CallAndReturn<bool, 0x4546C0, CPlayerInfo*>(info);
0AA7: call_function_return 0x4546C0 num_params 1 pop 1 [info] func_ret [bool]
</pre>

#### CTheScripts::IsVehicleStopped

<pre>
plugin::CallAndReturn<bool, 0x454770, CVehicle*>(vehicle);
0AA7: call_function_return 0x454770 num_params 1 pop 1 [vehicle] func_ret [bool]
</pre>

#### CTheScripts::CleanUpThisPed

<pre>
plugin::Call<0x4547A0, CPed*>(ped);
0AA5: call_function 0x4547A0 num_params 1 pop 1 [ped]
</pre>

#### CTheScripts::CleanUpThisObject

<pre>
plugin::Call<0x454910, CObject*>(object);
0AA5: call_function 0x454910 num_params 1 pop 1 [object]
</pre>

#### CTheScripts::CleanUpThisVehicle

<pre>
plugin::Call<0x4548D0, CVehicle*>(vehicle);
0AA5: call_function 0x4548D0 num_params 1 pop 1 [vehicle]
</pre>

#### CTheScripts::ClearSpaceForMissionEntity

<pre>
plugin::Call<0x454060, CVector const&, CEntity*>(position, entity);
0AA5: call_function 0x454060 num_params 2 pop 2 [position] [entity]
</pre>

### plugin_III\game_III\CTheZones.cpp

#### CTheZones::FindSmallestZonePosition

<pre>
plugin::CallAndReturn<CZone*, 0x4B69B0, CVector const&>(pos);
0AA7: call_function_return 0x4B69B0 num_params 1 pop 1 [pos] func_ret [CZone*]
</pre>

#### CTheZones::FindSmallestZonePositionType

<pre>
plugin::CallAndReturn<CZone*, 0x4B6790, CVector const&, int>(pos, type);
0AA7: call_function_return 0x4B6790 num_params 2 pop 2 [pos] [type] func_ret [CZone*]
</pre>

#### CTheZones::GetZoneInfo

<pre>
plugin::CallAndReturn<CZoneInfo*, 0x4B6A10, CVector const&, char>(pos, day);
0AA7: call_function_return 0x4B6A10 num_params 2 pop 2 [pos] [day] func_ret [CZoneInfo*]
</pre>

### plugin_III\game_III\CTimeModelInfo.cpp

#### \*CTimeModelInfo::FindOtherTimeModel

<pre>
plugin::CallMethodAndReturnDynGlobal<CTimeModelInfo *, CTimeModelInfo *>(gaddrof(CTimeModelInfo::FindOtherTimeModel), this);
0AA8: call_method_return 0x517C80 struct [*CTimeModelInfo] num_params 0 pop 0 func_ret [CTimeModelInfo *]
</pre>

### plugin_III\game_III\CTimer.cpp

#### CTimer::GetCurrentTimeInCycles

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CTimer::GetCurrentTimeInCycles));
</pre>

#### CTimer::GetCyclesPerMillisecond

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CTimer::GetCyclesPerMillisecond));
</pre>

#### CTimer::GetIsSlowMotionActive

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTimer::GetIsSlowMotionActive));
</pre>

### plugin_III\game_III\CTowerClock.cpp

#### CTowerClock::Init

<pre>
plugin::CallMethodDynGlobal<CTowerClock *, CVector, float, float, unsigned char, unsigned char, unsigned char, float, float>(gaddrof(CTowerClock::Init), this, pos, sizeX, sizeY, red, green, blue, drawDistance, scale);
0AA6: call_method 0x5000D0 struct [CTowerClock] num_params 8 pop 0 [pos] [sizeX] [sizeY] [red] [green] [blue] [drawDistance] [scale]
</pre>

#### CTowerClock::Render

<pre>
plugin::CallMethodDynGlobal<CTowerClock *>(gaddrof(CTowerClock::Render), this);
0AA6: call_method 0x5001D0 struct [CTowerClock] num_params 0 pop 0
</pre>

#### CTowerClock::Update

<pre>
plugin::CallMethodDynGlobal<CTowerClock *>(gaddrof(CTowerClock::Update), this);
0AA6: call_method 0x500130 struct [CTowerClock] num_params 0 pop 0
</pre>

### plugin_III\game_III\CTrafficLights.cpp

#### CTrafficLights::DisplayActualLight

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CTrafficLights::DisplayActualLight), entity);
</pre>

#### CTrafficLights::FindTrafficLightType

<pre>
plugin::CallAndReturnDynGlobal<int, CEntity *>(gaddrof(CTrafficLights::FindTrafficLightType), entity);
</pre>

#### CTrafficLights::LightForCars1

<pre>
plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForCars1));
</pre>

#### CTrafficLights::LightForCars2

<pre>
plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForCars2));
</pre>

#### CTrafficLights::LightForPeds

<pre>
plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForPeds));
</pre>

#### CTrafficLights::ShouldCarStopForBridge

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTrafficLights::ShouldCarStopForBridge), vehicle);
</pre>

#### CTrafficLights::ShouldCarStopForLight

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *, bool>(gaddrof(CTrafficLights::ShouldCarStopForLight), vehicle, alwaysStop);
</pre>

### plugin_III\game_III\CTrain.cpp

#### CTrain::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CTrain *, unsigned int>(this, modelIndex);
</pre>

#### CTrain::ProcessControl

<pre>
plugin::CallVirtualMethod<8, CTrain *>(this);
</pre>

#### CTrain::PreRender

<pre>
plugin::CallVirtualMethod<12, CTrain *>(this);
</pre>

#### CTrain::Render

<pre>
plugin::CallVirtualMethod<13, CTrain *>(this);
</pre>

#### CTrain::AddPassenger

<pre>
plugin::CallMethodDynGlobal<CTrain *, CPed *>(gaddrof(CTrain::AddPassenger), this, passenger);
0AA6: call_method 0x5504A0 struct [CTrain] num_params 1 pop 0 [passenger]
</pre>

#### CTrain::OpenTrainDoor

<pre>
plugin::CallMethodDynGlobal<CTrain *, float>(gaddrof(CTrain::OpenTrainDoor), this, angle);
0AA6: call_method 0x550360 struct [CTrain] num_params 1 pop 0 [angle]
</pre>

#### CTrain::TrainHitStuff

<pre>
plugin::CallMethodDynGlobal<CTrain *, CPtrList &>(gaddrof(CTrain::TrainHitStuff), this, list);
0AA6: call_method 0x550300 struct [CTrain] num_params 1 pop 0 [list]
</pre>

#### CTrain::ReadAndInterpretTrackFile

<pre>
plugin::CallDynGlobal<char const *, CTrainNode **, short *, int, float *, float *, float *, CTrainInterpolationLine *, bool>(gaddrof(CTrain::ReadAndInterpretTrackFile), filename, nodes, numNodes, numStations, stationDists, totalLength, totalDuration, line, rightRail);
</pre>

#### PlayAnnouncement

<pre>
plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(PlayAnnouncement), sound, station);
</pre>

### plugin_III\game_III\CTrainDoor.cpp

#### CTrainDoor::IsClosed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CTrainDoor *>(gaddrof(CTrainDoor::IsClosed), this);
0AA8: call_method_return 0x5460F0 struct [CTrainDoor] num_params 0 pop 0 func_ret [bool]
</pre>

#### CTrainDoor::IsFullyOpen

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CTrainDoor *>(gaddrof(CTrainDoor::IsFullyOpen), this);
0AA8: call_method_return 0x546120 struct [CTrainDoor] num_params 0 pop 0 func_ret [bool]
</pre>

#### CTrainDoor::Open

<pre>
plugin::CallMethodDynGlobal<CTrainDoor *, float>(gaddrof(CTrainDoor::Open), this, angle);
0AA6: call_method 0x546200 struct [CTrainDoor] num_params 1 pop 0 [angle]
</pre>

#### CTrainDoor::RetTranslationWhenClosed

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CTrainDoor *>(gaddrof(CTrainDoor::RetTranslationWhenClosed), this);
0AA8: call_method_return 0x546180 struct [CTrainDoor] num_params 0 pop 0 func_ret [float]
</pre>

#### CTrainDoor::RetTranslationWhenOpen

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CTrainDoor *>(gaddrof(CTrainDoor::RetTranslationWhenOpen), this);
0AA8: call_method_return 0x5461C0 struct [CTrainDoor] num_params 0 pop 0 func_ret [float]
</pre>

### plugin_III\game_III\cTransmission.cpp

#### cTransmission::CalculateDriveAcceleration

<pre>
plugin::CallMethodAndReturn<float, 0x5506B0, cTransmission *, float const&, unsigned char&, float&, float const&, bool>(this, gasPedal, currrentGear, pSpeed, pCurrentSpeed, bCheat);
0AA8: call_method_return 0x5506B0 struct [cTransmission] num_params 5 pop 0 [gasPedal] [currrentGear] [pSpeed] [pCurrentSpeed] [bCheat] func_ret [float]
</pre>

#### cTransmission::CalculateGearForSimpleCar

<pre>
plugin::CallMethod<0x550A00, cTransmission *, float, unsigned char&>(this, velocity, currrentGear);
0AA6: call_method 0x550A00 struct [cTransmission] num_params 2 pop 0 [velocity] [currrentGear]
</pre>

#### cTransmission::InitGearRatios

<pre>
plugin::CallMethod<0x550590, cTransmission *>(this);
0AA6: call_method 0x550590 struct [cTransmission] num_params 0 pop 0
</pre>

#### cTransmission::cTransmission

<pre>
plugin::CallMethod<0x550580, cTransmission *>(this);
0AA6: call_method 0x550580 struct [cTransmission] num_params 0 pop 0
</pre>

### plugin_III\game_III\CTreadable.cpp

#### CTreadable::GetIsATreadable

<pre>
plugin::CallVirtualMethodAndReturn<bool, 17, CTreadable *>(this);
</pre>

### plugin_III\game_III\CTxdStore.cpp

#### CTxdStore::Initialise

<pre>
plugin::Call<0x527440>();
0AA5: call_function 0x527440 num_params 0 pop 0
</pre>

#### CTxdStore::Shutdown

<pre>
plugin::Call<0x527470>();
0AA5: call_function 0x527470 num_params 0 pop 0
</pre>

#### CTxdStore::GameShutdown

<pre>
plugin::Call<0x527490>();
0AA5: call_function 0x527490 num_params 0 pop 0
</pre>

#### CTxdStore::AddTxdSlot

<pre>
plugin::CallAndReturn<int, 0x5274E0, char const*>(name);
0AA7: call_function_return 0x5274E0 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CTxdStore::RemoveTxdSlot

<pre>
plugin::Call<0x527520, int>(id);
0AA5: call_function 0x527520 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::GetTxdName

<pre>
plugin::CallAndReturn<char*, 0x527590, int>(id);
0AA7: call_function_return 0x527590 num_params 1 pop 1 [id] func_ret [char*]
</pre>

#### CTxdStore::FindTxdSlot

<pre>
plugin::CallAndReturn<int, 0x5275D0, char const*>(name);
0AA7: call_function_return 0x5275D0 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CTxdStore::LoadTxd

<pre>
plugin::CallAndReturn<bool, 0x5276B0, int, char const*>(id, name);
0AA7: call_function_return 0x5276B0 num_params 2 pop 2 [id] [name] func_ret [bool]
</pre>

#### CTxdStore::LoadTxd

<pre>
plugin::CallAndReturn<bool, 0x527700, int, RwStream*>(id, stream);
0AA7: call_function_return 0x527700 num_params 2 pop 2 [id] [stream] func_ret [bool]
</pre>

#### CTxdStore::StartLoadTxd

<pre>
plugin::CallAndReturn<bool, 0x527770, int, RwStream*>(id, stream);
0AA7: call_function_return 0x527770 num_params 2 pop 2 [id] [stream] func_ret [bool]
</pre>

#### CTxdStore::FinishLoadTxd

<pre>
plugin::CallAndReturn<bool, 0x5277E0, int, RwStream*>(id, stream);
0AA7: call_function_return 0x5277E0 num_params 2 pop 2 [id] [stream] func_ret [bool]
</pre>

#### CTxdStore::Create

<pre>
plugin::Call<0x527830, int>(id);
0AA5: call_function 0x527830 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::RemoveTxd

<pre>
plugin::Call<0x527870, int>(id);
0AA5: call_function 0x527870 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::SetCurrentTxd

<pre>
plugin::Call<0x5278C0, int>(id);
0AA5: call_function 0x5278C0 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::PushCurrentTxd

<pre>
plugin::Call<0x527900>();
0AA5: call_function 0x527900 num_params 0 pop 0
</pre>

#### CTxdStore::PopCurrentTxd

<pre>
plugin::Call<0x527910>();
0AA5: call_function 0x527910 num_params 0 pop 0
</pre>

#### CTxdStore::AddRef

<pre>
plugin::Call<0x527930, int>(id);
0AA5: call_function 0x527930 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::RemoveRef

<pre>
plugin::Call<0x527970, int>(id);
0AA5: call_function 0x527970 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::RemoveRefWithoutDelete

<pre>
plugin::Call<0x5279C0, int>(id);
0AA5: call_function 0x5279C0 num_params 1 pop 1 [id]
</pre>

#### CTxdStore::GetNumRefs

<pre>
plugin::CallAndReturn<int, 0x527A00, int>(id);
0AA7: call_function_return 0x527A00 num_params 1 pop 1 [id] func_ret [int]
</pre>

### plugin_III\game_III\CUpsideDownCarCheck.cpp

#### CUpsideDownCarCheck::AddCarToCheck

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::AddCarToCheck), this, id);
0AA6: call_method 0x437FB0 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id]
</pre>

#### CUpsideDownCarCheck::AreAnyCarsUpsideDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::AreAnyCarsUpsideDown), this);
0AA8: call_method_return 0x437F80 struct [CUpsideDownCarCheck] num_params 0 pop 0 func_ret [bool]
</pre>

#### CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile), this, id);
0AA8: call_method_return 0x438010 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id] func_ret [bool]
</pre>

#### CUpsideDownCarCheck::Init

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::Init), this);
0AA6: call_method 0x437DC0 struct [CUpsideDownCarCheck] num_params 0 pop 0
</pre>

#### CUpsideDownCarCheck::IsCarUpsideDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::IsCarUpsideDown), this, id);
0AA8: call_method_return 0x437E10 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id] func_ret [bool]
</pre>

#### CUpsideDownCarCheck::RemoveCarFromCheck

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::RemoveCarFromCheck), this, id);
0AA6: call_method 0x437FE0 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id]
</pre>

#### CUpsideDownCarCheck::UpdateTimers

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::UpdateTimers), this);
0AA6: call_method 0x437EE0 struct [CUpsideDownCarCheck] num_params 0 pop 0
</pre>

### plugin_III\game_III\CVehicle.cpp

#### CVehicle::SetModelIndex

<pre>
plugin::CallVirtualMethod<3, CVehicle *, unsigned int>(this, modelIndex);
</pre>

#### CVehicle::SetupLighting

<pre>
plugin::CallVirtualMethodAndReturn<bool, 14, CVehicle *>(this);
</pre>

#### CVehicle::RemoveLighting

<pre>
plugin::CallVirtualMethod<15, CVehicle *, bool>(this, reset);
</pre>

#### CVehicle::FlagToDestroyWhenNextProcessed

<pre>
plugin::CallVirtualMethod<16, CVehicle *>(this);
</pre>

#### CVehicle::ProcessControlInputs

<pre>
plugin::CallVirtualMethod<18, CVehicle *, unsigned char>(this, padNumber);
</pre>

#### CVehicle::GetComponentWorldPosition

<pre>
plugin::CallVirtualMethod<19, CVehicle *, int, CVector &>(this, component, pos);
</pre>

#### CVehicle::IsComponentPresent

<pre>
plugin::CallVirtualMethodAndReturn<bool, 20, CVehicle *, int>(this, component);
</pre>

#### CVehicle::SetComponentRotation

<pre>
plugin::CallVirtualMethod<21, CVehicle *, int, CVector>(this, component, rotation);
</pre>

#### CVehicle::OpenDoor

<pre>
plugin::CallVirtualMethod<22, CVehicle *, int, eDoors, float>(this, component, door, angle);
</pre>

#### CVehicle::ProcessOpenDoor

<pre>
plugin::CallVirtualMethod<23, CVehicle *, unsigned int, unsigned int, float>(this, component, anim, angle);
</pre>

#### CVehicle::IsDoorReady

<pre>
plugin::CallVirtualMethodAndReturn<bool, 24, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorFullyOpen

<pre>
plugin::CallVirtualMethodAndReturn<bool, 25, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorClosed

<pre>
plugin::CallVirtualMethodAndReturn<bool, 26, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorMissing

<pre>
plugin::CallVirtualMethodAndReturn<bool, 27, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::RemoveRefsToVehicle

<pre>
plugin::CallVirtualMethod<28, CVehicle *, CEntity *>(this, entity);
</pre>

#### CVehicle::BlowUpCar

<pre>
plugin::CallVirtualMethod<29, CVehicle *, CEntity *>(this, entity);
</pre>

#### CVehicle::SetUpWheelColModel

<pre>
plugin::CallVirtualMethodAndReturn<bool, 30, CVehicle *, CColModel *>(this, colModel);
</pre>

#### CVehicle::BurstTyre

<pre>
plugin::CallVirtualMethod<31, CVehicle *, unsigned char>(this, wheel);
</pre>

#### CVehicle::IsRoomForPedToLeaveCar

<pre>
plugin::CallVirtualMethodAndReturn<bool, 32, CVehicle *, unsigned int, CVector *>(this, component, doorOffset);
</pre>

#### CVehicle::GetHeightAboveRoad

<pre>
plugin::CallVirtualMethodAndReturn<float, 33, CVehicle *>(this);
</pre>

#### CVehicle::PlayCarHorn

<pre>
plugin::CallVirtualMethod<34, CVehicle *>(this);
</pre>

#### CVehicle::AddPassenger

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *>(gaddrof_o(CVehicle::AddPassenger, bool (CVehicle::*)(CPed *)), this, passenger);
0AA8: call_method_return 0x551E10 struct [CVehicle] num_params 1 pop 0 [passenger] func_ret [bool]
</pre>

#### CVehicle::AddPassenger

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *, unsigned char>(gaddrof_o(CVehicle::AddPassenger, bool (CVehicle::*)(CPed *, unsigned char)), this, passenger, number);
0AA8: call_method_return 0x551E10 struct [CVehicle] num_params 2 pop 0 [passenger] [number] func_ret [bool]
</pre>

#### CVehicle::CanBeDeleted

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanBeDeleted), this);
0AA8: call_method_return 0x5511B0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedEnterCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanPedEnterCar), this);
0AA8: call_method_return 0x5522F0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedExitCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanPedExitCar), this);
0AA8: call_method_return 0x5523C0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedOpenLocks

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *>(gaddrof(CVehicle::CanPedOpenLocks), this, ped);
0AA8: call_method_return 0x5522A0 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CVehicle::CarHasRoof

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CarHasRoof), this);
0AA8: call_method_return 0x552B70 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::ChangeLawEnforcerState

<pre>
plugin::CallMethodDynGlobal<CVehicle *, unsigned char>(gaddrof(CVehicle::ChangeLawEnforcerState), this, enable);
0AA6: call_method 0x552820 struct [CVehicle] num_params 1 pop 0 [enable]
</pre>

#### CVehicle::DoFixedMachineGuns

<pre>
plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::DoFixedMachineGuns), this);
0AA6: call_method 0x564300 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ExtinguishCarFire

<pre>
plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ExtinguishCarFire), this);
0AA6: call_method 0x552AF0 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::FlyingControl

<pre>
plugin::CallMethodDynGlobal<CVehicle *, eFlightModel>(gaddrof(CVehicle::FlyingControl), this, flightModel);
0AA6: call_method 0x552BB0 struct [CVehicle] num_params 1 pop 0 [flightModel]
</pre>

#### CVehicle::InflictDamage

<pre>
plugin::CallMethodDynGlobal<CVehicle *, CEntity *, eWeaponType, float>(gaddrof(CVehicle::InflictDamage), this, entity, weaponType, damage);
0AA6: call_method 0x551950 struct [CVehicle] num_params 3 pop 0 [entity] [weaponType] [damage]
</pre>

#### CVehicle::IsLawEnforcementVehicle

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsLawEnforcementVehicle), this);
0AA8: call_method_return 0x552880 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::IsOnItsSide

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsOnItsSide), this);
0AA8: call_method_return 0x552260 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::IsSphereTouchingVehicle

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, float, float, float, float>(gaddrof(CVehicle::IsSphereTouchingVehicle), this, x, y, z, radius);
0AA8: call_method_return 0x552620 struct [CVehicle] num_params 4 pop 0 [x] [y] [z] [radius] func_ret [bool]
</pre>

#### CVehicle::IsUpsideDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsUpsideDown), this);
0AA8: call_method_return 0x552230 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::IsVehicleNormal

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsVehicleNormal), this);
0AA8: call_method_return 0x5527E0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::ProcessCarAlarm

<pre>
plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ProcessCarAlarm), this);
0AA6: call_method 0x5525A0 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ProcessDelayedExplosion

<pre>
plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ProcessDelayedExplosion), this);
0AA6: call_method 0x551C90 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ProcessWheel

<pre>
plugin::CallMethodDynGlobal<CVehicle *, CVector &, CVector &, CVector &, CVector &, int, float, float, float, char, float *, tWheelState *, unsigned short>(gaddrof(CVehicle::ProcessWheel), this, wheelFwd, wheelRight, wheelContactSpeed, wheelContactPoint, wheelsOnGround, thrust, brake, adhesion, wheelId, wheelSpeed, wheelState, wheelStatus);
0AA6: call_method 0x5512E0 struct [CVehicle] num_params 12 pop 0 [wheelFwd] [wheelRight] [wheelContactSpeed] [wheelContactPoint] [wheelsOnGround] [thrust] [brake] [adhesion] [wheelId] [wheelSpeed] [wheelState] [wheelStatus]
</pre>

#### CVehicle::ProcessWheelRotation

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CVehicle *, tWheelState, CVector const &, CVector const &, float>(gaddrof(CVehicle::ProcessWheelRotation), this, state, fwd, speed, radius);
0AA8: call_method_return 0x551280 struct [CVehicle] num_params 4 pop 0 [state] [fwd] [speed] [radius] func_ret [float]
</pre>

#### CVehicle::RemoveDriver

<pre>
plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::RemoveDriver), this);
0AA6: call_method 0x5520A0 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::RemovePassenger

<pre>
plugin::CallMethodDynGlobal<CVehicle *, CPed *>(gaddrof(CVehicle::RemovePassenger), this, passenger);
0AA6: call_method 0x551EB0 struct [CVehicle] num_params 1 pop 0 [passenger]
</pre>

#### CVehicle::SetDriver

<pre>
plugin::CallMethodDynGlobal<CVehicle *, CPed *>(gaddrof(CVehicle::SetDriver), this, driver);
0AA6: call_method 0x551F20 struct [CVehicle] num_params 1 pop 0 [driver]
</pre>

#### \*CVehicle::SetUpDriver

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CVehicle *>(gaddrof(CVehicle::SetUpDriver), this);
0AA8: call_method_return 0x5520C0 struct [*CVehicle] num_params 0 pop 0 func_ret [CPed *]
</pre>

#### \*CVehicle::SetupPassenger

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CVehicle *, int>(gaddrof(CVehicle::SetupPassenger), this, number);
0AA8: call_method_return 0x552160 struct [*CVehicle] num_params 1 pop 0 [number] func_ret [CPed *]
</pre>

#### CVehicle::ShufflePassengersToMakeSpace

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::ShufflePassengersToMakeSpace), this);
0AA8: call_method_return 0x5528A0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::UsesSiren

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, unsigned int>(gaddrof(CVehicle::UsesSiren), this, vehicleModel);
0AA8: call_method_return 0x552200 struct [CVehicle] num_params 1 pop 0 [vehicleModel] func_ret [bool]
</pre>

#### DestroyVehicleAndDriverAndPassengers

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(DestroyVehicleAndDriverAndPassengers), vehicle);
</pre>

### plugin_III\game_III\CVehicleModelInfo.cpp

#### CVehicleModelInfo::DeleteRwObject

<pre>
plugin::CallVirtualMethod<2, CVehicleModelInfo *>(this);
</pre>

#### \*CVehicleModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 3, CVehicleModelInfo *>(this);
</pre>

#### CVehicleModelInfo::SetClump

<pre>
plugin::CallVirtualMethod<6, CVehicleModelInfo *, RpClump *>(this, clump);
</pre>

#### CVehicleModelInfo::AvoidSameVehicleColour

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char *, unsigned char *>(gaddrof(CVehicleModelInfo::AvoidSameVehicleColour), this, prim, sec);
0AA6: call_method 0x5210A0 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]
</pre>

#### CVehicleModelInfo::ChooseComponent

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::ChooseComponent), this);
0AA8: call_method_return 0x520AB0 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]
</pre>

#### CVehicleModelInfo::ChooseSecondComponent

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::ChooseSecondComponent), this);
0AA8: call_method_return 0x520BE0 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]
</pre>

#### CVehicleModelInfo::ChooseVehicleColour

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char *, unsigned char *>(gaddrof(CVehicleModelInfo::ChooseVehicleColour), this, prim, sec);
0AA6: call_method 0x520FD0 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]
</pre>

#### CVehicleModelInfo::FindEditableMaterialList

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::FindEditableMaterialList), this);
0AA6: call_method 0x520DE0 struct [CVehicleModelInfo] num_params 0 pop 0
</pre>

#### CVehicleModelInfo::GetWheelPosn

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *, int, CVector &>(gaddrof(CVehicleModelInfo::GetWheelPosn), this, wheel, outPos);
0AA6: call_method 0x520840 struct [CVehicleModelInfo] num_params 2 pop 0 [wheel] [outPos]
</pre>

#### CVehicleModelInfo::PreprocessHierarchy

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::PreprocessHierarchy), this);
0AA6: call_method 0x5204D0 struct [CVehicleModelInfo] num_params 0 pop 0
</pre>

#### CVehicleModelInfo::SetAtomicRenderCallbacks

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::SetAtomicRenderCallbacks), this);
0AA6: call_method 0x5202C0 struct [CVehicleModelInfo] num_params 0 pop 0
</pre>

#### CVehicleModelInfo::SetEnvironmentMap

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::SetEnvironmentMap), this);
0AA6: call_method 0x521890 struct [CVehicleModelInfo] num_params 0 pop 0
</pre>

#### CVehicleModelInfo::SetVehicleColour

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char, unsigned char>(gaddrof(CVehicleModelInfo::SetVehicleColour), this, prim, sec);
0AA6: call_method 0x520E70 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]
</pre>

#### CVehicleModelInfo::SetVehicleComponentFlags

<pre>
plugin::CallMethodDynGlobal<CVehicleModelInfo *, RwFrame *, unsigned int>(gaddrof(CVehicleModelInfo::SetVehicleComponentFlags), this, frame, flags);
0AA6: call_method 0x5203C0 struct [CVehicleModelInfo] num_params 2 pop 0 [frame] [flags]
</pre>

#### \*CVehicleModelInfo::ClearAtomicFlagCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::ClearAtomicFlagCB), object, data);
</pre>

#### \*CVehicleModelInfo::CollapseFramesCB

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CVehicleModelInfo::CollapseFramesCB), frame, data);
</pre>

#### \*CVehicleModelInfo::GetEditableMaterialListCB

<pre>
plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof_o(CVehicleModelInfo::GetEditableMaterialListCB, RpMaterial *(*)(RpMaterial *, void *)), material, data);
</pre>

#### \*CVehicleModelInfo::GetEditableMaterialListCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof_o(CVehicleModelInfo::GetEditableMaterialListCB, RpAtomic *(*)(RpAtomic *, void *)), atomic, data);
</pre>

#### CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors), modelIndex);
</pre>

#### \*CVehicleModelInfo::HasAlphaMaterialCB

<pre>
plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(CVehicleModelInfo::HasAlphaMaterialCB), material, data);
</pre>

#### \*CVehicleModelInfo::HasSpecularMaterialCB

<pre>
plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(CVehicleModelInfo::HasSpecularMaterialCB), material, data);
</pre>

#### \*CVehicleModelInfo::HideAllComponentsAtomicCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::HideAllComponentsAtomicCB), atomic, data);
</pre>

#### \*CVehicleModelInfo::HideDamagedAtomicCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::HideDamagedAtomicCB), atomic, data);
</pre>

#### \*CVehicleModelInfo::MoveObjectsCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::MoveObjectsCB), object, data);
</pre>

#### \*CVehicleModelInfo::SetAtomicFlagCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::SetAtomicFlagCB), object, data);
</pre>

#### \*CVehicleModelInfo::SetAtomicRendererCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB), atomic, data);
</pre>

#### \*CVehicleModelInfo::SetAtomicRendererCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_BigVehicle), atomic, data);
</pre>

#### \*CVehicleModelInfo::SetAtomicRendererCB_Boat

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Boat), atomic, data);
</pre>

#### \*CVehicleModelInfo::SetAtomicRendererCB_Heli

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Heli), atomic, data);
</pre>

#### \*CVehicleModelInfo::SetAtomicRendererCB_Train

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Train), atomic, data);
</pre>

#### \*CVehicleModelInfo::SetEnvironmentMapCB

<pre>
plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof_o(CVehicleModelInfo::SetEnvironmentMapCB, RpMaterial *(*)(RpMaterial *, void *)), material, data);
</pre>

#### \*CVehicleModelInfo::SetEnvironmentMapCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof_o(CVehicleModelInfo::SetEnvironmentMapCB, RpAtomic *(*)(RpAtomic *, void *)), atomic, data);
</pre>

#### \*GetOkAndDamagedAtomicCB

<pre>
plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetOkAndDamagedAtomicCB), object, data);
</pre>

#### IsValidCompRule

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(IsValidCompRule), rule);
</pre>

#### GetListOfComponentsNotUsedByRules

<pre>
plugin::CallAndReturnDynGlobal<int, unsigned int, int, int *>(gaddrof(GetListOfComponentsNotUsedByRules), compRulesBits, numExtras, variationsList);
</pre>

#### CountCompsInRule

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CountCompsInRule), compRulesBits);
</pre>

#### ChooseComponent

<pre>
plugin::CallAndReturnDynGlobal<int, int, int>(gaddrof(ChooseComponent), rule, compRulesBits);
</pre>

#### \*CreateCarColourTexture

<pre>
plugin::CallAndReturnDynGlobal<RwTexture *, unsigned char, unsigned char, unsigned char>(gaddrof(CreateCarColourTexture), red, green, blue);
</pre>

### plugin_III\game_III\CVisibilityPlugins.cpp

#### \*CVisibilityPlugins::AtomicConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicConstructor), object, offsetInObject, sizeInObject);
</pre>

#### \*CVisibilityPlugins::AtomicCopyConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);
</pre>

#### \*CVisibilityPlugins::AtomicDestructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicDestructor), object, offsetInObject, sizeInObject);
</pre>

#### CVisibilityPlugins::ClearAtomicFlag

<pre>
plugin::CallDynGlobal<RpAtomic *, int>(gaddrof(CVisibilityPlugins::ClearAtomicFlag), atomic, flag);
</pre>

#### \*CVisibilityPlugins::ClumpConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpConstructor), object, offsetInObject, sizeInObject);
</pre>

#### \*CVisibilityPlugins::ClumpCopyConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);
</pre>

#### \*CVisibilityPlugins::ClumpDestructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpDestructor), object, offsetInObject, sizeInObject);
</pre>

#### CVisibilityPlugins::DefaultVisibilityCB

<pre>
plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::DefaultVisibilityCB), clump);
</pre>

#### \*CVisibilityPlugins::FrameConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameConstructor), object, offsetInObject, sizeInObject);
</pre>

#### \*CVisibilityPlugins::FrameCopyConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);
</pre>

#### \*CVisibilityPlugins::FrameDestructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameDestructor), object, offsetInObject, sizeInObject);
</pre>

#### CVisibilityPlugins::FrustumSphereCB

<pre>
plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::FrustumSphereCB), clump);
</pre>

#### CVisibilityPlugins::GetAtomicId

<pre>
plugin::CallAndReturnDynGlobal<int, RpAtomic *>(gaddrof(CVisibilityPlugins::GetAtomicId), atomic);
</pre>

#### \*CVisibilityPlugins::GetAtomicModelInfo

<pre>
plugin::CallAndReturnDynGlobal<CSimpleModelInfo *, RpAtomic *>(gaddrof(CVisibilityPlugins::GetAtomicModelInfo), atomic);
</pre>

#### CVisibilityPlugins::GetClumpAlpha

<pre>
plugin::CallAndReturnDynGlobal<int, RpClump *>(gaddrof(CVisibilityPlugins::GetClumpAlpha), clump);
</pre>

#### CVisibilityPlugins::GetDistanceSquaredFromCamera

<pre>
plugin::CallAndReturnDynGlobal<float, RwFrame *>(gaddrof(CVisibilityPlugins::GetDistanceSquaredFromCamera), frame);
</pre>

#### CVisibilityPlugins::GetDotProductWithCameraVector

<pre>
plugin::CallAndReturnDynGlobal<float, RwMatrix *, RwMatrix *, unsigned int>(gaddrof(CVisibilityPlugins::GetDotProductWithCameraVector), atomicMat, clumpMat, flag);
</pre>

#### CVisibilityPlugins::GetFrameHierarchyId

<pre>
plugin::CallAndReturnDynGlobal<int, RwFrame *>(gaddrof(CVisibilityPlugins::GetFrameHierarchyId), frame);
</pre>

#### CVisibilityPlugins::InsertAtomicIntoSortedList

<pre>
plugin::CallAndReturnDynGlobal<bool, RpAtomic *, float>(gaddrof(CVisibilityPlugins::InsertAtomicIntoSortedList), atomic, dist);
</pre>

#### CVisibilityPlugins::InsertEntityIntoSortedList

<pre>
plugin::CallAndReturnDynGlobal<bool, CEntity *, float>(gaddrof(CVisibilityPlugins::InsertEntityIntoSortedList), entity, dist);
</pre>

#### CVisibilityPlugins::MloVisibilityCB

<pre>
plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::MloVisibilityCB), clump);
</pre>

#### CVisibilityPlugins::PluginAttach

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CVisibilityPlugins::PluginAttach));
</pre>

#### \*CVisibilityPlugins::RenderAlphaAtomic

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, int>(gaddrof(CVisibilityPlugins::RenderAlphaAtomic), atomic, alpha);
</pre>

#### \*CVisibilityPlugins::RenderFadingAtomic

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, float>(gaddrof(CVisibilityPlugins::RenderFadingAtomic), atomic, camdist);
</pre>

#### \*CVisibilityPlugins::RenderObjAlwaysAtomic

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderObjAlwaysAtomic), atomic);
</pre>

#### \*CVisibilityPlugins::RenderPedHiDetailCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPedHiDetailCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderPedLowDetailCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPedLowDetailCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderPlayerCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPlayerCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderTrainHiDetailAlphaCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderTrainHiDetailAlphaCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderTrainHiDetailCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderTrainHiDetailCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleHiDetailAlphaCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailAlphaCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleHiDetailCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleHiDetailCB_Boat

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB_Boat), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleLowDetailAlphaCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleLowDetailAlphaCB_BigVehicle), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleLowDetailCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleLowDetailCB_BigVehicle), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleReallyLowDetailCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleReallyLowDetailCB), atomic);
</pre>

#### \*CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle), atomic);
</pre>

#### \*CVisibilityPlugins::RenderWheelAtomicCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderWheelAtomicCB), atomic);
</pre>

#### CVisibilityPlugins::SetAtomicFlag

<pre>
plugin::CallDynGlobal<RpAtomic *, int>(gaddrof(CVisibilityPlugins::SetAtomicFlag), atomic, flag);
</pre>

#### CVisibilityPlugins::SetAtomicModelInfo

<pre>
plugin::CallDynGlobal<RpAtomic *, CSimpleModelInfo *>(gaddrof(CVisibilityPlugins::SetAtomicModelInfo), atomic, info);
</pre>

#### CVisibilityPlugins::SetAtomicRenderCallback

<pre>
plugin::CallDynGlobal<RpAtomic *, RpAtomic *(*)(RpAtomic *)>(gaddrof(CVisibilityPlugins::SetAtomicRenderCallback), atomic, f);
</pre>

#### CVisibilityPlugins::SetClumpAlpha

<pre>
plugin::CallDynGlobal<RpClump *, int>(gaddrof(CVisibilityPlugins::SetClumpAlpha), clump, alpha);
</pre>

#### CVisibilityPlugins::SetClumpModelInfo

<pre>
plugin::CallDynGlobal<RpClump *, CClumpModelInfo *>(gaddrof(CVisibilityPlugins::SetClumpModelInfo), clump, info);
</pre>

#### CVisibilityPlugins::SetFrameHierarchyId

<pre>
plugin::CallDynGlobal<RwFrame *, int>(gaddrof(CVisibilityPlugins::SetFrameHierarchyId), frame, id);
</pre>

#### CVisibilityPlugins::SetRenderWareCamera

<pre>
plugin::CallDynGlobal<RwCamera *>(gaddrof(CVisibilityPlugins::SetRenderWareCamera), camera);
</pre>

#### CVisibilityPlugins::VehicleVisibilityCB

<pre>
plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::VehicleVisibilityCB), clump);
</pre>

#### CVisibilityPlugins::VehicleVisibilityCB_BigVehicle

<pre>
plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::VehicleVisibilityCB_BigVehicle), clump);
</pre>

#### \*SetAlphaCB

<pre>
plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(SetAlphaCB), material, data);
</pre>

#### \*SetTextureCB

<pre>
plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(SetTextureCB), material, data);
</pre>

### plugin_III\game_III\CWanted.cpp

#### CCrimeBeingQd::operator=

<pre>
plugin::CallMethodDynGlobal<CCrimeBeingQd *, CCrimeBeingQd const &>(gaddrof_o(CCrimeBeingQd::operator=, void (CCrimeBeingQd::*)(CCrimeBeingQd const &)), this, right);
0AA6: call_method 0x5966A0 struct [CCrimeBeingQd] num_params 1 pop 0 [right]
</pre>

#### CWanted::AddCrimeToQ

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWanted *, eCrimeType, int, CVector const &, bool, bool>(gaddrof(CWanted::AddCrimeToQ), this, crimeType, crimeId, pos, bAlreadyReported, bPoliceDontReallyCare);
0AA8: call_method_return 0x4ADFD0 struct [CWanted] num_params 5 pop 0 [crimeType] [crimeId] [pos] [bAlreadyReported] [bPoliceDontReallyCare] func_ret [bool]
</pre>

#### CWanted::AreArmyRequired

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreArmyRequired), this);
0AA8: call_method_return 0x4ADBE0 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreFbiRequired

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreFbiRequired), this);
0AA8: call_method_return 0x4ADBC0 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreSwatRequired

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreSwatRequired), this);
0AA8: call_method_return 0x4ADBA0 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::ClearQdCrimes

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::ClearQdCrimes), this);
0AA6: call_method 0x4ADF20 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::Initialise

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Initialise), this);
0AA6: call_method 0x4AD6E0 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::NumOfHelisRequired

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CWanted *>(gaddrof(CWanted::NumOfHelisRequired), this);
0AA8: call_method_return 0x4ADC00 struct [CWanted] num_params 0 pop 0 func_ret [int]
</pre>

#### CWanted::RegisterCrime

<pre>
plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, unsigned int, bool>(gaddrof(CWanted::RegisterCrime), this, crimeType, pos, crimeId, bPoliceDontReallyCare);
0AA6: call_method 0x4AD9F0 struct [CWanted] num_params 4 pop 0 [crimeType] [pos] [crimeId] [bPoliceDontReallyCare]
</pre>

#### CWanted::RegisterCrime_Immediately

<pre>
plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, unsigned int, bool>(gaddrof(CWanted::RegisterCrime_Immediately), this, crimeType, pos, crimeId, bPoliceDontReallyCare);
0AA6: call_method 0x4ADA10 struct [CWanted] num_params 4 pop 0 [crimeType] [pos] [crimeId] [bPoliceDontReallyCare]
</pre>

#### CWanted::ReportCrimeNow

<pre>
plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, bool>(gaddrof(CWanted::ReportCrimeNow), this, crimeType, pos, bPoliceDontReallyCare);
0AA6: call_method 0x4AE110 struct [CWanted] num_params 3 pop 0 [crimeType] [pos] [bPoliceDontReallyCare]
</pre>

#### CWanted::Reset

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Reset), this);
0AA6: call_method 0x4AD790 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::ResetPolicePursuit

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::ResetPolicePursuit), this);
0AA6: call_method 0x4ADC40 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::SetWantedLevel

<pre>
plugin::CallMethodDynGlobal<CWanted *, int>(gaddrof(CWanted::SetWantedLevel), this, level);
0AA6: call_method 0x4ADA50 struct [CWanted] num_params 1 pop 0 [level]
</pre>

#### CWanted::SetWantedLevelNoDrop

<pre>
plugin::CallMethodDynGlobal<CWanted *, int>(gaddrof(CWanted::SetWantedLevelNoDrop), this, level);
0AA6: call_method 0x4ADAC0 struct [CWanted] num_params 1 pop 0 [level]
</pre>

#### CWanted::Update

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Update), this);
0AA6: call_method 0x4AD7B0 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::UpdateCrimesQ

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::UpdateCrimesQ), this);
0AA6: call_method 0x4AE090 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::UpdateWantedLevel

<pre>
plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::UpdateWantedLevel), this);
0AA6: call_method 0x4AD900 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::SetMaximumWantedLevel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CWanted::SetMaximumWantedLevel), level);
</pre>

#### CWanted::WorkOutPolicePresence

<pre>
plugin::CallAndReturnDynGlobal<int, CVector, float>(gaddrof(CWanted::WorkOutPolicePresence), pos, radius);
</pre>

### plugin_III\game_III\CWaterCannon.cpp

#### CWaterCannon::Init

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::Init), this);
0AA6: call_method 0x521A30 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::PushPeds

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::PushPeds), this);
0AA6: call_method 0x5220B0 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::Render

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::Render), this);
0AA6: call_method 0x521D30 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::Update_NewInput

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *, CVector *, CVector *>(gaddrof(CWaterCannon::Update_NewInput), this, pos, dir);
0AA6: call_method 0x521CC0 struct [CWaterCannon] num_params 2 pop 0 [pos] [dir]
</pre>

#### CWaterCannon::Update_OncePerFrame

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *, short>(gaddrof(CWaterCannon::Update_OncePerFrame), this, index);
0AA6: call_method 0x521B80 struct [CWaterCannon] num_params 1 pop 0 [index]
</pre>

### plugin_III\game_III\CWaterCannons.cpp

#### CWaterCannons::UpdateOne

<pre>
plugin::CallDynGlobal<unsigned int, CVector *, CVector *>(gaddrof(CWaterCannons::UpdateOne), id, pos, dir);
</pre>

### plugin_III\game_III\CWeapon.cpp

#### CWeapon::AddGunshell

<pre>
plugin::CallMethodDynGlobal<CWeapon *, CEntity *, CVector const &, CVector2D const &, float>(gaddrof(CWeapon::AddGunshell), this, shooter, source, direction, size);
0AA6: call_method 0x55F770 struct [CWeapon] num_params 4 pop 0 [shooter] [source] [direction] [size]
</pre>

#### CWeapon::DoBulletImpact

<pre>
plugin::CallMethodDynGlobal<CWeapon *, CEntity *, CEntity *, CVector *, CVector *, CColPoint *, CVector2D>(gaddrof(CWeapon::DoBulletImpact), this, shooter, victim, source, target, colPoint, ahead);
0AA6: call_method 0x55F950 struct [CWeapon] num_params 6 pop 0 [shooter] [victim] [source] [target] [colPoint] [ahead]
</pre>

#### CWeapon::Fire

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::Fire), this, shooter, fireSource);
0AA8: call_method_return 0x55C380 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]
</pre>

#### CWeapon::FireAreaEffect

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireAreaEffect), this, shooter, fireSource);
0AA8: call_method_return 0x561E00 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]
</pre>

#### CWeapon::FireFromCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CAutomobile *, bool>(gaddrof(CWeapon::FireFromCar), this, shooter, left);
0AA8: call_method_return 0x55C940 struct [CWeapon] num_params 2 pop 0 [shooter] [left] func_ret [bool]
</pre>

#### CWeapon::FireInstantHit

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireInstantHit), this, shooter, fireSource);
0AA8: call_method_return 0x55D2E0 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]
</pre>

#### CWeapon::FireInstantHitFromCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CAutomobile *, bool>(gaddrof(CWeapon::FireInstantHitFromCar), this, shooter, left);
0AA8: call_method_return 0x5624D0 struct [CWeapon] num_params 2 pop 0 [shooter] [left] func_ret [bool]
</pre>

#### CWeapon::FireM16_1stPerson

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *>(gaddrof(CWeapon::FireM16_1stPerson), this, shooter);
0AA8: call_method_return 0x562180 struct [CWeapon] num_params 1 pop 0 [shooter] func_ret [bool]
</pre>

#### CWeapon::FireMelee

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector &>(gaddrof(CWeapon::FireMelee), this, shooter, fireSource);
0AA8: call_method_return 0x55CA20 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]
</pre>

#### CWeapon::FireProjectile

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *, float>(gaddrof(CWeapon::FireProjectile), this, shooter, fireSource, power);
0AA8: call_method_return 0x561900 struct [CWeapon] num_params 3 pop 0 [shooter] [fireSource] [power] func_ret [bool]
</pre>

#### CWeapon::FireShotgun

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireShotgun), this, shooter, fireSource);
0AA8: call_method_return 0x560620 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]
</pre>

#### CWeapon::FireSniper

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *>(gaddrof(CWeapon::FireSniper), this, shooter);
0AA8: call_method_return 0x561FE0 struct [CWeapon] num_params 1 pop 0 [shooter] func_ret [bool]
</pre>

#### CWeapon::HasWeaponAmmoToBeUsed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::HasWeaponAmmoToBeUsed), this);
0AA8: call_method_return 0x564B80 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::HitsGround

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *, CEntity *>(gaddrof(CWeapon::HitsGround), this, holder, fireSource, aimingTo);
0AA8: call_method_return 0x564890 struct [CWeapon] num_params 3 pop 0 [holder] [fireSource] [aimingTo] func_ret [bool]
</pre>

#### CWeapon::Initialise

<pre>
plugin::CallMethodDynGlobal<CWeapon *, eWeaponType, int>(gaddrof(CWeapon::Initialise), this, type, ammo);
0AA6: call_method 0x55C330 struct [CWeapon] num_params 2 pop 0 [type] [ammo]
</pre>

#### CWeapon::IsType2Handed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::IsType2Handed), this);
0AA8: call_method_return 0x563FD0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::IsTypeMelee

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::IsTypeMelee), this);
0AA8: call_method_return 0x563FB0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::Reload

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(gaddrof(CWeapon::Reload), this);
0AA6: call_method 0x5639D0 struct [CWeapon] num_params 0 pop 0
</pre>

#### CWeapon::Update

<pre>
plugin::CallMethodDynGlobal<CWeapon *, int>(gaddrof(CWeapon::Update), this, audioEntity);
0AA6: call_method 0x563A10 struct [CWeapon] num_params 1 pop 0 [audioEntity]
</pre>

#### CWeapon::BlowUpExplosiveThings

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CWeapon::BlowUpExplosiveThings), thing);
</pre>

#### CWeapon::DoDoomAiming

<pre>
plugin::CallDynGlobal<CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoDoomAiming), shooter, source, target);
</pre>

#### CWeapon::DoDriveByAutoAiming

<pre>
plugin::CallDynGlobal<CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoDriveByAutoAiming), shooter, source, target);
</pre>

#### CWeapon::DoTankDoomAiming

<pre>
plugin::CallDynGlobal<CEntity *, CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoTankDoomAiming), shooter, driver, source, target);
</pre>

#### CWeapon::GenerateFlameThrowerParticles

<pre>
plugin::CallDynGlobal<CVector, CVector>(gaddrof(CWeapon::GenerateFlameThrowerParticles), pos, dir);
</pre>

#### CWeapon::MakePedsJumpAtShot

<pre>
plugin::CallDynGlobal<CPhysical *, CVector *, CVector *>(gaddrof(CWeapon::MakePedsJumpAtShot), shooter, source, target);
</pre>

#### CWeapon::ProcessLineOfSight

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector const &, CVector const &, CColPoint &, CEntity **, eWeaponType, CEntity *, bool, bool, bool, bool, bool, bool, bool>(gaddrof(CWeapon::ProcessLineOfSight), origin, target, point, outEntity, type, entity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
</pre>

#### FireOneInstantHitRound

<pre>
plugin::CallDynGlobal<CVector *, CVector *, int>(gaddrof(FireOneInstantHitRound), source, target, damage);
</pre>

### plugin_III\game_III\CWeaponEffects.cpp

#### CWeaponEffects::CWeaponEffects

<pre>
plugin::CallMethod<0x564C40, CWeaponEffects *>(this);
0AA6: call_method 0x564C40 struct [CWeaponEffects] num_params 0 pop 0
</pre>

#### CWeaponEffects::ClearCrossHair

<pre>
plugin::Call<0x564D60>();
0AA5: call_function 0x564D60 num_params 0 pop 0
</pre>

#### CWeaponEffects::Init

<pre>
plugin::Call<0x564C60>();
0AA5: call_function 0x564C60 num_params 0 pop 0
</pre>

#### CWeaponEffects::MarkTarget

<pre>
plugin::Call<0x564D00, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float>(pos, red, green, blue, alpha, size);
0AA5: call_function 0x564D00 num_params 6 pop 6 [pos] [red] [green] [blue] [alpha] [size]
</pre>

#### CWeaponEffects::Render

<pre>
plugin::Call<0x564D70>();
0AA5: call_function 0x564D70 num_params 0 pop 0
</pre>

#### CWeaponEffects::Shutdown

<pre>
plugin::Call<0x564CF0>();
0AA5: call_function 0x564CF0 num_params 0 pop 0
</pre>

#### CWeaponEffects::~CWeaponEffects

<pre>
plugin::CallMethod<0x564C50, CWeaponEffects *>(this);
0AA6: call_method 0x564C50 struct [CWeaponEffects] num_params 0 pop 0
</pre>

### plugin_III\game_III\CWeaponInfo.cpp

#### CWeaponInfo::CWeaponInfo

<pre>
plugin::CallMethod<0x5654F0, CWeaponInfo *>(this);
0AA6: call_method 0x5654F0 struct [CWeaponInfo] num_params 0 pop 0
</pre>

#### CWeaponInfo::GetWeaponInfo

<pre>
plugin::CallAndReturn<CWeaponInfo*, 0x564FD0, eWeaponType>(weaponType);
0AA7: call_function_return 0x564FD0 num_params 1 pop 1 [weaponType] func_ret [CWeaponInfo*]
</pre>

#### CWeaponInfo::Initialise

<pre>
plugin::Call<0x564EA0>();
0AA5: call_function 0x564EA0 num_params 0 pop 0
</pre>

#### CWeaponInfo::LoadWeaponData

<pre>
plugin::Call<0x564FE0>();
0AA5: call_function 0x564FE0 num_params 0 pop 0
</pre>

#### CWeaponInfo::Shutdown

<pre>
plugin::Call<0x564FB0>();
0AA5: call_function 0x564FB0 num_params 0 pop 0
</pre>

#### CWeaponInfo::~CWeaponInfo

<pre>
plugin::CallMethod<0x5654E0, CWeaponInfo *>(this);
0AA6: call_method 0x5654E0 struct [CWeaponInfo] num_params 0 pop 0
</pre>

### plugin_III\game_III\CWeather.cpp

#### CWeather::ForceWeather

<pre>
plugin::CallDynGlobal<short>(gaddrof(CWeather::ForceWeather), weather);
</pre>

#### CWeather::ForceWeatherNow

<pre>
plugin::CallDynGlobal<short>(gaddrof(CWeather::ForceWeatherNow), weather);
</pre>

#### RenderOneRainStreak

<pre>
plugin::CallDynGlobal<CVector, CVector, int, bool, float>(gaddrof(RenderOneRainStreak), pos, unused, intensity, scale, distance);
</pre>

### plugin_III\game_III\CWorld.cpp

#### CWorld::Add

<pre>
plugin::Call<0x4AE930, CEntity*>(entity);
0AA5: call_function 0x4AE930 num_params 1 pop 1 [entity]
</pre>

#### CWorld::AddParticles

<pre>
plugin::Call<0x4B4010>();
0AA5: call_function 0x4B4010 num_params 0 pop 0
</pre>

#### CWorld::CallOffChaseForArea

<pre>
plugin::Call<0x4B5530, float, float, float, float>(x1, y1, x2, y2);
0AA5: call_function 0x4B5530 num_params 4 pop 4 [x1] [y1] [x2] [y2]
</pre>

#### CWorld::CallOffChaseForAreaSectorListPeds

<pre>
plugin::Call<0x4B5A60, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
0AA5: call_function 0x4B5A60 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CWorld::CallOffChaseForAreaSectorListVehicles

<pre>
plugin::Call<0x4B57B0, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
0AA5: call_function 0x4B57B0 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CWorld::CameraToIgnoreThisObject

<pre>
plugin::CallAndReturn<bool, 0x4B5C30, CEntity*>(entity);
0AA7: call_function_return 0x4B5C30 num_params 1 pop 1 [entity] func_ret [bool]
</pre>

#### CWorld::ClearCarsFromArea

<pre>
plugin::Call<0x4B50E0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x4B50E0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CWorld::ClearExcitingStuffFromArea

<pre>
plugin::Call<0x4B4E70, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);
0AA5: call_function 0x4B4E70 num_params 3 pop 3 [point] [radius] [bRemoveProjectilesAndShadows]
</pre>

#### CWorld::ClearForRestart

<pre>
plugin::Call<0x4AE850>();
0AA5: call_function 0x4AE850 num_params 0 pop 0
</pre>

#### CWorld::ClearPedsFromArea

<pre>
plugin::Call<0x4B52B0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x4B52B0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CWorld::ClearScanCodes

<pre>
plugin::Call<0x4B1F60>();
0AA5: call_function 0x4B1F60 num_params 0 pop 0
</pre>

#### CWorld::ExtinguishAllCarFiresInArea

<pre>
plugin::Call<0x4B5460, CVector, float>(point, radius);
0AA5: call_function 0x4B5460 num_params 2 pop 2 [point] [radius]
</pre>

#### CWorld::FindGroundZFor3DCoord

<pre>
plugin::CallAndReturn<float, 0x4B3AE0, float, float, float, bool*>(x, y, z, outResult);
0AA7: call_function_return 0x4B3AE0 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]
</pre>

#### CWorld::FindGroundZForCoord

<pre>
plugin::CallAndReturn<float, 0x4B3A80, float, float>(x, y);
0AA7: call_function_return 0x4B3A80 num_params 2 pop 2 [x] [y] func_ret [float]
</pre>

#### CWorld::FindMissionEntitiesIntersectingCube

<pre>
plugin::Call<0x4B3680, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);
0AA5: call_function 0x4B3680 num_params 8 pop 8 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehicles] [peds] [objects]
</pre>

#### CWorld::FindMissionEntitiesIntersectingCubeSectorList

<pre>
plugin::Call<0x4B3920, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);
0AA5: call_function 0x4B3920 num_params 9 pop 9 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehiclesList] [pedsList] [objectsList]
</pre>

#### CWorld::FindObjectsInRange

<pre>
plugin::Call<0x4B2200, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4B2200 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsInRangeSectorList

<pre>
plugin::Call<0x4B2540, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x4B2540 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsIntersectingAngledCollisionBox

<pre>
plugin::Call<0x4B3280, CColBox const&, CMatrix const&, CVector const&, float, float, float, float, short*, short, CEntity**, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4B3280 num_params 15 pop 15 [box] [transform] [point] [x1] [y1] [x2] [y2] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList

<pre>
plugin::Call<0x4B3590, CPtrList&, CColBox const&, CMatrix const&, CVector const&, short*, short, CEntity**>(list, box, transform, poin, outCount, maxCount, outEntities);
0AA5: call_function 0x4B3590 num_params 7 pop 7 [list] [box] [transform] [poin] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsIntersectingCube

<pre>
plugin::Call<0x4B2E70, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4B2E70 num_params 10 pop 10 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsIntersectingCubeSectorList

<pre>
plugin::Call<0x4B3150, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**>(list, cornerA, cornerB, outCount, maxCount, outEntities);
0AA5: call_function 0x4B3150 num_params 6 pop 6 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsKindaColliding

<pre>
plugin::Call<0x4B2A30, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4B2A30 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsKindaCollidingSectorList

<pre>
plugin::Call<0x4B2D70, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x4B2D70 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsOfTypeInRange

<pre>
plugin::Call<0x4B2600, unsigned int, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4B2600 num_params 12 pop 12 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsOfTypeInRangeSectorList

<pre>
plugin::Call<0x4B2960, unsigned int, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(modelId, list, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x4B2960 num_params 8 pop 8 [modelId] [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindRoofZFor3DCoord

<pre>
plugin::CallAndReturn<float, 0x4B3B50, float, float, float, bool*>(x, y, z, outResult);
0AA7: call_function_return 0x4B3B50 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]
</pre>

#### CWorld::GetIsLineOfSightClear

<pre>
plugin::CallAndReturn<bool, 0x4AEAA0, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4AEAA0 num_params 9 pop 9 [origin] [target] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::GetIsLineOfSightSectorClear

<pre>
plugin::CallAndReturn<bool, 0x4B2000, CSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4B2000 num_params 9 pop 9 [sector] [line] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::GetIsLineOfSightSectorListClear

<pre>
plugin::CallAndReturn<bool, 0x4B2160, CPtrList&, CColLine const&, bool, bool>(list, line, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4B2160 num_params 4 pop 4 [list] [line] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::Initialise

<pre>
plugin::Call<0x4AE410>();
0AA5: call_function 0x4AE410 num_params 0 pop 0
</pre>

#### CWorld::Process

<pre>
plugin::Call<0x4B1A60>();
0AA5: call_function 0x4B1A60 num_params 0 pop 0
</pre>

#### CWorld::ProcessLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x4AF970, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4AF970 num_params 11 pop 11 [origin] [target] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::ProcessLineOfSightSector

<pre>
plugin::CallAndReturn<bool, 0x4B0A80, CSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool>(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4B0A80 num_params 12 pop 12 [sector] [line] [outColPoint] [maxTouchDistance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::ProcessLineOfSightSectorList

<pre>
plugin::CallAndReturn<bool, 0x4B0C70, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4B0C70 num_params 7 pop 7 [list] [line] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x4B0DE0, CVector const&, float, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x4B0DE0 num_params 11 pop 11 [origin] [distance] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLineSector

<pre>
plugin::CallAndReturn<bool, 0x4B0EF0, CSector&, CColLine const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x4B0EF0 num_params 11 pop 11 [sector] [line] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLineSectorList

<pre>
plugin::CallAndReturn<bool, 0x4B1090, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, CStoredCollPoly*>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x4B1090 num_params 7 pop 7 [list] [line] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::Remove

<pre>
plugin::Call<0x4AE9D0, CEntity*>(entity);
0AA5: call_function 0x4AE9D0 num_params 1 pop 1 [entity]
</pre>

#### CWorld::RemoveEntityInsteadOfProcessingIt

<pre>
plugin::Call<0x4B4E10, CEntity*>(entity);
0AA5: call_function 0x4B4E10 num_params 1 pop 1 [entity]
</pre>

#### CWorld::RemoveFallenCars

<pre>
plugin::Call<0x4B4170>();
0AA5: call_function 0x4B4170 num_params 0 pop 0
</pre>

#### CWorld::RemoveFallenPeds

<pre>
plugin::Call<0x4B4060>();
0AA5: call_function 0x4B4060 num_params 0 pop 0
</pre>

#### CWorld::RemoveReferencesToDeletedObject

<pre>
plugin::Call<0x4B3BF0, CEntity*>(entity);
0AA5: call_function 0x4B3BF0 num_params 1 pop 1 [entity]
</pre>

#### CWorld::RemoveStaticObjects

<pre>
plugin::Call<0x4B4D50>();
0AA5: call_function 0x4B4D50 num_params 0 pop 0
</pre>

#### CWorld::RepositionCertainDynamicObjects

<pre>
plugin::Call<0x4B42B0>();
0AA5: call_function 0x4B42B0 num_params 0 pop 0
</pre>

#### CWorld::RepositionOneObject

<pre>
plugin::Call<0x4B4300, CEntity*>(entity);
0AA5: call_function 0x4B4300 num_params 1 pop 1 [entity]
</pre>

#### CWorld::SetAllCarsCanBeDamaged

<pre>
plugin::Call<0x4B53F0, bool>(enable);
0AA5: call_function 0x4B53F0 num_params 1 pop 1 [enable]
</pre>

#### CWorld::SetCarsOnFire

<pre>
plugin::Call<0x4B3E90, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
0AA5: call_function 0x4B3E90 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]
</pre>

#### CWorld::SetPedsOnFire

<pre>
plugin::Call<0x4B3D30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
0AA5: call_function 0x4B3D30 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]
</pre>

#### CWorld::ShutDown

<pre>
plugin::Call<0x4AE450>();
0AA5: call_function 0x4AE450 num_params 0 pop 0
</pre>

#### CWorld::StopAllLawEnforcersInTheirTracks

<pre>
plugin::Call<0x4B5BC0>();
0AA5: call_function 0x4B5BC0 num_params 0 pop 0
</pre>

#### CWorld::TestSphereAgainstSectorList

<pre>
plugin::CallAndReturn<CEntity*, 0x4B4AC0, CPtrList&, CVector, float, CEntity*, bool>(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);
0AA7: call_function_return 0x4B4AC0 num_params 5 pop 5 [list] [sphereCenter] [sphereRadius] [ignoreEntity] [doCameraIgnoreCheck] func_ret [CEntity*]
</pre>

#### CWorld::TestSphereAgainstWorld

<pre>
plugin::CallAndReturn<CEntity*, 0x4B4710, CVector, float, CEntity*, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck);
0AA7: call_function_return 0x4B4710 num_params 9 pop 9 [sphereCenter] [sphereRadius] [ignoreEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] func_ret [CEntity*]
</pre>

#### CWorld::TriggerExplosion

<pre>
plugin::Call<0x4B1140, CVector const&, float, float, CEntity*, bool>(point, radius, visibleDistance, entity, processVehicleBombTimer);
0AA5: call_function 0x4B1140 num_params 5 pop 5 [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]
</pre>

#### CWorld::TriggerExplosionSectorList

<pre>
plugin::Call<0x4B1340, CPtrList&, CVector const&, float, float, CEntity*, bool>(list, point, radius, visibleDistance, entity, processVehicleBombTimer);
0AA5: call_function 0x4B1340 num_params 6 pop 6 [list] [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]
</pre>

#### CWorld::UseDetonator

<pre>
plugin::Call<0x4B4650, CEntity*>(creator);
0AA5: call_function 0x4B4650 num_params 1 pop 1 [creator]
</pre>

### plugin_III\game_III\CXtraCompsModelInfo.cpp

#### CXtraCompsModelInfo::Shutdown

<pre>
plugin::CallVirtualMethod<1, CXtraCompsModelInfo *>(this);
</pre>

#### \*CXtraCompsModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject *, 3, CXtraCompsModelInfo *>(this);
</pre>

#### CXtraCompsModelInfo::SetClump

<pre>
plugin::CallVirtualMethod<6, CXtraCompsModelInfo *, RpClump *>(this, clump);
</pre>

### plugin_III\game_III\CZone.cpp

#### \*CZone::GetTranslatedName

<pre>
plugin::CallMethodAndReturnDynGlobal<wchar_t *, CZone *>(gaddrof(CZone::GetTranslatedName), this);
0AA8: call_method_return 0x4B5DD0 struct [*CZone] num_params 0 pop 0 func_ret [wchar_t *]
</pre>

### plugin_III\game_III\GenericGameStorage.cpp

#### GenericSave

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(GenericSave), file);
</pre>

#### GenericLoad

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(GenericLoad));
</pre>

#### ReadInSizeofSaveFileBuffer

<pre>
plugin::CallAndReturnDynGlobal<bool, int &, unsigned int &>(gaddrof(ReadInSizeofSaveFileBuffer), file, size);
</pre>

#### ReadDataFromFile

<pre>
plugin::CallAndReturnDynGlobal<bool, int, unsigned char *, unsigned int>(gaddrof(ReadDataFromFile), file, buf, size);
</pre>

#### CloseFile

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CloseFile), file);
</pre>

#### CheckSlotDataValid

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CheckSlotDataValid), slot);
</pre>

#### MakeSpaceForSizeInBufferPointer

<pre>
plugin::CallDynGlobal<unsigned char *&, unsigned char *&, unsigned char *&>(gaddrof(MakeSpaceForSizeInBufferPointer), preSize, buf, postSize);
</pre>

#### CopySizeAndPreparePointer

<pre>
plugin::CallDynGlobal<unsigned char *&, unsigned char *&, unsigned char *&, unsigned int &, unsigned int &>(gaddrof(CopySizeAndPreparePointer), buf, postBuf, postBuf2, unused, size);
</pre>

#### MakeValidSaveName

<pre>
plugin::CallDynGlobal<int>(gaddrof(MakeValidSaveName), slot);
</pre>

#### \*GetSavedGameDateAndTime

<pre>
plugin::CallAndReturnDynGlobal<wchar_t *, int>(gaddrof(GetSavedGameDateAndTime), slot);
</pre>

#### \*GetNameOfSavedGame

<pre>
plugin::CallAndReturnDynGlobal<wchar_t *, int>(gaddrof(GetNameOfSavedGame), slot);
</pre>

#### CheckDataNotCorrupt

<pre>
plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CheckDataNotCorrupt), slot, name);
</pre>

#### RestoreForStartLoad

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(RestoreForStartLoad));
</pre>

#### align4bytes

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(align4bytes), size);
</pre>

### plugin_III\game_III\NodeName.cpp

#### \*NodeNameConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameConstructor), object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameDestructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameDestructor), object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameCopy

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(NodeNameCopy), dstObject, srcObject, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameStreamWrite

<pre>
plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamWrite), stream, binaryLength, object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameStreamRead

<pre>
plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void *, RwInt32, RwInt32>(gaddrof(NodeNameStreamRead), stream, binaryLength, object, offsetInObject, sizeInObject);
</pre>

#### NodeNameStreamGetSize

<pre>
plugin::CallAndReturnDynGlobal<RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamGetSize), object, offsetInObject, sizeInObject);
</pre>

#### NodeNamePluginAttach

<pre>
plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(NodeNamePluginAttach));
</pre>

#### \*GetFrameNodeName

<pre>
plugin::CallAndReturnDynGlobal<char *, RwFrame *>(gaddrof(GetFrameNodeName), frame);
</pre>

### plugin_III\game_III\RenderBuffer.cpp

#### RenderBuffer::StartStoring

<pre>
plugin::CallDynGlobal<int, int, RwImVertexIndex **, RwIm3DVertex **>(gaddrof(RenderBuffer::StartStoring), numIndices, numVertices, indexStart, vertexStart);
</pre>

### plugin_III\game_III\RpAnimBlend.cpp

#### RpAnimBlendClumpUpdateAnimations

<pre>
plugin::CallDynGlobal<RpClump *, float>(gaddrof(RpAnimBlendClumpUpdateAnimations), clump, timeDelta);
</pre>

#### FrameUpdateCallBack

<pre>
plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBack), frames, data);
</pre>

#### FrameUpdateCallBackWithVelocityExtraction

<pre>
plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBackWithVelocityExtraction), frames, data);
</pre>

#### FrameUpdateCallBackWith3dVelocityExtraction

<pre>
plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBackWith3dVelocityExtraction), frames, data);
</pre>

#### \*RpAnimBlendClumpGetFirstAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *>(gaddrof_o(RpAnimBlendClumpGetFirstAssociation, CAnimBlendAssociation *(*)(RpClump *)), clump);
</pre>

#### \*AnimBlendClumpDestroy

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpDestroy), object, offsetInObject, sizeInObject);
</pre>

#### \*AnimBlendClumpCreate

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpCreate), object, offsetInObject, sizeInObject);
</pre>

#### RpAnimBlendAllocateData

<pre>
plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendAllocateData), clump);
</pre>

#### \*AnimBlendClumpCopy

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpCopy), dstObject, srcObject, offsetInObject, sizeInObject);
</pre>

#### RpAnimBlendPluginAttach

<pre>
plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(RpAnimBlendPluginAttach));
</pre>

#### \*FrameForAllChildrenCountCBnonskin

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(FrameForAllChildrenCountCBnonskin), frame, data);
</pre>

#### \*FrameForAllChildrenFillFrameArrayCBnonskin

<pre>
plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(FrameForAllChildrenFillFrameArrayCBnonskin), frame, data);
</pre>

#### FrameInitCBnonskin

<pre>
plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameInitCBnonskin), frames, data);
</pre>

#### FrameFindByNameCBnonskin

<pre>
plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameFindByNameCBnonskin), frames, data);
</pre>

#### FillFrameArrayCBnonskin

<pre>
plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FillFrameArrayCBnonskin), frames, data);
</pre>

#### \*RpAnimBlendClumpFindFrame

<pre>
plugin::CallAndReturnDynGlobal<AnimBlendFrameData *, RpClump *, char const *>(gaddrof(RpAnimBlendClumpFindFrame), clump, name);
</pre>

#### RpAnimBlendClumpFillFrameArray

<pre>
plugin::CallDynGlobal<RpClump *, AnimBlendFrameData **>(gaddrof(RpAnimBlendClumpFillFrameArray), clump, frames);
</pre>

#### RpAnimBlendClumpInit

<pre>
plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendClumpInit), clump);
</pre>

#### RpAnimBlendClumpIsInitialized

<pre>
plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(RpAnimBlendClumpIsInitialized), clump);
</pre>

#### RpAnimBlendClumpSetBlendDeltas

<pre>
plugin::CallDynGlobal<RpClump *, unsigned int, float>(gaddrof(RpAnimBlendClumpSetBlendDeltas), clump, mask, delta);
</pre>

#### RpAnimBlendClumpRemoveAllAssociations

<pre>
plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendClumpRemoveAllAssociations), clump);
</pre>

#### RpAnimBlendClumpRemoveAssociations

<pre>
plugin::CallDynGlobal<RpClump *, unsigned int>(gaddrof(RpAnimBlendClumpRemoveAssociations), clump, mask);
</pre>

#### \*RpAnimBlendClumpGetAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, unsigned int>(gaddrof(RpAnimBlendClumpGetAssociation), clump, id);
</pre>

#### \*RpAnimBlendClumpGetMainAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendAssociation **, float *>(gaddrof(RpAnimBlendClumpGetMainAssociation), clump, assocRet, blendRet);
</pre>

#### \*RpAnimBlendClumpGetMainPartialAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *>(gaddrof(RpAnimBlendClumpGetMainPartialAssociation), clump);
</pre>

#### \*RpAnimBlendClumpGetMainAssociation_N

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int>(gaddrof(RpAnimBlendClumpGetMainAssociation_N), clump, n);
</pre>

#### \*RpAnimBlendClumpGetMainPartialAssociation_N

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int>(gaddrof(RpAnimBlendClumpGetMainPartialAssociation_N), clump, n);
</pre>

#### \*RpAnimBlendClumpGetFirstAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, unsigned int>(gaddrof_o(RpAnimBlendClumpGetFirstAssociation, CAnimBlendAssociation *(*)(RpClump *, unsigned int)), clump, mask);
</pre>

#### \*RpAnimBlendGetNextAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof_o(RpAnimBlendGetNextAssociation, CAnimBlendAssociation *(*)(CAnimBlendAssociation *)), assoc);
</pre>

#### \*RpAnimBlendGetNextAssociation

<pre>
plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *, unsigned int>(gaddrof_o(RpAnimBlendGetNextAssociation, CAnimBlendAssociation *(*)(CAnimBlendAssociation *, unsigned int)), assoc, mask);
</pre>

### plugin_III\game_III\meta\meta.C2deffectsModelInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), reinterpret_cast<C2deffectsModelInfo *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), reinterpret_cast<C2deffectsModelInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.C3dMarker.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), reinterpret_cast<C3dMarker *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), reinterpret_cast<C3dMarker *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAccident.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), reinterpret_cast<CAccident *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), reinterpret_cast<CAccident *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAccidentManager.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), reinterpret_cast<CAccidentManager *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *>(del_dtor_gaddr(CAccidentManager), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAccidentManager *>(del_dtor_gaddr(CAccidentManager), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAnimBlendAssocGroup.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), reinterpret_cast<CAnimBlendAssocGroup *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), reinterpret_cast<CAnimBlendAssocGroup *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAnimBlendAssociation.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), other);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(dtor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), &objArray[i]);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), obj, other);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendAssociation *, int>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendAssociation *, int>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CAnimBlendClumpData.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), reinterpret_cast<CAnimBlendClumpData *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), reinterpret_cast<CAnimBlendClumpData *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAnimBlendHierarchy.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), reinterpret_cast<CAnimBlendHierarchy *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), reinterpret_cast<CAnimBlendHierarchy *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAnimBlendSequence.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), reinterpret_cast<CAnimBlendSequence *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *>(dtor_gaddr(CAnimBlendSequence), reinterpret_cast<CAnimBlendSequence *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), &objArray[i]);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendSequence *, int>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendSequence *, int>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CAntenna.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), reinterpret_cast<CAntenna *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.cAudioCollision.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), reinterpret_cast<cAudioCollision *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CAudioHydrant.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), reinterpret_cast<CAudioHydrant *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.cAudioScriptObject.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</pre>

#### \*operator_new<cAudioScriptObject>

<pre>
plugin::CallAndReturnDynGlobal<void *, unsigned int>(op_new_gaddr(cAudioScriptObject), sizeof(cAudioScriptObject));
</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), obj);</pre>

#### plugin::CallMethodDynGlobal<cAudioScriptObject \*>

<pre>
plugin::CallDynGlobal<void *>(op_delete_gaddr(cAudioScriptObject), obj);
</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CBaseModelInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *, ModelInfoType>(ctor_gaddr_o(CBaseModelInfo, void(ModelInfoType)), reinterpret_cast<CBaseModelInfo *>(objBuff), type);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *>(dtor_gaddr(CBaseModelInfo), reinterpret_cast<CBaseModelInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CBaseModelInfo *, ModelInfoType>(ctor_gaddr_o(CBaseModelInfo, void(ModelInfoType)), obj, type);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CBaseModelInfo *>(obj);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CBaseModelInfo *>(&objArray[i]);
</pre>

### plugin_III\game_III\meta\meta.CBrightLight.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), reinterpret_cast<CBrightLight *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CBulletInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), reinterpret_cast<CBulletInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CBulletTrace.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), reinterpret_cast<CBulletTrace *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CCamera.h

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CCamera *>(dtor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));</pre>

####

<pre>
plugin::CallVirtualMethod<0, CCamera *, char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CCamera *, char>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CCarGenerator.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), reinterpret_cast<CCarGenerator *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CColLine.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), reinterpret_cast<CColLine *>(objBuff));</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(ctor_gaddr_o(CColLine, void(CVector const &, CVector const &)), reinterpret_cast<CColLine *>(objBuff), start, end);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), &objArray[i]);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(ctor_gaddr_o(CColLine, void(CVector const &, CVector const &)), obj, start, end);</pre>

### plugin_III\game_III\meta\meta.CColPoint.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), reinterpret_cast<CColPoint *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CCurrentVehicle.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), reinterpret_cast<CCurrentVehicle *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CDate.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), reinterpret_cast<CDate *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CDigitalClock.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), reinterpret_cast<CDigitalClock *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CDirectory.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), reinterpret_cast<CDirectory *>(objBuff), capacity);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), reinterpret_cast<CDirectory *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), obj, capacity);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.cDMAudio.h

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), reinterpret_cast<cDMAudio *>(objBuff));</pre>

####

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CEntity.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), reinterpret_cast<CEntity *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CEntity *>(dtor_gaddr(CEntity), reinterpret_cast<CEntity *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), &objArray[i]);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CEntity *, char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CEntity *, char>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CEventList.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), reinterpret_cast<CEvent *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CFallingGlassPane.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), reinterpret_cast<CFallingGlassPane *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), reinterpret_cast<CFallingGlassPane *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CFire.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), reinterpret_cast<CFire *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), reinterpret_cast<CFire *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CFireManager.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), reinterpret_cast<CFireManager *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), reinterpret_cast<CFireManager *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CGangInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CInstance.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), reinterpret_cast<CInstance *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CInstance *>(dtor_gaddr(CInstance), reinterpret_cast<CInstance *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), &objArray[i]);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CInstance *, char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CInstance *, char>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CMissionCleanup.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), reinterpret_cast<CMissionCleanup *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CMoneyMessage.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), reinterpret_cast<CMoneyMessage *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CMovie.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), reinterpret_cast<CMovie *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CMovingThing.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), reinterpret_cast<CMovingThing *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.cMusicManager.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), reinterpret_cast<cMusicManager *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CPacManPickup.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), reinterpret_cast<CPacManPickup *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CParticle.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CParticleObject.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), reinterpret_cast<CParticleObject *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(dtor_gaddr(CParticleObject), reinterpret_cast<CParticleObject *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), &objArray[i]);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CParticleObject *, char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CParticleObject *, char>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CPathNode.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), reinterpret_cast<CPathNode *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CPhone.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CPhoneInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CPickup.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), reinterpret_cast<CPickup *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CPlaceable.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), reinterpret_cast<CPlaceable *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPlaceable *>(dtor_gaddr(CPlaceable), reinterpret_cast<CPlaceable *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), &objArray[i]);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CPlaceable *, unsigned char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CPlaceable *, unsigned char>(&objArray[i], 1);
</pre>

### plugin_III\game_III\meta\meta.CPlaceName.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), reinterpret_cast<CPlaceName *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CRadar.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<tRadarTrace*>(ctor_gaddr(tRadarTrace), reinterpret_cast<tRadarTrace *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<tRadarTrace *>(ctor_gaddr(tRadarTrace), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<tRadarTrace *>(ctor_gaddr(tRadarTrace), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CRegisteredCorona.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), reinterpret_cast<CRegisteredCorona *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CRegisteredMotionBlurStreak.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), reinterpret_cast<CRegisteredMotionBlurStreak *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CRegisteredShinyText.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), reinterpret_cast<CRegisteredShinyText *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CRouteNode.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), reinterpret_cast<CRouteNode *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CScrollBar.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), reinterpret_cast<CScrollBar *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CShotInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), reinterpret_cast<CShotInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CSkidmark.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), reinterpret_cast<CSkidmark *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CSprite2d.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), reinterpret_cast<CSprite2d *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), reinterpret_cast<CSprite2d *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CStoredCollPoly.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), reinterpret_cast<CStoredCollPoly *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CStuckCarCheck.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), reinterpret_cast<CStuckCarCheck *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CTempNode.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), reinterpret_cast<CTempNode *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CText.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), reinterpret_cast<CText *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), reinterpret_cast<CText *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CTowerClock.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), reinterpret_cast<CTowerClock *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CTrainCamNode.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), reinterpret_cast<CTrainCamNode *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CTrainDoor.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), reinterpret_cast<CTrainDoor *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CWanted.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), reinterpret_cast<CCrimeBeingQd *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CWaterCannon.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), reinterpret_cast<CWaterCannon *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), &objArray[i]);</pre>

### plugin_III\game_III\meta\meta.CWeapon.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), reinterpret_cast<CWeapon *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), reinterpret_cast<CWeapon *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), &objArray[i]);</pre>

### plugin_sa\game_sa\C_PcSave.cpp

#### C_PcSave::PopulateSlotInfo

<pre>
plugin::CallMethod<0x619140, C_PcSave*>(this);
0AA6: call_method 0x619140 struct [C_PcSave] num_params 0 pop 0
</pre>

#### C_PcSave::DeleteSlot

<pre>
plugin::CallMethodAndReturn<bool, 0x6190D0, C_PcSave*, int>(this, slot);
0AA8: call_method_return 0x6190D0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]
</pre>

#### C_PcSave::SaveSlot

<pre>
plugin::CallMethodAndReturn<bool, 0x619060, C_PcSave*, int>(this, slot);
0AA8: call_method_return 0x619060 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]
</pre>

#### C_PcSave::SetSaveDirectory

<pre>
plugin::Call<0x619040, const char*>(path);
0AA5: call_function 0x619040 num_params 1 pop 1 [path]
</pre>

### plugin_sa\game_sa\C3dMarker.cpp

#### C3dMarker::AddMarker

<pre>
plugin::CallMethodAndReturn<bool, 0x722230, C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(this, id, type, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);
0AA8: call_method_return 0x722230 struct [C3dMarker] num_params 10 pop 0 [id] [type] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] func_ret [bool]
</pre>

#### C3dMarker::DeleteMarkerObject

<pre>
plugin::CallMethod<0x722390, C3dMarker *>(this);
0AA6: call_method 0x722390 struct [C3dMarker] num_params 0 pop 0
</pre>

#### C3dMarker::IsZCoordinateUpToDate

<pre>
plugin::CallMethodAndReturn<bool, 0x7226A0, C3dMarker *>(this);
0AA8: call_method_return 0x7226A0 struct [C3dMarker] num_params 0 pop 0 func_ret [bool]
</pre>

#### C3dMarker::Render

<pre>
plugin::CallMethod<0x7223D0, C3dMarker *>(this);
0AA6: call_method 0x7223D0 struct [C3dMarker] num_params 0 pop 0
</pre>

#### C3dMarker::SetZCoordinateIfNotUpToDate

<pre>
plugin::CallMethod<0x724E10, C3dMarker *, float>(this, coordinate);
0AA6: call_method 0x724E10 struct [C3dMarker] num_params 1 pop 0 [coordinate]
</pre>

#### C3dMarker::UpdateZCoordinate

<pre>
plugin::CallMethod<0x724D40, C3dMarker *, CVector, float>(this, arg0, arg1);
0AA6: call_method 0x724D40 struct [C3dMarker] num_params 2 pop 0 [arg0] [arg1]
</pre>

### plugin_sa\game_sa\C3dMarkers.cpp

#### C3dMarkers::DirectionArrowFindFirstFreeSlot

<pre>
plugin::CallAndReturn<int, 0x721120>();
0AA7: call_function_return 0x721120 num_params 0 pop 0 func_ret [int]
</pre>

#### C3dMarkers::DirectionArrowSet

<pre>
plugin::Call<0x721140, CVector, float, int, int, int, int, float, float, float>(posn, size, red, green, blue, alpha, dir_x, dir_y, dir_z);
0AA5: call_function 0x721140 num_params 9 pop 9 [posn] [size] [red] [green] [blue] [alpha] [dir_x] [dir_y] [dir_z]
</pre>

#### C3dMarkers::DirectionArrowsDraw

<pre>
plugin::Call<0x7211F0>();
0AA5: call_function 0x7211F0 num_params 0 pop 0
</pre>

#### C3dMarkers::DirectionArrowsInit

<pre>
plugin::Call<0x721100>();
0AA5: call_function 0x721100 num_params 0 pop 0
</pre>

#### C3dMarkers::ForceRender

<pre>
plugin::Call<0x722870, unsigned char>(bEnable);
0AA5: call_function 0x722870 num_params 1 pop 1 [bEnable]
</pre>

#### C3dMarkers::Init

<pre>
plugin::Call<0x724E40>();
0AA5: call_function 0x724E40 num_params 0 pop 0
</pre>

#### C3dMarkers::LoadMarker

<pre>
plugin::CallAndReturn<RpClump*, 0x722810, char const*>(modelName);
0AA7: call_function_return 0x722810 num_params 1 pop 1 [modelName] func_ret [RpClump*]
</pre>

#### C3dMarkers::LoadUser3dMarkers

<pre>
plugin::CallAndReturn<bool, 0x5D42E0>();
0AA7: call_function_return 0x5D42E0 num_params 0 pop 0 func_ret [bool]
</pre>

#### C3dMarkers::PlaceMarker

<pre>
plugin::CallAndReturn<C3dMarker*, 0x725120, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short, float, float, float, bool>(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, nrm_x, nrm_y, nrm_z, zCheck);
0AA7: call_function_return 0x725120 num_params 15 pop 15 [id] [type] [posn] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] [nrm_x] [nrm_y] [nrm_z] [zCheck] func_ret [C3dMarker*]
</pre>

#### C3dMarkers::PlaceMarkerCone

<pre>
plugin::Call<0x726D40, unsigned int, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short, unsigned char>(id, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, bEnableCollision);
0AA5: call_function 0x726D40 num_params 11 pop 11 [id] [posn] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] [bEnableCollision]
</pre>

#### C3dMarkers::PlaceMarkerSet

<pre>
plugin::Call<0x725BA0, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);
0AA5: call_function 0x725BA0 num_params 11 pop 11 [id] [type] [posn] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate]
</pre>

#### C3dMarkers::Render

<pre>
plugin::Call<0x725040>();
0AA5: call_function 0x725040 num_params 0 pop 0
</pre>

#### C3dMarkers::SaveUser3dMarkers

<pre>
plugin::Call<0x5D4300>();
0AA5: call_function 0x5D4300 num_params 0 pop 0
</pre>

#### C3dMarkers::Shutdown

<pre>
plugin::Call<0x722710>();
0AA5: call_function 0x722710 num_params 0 pop 0
</pre>

#### C3dMarkers::Update

<pre>
plugin::Call<0x7227B0>();
0AA5: call_function 0x7227B0 num_params 0 pop 0
</pre>

#### C3dMarkers::User3dMarkerAtomicCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x7210D0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x7210D0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### C3dMarkers::User3dMarkerDelete

<pre>
plugin::Call<0x721090, int>(slotIndex);
0AA5: call_function 0x721090 num_params 1 pop 1 [slotIndex]
</pre>

#### C3dMarkers::User3dMarkerDeleteAll

<pre>
plugin::Call<0x7210B0>();
0AA5: call_function 0x7210B0 num_params 0 pop 0
</pre>

#### C3dMarkers::User3dMarkerFindFirstFreeSlot

<pre>
plugin::CallAndReturn<int, 0x720FB0>();
0AA7: call_function_return 0x720FB0 num_params 0 pop 0 func_ret [int]
</pre>

#### C3dMarkers::User3dMarkerSet

<pre>
plugin::CallAndReturn<int, 0x720FD0, float, float, float, int>(x, y, z, colour);
0AA7: call_function_return 0x720FD0 num_params 4 pop 4 [x] [y] [z] [colour] func_ret [int]
</pre>

#### C3dMarkers::User3dMarkersDraw

<pre>
plugin::Call<0x723240>();
0AA5: call_function 0x723240 num_params 0 pop 0
</pre>

#### MarkerAtomicCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x722220, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x722220 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

### plugin_sa\game_sa\CAEAudioHardware.cpp

#### CAEAudioHardware::GetActiveTrackID

<pre>
plugin::CallMethodAndReturn<int, 0x4D8F80, CAEAudioHardware*>(this);
0AA8: call_method_return 0x4D8F80 struct [CAEAudioHardware] num_params 0 pop 0 func_ret [int]
</pre>

### plugin_sa\game_sa\CAECutsceneTrackManager.cpp

#### CAECutsceneTrackManager::StopCutsceneTrack

<pre>
plugin::CallMethod<0x4DBE80, CAECutsceneTrackManager*>(this);
0AA6: call_method 0x4DBE80 struct [CAECutsceneTrackManager] num_params 0 pop 0
</pre>

#### CAECutsceneTrackManager::StartTrackPlayback

<pre>
plugin::CallMethod<0x4DBF10, CAECutsceneTrackManager*>(this);
0AA6: call_method 0x4DBF10 struct [CAECutsceneTrackManager] num_params 0 pop 0
</pre>

#### CAECutsceneTrackManager::Service

<pre>
plugin::CallMethod<0x4DBFB0, CAECutsceneTrackManager*, int>(this, time);
0AA6: call_method 0x4DBFB0 struct [CAECutsceneTrackManager] num_params 1 pop 0 [time]
</pre>

#### CAECutsceneTrackManager::PreloadBeatTrack

<pre>
plugin::CallMethod<0x4DC130, CAECutsceneTrackManager*, char, bool>(this, arg1, arg2);
0AA6: call_method 0x4DC130 struct [CAECutsceneTrackManager] num_params 2 pop 0 [arg1] [arg2]
</pre>

#### CAECutsceneTrackManager::PlayPreloadedCutsceneTrack

<pre>
plugin::CallMethod<0x4DBE70, CAECutsceneTrackManager*>(this);
0AA6: call_method 0x4DBE70 struct [CAECutsceneTrackManager] num_params 0 pop 0
</pre>

#### CAECutsceneTrackManager::IsCutsceneTrackActive

<pre>
plugin::CallMethodAndReturn<bool, 0x4DBEB0, CAECutsceneTrackManager*>(this);
0AA8: call_method_return 0x4DBEB0 struct [CAECutsceneTrackManager] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAECutsceneTrackManager::GetCutsceneTrackStatus

<pre>
plugin::CallMethodAndReturn<char, 0x4DBEC0, CAECutsceneTrackManager*>(this);
0AA8: call_method_return 0x4DBEC0 struct [CAECutsceneTrackManager] num_params 0 pop 0 func_ret [char]
</pre>

### plugin_sa\game_sa\CAERadioTrackManager.cpp

#### CAERadioTrackManager::StartRadio

<pre>
plugin::CallMethod<0x4EB3C0, CAERadioTrackManager*, int, float, int, char>(this, stationId, bass, arg, unused);
0AA6: call_method 0x4EB3C0 struct [CAERadioTrackManager] num_params 4 pop 0 [stationId] [bass] [arg] [unused]
</pre>

#### CAERadioTrackManager::StopRadio

<pre>
plugin::CallMethod<0x4E9820, CAERadioTrackManager*, tVehicleAudioSettings*, char>(this, settings, arg);
0AA6: call_method 0x4E9820 struct [CAERadioTrackManager] num_params 2 pop 0 [settings] [arg]
</pre>

### plugin_sa\game_sa\CAEStreamThread.cpp

#### CAEStreamThread::Initialise

<pre>
plugin::CallMethodAndReturn<bool, 0x4F1680, CAEStreamThread*>(this);
0AA8: call_method_return 0x4F1680 struct [CAEStreamThread] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAEStreamThread::GetActiveTrackID

<pre>
plugin::CallMethodAndReturn<int, 0x4F1560, CAEStreamThread*>(this);
0AA8: call_method_return 0x4F1560 struct [CAEStreamThread] num_params 0 pop 0 func_ret [int]
</pre>

### plugin_sa\game_sa\CAEWeaponAudioEntity.cpp

#### CAEWeaponAudioEntity::CAEWeaponAudioEntity

<pre>
plugin::CallMethod<0x507560, CAEWeaponAudioEntity *>(this);
0AA6: call_method 0x507560 struct [CAEWeaponAudioEntity] num_params 0 pop 0
</pre>

#### CAEWeaponAudioEntity::WeaponReload

<pre>
plugin::CallMethod<0x503690, CAEWeaponAudioEntity *, eWeaponType, CPhysical*, int>(this, weaptype, entity, AudioEventId);
0AA6: call_method 0x503690 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [weaptype] [entity] [AudioEventId]
</pre>

#### CAEWeaponAudioEntity::WeaponFire

<pre>
plugin::CallMethod<0x504F80, CAEWeaponAudioEntity *, eWeaponType, CPhysical*, int>(this, weaptype, entity, AudioEventId);
0AA6: call_method 0x504F80 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [weaptype] [entity] [AudioEventId]
</pre>

#### CAEWeaponAudioEntity::Terminate

<pre>
plugin::CallMethod<0x503480, CAEWeaponAudioEntity *>(this);
0AA6: call_method 0x503480 struct [CAEWeaponAudioEntity] num_params 0 pop 0
</pre>

#### CAEWeaponAudioEntity::StopFlameThrowerIdleGasLoop

<pre>
plugin::CallMethod<0x5034E0, CAEWeaponAudioEntity *>(this);
0AA6: call_method 0x5034E0 struct [CAEWeaponAudioEntity] num_params 0 pop 0
</pre>

#### CAEWeaponAudioEntity::Reset

<pre>
plugin::CallMethod<0x503490, CAEWeaponAudioEntity *>(this);
0AA6: call_method 0x503490 struct [CAEWeaponAudioEntity] num_params 0 pop 0
</pre>

#### CAEWeaponAudioEntity::ReportStealthKill

<pre>
plugin::CallMethod<0x503B20, CAEWeaponAudioEntity *, eWeaponType, CPhysical*, int>(this, weaptype, entity, AudioEventId);
0AA6: call_method 0x503B20 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [weaptype] [entity] [AudioEventId]
</pre>

#### CAEWeaponAudioEntity::ReportChainsawEvent

<pre>
plugin::CallMethod<0x503910, CAEWeaponAudioEntity *, CPhysical*, int>(this, entity, AudioEventId);
0AA6: call_method 0x503910 struct [CAEWeaponAudioEntity] num_params 2 pop 0 [entity] [AudioEventId]
</pre>

#### CAEWeaponAudioEntity::PlayWeaponLoopSound

<pre>
plugin::CallMethod<0x504610, CAEWeaponAudioEntity *, CPhysical*, short, int, float, float, int>(this, arg0, sfxId, AudioEventId, audability, speed, finalEvent);
0AA6: call_method 0x504610 struct [CAEWeaponAudioEntity] num_params 6 pop 0 [arg0] [sfxId] [AudioEventId] [audability] [speed] [finalEvent]
</pre>

#### CAEWeaponAudioEntity::PlayMiniGunStopSound

<pre>
plugin::CallMethod<0x504960, CAEWeaponAudioEntity *, CPhysical*>(this, entity);
0AA6: call_method 0x504960 struct [CAEWeaponAudioEntity] num_params 1 pop 0 [entity]
</pre>

#### CAEWeaponAudioEntity::PlayMiniGunFireSounds

<pre>
plugin::CallMethod<0x5047C0, CAEWeaponAudioEntity *, CPhysical*, int>(this, entity, AudioEventId);
0AA6: call_method 0x5047C0 struct [CAEWeaponAudioEntity] num_params 2 pop 0 [entity] [AudioEventId]
</pre>

#### CAEWeaponAudioEntity::PlayGunSounds

<pre>
plugin::CallMethod<0x503CE0, CAEWeaponAudioEntity *, CPhysical*, short, short, short, short, short, int, float, float, float>(this, entity, emptySfxId, farSfxId2, highPitchSfxId3, lowPitchSfxId4, echoSfxId5, nAudioEventId, volumeChange, speed1, speed2);
0AA6: call_method 0x503CE0 struct [CAEWeaponAudioEntity] num_params 10 pop 0 [entity] [emptySfxId] [farSfxId2] [highPitchSfxId3] [lowPitchSfxId4] [echoSfxId5] [nAudioEventId] [volumeChange] [speed1] [speed2]
</pre>

#### CAEWeaponAudioEntity::PlayGoggleSound

<pre>
plugin::CallMethod<0x503500, CAEWeaponAudioEntity *, short, int>(this, sfxId, AudioEventId);
0AA6: call_method 0x503500 struct [CAEWeaponAudioEntity] num_params 2 pop 0 [sfxId] [AudioEventId]
</pre>

#### CAEWeaponAudioEntity::PlayFlameThrowerSounds

<pre>
plugin::CallMethod<0x504470, CAEWeaponAudioEntity *, CPhysical*, short, short, int, float, float>(this, entity, sfx1, sfx2, AudioEventId, audability, speed);
0AA6: call_method 0x504470 struct [CAEWeaponAudioEntity] num_params 6 pop 0 [entity] [sfx1] [sfx2] [AudioEventId] [audability] [speed]
</pre>

#### CAEWeaponAudioEntity::PlayFlameThrowerIdleGasLoop

<pre>
plugin::CallMethod<0x503870, CAEWeaponAudioEntity *, CPhysical*>(this, entity);
0AA6: call_method 0x503870 struct [CAEWeaponAudioEntity] num_params 1 pop 0 [entity]
</pre>

#### CAEWeaponAudioEntity::PlayChainsawStopSound

<pre>
plugin::CallMethod<0x504AA0, CAEWeaponAudioEntity *, CPhysical*>(this, entity);
0AA6: call_method 0x504AA0 struct [CAEWeaponAudioEntity] num_params 1 pop 0 [entity]
</pre>

#### CAEWeaponAudioEntity::PlayCameraSound

<pre>
plugin::CallMethod<0x5046F0, CAEWeaponAudioEntity *, CPhysical*, int, float>(this, entity, AudioEventId, audability);
0AA6: call_method 0x5046F0 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [entity] [AudioEventId] [audability]
</pre>

#### CAEWeaponAudioEntity::Initialise

<pre>
plugin::CallMethod<0x503450, CAEWeaponAudioEntity *>(this);
0AA6: call_method 0x503450 struct [CAEWeaponAudioEntity] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CAnimatedBuilding.cpp

#### CAnimatedBuilding::CAnimatedBuilding

<pre>
plugin::CallMethod<0x537A10, CAnimatedBuilding *>(this);
0AA6: call_method 0x537A10 struct [CAnimatedBuilding] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CAnimBlendAssocGroup.cpp

#### CAnimBlendAssocGroup::CAnimBlendAssocGroup

<pre>
plugin::CallMethod<0x4CDE70, CAnimBlendAssocGroup *>(this);
0AA6: call_method 0x4CDE70 struct [CAnimBlendAssocGroup] num_params 0 pop 0
</pre>

#### CAnimBlendAssocGroup::CopyAnimation

<pre>
plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE0B0, CAnimBlendAssocGroup *, char const*>(this, AnimName);
0AA8: call_method_return 0x4CE0B0 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [AnimName] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimBlendAssocGroup::CopyAnimation

<pre>
plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE130, CAnimBlendAssocGroup *, unsigned int>(this, ID);
0AA8: call_method_return 0x4CE130 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [ID] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimBlendAssocGroup::CreateAssociations

<pre>
plugin::CallMethod<0x4CE220, CAnimBlendAssocGroup *, char const*>(this, szBlockName);
0AA6: call_method 0x4CE220 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [szBlockName]
</pre>

#### CAnimBlendAssocGroup::CreateAssociations

<pre>
plugin::CallMethod<0x4CE6E0, CAnimBlendAssocGroup *, char const*, RpClump*, char**, int>(this, AnimName, pClump, arg3, NumAnimations);
0AA6: call_method 0x4CE6E0 struct [CAnimBlendAssocGroup] num_params 4 pop 0 [AnimName] [pClump] [arg3] [NumAnimations]
</pre>

#### CAnimBlendAssocGroup::CreateAssociations

<pre>
plugin::CallMethod<0x4CE3B0, CAnimBlendAssocGroup *, char const*, char const*, char const*, int>(this, AnimName, arg2, arg3, arg4);
0AA6: call_method 0x4CE3B0 struct [CAnimBlendAssocGroup] num_params 4 pop 0 [AnimName] [arg2] [arg3] [arg4]
</pre>

#### CAnimBlendAssocGroup::DestroyAssociations

<pre>
plugin::CallMethod<0x4CDFF0, CAnimBlendAssocGroup *>(this);
0AA6: call_method 0x4CDFF0 struct [CAnimBlendAssocGroup] num_params 0 pop 0
</pre>

#### CAnimBlendAssocGroup::GetAnimation

<pre>
plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE040, CAnimBlendAssocGroup *, char const*>(this, AnimName);
0AA8: call_method_return 0x4CE040 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [AnimName] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimBlendAssocGroup::GetAnimation

<pre>
plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE090, CAnimBlendAssocGroup *, unsigned int>(this, ID);
0AA8: call_method_return 0x4CE090 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [ID] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimBlendAssocGroup::GetAnimationId

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x4CE1B0, CAnimBlendAssocGroup *, char const*>(this, AnimName);
0AA8: call_method_return 0x4CE1B0 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [AnimName] func_ret [unsigned int]
</pre>

#### CAnimBlendAssocGroup::InitEmptyAssociations

<pre>
plugin::CallMethod<0x4CDFB0, CAnimBlendAssocGroup *, RpClump*>(this, pClump);
0AA6: call_method 0x4CDFB0 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [pClump]
</pre>

#### CAnimBlendAssocGroup::~CAnimBlendAssocGroup

<pre>
plugin::CallMethod<0x4CE1D0, CAnimBlendAssocGroup *>(this);
0AA6: call_method 0x4CE1D0 struct [CAnimBlendAssocGroup] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CAnimBlendAssociation.cpp

#### CAnimBlendAssociation::AllocateAnimBlendNodeArray

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::AllocateAnimBlendNodeArray), this, count);
0AA6: call_method 0x4CE9F0 struct [CAnimBlendAssociation] num_params 1 pop 0 [count]
</pre>

#### CAnimBlendAssociation::FreeAnimBlendNodeArray

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::FreeAnimBlendNodeArray), this);
0AA6: call_method 0x4CEA40 struct [CAnimBlendAssociation] num_params 0 pop 0
</pre>

#### \*CAnimBlendAssociation::GetNode

<pre>
plugin::CallMethodAndReturnDynGlobal<CAnimBlendNode *, CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::GetNode), this, nodeIndex);
0AA8: call_method_return 0x4CEB60 struct [*CAnimBlendAssociation] num_params 1 pop 0 [nodeIndex] func_ret [CAnimBlendNode *]
</pre>

#### CAnimBlendAssociation::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(RpClump *, CAnimBlendHierarchy *)), this, clump, hierarchy);
0AA6: call_method 0x4CEEC0 struct [CAnimBlendAssociation] num_params 2 pop 0 [clump] [hierarchy]
</pre>

#### CAnimBlendAssociation::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendAssociation &)), this, source);
0AA6: call_method 0x4CEEC0 struct [CAnimBlendAssociation] num_params 1 pop 0 [source]
</pre>

#### CAnimBlendAssociation::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendStaticAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendStaticAssociation &)), this, source);
0AA6: call_method 0x4CEEC0 struct [CAnimBlendAssociation] num_params 1 pop 0 [source]
</pre>

#### CAnimBlendAssociation::ReferenceAnimBlock

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::ReferenceAnimBlock), this);
0AA6: call_method 0x4CEA50 struct [CAnimBlendAssociation] num_params 0 pop 0
</pre>

#### CAnimBlendAssociation::SetBlend

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlend), this, blendAmount, blendDelta);
0AA6: call_method 0x4CEBA0 struct [CAnimBlendAssociation] num_params 2 pop 0 [blendAmount] [blendDelta]
</pre>

#### CAnimBlendAssociation::SetBlendTo

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlendTo), this, blendAmount, blendDelta);
0AA6: call_method 0x4CEB80 struct [CAnimBlendAssociation] num_params 2 pop 0 [blendAmount] [blendDelta]
</pre>

#### CAnimBlendAssociation::SetCurrentTime

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::SetCurrentTime), this, currentTime);
0AA6: call_method 0x4CEA80 struct [CAnimBlendAssociation] num_params 1 pop 0 [currentTime]
</pre>

#### CAnimBlendAssociation::SetDeleteCallback

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetDeleteCallback), this, callback, data);
0AA6: call_method 0x4CEBC0 struct [CAnimBlendAssociation] num_params 2 pop 0 [callback] [data]
</pre>

#### CAnimBlendAssociation::SetFinishCallback

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetFinishCallback), this, callback, data);
0AA6: call_method 0x4CEBE0 struct [CAnimBlendAssociation] num_params 2 pop 0 [callback] [data]
</pre>

#### CAnimBlendAssociation::Start

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::Start), this, currentTime);
0AA6: call_method 0x4CEB70 struct [CAnimBlendAssociation] num_params 1 pop 0 [currentTime]
</pre>

#### CAnimBlendAssociation::SyncAnimation

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::SyncAnimation), this, syncWith);
0AA6: call_method 0x4CEB40 struct [CAnimBlendAssociation] num_params 1 pop 0 [syncWith]
</pre>

#### CAnimBlendAssociation::UpdateBlend

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::UpdateBlend), this, blendDeltaMult);
0AA8: call_method_return 0x4D1490 struct [CAnimBlendAssociation] num_params 1 pop 0 [blendDeltaMult] func_ret [bool]
</pre>

#### CAnimBlendAssociation::UpdateTime

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTime), this, unused1, unused2);
0AA8: call_method_return 0x4D13D0 struct [CAnimBlendAssociation] num_params 2 pop 0 [unused1] [unused2] func_ret [bool]
</pre>

#### CAnimBlendAssociation::UpdateTimeStep

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTimeStep), this, speedMult, timeMult);
0AA6: call_method 0x4D13A0 struct [CAnimBlendAssociation] num_params 2 pop 0 [speedMult] [timeMult]
</pre>

### plugin_sa\game_sa\CAnimBlendClumpData.cpp

#### CAnimBlendClumpData::CAnimBlendClumpData

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), this);</pre>

#### CAnimBlendClumpData::~CAnimBlendClumpData

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), this);</pre>

#### CAnimBlendClumpData::ForAllFrames

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *>(gaddrof(CAnimBlendClumpData::ForAllFrames), this, callback, data);
0AA6: call_method 0x4CF190 struct [CAnimBlendClumpData] num_params 2 pop 0 [callback] [data]
</pre>

#### CAnimBlendClumpData::ForAllFramesInSPR

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *, unsigned int>(gaddrof(CAnimBlendClumpData::ForAllFramesInSPR), this, callback, data, a3);
0AA6: call_method 0x4CF1E0 struct [CAnimBlendClumpData] num_params 3 pop 0 [callback] [data] [a3]
</pre>

#### CAnimBlendClumpData::LoadFramesIntoSPR

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(gaddrof(CAnimBlendClumpData::LoadFramesIntoSPR), this);
0AA6: call_method 0x4CF1D0 struct [CAnimBlendClumpData] num_params 0 pop 0
</pre>

#### CAnimBlendClumpData::SetNumberOfBones

<pre>
plugin::CallMethodDynGlobal<CAnimBlendClumpData *, int>(gaddrof(CAnimBlendClumpData::SetNumberOfBones), this, numBones);
0AA6: call_method 0x4CF140 struct [CAnimBlendClumpData] num_params 1 pop 0 [numBones]
</pre>

### plugin_sa\game_sa\CAnimBlendHierarchy.cpp

#### CAnimBlendHierarchy::AllocSequenceBlock

<pre>
plugin::CallMethodAndReturn<void*, 0x4CF510, CAnimBlendHierarchy *, bool>(this, arg1);
0AA8: call_method_return 0x4CF510 struct [CAnimBlendHierarchy] num_params 1 pop 0 [arg1] func_ret [void*]
</pre>

#### CAnimBlendHierarchy::CAnimBlendHierarchy

<pre>
plugin::CallMethod<0x4CF270, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF270 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::CalcTotalTime

<pre>
plugin::CallMethod<0x4CF2F0, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF2F0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::CalcTotalTimeCompressed

<pre>
plugin::CallMethod<0x4CF3E0, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF3E0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::RemoveAnimSequences

<pre>
plugin::CallMethod<0x4CF8E0, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF8E0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::RemoveQuaternionFlips

<pre>
plugin::CallMethod<0x4CF4E0, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF4E0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::RemoveUncompressedData

<pre>
plugin::CallMethod<0x4CF760, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF760 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::SetName

<pre>
plugin::CallMethod<0x4CF2D0, CAnimBlendHierarchy *, char const*>(this, string);
0AA6: call_method 0x4CF2D0 struct [CAnimBlendHierarchy] num_params 1 pop 0 [string]
</pre>

#### CAnimBlendHierarchy::Shutdown

<pre>
plugin::CallMethod<0x4CF980, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF980 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

#### CAnimBlendHierarchy::Uncompress

<pre>
plugin::CallMethod<0x4CF5F0, CAnimBlendHierarchy *>(this);
0AA6: call_method 0x4CF5F0 struct [CAnimBlendHierarchy] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CAnimBlendNode.cpp

#### CAnimBlendNode::CalcDeltas

<pre>
plugin::CallMethod<0x4D0190, CAnimBlendNode *>(this);
0AA6: call_method 0x4D0190 struct [CAnimBlendNode] num_params 0 pop 0
</pre>

#### CAnimBlendNode::CalcDeltasCompressed

<pre>
plugin::CallMethod<0x4D0350, CAnimBlendNode *>(this);
0AA6: call_method 0x4D0350 struct [CAnimBlendNode] num_params 0 pop 0
</pre>

#### CAnimBlendNode::FindKeyFrame

<pre>
plugin::CallMethodAndReturn<bool, 0x4D0240, CAnimBlendNode *, float>(this, arg1);
0AA8: call_method_return 0x4D0240 struct [CAnimBlendNode] num_params 1 pop 0 [arg1] func_ret [bool]
</pre>

#### CAnimBlendNode::GetCurrentTranslation

<pre>
plugin::CallMethod<0x4CFC50, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
0AA6: call_method 0x4CFC50 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]
</pre>

#### CAnimBlendNode::GetCurrentTranslationCompressed

<pre>
plugin::CallMethod<0x4CFE60, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
0AA6: call_method 0x4CFE60 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]
</pre>

#### CAnimBlendNode::GetEndTranslation

<pre>
plugin::CallMethod<0x4CFD90, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
0AA6: call_method 0x4CFD90 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]
</pre>

#### CAnimBlendNode::GetEndTranslationCompressed

<pre>
plugin::CallMethod<0x4D0000, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);
0AA6: call_method 0x4D0000 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]
</pre>

#### CAnimBlendNode::Init

<pre>
plugin::CallMethod<0x4CFB70, CAnimBlendNode *>(this);
0AA6: call_method 0x4CFB70 struct [CAnimBlendNode] num_params 0 pop 0
</pre>

#### CAnimBlendNode::NextKeyFrame

<pre>
plugin::CallMethodAndReturn<bool, 0x4D04A0, CAnimBlendNode *>(this);
0AA8: call_method_return 0x4D04A0 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAnimBlendNode::NextKeyFrameCompressed

<pre>
plugin::CallMethodAndReturn<bool, 0x4D0570, CAnimBlendNode *>(this);
0AA8: call_method_return 0x4D0570 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAnimBlendNode::NextKeyFrameNoCalc

<pre>
plugin::CallMethodAndReturn<bool, 0x4CFB90, CAnimBlendNode *>(this);
0AA8: call_method_return 0x4CFB90 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAnimBlendNode::SetupKeyFrameCompressed

<pre>
plugin::CallMethodAndReturn<bool, 0x4D0650, CAnimBlendNode *>(this);
0AA8: call_method_return 0x4D0650 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAnimBlendNode::Update

<pre>
plugin::CallMethodAndReturn<bool, 0x4D06C0, CAnimBlendNode *, CVector&, CQuaternion&, float>(this, Vector, Qauternion, arg3);
0AA8: call_method_return 0x4D06C0 struct [CAnimBlendNode] num_params 3 pop 0 [Vector] [Qauternion] [arg3] func_ret [bool]
</pre>

#### CAnimBlendNode::UpdateCompressed

<pre>
plugin::CallMethodAndReturn<bool, 0x4D08D0, CAnimBlendNode *, CVector&, CQuaternion&, float>(this, Vector, Quaternion, arg3);
0AA8: call_method_return 0x4D08D0 struct [CAnimBlendNode] num_params 3 pop 0 [Vector] [Quaternion] [arg3] func_ret [bool]
</pre>

### plugin_sa\game_sa\CAnimBlendSequence.cpp

#### CAnimBlendSequence::CAnimBlendSequence

<pre>
plugin::CallMethod<0x4D0C10, CAnimBlendSequence *>(this);
0AA6: call_method 0x4D0C10 struct [CAnimBlendSequence] num_params 0 pop 0
</pre>

#### CAnimBlendSequence::CompressKeyframes

<pre>
plugin::CallMethod<0x4D0F40, CAnimBlendSequence *, unsigned char*>(this, arg1);
0AA6: call_method 0x4D0F40 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1]
</pre>

#### CAnimBlendSequence::GetDataSize

<pre>
plugin::CallMethodAndReturn<int, 0x4D0C90, CAnimBlendSequence *, bool>(this, arg1);
0AA8: call_method_return 0x4D0C90 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1] func_ret [int]
</pre>

#### CAnimBlendSequence::MoveMemorY

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1150, CAnimBlendSequence *>(this);
0AA8: call_method_return 0x4D1150 struct [CAnimBlendSequence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAnimBlendSequence::RemoveQuaternionFlips

<pre>
plugin::CallMethodAndReturn<int, 0x4D1190, CAnimBlendSequence *>(this);
0AA8: call_method_return 0x4D1190 struct [CAnimBlendSequence] num_params 0 pop 0 func_ret [int]
</pre>

#### CAnimBlendSequence::RemoveUncompressedData

<pre>
plugin::CallMethod<0x4D12A0, CAnimBlendSequence *, unsigned char*>(this, arg1);
0AA6: call_method 0x4D12A0 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1]
</pre>

#### CAnimBlendSequence::SetBoneTag

<pre>
plugin::CallMethod<0x4D0C70, CAnimBlendSequence *, int>(this, hash);
0AA6: call_method 0x4D0C70 struct [CAnimBlendSequence] num_params 1 pop 0 [hash]
</pre>

#### CAnimBlendSequence::SetName

<pre>
plugin::CallMethod<0x4D0C50, CAnimBlendSequence *, char const*>(this, string);
0AA6: call_method 0x4D0C50 struct [CAnimBlendSequence] num_params 1 pop 0 [string]
</pre>

#### CAnimBlendSequence::SetNumFrames

<pre>
plugin::CallMethod<0x4D0CD0, CAnimBlendSequence *, int, bool, bool, unsigned char*>(this, count, arg2, arg3, arg4);
0AA6: call_method 0x4D0CD0 struct [CAnimBlendSequence] num_params 4 pop 0 [count] [arg2] [arg3] [arg4]
</pre>

#### CAnimBlendSequence::Uncompress

<pre>
plugin::CallMethod<0x4D0D40, CAnimBlendSequence *, unsigned char*>(this, arg1);
0AA6: call_method 0x4D0D40 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1]
</pre>

#### CAnimBlendSequence::~CAnimBlendSequence

<pre>
plugin::CallMethod<0x4D0C30, CAnimBlendSequence *>(this);
0AA6: call_method 0x4D0C30 struct [CAnimBlendSequence] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CAnimBlendStaticAssociation.cpp

#### CAnimBlendStaticAssociation::AllocateSequenceArray

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, int>(gaddrof(CAnimBlendStaticAssociation::AllocateSequenceArray), this, count);
0AA6: call_method 0x4CE960 struct [CAnimBlendStaticAssociation] num_params 1 pop 0 [count]
</pre>

#### CAnimBlendStaticAssociation::FreeSequenceArray

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(gaddrof(CAnimBlendStaticAssociation::FreeSequenceArray), this);
0AA6: call_method 0x4CE9A0 struct [CAnimBlendStaticAssociation] num_params 0 pop 0
</pre>

#### CAnimBlendStaticAssociation::Init

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof(CAnimBlendStaticAssociation::Init), this, clump, hierarchy);
0AA6: call_method 0x4CEC20 struct [CAnimBlendStaticAssociation] num_params 2 pop 0 [clump] [hierarchy]
</pre>

### plugin_sa\game_sa\CAnimManager.cpp

#### CAnimManager::GetAnimationBlock

<pre>
plugin::CallAndReturn<CAnimBlock*, 0x4D3940, char const*>(name);
0AA7: call_function_return 0x4D3940 num_params 1 pop 1 [name] func_ret [CAnimBlock*]
</pre>

#### CAnimManager::GetAnimationBlockIndex

<pre>
plugin::CallAndReturn<int, 0x4D3990, char const*>(name);
0AA7: call_function_return 0x4D3990 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CAnimManager::GetFirstAssocGroup

<pre>
plugin::CallAndReturn<int, 0x4D39B0, char const*>(basename);
0AA7: call_function_return 0x4D39B0 num_params 1 pop 1 [basename] func_ret [int]
</pre>

#### CAnimManager::GetAnimation

<pre>
plugin::CallAndReturn<CAnimBlendHierarchy*, 0x4D39F0, unsigned int, CAnimBlock const*>(hash, ifp);
0AA7: call_function_return 0x4D39F0 num_params 2 pop 2 [hash] [ifp] func_ret [CAnimBlendHierarchy*]
</pre>

#### CAnimManager::GetAnimation

<pre>
plugin::CallAndReturn<CAnimBlendHierarchy*, 0x4D42F0, char const*, CAnimBlock const*>(animName, ifp);
0AA7: call_function_return 0x4D42F0 num_params 2 pop 2 [animName] [ifp] func_ret [CAnimBlendHierarchy*]
</pre>

#### CAnimManager::GetAnimGroupName

<pre>
plugin::CallAndReturn<char*, 0x4D3A20, int>(AssocGroupId);
0AA7: call_function_return 0x4D3A20 num_params 1 pop 1 [AssocGroupId] func_ret [char*]
</pre>

#### CAnimManager::GetAnimBlockName

<pre>
plugin::CallAndReturn<char*, 0x4D3A30, int>(AssocGroupId);
0AA7: call_function_return 0x4D3A30 num_params 1 pop 1 [AssocGroupId] func_ret [char*]
</pre>

#### CAnimManager::CreateAnimAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3A40, int, int>(AssocGroupId, AnimationId);
0AA7: call_function_return 0x4D3A40 num_params 2 pop 2 [AssocGroupId] [AnimationId] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::GetAnimAssociation

<pre>
plugin::CallAndReturn<CAnimBlendStaticAssociation*, 0x4D3A60, int, int>(AssocGroupId, AnimationId);
0AA7: call_function_return 0x4D3A60 num_params 2 pop 2 [AssocGroupId] [AnimationId] func_ret [CAnimBlendStaticAssociation*]
</pre>

#### CAnimManager::GetAnimAssociation

<pre>
plugin::CallAndReturn<CAnimBlendStaticAssociation*, 0x4D3A80, int, char const*>(AssocGroupId, arg2);
0AA7: call_function_return 0x4D3A80 num_params 2 pop 2 [AssocGroupId] [arg2] func_ret [CAnimBlendStaticAssociation*]
</pre>

#### CAnimManager::AddAnimation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3AA0, RpClump*, int, int>(clump, AssocGroupId, AnimationId);
0AA7: call_function_return 0x4D3AA0 num_params 3 pop 3 [clump] [AssocGroupId] [AnimationId] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::AddAnimation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D4330, RpClump*, CAnimBlendHierarchy*, int>(clump, pAnimBlendHier, clumpAssocFlag);
0AA7: call_function_return 0x4D4330 num_params 3 pop 3 [clump] [pAnimBlendHier] [clumpAssocFlag] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::AddAnimationAndSync

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3B30, RpClump*, CAnimBlendAssociation*, int, int>(clump, pAnimBlendAssoc, AssocGroupId, AnimationId);
0AA7: call_function_return 0x4D3B30 num_params 4 pop 4 [clump] [pAnimBlendAssoc] [AssocGroupId] [AnimationId] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::AddAnimAssocDefinition

<pre>
plugin::CallAndReturn<CAnimationStyleDescriptor*, 0x4D3BA0, char const*, char const*, unsigned int, unsigned int, void*>(groupName, blockName, arg3, animsCount, pAnimDescriptor);
0AA7: call_function_return 0x4D3BA0 num_params 5 pop 5 [groupName] [blockName] [arg3] [animsCount] [pAnimDescriptor] func_ret [CAnimationStyleDescriptor*]
</pre>

#### CAnimManager::AddAnimToAssocDefinition

<pre>
plugin::CallAndReturn<void*, 0x4D3C80, void*, char const*>(pAnimAssocDefinition, arg2);
0AA7: call_function_return 0x4D3C80 num_params 2 pop 2 [pAnimAssocDefinition] [arg2] func_ret [void*]
</pre>

#### CAnimManager::CreateAnimAssocGroups

<pre>
plugin::Call<0x4D3CC0>();
0AA5: call_function 0x4D3CC0 num_params 0 pop 0
</pre>

#### CAnimManager::RegisterAnimBlock

<pre>
plugin::CallAndReturn<int, 0x4D3E50, char const*>(name);
0AA7: call_function_return 0x4D3E50 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CAnimManager::RemoveLastAnimFile

<pre>
plugin::Call<0x4D3ED0>();
0AA5: call_function 0x4D3ED0 num_params 0 pop 0
</pre>

#### CAnimManager::RemoveAnimBlock

<pre>
plugin::Call<0x4D3F40, int>(index);
0AA5: call_function 0x4D3F40 num_params 1 pop 1 [index]
</pre>

#### CAnimManager::AddAnimBlockRef

<pre>
plugin::Call<0x4D3FB0, int>(index);
0AA5: call_function 0x4D3FB0 num_params 1 pop 1 [index]
</pre>

#### CAnimManager::RemoveAnimBlockRef

<pre>
plugin::Call<0x4D3FD0, int>(index);
0AA5: call_function 0x4D3FD0 num_params 1 pop 1 [index]
</pre>

#### CAnimManager::RemoveAnimBlockRefWithoutDelete

<pre>
plugin::Call<0x4D3FF0, int>(index);
0AA5: call_function 0x4D3FF0 num_params 1 pop 1 [index]
</pre>

#### CAnimManager::GetNumRefsToAnimBlock

<pre>
plugin::CallAndReturn<int, 0x4D4010, int>(index);
0AA7: call_function_return 0x4D4010 num_params 1 pop 1 [index] func_ret [int]
</pre>

#### CAnimManager::Shutdown

<pre>
plugin::Call<0x4D4130>();
0AA5: call_function 0x4D4130 num_params 0 pop 0
</pre>

#### CAnimManager::UncompressAnimation

<pre>
plugin::Call<0x4D41C0, CAnimBlendHierarchy*>(pAnimBlendHier);
0AA5: call_function 0x4D41C0 num_params 1 pop 1 [pAnimBlendHier]
</pre>

#### CAnimManager::RemoveFromUncompressedCache

<pre>
plugin::Call<0x4D42A0, CAnimBlendHierarchy*>(pAnimBlendHier);
0AA5: call_function 0x4D42A0 num_params 1 pop 1 [pAnimBlendHier]
</pre>

#### CAnimManager::BlendAnimation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D4410, RpClump*, CAnimBlendHierarchy*, int, float>(clump, pAnimBlendHier, flags, clumpAssocBlendData);
0AA7: call_function_return 0x4D4410 num_params 4 pop 4 [clump] [pAnimBlendHier] [flags] [clumpAssocBlendData] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::BlendAnimation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D4610, RpClump*, int, int, float>(clump, AssocGroupId, AnimationId, clumpAssocBlendData);
0AA7: call_function_return 0x4D4610 num_params 4 pop 4 [clump] [AssocGroupId] [AnimationId] [clumpAssocBlendData] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::LoadAnimFile

<pre>
plugin::Call<0x4D47F0, RwStream*, bool, char const(*)[32]>(stream, arg1, string);
0AA5: call_function 0x4D47F0 num_params 3 pop 3 [stream] [arg1] [string]
</pre>

#### CAnimManager::LoadAnimFiles

<pre>
plugin::Call<0x4D5620>();
0AA5: call_function 0x4D5620 num_params 0 pop 0
</pre>

#### CAnimManager::ReadAnimAssociationDefinitions

<pre>
plugin::Call<0x5BC910>();
0AA5: call_function 0x5BC910 num_params 0 pop 0
</pre>

#### CAnimManager::Initialise

<pre>
plugin::Call<0x5BF6B0>();
0AA5: call_function 0x5BF6B0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CAudioEngine.cpp

#### CAudioEngine::Initialise

<pre>
plugin::CallMethod<0x5B9C60, CAudioEngine*>(this);
0AA6: call_method 0x5B9C60 struct [CAudioEngine] num_params 0 pop 0
</pre>

#### CAudioEngine::Restart

<pre>
plugin::CallMethod<0x506DB0, CAudioEngine*>(this);
0AA6: call_method 0x506DB0 struct [CAudioEngine] num_params 0 pop 0
</pre>

#### CAudioEngine::Shutdown

<pre>
plugin::CallMethod<0x507CB0, CAudioEngine*>(this);
0AA6: call_method 0x507CB0 struct [CAudioEngine] num_params 0 pop 0
</pre>

#### CAudioEngine::SetEffectsMasterVolume

<pre>
plugin::CallMethod<0x506E10, CAudioEngine*, char>(this, volume);
0AA6: call_method 0x506E10 struct [CAudioEngine] num_params 1 pop 0 [volume]
</pre>

#### CAudioEngine::SetMusicMasterVolume

<pre>
plugin::CallMethod<0x506DE0, CAudioEngine*, char>(this, volume);
0AA6: call_method 0x506DE0 struct [CAudioEngine] num_params 1 pop 0 [volume]
</pre>

#### CAudioEngine::SetBassEnhanceOnOff

<pre>
plugin::CallMethod<0x506F90, CAudioEngine*, bool>(this, on);
0AA6: call_method 0x506F90 struct [CAudioEngine] num_params 1 pop 0 [on]
</pre>

#### CAudioEngine::SetRadioAutoRetuneOnOff

<pre>
plugin::CallMethod<0x506F80, CAudioEngine*, bool>(this, on);
0AA6: call_method 0x506F80 struct [CAudioEngine] num_params 1 pop 0 [on]
</pre>

#### CAudioEngine::RetuneRadio

<pre>
plugin::CallMethod<0x507E10, CAudioEngine*, char>(this, stationId);
0AA6: call_method 0x507E10 struct [CAudioEngine] num_params 1 pop 0 [stationId]
</pre>

#### CAudioEngine::ReportFrontendAudioEvent

<pre>
plugin::CallMethodAndReturn<CReference*, 0x506EA0, CAudioEngine*, int, float, float>(this, id, volume, speed);
0AA8: call_method_return 0x506EA0 struct [CAudioEngine] num_params 3 pop 0 [id] [volume] [speed] func_ret [CReference*]
</pre>

#### CAudioEngine::ReportMissionAudioEvent

<pre>
plugin::CallMethod<0x507340, CAudioEngine*, eAudioEvents,CVector const*>(this,audioEvent,coords);
0AA6: call_method 0x507340 struct [CAudioEngine] num_params 2 pop 0 [audioEvent] [coords]
</pre>

#### CAudioEngine::Service

<pre>
plugin::CallMethod<0x507750, CAudioEngine*>(this);
0AA6: call_method 0x507750 struct [CAudioEngine] num_params 0 pop 0
</pre>

#### CAudioEngine::ServiceLoadingTune

<pre>
plugin::CallMethod<0x5078A0, CAudioEngine*, float>(this, fade);
0AA6: call_method 0x5078A0 struct [CAudioEngine] num_params 1 pop 0 [fade]
</pre>

#### CAudioEngine::StartRadio

<pre>
plugin::CallMethod<0x507DC0, CAudioEngine*, int, char>(this, radioStation, arg);
0AA6: call_method 0x507DC0 struct [CAudioEngine] num_params 2 pop 0 [radioStation] [arg]
</pre>

#### CAudioEngine::StopRadio

<pre>
plugin::CallMethod<0x506F70, CAudioEngine*, tVehicleAudioSettings*, bool>(this, settings, arg);
0AA6: call_method 0x506F70 struct [CAudioEngine] num_params 2 pop 0 [settings] [arg]
</pre>

#### CAudioEngine::IsRadioRetuneInProgress

<pre>
plugin::CallMethodAndReturn<bool, 0x506FF0, CAudioEngine*>(this);
0AA8: call_method_return 0x506FF0 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::IsLoadingTuneActive

<pre>
plugin::CallMethodAndReturn<bool, 0x506D90, CAudioEngine*>(this);
0AA8: call_method_return 0x506D90 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::IsRadioOn

<pre>
plugin::CallMethodAndReturn<bool, 0x506FD0, CAudioEngine*>(this);
0AA8: call_method_return 0x506FD0 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::IsAmbienceTrackActive

<pre>
plugin::CallMethodAndReturn<bool, 0x507210, CAudioEngine*>(this);
0AA8: call_method_return 0x507210 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::StartLoadingTune

<pre>
plugin::CallMethodAndReturn<bool, 0x507410, CAudioEngine*>(this);
0AA8: call_method_return 0x507410 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::GetCurrentRadioStationID

<pre>
plugin::CallMethodAndReturn<bool, 0x507040, CAudioEngine*>(this);
0AA8: call_method_return 0x507040 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::IsVehicleRadioActive

<pre>
plugin::CallMethodAndReturn<bool, 0x507050, CAudioEngine*>(this);
0AA8: call_method_return 0x507050 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAudioEngine::InitialisePostLoading

<pre>
plugin::CallMethod<0x5078F0, CAudioEngine*>(this);
0AA6: call_method 0x5078F0 struct [CAudioEngine] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBaseModelInfo.cpp

#### CBaseModelInfo::GetIsDrawLast

<pre>
plugin::CallMethodAndReturn<bool, 0x5328C0, CBaseModelInfo *>(this);
0AA8: call_method_return 0x5328C0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::HasBeenPreRendered

<pre>
plugin::CallMethodAndReturn<bool, 0x5328B0, CBaseModelInfo *>(this);
0AA8: call_method_return 0x5328B0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::HasComplexHierarchy

<pre>
plugin::CallMethodAndReturn<bool, 0x4C4E00, CBaseModelInfo *>(this);
0AA8: call_method_return 0x4C4E00 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::IsBackfaceCulled

<pre>
plugin::CallMethodAndReturn<bool, 0x5328F0, CBaseModelInfo *>(this);
0AA8: call_method_return 0x5328F0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::IsBreakableStatuePart

<pre>
plugin::CallMethodAndReturn<bool, 0x59F090, CBaseModelInfo *>(this);
0AA8: call_method_return 0x59F090 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::IsLod

<pre>
plugin::CallMethodAndReturn<bool, 0x4C4A00, CBaseModelInfo *>(this);
0AA8: call_method_return 0x4C4A00 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::IsRoad

<pre>
plugin::CallMethodAndReturn<bool, 0x4C4DF0, CBaseModelInfo *>(this);
0AA8: call_method_return 0x4C4DF0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::IsTagModel

<pre>
plugin::CallMethodAndReturn<bool, 0x49CC20, CBaseModelInfo *>(this);
0AA8: call_method_return 0x49CC20 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::SwaysInWind

<pre>
plugin::CallMethodAndReturn<bool, 0x4212C0, CBaseModelInfo *>(this);
0AA8: call_method_return 0x4212C0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CBaseModelInfo::SetHasBeenPreRendered

<pre>
plugin::CallMethod<0x4C42F0, CBaseModelInfo *, int>(this, bHasBeenPreRendered);
0AA6: call_method 0x4C42F0 struct [CBaseModelInfo] num_params 1 pop 0 [bHasBeenPreRendered]
</pre>

#### CBaseModelInfo::SetIsLod

<pre>
plugin::CallMethod<0x4C4A10, CBaseModelInfo *, int>(this, bIsLod);
0AA6: call_method 0x4C4A10 struct [CBaseModelInfo] num_params 1 pop 0 [bIsLod]
</pre>

#### CBaseModelInfo::SetOwnsColModel

<pre>
plugin::CallMethod<0x5328D0, CBaseModelInfo *, int>(this, bOwns);
0AA6: call_method 0x5328D0 struct [CBaseModelInfo] num_params 1 pop 0 [bOwns]
</pre>

#### CBaseModelInfo::IncreaseAlpha

<pre>
plugin::CallMethod<0x532900, CBaseModelInfo *>(this);
0AA6: call_method 0x532900 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBirds.cpp

#### CBirds::Init

<pre>
plugin::Call<0x711EC0>();
0AA5: call_function 0x711EC0 num_params 0 pop 0
</pre>

#### CBirds::CreateNumberOfBirds

<pre>
plugin::CallAndReturn<int, 0x711EF0, CVector, CVector, int, int, bool>(pos, destination, count, birdType, checkObstacles);
0AA7: call_function_return 0x711EF0 num_params 5 pop 5 [pos] [destination] [count] [birdType] [checkObstacles] func_ret [int]
</pre>

#### CBirds::Shutdown

<pre>
plugin::Call<0x712300>();
0AA5: call_function 0x712300 num_params 0 pop 0
</pre>

#### CBirds::Update

<pre>
plugin::Call<0x712330>();
0AA5: call_function 0x712330 num_params 0 pop 0
</pre>

#### CBirds::Render

<pre>
plugin::Call<0x712810>();
0AA5: call_function 0x712810 num_params 0 pop 0
</pre>

#### CBirds::HandleGunShot

<pre>
plugin::Call<0x712E40, CVector const*, CVector const*>(pointA, pointB);
0AA5: call_function 0x712E40 num_params 2 pop 2 [pointA] [pointB]
</pre>

### plugin_sa\game_sa\CBouncingPanel.cpp

#### CBouncingPanel::ResetPanel

<pre>
plugin::CallMethod<0x6F4910, CBouncingPanel *>(this);
0AA6: call_method 0x6F4910 struct [CBouncingPanel] num_params 0 pop 0
</pre>

#### CBouncingPanel::SetPanel

<pre>
plugin::CallMethod<0x6F4920, CBouncingPanel *, short, short, float>(this, frameId, axis, angleLimit);
0AA6: call_method 0x6F4920 struct [CBouncingPanel] num_params 3 pop 0 [frameId] [axis] [angleLimit]
</pre>

#### CBouncingPanel::ProcessPanel

<pre>
plugin::CallMethod<0x6F49A0, CBouncingPanel *, CVehicle*, RwFrame*, CVector, CVector, float, float>(this, vehicle, frame, arg2, arg3, arg4, arg5);
0AA6: call_method 0x6F49A0 struct [CBouncingPanel] num_params 6 pop 0 [vehicle] [frame] [arg2] [arg3] [arg4] [arg5]
</pre>

### plugin_sa\game_sa\CBoundingBox.cpp

#### CBoundingBox::CBoundingBox

<pre>
plugin::CallMethod<0x40FAF0, CBoundingBox *>(this);
0AA6: call_method 0x40FAF0 struct [CBoundingBox] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBrightLights.cpp

#### CBrightLights::RenderOutGeometryBuffer

<pre>
plugin::Call<0x722150>();
0AA5: call_function 0x722150 num_params 0 pop 0
</pre>

#### CBrightLights::Render

<pre>
plugin::Call<0x7241C0>();
0AA5: call_function 0x7241C0 num_params 0 pop 0
</pre>

#### CBrightLights::RegisterOne

<pre>
plugin::Call<0x724770, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(posn, top, right, at, color, arg5, arg6, arg7);
0AA5: call_function 0x724770 num_params 8 pop 8 [posn] [top] [right] [at] [color] [arg5] [arg6] [arg7]
</pre>

#### CBrightLights::Init

<pre>
plugin::Call<0x722140>();
0AA5: call_function 0x722140 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBuilding.cpp

#### CBuilding::operator new

<pre>
plugin::CallAndReturn<void*, 0x404090, unsigned int>(size);
0AA7: call_function_return 0x404090 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CBuilding::operator delete

<pre>
plugin::Call<0x4040A0, void*>(data);
0AA5: call_function 0x4040A0 num_params 1 pop 1 [data]
</pre>

#### CBuilding::CBuilding

<pre>
plugin::CallMethod<0x403E00, CBuilding *>(this);
0AA6: call_method 0x403E00 struct [CBuilding] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBulletInfo.cpp

#### CBulletInfo::Initialise

<pre>
plugin::Call<0x735FD0>();
0AA5: call_function 0x735FD0 num_params 0 pop 0
</pre>

#### CBulletInfo::Shutdown

<pre>
plugin::Call<0x736000>();
0AA5: call_function 0x736000 num_params 0 pop 0
</pre>

#### CBulletInfo::AddBullet

<pre>
plugin::CallAndReturn<bool, 0x736010, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, position, velocity);
0AA7: call_function_return 0x736010 num_params 4 pop 4 [creator] [weaponType] [position] [velocity] func_ret [bool]
</pre>

#### CBulletInfo::Update

<pre>
plugin::Call<0x7360D0>();
0AA5: call_function 0x7360D0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBulletTrace.cpp

#### CBulletTrace::Update

<pre>
plugin::CallMethod<0x721D70, CBulletTrace *>(this);
0AA6: call_method 0x721D70 struct [CBulletTrace] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CBulletTraces.cpp

#### CBulletTraces::AddTrace

<pre>
plugin::Call<0x726AF0, CVector*, CVector*, int, CEntity*>(start, end, weaponType, entity);
0AA5: call_function 0x726AF0 num_params 4 pop 4 [start] [end] [weaponType] [entity]
</pre>

#### CBulletTraces::Init

<pre>
plugin::Call<0x721D50>();
0AA5: call_function 0x721D50 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CCamera.cpp

#### CCamera::AddShakeSimple

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, int, float>(gaddrof(CCamera::AddShakeSimple), this, duration, type, intensity);
0AA6: call_method 0x50D240 struct [CCamera] num_params 3 pop 0 [duration] [type] [intensity]
</pre>

#### CCamera::AllowShootingWith2PlayersInCar

<pre>
plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::AllowShootingWith2PlayersInCar), this, bAllowShootingWith2PlayersInCar);
0AA6: call_method 0x50C280 struct [CCamera] num_params 1 pop 0 [bAllowShootingWith2PlayersInCar]
</pre>

#### CCamera::ApplyVehicleCameraTweaks

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVehicle *>(gaddrof(CCamera::ApplyVehicleCameraTweaks), this, vehicle);
0AA6: call_method 0x50A480 struct [CCamera] num_params 1 pop 0 [vehicle]
</pre>

#### CCamera::AvoidTheGeometry

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const *, CVector const *, CVector *, float>(gaddrof(CCamera::AvoidTheGeometry), this, arg2, arg3, arg4, FOV);
0AA6: call_method 0x514030 struct [CCamera] num_params 4 pop 0 [arg2] [arg3] [arg4] [FOV]
</pre>

#### CCamera::CalculateDerivedValues

<pre>
plugin::CallMethodDynGlobal<CCamera *, bool, bool>(gaddrof(CCamera::CalculateDerivedValues), this, bForMirror, bOriented);
0AA6: call_method 0x5150E0 struct [CCamera] num_params 2 pop 0 [bForMirror] [bOriented]
</pre>

#### CCamera::CalculateFrustumPlanes

<pre>
plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::CalculateFrustumPlanes), this, bForMirror);
0AA6: call_method 0x514D60 struct [CCamera] num_params 1 pop 0 [bForMirror]
</pre>

#### CCamera::CalculateGroundHeight

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *, unsigned int>(gaddrof(CCamera::CalculateGroundHeight), this, type);
0AA8: call_method_return 0x514B80 struct [CCamera] num_params 1 pop 0 [type] func_ret [float]
</pre>

#### CCamera::CalculateMirroredMatrix

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector, float, CMatrix *, CMatrix *>(gaddrof(CCamera::CalculateMirroredMatrix), this, posn, MirrorV, CamMat, MirrorMat);
0AA6: call_method 0x50B380 struct [CCamera] num_params 4 pop 0 [posn] [MirrorV] [CamMat] [MirrorMat]
</pre>

#### CCamera::CamControl

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CamControl), this);
0AA6: call_method 0x527FA0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::CamShake

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, float, float, float>(gaddrof(CCamera::CamShake), this, arg2, x, y, z);
0AA6: call_method 0x50A9F0 struct [CCamera] num_params 4 pop 0 [arg2] [x] [y] [z]
</pre>

#### CCamera::CameraColDetAndReact

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CCamera *, CVector *, CVector *>(gaddrof(CCamera::CameraColDetAndReact), this, source, target);
0AA8: call_method_return 0x520190 struct [CCamera] num_params 2 pop 0 [source] [target] func_ret [char]
</pre>

#### CCamera::CameraGenericModeSpecialCases

<pre>
plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::CameraGenericModeSpecialCases), this, targetPed);
0AA6: call_method 0x50CD30 struct [CCamera] num_params 1 pop 0 [targetPed]
</pre>

#### CCamera::CameraPedAimModeSpecialCases

<pre>
plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::CameraPedAimModeSpecialCases), this, targPed);
0AA6: call_method 0x50CDA0 struct [CCamera] num_params 1 pop 0 [targPed]
</pre>

#### CCamera::CameraPedModeSpecialCases

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CameraPedModeSpecialCases), this);
0AA6: call_method 0x50CD80 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::CameraVehicleModeSpecialCases

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVehicle *>(gaddrof(CCamera::CameraVehicleModeSpecialCases), this, targVehicle);
0AA6: call_method 0x50CDE0 struct [CCamera] num_params 1 pop 0 [targVehicle]
</pre>

#### CCamera::ClearPlayerWeaponMode

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ClearPlayerWeaponMode), this);
0AA6: call_method 0x50AB10 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ConeCastCollisionResolve

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector *, CVector *, CVector *, float, float, float *>(gaddrof(CCamera::ConeCastCollisionResolve), this, source, center, pVecOut, radius, arg5, pFloatOut);
0AA8: call_method_return 0x51A5D0 struct [CCamera] num_params 6 pop 0 [source] [center] [pVecOut] [radius] [arg5] [pFloatOut] func_ret [bool]
</pre>

#### CCamera::ConsiderPedAsDucking

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CPed *>(gaddrof(CCamera::ConsiderPedAsDucking), this, ped);
0AA8: call_method_return 0x50CEB0 struct [CCamera] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CCamera::CopyCameraMatrixToRWCam

<pre>
plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::CopyCameraMatrixToRWCam), this, bUpdateMatrix);
0AA6: call_method 0x50AFA0 struct [CCamera] num_params 1 pop 0 [bUpdateMatrix]
</pre>

#### CCamera::DealWithMirrorBeforeConstructRenderList

<pre>
plugin::CallMethodDynGlobal<CCamera *, bool, CVector, float, CMatrix *>(gaddrof(CCamera::DealWithMirrorBeforeConstructRenderList), this, bActiveMirror, MirrorNormal, MirrorV, matMirror);
0AA6: call_method 0x50B510 struct [CCamera] num_params 4 pop 0 [bActiveMirror] [MirrorNormal] [MirrorV] [matMirror]
</pre>

#### CCamera::DeleteCutSceneCamDataMemory

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DeleteCutSceneCamDataMemory), this);
0AA6: call_method 0x5B24A0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::DrawBordersForWideScreen

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DrawBordersForWideScreen), this);
0AA6: call_method 0x514860 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Enable1rstPersonCamCntrlsScript

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Enable1rstPersonCamCntrlsScript), this);
0AA6: call_method 0x50AC00 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Enable1rstPersonWeaponsCamera

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Enable1rstPersonWeaponsCamera), this);
0AA6: call_method 0x50AC10 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Fade

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, short>(gaddrof(CCamera::Fade), this, fadeDuration, FadeInOutFlag);
0AA6: call_method 0x50AC20 struct [CCamera] num_params 2 pop 0 [fadeDuration] [FadeInOutFlag]
</pre>

#### CCamera::Find3rdPersonCamTargetVector

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, CVector, CVector *, CVector *>(gaddrof(CCamera::Find3rdPersonCamTargetVector), this, range, source, pCamera, pPoint);
0AA6: call_method 0x514970 struct [CCamera] num_params 4 pop 0 [range] [source] [pCamera] [pPoint]
</pre>

#### CCamera::Find3rdPersonQuickAimPitch

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::Find3rdPersonQuickAimPitch), this);
0AA8: call_method_return 0x50AD40 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::FindCamFOV

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::FindCamFOV), this);
0AA8: call_method_return 0x50AD20 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::FinishCutscene

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::FinishCutscene), this);
0AA6: call_method 0x514950 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::GetArrPosForVehicleType

<pre>
plugin::CallMethodDynGlobal<CCamera *, int, int *>(gaddrof(CCamera::GetArrPosForVehicleType), this, type, arrPos);
0AA6: call_method 0x50AF00 struct [CCamera] num_params 2 pop 0 [type] [arrPos]
</pre>

#### CCamera::GetCutSceneFinishTime

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::GetCutSceneFinishTime), this);
0AA8: call_method_return 0x50AD90 struct [CCamera] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CCamera::GetFading

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetFading), this);
0AA8: call_method_return 0x50ADE0 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetFadingDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetFadingDirection), this);
0AA8: call_method_return 0x50ADF0 struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### \*CCamera::GetGameCamPosition

<pre>
plugin::CallMethodAndReturnDynGlobal<CVector *, CCamera *>(gaddrof(CCamera::GetGameCamPosition), this);
0AA8: call_method_return 0x50AE50 struct [*CCamera] num_params 0 pop 0 func_ret [CVector *]
</pre>

#### CCamera::GetLookDirection

<pre>
plugin::CallMethodAndReturnDynGlobal<signed int, CCamera *>(gaddrof(CCamera::GetLookDirection), this);
0AA8: call_method_return 0x50AE90 struct [CCamera] num_params 0 pop 0 func_ret [signed int]
</pre>

#### CCamera::GetLookingForwardFirstPerson

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingForwardFirstPerson), this);
0AA8: call_method_return 0x50AED0 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetLookingLRBFirstPerson

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingLRBFirstPerson), this);
0AA8: call_method_return 0x50AE60 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetPositionAlongSpline

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetPositionAlongSpline), this);
0AA8: call_method_return 0x50AF80 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::GetRoughDistanceToGround

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetRoughDistanceToGround), this);
0AA8: call_method_return 0x516B00 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::GetScreenFadeStatus

<pre>
plugin::CallMethodAndReturnDynGlobal<signed int, CCamera *>(gaddrof(CCamera::GetScreenFadeStatus), this);
0AA8: call_method_return 0x50AE20 struct [CCamera] num_params 0 pop 0 func_ret [signed int]
</pre>

#### CCamera::GetScreenRect

<pre>
plugin::CallMethodDynGlobal<CCamera *, CRect *>(gaddrof(CCamera::GetScreenRect), this, pRect);
0AA6: call_method 0x50AB50 struct [CCamera] num_params 1 pop 0 [pRect]
</pre>

#### CCamera::Get_Just_Switched_Status

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Get_Just_Switched_Status), this);
0AA8: call_method_return 0x50AE10 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::HandleCameraMotionForDucking

<pre>
plugin::CallMethodDynGlobal<CCamera *, CPed *, CVector *, CVector *, bool>(gaddrof(CCamera::HandleCameraMotionForDucking), this, ped, source, targPosn, arg5);
0AA6: call_method 0x50CFA0 struct [CCamera] num_params 4 pop 0 [ped] [source] [targPosn] [arg5]
</pre>

#### CCamera::HandleCameraMotionForDuckingDuringAim

<pre>
plugin::CallMethodDynGlobal<CCamera *, CPed *, CVector *, CVector *, bool>(gaddrof(CCamera::HandleCameraMotionForDuckingDuringAim), this, ped, source, targPosn, arg5);
0AA6: call_method 0x50D090 struct [CCamera] num_params 4 pop 0 [ped] [source] [targPosn] [arg5]
</pre>

#### CCamera::ImproveNearClip

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVehicle *, CPed *, CVector *, CVector *>(gaddrof(CCamera::ImproveNearClip), this, pVehicle, pPed, source, targPosn);
0AA6: call_method 0x516B20 struct [CCamera] num_params 4 pop 0 [pVehicle] [pPed] [source] [targPosn]
</pre>

#### CCamera::Init

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Init), this);
0AA6: call_method 0x5BC520 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::InitCameraVehicleTweaks

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::InitCameraVehicleTweaks), this);
0AA6: call_method 0x50A3B0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::InitialiseScriptableComponents

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::InitialiseScriptableComponents), this);
0AA8: call_method_return 0x50D2D0 struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### CCamera::IsExtraEntityToIgnore

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CEntity *>(gaddrof(CCamera::IsExtraEntityToIgnore), this, entity);
0AA8: call_method_return 0x50CE80 struct [CCamera] num_params 1 pop 0 [entity] func_ret [bool]
</pre>

#### CCamera::IsItTimeForNewcam

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int, int>(gaddrof(CCamera::IsItTimeForNewcam), this, CamSequence, StartTime);
0AA8: call_method_return 0x51D770 struct [CCamera] num_params 2 pop 0 [CamSequence] [StartTime] func_ret [bool]
</pre>

#### CCamera::IsSphereVisible

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float, RwMatrixTag *>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float, RwMatrixTag *)), this, origin, radius, transformMatrix);
0AA8: call_method_return 0x420D40 struct [CCamera] num_params 3 pop 0 [origin] [radius] [transformMatrix] func_ret [bool]
</pre>

#### CCamera::IsSphereVisible

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &, float)), this, origin, radius);
0AA8: call_method_return 0x420D40 struct [CCamera] num_params 2 pop 0 [origin] [radius] func_ret [bool]
</pre>

#### CCamera::LerpFOV

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, float, float, bool>(gaddrof(CCamera::LerpFOV), this, zoomInFactor, zoomOutFactor, timelimit, bEase);
0AA6: call_method 0x50D280 struct [CCamera] num_params 4 pop 0 [zoomInFactor] [zoomOutFactor] [timelimit] [bEase]
</pre>

#### CCamera::LoadPathSplines

<pre>
plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::LoadPathSplines), this, pFile);
0AA6: call_method 0x5B24D0 struct [CCamera] num_params 1 pop 0 [pFile]
</pre>

#### CCamera::Process

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process), this);
0AA6: call_method 0x52B730 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessFOVLerp

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessFOVLerp, void (CCamera::*)(float)), this, ratio);
0AA6: call_method 0x516500 struct [CCamera] num_params 1 pop 0 [ratio]
</pre>

#### CCamera::ProcessFOVLerp

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessFOVLerp, void (CCamera::*)()), this);
0AA6: call_method 0x516500 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessFade

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessFade), this);
0AA6: call_method 0x50B5D0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessMusicFade

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessMusicFade), this);
0AA6: call_method 0x50B6D0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraBoat

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraBoat), this);
0AA6: call_method 0x526E20 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraCar

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraCar), this);
0AA6: call_method 0x5267C0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraHeli

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraHeli), this);
0AA6: call_method 0x526AE0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraPed

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPed), this);
0AA8: call_method_return 0x50B880 struct [CCamera] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CCamera::ProcessObbeCinemaCameraPlane

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPlane), this);
0AA6: call_method 0x526C80 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraTrain

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraTrain), this);
0AA6: call_method 0x526950 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessScriptedCommands

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessScriptedCommands), this);
0AA6: call_method 0x516AE0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessShake

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessShake, void (CCamera::*)(float)), this, JiggleIntensity);
0AA6: call_method 0x51A6F0 struct [CCamera] num_params 1 pop 0 [JiggleIntensity]
</pre>

#### CCamera::ProcessShake

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessShake, void (CCamera::*)()), this);
0AA6: call_method 0x51A6F0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessVectorMoveLinear

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessVectorMoveLinear, void (CCamera::*)(float)), this, ratio);
0AA6: call_method 0x5164A0 struct [CCamera] num_params 1 pop 0 [ratio]
</pre>

#### CCamera::ProcessVectorMoveLinear

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessVectorMoveLinear, void (CCamera::*)()), this);
0AA6: call_method 0x5164A0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessVectorTrackLinear

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessVectorTrackLinear, void (CCamera::*)(float)), this, ratio);
0AA6: call_method 0x516440 struct [CCamera] num_params 1 pop 0 [ratio]
</pre>

#### CCamera::ProcessVectorTrackLinear

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessVectorTrackLinear, void (CCamera::*)()), this);
0AA6: call_method 0x516440 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessWideScreenOn

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessWideScreenOn), this);
0AA6: call_method 0x50B890 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RenderMotionBlur

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RenderMotionBlur), this);
0AA6: call_method 0x50B8F0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ResetDuckingSystem

<pre>
plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::ResetDuckingSystem), this, ped);
0AA6: call_method 0x50CEF0 struct [CCamera] num_params 1 pop 0 [ped]
</pre>

#### CCamera::Restore

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Restore), this);
0AA6: call_method 0x50B930 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RestoreCameraAfterMirror

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreCameraAfterMirror), this);
0AA6: call_method 0x51A5A0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RestoreWithJumpCut

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreWithJumpCut), this);
0AA6: call_method 0x50BAB0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetCamCutSceneOffSet

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const *>(gaddrof(CCamera::SetCamCutSceneOffSet), this, cutsceneOffset);
0AA6: call_method 0x50BD20 struct [CCamera] num_params 1 pop 0 [cutsceneOffset]
</pre>

#### CCamera::SetCamPositionForFixedMode

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const *, CVector const *>(gaddrof(CCamera::SetCamPositionForFixedMode), this, fixedModeSource, fixedModeUpOffset);
0AA6: call_method 0x50BEC0 struct [CCamera] num_params 2 pop 0 [fixedModeSource] [fixedModeUpOffset]
</pre>

#### CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString), this);
0AA6: call_method 0x50BD40 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString

<pre>
plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString), this, targetPed);
0AA6: call_method 0x50BDA0 struct [CCamera] num_params 1 pop 0 [targetPed]
</pre>

#### CCamera::SetCameraUpForMirror

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraUpForMirror), this);
0AA6: call_method 0x51A560 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetFadeColour

<pre>
plugin::CallMethodDynGlobal<CCamera *, unsigned char, unsigned char, unsigned char>(gaddrof(CCamera::SetFadeColour), this, Red, Green, Blue);
0AA6: call_method 0x50BF00 struct [CCamera] num_params 3 pop 0 [Red] [Green] [Blue]
</pre>

#### CCamera::SetMotionBlur

<pre>
plugin::CallMethodDynGlobal<CCamera *, int, int, int, int, int>(gaddrof(CCamera::SetMotionBlur), this, Red, Green, Blue, value, Blurtype);
0AA6: call_method 0x50BF40 struct [CCamera] num_params 5 pop 0 [Red] [Green] [Blue] [value] [Blurtype]
</pre>

#### CCamera::SetMotionBlurAlpha

<pre>
plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::SetMotionBlurAlpha), this, Alpha);
0AA6: call_method 0x50BF80 struct [CCamera] num_params 1 pop 0 [Alpha]
</pre>

#### CCamera::SetNearClipBasedOnPedCollision

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipBasedOnPedCollision), this, arg2);
0AA6: call_method 0x50CB90 struct [CCamera] num_params 1 pop 0 [arg2]
</pre>

#### CCamera::SetNearClipScript

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipScript), this, NearClip);
0AA6: call_method 0x50BF90 struct [CCamera] num_params 1 pop 0 [NearClip]
</pre>

#### CCamera::SetNewPlayerWeaponMode

<pre>
plugin::CallMethodDynGlobal<CCamera *, short, short, short>(gaddrof(CCamera::SetNewPlayerWeaponMode), this, mode, maxZoom, minZoom);
0AA6: call_method 0x50BFB0 struct [CCamera] num_params 3 pop 0 [mode] [maxZoom] [minZoom]
</pre>

#### CCamera::SetParametersForScriptInterpolation

<pre>
plugin::CallMethodDynGlobal<CCamera *, float, float, unsigned int>(gaddrof(CCamera::SetParametersForScriptInterpolation), this, InterpolationToStopMoving, InterpolationToCatchUp, TimeForInterPolation);
0AA6: call_method 0x50C030 struct [CCamera] num_params 3 pop 0 [InterpolationToStopMoving] [InterpolationToCatchUp] [TimeForInterPolation]
</pre>

#### CCamera::SetPercentAlongCutScene

<pre>
plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetPercentAlongCutScene), this, percent);
0AA6: call_method 0x50C070 struct [CCamera] num_params 1 pop 0 [percent]
</pre>

#### CCamera::SetRwCamera

<pre>
plugin::CallMethodDynGlobal<CCamera *, RwCamera *>(gaddrof(CCamera::SetRwCamera), this, rwcamera);
0AA6: call_method 0x50C100 struct [CCamera] num_params 1 pop 0 [rwcamera]
</pre>

#### CCamera::SetWideScreenOff

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOff), this);
0AA6: call_method 0x50C150 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetWideScreenOn

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOn), this);
0AA6: call_method 0x50C140 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetZoomValueCamStringScript

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueCamStringScript), this, zoomMode);
0AA6: call_method 0x50C1B0 struct [CCamera] num_params 1 pop 0 [zoomMode]
</pre>

#### CCamera::SetZoomValueFollowPedScript

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueFollowPedScript), this, zoomMode);
0AA6: call_method 0x50C160 struct [CCamera] num_params 1 pop 0 [zoomMode]
</pre>

#### CCamera::StartCooperativeCamMode

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::StartCooperativeCamMode), this);
0AA6: call_method 0x50C260 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::StartTransition

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransition), this, currentCamMode);
0AA6: call_method 0x515200 struct [CCamera] num_params 1 pop 0 [currentCamMode]
</pre>

#### CCamera::StartTransitionWhenNotFinishedInter

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransitionWhenNotFinishedInter), this, currentCamMode);
0AA6: call_method 0x515BC0 struct [CCamera] num_params 1 pop 0 [currentCamMode]
</pre>

#### CCamera::StopCooperativeCamMode

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::StopCooperativeCamMode), this);
0AA6: call_method 0x50C270 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::StoreValuesDuringInterPol

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, CVector *, float *>(gaddrof(CCamera::StoreValuesDuringInterPol), this, SourceDuringInter, TargetDuringInter, UpDuringInter, FOVDuringInter);
0AA6: call_method 0x50C290 struct [CCamera] num_params 4 pop 0 [SourceDuringInter] [TargetDuringInter] [UpDuringInter] [FOVDuringInter]
</pre>

#### CCamera::TakeControl

<pre>
plugin::CallMethodDynGlobal<CCamera *, CEntity *, short, short, int>(gaddrof(CCamera::TakeControl), this, target, ModeToGoTo, TypeOfSwitch, WhoIsInControlOfTheCamera);
0AA6: call_method 0x50C7C0 struct [CCamera] num_params 4 pop 0 [target] [ModeToGoTo] [TypeOfSwitch] [WhoIsInControlOfTheCamera]
</pre>

#### CCamera::TakeControlAttachToEntity

<pre>
plugin::CallMethodDynGlobal<CCamera *, CEntity *, CEntity *, CVector *, CVector *, float, short, int>(gaddrof(CCamera::TakeControlAttachToEntity), this, target, attached, AttachedCamOffset, AttachedCamLookAt, AttachedCamAngle, TypeOfSwitch, WhoIsInControlOfTheCamera);
0AA6: call_method 0x50C910 struct [CCamera] num_params 7 pop 0 [target] [attached] [AttachedCamOffset] [AttachedCamLookAt] [AttachedCamAngle] [TypeOfSwitch] [WhoIsInControlOfTheCamera]
</pre>

#### CCamera::TakeControlNoEntity

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const *, short, int>(gaddrof(CCamera::TakeControlNoEntity), this, FixedModeVector, TypeOfSwitch, WhoIsInControlOfTheCamera);
0AA6: call_method 0x50C8B0 struct [CCamera] num_params 3 pop 0 [FixedModeVector] [TypeOfSwitch] [WhoIsInControlOfTheCamera]
</pre>

#### CCamera::TakeControlWithSpline

<pre>
plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::TakeControlWithSpline), this, TypeOfSwitch);
0AA6: call_method 0x50CAE0 struct [CCamera] num_params 1 pop 0 [TypeOfSwitch]
</pre>

#### CCamera::TryToStartNewCamMode

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int>(gaddrof(CCamera::TryToStartNewCamMode), this, CamSequence);
0AA8: call_method_return 0x51E560 struct [CCamera] num_params 1 pop 0 [CamSequence] func_ret [bool]
</pre>

#### CCamera::UpdateAimingCoors

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector const *>(gaddrof(CCamera::UpdateAimingCoors), this, AimingTargetCoors);
0AA6: call_method 0x50CB10 struct [CCamera] num_params 1 pop 0 [AimingTargetCoors]
</pre>

#### CCamera::UpdateSoundDistances

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateSoundDistances), this);
0AA6: call_method 0x515BD0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::UpdateTargetEntity

<pre>
plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateTargetEntity), this);
0AA6: call_method 0x50C360 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Using1stPersonWeaponMode

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Using1stPersonWeaponMode), this);
0AA8: call_method_return 0x50BFF0 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::VectorMoveLinear

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, float, bool>(gaddrof(CCamera::VectorMoveLinear), this, MoveLinearPosnEnd, MoveLinearPosnStart, duration, bMoveLinearWithEase);
0AA6: call_method 0x50D160 struct [CCamera] num_params 4 pop 0 [MoveLinearPosnEnd] [MoveLinearPosnStart] [duration] [bMoveLinearWithEase]
</pre>

#### CCamera::VectorMoveRunning

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::VectorMoveRunning), this);
0AA8: call_method_return 0x4748A0 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::VectorTrackLinear

<pre>
plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, float, bool>(gaddrof(CCamera::VectorTrackLinear), this, TrackLinearStartPoint, TrackLinearEndPoint, duration, bEase);
0AA6: call_method 0x50D1D0 struct [CCamera] num_params 4 pop 0 [TrackLinearStartPoint] [TrackLinearEndPoint] [duration] [bEase]
</pre>

#### CCamera::VectorTrackRunning

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::VectorTrackRunning), this);
0AA8: call_method_return 0x474870 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::SetCamCollisionVarDataSet

<pre>
plugin::CallDynGlobal<int>(gaddrof(CCamera::SetCamCollisionVarDataSet), index);
</pre>

#### CCamera::SetColVarsAimWeapon

<pre>
plugin::CallDynGlobal<int>(gaddrof(CCamera::SetColVarsAimWeapon), aimingType);
</pre>

#### CCamera::SetColVarsPed

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CCamera::SetColVarsPed), pedtype, nCamPedZoom);
</pre>

#### CCamera::SetColVarsVehicle

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CCamera::SetColVarsVehicle), vehicletype, CamVehicleZoom);
</pre>

### plugin_sa\game_sa\CCarAI.cpp

#### CCarAI::BackToCruisingIfNoWantedLevel

<pre>
plugin::Call<0x41BFA0, CVehicle*>(pVehicle);
0AA5: call_function 0x41BFA0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::CarHasReasonToStop

<pre>
plugin::Call<0x41C050, CVehicle*>(pVehicle);
0AA5: call_function 0x41C050 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::AddPoliceCarOccupants

<pre>
plugin::Call<0x41C070, CVehicle*, bool>(pVehicle, arg2);
0AA5: call_function 0x41C070 num_params 2 pop 2 [pVehicle] [arg2]
</pre>

#### CCarAI::AddAmbulanceOccupants

<pre>
plugin::Call<0x41C4A0, CVehicle*>(pVehicle);
0AA5: call_function 0x41C4A0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::AddFiretruckOccupants

<pre>
plugin::Call<0x41C600, CVehicle*>(pVehicle);
0AA5: call_function 0x41C600 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::TellOccupantsToLeaveCar

<pre>
plugin::Call<0x41C760, CVehicle*>(pVehicle);
0AA5: call_function 0x41C760 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::TellCarToFollowOtherCar

<pre>
plugin::Call<0x41C960, CVehicle*, CVehicle*, float>(pVehicle1, pVehicle2, radius);
0AA5: call_function 0x41C960 num_params 3 pop 3 [pVehicle1] [pVehicle2] [radius]
</pre>

#### CCarAI::FindPoliceBikeMissionForWantedLevel

<pre>
plugin::CallAndReturn<char, 0x41CA40>();
0AA7: call_function_return 0x41CA40 num_params 0 pop 0 func_ret [char]
</pre>

#### CCarAI::FindPoliceBoatMissionForWantedLevel

<pre>
plugin::CallAndReturn<char, 0x41CA50>();
0AA7: call_function_return 0x41CA50 num_params 0 pop 0 func_ret [char]
</pre>

#### CCarAI::FindPoliceCarSpeedForWantedLevel

<pre>
plugin::CallAndReturn<int, 0x41CAA0, CVehicle*>(pVehicle);
0AA7: call_function_return 0x41CAA0 num_params 1 pop 1 [pVehicle] func_ret [int]
</pre>

#### CCarAI::GetCarToGoToCoors

<pre>
plugin::CallAndReturn<float, 0x41CE30, CVehicle*, CVector*, int, bool>(pVehicle1, pVector, drivingStyle, bSpeedLimit20);
0AA7: call_function_return 0x41CE30 num_params 4 pop 4 [pVehicle1] [pVector] [drivingStyle] [bSpeedLimit20] func_ret [float]
</pre>

#### CCarAI::GetCarToParkAtCoors

<pre>
plugin::CallAndReturn<float, 0x41D350, CVehicle*, CVector*>(pVehicle, pVector);
0AA7: call_function_return 0x41D350 num_params 2 pop 2 [pVehicle] [pVector] func_ret [float]
</pre>

#### CCarAI::MellowOutChaseSpeed

<pre>
plugin::Call<0x41D3D0, CVehicle*>(pVehicle);
0AA5: call_function 0x41D3D0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::MakeWayForCarWithSiren

<pre>
plugin::Call<0x41D660, CVehicle*>(pVehicle);
0AA5: call_function 0x41D660 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::UpdateCarAI

<pre>
plugin::Call<0x41DA30, CVehicle*>(pVehicle);
0AA5: call_function 0x41DA30 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarAI::FindPoliceCarMissionForWantedLevel

<pre>
plugin::CallAndReturn<char, 0x41C9D0>();
0AA7: call_function_return 0x41C9D0 num_params 0 pop 0 func_ret [char]
</pre>

### plugin_sa\game_sa\CCarCtrl.cpp

#### CCarCtrl::ChooseBoatModel

<pre>
plugin::CallAndReturn<int, 0x421970>();
0AA7: call_function_return 0x421970 num_params 0 pop 0 func_ret [int]
</pre>

#### CCarCtrl::ChooseCarModelToLoad

<pre>
plugin::CallAndReturn<int, 0x421900, int>(arg1);
0AA7: call_function_return 0x421900 num_params 1 pop 1 [arg1] func_ret [int]
</pre>

#### CCarCtrl::ChooseGangCarModel

<pre>
plugin::CallAndReturn<int, 0x421A40, int>(arg1);
0AA7: call_function_return 0x421A40 num_params 1 pop 1 [arg1] func_ret [int]
</pre>

#### CCarCtrl::ChooseModel

<pre>
plugin::CallAndReturn<int, 0x424CE0, int*>(arg1);
0AA7: call_function_return 0x424CE0 num_params 1 pop 1 [arg1] func_ret [int]
</pre>

#### CCarCtrl::ChoosePoliceCarModel

<pre>
plugin::CallAndReturn<int, 0x421980, unsigned int>(arg0);
0AA7: call_function_return 0x421980 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CCarCtrl::ClearInterestingVehicleList

<pre>
plugin::Call<0x423F00>();
0AA5: call_function 0x423F00 num_params 0 pop 0
</pre>

#### CCarCtrl::ClipTargetOrientationToLink

<pre>
plugin::Call<0x422760, CVehicle*, CCarPathLinkAddress, char, float*, float, float>(pVehicle, arg2, arg3, arg4, arg5, arg6);
0AA5: call_function 0x422760 num_params 6 pop 6 [pVehicle] [arg2] [arg3] [arg4] [arg5] [arg6]
</pre>

#### CCarCtrl::CreateCarForScript

<pre>
plugin::CallAndReturn<CVehicle*, 0x431F80, int, CVector, unsigned char>(modelid, posn, MissionCleanUpFlag);
0AA7: call_function_return 0x431F80 num_params 3 pop 3 [modelid] [posn] [MissionCleanUpFlag] func_ret [CVehicle*]
</pre>

#### CCarCtrl::CreateConvoy

<pre>
plugin::CallAndReturn<bool, 0x42C740, CVehicle*, int>(pVehicle, arg2);
0AA7: call_function_return 0x42C740 num_params 2 pop 2 [pVehicle] [arg2] func_ret [bool]
</pre>

#### CCarCtrl::CreatePoliceChase

<pre>
plugin::CallAndReturn<bool, 0x42C2B0, CVehicle*, int, CNodeAddress>(pVehicle, arg2, NodeAddress);
0AA7: call_function_return 0x42C2B0 num_params 3 pop 3 [pVehicle] [arg2] [NodeAddress] func_ret [bool]
</pre>

#### CCarCtrl::DealWithBend_Racing

<pre>
plugin::CallAndReturn<bool, 0x428040, CVehicle*, CCarPathLinkAddress, CCarPathLinkAddress, CCarPathLinkAddress, CCarPathLinkAddress, char, char, char, char, float, float*, float*, float*, float*, CVector*>(pVehicle, LinkAddress1, LinkAddress2, LinkAddress3, LinkAddress4, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, pVector);
0AA7: call_function_return 0x428040 num_params 15 pop 15 [pVehicle] [LinkAddress1] [LinkAddress2] [LinkAddress3] [LinkAddress4] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12] [arg13] [arg14] [pVector] func_ret [bool]
</pre>

#### CCarCtrl::DragCarToPoint

<pre>
plugin::Call<0x42EC90, CVehicle*, CVector*>(pVehicle, pVector);
0AA5: call_function 0x42EC90 num_params 2 pop 2 [pVehicle] [pVector]
</pre>

#### CCarCtrl::FindAngleToWeaveThroughTraffic

<pre>
plugin::CallAndReturn<float, 0x4325C0, CVehicle*, CPhysical*, float, float, float>(pVehicle, pPhysical, arg3, arg4, arg5);
0AA7: call_function_return 0x4325C0 num_params 5 pop 5 [pVehicle] [pPhysical] [arg3] [arg4] [arg5] func_ret [float]
</pre>

#### CCarCtrl::FindIntersection2Lines

<pre>
plugin::Call<0x4226F0, float, float, float, float, float, float, float, float, float*, float*>(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
0AA5: call_function 0x4226F0 num_params 10 pop 10 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10]
</pre>

#### CCarCtrl::FindLinksToGoWithTheseNodes

<pre>
plugin::Call<0x42B470, CVehicle*>(pVehicle);
0AA5: call_function 0x42B470 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::FindMaximumSpeedForThisCarInTraffic

<pre>
plugin::CallAndReturn<float, 0x434400, CVehicle*>(pVehicle);
0AA7: call_function_return 0x434400 num_params 1 pop 1 [pVehicle] func_ret [float]
</pre>

#### CCarCtrl::FindNodesThisCarIsNearestTo

<pre>
plugin::Call<0x42BD20, CVehicle*, CNodeAddress&, CNodeAddress&>(pVehicle, NodeAddress1, NodeAddress2);
0AA5: call_function 0x42BD20 num_params 3 pop 3 [pVehicle] [NodeAddress1] [NodeAddress2]
</pre>

#### CCarCtrl::FindPathDirection

<pre>
plugin::CallAndReturn<char, 0x422090, CNodeAddress, CNodeAddress, CNodeAddress, bool*>(NodeAddress1, NodeAddress2, NodeAddress3, arg4);
0AA7: call_function_return 0x422090 num_params 4 pop 4 [NodeAddress1] [NodeAddress2] [NodeAddress3] [arg4] func_ret [char]
</pre>

#### CCarCtrl::FindPercDependingOnDistToLink

<pre>
plugin::CallAndReturn<float, 0x422620, CVehicle*, CCarPathLinkAddress>(pVehicle, LinkAddress);
0AA7: call_function_return 0x422620 num_params 2 pop 2 [pVehicle] [LinkAddress] func_ret [float]
</pre>

#### CCarCtrl::FindSequenceElement

<pre>
plugin::CallAndReturn<int, 0x421770, int>(arg1);
0AA7: call_function_return 0x421770 num_params 1 pop 1 [arg1] func_ret [int]
</pre>

#### CCarCtrl::FindSpeedMultiplier

<pre>
plugin::CallAndReturn<float, 0x4224E0, float, float, float, float>(arg1, arg2, arg3, arg4);
0AA7: call_function_return 0x4224E0 num_params 4 pop 4 [arg1] [arg2] [arg3] [arg4] func_ret [float]
</pre>

#### CCarCtrl::FindSpeedMultiplierWithSpeedFromNodes

<pre>
plugin::CallAndReturn<float, 0x424130, char>(arg1);
0AA7: call_function_return 0x424130 num_params 1 pop 1 [arg1] func_ret [float]
</pre>

#### CCarCtrl::FireHeliRocketsAtTarget

<pre>
plugin::Call<0x42B270, CAutomobile*, CEntity*>(pEntityLauncher, pEntity);
0AA5: call_function 0x42B270 num_params 2 pop 2 [pEntityLauncher] [pEntity]
</pre>

#### CCarCtrl::FlyAIHeliInCertainDirection

<pre>
plugin::Call<0x429A70, CHeli*, float, float, bool>(pHeli, arg2, arg3, arg4);
0AA5: call_function 0x429A70 num_params 4 pop 4 [pHeli] [arg2] [arg3] [arg4]
</pre>

#### CCarCtrl::FlyAIHeliToTarget_FixedOrientation

<pre>
plugin::Call<0x423940, CHeli*, float, CVector>(pHeli, Orientation, posn);
0AA5: call_function 0x423940 num_params 3 pop 3 [pHeli] [Orientation] [posn]
</pre>

#### CCarCtrl::FlyAIPlaneInCertainDirection

<pre>
plugin::Call<0x423000, CPlane*>(pPlane);
0AA5: call_function 0x423000 num_params 1 pop 1 [pPlane]
</pre>

#### CCarCtrl::GenerateCarCreationCoors2

<pre>
plugin::CallAndReturn<bool, 0x424210, CVector, float, float, float, bool, float, float, CVector*, CNodeAddress*, CNodeAddress*, float*, bool, bool>(posn, radius, arg3, arg4, arg5, arg6, arg7, pOrigin, pNodeAddress1, pNodeAddress12, arg11, arg12, arg13);
0AA7: call_function_return 0x424210 num_params 13 pop 13 [posn] [radius] [arg3] [arg4] [arg5] [arg6] [arg7] [pOrigin] [pNodeAddress1] [pNodeAddress12] [arg11] [arg12] [arg13] func_ret [bool]
</pre>

#### CCarCtrl::GenerateEmergencyServicesCar

<pre>
plugin::Call<0x42F9C0>();
0AA5: call_function 0x42F9C0 num_params 0 pop 0
</pre>

#### CCarCtrl::GenerateOneEmergencyServicesCar

<pre>
plugin::CallAndReturn<bool, 0x42B7D0, unsigned int, CVector>(modelID, posn);
0AA7: call_function_return 0x42B7D0 num_params 2 pop 2 [modelID] [posn] func_ret [bool]
</pre>

#### CCarCtrl::GenerateOneRandomCar

<pre>
plugin::Call<0x430050>();
0AA5: call_function 0x430050 num_params 0 pop 0
</pre>

#### CCarCtrl::GenerateRandomCars

<pre>
plugin::Call<0x4341C0>();
0AA5: call_function 0x4341C0 num_params 0 pop 0
</pre>

#### CCarCtrl::GetAIHeliToAttackPlayer

<pre>
plugin::Call<0x42F3C0, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42F3C0 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::GetAIHeliToFlyInDirection

<pre>
plugin::Call<0x42A730, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42A730 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::GetAIPlaneToAttackPlayer

<pre>
plugin::Call<0x429780, CAutomobile*>(pAutomobile);
0AA5: call_function 0x429780 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::GetAIPlaneToDoDogFight

<pre>
plugin::Call<0x429890, CAutomobile*>(pAutomobile);
0AA5: call_function 0x429890 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::GetAIPlaneToDoDogFightAgainstPlayer

<pre>
plugin::Call<0x42F370, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42F370 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::GetNewVehicleDependingOnCarModel

<pre>
plugin::CallAndReturn<CVehicle*, 0x421440, int, unsigned char>(modelID, createdBy);
0AA7: call_function_return 0x421440 num_params 2 pop 2 [modelID] [createdBy] func_ret [CVehicle*]
</pre>

#### CCarCtrl::Init

<pre>
plugin::Call<0x4212E0>();
0AA5: call_function 0x4212E0 num_params 0 pop 0
</pre>

#### CCarCtrl::InitSequence

<pre>
plugin::Call<0x421740, int>(SequenceElements);
0AA5: call_function 0x421740 num_params 1 pop 1 [SequenceElements]
</pre>

#### CCarCtrl::IsAnyoneParking

<pre>
plugin::CallAndReturn<bool, 0x42C250>();
0AA7: call_function_return 0x42C250 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCarCtrl::IsThisAnAppropriateNode

<pre>
plugin::CallAndReturn<bool, 0x42DAB0, CVehicle*, CNodeAddress, CNodeAddress, CNodeAddress, bool>(pVehicle, NodeAddress1, NodeAddress2, NodeAddress3, arg5);
0AA7: call_function_return 0x42DAB0 num_params 5 pop 5 [pVehicle] [NodeAddress1] [NodeAddress2] [NodeAddress3] [arg5] func_ret [bool]
</pre>

#### CCarCtrl::IsThisVehicleInteresting

<pre>
plugin::CallAndReturn<bool, 0x423EA0, CVehicle*>(pVehicle);
0AA7: call_function_return 0x423EA0 num_params 1 pop 1 [pVehicle] func_ret [bool]
</pre>

#### CCarCtrl::JoinCarWithRoadAccordingToMission

<pre>
plugin::Call<0x432CB0, CVehicle*>(pVehicle);
0AA5: call_function 0x432CB0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::JoinCarWithRoadSystem

<pre>
plugin::Call<0x42F5A0, CVehicle*>(pVehicle);
0AA5: call_function 0x42F5A0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::JoinCarWithRoadSystemGotoCoors

<pre>
plugin::CallAndReturn<bool, 0x42F870, CVehicle*, CVector const&, bool, bool>(pVehicle, posn, unused, bIsBoat);
0AA7: call_function_return 0x42F870 num_params 4 pop 4 [pVehicle] [posn] [unused] [bIsBoat] func_ret [bool]
</pre>

#### CCarCtrl::PickNextNodeAccordingStrategy

<pre>
plugin::CallAndReturn<bool, 0x432B10, CVehicle*>(pVehicle);
0AA7: call_function_return 0x432B10 num_params 1 pop 1 [pVehicle] func_ret [bool]
</pre>

#### CCarCtrl::PickNextNodeRandomly

<pre>
plugin::Call<0x42DE80, CVehicle*>(pVehicle);
0AA5: call_function 0x42DE80 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::PickNextNodeToChaseCar

<pre>
plugin::CallAndReturn<bool, 0x426EF0, CVehicle*, float, float, float>(pVehicle, x_dest, y_dest, z_dest);
0AA7: call_function_return 0x426EF0 num_params 4 pop 4 [pVehicle] [x_dest] [y_dest] [z_dest] func_ret [bool]
</pre>

#### CCarCtrl::PickNextNodeToFollowPath

<pre>
plugin::CallAndReturn<bool, 0x427740, CVehicle*>(pVehicle);
0AA7: call_function_return 0x427740 num_params 1 pop 1 [pVehicle] func_ret [bool]
</pre>

#### CCarCtrl::PossiblyFireHSMissile

<pre>
plugin::Call<0x429600, CVehicle*, CEntity*>(pEntityLauncher, pTargetEntity);
0AA5: call_function 0x429600 num_params 2 pop 2 [pEntityLauncher] [pTargetEntity]
</pre>

#### CCarCtrl::PossiblyRemoveVehicle

<pre>
plugin::Call<0x424F80, CVehicle*>(pVehicle);
0AA5: call_function 0x424F80 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::PruneVehiclesOfInterest

<pre>
plugin::Call<0x423F10>();
0AA5: call_function 0x423F10 num_params 0 pop 0
</pre>

#### CCarCtrl::ReInit

<pre>
plugin::Call<0x4213B0>();
0AA5: call_function 0x4213B0 num_params 0 pop 0
</pre>

#### CCarCtrl::ReconsiderRoute

<pre>
plugin::Call<0x42FC40, CVehicle*>(pVehicle);
0AA5: call_function 0x42FC40 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::RegisterVehicleOfInterest

<pre>
plugin::Call<0x423DE0, CVehicle*>(pVehicle);
0AA5: call_function 0x423DE0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::RemoveCarsIfThePoolGetsFull

<pre>
plugin::Call<0x4322B0>();
0AA5: call_function 0x4322B0 num_params 0 pop 0
</pre>

#### CCarCtrl::RemoveDistantCars

<pre>
plugin::Call<0x42CD10>();
0AA5: call_function 0x42CD10 num_params 0 pop 0
</pre>

#### CCarCtrl::RemoveFromInterestingVehicleList

<pre>
plugin::Call<0x423ED0, CVehicle*>(pVehicle);
0AA5: call_function 0x423ED0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::ScanForPedDanger

<pre>
plugin::Call<0x42CE40, CVehicle*>(pVehicle);
0AA5: call_function 0x42CE40 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::ScriptGenerateOneEmergencyServicesCar

<pre>
plugin::CallAndReturn<bool, 0x42FBC0, unsigned int, CVector>(modelID, posn);
0AA7: call_function_return 0x42FBC0 num_params 2 pop 2 [modelID] [posn] func_ret [bool]
</pre>

#### CCarCtrl::SetCoordsOfScriptCar

<pre>
plugin::Call<0x4342A0, CVehicle*, float, float, float, unsigned char, unsigned char>(pVehicle, x, y, z, arg5, arg6);
0AA5: call_function 0x4342A0 num_params 6 pop 6 [pVehicle] [x] [y] [z] [arg5] [arg6]
</pre>

#### CCarCtrl::SetUpDriverAndPassengersForVehicle

<pre>
plugin::Call<0x4217C0, CVehicle*, int, int, bool, bool, int>(pVehicle, arg2, arg3, arg4, arg5, passengersNum);
0AA5: call_function 0x4217C0 num_params 6 pop 6 [pVehicle] [arg2] [arg3] [arg4] [arg5] [passengersNum]
</pre>

#### CCarCtrl::SlowCarDownForCarsSectorList

<pre>
plugin::Call<0x432420, CPtrList&, CVehicle*, float, float, float, float, float*, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x432420 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::SlowCarDownForObject

<pre>
plugin::Call<0x426220, CEntity*, CVehicle*, float*, float>(pEntity, pVehicle, arg3, arg4);
0AA5: call_function 0x426220 num_params 4 pop 4 [pEntity] [pVehicle] [arg3] [arg4]
</pre>

#### CCarCtrl::SlowCarDownForObjectsSectorList

<pre>
plugin::Call<0x42D4F0, CPtrList&, CVehicle*, float, float, float, float, float*, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x42D4F0 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::SlowCarDownForOtherCar

<pre>
plugin::Call<0x42D0E0, CEntity*, CVehicle*, float*, float>(pCar1, pCar2, arg3, arg4);
0AA5: call_function 0x42D0E0 num_params 4 pop 4 [pCar1] [pCar2] [arg3] [arg4]
</pre>

#### CCarCtrl::SlowCarDownForPedsSectorList

<pre>
plugin::Call<0x425440, CPtrList&, CVehicle*, float, float, float, float, float*, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x425440 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::SlowCarOnRailsDownForTrafficAndLights

<pre>
plugin::Call<0x434790, CVehicle*>(pVehicle);
0AA5: call_function 0x434790 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer

<pre>
plugin::Call<0x428DE0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x428DE0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAIBoatWithPhysicsCirclingPlayer

<pre>
plugin::Call<0x429090, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x429090 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget

<pre>
plugin::Call<0x428BE0, CVehicle*, float, float, float*, float*, float*>(pVehicle, arg2, arg3, arg4, arg5, arg6);
0AA5: call_function 0x428BE0 num_params 6 pop 6 [pVehicle] [arg2] [arg3] [arg4] [arg5] [arg6]
</pre>

#### CCarCtrl::SteerAICarBlockingPlayerForwardAndBack

<pre>
plugin::Call<0x422B20, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x422B20 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarParkParallel

<pre>
plugin::Call<0x433BA0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x433BA0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarParkPerpendicular

<pre>
plugin::Call<0x433EA0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x433EA0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarTowardsPointInEscort

<pre>
plugin::Call<0x4336D0, CVehicle*, CVehicle*, float, float, float*, float*, float*, bool*>(pVehicle1, pVehicle2, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x4336D0 num_params 8 pop 8 [pVehicle1] [pVehicle2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::SteerAICarWithPhysics

<pre>
plugin::Call<0x437C20, CVehicle*>(pVehicle);
0AA5: call_function 0x437C20 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsFollowPath

<pre>
plugin::Call<0x434900, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x434900 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsFollowPath_Racing

<pre>
plugin::Call<0x435830, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x435830 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsFollowPreRecordedPath

<pre>
plugin::Call<0x432DD0, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x432DD0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsHeadingForTarget

<pre>
plugin::Call<0x433280, CVehicle*, CPhysical*, float, float, float*, float*, float*, bool*>(pVehicle, pTarget, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x433280 num_params 8 pop 8 [pVehicle] [pTarget] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget

<pre>
plugin::Call<0x4335E0, CVehicle*, CEntity*, float, float, float, float, float*, float*, float*, bool*>(pVehicle, Unusued, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
0AA5: call_function 0x4335E0 num_params 10 pop 10 [pVehicle] [Unusued] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop

<pre>
plugin::Call<0x428990, CVehicle*, float, float, float, float, float*, float*, float*, bool*>(pVehicle, x, y, arg4, arg5, arg6, arg7, arg8, arg9);
0AA5: call_function 0x428990 num_params 9 pop 9 [pVehicle] [x] [y] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]
</pre>

#### CCarCtrl::SteerAICarWithPhysics_OnlyMission

<pre>
plugin::Call<0x436A90, CVehicle*, float*, float*, float*, bool*>(pVehicle, arg2, arg3, arg4, arg5);
0AA5: call_function 0x436A90 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAIHeliAsPoliceHeli

<pre>
plugin::Call<0x42AAD0, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42AAD0 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIHeliFlyingAwayFromPlayer

<pre>
plugin::Call<0x42ACB0, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42ACB0 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIHeliToCrashAndBurn

<pre>
plugin::Call<0x4238E0, CAutomobile*>(pAutomobile);
0AA5: call_function 0x4238E0 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIHeliToFollowEntity

<pre>
plugin::Call<0x42A750, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42A750 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIHeliToKeepEntityInView

<pre>
plugin::Call<0x42AEB0, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42AEB0 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIHeliToLand

<pre>
plugin::Call<0x42AD30, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42AD30 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIHeliTowardsTargetCoors

<pre>
plugin::Call<0x42A630, CAutomobile*>(pAutomobile);
0AA5: call_function 0x42A630 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIPlaneToCrashAndBurn

<pre>
plugin::Call<0x423880, CAutomobile*>(pAutomobile);
0AA5: call_function 0x423880 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIPlaneToFollowEntity

<pre>
plugin::Call<0x4237F0, CAutomobile*>(pAutomobile);
0AA5: call_function 0x4237F0 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::SteerAIPlaneTowardsTargetCoors

<pre>
plugin::Call<0x423790, CAutomobile*>(pAutomobile);
0AA5: call_function 0x423790 num_params 1 pop 1 [pAutomobile]
</pre>

#### CCarCtrl::StopCarIfNodesAreInvalid

<pre>
plugin::CallAndReturn<bool, 0x422590, CVehicle*>(pVehicle);
0AA7: call_function_return 0x422590 num_params 1 pop 1 [pVehicle] func_ret [bool]
</pre>

#### CCarCtrl::SwitchBetweenPhysicsAndGhost

<pre>
plugin::Call<0x4222A0, CVehicle*>(pVehicle);
0AA5: call_function 0x4222A0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::SwitchVehicleToRealPhysics

<pre>
plugin::Call<0x423FC0, CVehicle*>(pVehicle);
0AA5: call_function 0x423FC0 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::TestCollisionBetween2MovingRects

<pre>
plugin::CallAndReturn<float, 0x425B30, CVehicle*, CVehicle*, float, float, CVector*, CVector*>(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2);
0AA7: call_function_return 0x425B30 num_params 6 pop 6 [pVehicle1] [pVehicle2] [arg3] [arg4] [pVector1] [pVector2] func_ret [float]
</pre>

#### CCarCtrl::TestCollisionBetween2MovingRects_OnlyFrontBumper

<pre>
plugin::CallAndReturn<float, 0x425F70, CVehicle*, CVehicle*, float, float, CVector*, CVector*>(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2);
0AA7: call_function_return 0x425F70 num_params 6 pop 6 [pVehicle1] [pVehicle2] [arg3] [arg4] [pVector1] [pVector2] func_ret [float]
</pre>

#### CCarCtrl::TestWhetherToFirePlaneGuns

<pre>
plugin::Call<0x429520, CVehicle*, CEntity*>(pVehicle, pTarget);
0AA5: call_function 0x429520 num_params 2 pop 2 [pVehicle] [pTarget]
</pre>

#### CCarCtrl::ThisVehicleShouldTryNotToTurn

<pre>
plugin::CallAndReturn<bool, 0x421FE0, CVehicle*>(pVehicle);
0AA7: call_function_return 0x421FE0 num_params 1 pop 1 [pVehicle] func_ret [bool]
</pre>

#### CCarCtrl::TriggerDogFightMoves

<pre>
plugin::Call<0x429300, CVehicle*, CVehicle*>(pVehicle1, pVehicle2);
0AA5: call_function 0x429300 num_params 2 pop 2 [pVehicle1] [pVehicle2]
</pre>

#### CCarCtrl::UpdateCarCount

<pre>
plugin::Call<0x424000, CVehicle*, unsigned char>(pVehicle, bDecrease);
0AA5: call_function 0x424000 num_params 2 pop 2 [pVehicle] [bDecrease]
</pre>

#### CCarCtrl::UpdateCarOnRails

<pre>
plugin::Call<0x436540, CVehicle*>(pVehicle);
0AA5: call_function 0x436540 num_params 1 pop 1 [pVehicle]
</pre>

#### CCarCtrl::WeaveForObject

<pre>
plugin::Call<0x426BC0, CEntity*, CVehicle*, float*, float*>(pEntity, pVehicle, arg3, arg4);
0AA5: call_function 0x426BC0 num_params 4 pop 4 [pEntity] [pVehicle] [arg3] [arg4]
</pre>

#### CCarCtrl::WeaveForOtherCar

<pre>
plugin::Call<0x426350, CEntity*, CVehicle*, float*, float*>(pEntity, pVehicle, arg3, arg4);
0AA5: call_function 0x426350 num_params 4 pop 4 [pEntity] [pVehicle] [arg3] [arg4]
</pre>

#### CCarCtrl::WeaveThroughCarsSectorList

<pre>
plugin::Call<0x42D680, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9);
0AA5: call_function 0x42D680 num_params 9 pop 9 [PtrList] [pVehicle] [pPhysical] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]
</pre>

#### CCarCtrl::WeaveThroughObjectsSectorList

<pre>
plugin::Call<0x42D950, CPtrList&, CVehicle*, float, float, float, float, float*, float*>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x42D950 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::WeaveThroughPedsSectorList

<pre>
plugin::Call<0x42D7E0, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9);
0AA5: call_function 0x42D7E0 num_params 9 pop 9 [PtrList] [pVehicle] [pPhysical] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]
</pre>

### plugin_sa\game_sa\CCarEnterExit.cpp

#### CCarEnterExit::AddInCarAnim

<pre>
plugin::CallDynGlobal<CVehicle const *, CPed *, bool>(gaddrof(CCarEnterExit::AddInCarAnim), vehicle, ped, bAsDriver);
</pre>

#### CCarEnterExit::CarHasDoorToClose

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasDoorToClose), vehicle, doorId);
</pre>

#### CCarEnterExit::CarHasDoorToOpen

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasDoorToOpen), vehicle, doorID);
</pre>

#### CCarEnterExit::CarHasOpenableDoor

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CPed const *>(gaddrof(CCarEnterExit::CarHasOpenableDoor), vehicle, DoorID_UnusedArg, ped);
</pre>

#### CCarEnterExit::CarHasPartiallyOpenDoor

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasPartiallyOpenDoor), vehicle, doorID);
</pre>

#### CCarEnterExit::ComputeDoorFlag

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle const *, int, bool>(gaddrof(CCarEnterExit::ComputeDoorFlag), vehicle, doorId, bCheckVehicleType);
</pre>

#### CCarEnterExit::ComputeOppositeDoorFlag

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle const *, int, bool>(gaddrof(CCarEnterExit::ComputeOppositeDoorFlag), vehicle, doorId, bCheckVehicleType);
</pre>

#### CCarEnterExit::ComputePassengerIndexFromCarDoor

<pre>
plugin::CallAndReturnDynGlobal<signed int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputePassengerIndexFromCarDoor), vehicle, doorID);
</pre>

#### CCarEnterExit::ComputeSlowJackedPed

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputeSlowJackedPed), vehicle, doorID);
</pre>

#### CCarEnterExit::ComputeTargetDoorToEnterAsPassenger

<pre>
plugin::CallAndReturnDynGlobal<signed int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputeTargetDoorToEnterAsPassenger), pVehicle, nPassengerNum);
</pre>

#### CCarEnterExit::ComputeTargetDoorToExit

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::ComputeTargetDoorToExit), pVehicle, pPed);
</pre>

#### CCarEnterExit::GetNearestCarDoor

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, CVector *, int>(gaddrof(CCarEnterExit::GetNearestCarDoor), pPed, pVehicle, outPos, doorID);
</pre>

#### CCarEnterExit::GetNearestCarPassengerDoor

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, CVector *, int *, bool, bool, bool>(gaddrof(CCarEnterExit::GetNearestCarPassengerDoor), ped, vehicle, outVec, doorId, flag1, flag2, flag3);
</pre>

#### \*CCarEnterExit::GetPositionToOpenCarDoor

<pre>
plugin::CallAndReturnDynGlobal<CVector *, CVector *, CVehicle const *, int>(gaddrof(CCarEnterExit::GetPositionToOpenCarDoor), out, vehicle, doorId);
</pre>

#### CCarEnterExit::IsCarDoorInUse

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, int>(gaddrof(CCarEnterExit::IsCarDoorInUse), vehicle, door1Id, door2Id);
</pre>

#### CCarEnterExit::IsCarDoorReady

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::IsCarDoorReady), vehicle, doorID);
</pre>

#### CCarEnterExit::IsCarQuickJackPossible

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CPed const *>(gaddrof(CCarEnterExit::IsCarQuickJackPossible), vehicle, doorID, ped);
</pre>

#### CCarEnterExit::IsCarSlowJackRequired

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::IsCarSlowJackRequired), vehicle, doorID);
</pre>

#### CCarEnterExit::IsClearToDriveAway

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *>(gaddrof(CCarEnterExit::IsClearToDriveAway), outVehicle);
</pre>

#### CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle *, CVector const *>(gaddrof(CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel), ped, vehicle, pos);
</pre>

#### CCarEnterExit::IsPedHealthy

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CCarEnterExit::IsPedHealthy), vehicle);
</pre>

#### CCarEnterExit::IsPlayerToQuitCarEnter

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, int, CTask *>(gaddrof(CCarEnterExit::IsPlayerToQuitCarEnter), ped, vehicle, StartTime, task);
</pre>

#### CCarEnterExit::IsRoomForPedToLeaveCar

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CVector *>(gaddrof(CCarEnterExit::IsRoomForPedToLeaveCar), veh, doorID, pos);
</pre>

#### CCarEnterExit::IsVehicleHealthy

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *>(gaddrof(CCarEnterExit::IsVehicleHealthy), vehicle);
</pre>

#### CCarEnterExit::IsVehicleStealable

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::IsVehicleStealable), vehicle, ped);
</pre>

#### CCarEnterExit::MakeUndraggedDriverPedLeaveCar

<pre>
plugin::CallDynGlobal<CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::MakeUndraggedDriverPedLeaveCar), vehicle, ped);
</pre>

#### CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar

<pre>
plugin::CallDynGlobal<CVehicle const *, CPed const *, CPed const *>(gaddrof(CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar), targetVehicle, draggedPed, ped);
</pre>

#### CCarEnterExit::QuitEnteringCar

<pre>
plugin::CallDynGlobal<CPed *, CVehicle *, int, bool>(gaddrof(CCarEnterExit::QuitEnteringCar), ped, vehicle, doorID, bCarWasBeingJacked);
</pre>

#### CCarEnterExit::RemoveCarSitAnim

<pre>
plugin::CallDynGlobal<CPed const *>(gaddrof(CCarEnterExit::RemoveCarSitAnim), ped);
</pre>

#### CCarEnterExit::RemoveGetInAnims

<pre>
plugin::CallDynGlobal<CPed const *>(gaddrof(CCarEnterExit::RemoveGetInAnims), ped);
</pre>

#### CCarEnterExit::SetPedInCarDirect

<pre>
plugin::CallDynGlobal<CPed *, CVehicle *, int, bool>(gaddrof(CCarEnterExit::SetPedInCarDirect), ped, vehicle, seatNumber, bAsDriver);
</pre>

### plugin_sa\game_sa\CCarGenerator.cpp

#### CCarGenerator::CheckForBlockage

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *, int>(gaddrof(CCarGenerator::CheckForBlockage), this, modelId);
0AA8: call_method_return 0x6F32E0 struct [CCarGenerator] num_params 1 pop 0 [modelId] func_ret [bool]
</pre>

#### CCarGenerator::CheckIfWithinRangeOfAnyPlayers

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckIfWithinRangeOfAnyPlayers), this);
0AA8: call_method_return 0x6F2F40 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCarGenerator::DoInternalProcessing

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::DoInternalProcessing), this);
0AA6: call_method 0x6F34D0 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::Process

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::Process), this);
0AA6: call_method 0x6F3E90 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::Setup

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short, unsigned char, unsigned char>(gaddrof(CCarGenerator::Setup), this, x, y, z, angle, modelId, color1, color2, bforceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer);
0AA6: call_method 0x6F2E50 struct [CCarGenerator] num_params 14 pop 0 [x] [y] [z] [angle] [modelId] [color1] [color2] [bforceSpawn] [alarm_chances] [doorLock_chances] [minDelay] [maxDelay] [iplId] [bOwnedbyplayer]
</pre>

#### CCarGenerator::SwitchOff

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOff), this);
0AA6: call_method 0x6F2E30 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::SwitchOn

<pre>
plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOn), this);
0AA6: call_method 0x6F32C0 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::CalcNextGen

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CCarGenerator::CalcNextGen));
</pre>

#### \*CCarGenerator::Get

<pre>
plugin::CallAndReturnDynGlobal<CCarGenerator *, unsigned short>(gaddrof(CCarGenerator::Get), index);
</pre>

### plugin_sa\game_sa\CCarPathLink.cpp

#### CCarPathLink::OneWayLaneOffset

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CCarPathLink *>(gaddrof(CCarPathLink::OneWayLaneOffset), this);
0AA8: call_method_return 0x44DB00 struct [CCarPathLink] num_params 0 pop 0 func_ret [float]
</pre>

### plugin_sa\game_sa\CCheat.cpp

#### CCheat::AddToCheatString

<pre>
plugin::CallDynGlobal<char>(gaddrof(CCheat::AddToCheatString), LastPressedKey);
</pre>

#### CCheat::HandleSpecialCheats

<pre>
plugin::CallDynGlobal<int>(gaddrof(CCheat::HandleSpecialCheats), CheatID);
</pre>

#### CCheat::VehicleCheat

<pre>
plugin::CallAndReturnDynGlobal<CVehicle*,int>(gaddrof(CCheat::VehicleCheat), vehicleModelId);
</pre>

#### CCheat::ResetCheats

<pre>
plugin::Call<0x438450>();
0AA5: call_function 0x438450 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CCheckpoint.cpp

#### CCheckpoint::Render

<pre>
plugin::CallMethod<0x725C00, CCheckpoint *>(this);
0AA6: call_method 0x725C00 struct [CCheckpoint] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CCheckpoints.cpp

#### CCheckpoints::DeleteCP

<pre>
plugin::Call<0x722FC0, unsigned int, unsigned short>(id, type);
0AA5: call_function 0x722FC0 num_params 2 pop 2 [id] [type]
</pre>

#### CCheckpoints::Init

<pre>
plugin::Call<0x722880>();
0AA5: call_function 0x722880 num_params 0 pop 0
</pre>

#### CCheckpoints::PlaceMarker

<pre>
plugin::CallAndReturn<CCheckpoint*, 0x722C40, unsigned int, unsigned short, CVector&, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, posn, direction, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);
0AA7: call_function_return 0x722C40 num_params 12 pop 12 [id] [type] [posn] [direction] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] func_ret [CCheckpoint*]
</pre>

#### CCheckpoints::Render

<pre>
plugin::Call<0x726060>();
0AA5: call_function 0x726060 num_params 0 pop 0
</pre>

#### CCheckpoints::SetHeading

<pre>
plugin::Call<0x722970, unsigned int, float>(id, angle);
0AA5: call_function 0x722970 num_params 2 pop 2 [id] [angle]
</pre>

#### CCheckpoints::Shutdown

<pre>
plugin::Call<0x7228F0>();
0AA5: call_function 0x7228F0 num_params 0 pop 0
</pre>

#### CCheckpoints::Update

<pre>
plugin::Call<0x7229C0>();
0AA5: call_function 0x7229C0 num_params 0 pop 0
</pre>

#### CCheckpoints::UpdatePos

<pre>
plugin::Call<0x722900, unsigned int, CVector&>(id, posn);
0AA5: call_function 0x722900 num_params 2 pop 2 [id] [posn]
</pre>

### plugin_sa\game_sa\CClock.cpp

#### CClock::GetGameClockMinutesUntil

<pre>
plugin::CallAndReturnDynGlobal<unsigned short, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);
</pre>

#### CClock::GetIsTimeInRange

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);
</pre>

#### CClock::Initialise

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);
</pre>

#### CClock::OffsetClockByADay

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::OffsetClockByADay), timeDirection);
</pre>

#### CClock::SetGameClock

<pre>
plugin::CallDynGlobal<unsigned char, unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes, day);
</pre>

### plugin_sa\game_sa\CClothes.cpp

#### CClothes::ConstructPedModel

<pre>
plugin::Call<0x5A81E0, unsigned int, CPedClothesDesc&, CPedClothesDesc const*, bool>(modelid, newclothes, oldclothes, bCutscenePlayer);
0AA5: call_function 0x5A81E0 num_params 4 pop 4 [modelid] [newclothes] [oldclothes] [bCutscenePlayer]
</pre>

#### CClothes::RequestMotionGroupAnims

<pre>
plugin::Call<0x5A8120>();
0AA5: call_function 0x5A8120 num_params 0 pop 0
</pre>

#### CClothes::RebuildPlayerIfNeeded

<pre>
plugin::Call<0x5A8390, CPlayerPed*>(player);
0AA5: call_function 0x5A8390 num_params 1 pop 1 [player]
</pre>

#### CClothes::RebuildPlayer

<pre>
plugin::Call<0x5A82C0, CPlayerPed*, bool>(player, bIgnoreFatAndMuscle);
0AA5: call_function 0x5A82C0 num_params 2 pop 2 [player] [bIgnoreFatAndMuscle]
</pre>

#### CClothes::RebuildCutscenePlayer

<pre>
plugin::Call<0x5A8270, CPlayerPed*, int>(player, modelid);
0AA5: call_function 0x5A8270 num_params 2 pop 2 [player] [modelid]
</pre>

#### CClothes::LoadClothesFile

<pre>
plugin::Call<0x5A7B30>();
0AA5: call_function 0x5A7B30 num_params 0 pop 0
</pre>

#### CClothes::Init

<pre>
plugin::Call<0x5A80D0>();
0AA5: call_function 0x5A80D0 num_params 0 pop 0
</pre>

#### CClothes::GetPlayerMotionGroupToLoad

<pre>
plugin::CallAndReturn<int, 0x5A7FB0>();
0AA7: call_function_return 0x5A7FB0 num_params 0 pop 0 func_ret [int]
</pre>

#### CClothes::GetDefaultPlayerMotionGroup

<pre>
plugin::CallAndReturn<int, 0x5A81B0>();
0AA7: call_function_return 0x5A81B0 num_params 0 pop 0 func_ret [int]
</pre>

### plugin_sa\game_sa\CClothesBuilder.cpp

#### CClothesBuilder::BlendTextures

<pre>
plugin::Call<0x5A5BC0, RwTexture*, RwTexture*, RwTexture*, float, float, float, int, RwTexture*>(texture1, texture2, texture3, factorA, factorB, factorC, arg7, texture4);
0AA5: call_function 0x5A5BC0 num_params 8 pop 8 [texture1] [texture2] [texture3] [factorA] [factorB] [factorC] [arg7] [texture4]
</pre>

#### CClothesBuilder::BlendTextures

<pre>
plugin::Call<0x5A59C0, RwTexture*, RwTexture*, RwTexture*, float, float, float>(texture1, texture2, texture3, factorA, factorB, factorC);
0AA5: call_function 0x5A59C0 num_params 6 pop 6 [texture1] [texture2] [texture3] [factorA] [factorB] [factorC]
</pre>

#### CClothesBuilder::BlendTextures

<pre>
plugin::Call<0x5A5820, RwTexture*, RwTexture*, float, float>(texture1, texture2, arg3, arg4);
0AA5: call_function 0x5A5820 num_params 4 pop 4 [texture1] [texture2] [arg3] [arg4]
</pre>

#### CClothesBuilder::BuildBoneIndexConversionTable

<pre>
plugin::Call<0x5A56E0, unsigned char*, RpHAnimHierarchy*, int>(arg1, arg2, arg3);
0AA5: call_function 0x5A56E0 num_params 3 pop 3 [arg1] [arg2] [arg3]
</pre>

#### CClothesBuilder::ConstructGeometryAndSkinArrays

<pre>
plugin::Call<0x5A6530, RpHAnimHierarchy*, RpGeometry**, RwMatrixWeights**, unsigned int**, unsigned int, RpGeometry**, RpMaterial**>(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0AA5: call_function 0x5A6530 num_params 7 pop 7 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]
</pre>

#### CClothesBuilder::ConstructGeometryArray

<pre>
plugin::Call<0x5A55A0, RpGeometry**, unsigned int*, float, float, float>(arg1, arg2, arg3, arg4, arg5);
0AA5: call_function 0x5A55A0 num_params 5 pop 5 [arg1] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CClothesBuilder::ConstructTextures

<pre>
plugin::Call<0x5A6040, RwTexDictionary*, unsigned int*, float, float, float>(dict, hashes, factorA, factorB, factorC);
0AA5: call_function 0x5A6040 num_params 5 pop 5 [dict] [hashes] [factorA] [factorB] [factorC]
</pre>

#### CClothesBuilder::CopyTexture

<pre>
plugin::CallAndReturn<RwTexture*, 0x5A5730, RwTexture*>(texture);
0AA7: call_function_return 0x5A5730 num_params 1 pop 1 [texture] func_ret [RwTexture*]
</pre>

#### CClothesBuilder::CreateSkinnedClump

<pre>
plugin::CallAndReturn<RpClump*, 0x5A69D0, RpClump*, RwTexDictionary*, CPedClothesDesc&, CPedClothesDesc const*, bool>(clump, dict, newclothes, oldclothes, bCutscenePlayer);
0AA7: call_function_return 0x5A69D0 num_params 5 pop 5 [clump] [dict] [newclothes] [oldclothes] [bCutscenePlayer] func_ret [RpClump*]
</pre>

#### CClothesBuilder::DestroySkinArrays

<pre>
plugin::Call<0x5A56C0, RwMatrixWeights*, unsigned int*>(arg1, arg2);
0AA5: call_function 0x5A56C0 num_params 2 pop 2 [arg1] [arg2]
</pre>

#### CClothesBuilder::FindNearestColour

<pre>
plugin::CallAndReturn<int, 0x5A5F40, RwRGBA*>(color);
0AA7: call_function_return 0x5A5F40 num_params 1 pop 1 [color] func_ret [int]
</pre>

#### CClothesBuilder::InitPaletteOctTree

<pre>
plugin::Call<0x5A5EB0, int>(numColors);
0AA5: call_function 0x5A5EB0 num_params 1 pop 1 [numColors]
</pre>

#### CClothesBuilder::LoadCdDirectory

<pre>
plugin::Call<0x5A4190>();
0AA5: call_function 0x5A4190 num_params 0 pop 0
</pre>

#### CClothesBuilder::PlaceTextureOnTopOfTexture

<pre>
plugin::Call<0x5A57B0, RwTexture*, RwTexture*>(texture1, texture2);
0AA5: call_function 0x5A57B0 num_params 2 pop 2 [texture1] [texture2]
</pre>

#### CClothesBuilder::PreprocessClothesDesc

<pre>
plugin::Call<0x5A44C0, CPedClothesDesc&, bool>(arg1, arg2);
0AA5: call_function 0x5A44C0 num_params 2 pop 2 [arg1] [arg2]
</pre>

#### CClothesBuilder::ReducePaletteSize

<pre>
plugin::Call<0x5A6870, RwTexture*, int>(texture, numColorsToReduce);
0AA5: call_function 0x5A6870 num_params 2 pop 2 [texture] [numColorsToReduce]
</pre>

#### CClothesBuilder::ReleaseGeometry

<pre>
plugin::Call<0x5A47B0, int>(numToRelease);
0AA5: call_function 0x5A47B0 num_params 1 pop 1 [numToRelease]
</pre>

#### CClothesBuilder::RequestGeometry

<pre>
plugin::CallMethod<0x5A41C0, CClothesBuilder *, int, unsigned int>(this, modelid, crc);
0AA6: call_method 0x5A41C0 struct [CClothesBuilder] num_params 2 pop 0 [modelid] [crc]
</pre>

#### CClothesBuilder::StoreBoneArray

<pre>
plugin::Call<0x5A48B0, RpClump*, int>(clump, arg2);
0AA5: call_function 0x5A48B0 num_params 2 pop 2 [clump] [arg2]
</pre>

#### CClothesBuilder::BlendGeometry

<pre>
plugin::CallAndReturn<RpGeometry*, 0x5A4940, RpClump*, char const*, char const*, char const*, float, float, float>(clump, arg2, arg3, arg4, arg5, arg6, arg7);
0AA7: call_function_return 0x5A4940 num_params 7 pop 7 [clump] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] func_ret [RpGeometry*]
</pre>

#### CClothesBuilder::BlendGeometry

<pre>
plugin::CallAndReturn<RpGeometry*, 0x5A4F10, RpClump*, char const*, char const*, float, float>(clump, arg2, arg3, arg4, arg5);
0AA7: call_function_return 0x5A4F10 num_params 5 pop 5 [clump] [arg2] [arg3] [arg4] [arg5] func_ret [RpGeometry*]
</pre>

#### CClothesBuilder::CopyGeometry

<pre>
plugin::CallAndReturn<RpGeometry*, 0x5A5340, RpClump*, char const*, char const*>(clump, arg2, arg3);
0AA7: call_function_return 0x5A5340 num_params 3 pop 3 [clump] [arg2] [arg3] func_ret [RpGeometry*]
</pre>

#### CClothesBuilder::ShutdownPaletteOctTree

<pre>
plugin::Call<0x5A5EE0>();
0AA5: call_function 0x5A5EE0 num_params 0 pop 0
</pre>

#### CClothesBuilder::ReducePaletteOctTree

<pre>
plugin::Call<0x5A5EF0, int>(numColorsToReduce);
0AA5: call_function 0x5A5EF0 num_params 1 pop 1 [numColorsToReduce]
</pre>

#### CClothesBuilder::AddColour

<pre>
plugin::CallAndReturn<bool, 0x5A5F00, RwRGBA*>(color);
0AA7: call_function_return 0x5A5F00 num_params 1 pop 1 [color] func_ret [bool]
</pre>

#### CClothesBuilder::FillPalette

<pre>
plugin::Call<0x5A5F30, RwRGBA*>(color);
0AA5: call_function 0x5A5F30 num_params 1 pop 1 [color]
</pre>

### plugin_sa\game_sa\CClouds.cpp

#### CClouds::Shutdown

<pre>
plugin::Call<0x712FA0>();
0AA5: call_function 0x712FA0 num_params 0 pop 0
</pre>

#### CClouds::Update

<pre>
plugin::Call<0x712FF0>();
0AA5: call_function 0x712FF0 num_params 0 pop 0
</pre>

#### CClouds::SetUpOneSkyPoly

<pre>
plugin::Call<0x713060, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char>(vert1pos, vert2pos, vert3pos, vert4pos, topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue);
0AA5: call_function 0x713060 num_params 10 pop 10 [vert1pos] [vert2pos] [vert3pos] [vert4pos] [topRed] [topGreen] [topBlue] [bottomRed] [bottomGreen] [bottomBlue]
</pre>

#### CClouds::VolumetricCloudsInit

<pre>
plugin::Call<0x7131C0>();
0AA5: call_function 0x7131C0 num_params 0 pop 0
</pre>

#### CClouds::VolumetricClouds_GetFirstFreeSlot

<pre>
plugin::CallAndReturn<int, 0x7135C0>();
0AA7: call_function_return 0x7135C0 num_params 0 pop 0 func_ret [int]
</pre>

#### CClouds::VolumetricClouds_Delete

<pre>
plugin::Call<0x7135F0, int>(vcSlotIndex);
0AA5: call_function 0x7135F0 num_params 1 pop 1 [vcSlotIndex]
</pre>

#### CClouds::VolumetricCloudsGetMaxDistance

<pre>
plugin::CallAndReturn<float, 0x713630>();
0AA7: call_function_return 0x713630 num_params 0 pop 0 func_ret [float]
</pre>

#### CClouds::MovingFogInit

<pre>
plugin::Call<0x713660>();
0AA5: call_function 0x713660 num_params 0 pop 0
</pre>

#### CClouds::MovingFog_GetFXIntensity

<pre>
plugin::CallAndReturn<float, 0x7136D0>();
0AA7: call_function_return 0x7136D0 num_params 0 pop 0 func_ret [float]
</pre>

#### CClouds::MovingFog_GetFirstFreeSlot

<pre>
plugin::CallAndReturn<int, 0x713710>();
0AA7: call_function_return 0x713710 num_params 0 pop 0 func_ret [int]
</pre>

#### CClouds::MovingFog_Delete

<pre>
plugin::Call<0x713730, int>(fogSlotIndex);
0AA5: call_function 0x713730 num_params 1 pop 1 [fogSlotIndex]
</pre>

#### CClouds::MovingFog_Create

<pre>
plugin::Call<0x713760, CVector*>(posn);
0AA5: call_function 0x713760 num_params 1 pop 1 [posn]
</pre>

#### CClouds::Init

<pre>
plugin::Call<0x7138D0>();
0AA5: call_function 0x7138D0 num_params 0 pop 0
</pre>

#### CClouds::Render

<pre>
plugin::Call<0x713950>();
0AA5: call_function 0x713950 num_params 0 pop 0
</pre>

#### CClouds::RenderSkyPolys

<pre>
plugin::Call<0x714650>();
0AA5: call_function 0x714650 num_params 0 pop 0
</pre>

#### CClouds::RenderBottomFromHeight

<pre>
plugin::Call<0x7154B0>();
0AA5: call_function 0x7154B0 num_params 0 pop 0
</pre>

#### CClouds::VolumetricClouds_Create

<pre>
plugin::Call<0x715F40, CVector*>(posn);
0AA5: call_function 0x715F40 num_params 1 pop 1 [posn]
</pre>

#### CClouds::VolumetricCloudsRender

<pre>
plugin::Call<0x716380>();
0AA5: call_function 0x716380 num_params 0 pop 0
</pre>

#### CClouds::MovingFog_Update

<pre>
plugin::Call<0x716B10>();
0AA5: call_function 0x716B10 num_params 0 pop 0
</pre>

#### CClouds::MovingFogRender

<pre>
plugin::Call<0x716C90>();
0AA5: call_function 0x716C90 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CClumpModelInfo.cpp

#### CClumpModelInfo::SetFrameIds

<pre>
plugin::CallMethod<0x4C5460, CClumpModelInfo *, RwObjectNameIdAssocation*>(this, data);
0AA6: call_method 0x4C5460 struct [CClumpModelInfo] num_params 1 pop 0 [data]
</pre>

### plugin_sa\game_sa\CColAccel.cpp

#### CColAccel::IsCacheLoading

<pre>
plugin::CallAndReturn<bool, 0x5B2AC0>();
0AA7: call_function_return 0x5B2AC0 num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_sa\game_sa\CColDisk.cpp

#### CColDisk::Set

<pre>
plugin::CallMethod<0x40FD50, CColDisk *, float, CVector const&, CVector const&, float, unsigned char, unsigned char, unsigned char>(this, startRadius, start, end, endRadius, material, pieceType, lighting);
0AA6: call_method 0x40FD50 struct [CColDisk] num_params 7 pop 0 [startRadius] [start] [end] [endRadius] [material] [pieceType] [lighting]
</pre>

### plugin_sa\game_sa\CCollision.cpp

#### CCollision::Update

<pre>
plugin::Call<0x411E20>();
0AA5: call_function 0x411E20 num_params 0 pop 0
</pre>

#### CCollision::SortOutCollisionAfterLoad

<pre>
plugin::Call<0x411E30>();
0AA5: call_function 0x411E30 num_params 0 pop 0
</pre>

#### CCollision::TestSphereSphere

<pre>
plugin::CallAndReturn<bool, 0x411E70, CColSphere const&, CColSphere const&>(sphere1, sphere2);
0AA7: call_function_return 0x411E70 num_params 2 pop 2 [sphere1] [sphere2] func_ret [bool]
</pre>

#### CalculateColPointInsideBox

<pre>
plugin::Call<0x411EC0, CBox const&, CVector const&, CColPoint&>(box, point, colPoint);
0AA5: call_function 0x411EC0 num_params 3 pop 3 [box] [point] [colPoint]
</pre>

#### CCollision::TestSphereBox

<pre>
plugin::CallAndReturn<bool, 0x4120C0, CSphere const&, CBox const&>(sphere, box);
0AA7: call_function_return 0x4120C0 num_params 2 pop 2 [sphere] [box] func_ret [bool]
</pre>

#### CCollision::ProcessSphereBox

<pre>
plugin::CallAndReturn<bool, 0x412130, CColSphere const&, CColBox const&, CColPoint&, float&>(sphere, box, colPoint, maxTouchDistance);
0AA7: call_function_return 0x412130 num_params 4 pop 4 [sphere] [box] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::PointInTriangle

<pre>
plugin::CallAndReturn<bool, 0x412700, CVector const&, CVector const*>(point, triPoints);
0AA7: call_function_return 0x412700 num_params 2 pop 2 [point] [triPoints] func_ret [bool]
</pre>

#### CCollision::DistToLineSqr

<pre>
plugin::CallAndReturn<float, 0x412850, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
0AA7: call_function_return 0x412850 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]
</pre>

#### CCollision::DistToMathematicalLine

<pre>
plugin::CallAndReturn<float, 0x412970, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
0AA7: call_function_return 0x412970 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]
</pre>

#### CCollision::DistToMathematicalLine2D

<pre>
plugin::CallAndReturn<float, 0x412A30, float, float, float, float, float, float>(lineStartX, lineStartY, lineEndX, lineEndY, pointX, pointY);
0AA7: call_function_return 0x412A30 num_params 6 pop 6 [lineStartX] [lineStartY] [lineEndX] [lineEndY] [pointX] [pointY] func_ret [float]
</pre>

#### CCollision::DistAlongLine2D

<pre>
plugin::CallAndReturn<float, 0x412A80, float, float, float, float, float, float>(lineX, lineY, lineDirX, lineDirY, pointX, pointY);
0AA7: call_function_return 0x412A80 num_params 6 pop 6 [lineX] [lineY] [lineDirX] [lineDirY] [pointX] [pointY] func_ret [float]
</pre>

#### CCollision::ProcessLineSphere

<pre>
plugin::CallAndReturn<bool, 0x412AA0, CColLine const&, CColSphere const&, CColPoint&, float&>(line, sphere, colPoint, depth);
0AA7: call_function_return 0x412AA0 num_params 4 pop 4 [line] [sphere] [colPoint] [depth] func_ret [bool]
</pre>

#### CCollision::TestLineBox_DW

<pre>
plugin::CallAndReturn<bool, 0x412C70, CColLine const&, CBox const&>(line, box);
0AA7: call_function_return 0x412C70 num_params 2 pop 2 [line] [box] func_ret [bool]
</pre>

#### CCollision::TestLineBox

<pre>
plugin::CallAndReturn<bool, 0x413070, CColLine const&, CBox const&>(line, box);
0AA7: call_function_return 0x413070 num_params 2 pop 2 [line] [box] func_ret [bool]
</pre>

#### CCollision::TestVerticalLineBox

<pre>
plugin::CallAndReturn<bool, 0x413080, CColLine const&, CBox const&>(line, box);
0AA7: call_function_return 0x413080 num_params 2 pop 2 [line] [box] func_ret [bool]
</pre>

#### CCollision::ProcessLineBox

<pre>
plugin::CallAndReturn<bool, 0x413100, CColLine const&, CColBox const&, CColPoint&, float&>(line, box, colPoint, maxTouchDistance);
0AA7: call_function_return 0x413100 num_params 4 pop 4 [line] [box] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::Test2DLineAgainst2DLine

<pre>
plugin::CallAndReturn<bool, 0x4138D0, float, float, float, float, float, float, float, float>(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY);
0AA7: call_function_return 0x4138D0 num_params 8 pop 8 [line1StartX] [line1StartY] [line1EndX] [line1EndY] [line2StartX] [line2StartY] [line2EndX] [line2EndY] func_ret [bool]
</pre>

#### ProcessDiscCollision

<pre>
plugin::CallAndReturn<bool, 0x413960, CColPoint&, CMatrix const&, CColDisk const&, CColPoint&, bool&, float&, CColPoint&>(colPoint1, mat, disk, colPoint2, arg4, arg5, colPoint3);
0AA7: call_function_return 0x413960 num_params 7 pop 7 [colPoint1] [mat] [disk] [colPoint2] [arg4] [arg5] [colPoint3] func_ret [bool]
</pre>

#### CCollision::TestLineTriangle

<pre>
plugin::CallAndReturn<bool, 0x413AC0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(line, verts, tri, triPlane);
0AA7: call_function_return 0x413AC0 num_params 4 pop 4 [line] [verts] [tri] [triPlane] func_ret [bool]
</pre>

#### CCollision::ProcessLineTriangle

<pre>
plugin::CallAndReturn<bool, 0x4140F0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly*>(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly);
0AA7: call_function_return 0x4140F0 num_params 7 pop 7 [line] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] [collPoly] func_ret [bool]
</pre>

#### CCollision::ProcessVerticalLineTriangle

<pre>
plugin::CallAndReturn<bool, 0x4147E0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly*>(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly);
0AA7: call_function_return 0x4147E0 num_params 7 pop 7 [line] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] [collPoly] func_ret [bool]
</pre>

#### CCollision::IsStoredPolyStillValidVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x414D70, CVector const&, float, CColPoint&, CStoredCollPoly*>(lineOrigin, lineDist, colPoint, collPoly);
0AA7: call_function_return 0x414D70 num_params 4 pop 4 [lineOrigin] [lineDist] [colPoint] [collPoly] func_ret [bool]
</pre>

#### CCollision::GetBoundingBoxFromTwoSpheres

<pre>
plugin::Call<0x415230, CColBox*, CColSphere*, CColSphere*>(bbox, sphere1, sphere2);
0AA5: call_function 0x415230 num_params 3 pop 3 [bbox] [sphere1] [sphere2]
</pre>

#### CCollision::IsThisVehicleSittingOnMe

<pre>
plugin::CallAndReturn<bool, 0x4152C0, CVehicle*, CVehicle*>(vehicle, vehicleOnMe);
0AA7: call_function_return 0x4152C0 num_params 2 pop 2 [vehicle] [vehicleOnMe] func_ret [bool]
</pre>

#### CCollision::CheckCameraCollisionPeds

<pre>
plugin::CallAndReturn<bool, 0x415320, int, int, CVector*, CVector*, float*>(sectorX, sectorY, pos, dir, arg4);
0AA7: call_function_return 0x415320 num_params 5 pop 5 [sectorX] [sectorY] [pos] [dir] [arg4] func_ret [bool]
</pre>

#### CCollision::CheckPeds

<pre>
plugin::CallAndReturn<bool, 0x4154A0, CVector*, CVector*, float*>(pos, dir, arg2);
0AA7: call_function_return 0x4154A0 num_params 3 pop 3 [pos] [dir] [arg2] func_ret [bool]
</pre>

#### ResetMadeInvisibleObjects

<pre>
plugin::Call<0x415540>();
0AA5: call_function 0x415540 num_params 0 pop 0
</pre>

#### CCollision::SphereCastVsBBox

<pre>
plugin::CallAndReturn<bool, 0x415590, CColSphere*, CColSphere*, CColBox*>(sphere1, sphere2, box);
0AA7: call_function_return 0x415590 num_params 3 pop 3 [sphere1] [sphere2] [box] func_ret [bool]
</pre>

#### CCollision::RayPolyPOP

<pre>
plugin::CallAndReturn<bool, 0x415620, CVector*, CVector*, CColTriangle*, CVector*, CVector*>(arg0, arg1, arg2, arg3, arg4);
0AA7: call_function_return 0x415620 num_params 5 pop 5 [arg0] [arg1] [arg2] [arg3] [arg4] func_ret [bool]
</pre>

#### CCollision::GetPrincipleAxis

<pre>
plugin::CallAndReturn<int, 0x4156D0, CVector*>(vec);
0AA7: call_function_return 0x4156D0 num_params 1 pop 1 [vec] func_ret [int]
</pre>

#### CCollision::PointInPoly

<pre>
plugin::CallAndReturn<bool, 0x415730, CVector*, CColTriangle*, CVector*, CVector*>(point, tri, arg2, triVerts);
0AA7: call_function_return 0x415730 num_params 4 pop 4 [point] [tri] [arg2] [triVerts] func_ret [bool]
</pre>

#### CCollision::Closest3

<pre>
plugin::Call<0x415950, CVector*, CVector*>(arg0, arg1);
0AA5: call_function 0x415950 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### ClosestSquaredDistanceBetweenFiniteLines

<pre>
plugin::CallAndReturn<float, 0x415A40, CVector*, CVector*, CVector*, CVector*, float>(line1Start, line1End, line2Start, line2End, arg4);
0AA7: call_function_return 0x415A40 num_params 5 pop 5 [line1Start] [line1End] [line2Start] [line2End] [arg4] func_ret [float]
</pre>

#### CCollision::SphereCastVersusVsPoly

<pre>
plugin::CallAndReturn<bool, 0x415CF0, CColSphere*, CColSphere*, CColTriangle*, CColTrianglePlane*, CompressedVector*>(sphere1, sphere2, tri, triPlane, verts);
0AA7: call_function_return 0x415CF0 num_params 5 pop 5 [sphere1] [sphere2] [tri] [triPlane] [verts] func_ret [bool]
</pre>

#### CCollision::Init

<pre>
plugin::Call<0x416260>();
0AA5: call_function 0x416260 num_params 0 pop 0
</pre>

#### CCollision::Shutdown

<pre>
plugin::Call<0x4162E0>();
0AA5: call_function 0x4162E0 num_params 0 pop 0
</pre>

#### CCollision::CalculateTrianglePlanes

<pre>
plugin::Call<0x416330, CCollisionData*>(colData);
0AA5: call_function 0x416330 num_params 1 pop 1 [colData]
</pre>

#### CCollision::RemoveTrianglePlanes

<pre>
plugin::Call<0x416400, CCollisionData*>(colData);
0AA5: call_function 0x416400 num_params 1 pop 1 [colData]
</pre>

#### CCollision::ProcessSphereSphere

<pre>
plugin::CallAndReturn<bool, 0x416450, CColSphere const&, CColSphere const&, CColPoint&, float&>(sphere1, sphere2, colPoint, maxTouchDistance);
0AA7: call_function_return 0x416450 num_params 4 pop 4 [sphere1] [sphere2] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestSphereTriangle

<pre>
plugin::CallAndReturn<bool, 0x4165B0, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(sphere, verts, tri, triPlane);
0AA7: call_function_return 0x4165B0 num_params 4 pop 4 [sphere] [verts] [tri] [triPlane] func_ret [bool]
</pre>

#### CCollision::ProcessSphereTriangle

<pre>
plugin::CallAndReturn<bool, 0x416BA0, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(sphere, verts, tri, triPlane, colPoint, maxTouchDistance);
0AA7: call_function_return 0x416BA0 num_params 6 pop 6 [sphere] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] func_ret [bool]
</pre>

#### CCollision::TestLineSphere

<pre>
plugin::CallAndReturn<bool, 0x417470, CColLine const&, CColSphere const&>(line, sphere);
0AA7: call_function_return 0x417470 num_params 2 pop 2 [line] [sphere] func_ret [bool]
</pre>

#### CCollision::DistToLine

<pre>
plugin::CallAndReturn<float, 0x417610, CVector const*, CVector const*, CVector const*>(lineStart, lineEnd, point);
0AA7: call_function_return 0x417610 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]
</pre>

#### CCollision::TestLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x417730, CColLine const&, CMatrix const&, CColModel&, bool, bool>(line, transform, colModel, doSeeThroughCheck, doShootThroughCheck);
0AA7: call_function_return 0x417730 num_params 5 pop 5 [line] [transform] [colModel] [doSeeThroughCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CCollision::ProcessLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x417950, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, bool>(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck);
0AA7: call_function_return 0x417950 num_params 7 pop 7 [line] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CCollision::ProcessVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x417BF0, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, bool, CStoredCollPoly*>(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck, collPoly);
0AA7: call_function_return 0x417BF0 num_params 8 pop 8 [line] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] [doShootThroughCheck] [collPoly] func_ret [bool]
</pre>

#### CCollision::SphereCastVsSphere

<pre>
plugin::CallAndReturn<bool, 0x417F20, CColSphere*, CColSphere*, CColSphere*>(arg0, arg1, arg2);
0AA7: call_function_return 0x417F20 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [bool]
</pre>

#### CCollision::ClosestPointOnLine

<pre>
plugin::Call<0x417FD0, CVector*, CVector*, CVector*, CVector*>(arg0, arg1, arg2, arg3);
0AA5: call_function 0x417FD0 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CCollision::ClosestPointsOnPoly

<pre>
plugin::Call<0x418100, CColTriangle*, CVector*, CVector*, CVector*>(arg0, arg1, arg2, arg3);
0AA5: call_function 0x418100 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CCollision::ClosestPointOnPoly

<pre>
plugin::Call<0x418150, CColTriangle*, CVector*, CVector*>(arg0, arg1, arg2);
0AA5: call_function 0x418150 num_params 3 pop 3 [arg0] [arg1] [arg2]
</pre>

#### CCollision::SphereCastVsCaches

<pre>
plugin::CallAndReturn<bool, 0x4181B0, CColSphere*, CVector*, int, CColCacheEntry*, int*, CColCacheEntry*>(sphere, arg1, arg2, arg3, arg4, arg5);
0AA7: call_function_return 0x4181B0 num_params 6 pop 6 [sphere] [arg1] [arg2] [arg3] [arg4] [arg5] func_ret [bool]
</pre>

#### CCollision::CalculateTrianglePlanes

<pre>
plugin::Call<0x418580, CColModel*>(colModel);
0AA5: call_function 0x418580 num_params 1 pop 1 [colModel]
</pre>

#### CCollision::RemoveTrianglePlanes

<pre>
plugin::Call<0x4185A0, CColModel*>(colModel);
0AA5: call_function 0x4185A0 num_params 1 pop 1 [colModel]
</pre>

#### CCollision::ProcessColModels

<pre>
plugin::CallAndReturn<int, 0x4185C0, CMatrix const&, CColModel&, CMatrix const&, CColModel&, CColPoint*, CColPoint*, float*, bool>(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance, arg7);
0AA7: call_function_return 0x4185C0 num_params 8 pop 8 [transform1] [colModel1] [transform2] [colModel2] [colPoint1] [colPoint2] [maxTouchDistance] [arg7] func_ret [int]
</pre>

#### CCollision::SphereCastVsEntity

<pre>
plugin::CallAndReturn<bool, 0x419F00, CColSphere*, CColSphere*, CEntity*>(sphere1, sphere2, entity);
0AA7: call_function_return 0x419F00 num_params 3 pop 3 [sphere1] [sphere2] [entity] func_ret [bool]
</pre>

#### CCollision::SphereVsEntity

<pre>
plugin::CallAndReturn<bool, 0x41A5A0, CColSphere*, CEntity*>(sphere, entity);
0AA7: call_function_return 0x41A5A0 num_params 2 pop 2 [sphere] [entity] func_ret [bool]
</pre>

#### CCollision::CheckCameraCollisionBuildings

<pre>
plugin::CallAndReturn<bool, 0x41A820, int, int, CColBox*, CColSphere*, CColSphere*, CColSphere*>(sectorX, sectorY, arg2, arg3, arg4, arg5);
0AA7: call_function_return 0x41A820 num_params 6 pop 6 [sectorX] [sectorY] [arg2] [arg3] [arg4] [arg5] func_ret [bool]
</pre>

#### CCollision::CheckCameraCollisionVehicles

<pre>
plugin::CallAndReturn<bool, 0x41A990, int, int, CColBox*, CColSphere*, CColSphere*, CColSphere*, CVector*>(sectorX, sectorY, arg2, arg3, arg4, arg5, arg6);
0AA7: call_function_return 0x41A990 num_params 7 pop 7 [sectorX] [sectorY] [arg2] [arg3] [arg4] [arg5] [arg6] func_ret [bool]
</pre>

#### CCollision::CheckCameraCollisionObjects

<pre>
plugin::CallAndReturn<bool, 0x41AB20, int, int, CColBox*, CColSphere*, CColSphere*, CColSphere*>(sectorX, sectorY, arg2, arg3, arg4, arg5);
0AA7: call_function_return 0x41AB20 num_params 6 pop 6 [sectorX] [sectorY] [arg2] [arg3] [arg4] [arg5] func_ret [bool]
</pre>

#### CCollision::BuildCacheOfCameraCollision

<pre>
plugin::CallAndReturn<bool, 0x41AC40, CColSphere*, CColSphere*>(sphere1, sphere2);
0AA7: call_function_return 0x41AC40 num_params 2 pop 2 [sphere1] [sphere2] func_ret [bool]
</pre>

#### CCollision::CameraConeCastVsWorldCollision

<pre>
plugin::CallAndReturn<bool, 0x41B000, CColSphere*, CColSphere*, float*, float>(sphere1, sphere2, arg2, arg3);
0AA7: call_function_return 0x41B000 num_params 4 pop 4 [sphere1] [sphere2] [arg2] [arg3] func_ret [bool]
</pre>

### plugin_sa\game_sa\CCollisionData.cpp

#### CCollisionData::CCollisionData

<pre>
plugin::CallMethod<0x40F030, CCollisionData *>(this);
0AA6: call_method 0x40F030 struct [CCollisionData] num_params 0 pop 0
</pre>

#### CCollisionData::RemoveCollisionVolumes

<pre>
plugin::CallMethod<0x40F070, CCollisionData *>(this);
0AA6: call_method 0x40F070 struct [CCollisionData] num_params 0 pop 0
</pre>

#### CCollisionData::Copy

<pre>
plugin::CallMethod<0x40F120, CCollisionData *, CCollisionData const&>(this, arg0);
0AA6: call_method 0x40F120 struct [CCollisionData] num_params 1 pop 0 [arg0]
</pre>

#### CCollisionData::CalculateTrianglePlanes

<pre>
plugin::CallMethod<0x40F590, CCollisionData *>(this);
0AA6: call_method 0x40F590 struct [CCollisionData] num_params 0 pop 0
</pre>

#### CCollisionData::GetTrianglePoint

<pre>
plugin::CallMethod<0x40F5E0, CCollisionData *, CVector&, int>(this, outVec, vertId);
0AA6: call_method 0x40F5E0 struct [CCollisionData] num_params 2 pop 0 [outVec] [vertId]
</pre>

#### CCollisionData::GetShadTrianglePoint

<pre>
plugin::CallMethod<0x40F640, CCollisionData *, CVector&, int>(this, outVec, vertId);
0AA6: call_method 0x40F640 struct [CCollisionData] num_params 2 pop 0 [outVec] [vertId]
</pre>

#### CCollisionData::RemoveTrianglePlanes

<pre>
plugin::CallMethod<0x40F6A0, CCollisionData *>(this);
0AA6: call_method 0x40F6A0 struct [CCollisionData] num_params 0 pop 0
</pre>

#### CCollisionData::SetLinkPtr

<pre>
plugin::CallMethod<0x40F6C0, CCollisionData *, CLink<CCollisionData*> *>(this, link);
0AA6: call_method 0x40F6C0 struct [CCollisionData] num_params 1 pop 0 [link]
</pre>

#### \*CCollisionData::GetLinkPtr

<pre>
plugin::CallMethodAndReturn<CLink<CCollisionData*> *, 0x40F6E0, CCollisionData *>(this);
0AA8: call_method_return 0x40F6E0 struct [*CCollisionData] num_params 0 pop 0 func_ret [CLink<CCollisionData*> *]
</pre>

### plugin_sa\game_sa\CColModel.cpp

#### CColModel::CColModel

<pre>
plugin::CallMethod<0x40FB60, CColModel *>(this);
0AA6: call_method 0x40FB60 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::~CColModel

<pre>
plugin::CallMethod<0x40F700, CColModel *>(this);
0AA6: call_method 0x40F700 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::MakeMultipleAlloc

<pre>
plugin::CallMethod<0x40F740, CColModel *>(this);
0AA6: call_method 0x40F740 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::operator=

<pre>
plugin::CallMethodAndReturn<CColModel&, 0x40F7C0, CColModel *, CColModel const&>(this, colModel);
0AA8: call_method_return 0x40F7C0 struct [CColModel] num_params 1 pop 0 [colModel] func_ret [CColModel&]
</pre>

#### CColModel::AllocateData

<pre>
plugin::CallMethod<0x40F810, CColModel *>(this);
0AA6: call_method 0x40F810 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::AllocateData

<pre>
plugin::CallMethod<0x40F870, CColModel *, int, int, int, int, int, bool>(this, numSpheres, numBoxes, numLines, numVertices, numTriangles, disks);
0AA6: call_method 0x40F870 struct [CColModel] num_params 6 pop 0 [numSpheres] [numBoxes] [numLines] [numVertices] [numTriangles] [disks]
</pre>

#### CColModel::AllocateData

<pre>
plugin::CallMethod<0x40F9B0, CColModel *, int>(this, size);
0AA6: call_method 0x40F9B0 struct [CColModel] num_params 1 pop 0 [size]
</pre>

#### CColModel::RemoveCollisionVolumes

<pre>
plugin::CallMethod<0x40F9E0, CColModel *>(this);
0AA6: call_method 0x40F9E0 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::CalculateTrianglePlanes

<pre>
plugin::CallMethod<0x40FA30, CColModel *>(this);
0AA6: call_method 0x40FA30 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::RemoveTrianglePlanes

<pre>
plugin::CallMethod<0x40FA40, CColModel *>(this);
0AA6: call_method 0x40FA40 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::operator new

<pre>
plugin::CallAndReturn<void*, 0x40FC30, unsigned int>(size);
0AA7: call_function_return 0x40FC30 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CColModel::operator delete

<pre>
plugin::Call<0x40FC40, void*>(data);
0AA5: call_function 0x40FC40 num_params 1 pop 1 [data]
</pre>

### plugin_sa\game_sa\CColourSet.cpp

#### CColourSet::CColourSet

<pre>
plugin::CallMethod<0x55F4B0, CColourSet *, int, int>(this, weatherId, timeId);
0AA6: call_method 0x55F4B0 struct [CColourSet] num_params 2 pop 0 [weatherId] [timeId]
</pre>

#### CColourSet::Interpolate

<pre>
plugin::CallMethod<0x55F870, CColourSet *, CColourSet*, CColourSet*, float, float, bool>(this, a, b, factor_a, factor_b, bIgnoreSky);
0AA6: call_method 0x55F870 struct [CColourSet] num_params 5 pop 0 [a] [b] [factor_a] [factor_b] [bIgnoreSky]
</pre>

### plugin_sa\game_sa\CControllerConfigManager.cpp

#### CControllerConfigManager::GetIsKeyboardKeyDown

<pre>
plugin::CallMethodAndReturn<bool, 0x52DDB0, CControllerConfigManager *, RsKeyCodes>(this, key);
0AA8: call_method_return 0x52DDB0 struct [CControllerConfigManager] num_params 1 pop 0 [key] func_ret [bool]
</pre>

#### CControllerConfigManager::GetIsKeyboardKeyJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x52E450, CControllerConfigManager *, RsKeyCodes>(this, key);
0AA8: call_method_return 0x52E450 struct [CControllerConfigManager] num_params 1 pop 0 [key] func_ret [bool]
</pre>

#### CControllerConfigManager::ResetSettingOrder

<pre>
plugin::CallMethod<0x52F5F0, CControllerConfigManager*, e_ControllerAction>(this, action);
0AA6: call_method 0x52F5F0 struct [CControllerConfigManager] num_params 1 pop 0 [action]
</pre>

### plugin_sa\game_sa\CCover.cpp

#### CCover::AddCoverPoint

<pre>
plugin::CallDynGlobal<int, CEntity *, CVector *, char, unsigned char>(gaddrof(CCover::AddCoverPoint), maxPeds, coverEntity, position, coverType, direction);
</pre>

#### CCover::CalculateHorizontalSize

<pre>
plugin::CallAndReturnDynGlobal<float, CColTriangle *, CVector *>(gaddrof(CCover::CalculateHorizontalSize), triangle, vertPositions);
</pre>

#### CCover::DoLineCheckWithinObject

<pre>
plugin::CallAndReturnDynGlobal<char, CColTriangle *, int, CVector *, CVector *, CVector, CVector>(gaddrof(CCover::DoLineCheckWithinObject), triangle, a2, a3, a4, a5, a6);
</pre>

#### CCover::DoesCoverPointStillProvideCover

<pre>
plugin::CallAndReturnDynGlobal<bool, CCoverPoint *, CVector>(gaddrof(CCover::DoesCoverPointStillProvideCover), point, position);
</pre>

#### CCover::Find2HighestPoints

<pre>
plugin::CallDynGlobal<CColTriangle *, CVector *, int &, int &>(gaddrof(CCover::Find2HighestPoints), triangle, vertPositions, outPoint1, outPoint2);
</pre>

#### \*CCover::FindAndReserveCoverPoint

<pre>
plugin::CallAndReturnDynGlobal<CCoverPoint *, CPed *, CVector &, bool>(gaddrof(CCover::FindAndReserveCoverPoint), ped, position, a3);
</pre>

#### CCover::FindCoordinatesCoverPoint

<pre>
plugin::CallAndReturnDynGlobal<bool, CCoverPoint *, CPed *, CVector &, CVector &>(gaddrof(CCover::FindCoordinatesCoverPoint), point, ped, position, outCoordinates);
</pre>

#### CCover::FindCoverPointsForThisBuilding

<pre>
plugin::CallDynGlobal<CBuilding *>(gaddrof(CCover::FindCoverPointsForThisBuilding), building);
</pre>

#### CCover::FindDirFromVector

<pre>
plugin::CallAndReturnDynGlobal<unsigned char, float, float>(gaddrof(CCover::FindDirFromVector), x, y);
</pre>

#### CCover::RemoveCoverPointIfEntityLost

<pre>
plugin::CallDynGlobal<CCoverPoint *>(gaddrof(CCover::RemoveCoverPointIfEntityLost), point);
</pre>

#### CCover::RemoveCoverPointsForThisEntity

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CCover::RemoveCoverPointsForThisEntity), entity);
</pre>

#### CCover::ShouldThisBuildingHaveItsCoverPointsCreated

<pre>
plugin::CallAndReturnDynGlobal<bool, CBuilding *>(gaddrof(CCover::ShouldThisBuildingHaveItsCoverPointsCreated), building);
</pre>

### plugin_sa\game_sa\CCoverPoint.cpp

#### CCoverPoint::CanAccomodateAnotherPed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCoverPoint *>(gaddrof(CCoverPoint::CanAccomodateAnotherPed), this);
0AA8: call_method_return 0x698E70 struct [CCoverPoint] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCoverPoint::ReleaseCoverPointForPed

<pre>
plugin::CallMethodDynGlobal<CCoverPoint *, CPed *>(gaddrof(CCoverPoint::ReleaseCoverPointForPed), this, ped);
0AA6: call_method 0x698EF0 struct [CCoverPoint] num_params 1 pop 0 [ped]
</pre>

#### CCoverPoint::ReserveCoverPointForPed

<pre>
plugin::CallMethodDynGlobal<CCoverPoint *, CPed *>(gaddrof(CCoverPoint::ReserveCoverPointForPed), this, ped);
0AA6: call_method 0x698EB0 struct [CCoverPoint] num_params 1 pop 0 [ped]
</pre>

### plugin_sa\game_sa\CCredits.cpp

#### CCredits::Render

<pre>
plugin::Call<0x53D5B0>();
0AA5: call_function 0x53D5B0 num_params 0 pop 0
</pre>

#### CCredits::PrintCreditText

<pre>
plugin::Call<0x5A8660, float, float, unsigned short*, unsigned int&, float, bool>(scaleX, scaleY, text, position, currentOffset, highlighted);
0AA5: call_function 0x5A8660 num_params 6 pop 6 [scaleX] [scaleY] [text] [position] [currentOffset] [highlighted]
</pre>

#### CCredits::PrintCreditSpace

<pre>
plugin::Call<0x5A87C0, float, unsigned int&>(spaceSize, position);
0AA5: call_function 0x5A87C0 num_params 2 pop 2 [spaceSize] [position]
</pre>

#### CCredits::RenderCredits

<pre>
plugin::Call<0x5A87F0>();
0AA5: call_function 0x5A87F0 num_params 0 pop 0
</pre>

#### CCredits::Start

<pre>
plugin::Call<0x7170E0>();
0AA5: call_function 0x7170E0 num_params 0 pop 0
</pre>

#### CCredits::Stop

<pre>
plugin::Call<0x717100>();
0AA5: call_function 0x717100 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CCullZones.cpp

#### CZoneDef::IsPointWithin

<pre>
plugin::CallMethodAndReturn<bool, 0x72D850>(this, point);
0AA8: call_method_return 0x72D850 struct [CZoneDef] num_params 1 pop 0 [point] func_ret [bool]
</pre>

#### CCullZones::Init

<pre>
plugin::Call<0x72D6B0>();
0AA5: call_function 0x72D6B0 num_params 0 pop 0
</pre>

#### CCullZones::Update

<pre>
plugin::Call<0x72DEC0>();
0AA5: call_function 0x72DEC0 num_params 0 pop 0
</pre>

#### CCullZones::AddCullZone

<pre>
plugin::Call<0x72DF70>();
0AA5: call_function 0x72DF70 num_params 0 pop 0
</pre>

#### CCullZones::AddTunnelAttributeZone

<pre>
plugin::Call<0x72DB50>();
0AA5: call_function 0x72DB50 num_params 0 pop 0
</pre>

#### CCullZones::AddMirrorAttributeZone

<pre>
plugin::Call<0x72DC10>();
0AA5: call_function 0x72DC10 num_params 0 pop 0
</pre>

#### CCullZones::InRoomForAudio

<pre>
plugin::CallAndReturn<bool, 0x72DD70>();
0AA7: call_function_return 0x72DD70 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::FewerCars

<pre>
plugin::CallAndReturn<bool, 0x72DD80>();
0AA7: call_function_return 0x72DD80 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::CamNoRain

<pre>
plugin::CallAndReturn<bool, 0x72DDB0>();
0AA7: call_function_return 0x72DDB0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::PlayerNoRain

<pre>
plugin::CallAndReturn<bool, 0x72DDC0>();
0AA7: call_function_return 0x72DDC0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::FewerPeds

<pre>
plugin::CallAndReturn<bool, 0x72DD90>();
0AA7: call_function_return 0x72DD90 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::NoPolice

<pre>
plugin::CallAndReturn<bool, 0x72DD50>();
0AA7: call_function_return 0x72DD50 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::DoExtraAirResistanceForPlayer

<pre>
plugin::CallAndReturn<bool, 0x72DDD0>();
0AA7: call_function_return 0x72DDD0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCullZones::FindTunnelAttributesForCoors

<pre>
plugin::CallAndReturn<eZoneAttributes, 0x72D9F0>(point);
0AA7: call_function_return 0x72D9F0 num_params 1 pop 1 [point] func_ret [eZoneAttributes]
</pre>

#### CCullZones::FindMirrorAttributesForCoors

<pre>
plugin::CallAndReturn<CCullZoneReflection*, 0x72DA70>(cameraPosition);
0AA7: call_function_return 0x72DA70 num_params 1 pop 1 [cameraPosition] func_ret [CCullZoneReflection*]
</pre>

#### CCullZones::FindZoneWithStairsAttributeForPlayer

<pre>
plugin::CallAndReturn<CCullZone*, 0x72DAD0>();
0AA7: call_function_return 0x72DAD0 num_params 0 pop 0 func_ret [CCullZone*]
</pre>

#### CCullZones::FindAttributesForCoors

<pre>
plugin::CallAndReturn<eZoneAttributes, 0x72D970>(pos);
0AA7: call_function_return 0x72D970 num_params 1 pop 1 [pos] func_ret [eZoneAttributes]
</pre>

### plugin_sa\game_sa\CCustomCarEnvMapPipeline.cpp

#### CCustomCarEnvMapPipeline::CustomPipeInstanceCB

<pre>
plugin::CallAndReturn<int,0x5D8490, int, int, int(__cdecl *)(int, int, int)>(arg1, arg2, callback);
0AA7: call_function_return 0x5D8490 num_params 3 pop 3 [arg1] [arg2] [callback] func_ret [int]
</pre>

#### CCustomCarEnvMapPipeline::PreRenderUpdate

<pre>
plugin::Call<0x5D8870>();
0AA5: call_function 0x5D8870 num_params 0 pop 0
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvMatConstructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D8BD0, void*, int>(object, offset);
0AA7: call_function_return 0x5D8BD0 num_params 2 pop 2 [object] [offset] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvMatStreamWriteCB

<pre>
plugin::CallAndReturn<RwStream*, 0x5D8CD0, RwStream*, int, void const*, int>(stream, length, arg3, arg4);
0AA7: call_function_return 0x5D8CD0 num_params 4 pop 4 [stream] [length] [arg3] [arg4] func_ret [RwStream*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvMatStreamGetSizeCB

<pre>
plugin::CallAndReturn<int, 0x5D8D10, void const*>(arg0);
0AA7: call_function_return 0x5D8D10 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvAtmConstructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D8D30, void*, int>(object, offset);
0AA7: call_function_return 0x5D8D30 num_params 2 pop 2 [object] [offset] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginSpecMatConstructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D8D40, void*>(object);
0AA7: call_function_return 0x5D8D40 num_params 1 pop 1 [object] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginSpecMatStreamWriteCB

<pre>
plugin::CallAndReturn<RwStream*, 0x5D8D60, RwStream*, int, void const*>(stream, length, object);
0AA7: call_function_return 0x5D8D60 num_params 3 pop 3 [stream] [length] [object] func_ret [RwStream*]
</pre>

#### CCustomCarEnvMapPipeline::pluginSpecMatStreamGetSizeCB

<pre>
plugin::CallAndReturn<signed int, 0x5D8DD0>();
0AA7: call_function_return 0x5D8DD0 num_params 0 pop 0 func_ret [signed int]
</pre>

#### CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData

<pre>
plugin::CallAndReturn<CustomEnvMapPipeMaterialData*, 0x5D9570, CustomEnvMapPipeMaterialData**>(arg0);
0AA7: call_function_return 0x5D9570 num_params 1 pop 1 [arg0] func_ret [CustomEnvMapPipeMaterialData*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvMatDestructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D95B0, void*, int>(object, offset);
0AA7: call_function_return 0x5D95B0 num_params 2 pop 2 [object] [offset] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvMatCopyConstructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D9600, void*, void const*, int, int>(object_dst, object_src, offset, size);
0AA7: call_function_return 0x5D9600 num_params 4 pop 4 [object_dst] [object_src] [offset] [size] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvMatStreamReadCB

<pre>
plugin::CallAndReturn<RwStream*, 0x5D9660, RwStream*, int, void*, int>(stream, length, object, offset);
0AA7: call_function_return 0x5D9660 num_params 4 pop 4 [stream] [length] [object] [offset] func_ret [RwStream*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvAtmDestructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D9730, void*, int>(object, offset);
0AA7: call_function_return 0x5D9730 num_params 2 pop 2 [object] [offset] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginEnvAtmCopyConstructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D9780, void*, void const*, int, int>(object_dst, object_src, offset, size);
0AA7: call_function_return 0x5D9780 num_params 4 pop 4 [object_dst] [object_src] [offset] [size] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginSpecMatDestructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D97D0, void*>(object);
0AA7: call_function_return 0x5D97D0 num_params 1 pop 1 [object] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginSpecMatCopyConstructorCB

<pre>
plugin::CallAndReturn<void*, 0x5D9830, void*, void const*>(object_dst, object_src);
0AA7: call_function_return 0x5D9830 num_params 2 pop 2 [object_dst] [object_src] func_ret [void*]
</pre>

#### CCustomCarEnvMapPipeline::pluginSpecMatStreamReadCB

<pre>
plugin::CallAndReturn<RwStream*, 0x5D9880, RwStream*, int, void*>(stream, length, object);
0AA7: call_function_return 0x5D9880 num_params 3 pop 3 [stream] [length] [object] func_ret [RwStream*]
</pre>

#### CCustomCarEnvMapPipeline::CustomPipeRenderCB

<pre>
plugin::CallAndReturn<int, 0x5D9900, RwResEntry*, void*, unsigned char, unsigned int>(atomic, object, flags1, flags2);
0AA7: call_function_return 0x5D9900 num_params 4 pop 4 [atomic] [object] [flags1] [flags2] func_ret [int]
</pre>

#### CCustomCarEnvMapPipeline::CreateCustomOpenGLObjPipe

<pre>
plugin::CallAndReturn<RxPipeline*, 0x5D9F80>();
0AA7: call_function_return 0x5D9F80 num_params 0 pop 0 func_ret [RxPipeline*]
</pre>

#### CCustomCarEnvMapPipeline::CreatePipe

<pre>
plugin::CallAndReturn<char, 0x5DA020>();
0AA7: call_function_return 0x5DA020 num_params 0 pop 0 func_ret [char]
</pre>

#### CCustomCarEnvMapPipeline::DestroyPipe

<pre>
plugin::Call<0x5DA130>();
0AA5: call_function 0x5DA130 num_params 0 pop 0
</pre>

#### CCustomCarEnvMapPipeline::SetFxEnvTexture

<pre>
plugin::Call<0x5DA230, RpMaterial*, RwTexture*>(material, texture);
0AA5: call_function 0x5DA230 num_params 2 pop 2 [material] [texture]
</pre>

#### CCustomCarEnvMapPipeline::RegisterPlugin

<pre>
plugin::CallAndReturn<char, 0x5DA450>();
0AA7: call_function_return 0x5DA450 num_params 0 pop 0 func_ret [char]
</pre>

#### CCustomCarEnvMapPipeline::CustomPipeMaterialSetup

<pre>
plugin::CallAndReturn<RpMaterial*, 0x5DA560, RpMaterial*, void*>(arg0, arg1);
0AA7: call_function_return 0x5DA560 num_params 2 pop 2 [arg0] [arg1] func_ret [RpMaterial*]
</pre>

#### CCustomCarEnvMapPipeline::CustomPipeAtomicSetup

<pre>
plugin::CallAndReturn<RpAtomic*, 0x5DA610, RpAtomic*>(arg0);
0AA7: call_function_return 0x5DA610 num_params 1 pop 1 [arg0] func_ret [RpAtomic*]
</pre>

### plugin_sa\game_sa\CCustomCarPlateMgr.cpp

#### CCustomCarPlateMgr::Initialise

<pre>
plugin::CallAndReturn<bool, 0x6FD500>();
0AA7: call_function_return 0x6FD500 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCustomCarPlateMgr::GeneratePlateText

<pre>
plugin::CallAndReturn<bool, 0x6FD5B0, char*, int>(plateTextBuf, length);
0AA7: call_function_return 0x6FD5B0 num_params 2 pop 2 [plateTextBuf] [length] func_ret [bool]
</pre>

#### CCustomCarPlateMgr::Shutdown

<pre>
plugin::CallAndReturn<bool, 0x6FD720>();
0AA7: call_function_return 0x6FD720 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCustomCarPlateMgr::GetMapRegionPlateDesign

<pre>
plugin::CallAndReturn<unsigned char, 0x6FD7A0>();
0AA7: call_function_return 0x6FD7A0 num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### CCustomCarPlateMgr::LoadPlatecharsetDat

<pre>
plugin::CallAndReturn<bool, 0x6FDC00, char const*, unsigned char*, int, int>(filename, data, arg2, arg3);
0AA7: call_function_return 0x6FDC00 num_params 4 pop 4 [filename] [data] [arg2] [arg3] func_ret [bool]
</pre>

#### RenderLicenseplateTextToRaster

<pre>
plugin::CallAndReturn<bool, 0x6FDD70, char*, RwRaster*, void*, RwRaster*>(text, charsetRaster, palette, resultRaster);
0AA7: call_function_return 0x6FDD70 num_params 4 pop 4 [text] [charsetRaster] [palette] [resultRaster] func_ret [bool]
</pre>

#### CCustomCarPlateMgr::SetupMaterialPlatebackTexture

<pre>
plugin::CallAndReturn<RpMaterial*, 0x6FDE50, RpMaterial*, unsigned char>(material, plateType);
0AA7: call_function_return 0x6FDE50 num_params 2 pop 2 [material] [plateType] func_ret [RpMaterial*]
</pre>

#### CCustomCarPlateMgr::CreatePlateTexture

<pre>
plugin::CallAndReturn<RwTexture*, 0x6FDEA0, char*, unsigned char>(text, plateType);
0AA7: call_function_return 0x6FDEA0 num_params 2 pop 2 [text] [plateType] func_ret [RwTexture*]
</pre>

#### MaterialUpgradeSetCarplateTextureCB

<pre>
plugin::CallAndReturn<RpMaterial*, 0x6FDF50, RpMaterial*, void*>(material, data);
0AA7: call_function_return 0x6FDF50 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]
</pre>

#### AtomicUpgradeSetCarplateTextureCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x6FDFC0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x6FDFC0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CCustomCarPlateMgr::SetupClumpAfterVehicleUpgrade

<pre>
plugin::CallAndReturn<bool, 0x6FDFE0, RpClump*, RpMaterial*, unsigned char>(clump, plateMaterial, plateType);
0AA7: call_function_return 0x6FDFE0 num_params 3 pop 3 [clump] [plateMaterial] [plateType] func_ret [bool]
</pre>

#### CCustomCarPlateMgr::SetupMaterialPlateTexture

<pre>
plugin::CallAndReturn<RpMaterial*, 0x6FE020, RpMaterial*, char*, unsigned char>(material, plateText, plateType);
0AA7: call_function_return 0x6FE020 num_params 3 pop 3 [material] [plateText] [plateType] func_ret [RpMaterial*]
</pre>

#### MaterialSetCarplateTextureCB

<pre>
plugin::CallAndReturn<RpMaterial*, 0x6FE060, RpMaterial*, void*>(material, data);
0AA7: call_function_return 0x6FE060 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]
</pre>

#### AtomicSetCarplateTextureCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x6FE0D0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x6FE0D0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CCustomCarPlateMgr::SetupClump

<pre>
plugin::CallAndReturn<RpMaterial*, 0x6FE0F0, RpClump*, char*, unsigned char>(clump, plateText, plateType);
0AA7: call_function_return 0x6FE0F0 num_params 3 pop 3 [clump] [plateText] [plateType] func_ret [RpMaterial*]
</pre>

### plugin_sa\game_sa\CCutsceneMgr.cpp

#### CCutsceneMgr::AddCutsceneHead

<pre>
plugin::CallAndReturn<int, 0x5B0380, CObject*, int>(object, arg1);
0AA7: call_function_return 0x5B0380 num_params 2 pop 2 [object] [arg1] func_ret [int]
</pre>

#### CCutsceneMgr::AppendToNextCutscene

<pre>
plugin::Call<0x4D5DB0, char const*, char const*>(objectName, animName);
0AA5: call_function 0x4D5DB0 num_params 2 pop 2 [objectName] [animName]
</pre>

#### CCutsceneMgr::AttachObjectToBone

<pre>
plugin::Call<0x5B0450, CObject*, CObject*, int>(attachment, object, boneId);
0AA5: call_function 0x5B0450 num_params 3 pop 3 [attachment] [object] [boneId]
</pre>

#### CCutsceneMgr::AttachObjectToFrame

<pre>
plugin::Call<0x5B0480, CObject*, CEntity*, char const*>(attachment, object, frameName);
0AA5: call_function 0x5B0480 num_params 3 pop 3 [attachment] [object] [frameName]
</pre>

#### CCutsceneMgr::AttachObjectToParent

<pre>
plugin::Call<0x5B04B0, CObject*, CEntity*>(attachment, object);
0AA5: call_function 0x5B04B0 num_params 2 pop 2 [attachment] [object]
</pre>

#### CCutsceneMgr::BuildCutscenePlayer

<pre>
plugin::Call<0x4D5E20>();
0AA5: call_function 0x4D5E20 num_params 0 pop 0
</pre>

#### CCutsceneMgr::CreateCutsceneObject

<pre>
plugin::CallAndReturn<CCutsceneObject*, 0x5B02A0, int>(modelId);
0AA7: call_function_return 0x5B02A0 num_params 1 pop 1 [modelId] func_ret [CCutsceneObject*]
</pre>

#### CCutsceneMgr::DeleteCutsceneData

<pre>
plugin::Call<0x4D5ED0>();
0AA5: call_function 0x4D5ED0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::DeleteCutsceneData_overlay

<pre>
plugin::Call<0x5AFD60>();
0AA5: call_function 0x5AFD60 num_params 0 pop 0
</pre>

#### CCutsceneMgr::FinishCutscene

<pre>
plugin::Call<0x5B04D0>();
0AA5: call_function 0x5B04D0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::GetCutsceneTimeInMilleseconds

<pre>
plugin::CallAndReturn<long long, 0x5B0550>();
0AA7: call_function_return 0x5B0550 num_params 0 pop 0 func_ret [long long]
</pre>

#### CCutsceneMgr::HasCutsceneFinished

<pre>
plugin::CallAndReturn<bool, 0x5B0570>();
0AA7: call_function_return 0x5B0570 num_params 0 pop 0 func_ret [bool]
</pre>

#### CCutsceneMgr::HideRequestedObjects

<pre>
plugin::Call<0x5AFAD0>();
0AA5: call_function 0x5AFAD0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::Initialise

<pre>
plugin::Call<0x4D5A20>();
0AA5: call_function 0x4D5A20 num_params 0 pop 0
</pre>

#### CCutsceneMgr::IsCutsceneSkipButtonBeingPressed

<pre>
plugin::Call<0x4D5D10>();
0AA5: call_function 0x4D5D10 num_params 0 pop 0
</pre>

#### CCutsceneMgr::LoadAnimationUncompressed

<pre>
plugin::Call<0x4D5AB0, char const*>(animName);
0AA5: call_function 0x4D5AB0 num_params 1 pop 1 [animName]
</pre>

#### CCutsceneMgr::LoadCutsceneData

<pre>
plugin::Call<0x4D5E80, char const*>(cutsceneName);
0AA5: call_function 0x4D5E80 num_params 1 pop 1 [cutsceneName]
</pre>

#### CCutsceneMgr::LoadCutsceneData_loading

<pre>
plugin::Call<0x5B11C0>();
0AA5: call_function 0x5B11C0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::LoadCutsceneData_overlay

<pre>
plugin::Call<0x5B13F0, char const*>(cutsceneName);
0AA5: call_function 0x5B13F0 num_params 1 pop 1 [cutsceneName]
</pre>

#### CCutsceneMgr::LoadCutsceneData_postload

<pre>
plugin::Call<0x5AFBC0>();
0AA5: call_function 0x5AFBC0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::LoadCutsceneData_preload

<pre>
plugin::Call<0x5B05A0>();
0AA5: call_function 0x5B05A0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::LoadEverythingBecauseCutsceneDeletedAllOfIt

<pre>
plugin::Call<0x4D5C10>();
0AA5: call_function 0x4D5C10 num_params 0 pop 0
</pre>

#### CCutsceneMgr::RemoveCutscenePlayer

<pre>
plugin::Call<0x4D5E50>();
0AA5: call_function 0x4D5E50 num_params 0 pop 0
</pre>

#### CCutsceneMgr::RemoveEverythingBecauseCutsceneDoesntFitInMemory

<pre>
plugin::Call<0x4D5AF0>();
0AA5: call_function 0x4D5AF0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::SetCutsceneAnim

<pre>
plugin::Call<0x5B0390, char const*, CObject*>(animName, object);
0AA5: call_function 0x5B0390 num_params 2 pop 2 [animName] [object]
</pre>

#### CCutsceneMgr::SetCutsceneAnimToLoop

<pre>
plugin::Call<0x5B0420, char const*>(animName);
0AA5: call_function 0x5B0420 num_params 1 pop 1 [animName]
</pre>

#### CCutsceneMgr::SetHeadAnim

<pre>
plugin::Call<0x5B0440, char const*, CObject*>(animName, headObject);
0AA5: call_function 0x5B0440 num_params 2 pop 2 [animName] [headObject]
</pre>

#### CCutsceneMgr::SetupCutsceneToStart

<pre>
plugin::Call<0x5B14D0>();
0AA5: call_function 0x5B14D0 num_params 0 pop 0
</pre>

#### CCutsceneMgr::Shutdown

<pre>
plugin::Call<0x4D5E60>();
0AA5: call_function 0x4D5E60 num_params 0 pop 0
</pre>

#### CCutsceneMgr::SkipCutscene

<pre>
plugin::Call<0x5B1700>();
0AA5: call_function 0x5B1700 num_params 0 pop 0
</pre>

#### CCutsceneMgr::StartCutscene

<pre>
plugin::Call<0x5B1460>();
0AA5: call_function 0x5B1460 num_params 0 pop 0
</pre>

#### CCutsceneMgr::Update

<pre>
plugin::Call<0x4D5D00>();
0AA5: call_function 0x4D5D00 num_params 0 pop 0
</pre>

#### CCutsceneMgr::Update_overlay

<pre>
plugin::Call<0x5B1720>();
0AA5: call_function 0x5B1720 num_params 0 pop 0
</pre>

#### FindCutsceneAudioTrackId

<pre>
plugin::CallAndReturn<short, 0x5AFA50, char const*>(cutsceneName);
0AA7: call_function_return 0x5AFA50 num_params 1 pop 1 [cutsceneName] func_ret [short]
</pre>

#### UpdateCutsceneObjectBoundingBox

<pre>
plugin::Call<0x5B01E0, RpClump*, int>(clump, modelId);
0AA5: call_function 0x5B01E0 num_params 2 pop 2 [clump] [modelId]
</pre>

### plugin_sa\game_sa\CDarkel.cpp

#### CDarkel::Init

<pre>
plugin::Call<0x43CEB0>();
0AA5: call_function 0x43CEB0 num_params 0 pop 0
</pre>

#### CDarkel::DrawMessages

<pre>
plugin::Call<0x43CEC0>();
0AA5: call_function 0x43CEC0 num_params 0 pop 0
</pre>

#### CDarkel::ReadStatus

<pre>
plugin::CallAndReturn<short, 0x43D1E0>();
0AA7: call_function_return 0x43D1E0 num_params 0 pop 0 func_ret [short]
</pre>

#### CDarkel::RegisterKillNotByPlayer

<pre>
plugin::Call<0x43D210, CPed const*>(pKilledPed);
0AA5: call_function 0x43D210 num_params 1 pop 1 [pKilledPed]
</pre>

#### CDarkel::ThisPedShouldBeKilledForFrenzy

<pre>
plugin::CallAndReturn<bool, 0x43D2F0, CPed const*>(pPed);
0AA7: call_function_return 0x43D2F0 num_params 1 pop 1 [pPed] func_ret [bool]
</pre>

#### CDarkel::ThisVehicleShouldBeKilledForFrenzy

<pre>
plugin::CallAndReturn<bool, 0x43D350, CVehicle const*>(pVehicle);
0AA7: call_function_return 0x43D350 num_params 1 pop 1 [pVehicle] func_ret [bool]
</pre>

#### CDarkel::StartFrenzy

<pre>
plugin::Call<0x43D3B0, eWeaponType, int, unsigned short, int, unsigned short*, int, int, int, bool, bool>(weapontype, Timelimit, KillsNeeded, ModelToKill, pStartMessage, ModelToKill2, ModelToKill3, ModelToKill4, bStandardSoundAndMessages, bNeedHeadShot);
0AA5: call_function 0x43D3B0 num_params 10 pop 10 [weapontype] [Timelimit] [KillsNeeded] [ModelToKill] [pStartMessage] [ModelToKill2] [ModelToKill3] [ModelToKill4] [bStandardSoundAndMessages] [bNeedHeadShot]
</pre>

#### CDarkel::ResetModelsKilledByPlayer

<pre>
plugin::Call<0x43D6A0, int>(playerid);
0AA5: call_function 0x43D6A0 num_params 1 pop 1 [playerid]
</pre>

#### CDarkel::QueryModelsKilledByPlayer

<pre>
plugin::CallAndReturn<int, 0x43D6C0, int, int>(player, modelid);
0AA7: call_function_return 0x43D6C0 num_params 2 pop 2 [player] [modelid] func_ret [int]
</pre>

#### CDarkel::FindTotalPedsKilledByPlayer

<pre>
plugin::CallAndReturn<int, 0x43D6E0, int>(player);
0AA7: call_function_return 0x43D6E0 num_params 1 pop 1 [player] func_ret [int]
</pre>

#### CDarkel::DealWithWeaponChangeAtEndOfFrenzy

<pre>
plugin::Call<0x43D7A0>();
0AA5: call_function 0x43D7A0 num_params 0 pop 0
</pre>

#### CDarkel::CheckDamagedWeaponType

<pre>
plugin::CallAndReturn<bool, 0x43D9E0, int, int>(damageWeaponID, expectedDamageWeaponID);
0AA7: call_function_return 0x43D9E0 num_params 2 pop 2 [damageWeaponID] [expectedDamageWeaponID] func_ret [bool]
</pre>

#### CDarkel::Update

<pre>
plugin::Call<0x43DAC0>();
0AA5: call_function 0x43DAC0 num_params 0 pop 0
</pre>

#### CDarkel::ResetOnPlayerDeath

<pre>
plugin::Call<0x43DC10>();
0AA5: call_function 0x43DC10 num_params 0 pop 0
</pre>

#### CDarkel::FailKillFrenzy

<pre>
plugin::Call<0x43DC60>();
0AA5: call_function 0x43DC60 num_params 0 pop 0
</pre>

#### CDarkel::RegisterKillByPlayer

<pre>
plugin::Call<0x43DCD0, CPed const*, eWeaponType, bool, int>(pKilledPed, damageWeaponID, bHeadShotted, arg4);
0AA5: call_function 0x43DCD0 num_params 4 pop 4 [pKilledPed] [damageWeaponID] [bHeadShotted] [arg4]
</pre>

#### CDarkel::RegisterCarBlownUpByPlayer

<pre>
plugin::Call<0x43DF20, CVehicle*, int>(pVehicle, arg2);
0AA5: call_function 0x43DF20 num_params 2 pop 2 [pVehicle] [arg2]
</pre>

### plugin_sa\game_sa\CDate.cpp

#### CDate::CDate

<pre>
plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), this);</pre>

#### CDate::operator<

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator<), this, rhs);
0AA8: call_method_return 0x618D90 struct [CDate] num_params 1 pop 0 [rhs] func_ret [bool]
</pre>

#### CDate::operator==

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator==), this, rhs);
0AA8: call_method_return 0x618DF0 struct [CDate] num_params 1 pop 0 [rhs] func_ret [bool]
</pre>

#### CDate::operator>

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator>), this, rhs);
0AA8: call_method_return 0x618D30 struct [CDate] num_params 1 pop 0 [rhs] func_ret [bool]
</pre>

#### CDate::PopulateDateFields

<pre>
plugin::CallMethodDynGlobal<CDate *, char const &, char const &, char const &, char const &, char const &, short>(gaddrof(CDate::PopulateDateFields), this, seconds, minutes, hours, day, month, year);
0AA6: call_method 0x618E30 struct [CDate] num_params 6 pop 0 [seconds] [minutes] [hours] [day] [month] [year]
</pre>

### plugin_sa\game_sa\CDecisionSimple.cpp

#### CDecisionSimple::Set

<pre>
plugin::CallMethod<0x600730, CDecisionSimple *, int*, unsigned char*, int>(this, taskTypes, chances, count);
0AA6: call_method 0x600730 struct [CDecisionSimple] num_params 3 pop 0 [taskTypes] [chances] [count]
</pre>

#### CDecisionSimple::MakeDecision

<pre>
plugin::CallMethod<0x6007A0, CDecisionSimple *, int, short&, int&>(this, taskType, outTaskType, outDecisionIndex);
0AA6: call_method 0x6007A0 struct [CDecisionSimple] num_params 3 pop 0 [taskType] [outTaskType] [outDecisionIndex]
</pre>

#### CDecisionSimple::SetDefault

<pre>
plugin::CallMethod<0x604220, CDecisionSimple *>(this);
0AA6: call_method 0x604220 struct [CDecisionSimple] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CDirectory.cpp

#### CDirectory::CDirectory

<pre>
plugin::CallMethod<0x532290, CDirectory *>(this);
0AA6: call_method 0x532290 struct [CDirectory] num_params 0 pop 0
</pre>

#### CDirectory::CDirectory

<pre>
plugin::CallMethod<0x5322A0, CDirectory *, int>(this, capacity);
0AA6: call_method 0x5322A0 struct [CDirectory] num_params 1 pop 0 [capacity]
</pre>

#### CDirectory::~CDirectory

<pre>
plugin::CallMethod<0x5322D0, CDirectory *>(this);
0AA6: call_method 0x5322D0 struct [CDirectory] num_params 0 pop 0
</pre>

#### CDirectory::Init

<pre>
plugin::CallMethod<0x5322F0, CDirectory *, int, void*>(this, capacity, entries);
0AA6: call_method 0x5322F0 struct [CDirectory] num_params 2 pop 0 [capacity] [entries]
</pre>

#### CDirectory::AddItem

<pre>
plugin::CallMethod<0x532310, CDirectory *, DirectoryInfo const&>(this, entry);
0AA6: call_method 0x532310 struct [CDirectory] num_params 1 pop 0 [entry]
</pre>

#### CDirectory::ReadDirFile

<pre>
plugin::CallMethod<0x532350, CDirectory *, char const*>(this, filename);
0AA6: call_method 0x532350 struct [CDirectory] num_params 1 pop 0 [filename]
</pre>

#### CDirectory::WriteDirFile

<pre>
plugin::CallMethodAndReturn<bool, 0x532410, CDirectory *, char const*>(this, filename);
0AA8: call_method_return 0x532410 struct [CDirectory] num_params 1 pop 0 [filename] func_ret [bool]
</pre>

#### CDirectory::DirectoryInfo\* CDirectory

<pre>
plugin::CallMethodAndReturn<DirectoryInfo*, 0x532450, CDirectory *, char const*>(this, name);
0AA8: call_method_return 0x532450 struct [CDirectory] num_params 1 pop 0 [name] func_ret [DirectoryInfo*]
</pre>

#### CDirectory::DirectoryInfo\* CDirectory

<pre>
plugin::CallMethodAndReturn<DirectoryInfo*, 0x5324A0, CDirectory *, char const*, unsigned int&, unsigned int&>(this, name, outOffset, outStreamingSize);
0AA8: call_method_return 0x5324A0 struct [CDirectory] num_params 3 pop 0 [name] [outOffset] [outStreamingSize] func_ret [DirectoryInfo*]
</pre>

#### CDirectory::DirectoryInfo\* CDirectory

<pre>
plugin::CallMethodAndReturn<DirectoryInfo*, 0x5324D0, CDirectory *, unsigned int, unsigned int&, unsigned int&>(this, key, outOffset, outStreamingSize);
0AA8: call_method_return 0x5324D0 struct [CDirectory] num_params 3 pop 0 [key] [outOffset] [outStreamingSize] func_ret [DirectoryInfo*]
</pre>

### plugin_sa\game_sa\CDoor.cpp

#### CDoor::Process

<pre>
plugin::CallMethodAndReturn<bool, 0x6F4040, CDoor *, CVehicle*, CVector&, CVector&, CVector&>(this, vehicle, arg1, arg2, arg3);
0AA8: call_method_return 0x6F4040 struct [CDoor] num_params 4 pop 0 [vehicle] [arg1] [arg2] [arg3] func_ret [bool]
</pre>

#### CDoor::ProcessImpact

<pre>
plugin::CallMethodAndReturn<bool, 0x6F4540, CDoor *, CVehicle*, CVector&, CVector&, CVector&>(this, vehicle, arg1, arg2, arg3);
0AA8: call_method_return 0x6F4540 struct [CDoor] num_params 4 pop 0 [vehicle] [arg1] [arg2] [arg3] func_ret [bool]
</pre>

#### CDoor::Open

<pre>
plugin::CallMethod<0x6F4790, CDoor *, float>(this, openRatio);
0AA6: call_method 0x6F4790 struct [CDoor] num_params 1 pop 0 [openRatio]
</pre>

#### CDoor::GetAngleOpenRatio

<pre>
plugin::CallMethodAndReturn<float, 0x6F47E0, CDoor *>(this);
0AA8: call_method_return 0x6F47E0 struct [CDoor] num_params 0 pop 0 func_ret [float]
</pre>

#### CDoor::IsClosed

<pre>
plugin::CallMethodAndReturn<bool, 0x6F4800, CDoor *>(this);
0AA8: call_method_return 0x6F4800 struct [CDoor] num_params 0 pop 0 func_ret [bool]
</pre>

#### CDoor::IsFullyOpen

<pre>
plugin::CallMethodAndReturn<bool, 0x6F4820, CDoor *>(this);
0AA8: call_method_return 0x6F4820 struct [CDoor] num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_sa\game_sa\CDraw.cpp

#### CDraw::SetFOV

<pre>
plugin::Call<0x6FF410, float>(fovValue);
0AA5: call_function 0x6FF410 num_params 1 pop 1 [fovValue]
</pre>

#### CDraw::CalculateAspectRatio

<pre>
plugin::CallAndReturn<float, 0x6FF420>();
0AA7: call_function_return 0x6FF420 num_params 0 pop 0 func_ret [float]
</pre>

### plugin_sa\game_sa\CEntryExit.cpp

#### CEntryExit::GenerateAmbientPeds

<pre>
plugin::CallMethodDynGlobal<CEntryExit *, CVector const &>(gaddrof(CEntryExit::GenerateAmbientPeds), this, position);
0AA6: call_method 0x43E8B0 struct [CEntryExit] num_params 1 pop 0 [position]
</pre>

#### \*CEntryExit::GetEntryExitToDisplayNameOf

<pre>
plugin::CallMethodAndReturnDynGlobal<char *, CEntryExit *>(gaddrof(CEntryExit::GetEntryExitToDisplayNameOf), this);
0AA8: call_method_return 0x43E650 struct [*CEntryExit] num_params 0 pop 0 func_ret [char *]
</pre>

#### CEntryExit::GetPositionRelativeToOutsideWorld

<pre>
plugin::CallMethodDynGlobal<CEntryExit *, CVector &>(gaddrof(CEntryExit::GetPositionRelativeToOutsideWorld), this, positionInOut);
0AA6: call_method 0x43EA00 struct [CEntryExit] num_params 1 pop 0 [positionInOut]
</pre>

#### CEntryExit::IsInArea

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CVector const &>(gaddrof(CEntryExit::IsInArea), this, position);
0AA8: call_method_return 0x43E460 struct [CEntryExit] num_params 1 pop 0 [position] func_ret [bool]
</pre>

#### CEntryExit::RequestAmbientPeds

<pre>
plugin::CallMethodDynGlobal<CEntryExit *>(gaddrof(CEntryExit::RequestAmbientPeds), this);
0AA6: call_method 0x43E6D0 struct [CEntryExit] num_params 0 pop 0
</pre>

#### CEntryExit::RequestObjectsInFrustum

<pre>
plugin::CallMethodDynGlobal<CEntryExit *>(gaddrof(CEntryExit::RequestObjectsInFrustum), this);
0AA6: call_method 0x43E690 struct [CEntryExit] num_params 0 pop 0
</pre>

#### CEntryExit::TransitionFinished

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CPed *>(gaddrof(CEntryExit::TransitionFinished), this, player);
0AA8: call_method_return 0x4404A0 struct [CEntryExit] num_params 1 pop 0 [player] func_ret [bool]
</pre>

#### CEntryExit::TransitionStarted

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CPed *>(gaddrof(CEntryExit::TransitionStarted), this, player);
0AA8: call_method_return 0x43FFD0 struct [CEntryExit] num_params 1 pop 0 [player] func_ret [bool]
</pre>

#### CEntryExit::WarpGangWithPlayer

<pre>
plugin::CallMethodDynGlobal<CEntryExit *, CPed *>(gaddrof(CEntryExit::WarpGangWithPlayer), this, player);
0AA6: call_method 0x43F1F0 struct [CEntryExit] num_params 1 pop 0 [player]
</pre>

### plugin_sa\game_sa\CEntryExitManager.cpp

#### CEntryExitManager::AddEntryExitToStack

<pre>
plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::AddEntryExitToStack), a1);
</pre>

#### CEntryExitManager::AddOne

<pre>
plugin::CallAndReturnDynGlobal<int, float, float, float, float, float, float, int, float, float, float, float, int, int, int, int, int, int, char const *>(gaddrof(CEntryExitManager::AddOne), entranceX, entranceY, entranceZ, entranceAngle, entranceRangeX, entranceRangeY, unused, exitX, exitY, exitZ, exitAngle, area, flags, skyColor, timeOn, timeOff, numberOfPeds, name);
</pre>

#### CEntryExitManager::DeleteOne

<pre>
plugin::CallDynGlobal<int>(gaddrof(CEntryExitManager::DeleteOne), index);
</pre>

#### CEntryExitManager::EnableBurglaryHouses

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CEntryExitManager::EnableBurglaryHouses), enable);
</pre>

#### \*CEntryExitManager::FindNearestDoor

<pre>
plugin::CallAndReturnDynGlobal<CEntity *, CEntryExit const &, float>(gaddrof(CEntryExitManager::FindNearestDoor), entryExit, range);
</pre>

#### CEntryExitManager::FindNearestEntryExit

<pre>
plugin::CallAndReturnDynGlobal<int, CVector2D const &, float, int>(gaddrof(CEntryExitManager::FindNearestEntryExit), position, range, ignoreArea);
</pre>

#### \*CEntryExitManager::GetEntryExit

<pre>
plugin::CallAndReturnDynGlobal<CEntryExit *, int>(gaddrof(CEntryExitManager::GetEntryExit), index);
</pre>

#### CEntryExitManager::GetEntryExitIndex

<pre>
plugin::CallAndReturnDynGlobal<int, char const *, unsigned short, unsigned short>(gaddrof(CEntryExitManager::GetEntryExitIndex), name, enabledFlags, disabledFlags);
</pre>

#### CEntryExitManager::GetPositionRelativeToOutsideWorld

<pre>
plugin::CallDynGlobal<CVector &>(gaddrof(CEntryExitManager::GetPositionRelativeToOutsideWorld), positionInOut);
</pre>

#### CEntryExitManager::GotoEntryExit

<pre>
plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::GotoEntryExit), entryExit);
</pre>

#### CEntryExitManager::GotoEntryExitVC

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CEntryExitManager::GotoEntryExitVC), name);
</pre>

#### CEntryExitManager::LinkEntryExit

<pre>
plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::LinkEntryExit), entryExit);
</pre>

#### CEntryExitManager::Load

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::Load));
</pre>

#### CEntryExitManager::Save

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::Save));
</pre>

#### CEntryExitManager::SetEnabled

<pre>
plugin::CallDynGlobal<int, bool>(gaddrof(CEntryExitManager::SetEnabled), index, enable);
</pre>

#### CEntryExitManager::SetEnabledByName

<pre>
plugin::CallDynGlobal<char const *, bool>(gaddrof(CEntryExitManager::SetEnabledByName), name, enable);
</pre>

#### CEntryExitManager::SetEntryExitFlag

<pre>
plugin::CallDynGlobal<char const *, unsigned int, bool>(gaddrof(CEntryExitManager::SetEntryExitFlag), name, flag, enable);
</pre>

#### CEntryExitManager::SetEntryExitFlagWithIndex

<pre>
plugin::CallDynGlobal<int, unsigned int, bool>(gaddrof(CEntryExitManager::SetEntryExitFlagWithIndex), index, flag, enable);
</pre>

#### CEntryExitManager::WeAreInInteriorTransition

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::WeAreInInteriorTransition));
</pre>

### plugin_sa\game_sa\CExplosion.cpp

#### CExplosion::ClearAllExplosions

<pre>
plugin::Call<0x736840>();
0AA5: call_function 0x736840 num_params 0 pop 0
</pre>

#### CExplosion::Shutdown

<pre>
plugin::Call<0x7368F0>();
0AA5: call_function 0x7368F0 num_params 0 pop 0
</pre>

#### CExplosion::GetExplosionActiveCounter

<pre>
plugin::CallAndReturn<unsigned char, 0x736900, unsigned char>(explosionId);
0AA7: call_function_return 0x736900 num_params 1 pop 1 [explosionId] func_ret [unsigned char]
</pre>

#### CExplosion::ResetExplosionActiveCounter

<pre>
plugin::Call<0x736910, unsigned char>(explosionId);
0AA5: call_function 0x736910 num_params 1 pop 1 [explosionId]
</pre>

#### CExplosion::DoesExplosionMakeSound

<pre>
plugin::CallAndReturn<bool, 0x736920, unsigned char>(explosionId);
0AA7: call_function_return 0x736920 num_params 1 pop 1 [explosionId] func_ret [bool]
</pre>

#### CExplosion::GetExplosionType

<pre>
plugin::CallAndReturn<unsigned int, 0x736930, unsigned char>(explosionId);
0AA7: call_function_return 0x736930 num_params 1 pop 1 [explosionId] func_ret [unsigned int]
</pre>

#### CExplosion::GetExplosionPosition

<pre>
plugin::CallAndReturn<CVector*, 0x736940, unsigned char>(explosionId);
0AA7: call_function_return 0x736940 num_params 1 pop 1 [explosionId] func_ret [CVector*]
</pre>

#### CExplosion::TestForExplosionInArea

<pre>
plugin::CallAndReturn<bool, 0x736950, eExplosionType, float, float, float, float, float, float>(explosionType, x1, y1, z1, x2, y2, z2);
0AA7: call_function_return 0x736950 num_params 7 pop 7 [explosionType] [x1] [y1] [z1] [x2] [y2] [z2] func_ret [bool]
</pre>

#### CExplosion::RemoveAllExplosionsInArea

<pre>
plugin::Call<0x7369E0, CVector, float>(posn, radius);
0AA5: call_function 0x7369E0 num_params 2 pop 2 [posn] [radius]
</pre>

#### CExplosion::Initialise

<pre>
plugin::Call<0x736A40>();
0AA5: call_function 0x736A40 num_params 0 pop 0
</pre>

#### CExplosion::AddExplosion

<pre>
plugin::CallAndReturn<bool, 0x736A50, CEntity*, CEntity*, eExplosionType, CVector const&, unsigned int, unsigned char, float, unsigned char>(victim, creator, explosionType, posn, time, makeSound, camShake, visibility);
0AA7: call_function_return 0x736A50 num_params 8 pop 8 [victim] [creator] [explosionType] [posn] [time] [makeSound] [camShake] [visibility] func_ret [bool]
</pre>

#### CExplosion::Update

<pre>
plugin::Call<0x737620>();
0AA5: call_function 0x737620 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CFileLoader.cpp

#### CFileLoader::AddTexDictionaries

<pre>
plugin::CallDynGlobal<RwTexDictionary *, RwTexDictionary *>(gaddrof(CFileLoader::AddTexDictionaries), dictionary, baseDictionary);
</pre>

#### \*CFileLoader::FindRelatedModelInfoCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CFileLoader::FindRelatedModelInfoCB), atomic, data);
</pre>

#### CFileLoader::FinishLoadClumpFile

<pre>
plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof(CFileLoader::FinishLoadClumpFile), stream, modelIndex);
</pre>

#### CFileLoader::LoadAnimatedClumpObject

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadAnimatedClumpObject), line);
</pre>

#### CFileLoader::LoadAtomicFile

<pre>
plugin::CallDynGlobal<RwStream *, unsigned int>(gaddrof_o(CFileLoader::LoadAtomicFile, void (*)(RwStream *, unsigned int)), stream, modelIndex);
</pre>

#### CFileLoader::LoadAtomicFile

<pre>
plugin::CallDynGlobal<char const *>(gaddrof_o(CFileLoader::LoadAtomicFile, void (*)(char const *)), filename);
</pre>

#### \*CFileLoader::LoadAtomicFile2Return

<pre>
plugin::CallAndReturnDynGlobal<RpClump *, char const *>(gaddrof(CFileLoader::LoadAtomicFile2Return), filename);
</pre>

#### CFileLoader::LoadAudioZone

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadAudioZone), line);
</pre>

#### CFileLoader::LoadBoundingBox

<pre>
plugin::CallDynGlobal<unsigned char *, CBoundingBox &>(gaddrof(CFileLoader::LoadBoundingBox), data, outBoundBox);
</pre>

#### CFileLoader::LoadCarGenerator

<pre>
plugin::CallDynGlobal<CFileCarGenerator *, int>(gaddrof_o(CFileLoader::LoadCarGenerator, void (*)(CFileCarGenerator *, int)), carGen, iplId);
</pre>

#### CFileLoader::LoadCarGenerator

<pre>
plugin::CallDynGlobal<char const *, int>(gaddrof_o(CFileLoader::LoadCarGenerator, void (*)(char const *, int)), line, iplId);
</pre>

#### CFileLoader::LoadCarPathNode

<pre>
plugin::CallDynGlobal<char const *, int, int, bool>(gaddrof(CFileLoader::LoadCarPathNode), line, objModelIndex, pathEntryIndex, a4);
</pre>

#### CFileLoader::LoadClumpFile

<pre>
plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof_o(CFileLoader::LoadClumpFile, bool (*)(RwStream *, unsigned int)), stream, modelIndex);
</pre>

#### CFileLoader::LoadClumpFile

<pre>
plugin::CallDynGlobal<char const *>(gaddrof_o(CFileLoader::LoadClumpFile, void (*)(char const *)), filename);
</pre>

#### CFileLoader::LoadClumpObject

<pre>
plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadClumpObject), line);
</pre>

#### CFileLoader::LoadCollisionFile

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned char *, unsigned int, unsigned char>(gaddrof_o(CFileLoader::LoadCollisionFile, bool (*)(unsigned char *, unsigned int, unsigned char)), data, dataSize, colId);
</pre>

#### CFileLoader::LoadCollisionFile

<pre>
plugin::CallDynGlobal<char const *, unsigned char>(gaddrof_o(CFileLoader::LoadCollisionFile, void (*)(char const *, unsigned char)), filename, colId);
</pre>

#### CFileLoader::LoadCollisionFileFirstTime

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned char *, unsigned int, unsigned char>(gaddrof(CFileLoader::LoadCollisionFileFirstTime), data, dataSize, colId);
</pre>

#### CFileLoader::LoadCollisionModel

<pre>
plugin::CallDynGlobal<unsigned char *, CColModel &>(gaddrof(CFileLoader::LoadCollisionModel), data, outColModel);
</pre>

#### CFileLoader::LoadCollisionModelVer2

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer2), data, dataSize, outColModel, modelName);
</pre>

#### CFileLoader::LoadCollisionModelVer3

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer3), data, dataSize, outColModel, modelName);
</pre>

#### CFileLoader::LoadCollisionModelVer4

<pre>
plugin::CallDynGlobal<void *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer4), data, dataSize, outColModel, modelName);
</pre>

#### CFileLoader::LoadCullZone

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadCullZone), line);
</pre>

#### CFileLoader::LoadEntryExit

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadEntryExit), line);
</pre>

#### CFileLoader::LoadGarage

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadGarage), line);
</pre>

#### CFileLoader::LoadLevel

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadLevel), filename);
</pre>

#### \*CFileLoader::LoadLine

<pre>
plugin::CallAndReturnDynGlobal<char *, FILESTREAM>(gaddrof_o(CFileLoader::LoadLine, char *(*)(FILESTREAM)), file);
</pre>

#### \*CFileLoader::LoadLine

<pre>
plugin::CallAndReturnDynGlobal<char *, char **, int &>(gaddrof_o(CFileLoader::LoadLine, char *(*)(char **, int &)), outLine, outSize);
</pre>

#### CFileLoader::LoadObject

<pre>
plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadObject), line);
</pre>

#### \*CFileLoader::LoadObjectInstance

<pre>
plugin::CallAndReturnDynGlobal<CEntity *, CFileObjectInstance *, char const *>(gaddrof_o(CFileLoader::LoadObjectInstance, CEntity *(*)(CFileObjectInstance *, char const *)), objInstance, modelname);
</pre>

#### \*CFileLoader::LoadObjectInstance

<pre>
plugin::CallAndReturnDynGlobal<CEntity *, char const *>(gaddrof_o(CFileLoader::LoadObjectInstance, CEntity *(*)(char const *)), line);
</pre>

#### CFileLoader::LoadObjectTypes

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadObjectTypes), filename);
</pre>

#### CFileLoader::LoadOcclusionVolume

<pre>
plugin::CallDynGlobal<char const *, char const *>(gaddrof(CFileLoader::LoadOcclusionVolume), line, filename);
</pre>

#### CFileLoader::LoadPathHeader

<pre>
plugin::CallAndReturnDynGlobal<int, char const *, int &>(gaddrof(CFileLoader::LoadPathHeader), line, outPathType);
</pre>

#### CFileLoader::LoadPedObject

<pre>
plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadPedObject), line);
</pre>

#### CFileLoader::LoadPedPathNode

<pre>
plugin::CallDynGlobal<char const *, int, int>(gaddrof(CFileLoader::LoadPedPathNode), line, objModelIndex, pathEntryIndex);
</pre>

#### CFileLoader::LoadPickup

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadPickup), line);
</pre>

#### CFileLoader::LoadScene

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadScene), filename);
</pre>

#### CFileLoader::LoadStuntJump

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadStuntJump), line);
</pre>

#### CFileLoader::LoadTXDParent

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadTXDParent), line);
</pre>

#### \*CFileLoader::LoadTexDictionary

<pre>
plugin::CallAndReturnDynGlobal<RwTexDictionary *, char const *>(gaddrof(CFileLoader::LoadTexDictionary), filename);
</pre>

#### CFileLoader::LoadTimeCyclesModifier

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadTimeCyclesModifier), line);
</pre>

#### CFileLoader::LoadTimeObject

<pre>
plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadTimeObject), line);
</pre>

#### CFileLoader::LoadVehicleObject

<pre>
plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadVehicleObject), line);
</pre>

#### CFileLoader::LoadWeaponObject

<pre>
plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadWeaponObject), line);
</pre>

#### CFileLoader::LoadZone

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadZone), line);
</pre>

#### CFileLoader::ReloadObjectTypes

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::ReloadObjectTypes), arg1);
</pre>

#### CFileLoader::ReloadPaths

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::ReloadPaths), filename);
</pre>

#### CFileLoader::SaveTexDictionary

<pre>
plugin::CallDynGlobal<RwTexDictionary *, char const *>(gaddrof(CFileLoader::SaveTexDictionary), dictionary, filename);
</pre>

#### \*CFileLoader::SetRelatedModelInfoCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CFileLoader::SetRelatedModelInfoCB), atomic, data);
</pre>

#### CFileLoader::StartLoadClumpFile

<pre>
plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof(CFileLoader::StartLoadClumpFile), stream, modelIndex);
</pre>

#### GetNameAndDamage

<pre>
plugin::CallDynGlobal<char const *, char *, bool &>(gaddrof(GetNameAndDamage), nodeName, outName, outDamage);
</pre>

#### \*CloneAtomicToClumpCB

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CloneAtomicToClumpCB), atomic, data);
</pre>

#### \*GetFilename

<pre>
plugin::CallAndReturnDynGlobal<char const *, char const *>(gaddrof(GetFilename), filepath);
</pre>

#### LoadingScreenLoadingFile

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(LoadingScreenLoadingFile), filename);
</pre>

#### \*AddTextureCB

<pre>
plugin::CallAndReturnDynGlobal<RwTexture *, RwTexture *, void *>(gaddrof(AddTextureCB), texture, data);
</pre>

### plugin_sa\game_sa\CFormation.cpp

#### CFormation::DistributeDestinations

<pre>
plugin::CallDynGlobal<CPedList *>(gaddrof(CFormation::DistributeDestinations), pedlist);
</pre>

#### CFormation::DistributeDestinations_CoverPoints

<pre>
plugin::CallDynGlobal<CPedList *, CVector>(gaddrof(CFormation::DistributeDestinations_CoverPoints), pedlist, pos);
</pre>

#### CFormation::DistributeDestinations_PedsToAttack

<pre>
plugin::CallDynGlobal<CPedList *>(gaddrof(CFormation::DistributeDestinations_PedsToAttack), pedlist);
</pre>

#### CFormation::FindCoverPoints

<pre>
plugin::CallDynGlobal<CVector, float>(gaddrof(CFormation::FindCoverPoints), pos, radius);
</pre>

#### CFormation::FindCoverPointsBehindBox

<pre>
plugin::CallDynGlobal<CPointList *, CVector, CMatrix *, CVector const *, CVector const *, CVector const *, float>(gaddrof(CFormation::FindCoverPointsBehindBox), pointlist, Pos, coverEntityMatrix, vecCenter, vecMin, vecMax, radius);
</pre>

#### CFormation::FindNearestAvailableDestination

<pre>
plugin::CallAndReturnDynGlobal<signed int, CVector, float *>(gaddrof(CFormation::FindNearestAvailableDestination), pos, pOutDistance);
</pre>

#### CFormation::GenerateGatherDestinations

<pre>
plugin::CallDynGlobal<CPedList *, CPed *>(gaddrof(CFormation::GenerateGatherDestinations), pedList, ped);
</pre>

#### CFormation::GenerateGatherDestinations_AroundCar

<pre>
plugin::CallDynGlobal<CPedList *, CVehicle *>(gaddrof(CFormation::GenerateGatherDestinations_AroundCar), pedlist, vehicle);
</pre>

#### CFormation::ReturnDestinationForPed

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *, CVector *>(gaddrof(CFormation::ReturnDestinationForPed), ped, pos);
</pre>

#### CFormation::ReturnTargetPedForPed

<pre>
plugin::CallAndReturnDynGlobal<int, CPed *, CPed **>(gaddrof(CFormation::ReturnTargetPedForPed), ped, pOutTargetPed);
</pre>

### plugin_sa\game_sa\CGame.cpp

#### CGame::CanSeeOutSideFromCurrArea

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeOutSideFromCurrArea));
</pre>

#### CGame::CanSeeWaterFromCurrArea

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeWaterFromCurrArea));
</pre>

#### CGame::DrasticTidyUpMemory

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CGame::DrasticTidyUpMemory), a1);
</pre>

#### CGame::Init1

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init1), datFile);
</pre>

#### CGame::Init2

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init2), datFile);
</pre>

#### CGame::Init3

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init3), datFile);
</pre>

#### CGame::Initialise

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);
</pre>

#### CGame::InitialiseCoreDataAfterRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseCoreDataAfterRW));
</pre>

#### CGame::InitialiseEssentialsAfterRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseEssentialsAfterRW));
</pre>

#### CGame::InitialiseOnceBeforeRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));
</pre>

#### CGame::InitialiseRenderWare

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));
</pre>

#### CGame::Shutdown

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));
</pre>

#### CGame::TidyUpMemory

<pre>
plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), a1, clearD3Dmem);
</pre>

#### MoveMem

<pre>
plugin::CallAndReturnDynGlobal<bool, void **>(gaddrof(MoveMem), pMem);
</pre>

#### MoveColModelMemory

<pre>
plugin::CallAndReturnDynGlobal<bool, CColModel &, bool>(gaddrof(MoveColModelMemory), colModel, a2);
</pre>

#### \*MoveGeometryMemory

<pre>
plugin::CallAndReturnDynGlobal<RpGeometry *, RpGeometry *>(gaddrof(MoveGeometryMemory), geometry);
</pre>

#### TidyUpModelInfo2

<pre>
plugin::CallAndReturnDynGlobal<bool, CEntity *, bool>(gaddrof(TidyUpModelInfo2), entity, a2);
</pre>

#### DoHaspChecks

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(DoHaspChecks));
</pre>

### plugin_sa\game_sa\CGameLogic.cpp

#### CGameLogic::InitAtStartOfGame

<pre>
plugin::Call<0x441210>();
0AA5: call_function 0x441210 num_params 0 pop 0
</pre>

#### CGameLogic::IsCoopGameGoingOn

<pre>
plugin::CallAndReturn<bool, 0x441390>();
0AA7: call_function_return 0x441390 num_params 0 pop 0 func_ret [bool]
</pre>

#### CGameLogic::Remove2ndPlayerIfPresent

<pre>
plugin::Call<0x4413C0>();
0AA5: call_function 0x4413C0 num_params 0 pop 0
</pre>

#### CGameLogic::SortOutStreamingAndMemory

<pre>
plugin::Call<0x441440, CVector*, float>(translation, angle);
0AA5: call_function 0x441440 num_params 2 pop 2 [translation] [angle]
</pre>

#### CGameLogic::PassTime

<pre>
plugin::Call<0x4414C0, unsigned int>(time);
0AA5: call_function 0x4414C0 num_params 1 pop 1 [time]
</pre>

#### CGameLogic::ClearSkip

<pre>
plugin::Call<0x441560, char>(a1);
0AA5: call_function 0x441560 num_params 1 pop 1 [a1]
</pre>

#### CGameLogic::SkipCanBeActivated

<pre>
plugin::CallAndReturn<bool, 0x4415C0>();
0AA7: call_function_return 0x4415C0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CGameLogic::IsPointWithinLineArea

<pre>
plugin::CallAndReturn<int, 0x4416E0, RwV3d*, signed int, float, float>(vectors, sizeofvectors, x, y);
0AA7: call_function_return 0x4416E0 num_params 4 pop 4 [vectors] [sizeofvectors] [x] [y] func_ret [int]
</pre>

#### CGameLogic::SetPlayerWantedLevelForForbiddenTerritories

<pre>
plugin::Call<0x441770, char>(townNumber);
0AA5: call_function 0x441770 num_params 1 pop 1 [townNumber]
</pre>

#### CGameLogic::CalcDistanceToForbiddenTrainCrossing

<pre>
plugin::CallAndReturn<long double, 0x4418E0, float, float, float, float, float, float, char, CVector*>(x1, y1, z1, x2, y2, z2, a7, a8);
0AA7: call_function_return 0x4418E0 num_params 8 pop 8 [x1] [y1] [z1] [x2] [y2] [z2] [a7] [a8] func_ret [long double]
</pre>

#### CGameLogic::LaRiotsActiveHere

<pre>
plugin::CallAndReturn<bool, 0x441C10>();
0AA7: call_function_return 0x441C10 num_params 0 pop 0 func_ret [bool]
</pre>

#### CGameLogic::RestorePedsWeapons

<pre>
plugin::CallAndReturn<signed int, 0x441D30, int>(a1);
0AA7: call_function_return 0x441D30 num_params 1 pop 1 [a1] func_ret [signed int]
</pre>

#### CGameLogic::IsPlayerAllowedToGoInThisDirection

<pre>
plugin::CallAndReturn<bool, 0x441E10, CPed*, float, float, float, float>(a1, a2, a3, a4, a5);
0AA7: call_function_return 0x441E10 num_params 5 pop 5 [a1] [a2] [a3] [a4] [a5] func_ret [bool]
</pre>

#### CGameLogic::RestorePlayerStuffDuringResurrection

<pre>
plugin::Call<0x442060, CPlayerPed*, float, float, float, float>(player, x, y, z, fAngle);
0AA5: call_function 0x442060 num_params 5 pop 5 [player] [x] [y] [z] [fAngle]
</pre>

#### CGameLogic::UpdateSkip

<pre>
plugin::Call<0x442480>();
0AA5: call_function 0x442480 num_params 0 pop 0
</pre>

#### CGameLogic::ResetStuffUponResurrection

<pre>
plugin::Call<0x442980>();
0AA5: call_function 0x442980 num_params 0 pop 0
</pre>

#### CGameLogic::Update

<pre>
plugin::Call<0x442AD0>();
0AA5: call_function 0x442AD0 num_params 0 pop 0
</pre>

#### CGameLogic::Save

<pre>
plugin::Call<0x5D33C0>();
0AA5: call_function 0x5D33C0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CGangs.cpp

#### CGangs::ChooseGangPedModel

<pre>
plugin::CallAndReturnDynGlobal<signed int, short>(gaddrof(CGangs::ChooseGangPedModel), gangID);
</pre>

#### CGangs::GetWillAttackPlayerWithCops

<pre>
plugin::CallAndReturnDynGlobal<bool, ePedType>(gaddrof(CGangs::GetWillAttackPlayerWithCops), gangID);
</pre>

#### CGangs::SetGangPedModelOverride

<pre>
plugin::CallDynGlobal<short, signed char>(gaddrof(CGangs::SetGangPedModelOverride), gangID, PedModelOverride);
</pre>

#### CGangs::SetGangWeapons

<pre>
plugin::CallDynGlobal<short, int, int, int>(gaddrof(CGangs::SetGangWeapons), gangID, weapID1, weapID2, weapID3);
</pre>

#### CGangs::SetWillAttackPlayerWithCops

<pre>
plugin::CallDynGlobal<ePedType, bool>(gaddrof(CGangs::SetWillAttackPlayerWithCops), gangID, bAttackPlayerWithCops);
</pre>

### plugin_sa\game_sa\CGangWars.cpp

#### CGangWars::AddKillToProvocation

<pre>
plugin::CallDynGlobal<int>(gaddrof(CGangWars::AddKillToProvocation), Pedtype);
</pre>

#### CGangWars::AttackWaveOvercome

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::AttackWaveOvercome));
</pre>

#### CGangWars::CalculateTimeTillNextAttack

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CGangWars::CalculateTimeTillNextAttack));
</pre>

#### CGangWars::CanPlayerStartAGangWarHere

<pre>
plugin::CallAndReturnDynGlobal<bool, CZoneInfo *>(gaddrof(CGangWars::CanPlayerStartAGangWarHere), zoneInfo);
</pre>

#### CGangWars::CreateAttackWave

<pre>
plugin::CallAndReturnDynGlobal<bool, int, int>(gaddrof(CGangWars::CreateAttackWave), warFerocity, waveID);
</pre>

#### CGangWars::CreateDefendingGroup

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGangWars::CreateDefendingGroup), unsued);
</pre>

#### CGangWars::DoesPlayerControlThisZone

<pre>
plugin::CallAndReturnDynGlobal<bool, CZoneInfo *>(gaddrof(CGangWars::DoesPlayerControlThisZone), zoneinfo);
</pre>

#### CGangWars::DontCreateCivilians

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::DontCreateCivilians));
</pre>

#### CGangWars::EndGangWar

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CGangWars::EndGangWar), bEnd);
</pre>

#### CGangWars::GangWarFightingGoingOn

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::GangWarFightingGoingOn));
</pre>

#### CGangWars::GangWarGoingOn

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::GangWarGoingOn));
</pre>

#### CGangWars::MakeEnemyGainInfluenceInZone

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CGangWars::MakeEnemyGainInfluenceInZone), GangID, GangDensityIncreaser);
</pre>

#### CGangWars::MakePlayerGainInfluenceInZone

<pre>
plugin::CallAndReturnDynGlobal<bool, float>(gaddrof(CGangWars::MakePlayerGainInfluenceInZone), remove_mult);
</pre>

#### CGangWars::PedStreamedInForThisGang

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGangWars::PedStreamedInForThisGang), gangID);
</pre>

#### CGangWars::PickStreamedInPedForThisGang

<pre>
plugin::CallAndReturnDynGlobal<bool, int, int *>(gaddrof(CGangWars::PickStreamedInPedForThisGang), gangID, outPedID);
</pre>

#### CGangWars::PickZoneToAttack

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::PickZoneToAttack));
</pre>

#### CGangWars::ReleasePedsInAttackWave

<pre>
plugin::CallAndReturnDynGlobal<int, bool, bool>(gaddrof(CGangWars::ReleasePedsInAttackWave), IsEndOfWar, RestoreGangPedsAcquaintance);
</pre>

#### CGangWars::SetGangWarsActive

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CGangWars::SetGangWarsActive), bActive);
</pre>

#### CGangWars::SetSpecificZoneToTriggerGangWar

<pre>
plugin::CallDynGlobal<int>(gaddrof(CGangWars::SetSpecificZoneToTriggerGangWar), zoneId);
</pre>

#### CGangWars::StrengthenPlayerInfluenceInZone

<pre>
plugin::CallDynGlobal<int>(gaddrof(CGangWars::StrengthenPlayerInfluenceInZone), GroveDensityIncreaser);
</pre>

#### CGangWars::TellGangMembersTo

<pre>
plugin::CallDynGlobal<int>(gaddrof(CGangWars::TellGangMembersTo), bIsGangWarEnding);
</pre>

#### CGangWars::TellStreamingWhichGangsAreNeeded

<pre>
plugin::CallDynGlobal<int *>(gaddrof(CGangWars::TellStreamingWhichGangsAreNeeded), GangsBitFlags);
</pre>

### plugin_sa\game_sa\CGangWarsSaveStructure.cpp

#### CGangWarsSaveStructure::Construct

<pre>
plugin::CallMethodDynGlobal<CGangWarsSaveStructure *>(gaddrof(CGangWarsSaveStructure::Construct), this);
0AA6: call_method 0x5D2620 struct [CGangWarsSaveStructure] num_params 0 pop 0
</pre>

#### CGangWarsSaveStructure::Extract

<pre>
plugin::CallMethodDynGlobal<CGangWarsSaveStructure *>(gaddrof(CGangWarsSaveStructure::Extract), this);
0AA6: call_method 0x5D2740 struct [CGangWarsSaveStructure] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CGenericGameStorage.cpp

#### CGenericGameStorage::CheckDataNotCorrupt

<pre>
plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CGenericGameStorage::CheckDataNotCorrupt), saveID, saveGameFilename);
</pre>

#### CGenericGameStorage::CheckSlotDataValid

<pre>
plugin::CallAndReturnDynGlobal<bool, int, bool>(gaddrof(CGenericGameStorage::CheckSlotDataValid), saveID, unused);
</pre>

#### CGenericGameStorage::GenericLoad

<pre>
plugin::CallAndReturnDynGlobal<bool, bool *>(gaddrof(CGenericGameStorage::GenericLoad), arg1);
</pre>

#### CGenericGameStorage::GenericSave

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGenericGameStorage::GenericSave), unused);
</pre>

#### CGenericGameStorage::GetCurrentVersionNumber

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CGenericGameStorage::GetCurrentVersionNumber));
</pre>

#### \*CGenericGameStorage::GetNameOfSavedGame

<pre>
plugin::CallAndReturnDynGlobal<char *, int>(gaddrof(CGenericGameStorage::GetNameOfSavedGame), saveID);
</pre>

#### \*CGenericGameStorage::GetNameOfSavedGame_Alt

<pre>
plugin::CallAndReturnDynGlobal<char *, int>(gaddrof(CGenericGameStorage::GetNameOfSavedGame_Alt), saveID);
</pre>

#### CGenericGameStorage::GetSavedRadioStationPosition

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CGenericGameStorage::GetSavedRadioStationPosition));
</pre>

#### CGenericGameStorage::LoadWorkBuffer

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGenericGameStorage::LoadWorkBuffer));
</pre>

#### CGenericGameStorage::MakeValidSaveName

<pre>
plugin::CallDynGlobal<int>(gaddrof(CGenericGameStorage::MakeValidSaveName), saveNum);
</pre>

#### CGenericGameStorage::OpenFileForReading

<pre>
plugin::CallAndReturnDynGlobal<bool, char *, unsigned int *>(gaddrof(CGenericGameStorage::OpenFileForReading), saveGameFilename, saveID);
</pre>

#### CGenericGameStorage::OpenFileForWriting

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGenericGameStorage::OpenFileForWriting));
</pre>

#### CGenericGameStorage::ReportError

<pre>
plugin::CallDynGlobal<eSaveLoadBlocks, eSaveLoadError>(gaddrof(CGenericGameStorage::ReportError),block,errorType);
</pre>

#### CGenericGameStorage::RestoreForStartLoad

<pre>
plugin::CallAndReturnDynGlobal<char>(gaddrof(CGenericGameStorage::RestoreForStartLoad));
</pre>

#### CGenericGameStorage::SaveWorkBuffer

<pre>
plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CGenericGameStorage::SaveWorkBuffer), a1);
</pre>

#### CGenericGameStorage::\_LoadDataFromWorkBuffer

<pre>
plugin::CallAndReturnDynGlobal<bool, void *, int>(gaddrof(CGenericGameStorage::_LoadDataFromWorkBuffer), pData, size);
</pre>

#### CGenericGameStorage::\_SaveDataToWorkBuffer

<pre>
plugin::CallAndReturnDynGlobal<bool, void *, int>(gaddrof(CGenericGameStorage::_SaveDataToWorkBuffer), pData, Size);
</pre>

### plugin_sa\game_sa\CGridRef.cpp

#### \*CGridRef::GetAreaName

<pre>
plugin::CallAndReturnDynGlobal<char *, unsigned char, unsigned char>(gaddrof(CGridRef::GetAreaName), sectorX, sectorY);
</pre>

#### CGridRef::GetArtistBugstarID

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, unsigned char, unsigned char>(gaddrof(CGridRef::GetArtistBugstarID), sectorX, sectorY);
</pre>

#### CGridRef::GetGridRefPositions

<pre>
plugin::CallDynGlobal<CVector, unsigned char *, unsigned char *>(gaddrof_o(CGridRef::GetGridRefPositions, void (*)(CVector, unsigned char *, unsigned char *)), posn, outSectorX, outSectorY);
</pre>

#### CGridRef::GetGridRefPositions

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned char *>(gaddrof_o(CGridRef::GetGridRefPositions, void (*)(unsigned char *, unsigned char *)), outSectorX, outSectorY);
</pre>

### plugin_sa\game_sa\CHud.cpp

#### CHud::Draw

<pre>
plugin::Call<0x58FAE0>();
0AA5: call_function 0x58FAE0 num_params 0 pop 0
</pre>

#### CHud::DrawAfterFade

<pre>
plugin::Call<0x58D490>();
0AA5: call_function 0x58D490 num_params 0 pop 0
</pre>

#### CHud::DrawAreaName

<pre>
plugin::Call<0x58AA50>();
0AA5: call_function 0x58AA50 num_params 0 pop 0
</pre>

#### CHud::DrawBustedWastedMessage

<pre>
plugin::Call<0x58CA50>();
0AA5: call_function 0x58CA50 num_params 0 pop 0
</pre>

#### CHud::DrawCrossHairs

<pre>
plugin::Call<0x58E020>();
0AA5: call_function 0x58E020 num_params 0 pop 0
</pre>

#### CHud::DrawFadeState

<pre>
plugin::CallAndReturn<float, 0x58D580, DRAW_FADE_STATE, int>(fadeState, arg1);
0AA7: call_function_return 0x58D580 num_params 2 pop 2 [fadeState] [arg1] func_ret [float]
</pre>

#### CHud::DrawHelpText

<pre>
plugin::Call<0x58B6E0>();
0AA5: call_function 0x58B6E0 num_params 0 pop 0
</pre>

#### CHud::DrawMissionTimers

<pre>
plugin::Call<0x58B180>();
0AA5: call_function 0x58B180 num_params 0 pop 0
</pre>

#### CHud::DrawMissionTitle

<pre>
plugin::Call<0x58D240>();
0AA5: call_function 0x58D240 num_params 0 pop 0
</pre>

#### CHud::DrawOddJobMessage

<pre>
plugin::Call<0x58CC80, unsigned char>(priority);
0AA5: call_function 0x58CC80 num_params 1 pop 1 [priority]
</pre>

#### CHud::DrawRadar

<pre>
plugin::Call<0x58A330>();
0AA5: call_function 0x58A330 num_params 0 pop 0
</pre>

#### CHud::DrawScriptText

<pre>
plugin::Call<0x58C080, unsigned char>(priority);
0AA5: call_function 0x58C080 num_params 1 pop 1 [priority]
</pre>

#### CHud::DrawSubtitles

<pre>
plugin::Call<0x58C250>();
0AA5: call_function 0x58C250 num_params 0 pop 0
</pre>

#### CHud::DrawSuccessFailedMessage

<pre>
plugin::Call<0x58C6A0>();
0AA5: call_function 0x58C6A0 num_params 0 pop 0
</pre>

#### CHud::DrawVehicleName

<pre>
plugin::Call<0x58AEA0>();
0AA5: call_function 0x58AEA0 num_params 0 pop 0
</pre>

#### CHud::DrawVitalStats

<pre>
plugin::Call<0x589650>();
0AA5: call_function 0x589650 num_params 0 pop 0
</pre>

#### CHud::GetRidOfAllHudMessages

<pre>
plugin::Call<0x588A50, unsigned char>(arg0);
0AA5: call_function 0x588A50 num_params 1 pop 1 [arg0]
</pre>

#### CHud::GetYPosBasedOnHealth

<pre>
plugin::CallAndReturn<float, 0x588B60, unsigned char, float, signed>(playerId, pos, offset);
0AA7: call_function_return 0x588B60 num_params 3 pop 3 [playerId] [pos] [offset] func_ret [float]
</pre>

#### CHud::HelpMessageDisplayed

<pre>
plugin::CallAndReturn<bool, 0x588B50>();
0AA7: call_function_return 0x588B50 num_params 0 pop 0 func_ret [bool]
</pre>

#### CHud::Initialise

<pre>
plugin::Call<0x5BA850>();
0AA5: call_function 0x5BA850 num_params 0 pop 0
</pre>

#### CHud::ReInitialise

<pre>
plugin::Call<0x588880>();
0AA5: call_function 0x588880 num_params 0 pop 0
</pre>

#### CHud::ResetWastedText

<pre>
plugin::Call<0x589070>();
0AA5: call_function 0x589070 num_params 0 pop 0
</pre>

#### CHud::SetBigMessage

<pre>
plugin::Call<0x588FC0, char*, unsigned short>(text, style);
0AA5: call_function 0x588FC0 num_params 2 pop 2 [text] [style]
</pre>

#### CHud::SetHelpMessage

<pre>
plugin::Call<0x588BE0, char const*, bool, bool, bool>(text, quickMessage, permanent, addToBrief);
0AA5: call_function 0x588BE0 num_params 4 pop 4 [text] [quickMessage] [permanent] [addToBrief]
</pre>

#### CHud::SetHelpMessageStatUpdate

<pre>
plugin::Call<0x588D40, unsigned char, unsigned short, float, float>(state, statId, diff, max);
0AA5: call_function 0x588D40 num_params 4 pop 4 [state] [statId] [diff] [max]
</pre>

#### CHud::SetHelpMessageWithNumber

<pre>
plugin::Call<0x588E30, char const*, int, bool, bool>(text, number, quickMessage, permanent);
0AA5: call_function 0x588E30 num_params 4 pop 4 [text] [number] [quickMessage] [permanent]
</pre>

#### CHud::SetMessage

<pre>
plugin::Call<0x588F60, char*>(text);
0AA5: call_function 0x588F60 num_params 1 pop 1 [text]
</pre>

#### CHud::SetVehicleName

<pre>
plugin::Call<0x588F50, char*>(name);
0AA5: call_function 0x588F50 num_params 1 pop 1 [name]
</pre>

#### CHud::SetZoneName

<pre>
plugin::Call<0x588BB0, char*, unsigned char>(name, displayState);
0AA5: call_function 0x588BB0 num_params 2 pop 2 [name] [displayState]
</pre>

#### CHud::Shutdown

<pre>
plugin::Call<0x588850>();
0AA5: call_function 0x588850 num_params 0 pop 0
</pre>

#### CHud::DrawAmmo

<pre>
plugin::Call<0x5893B0, CPed*, int, int, float>(ped, x, y, alpha);
0AA5: call_function 0x5893B0 num_params 4 pop 4 [ped] [x] [y] [alpha]
</pre>

#### CHud::DrawPlayerInfo

<pre>
plugin::Call<0x58EAF0>();
0AA5: call_function 0x58EAF0 num_params 0 pop 0
</pre>

#### CHud::DrawTripSkip

<pre>
plugin::Call<0x58A160>();
0AA5: call_function 0x58A160 num_params 0 pop 0
</pre>

#### CHud::DrawWanted

<pre>
plugin::Call<0x58D9A0>();
0AA5: call_function 0x58D9A0 num_params 0 pop 0
</pre>

#### CHud::DrawWeaponIcon

<pre>
plugin::Call<0x58D7D0, CPed*, int, int, float>(ped, x, y, alpha);
0AA5: call_function 0x58D7D0 num_params 4 pop 4 [ped] [x] [y] [alpha]
</pre>

#### CHud::RenderArmorBar

<pre>
plugin::Call<0x5890A0, int, int, int>(playerId, x, y);
0AA5: call_function 0x5890A0 num_params 3 pop 3 [playerId] [x] [y]
</pre>

#### CHud::RenderBreathBar

<pre>
plugin::Call<0x589190, int, int, int>(playerId, x, y);
0AA5: call_function 0x589190 num_params 3 pop 3 [playerId] [x] [y]
</pre>

#### CHud::RenderHealthBar

<pre>
plugin::Call<0x589270, int, int, int>(playerId, x, y);
0AA5: call_function 0x589270 num_params 3 pop 3 [playerId] [x] [y]
</pre>

### plugin_sa\game_sa\CIplStore.cpp

#### CIplStore::AddIplSlot

<pre>
plugin::CallAndReturn<int, 0x405AC0, char const*>(name);
0AA7: call_function_return 0x405AC0 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CIplStore::AddIplsNeededAtPosn

<pre>
plugin::Call<0x4045B0, CVector const&>(posn);
0AA5: call_function 0x4045B0 num_params 1 pop 1 [posn]
</pre>

#### CIplStore::ClearIplsNeededAtPosn

<pre>
plugin::Call<0x4045E0>();
0AA5: call_function 0x4045E0 num_params 0 pop 0
</pre>

#### CIplStore::EnableDynamicStreaming

<pre>
plugin::Call<0x404D30, int, bool>(iplSlotIndex, enable);
0AA5: call_function 0x404D30 num_params 2 pop 2 [iplSlotIndex] [enable]
</pre>

#### CIplStore::EnsureIplsAreInMemory

<pre>
plugin::Call<0x4053F0, CVector const&>(posn);
0AA5: call_function 0x4053F0 num_params 1 pop 1 [posn]
</pre>

#### CIplStore::FindIplSlot

<pre>
plugin::CallAndReturn<int, 0x404AC0, char const*>(name);
0AA7: call_function_return 0x404AC0 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CIplStore::GetBoundingBox

<pre>
plugin::CallAndReturn<CRect*, 0x404C70, int>(iplSlotIndex);
0AA7: call_function_return 0x404C70 num_params 1 pop 1 [iplSlotIndex] func_ret [CRect*]
</pre>

#### CIplStore::GetIplEntityIndexArray

<pre>
plugin::CallAndReturn<int*, 0x4047B0, int>(arrayIndex);
0AA7: call_function_return 0x4047B0 num_params 1 pop 1 [arrayIndex] func_ret [int*]
</pre>

#### CIplStore::GetIplName

<pre>
plugin::CallAndReturn<char*, 0x404A60, int>(iplSlotIndex);
0AA7: call_function_return 0x404A60 num_params 1 pop 1 [iplSlotIndex] func_ret [char*]
</pre>

#### CIplStore::GetNewIplEntityIndexArray

<pre>
plugin::CallAndReturn<int, 0x404780, int>(entitiesCount);
0AA7: call_function_return 0x404780 num_params 1 pop 1 [entitiesCount] func_ret [int]
</pre>

#### CIplStore::HaveIplsLoaded

<pre>
plugin::CallAndReturn<bool, 0x405600, CVector const&, int>(coords, playerNumber);
0AA7: call_function_return 0x405600 num_params 2 pop 2 [coords] [playerNumber] func_ret [bool]
</pre>

#### CIplStore::IncludeEntity

<pre>
plugin::Call<0x404C90, int, CEntity*>(iplSlotIndex, entity);
0AA5: call_function 0x404C90 num_params 2 pop 2 [iplSlotIndex] [entity]
</pre>

#### CIplStore::Initialise

<pre>
plugin::Call<0x405EC0>();
0AA5: call_function 0x405EC0 num_params 0 pop 0
</pre>

#### CIplStore::Load

<pre>
plugin::CallAndReturn<bool, 0x5D54A0>();
0AA7: call_function_return 0x5D54A0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CIplStore::LoadAllRemainingIpls

<pre>
plugin::Call<0x405780>();
0AA5: call_function 0x405780 num_params 0 pop 0
</pre>

#### CIplStore::LoadIpl

<pre>
plugin::CallAndReturn<bool, 0x406080, int, unsigned char*, int>(iplSlotIndex, data, dataSize);
0AA7: call_function_return 0x406080 num_params 3 pop 3 [iplSlotIndex] [data] [dataSize] func_ret [bool]
</pre>

#### CIplStore::LoadIplBoundingBox

<pre>
plugin::CallAndReturn<bool, 0x405C00, int, unsigned char*, int>(iplSlotIndex, data, dataSize);
0AA7: call_function_return 0x405C00 num_params 3 pop 3 [iplSlotIndex] [data] [dataSize] func_ret [bool]
</pre>

#### CIplStore::LoadIpls

<pre>
plugin::Call<0x405170, CVector, bool>(posn, arg1);
0AA5: call_function 0x405170 num_params 2 pop 2 [posn] [arg1]
</pre>

#### CIplStore::RemoveAllIpls

<pre>
plugin::Call<0x405720>();
0AA5: call_function 0x405720 num_params 0 pop 0
</pre>

#### CIplStore::RemoveIpl

<pre>
plugin::Call<0x404B20, int>(iplSlotIndex);
0AA5: call_function 0x404B20 num_params 1 pop 1 [iplSlotIndex]
</pre>

#### CIplStore::RemoveIplAndIgnore

<pre>
plugin::Call<0x405890, int>(iplSlotIndex);
0AA5: call_function 0x405890 num_params 1 pop 1 [iplSlotIndex]
</pre>

#### CIplStore::RemoveIplSlot

<pre>
plugin::Call<0x405B60, int>(iplSlotIndex);
0AA5: call_function 0x405B60 num_params 1 pop 1 [iplSlotIndex]
</pre>

#### CIplStore::RemoveIplWhenFarAway

<pre>
plugin::Call<0x4058D0, int>(iplSlotIndex);
0AA5: call_function 0x4058D0 num_params 1 pop 1 [iplSlotIndex]
</pre>

#### CIplStore::RemoveRelatedIpls

<pre>
plugin::Call<0x405110, int>(entityArraysIndex);
0AA5: call_function 0x405110 num_params 1 pop 1 [entityArraysIndex]
</pre>

#### CIplStore::RequestIplAndIgnore

<pre>
plugin::Call<0x405850, int>(iplSlotIndex);
0AA5: call_function 0x405850 num_params 1 pop 1 [iplSlotIndex]
</pre>

#### CIplStore::RequestIpls

<pre>
plugin::Call<0x405520, CVector const&, int>(posn, playerNumber);
0AA5: call_function 0x405520 num_params 2 pop 2 [posn] [playerNumber]
</pre>

#### CIplStore::Save

<pre>
plugin::CallAndReturn<bool, 0x5D5420>();
0AA7: call_function_return 0x5D5420 num_params 0 pop 0 func_ret [bool]
</pre>

#### CIplStore::SetIplsRequired

<pre>
plugin::Call<0x404700, CVector const&, int>(posn, playerNumber);
0AA5: call_function 0x404700 num_params 2 pop 2 [posn] [playerNumber]
</pre>

#### CIplStore::SetIsInterior

<pre>
plugin::Call<0x404A90, int, bool>(iplSlotIndex, isInterior);
0AA5: call_function 0x404A90 num_params 2 pop 2 [iplSlotIndex] [isInterior]
</pre>

#### CIplStore::SetupRelatedIpls

<pre>
plugin::CallAndReturn<int, 0x404DE0, char const*, int, CEntity**>(iplName, entityArraysIndex, instances);
0AA7: call_function_return 0x404DE0 num_params 3 pop 3 [iplName] [entityArraysIndex] [instances] func_ret [int]
</pre>

#### CIplStore::Shutdown

<pre>
plugin::Call<0x405FA0>();
0AA5: call_function 0x405FA0 num_params 0 pop 0
</pre>

#### SetIfInteriorIplIsRequired

<pre>
plugin::Call<0x4045F0, CVector2D const&, void*>(posn, data);
0AA5: call_function 0x4045F0 num_params 2 pop 2 [posn] [data]
</pre>

#### SetIfIplIsRequired

<pre>
plugin::Call<0x404660, CVector2D const&, void*>(posn, data);
0AA5: call_function 0x404660 num_params 2 pop 2 [posn] [data]
</pre>

#### SetIfIplIsRequiredReducedBB

<pre>
plugin::Call<0x404690, CVector2D const&, void*>(posn, data);
0AA5: call_function 0x404690 num_params 2 pop 2 [posn] [data]
</pre>

### plugin_sa\game_sa\CLoadedCarGroup.cpp

#### CLoadedCarGroup::SortBasedOnUsage

<pre>
plugin::CallMethod<0x611E10, CLoadedCarGroup *>(this);
0AA6: call_method 0x611E10 struct [CLoadedCarGroup] num_params 0 pop 0
</pre>

#### CLoadedCarGroup::RemoveMember

<pre>
plugin::CallMethodAndReturn<int, 0x611BD0, CLoadedCarGroup *, int>(this, modelindex);
0AA8: call_method_return 0x611BD0 struct [CLoadedCarGroup] num_params 1 pop 0 [modelindex] func_ret [int]
</pre>

#### CLoadedCarGroup::PickRandomCar

<pre>
plugin::CallMethodAndReturn<int, 0x611C50, CLoadedCarGroup *, bool, bool>(this, arg1, arg2);
0AA8: call_method_return 0x611C50 struct [CLoadedCarGroup] num_params 2 pop 0 [arg1] [arg2] func_ret [int]
</pre>

#### CLoadedCarGroup::PickLeastUsedModel

<pre>
plugin::CallMethodAndReturn<int, 0x611E90, CLoadedCarGroup *, int>(this, minRefs);
0AA8: call_method_return 0x611E90 struct [CLoadedCarGroup] num_params 1 pop 0 [minRefs] func_ret [int]
</pre>

#### CLoadedCarGroup::GetMember

<pre>
plugin::CallMethodAndReturn<int, 0x611C20, CLoadedCarGroup *, int>(this, count);
0AA8: call_method_return 0x611C20 struct [CLoadedCarGroup] num_params 1 pop 0 [count] func_ret [int]
</pre>

#### CLoadedCarGroup::CountMembers

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x611C30, CLoadedCarGroup *>(this);
0AA8: call_method_return 0x611C30 struct [CLoadedCarGroup] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CLoadedCarGroup::Clear

<pre>
plugin::CallMethod<0x611B90, CLoadedCarGroup *>(this);
0AA6: call_method 0x611B90 struct [CLoadedCarGroup] num_params 0 pop 0
</pre>

#### CLoadedCarGroup::AddMember

<pre>
plugin::CallMethod<0x611BB0, CLoadedCarGroup *, int>(this, member);
0AA6: call_method 0x611BB0 struct [CLoadedCarGroup] num_params 1 pop 0 [member]
</pre>

### plugin_sa\game_sa\CLoadingScreen.cpp

#### CLoadingScreen::Shutdown

<pre>
plugin::Call<0x58FF10>();
0AA5: call_function 0x58FF10 num_params 0 pop 0
</pre>

#### CLoadingScreen::RenderSplash

<pre>
plugin::Call<0x58FF60>();
0AA5: call_function 0x58FF60 num_params 0 pop 0
</pre>

#### CLoadingScreen::LoadSplashes

<pre>
plugin::Call<0x5900B0, unsigned char, unsigned char>(bStarting, bNvidia);
0AA5: call_function 0x5900B0 num_params 2 pop 2 [bStarting] [bNvidia]
</pre>

#### CLoadingScreen::DisplayMessage

<pre>
plugin::Call<0x590220, char const*>(message);
0AA5: call_function 0x590220 num_params 1 pop 1 [message]
</pre>

#### CLoadingScreen::SetLoadingBarMsg

<pre>
plugin::Call<0x590240, char const*, char const*>(msg1, msg2);
0AA5: call_function 0x590240 num_params 2 pop 2 [msg1] [msg2]
</pre>

#### CLoadingScreen::GetClockTime

<pre>
plugin::CallAndReturn<double, 0x590280, bool>(bIgnorePauseTime);
0AA7: call_function_return 0x590280 num_params 1 pop 1 [bIgnorePauseTime] func_ret [double]
</pre>

#### CLoadingScreen::Init

<pre>
plugin::Call<0x5902B0, bool, bool>(unusedflag, bLoaded);
0AA5: call_function 0x5902B0 num_params 2 pop 2 [unusedflag] [bLoaded]
</pre>

#### CLoadingScreen::Continue

<pre>
plugin::Call<0x590320>();
0AA5: call_function 0x590320 num_params 0 pop 0
</pre>

#### CLoadingScreen::RenderLoadingBar

<pre>
plugin::Call<0x590370>();
0AA5: call_function 0x590370 num_params 0 pop 0
</pre>

#### CLoadingScreen::DisplayNextSplash

<pre>
plugin::Call<0x5904D0>();
0AA5: call_function 0x5904D0 num_params 0 pop 0
</pre>

#### CLoadingScreen::StartFading

<pre>
plugin::Call<0x590530>();
0AA5: call_function 0x590530 num_params 0 pop 0
</pre>

#### CLoadingScreen::DisplayPCScreen

<pre>
plugin::Call<0x590570>();
0AA5: call_function 0x590570 num_params 0 pop 0
</pre>

#### CLoadingScreen::Update

<pre>
plugin::Call<0x5905E0>();
0AA5: call_function 0x5905E0 num_params 0 pop 0
</pre>

#### CLoadingScreen::DoPCTitleFadeOut

<pre>
plugin::Call<0x590990>();
0AA5: call_function 0x590990 num_params 0 pop 0
</pre>

#### CLoadingScreen::DoPCTitleFadeIn

<pre>
plugin::Call<0x590860>();
0AA5: call_function 0x590860 num_params 0 pop 0
</pre>

#### CLoadingScreen::DoPCScreenChange

<pre>
plugin::Call<0x590AC0, unsigned int>(bFinish);
0AA5: call_function 0x590AC0 num_params 1 pop 1 [bFinish]
</pre>

#### CLoadingScreen::NewChunkLoaded

<pre>
plugin::Call<0x590D00>();
0AA5: call_function 0x590D00 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CMatrix.cpp

#### CMatrix::Scale

<pre>
plugin::CallMethod<0x459350, CMatrix *, float>(this, scale);
0AA6: call_method 0x459350 struct [CMatrix] num_params 1 pop 0 [scale]
</pre>

#### CMatrix::Scale

<pre>
plugin::CallMethod<0x459350, CMatrix *, float, float, float>(this, x, y, z);
0AA6: call_method 0x459350 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]
</pre>

### plugin_sa\game_sa\CMatrixLink.cpp

#### CMatrixLink::Insert

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *, CMatrixLink *>(gaddrof(CMatrixLink::Insert), this, where);
0AA6: call_method 0x54E8F0 struct [CMatrixLink] num_params 1 pop 0 [where]
</pre>

#### CMatrixLink::Remove

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(gaddrof(CMatrixLink::Remove), this);
0AA6: call_method 0x54E910 struct [CMatrixLink] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CMenuManager.cpp

#### CMenuManager::CMenuManager

<pre>
plugin::CallMethod<0x574350, CMenuManager*>(this);
0AA6: call_method 0x574350 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::~CMenuManager

<pre>
plugin::CallMethod<0x579440, CMenuManager*>(this);
0AA6: call_method 0x579440 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::AdditionalOptionInput

<pre>
plugin::CallMethodAndReturn<char, 0x5773D0, CMenuManager*, char, char>(this, input, enter);
0AA8: call_method_return 0x5773D0 struct [CMenuManager] num_params 2 pop 0 [input] [enter] func_ret [char]
</pre>

#### CMenuManager::CentreMousePointer

<pre>
plugin::CallMethod<0x57C520, CMenuManager*>(this);
0AA6: call_method 0x57C520 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::CheckCodesForControls

<pre>
plugin::CallMethodAndReturn<char, 0x57DB20, CMenuManager*, int>(this, code);
0AA8: call_method_return 0x57DB20 struct [CMenuManager] num_params 1 pop 0 [code] func_ret [char]
</pre>

#### CMenuManager::CheckFrontEndDownInput

<pre>
plugin::CallMethodAndReturn<char, 0x5738B0, CMenuManager*>(this);
0AA8: call_method_return 0x5738B0 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::CheckFrontEndLeftInput

<pre>
plugin::CallMethodAndReturn<char, 0x573920, CMenuManager*>(this);
0AA8: call_method_return 0x573920 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::CheckFrontEndRightInput

<pre>
plugin::CallMethodAndReturn<char, 0x573990, CMenuManager*>(this);
0AA8: call_method_return 0x573990 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::CheckFrontEndUpInput

<pre>
plugin::CallMethodAndReturn<char, 0x573840, CMenuManager*>(this);
0AA8: call_method_return 0x573840 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::CheckHover

<pre>
plugin::CallMethodAndReturn<bool, 0x57C4F0, CMenuManager*>(this, x1, x2, y1, y2);
0AA8: call_method_return 0x57C4F0 struct [CMenuManager] num_params 4 pop 0 [x1] [x2] [y1] [y2] func_ret [bool]
</pre>

#### CMenuManager::CheckMissionPackValidMenu

<pre>
plugin::CallMethodAndReturn<char, 0x57D720, CMenuManager*>(this);
0AA8: call_method_return 0x57D720 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::CheckRedefineControlInput

<pre>
plugin::CallMethodAndReturn<char, 0x57E4D0, CMenuManager*>(this);
0AA8: call_method_return 0x57E4D0 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::CheckSliderMovement

<pre>
plugin::CallMethod<0x57E4D0, CMenuManager*>(this, input);
0AA6: call_method 0x57E4D0 struct [CMenuManager] num_params 1 pop 0 [input]
</pre>

#### CMenuManager::DisplayHelperText

<pre>
plugin::CallMethod<0x57E4D0, CMenuManager*>(this, text);
0AA6: call_method 0x57E4D0 struct [CMenuManager] num_params 1 pop 0 [text]
</pre>

#### CMenuManager::DisplaySlider

<pre>
plugin::CallMethodAndReturn<int, 0x576860, CMenuManager*>(this, posX, posY, beginHeight, endHeight, distBetweenRects, filledAmount, colour);
0AA8: call_method_return 0x576860 struct [CMenuManager] num_params 7 pop 0 [posX] [posY] [beginHeight] [endHeight] [distBetweenRects] [filledAmount] [colour] func_ret [int]
</pre>

#### CMenuManager::DoSettingsBeforeStartingAGame

<pre>
plugin::CallMethodAndReturn<signed int, 0x573330, CMenuManager*>(this);
0AA8: call_method_return 0x573330 struct [CMenuManager] num_params 0 pop 0 func_ret [signed int]
</pre>

#### CMenuManager::DrawBackground

<pre>
plugin::CallMethodAndReturn<char, 0x57B750, CMenuManager*>(this);
0AA8: call_method_return 0x57B750 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::DrawControllerScreenExtraText

<pre>
plugin::CallMethodAndReturn<char, 0x57D8D0, CMenuManager*>(this, unk);
0AA8: call_method_return 0x57D8D0 struct [CMenuManager] num_params 1 pop 0 [unk] func_ret [char]
</pre>

#### CMenuManager::DrawControllerSetupScreen

<pre>
plugin::CallMethodAndReturn<char, 0x57F300, CMenuManager*>(this);
0AA8: call_method_return 0x57F300 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::DrawFrontEnd

<pre>
plugin::CallMethod<0x57C290, CMenuManager*>(this);
0AA6: call_method 0x57C290 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::DrawQuitGameScreen

<pre>
plugin::CallMethod<0x57D860, CMenuManager*>(this, unused);
0AA6: call_method 0x57D860 struct [CMenuManager] num_params 1 pop 0 [unused]
</pre>

#### CMenuManager::DrawStandardMenu

<pre>
plugin::CallMethod<0x5794A0, CMenuManager*>(this, header);
0AA6: call_method 0x5794A0 struct [CMenuManager] num_params 1 pop 0 [header]
</pre>

#### CMenuManager::DrawWindow

<pre>
plugin::CallMethod<0x573EE0, CMenuManager*>(this, coords, pKey, nColour, backColor, Unused, bBackground);
0AA6: call_method 0x573EE0 struct [CMenuManager] num_params 6 pop 0 [coords] [pKey] [nColour] [backColor] [Unused] [bBackground]
</pre>

#### CMenuManager::DrawWindowedText

<pre>
plugin::CallMethod<0x578F50, CMenuManager*>(this, x1, y1, x2, y2, gxt, align);
0AA6: call_method 0x578F50 struct [CMenuManager] num_params 6 pop 0 [x1] [y1] [x2] [y2] [gxt] [align]
</pre>

#### CMenuManager::GetNumberOfMenuOptions

<pre>
plugin::CallMethodAndReturn<unsigned char, 0x573E70, CMenuManager*>(this);
0AA8: call_method_return 0x573E70 struct [CMenuManager] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### CMenuManager::HasLanguageChanged

<pre>
plugin::CallMethodAndReturn<bool, 0x573CD0, CMenuManager*>(this);
0AA8: call_method_return 0x573CD0 struct [CMenuManager] num_params 0 pop 0 func_ret [bool]
</pre>

#### CMenuManager::Initialise

<pre>
plugin::CallMethod<0x5744D0, CMenuManager*>(this);
0AA6: call_method 0x5744D0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::InitialiseChangedLanguageSettings

<pre>
plugin::CallMethod<0x573260, CMenuManager*>(this, reInitControls);
0AA6: call_method 0x573260 struct [CMenuManager] num_params 1 pop 0 [reInitControls]
</pre>

#### CMenuManager::JumpToGenericMessageScreen

<pre>
plugin::CallMethodAndReturn<int, 0x576AE0, CMenuManager*>(this, screen, header, action);
0AA8: call_method_return 0x576AE0 struct [CMenuManager] num_params 3 pop 0 [screen] [header] [action] func_ret [int]
</pre>

#### CMenuManager::LoadAllTextures

<pre>
plugin::CallMethod<0x572EC0, CMenuManager*>(this);
0AA6: call_method 0x572EC0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::LoadSettings

<pre>
plugin::CallMethod<0x57C8F0, CMenuManager*>(this);
0AA6: call_method 0x57C8F0 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::MessageScreen

<pre>
plugin::CallMethod<0x579330, CMenuManager*>(this, message, col, frame);
0AA6: call_method 0x579330 struct [CMenuManager] num_params 3 pop 0 [message] [col] [frame]
</pre>

#### CMenuManager::PrintBriefs

<pre>
plugin::CallMethodAndReturn<float, 0x576320, CMenuManager*>(this);
0AA8: call_method_return 0x576320 struct [CMenuManager] num_params 0 pop 0 func_ret [float]
</pre>

#### CMenuManager::PrintMap

<pre>
plugin::CallMethodAndReturn<char, 0x575130, CMenuManager*>(this);
0AA8: call_method_return 0x575130 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::PrintRadioStationList

<pre>
plugin::CallMethodAndReturn<char, 0x5746F0, CMenuManager*>(this);
0AA8: call_method_return 0x5746F0 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::PrintStats

<pre>
plugin::CallMethodAndReturn<char, 0x574900, CMenuManager*>(this);
0AA8: call_method_return 0x574900 struct [CMenuManager] num_params 0 pop 0 func_ret [char]
</pre>

#### CMenuManager::Process

<pre>
plugin::CallMethodAndReturn<int, 0x57B440, CMenuManager*>(this);
0AA8: call_method_return 0x57B440 struct [CMenuManager] num_params 0 pop 0 func_ret [int]
</pre>

#### CMenuManager::ProcessFileActions

<pre>
plugin::CallMethod<0x578D60, CMenuManager*>(this);
0AA6: call_method 0x578D60 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::ProcessMenuOptions

<pre>
plugin::CallMethod<0x576FE0, CMenuManager*>(this, input, exit, enter);
0AA6: call_method 0x576FE0 struct [CMenuManager] num_params 3 pop 0 [input] [exit] [enter]
</pre>

#### CMenuManager::ProcessMissionPackNewGame

<pre>
plugin::CallMethod<0x57D520, CMenuManager*>(this);
0AA6: call_method 0x57D520 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::ProcessPCMenuOptions

<pre>
plugin::CallMethodAndReturn<char, 0x57CD50, CMenuManager*>(this, input, enter);
0AA8: call_method_return 0x57CD50 struct [CMenuManager] num_params 2 pop 0 [input] [enter] func_ret [char]
</pre>

#### CMenuManager::ProcessStreaming

<pre>
plugin::CallMethod<0x573CF0, CMenuManager*>(this, all);
0AA6: call_method 0x573CF0 struct [CMenuManager] num_params 1 pop 0 [all]
</pre>

#### CMenuManager::ProcessUserInput

<pre>
plugin::CallMethod<0x57B480, CMenuManager*>(this, down, up, enter, exit, input);
0AA6: call_method 0x57B480 struct [CMenuManager] num_params 5 pop 0 [down] [up] [enter] [exit] [input]
</pre>

#### CMenuManager::RedefineScreenUserInput

<pre>
plugin::CallMethodAndReturn<char, 0x57EF50, CMenuManager*>(this, enter, exit);
0AA8: call_method_return 0x57EF50 struct [CMenuManager] num_params 2 pop 0 [enter] [exit] func_ret [char]
</pre>

#### CMenuManager::ResetHelperText

<pre>
plugin::CallMethod<0x57CD30, CMenuManager*>(this);
0AA6: call_method 0x57CD30 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SaveLoadFileError_SetUpErrorScreen

<pre>
plugin::CallMethod<0x57C490, CMenuManager*>(this);
0AA6: call_method 0x57C490 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SaveSettings

<pre>
plugin::CallMethod<0x57C660, CMenuManager*>(this);
0AA6: call_method 0x57C660 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SaveStatsToFile

<pre>
plugin::CallMethodAndReturn<int, 0x57DDE0, CMenuManager*>(this);
0AA8: call_method_return 0x57DDE0 struct [CMenuManager] num_params 0 pop 0 func_ret [int]
</pre>

#### CMenuManager::ScrollRadioStations

<pre>
plugin::CallMethod<0x573A00, CMenuManager*>(this, input);
0AA6: call_method 0x573A00 struct [CMenuManager] num_params 1 pop 0 [input]
</pre>

#### CMenuManager::SetDefaultPreferences

<pre>
plugin::CallMethodAndReturn<char, 0x573AE0, CMenuManager*>(this, page);
0AA8: call_method_return 0x573AE0 struct [CMenuManager] num_params 1 pop 0 [page] func_ret [char]
</pre>

#### CMenuManager::SetFrontEndRenderStates

<pre>
plugin::CallMethod<0x573A60, CMenuManager*>(this);
0AA6: call_method 0x573A60 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SetHelperText

<pre>
plugin::CallMethodAndReturn<int, 0x57CD10, CMenuManager*>(this, index);
0AA8: call_method_return 0x57CD10 struct [CMenuManager] num_params 1 pop 0 [index] func_ret [int]
</pre>

#### CMenuManager::SmallMessageScreen

<pre>
plugin::CallMethod<0x574010, CMenuManager*>(this, message);
0AA6: call_method 0x574010 struct [CMenuManager] num_params 1 pop 0 [message]
</pre>

#### CMenuManager::StretchX

<pre>
plugin::CallMethodAndReturn<float, 0x5733E0, CMenuManager*>(this, x);
0AA8: call_method_return 0x5733E0 struct [CMenuManager] num_params 1 pop 0 [x] func_ret [float]
</pre>

#### CMenuManager::StretchY

<pre>
plugin::CallMethodAndReturn<float, 0x573410, CMenuManager*>(this, y);
0AA8: call_method_return 0x573410 struct [CMenuManager] num_params 1 pop 0 [y] func_ret [float]
</pre>

#### CMenuManager::SwapTexturesRound

<pre>
plugin::CallMethod<0x5730A0, CMenuManager*>(this, force);
0AA6: call_method 0x5730A0 struct [CMenuManager] num_params 1 pop 0 [force]
</pre>

#### CMenuManager::SwitchMenuOnAndOff

<pre>
plugin::CallMethod<0x576B70, CMenuManager*>(this);
0AA6: call_method 0x576B70 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::SwitchToNewScreen

<pre>
plugin::CallMethodAndReturn<char, 0x573680, CMenuManager*>(this, page);
0AA8: call_method_return 0x573680 struct [CMenuManager] num_params 1 pop 0 [page] func_ret [char]
</pre>

#### CMenuManager::UnloadTextures

<pre>
plugin::CallMethod<0x574630, CMenuManager*>(this);
0AA6: call_method 0x574630 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::UserInput

<pre>
plugin::CallMethod<0x57FD70, CMenuManager*>(this);
0AA6: call_method 0x57FD70 struct [CMenuManager] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CMirrors.cpp

#### CMirrors::BeforeConstructRenderList

<pre>
plugin::Call<0x726DF0>();
0AA5: call_function 0x726DF0 num_params 0 pop 0
</pre>

#### CMirrors::BeforeMainRender

<pre>
plugin::Call<0x727140>();
0AA5: call_function 0x727140 num_params 0 pop 0
</pre>

#### CMirrors::BuildCamMatrix

<pre>
plugin::Call<0x723150, CMatrix*, CVector, CVector>(mat, pointA, pointB);
0AA5: call_function 0x723150 num_params 3 pop 3 [mat] [pointA] [pointB]
</pre>

#### CMirrors::BuildCameraMatrixForScreens

<pre>
plugin::Call<0x7266B0, CMatrix*>(mat);
0AA5: call_function 0x7266B0 num_params 1 pop 1 [mat]
</pre>

#### CMirrors::CreateBuffer

<pre>
plugin::Call<0x7230A0>();
0AA5: call_function 0x7230A0 num_params 0 pop 0
</pre>

#### CMirrors::Init

<pre>
plugin::Call<0x723000>();
0AA5: call_function 0x723000 num_params 0 pop 0
</pre>

#### CMirrors::RenderMirrorBuffer

<pre>
plugin::Call<0x726090>();
0AA5: call_function 0x726090 num_params 0 pop 0
</pre>

#### CMirrors::ShutDown

<pre>
plugin::Call<0x723050>();
0AA5: call_function 0x723050 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CModelInfo.cpp

#### \*CModelInfo::GetModelInfo

<pre>
plugin::CallAndReturn<CBaseModelInfo *, 0x403DA0, int>(index);
0AA7: call_function_return 0x403DA0 num_params 1 pop 1 [index] func_ret [CBaseModelInfo *]
</pre>

### plugin_sa\game_sa\CModelInfoAccelerator.cpp

#### CModelInfoAccelerator::Init

<pre>
plugin::CallMethod<0x4C6A80, CModelInfoAccelerator *>(this);
0AA6: call_method 0x4C6A80 struct [CModelInfoAccelerator] num_params 0 pop 0
</pre>

#### CModelInfoAccelerator::AddModelInfoId

<pre>
plugin::CallMethod<0x4C6AA0, CModelInfoAccelerator *, unsigned short>(this, modelId);
0AA6: call_method 0x4C6AA0 struct [CModelInfoAccelerator] num_params 1 pop 0 [modelId]
</pre>

#### CModelInfoAccelerator::GetNextModelInfoId

<pre>
plugin::CallMethodAndReturn<unsigned short, 0x4C6AC0, CModelInfoAccelerator *>(this);
0AA8: call_method_return 0x4C6AC0 struct [CModelInfoAccelerator] num_params 0 pop 0 func_ret [unsigned short]
</pre>

#### CModelInfoAccelerator::AllocModelInfoIds

<pre>
plugin::CallMethod<0x4C6AE0, CModelInfoAccelerator *>(this);
0AA6: call_method 0x4C6AE0 struct [CModelInfoAccelerator] num_params 0 pop 0
</pre>

#### CModelInfoAccelerator::FreeModelInfoIds

<pre>
plugin::CallMethod<0x4C6B10, CModelInfoAccelerator *>(this);
0AA6: call_method 0x4C6B10 struct [CModelInfoAccelerator] num_params 0 pop 0
</pre>

#### CModelInfoAccelerator::GetEntry

<pre>
plugin::CallMethod<0x4C6B30, CModelInfoAccelerator *, CBaseModelInfo**, int*, char*>(this, arg0, arg1, arg2);
0AA6: call_method 0x4C6B30 struct [CModelInfoAccelerator] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CModelInfoAccelerator::End

<pre>
plugin::CallMethod<0x4C6B40, CModelInfoAccelerator *, char*>(this, arg0);
0AA6: call_method 0x4C6B40 struct [CModelInfoAccelerator] num_params 1 pop 0 [arg0]
</pre>

#### CModelInfoAccelerator::CModelInfoAccelerator

<pre>
plugin::CallMethod<0x4C6B50, CModelInfoAccelerator *>(this);
0AA6: call_method 0x4C6B50 struct [CModelInfoAccelerator] num_params 0 pop 0
</pre>

#### CModelInfoAccelerator::GetModelInfoIdFile

<pre>
plugin::CallMethodAndReturn<bool, 0x4C6B70, CModelInfoAccelerator *>(this);
0AA8: call_method_return 0x4C6B70 struct [CModelInfoAccelerator] num_params 0 pop 0 func_ret [bool]
</pre>

#### CModelInfoAccelerator::EndOfLoadPhase

<pre>
plugin::CallMethod<0x4C6BD0, CModelInfoAccelerator *>(this);
0AA6: call_method 0x4C6BD0 struct [CModelInfoAccelerator] num_params 0 pop 0
</pre>

#### CModelInfoAccelerator::Begin

<pre>
plugin::CallMethodAndReturn<bool, 0x4C6C20, CModelInfoAccelerator *, char*>(this, filePath);
0AA8: call_method_return 0x4C6C20 struct [CModelInfoAccelerator] num_params 1 pop 0 [filePath] func_ret [bool]
</pre>

### plugin_sa\game_sa\CMotionBlurStreaks.cpp

#### CMotionBlurStreaks::Update

<pre>
plugin::Call<0x7240C0>();
0AA5: call_function 0x7240C0 num_params 0 pop 0
</pre>

#### CMotionBlurStreaks::Render

<pre>
plugin::Call<0x7240E0>();
0AA5: call_function 0x7240E0 num_params 0 pop 0
</pre>

#### CMotionBlurStreaks::RegisterStreak

<pre>
plugin::Call<0x721DC0, unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(id, red, green, blue, leftPoint, rightPoint);
0AA5: call_function 0x721DC0 num_params 6 pop 6 [id] [red] [green] [blue] [leftPoint] [rightPoint]
</pre>

#### CMotionBlurStreaks::Init

<pre>
plugin::Call<0x721D90>();
0AA5: call_function 0x721D90 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\COctTree.cpp

#### COctTree::InsertTree

<pre>
plugin::CallVirtualMethodAndReturn<bool, 0, COctTree *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);
</pre>

#### COctTree::FillPalette

<pre>
plugin::CallVirtualMethod<1, COctTree *, unsigned char*>(this, colors);
</pre>

#### COctTree::COctTree

<pre>
plugin::CallMethod<0x5A6DB0, COctTree *>(this);
0AA6: call_method 0x5A6DB0 struct [COctTree] num_params 0 pop 0
</pre>

#### COctTree::FindNearestColour

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A71E0, COctTree *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);
0AA8: call_method_return 0x5A71E0 struct [COctTree] num_params 3 pop 0 [colorRed] [colorGreen] [colorBlue] func_ret [unsigned int]
</pre>

#### COctTree::InitPool

<pre>
plugin::CallMethod<0x5A7460, COctTree *, void*, int>(this, data, dataSize);
0AA6: call_method 0x5A7460 struct [COctTree] num_params 2 pop 0 [data] [dataSize]
</pre>

#### COctTree::NoOfChildren

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A6DE0, COctTree *>(this);
0AA8: call_method_return 0x5A6DE0 struct [COctTree] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### COctTree::ReduceTree

<pre>
plugin::CallMethod<0x5A7040, COctTree *>(this);
0AA6: call_method 0x5A7040 struct [COctTree] num_params 0 pop 0
</pre>

#### COctTree::RemoveChildren

<pre>
plugin::CallMethod<0x5A74F0, COctTree *>(this);
0AA6: call_method 0x5A74F0 struct [COctTree] num_params 0 pop 0
</pre>

#### COctTree::ShutdownPool

<pre>
plugin::CallMethod<0x5A6F70, COctTree *>(this);
0AA6: call_method 0x5A6F70 struct [COctTree] num_params 0 pop 0
</pre>

#### COctTree::empty

<pre>
plugin::CallMethod<0x5A6FC0, COctTree *>(this);
0AA6: call_method 0x5A6FC0 struct [COctTree] num_params 0 pop 0
</pre>

#### COctTree::operator delete

<pre>
plugin::Call<0x5A7420, void*>(data);
0AA5: call_function 0x5A7420 num_params 1 pop 1 [data]
</pre>

#### COctTree::operator new

<pre>
plugin::CallAndReturn<void*, 0x5A7410, unsigned int>(size);
0AA7: call_function_return 0x5A7410 num_params 1 pop 1 [size] func_ret [void*]
</pre>

### plugin_sa\game_sa\COctTreeBase.cpp

#### COctTreeBase::COctTreeBase

<pre>
plugin::CallMethod<0x5A7570, COctTreeBase *>(this);
0AA6: call_method 0x5A7570 struct [COctTreeBase] num_params 0 pop 0
</pre>

#### COctTreeBase::Init

<pre>
plugin::CallMethod<0x5A7260, COctTreeBase *, int>(this, numBranches);
0AA6: call_method 0x5A7260 struct [COctTreeBase] num_params 1 pop 0 [numBranches]
</pre>

#### COctTreeBase::Insert

<pre>
plugin::CallMethodAndReturn<bool, 0x5A7750, COctTreeBase *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);
0AA8: call_method_return 0x5A7750 struct [COctTreeBase] num_params 3 pop 0 [colorRed] [colorGreen] [colorBlue] func_ret [bool]
</pre>

#### COctTreeBase::ReduceBranches

<pre>
plugin::CallMethod<0x5A7840, COctTreeBase *, int>(this, newBranchesCount);
0AA6: call_method 0x5A7840 struct [COctTreeBase] num_params 1 pop 0 [newBranchesCount]
</pre>

### plugin_sa\game_sa\common.cpp

#### RemoveRefsCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x7226D0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x7226D0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### RemoveRefsForAtomic

<pre>
plugin::Call<0x7226F0, RpClump*>(clump);
0AA5: call_function 0x7226F0 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendAllocateData

<pre>
plugin::CallAndReturn<CAnimBlendClumpData*, 0x4D5F50, RpClump*>(clump);
0AA7: call_function_return 0x4D5F50 num_params 1 pop 1 [clump] func_ret [CAnimBlendClumpData*]
</pre>

#### RpAnimBlendClumpAddAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6790, RpClump*, CAnimBlendAssociation*, unsigned int, float, float>(clump, association, flags, startTime, blendAmount);
0AA7: call_function_return 0x4D6790 num_params 5 pop 5 [clump] [association] [flags] [startTime] [blendAmount] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpExtractAssociations

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6BE0, RpClump*>(clump);
0AA7: call_function_return 0x4D6BE0 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpFillFrameArray

<pre>
plugin::Call<0x4D64A0, RpClump*, AnimBlendFrameData**>(clump, frameData);
0AA5: call_function 0x4D64A0 num_params 2 pop 2 [clump] [frameData]
</pre>

#### RpAnimBlendClumpFindBone

<pre>
plugin::CallAndReturn<AnimBlendFrameData*, 0x4D6400, RpClump*, unsigned int>(clump, id);
0AA7: call_function_return 0x4D6400 num_params 2 pop 2 [clump] [id] func_ret [AnimBlendFrameData*]
</pre>

#### RpAnimBlendClumpFindFrame

<pre>
plugin::CallAndReturn<AnimBlendFrameData*, 0x4D62A0, RpClump*, char const*>(clump, name);
0AA7: call_function_return 0x4D62A0 num_params 2 pop 2 [clump] [name] func_ret [AnimBlendFrameData*]
</pre>

#### RpAnimBlendClumpFindFrameFromHashKey

<pre>
plugin::CallAndReturn<AnimBlendFrameData*, 0x4D6370, RpClump*, unsigned int>(clump, key);
0AA7: call_function_return 0x4D6370 num_params 2 pop 2 [clump] [key] func_ret [AnimBlendFrameData*]
</pre>

#### RpAnimBlendClumpGetAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D68E0, RpClump*, bool, CAnimBlendHierarchy*>(clump, arg1, hierarchy);
0AA7: call_function_return 0x4D68E0 num_params 3 pop 3 [clump] [arg1] [hierarchy] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6870, RpClump*, char const*>(clump, name);
0AA7: call_function_return 0x4D6870 num_params 2 pop 2 [clump] [name] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D68B0, RpClump*, unsigned int>(clump, animId);
0AA7: call_function_return 0x4D68B0 num_params 2 pop 2 [clump] [animId] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetFirstAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D15E0, RpClump*>(clump);
0AA7: call_function_return 0x4D15E0 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetFirstAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6A70, RpClump*, unsigned int>(clump, flags);
0AA7: call_function_return 0x4D6A70 num_params 2 pop 2 [clump] [flags] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetMainAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6910, RpClump*, CAnimBlendAssociation**, float*>(clump, pAssociation, blendAmount);
0AA7: call_function_return 0x4D6910 num_params 3 pop 3 [clump] [pAssociation] [blendAmount] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetMainAssociation_N

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6A30, RpClump*, int>(clump, n);
0AA7: call_function_return 0x4D6A30 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetMainPartialAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D69A0, RpClump*>(clump);
0AA7: call_function_return 0x4D69A0 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetMainPartialAssociation_N

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D69F0, RpClump*, int>(clump, n);
0AA7: call_function_return 0x4D69F0 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetNumAssociations

<pre>
plugin::CallAndReturn<unsigned int, 0x4D6B60, RpClump*>(clump);
0AA7: call_function_return 0x4D6B60 num_params 1 pop 1 [clump] func_ret [unsigned int]
</pre>

#### RpAnimBlendClumpGetNumNonPartialAssociations

<pre>
plugin::CallAndReturn<unsigned int, 0x4D6BB0, RpClump*>(clump);
0AA7: call_function_return 0x4D6BB0 num_params 1 pop 1 [clump] func_ret [unsigned int]
</pre>

#### RpAnimBlendClumpGetNumPartialAssociations

<pre>
plugin::CallAndReturn<unsigned int, 0x4D6B80, RpClump*>(clump);
0AA7: call_function_return 0x4D6B80 num_params 1 pop 1 [clump] func_ret [unsigned int]
</pre>

#### RpAnimBlendClumpGiveAssociations

<pre>
plugin::Call<0x4D6C30, RpClump*, CAnimBlendAssociation*>(clump, association);
0AA5: call_function 0x4D6C30 num_params 2 pop 2 [clump] [association]
</pre>

#### RpAnimBlendClumpInit

<pre>
plugin::Call<0x4D6720, RpClump*>(clump);
0AA5: call_function 0x4D6720 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendClumpIsInitialized

<pre>
plugin::CallAndReturn<bool, 0x4D6760, RpClump*>(clump);
0AA7: call_function_return 0x4D6760 num_params 1 pop 1 [clump] func_ret [bool]
</pre>

#### RpAnimBlendClumpPauseAllAnimations

<pre>
plugin::Call<0x4D6B00, RpClump*>(clump);
0AA5: call_function 0x4D6B00 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendClumpRemoveAllAssociations

<pre>
plugin::Call<0x4D6C00, RpClump*>(clump);
0AA5: call_function 0x4D6C00 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendClumpRemoveAssociations

<pre>
plugin::Call<0x4D6820, RpClump*, unsigned int>(clump, flags);
0AA5: call_function 0x4D6820 num_params 2 pop 2 [clump] [flags]
</pre>

#### RpAnimBlendClumpSetBlendDeltas

<pre>
plugin::Call<0x4D67E0, RpClump*, unsigned int, float>(clump, flags, delta);
0AA5: call_function 0x4D67E0 num_params 3 pop 3 [clump] [flags] [delta]
</pre>

#### RpAnimBlendClumpUnPauseAllAnimations

<pre>
plugin::Call<0x4D6B30, RpClump*>(clump);
0AA5: call_function 0x4D6B30 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendClumpUpdateAnimations

<pre>
plugin::Call<0x4D34F0, RpClump*, float, bool>(clump, step, onScreen);
0AA5: call_function 0x4D34F0 num_params 3 pop 3 [clump] [step] [onScreen]
</pre>

#### RpAnimBlendCreateAnimationForHierarchy

<pre>
plugin::CallAndReturn<RtAnimAnimation*, 0x4D60E0, RpHAnimHierarchy*>(hierarchy);
0AA7: call_function_return 0x4D60E0 num_params 1 pop 1 [hierarchy] func_ret [RtAnimAnimation*]
</pre>

#### RpAnimBlendFrameGetName

<pre>
plugin::CallAndReturn<char*, 0x4D5EF0, RwFrame*>(frame);
0AA7: call_function_return 0x4D5EF0 num_params 1 pop 1 [frame] func_ret [char*]
</pre>

#### RpAnimBlendFrameSetName

<pre>
plugin::Call<0x4D5F00, RwFrame*, char*>(frame, name);
0AA5: call_function 0x4D5F00 num_params 2 pop 2 [frame] [name]
</pre>

#### RpAnimBlendGetNextAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6AB0, CAnimBlendAssociation*>(association);
0AA7: call_function_return 0x4D6AB0 num_params 1 pop 1 [association] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendGetNextAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D6AD0, CAnimBlendAssociation*, unsigned int>(association, flags);
0AA7: call_function_return 0x4D6AD0 num_params 2 pop 2 [association] [flags] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendKeyFrameInterpolate

<pre>
plugin::Call<0x4D60C0, void*, void*, void*, float, void*>(voidOut, voidIn1, voidIn2, time, customData);
0AA5: call_function 0x4D60C0 num_params 5 pop 5 [voidOut] [voidIn1] [voidIn2] [time] [customData]
</pre>

#### RpAnimBlendPluginAttach

<pre>
plugin::CallAndReturn<bool, 0x4D6150>();
0AA7: call_function_return 0x4D6150 num_params 0 pop 0 func_ret [bool]
</pre>

#### AsciiToGxtChar

<pre>
plugin::Call<0x718600, char const *, char *>(src, dst);
0AA5: call_function 0x718600 num_params 2 pop 2 [src] [dst]
</pre>

#### assert

<pre>
plugin::Call<0x005A4150>(pRaster, pszPath);
0AA5: call_function 0x005A4150 num_params 2 pop 2 [pRaster] [pszPath]
</pre>

#### DoRWStuffStartOfFrame

<pre>
plugin::CallAndReturn<bool, 0x53D690>(topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue, alpha);
0AA7: call_function_return 0x53D690 num_params 7 pop 7 [topRed] [topGreen] [topBlue] [bottomRed] [bottomGreen] [bottomBlue] [alpha] func_ret [bool]
</pre>

#### DoRWStuffEndOfFrame

<pre>
plugin::Call<0x53D840>();
0AA5: call_function 0x53D840 num_params 0 pop 0
</pre>

#### RsCameraShowRaster

<pre>
plugin::Call<0x619440>(camera);
0AA5: call_function 0x619440 num_params 1 pop 1 [camera]
</pre>

### plugin_sa\game_sa\COnscreenCounterEntry.cpp

#### COnscreenCounterEntry::ProcessForDisplayCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenCounterEntry *, int>(gaddrof(COnscreenCounterEntry::ProcessForDisplayCounter), this, type);
0AA6: call_method 0x44CA90 struct [COnscreenCounterEntry] num_params 1 pop 0 [type]
</pre>

#### COnscreenCounterEntry::SetColourID

<pre>
plugin::CallMethodDynGlobal<COnscreenCounterEntry *, unsigned char>(gaddrof(COnscreenCounterEntry::SetColourID), this, ColourID);
0AA6: call_method 0x44CB00 struct [COnscreenCounterEntry] num_params 1 pop 0 [ColourID]
</pre>

### plugin_sa\game_sa\COnscreenTimer.cpp

#### COnscreenTimer::AddClock

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, char *, bool>(gaddrof(COnscreenTimer::AddClock), this, varId, gxt, bTimerDirection);
0AA6: call_method 0x44CD50 struct [COnscreenTimer] num_params 3 pop 0 [varId] [gxt] [bTimerDirection]
</pre>

#### COnscreenTimer::AddCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, int, short, char *, unsigned short>(gaddrof(COnscreenTimer::AddCounter), this, varId, type, gxt, counterIndex);
0AA6: call_method 0x44CDA0 struct [COnscreenTimer] num_params 4 pop 0 [varId] [type] [gxt] [counterIndex]
</pre>

#### COnscreenTimer::AddCounterCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned int, char *, unsigned short>(gaddrof(COnscreenTimer::AddCounterCounter), this, varId, maxValue, gxt, lineId);
0AA6: call_method 0x44CE00 struct [COnscreenTimer] num_params 4 pop 0 [varId] [maxValue] [gxt] [lineId]
</pre>

#### COnscreenTimer::ClearClock

<pre>
plugin::CallMethodAndReturnDynGlobal<int, COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearClock), this, varId);
0AA8: call_method_return 0x44CE60 struct [COnscreenTimer] num_params 1 pop 0 [varId] func_ret [int]
</pre>

#### COnscreenTimer::ClearCounter

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearCounter), this, varId);
0AA6: call_method 0x44CE80 struct [COnscreenTimer] num_params 1 pop 0 [varId]
</pre>

#### COnscreenTimer::Init

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Init), this);
0AA6: call_method 0x44CBC0 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::Process

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Process), this);
0AA6: call_method 0x44CD30 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::ProcessForDisplay

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::ProcessForDisplay), this);
0AA6: call_method 0x44CC20 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::SetClockBeepCountdownSecs

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned int>(gaddrof(COnscreenTimer::SetClockBeepCountdownSecs), this, varID, time);
0AA6: call_method 0x44CEE0 struct [COnscreenTimer] num_params 2 pop 0 [varID] [time]
</pre>

#### COnscreenTimer::SetCounterColourID

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned char>(gaddrof(COnscreenTimer::SetCounterColourID), this, varID, ColourID);
0AA6: call_method 0x44CF10 struct [COnscreenTimer] num_params 2 pop 0 [varID] [ColourID]
</pre>

#### COnscreenTimer::SetCounterFlashWhenFirstDisplayed

<pre>
plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned char>(gaddrof(COnscreenTimer::SetCounterFlashWhenFirstDisplayed), this, varId, bFlashWhenFirstDisplayed);
0AA6: call_method 0x44CEB0 struct [COnscreenTimer] num_params 2 pop 0 [varId] [bFlashWhenFirstDisplayed]
</pre>

### plugin_sa\game_sa\COnscreenTimerEntry.cpp

#### COnscreenTimerEntry::Process

<pre>
plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::Process), this);
0AA6: call_method 0x44CB10 struct [COnscreenTimerEntry] num_params 0 pop 0
</pre>

#### COnscreenTimerEntry::ProcessForDisplayClock

<pre>
plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayClock), this);
0AA6: call_method 0x44CA40 struct [COnscreenTimerEntry] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPad.cpp

#### CPad::UpdateMouse

<pre>
plugin::CallMethod<0x53F3C0, CPad *>(this);
0AA6: call_method 0x53F3C0 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::ReconcileTwoControllersInput

<pre>
plugin::CallMethod<0x53F530, CPad *, CControllerState const&, CControllerState const&>(this, controllerA, controllerB);
0AA6: call_method 0x53F530 struct [CPad] num_params 2 pop 0 [controllerA] [controllerB]
</pre>

#### CPad::SetDrunkInputDelay

<pre>
plugin::CallMethod<0x53F910, CPad *, int>(this, delay);
0AA6: call_method 0x53F910 struct [CPad] num_params 1 pop 0 [delay]
</pre>

#### CPad::StartShake

<pre>
plugin::CallMethod<0x53F920, CPad *, short, unsigned char, unsigned int>(this, time, frequency, arg2);
0AA6: call_method 0x53F920 struct [CPad] num_params 3 pop 0 [time] [frequency] [arg2]
</pre>

#### CPad::StartShake_Distance

<pre>
plugin::CallMethod<0x53F9A0, CPad *, short, unsigned char, float, float, float>(this, time, frequency, x, y, z);
0AA6: call_method 0x53F9A0 struct [CPad] num_params 5 pop 0 [time] [frequency] [x] [y] [z]
</pre>

#### CPad::StartShake_Train

<pre>
plugin::CallMethod<0x53FA70, CPad *, float, float>(this, x, y);
0AA6: call_method 0x53FA70 struct [CPad] num_params 2 pop 0 [x] [y]
</pre>

#### CPad::ProcessPCSpecificStuff

<pre>
plugin::CallMethod<0x53FB40, CPad *>(this);
0AA6: call_method 0x53FB40 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::StopShaking

<pre>
plugin::CallMethod<0x53FB50, CPad *, short>(this, arg0);
0AA6: call_method 0x53FB50 struct [CPad] num_params 1 pop 0 [arg0]
</pre>

#### CPad::GetPad

<pre>
plugin::CallAndReturn<CPad*, 0x53FB70, int>(padNumber);
0AA7: call_function_return 0x53FB70 num_params 1 pop 1 [padNumber] func_ret [CPad*]
</pre>

#### CPad::GetSteeringLeftRight

<pre>
plugin::CallMethodAndReturn<short, 0x53FB80, CPad *>(this);
0AA8: call_method_return 0x53FB80 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetSteeringUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x53FBD0, CPad *>(this);
0AA8: call_method_return 0x53FBD0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetPedWalkLeftRight

<pre>
plugin::CallMethodAndReturn<short, 0x53FC90, CPad *>(this);
0AA8: call_method_return 0x53FC90 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetPedWalkUpDown

<pre>
plugin::CallMethodAndReturn<short, 0x53FD30, CPad *>(this);
0AA8: call_method_return 0x53FD30 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetLookLeft

<pre>
plugin::CallMethodAndReturn<bool, 0x53FDD0, CPad *>(this);
0AA8: call_method_return 0x53FDD0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookRight

<pre>
plugin::CallMethodAndReturn<bool, 0x53FE10, CPad *>(this);
0AA8: call_method_return 0x53FE10 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookBehindForCar

<pre>
plugin::CallMethodAndReturn<bool, 0x53FE70, CPad *>(this);
0AA8: call_method_return 0x53FE70 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookBehindForPed

<pre>
plugin::CallMethodAndReturn<bool, 0x53FEC0, CPad *>(this);
0AA8: call_method_return 0x53FEC0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetHorn

<pre>
plugin::CallMethodAndReturn<bool, 0x53FEE0, CPad *>(this);
0AA8: call_method_return 0x53FEE0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::HornJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x53FF30, CPad *>(this);
0AA8: call_method_return 0x53FF30 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetHydraulicJump

<pre>
plugin::CallMethodAndReturn<bool, 0x53FF70, CPad *>(this);
0AA8: call_method_return 0x53FF70 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetCarGunFired

<pre>
plugin::CallMethodAndReturn<short, 0x53FF90, CPad *>(this);
0AA8: call_method_return 0x53FF90 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::CarGunJustDown

<pre>
plugin::CallMethodAndReturn<short, 0x53FFE0, CPad *>(this);
0AA8: call_method_return 0x53FFE0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetHandBrake

<pre>
plugin::CallMethodAndReturn<short, 0x540040, CPad *>(this);
0AA8: call_method_return 0x540040 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetBrake

<pre>
plugin::CallMethodAndReturn<short, 0x540080, CPad *>(this);
0AA8: call_method_return 0x540080 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetExitVehicle

<pre>
plugin::CallMethodAndReturn<bool, 0x5400D0, CPad *>(this);
0AA8: call_method_return 0x5400D0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ExitVehicleJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540120, CPad *>(this);
0AA8: call_method_return 0x540120 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetMeleeAttack

<pre>
plugin::CallMethodAndReturn<unsigned char, 0x540340, CPad *>(this, 0);
0AA8: call_method_return 0x540340 struct [CPad] num_params 1 pop 0 [0] func_ret [unsigned char]
</pre>

#### CPad::MeleeAttackJustDown

<pre>
plugin::CallMethodAndReturn<unsigned char, 0x540390, CPad *>(this);
0AA8: call_method_return 0x540390 struct [CPad] num_params 0 pop 0 func_ret [unsigned char]
</pre>

#### CPad::GetAccelerate

<pre>
plugin::CallMethodAndReturn<short, 0x5403F0, CPad *>(this);
0AA8: call_method_return 0x5403F0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetAccelerateJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540440, CPad *>(this);
0AA8: call_method_return 0x540440 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::NextStationJustUp

<pre>
plugin::CallMethodAndReturn<bool, 0x5405B0, CPad *>(this);
0AA8: call_method_return 0x5405B0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::LastStationJustUp

<pre>
plugin::CallMethodAndReturn<bool, 0x5405E0, CPad *>(this);
0AA8: call_method_return 0x5405E0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleWeaponLeftJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540610, CPad *>(this);
0AA8: call_method_return 0x540610 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleWeaponRightJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540640, CPad *>(this);
0AA8: call_method_return 0x540640 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x540670, CPad *>(this);
0AA8: call_method_return 0x540670 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetDuck

<pre>
plugin::CallMethodAndReturn<bool, 0x540700, CPad *>(this);
0AA8: call_method_return 0x540700 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::DuckJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540720, CPad *>(this);
0AA8: call_method_return 0x540720 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetJump

<pre>
plugin::CallMethodAndReturn<bool, 0x540750, CPad *>(this);
0AA8: call_method_return 0x540750 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::JumpJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540770, CPad *>(this);
0AA8: call_method_return 0x540770 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetSprint

<pre>
plugin::CallMethodAndReturn<bool, 0x5407A0, CPad *>(this);
0AA8: call_method_return 0x5407A0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SprintJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x5407F0, CPad *>(this);
0AA8: call_method_return 0x5407F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ShiftTargetLeftJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540850, CPad *>(this);
0AA8: call_method_return 0x540850 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ShiftTargetRightJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540880, CPad *>(this);
0AA8: call_method_return 0x540880 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetDisplayVitalStats

<pre>
plugin::CallMethodAndReturn<short, 0x5408B0, CPad *, CPed*>(this, ped);
0AA8: call_method_return 0x5408B0 struct [CPad] num_params 1 pop 0 [ped] func_ret [short]
</pre>

#### CPad::CollectPickupJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x540A70, CPad *>(this);
0AA8: call_method_return 0x540A70 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetForceCameraBehindPlayer

<pre>
plugin::CallMethodAndReturn<bool, 0x540AE0, CPad *>(this);
0AA8: call_method_return 0x540AE0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SniperZoomIn

<pre>
plugin::CallMethodAndReturn<bool, 0x540B30, CPad *>(this);
0AA8: call_method_return 0x540B30 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SniperZoomOut

<pre>
plugin::CallMethodAndReturn<bool, 0x540B80, CPad *>(this);
0AA8: call_method_return 0x540B80 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetGroupControlForward

<pre>
plugin::CallMethodAndReturn<bool, 0x541190, CPad *>(this);
0AA8: call_method_return 0x541190 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetGroupControlBack

<pre>
plugin::CallMethodAndReturn<bool, 0x5411B0, CPad *>(this);
0AA8: call_method_return 0x5411B0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ConversationYesJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x5411D0, CPad *>(this);
0AA8: call_method_return 0x5411D0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ConversationNoJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x541200, CPad *>(this);
0AA8: call_method_return 0x541200 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GroupControlForwardJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x541230, CPad *>(this);
0AA8: call_method_return 0x541230 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GroupControlBackJustDown

<pre>
plugin::CallMethodAndReturn<bool, 0x541260, CPad *>(this);
0AA8: call_method_return 0x541260 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::Clear

<pre>
plugin::CallMethod<0x541A70, CPad *, bool, bool>(this, enablePlayerControls, resetPhase);
0AA6: call_method 0x541A70 struct [CPad] num_params 2 pop 0 [enablePlayerControls] [resetPhase]
</pre>

#### CPad::UpdatePads

<pre>
plugin::Call<0x541DD0>();
0AA5: call_function 0x541DD0 num_params 0 pop 0
</pre>

#### CPad::ClearMouseHistory

<pre>
plugin::Call<0x541BD0>();
0AA5: call_function 0x541BD0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPathNode.cpp

### plugin_sa\game_sa\CPedClothesDesc.cpp

#### CPedClothesDesc::Initialise

<pre>
plugin::CallMethod<0x5A78F0, CPedClothesDesc *>(this);
0AA6: call_method 0x5A78F0 struct [CPedClothesDesc] num_params 0 pop 0
</pre>

#### CPedClothesDesc::SetModel

<pre>
plugin::CallMethod<0x5A7910, CPedClothesDesc *, unsigned int, int>(this, modelid, eClothesModelPart);
0AA6: call_method 0x5A7910 struct [CPedClothesDesc] num_params 2 pop 0 [modelid] [eClothesModelPart]
</pre>

#### CPedClothesDesc::SetModel

<pre>
plugin::CallMethod<0x5A7920, CPedClothesDesc *, char const*, int>(this, model, eClothesModelPart);
0AA6: call_method 0x5A7920 struct [CPedClothesDesc] num_params 2 pop 0 [model] [eClothesModelPart]
</pre>

#### CPedClothesDesc::GetIsWearingBalaclava

<pre>
plugin::CallMethodAndReturn<bool, 0x5A7950, CPedClothesDesc *>(this);
0AA8: call_method_return 0x5A7950 struct [CPedClothesDesc] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedClothesDesc::HasVisibleNewHairCut

<pre>
plugin::CallMethodAndReturn<bool, 0x5A7970, CPedClothesDesc *, int>(this, arg1);
0AA8: call_method_return 0x5A7970 struct [CPedClothesDesc] num_params 1 pop 0 [arg1] func_ret [bool]
</pre>

#### CPedClothesDesc::HasVisibleTattoo

<pre>
plugin::CallMethodAndReturn<bool, 0x5A79D0, CPedClothesDesc *>(this);
0AA8: call_method_return 0x5A79D0 struct [CPedClothesDesc] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedClothesDesc::CPedClothesDesc

<pre>
plugin::CallMethod<0x5A8020, CPedClothesDesc *>(this);
0AA6: call_method 0x5A8020 struct [CPedClothesDesc] num_params 0 pop 0
</pre>

#### CPedClothesDesc::SetTextureAndModel

<pre>
plugin::CallMethod<0x5A8050, CPedClothesDesc *, unsigned int, unsigned int, int>(this, texture, model, eClothesTexturePart);
0AA6: call_method 0x5A8050 struct [CPedClothesDesc] num_params 3 pop 0 [texture] [model] [eClothesTexturePart]
</pre>

#### CPedClothesDesc::SetTextureAndModel

<pre>
plugin::CallMethod<0x5A8080, CPedClothesDesc *, char const*, char const*, int>(this, texturename, modelname, eClothesTexturePart);
0AA6: call_method 0x5A8080 struct [CPedClothesDesc] num_params 3 pop 0 [texturename] [modelname] [eClothesTexturePart]
</pre>

### plugin_sa\game_sa\CPedGroup.cpp

#### CPedGroup::FindDistanceToFurthestMember

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CPedGroup *>(gaddrof(CPedGroup::FindDistanceToFurthestMember), this);
0AA8: call_method_return 0x5FB010 struct [CPedGroup] num_params 0 pop 0 func_ret [float]
</pre>

#### CPedGroup::FindDistanceToNearestMember

<pre>
plugin::CallMethodAndReturnDynGlobal<float, CPedGroup *, CPed **>(gaddrof(CPedGroup::FindDistanceToNearestMember), this, ppOutNearestMember);
0AA8: call_method_return 0x5FB0A0 struct [CPedGroup] num_params 1 pop 0 [ppOutNearestMember] func_ret [float]
</pre>

#### CPedGroup::Flush

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::Flush), this);
0AA6: call_method 0x5FB790 struct [CPedGroup] num_params 0 pop 0
</pre>

#### \*CPedGroup::GetClosestGroupPed

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroup *, CPed *, float *>(gaddrof(CPedGroup::GetClosestGroupPed), this, ped, pOutDistance);
0AA8: call_method_return 0x5FACD0 struct [*CPedGroup] num_params 2 pop 0 [ped] [pOutDistance] func_ret [CPed *]
</pre>

#### CPedGroup::IsAnyoneUsingCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroup *, CVehicle const *>(gaddrof(CPedGroup::IsAnyoneUsingCar), this, vehicle);
0AA8: call_method_return 0x5F7DB0 struct [CPedGroup] num_params 1 pop 0 [vehicle] func_ret [bool]
</pre>

#### CPedGroup::PlayerGaveCommand_Attack

<pre>
plugin::CallMethodDynGlobal<CPedGroup *, CPed *, CPed *>(gaddrof(CPedGroup::PlayerGaveCommand_Attack), this, playerPed, ped);
0AA6: call_method 0x5F7CC0 struct [CPedGroup] num_params 2 pop 0 [playerPed] [ped]
</pre>

#### CPedGroup::PlayerGaveCommand_Gather

<pre>
plugin::CallMethodDynGlobal<CPedGroup *, CPed *>(gaddrof(CPedGroup::PlayerGaveCommand_Gather), this, ped);
0AA6: call_method 0x5FAB60 struct [CPedGroup] num_params 1 pop 0 [ped]
</pre>

#### CPedGroup::Process

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::Process), this);
0AA6: call_method 0x5FC7E0 struct [CPedGroup] num_params 0 pop 0
</pre>

#### CPedGroup::RemoveAllFollowers

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::RemoveAllFollowers), this);
0AA6: call_method 0x5FB7D0 struct [CPedGroup] num_params 0 pop 0
</pre>

#### CPedGroup::Teleport

<pre>
plugin::CallMethodDynGlobal<CPedGroup *, CVector const *>(gaddrof(CPedGroup::Teleport), this, Pos);
0AA6: call_method 0x5F7AD0 struct [CPedGroup] num_params 1 pop 0 [Pos]
</pre>

### plugin_sa\game_sa\CPedGroupIntelligence.cpp

#### CPedGroupIntelligence::AddEvent

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CEvent *>(gaddrof(CPedGroupIntelligence::AddEvent), this, event);
0AA8: call_method_return 0x5F7470 struct [CPedGroupIntelligence] num_params 1 pop 0 [event] func_ret [bool]
</pre>

#### CPedGroupIntelligence::ComputeDefaultTasks

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::ComputeDefaultTasks), this, ped);
0AA6: call_method 0x5F88D0 struct [CPedGroupIntelligence] num_params 1 pop 0 [ped]
</pre>

#### \*CPedGroupIntelligence::ComputeEventResponseTasks

<pre>
plugin::CallMethodAndReturnDynGlobal<void *, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ComputeEventResponseTasks), this);
0AA8: call_method_return 0x5FC440 struct [*CPedGroupIntelligence] num_params 0 pop 0 func_ret [void *]
</pre>

#### CPedGroupIntelligence::ComputeScriptCommandTasks

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ComputeScriptCommandTasks), this);
0AA6: call_method 0x5F7800 struct [CPedGroupIntelligence] num_params 0 pop 0
</pre>

#### CPedGroupIntelligence::FlushTasks

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedTaskPair *, CPed *>(gaddrof(CPedGroupIntelligence::FlushTasks), this, taskpair, ped);
0AA6: call_method 0x5F79C0 struct [CPedGroupIntelligence] num_params 2 pop 0 [taskpair] [ped]
</pre>

#### \*CPedGroupIntelligence::GetTask

<pre>
plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *, CPedTaskPair const *>(gaddrof(CPedGroupIntelligence::GetTask), this, ped, taskpair);
0AA8: call_method_return 0x5F7660 struct [*CPedGroupIntelligence] num_params 2 pop 0 [ped] [taskpair] func_ret [CTask *]
</pre>

#### \*CPedGroupIntelligence::GetTaskDefault

<pre>
plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskDefault), this, ped);
0AA8: call_method_return 0x5F86C0 struct [*CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [CTask *]
</pre>

#### \*CPedGroupIntelligence::GetTaskScriptCommand

<pre>
plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskScriptCommand), this, ped);
0AA8: call_method_return 0x5F8690 struct [*CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [CTask *]
</pre>

#### \*CPedGroupIntelligence::GetTaskSecondary

<pre>
plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskSecondary), this, ped);
0AA8: call_method_return 0x5F8620 struct [*CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [CTask *]
</pre>

#### CPedGroupIntelligence::GetTaskSecondarySlot

<pre>
plugin::CallMethodAndReturnDynGlobal<signed int, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskSecondarySlot), this, ped);
0AA8: call_method_return 0x5F8650 struct [CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [signed int]
</pre>

#### CPedGroupIntelligence::IsCurrentEventValid

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::IsCurrentEventValid), this);
0AA8: call_method_return 0x5F77A0 struct [CPedGroupIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedGroupIntelligence::IsGroupResponding

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::IsGroupResponding), this);
0AA8: call_method_return 0x5F7760 struct [CPedGroupIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedGroupIntelligence::Process

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::Process), this);
0AA6: call_method 0x5FC4A0 struct [CPedGroupIntelligence] num_params 0 pop 0
</pre>

#### CPedGroupIntelligence::ProcessIgnorePlayerGroup

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ProcessIgnorePlayerGroup), this);
0AA6: call_method 0x5F87A0 struct [CPedGroupIntelligence] num_params 0 pop 0
</pre>

#### CPedGroupIntelligence::ReportAllBarScriptTasksFinished

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ReportAllBarScriptTasksFinished), this);
0AA6: call_method 0x5F8780 struct [CPedGroupIntelligence] num_params 0 pop 0
</pre>

#### CPedGroupIntelligence::ReportAllTasksFinished

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedTaskPair *>(gaddrof_o(CPedGroupIntelligence::ReportAllTasksFinished, void (CPedGroupIntelligence::*)(CPedTaskPair *)), this, taskpair);
0AA6: call_method 0x5F8750 struct [CPedGroupIntelligence] num_params 1 pop 0 [taskpair]
</pre>

#### CPedGroupIntelligence::ReportAllTasksFinished

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof_o(CPedGroupIntelligence::ReportAllTasksFinished, void (CPedGroupIntelligence::*)()), this);
0AA6: call_method 0x5F8750 struct [CPedGroupIntelligence] num_params 0 pop 0
</pre>

#### CPedGroupIntelligence::ReportFinishedTask

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CPed const *, CTask const *, CPedTaskPair *>(gaddrof_o(CPedGroupIntelligence::ReportFinishedTask, bool (CPedGroupIntelligence::*)(CPed const *, CTask const *, CPedTaskPair *)), this, ped, task, taskpair);
0AA8: call_method_return 0x5F86F0 struct [CPedGroupIntelligence] num_params 3 pop 0 [ped] [task] [taskpair] func_ret [bool]
</pre>

#### CPedGroupIntelligence::ReportFinishedTask

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CPed const *, CTask const *>(gaddrof_o(CPedGroupIntelligence::ReportFinishedTask, bool (CPedGroupIntelligence::*)(CPed const *, CTask const *)), this, ped, task);
0AA8: call_method_return 0x5F86F0 struct [CPedGroupIntelligence] num_params 2 pop 0 [ped] [task] func_ret [bool]
</pre>

#### CPedGroupIntelligence::SetDefaultTask

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *>(gaddrof(CPedGroupIntelligence::SetDefaultTask), this, ped, task);
0AA6: call_method 0x5F8580 struct [CPedGroupIntelligence] num_params 2 pop 0 [ped] [task]
</pre>

#### CPedGroupIntelligence::SetDefaultTaskAllocator

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedGroupDefaultTaskAllocator const *>(gaddrof(CPedGroupIntelligence::SetDefaultTaskAllocator), this, PedGroupDefaultTaskAllocator);
0AA6: call_method 0x5FB280 struct [CPedGroupIntelligence] num_params 1 pop 0 [PedGroupDefaultTaskAllocator]
</pre>

#### CPedGroupIntelligence::SetDefaultTaskAllocatorType

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetDefaultTaskAllocatorType), this, nPedGroupTaskAllocator);
0AA6: call_method 0x5FBB70 struct [CPedGroupIntelligence] num_params 1 pop 0 [nPedGroupTaskAllocator]
</pre>

#### CPedGroupIntelligence::SetEventResponseTask

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, bool, CTask const *, bool, CTask const *, int>(gaddrof(CPedGroupIntelligence::SetEventResponseTask), this, ped, arg3, task1, arg5, task2, arg7);
0AA6: call_method 0x5F8510 struct [CPedGroupIntelligence] num_params 6 pop 0 [ped] [arg3] [task1] [arg5] [task2] [arg7]
</pre>

#### CPedGroupIntelligence::SetEventResponseTaskAllocator

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetEventResponseTaskAllocator), this, a2);
0AA8: call_method_return 0x5F7440 struct [CPedGroupIntelligence] num_params 1 pop 0 [a2] func_ret [int]
</pre>

#### CPedGroupIntelligence::SetGroupDecisionMakerType

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetGroupDecisionMakerType), this, a2);
0AA8: call_method_return 0x5F7340 struct [CPedGroupIntelligence] num_params 1 pop 0 [a2] func_ret [int]
</pre>

#### CPedGroupIntelligence::SetPrimaryTaskAllocator

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CTaskAllocator *>(gaddrof(CPedGroupIntelligence::SetPrimaryTaskAllocator), this, taskAllocator);
0AA6: call_method 0x5F7410 struct [CPedGroupIntelligence] num_params 1 pop 0 [taskAllocator]
</pre>

#### CPedGroupIntelligence::SetScriptCommandTask

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *>(gaddrof(CPedGroupIntelligence::SetScriptCommandTask), this, ped, task);
0AA6: call_method 0x5F8560 struct [CPedGroupIntelligence] num_params 2 pop 0 [ped] [task]
</pre>

#### CPedGroupIntelligence::SetTask

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *, CPedTaskPair *, int, bool>(gaddrof(CPedGroupIntelligence::SetTask), this, ped, task, taskpair, arg5, arg6);
0AA6: call_method 0x5F7540 struct [CPedGroupIntelligence] num_params 5 pop 0 [ped] [task] [taskpair] [arg5] [arg6]
</pre>

### plugin_sa\game_sa\CPedGroupMembership.cpp

#### CPedGroupMembership::AddFollower

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *>(gaddrof(CPedGroupMembership::AddFollower), this, ped);
0AA6: call_method 0x5F8020 struct [CPedGroupMembership] num_params 1 pop 0 [ped]
</pre>

#### CPedGroupMembership::AddMember

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *, int>(gaddrof(CPedGroupMembership::AddMember), this, member, memberID);
0AA6: call_method 0x5F6AE0 struct [CPedGroupMembership] num_params 2 pop 0 [member] [memberID]
</pre>

#### CPedGroupMembership::AppointNewLeader

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::AppointNewLeader), this);
0AA6: call_method 0x5FB240 struct [CPedGroupMembership] num_params 0 pop 0
</pre>

#### CPedGroupMembership::CountMembers

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPedGroupMembership *>(gaddrof(CPedGroupMembership::CountMembers), this);
0AA8: call_method_return 0x5F6A50 struct [CPedGroupMembership] num_params 0 pop 0 func_ret [int]
</pre>

#### CPedGroupMembership::CountMembersExcludingLeader

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPedGroupMembership *>(gaddrof(CPedGroupMembership::CountMembersExcludingLeader), this);
0AA8: call_method_return 0x5F6AA0 struct [CPedGroupMembership] num_params 0 pop 0 func_ret [int]
</pre>

#### CPedGroupMembership::Flush

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::Flush), this);
0AA6: call_method 0x5FB160 struct [CPedGroupMembership] num_params 0 pop 0
</pre>

#### CPedGroupMembership::From

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(gaddrof(CPedGroupMembership::From), this, obj);
0AA6: call_method 0x5F7FE0 struct [CPedGroupMembership] num_params 1 pop 0 [obj]
</pre>

#### \*CPedGroupMembership::GetLeader

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroupMembership *>(gaddrof(CPedGroupMembership::GetLeader), this);
0AA8: call_method_return 0x5F69A0 struct [*CPedGroupMembership] num_params 0 pop 0 func_ret [CPed *]
</pre>

#### \*CPedGroupMembership::GetMember

<pre>
plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::GetMember), this, memberId);
0AA8: call_method_return 0x5F69B0 struct [*CPedGroupMembership] num_params 1 pop 0 [memberId] func_ret [CPed *]
</pre>

#### CPedGroupMembership::IsFollower

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsFollower), this, ped);
0AA8: call_method_return 0x5F69E0 struct [CPedGroupMembership] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedGroupMembership::IsLeader

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsLeader), this, ped);
0AA8: call_method_return 0x5F69C0 struct [CPedGroupMembership] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedGroupMembership::IsMember

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsMember), this, ped);
0AA8: call_method_return 0x5F6A10 struct [CPedGroupMembership] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedGroupMembership::Process

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::Process), this);
0AA6: call_method 0x5FBA60 struct [CPedGroupMembership] num_params 0 pop 0
</pre>

#### CPedGroupMembership::RemoveAllFollowers

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, bool>(gaddrof(CPedGroupMembership::RemoveAllFollowers), this, bCreatedByGameOnly);
0AA6: call_method 0x5FB190 struct [CPedGroupMembership] num_params 1 pop 0 [bCreatedByGameOnly]
</pre>

#### CPedGroupMembership::RemoveMember

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::RemoveMember), this, memberID);
0AA6: call_method 0x5F80D0 struct [CPedGroupMembership] num_params 1 pop 0 [memberID]
</pre>

#### CPedGroupMembership::RemoveNFollowers

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::RemoveNFollowers), this, count);
0AA8: call_method_return 0x5FB1D0 struct [CPedGroupMembership] num_params 1 pop 0 [count] func_ret [char]
</pre>

#### CPedGroupMembership::SetLeader

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *>(gaddrof(CPedGroupMembership::SetLeader), this, ped);
0AA6: call_method 0x5FB9C0 struct [CPedGroupMembership] num_params 1 pop 0 [ped]
</pre>

#### CPedGroupMembership::GetObjectForPedToHold

<pre>
plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CPedGroupMembership::GetObjectForPedToHold));
</pre>

### plugin_sa\game_sa\CPedGroupPlacer.cpp

#### CPedGroupPlacer::PlaceChatGroup

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceChatGroup), this, pedtype, numOfPeds, origin, unused);
0AA8: call_method_return 0x5FCE80 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [unused] func_ret [bool]
</pre>

#### CPedGroupPlacer::PlaceFormationGroup

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceFormationGroup), this, pedtype, numOfPeds, origin, unused);
0AA8: call_method_return 0x5FC9B0 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [unused] func_ret [bool]
</pre>

#### CPedGroupPlacer::PlaceGroup

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceGroup), this, pedtype, numOfPeds, origin, nGroupPlacerType);
0AA8: call_method_return 0x5FD810 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [nGroupPlacerType] func_ret [bool]
</pre>

#### CPedGroupPlacer::PlaceRandomGroup

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector *, int>(gaddrof(CPedGroupPlacer::PlaceRandomGroup), this, pedtype, numOfPeds, origin, unused);
0AA8: call_method_return 0x5FD330 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [unused] func_ret [bool]
</pre>

### plugin_sa\game_sa\CPedGroups.cpp

#### CPedGroups::AddGroup

<pre>
plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CPedGroups::AddGroup));
</pre>

#### CPedGroups::AreInSameGroup

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *, CPed *>(gaddrof(CPedGroups::AreInSameGroup), ped1, ped2);
</pre>

#### CPedGroups::GetGroupId

<pre>
plugin::CallAndReturnDynGlobal<signed int, CPedGroup *>(gaddrof(CPedGroups::GetGroupId), pedgrp);
</pre>

#### \*CPedGroups::GetPedsGroup

<pre>
plugin::CallAndReturnDynGlobal<char *, CPed *>(gaddrof(CPedGroups::GetPedsGroup), ped);
</pre>

#### CPedGroups::IsGroupLeader

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CPedGroups::IsGroupLeader), ped);
</pre>

#### CPedGroups::IsInPlayersGroup

<pre>
plugin::CallAndReturnDynGlobal<char, CPed *>(gaddrof(CPedGroups::IsInPlayersGroup), a1);
</pre>

#### CPedGroups::RemoveAllFollowersFromGroup

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPedGroups::RemoveAllFollowersFromGroup), groupID);
</pre>

#### CPedGroups::RemoveGroup

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPedGroups::RemoveGroup), groupID);
</pre>

### plugin_sa\game_sa\CPedIK.cpp

#### CPedIK::RotateTorso

<pre>
plugin::CallMethod<0x5FDDB0, CPedIK *, AnimBlendFrameData*, LimbOrientation&, bool>(this, bone, orientation, flag);
0AA6: call_method 0x5FDDB0 struct [CPedIK] num_params 3 pop 0 [bone] [orientation] [flag]
</pre>

#### CPedIK::PointGunInDirection

<pre>
plugin::CallMethodAndReturn<bool, 0x5FDC00, CPedIK *, float, float, bool, float>(this, Z_angle, arg2, flag, arg4);
0AA8: call_method_return 0x5FDC00 struct [CPedIK] num_params 4 pop 0 [Z_angle] [arg2] [flag] [arg4] func_ret [bool]
</pre>

#### CPedIK::PointGunAtPosition

<pre>
plugin::CallMethod<0x5FDE20, CPedIK *, CVector const&, float>(this, posn, arg2);
0AA6: call_method 0x5FDE20 struct [CPedIK] num_params 2 pop 0 [posn] [arg2]
</pre>

#### CPedIK::GetWorldMatrix

<pre>
plugin::CallAndReturn<RwMatrixTag*, 0x5FD8F0, RwFrame*, RwMatrixTag*>(frame, transformMat);
0AA7: call_function_return 0x5FD8F0 num_params 2 pop 2 [frame] [transformMat] func_ret [RwMatrixTag*]
</pre>

### plugin_sa\game_sa\CPedIntelligence.cpp

#### CPedIntelligence::SetPedDecisionMakerType

<pre>
plugin::CallMethod<0x600B50, CPedIntelligence *, int>(this, newtype);
0AA6: call_method 0x600B50 struct [CPedIntelligence] num_params 1 pop 0 [newtype]
</pre>

#### CPedIntelligence::SetPedDecisionMakerTypeInGroup

<pre>
plugin::CallMethod<0x600BB0, CPedIntelligence *, int>(this, newtype);
0AA6: call_method 0x600BB0 struct [CPedIntelligence] num_params 1 pop 0 [newtype]
</pre>

#### CPedIntelligence::RestorePedDecisionMakerType

<pre>
plugin::CallMethod<0x600BC0, CPedIntelligence *>(this);
0AA6: call_method 0x600BC0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::SetHearingRange

<pre>
plugin::CallMethod<0x600BE0, CPedIntelligence *, float>(this, range);
0AA6: call_method 0x600BE0 struct [CPedIntelligence] num_params 1 pop 0 [range]
</pre>

#### CPedIntelligence::SetSeeingRange

<pre>
plugin::CallMethod<0x600BF0, CPedIntelligence *, float>(this, range);
0AA6: call_method 0x600BF0 struct [CPedIntelligence] num_params 1 pop 0 [range]
</pre>

#### CPedIntelligence::IsInHearingRange

<pre>
plugin::CallMethodAndReturn<bool, 0x600C00, CPedIntelligence *, CVector const&>(this, posn);
0AA8: call_method_return 0x600C00 struct [CPedIntelligence] num_params 1 pop 0 [posn] func_ret [bool]
</pre>

#### CPedIntelligence::IsInSeeingRange

<pre>
plugin::CallMethodAndReturn<bool, 0x600C60, CPedIntelligence *, CVector const&>(this, posn);
0AA8: call_method_return 0x600C60 struct [CPedIntelligence] num_params 1 pop 0 [posn] func_ret [bool]
</pre>

#### CPedIntelligence::FindRespectedFriendInInformRange

<pre>
plugin::CallMethodAndReturn<bool, 0x600CF0, CPedIntelligence *>(this);
0AA8: call_method_return 0x600CF0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIntelligence::IsRespondingToEvent

<pre>
plugin::CallMethodAndReturn<bool, 0x600DB0, CPedIntelligence *, int>(this, event);
0AA8: call_method_return 0x600DB0 struct [CPedIntelligence] num_params 1 pop 0 [event] func_ret [bool]
</pre>

#### CPedIntelligence::AddTaskPhysResponse

<pre>
plugin::CallMethod<0x600DC0, CPedIntelligence *, CTask*, bool>(this, task, arg2);
0AA6: call_method 0x600DC0 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]
</pre>

#### CPedIntelligence::AddTaskEventResponseTemp

<pre>
plugin::CallMethod<0x600DE0, CPedIntelligence *, CTask*, bool>(this, task, arg2);
0AA6: call_method 0x600DE0 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]
</pre>

#### CPedIntelligence::AddTaskEventResponseNonTemp

<pre>
plugin::CallMethod<0x600E00, CPedIntelligence *, CTask*, bool>(this, task, arg2);
0AA6: call_method 0x600E00 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]
</pre>

#### CPedIntelligence::AddTaskPrimaryMaybeInGroup

<pre>
plugin::CallMethod<0x600E20, CPedIntelligence *, CTask*, bool>(this, task, arg2);
0AA6: call_method 0x600E20 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]
</pre>

#### CPedIntelligence::FindTaskByType

<pre>
plugin::CallMethodAndReturn<CTask*, 0x600EE0, CPedIntelligence *, int>(this, type);
0AA8: call_method_return 0x600EE0 struct [CPedIntelligence] num_params 1 pop 0 [type] func_ret [CTask*]
</pre>

#### CPedIntelligence::GetTaskFighting

<pre>
plugin::CallMethodAndReturn<CTaskSimpleFight*, 0x600F30, CPedIntelligence *>(this);
0AA8: call_method_return 0x600F30 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleFight*]
</pre>

#### CPedIntelligence::GetTaskUseGun

<pre>
plugin::CallMethodAndReturn<CTaskSimpleUseGun*, 0x600F70, CPedIntelligence *>(this);
0AA8: call_method_return 0x600F70 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleUseGun*]
</pre>

#### CPedIntelligence::GetTaskThrow

<pre>
plugin::CallMethodAndReturn<CTaskSimpleThrowProjectile*, 0x600FB0, CPedIntelligence *>(this);
0AA8: call_method_return 0x600FB0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleThrowProjectile*]
</pre>

#### CPedIntelligence::GetTaskHold

<pre>
plugin::CallMethodAndReturn<CTaskSimpleHoldEntity*, 0x600FF0, CPedIntelligence *, bool>(this, arg1);
0AA8: call_method_return 0x600FF0 struct [CPedIntelligence] num_params 1 pop 0 [arg1] func_ret [CTaskSimpleHoldEntity*]
</pre>

#### CPedIntelligence::GetTaskSwim

<pre>
plugin::CallMethodAndReturn<CTaskSimpleSwim*, 0x601070, CPedIntelligence *>(this);
0AA8: call_method_return 0x601070 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleSwim*]
</pre>

#### CPedIntelligence::GetTaskDuck

<pre>
plugin::CallMethodAndReturn<CTaskSimpleDuck*, 0x6010A0, CPedIntelligence *, bool>(this, arg1);
0AA8: call_method_return 0x6010A0 struct [CPedIntelligence] num_params 1 pop 0 [arg1] func_ret [CTaskSimpleDuck*]
</pre>

#### CPedIntelligence::GetTaskJetPack

<pre>
plugin::CallMethodAndReturn<CTaskSimpleJetPack*, 0x601110, CPedIntelligence *>(this);
0AA8: call_method_return 0x601110 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleJetPack*]
</pre>

#### CPedIntelligence::GetTaskInAir

<pre>
plugin::CallMethodAndReturn<CTaskSimpleInAir*, 0x601150, CPedIntelligence *>(this);
0AA8: call_method_return 0x601150 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleInAir*]
</pre>

#### CPedIntelligence::GetTaskClimb

<pre>
plugin::CallMethodAndReturn<CTaskSimpleClimb*, 0x601180, CPedIntelligence *>(this);
0AA8: call_method_return 0x601180 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleClimb*]
</pre>

#### CPedIntelligence::GetUsingParachute

<pre>
plugin::CallMethodAndReturn<bool, 0x6011B0, CPedIntelligence *>(this);
0AA8: call_method_return 0x6011B0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIntelligence::SetTaskDuckSecondary

<pre>
plugin::CallMethod<0x601230, CPedIntelligence *, unsigned short>(this, arg1);
0AA6: call_method 0x601230 struct [CPedIntelligence] num_params 1 pop 0 [arg1]
</pre>

#### CPedIntelligence::ClearTaskDuckSecondary

<pre>
plugin::CallMethod<0x601390, CPedIntelligence *>(this);
0AA6: call_method 0x601390 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::ClearTasks

<pre>
plugin::CallMethod<0x601420, CPedIntelligence *, bool, bool>(this, arg1, arg2);
0AA6: call_method 0x601420 struct [CPedIntelligence] num_params 2 pop 0 [arg1] [arg2]
</pre>

#### CPedIntelligence::FlushImmediately

<pre>
plugin::CallMethod<0x601640, CPedIntelligence *, bool>(this, arg1);
0AA6: call_method 0x601640 struct [CPedIntelligence] num_params 1 pop 0 [arg1]
</pre>

#### CPedIntelligence::GetEffectInUse

<pre>
plugin::CallMethodAndReturn<C2dEffect*, 0x6018D0, CPedIntelligence *>(this);
0AA8: call_method_return 0x6018D0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [C2dEffect*]
</pre>

#### CPedIntelligence::SetEffectInUse

<pre>
plugin::CallMethod<0x6018E0, CPedIntelligence *, C2dEffect*>(this, arg1);
0AA6: call_method 0x6018E0 struct [CPedIntelligence] num_params 1 pop 0 [arg1]
</pre>

#### CPedIntelligence::ProcessAfterProcCol

<pre>
plugin::CallMethod<0x6018F0, CPedIntelligence *>(this);
0AA6: call_method 0x6018F0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::ProcessAfterPreRender

<pre>
plugin::CallMethod<0x6019B0, CPedIntelligence *>(this);
0AA6: call_method 0x6019B0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::ProcessEventHandler

<pre>
plugin::CallMethod<0x601BB0, CPedIntelligence *>(this);
0AA6: call_method 0x601BB0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::IsFriendlyWith

<pre>
plugin::CallMethodAndReturn<bool, 0x601BC0, CPedIntelligence *, CPed const&>(this, ped);
0AA8: call_method_return 0x601BC0 struct [CPedIntelligence] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedIntelligence::IsThreatenedBy

<pre>
plugin::CallMethodAndReturn<bool, 0x601C30, CPedIntelligence *, CPed const&>(this, ped);
0AA8: call_method_return 0x601C30 struct [CPedIntelligence] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedIntelligence::Respects

<pre>
plugin::CallMethodAndReturn<bool, 0x601C90, CPedIntelligence *, CPed const&>(this, ped);
0AA8: call_method_return 0x601C90 struct [CPedIntelligence] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedIntelligence::IsInACarOrEnteringOne

<pre>
plugin::CallMethodAndReturn<bool, 0x601CC0, CPedIntelligence *>(this);
0AA8: call_method_return 0x601CC0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIntelligence::AreFriends

<pre>
plugin::CallAndReturn<bool, 0x601D10, CPed const&, CPed const&>(ped1, ped2);
0AA7: call_function_return 0x601D10 num_params 2 pop 2 [ped1] [ped2] func_ret [bool]
</pre>

#### CPedIntelligence::IsPedGoingSomewhereOnFoot

<pre>
plugin::CallMethodAndReturn<bool, 0x601D50, CPedIntelligence *>(this);
0AA8: call_method_return 0x601D50 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIntelligence::GetMoveStateFromGoToTask

<pre>
plugin::CallMethodAndReturn<int*, 0x601D70, CPedIntelligence *>(this);
0AA8: call_method_return 0x601D70 struct [CPedIntelligence] num_params 0 pop 0 func_ret [int*]
</pre>

#### CPedIntelligence::FlushIntelligence

<pre>
plugin::CallMethod<0x601DA0, CPedIntelligence *>(this);
0AA6: call_method 0x601DA0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::TestForStealthKill

<pre>
plugin::CallMethodAndReturn<bool, 0x601E00, CPedIntelligence *, CPed*, bool>(this, pPed, arg2);
0AA8: call_method_return 0x601E00 struct [CPedIntelligence] num_params 2 pop 0 [pPed] [arg2] func_ret [bool]
</pre>

#### CPedIntelligence::RecordEventForScript

<pre>
plugin::CallMethod<0x602050, CPedIntelligence *, int, int>(this, EventID, EventPriority);
0AA6: call_method 0x602050 struct [CPedIntelligence] num_params 2 pop 0 [EventID] [EventPriority]
</pre>

#### CPedIntelligence::HasInterestingEntites

<pre>
plugin::CallMethodAndReturn<bool, 0x602080, CPedIntelligence *>(this);
0AA8: call_method_return 0x602080 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIntelligence::IsInterestingEntity

<pre>
plugin::CallMethodAndReturn<bool, 0x6020A0, CPedIntelligence *, CEntity*>(this, pEntity);
0AA8: call_method_return 0x6020A0 struct [CPedIntelligence] num_params 1 pop 0 [pEntity] func_ret [bool]
</pre>

#### CPedIntelligence::LookAtInterestingEntities

<pre>
plugin::CallMethod<0x6020D0, CPedIntelligence *>(this);
0AA6: call_method 0x6020D0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::RemoveAllInterestingEntities

<pre>
plugin::CallMethod<0x602320, CPedIntelligence *>(this);
0AA6: call_method 0x602320 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::IsPedGoingForCarDoor

<pre>
plugin::CallMethodAndReturn<bool, 0x602350, CPedIntelligence *>(this);
0AA8: call_method_return 0x602350 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPedIntelligence::CanSeeEntityWithLights

<pre>
plugin::CallMethodAndReturn<float, 0x605550, CPedIntelligence *, CEntity const*, bool>(this, pEntity, arg2);
0AA8: call_method_return 0x605550 struct [CPedIntelligence] num_params 2 pop 0 [pEntity] [arg2] func_ret [float]
</pre>

#### CPedIntelligence::ProcessStaticCounter

<pre>
plugin::CallMethod<0x605650, CPedIntelligence *>(this);
0AA6: call_method 0x605650 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::ProcessFirst

<pre>
plugin::CallMethod<0x6073A0, CPedIntelligence *>(this);
0AA6: call_method 0x6073A0 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::Process

<pre>
plugin::CallMethod<0x608260, CPedIntelligence *>(this);
0AA6: call_method 0x608260 struct [CPedIntelligence] num_params 0 pop 0
</pre>

#### CPedIntelligence::operator delete

<pre>
plugin::Call<0x6074E0, void*>(arg1);
0AA5: call_function 0x6074E0 num_params 1 pop 1 [arg1]
</pre>

### plugin_sa\game_sa\CPedList.cpp

#### CPedList::BuildListFromGroup_NoLeader

<pre>
plugin::CallMethodDynGlobal<CPedList *, CPedGroupMembership *>(gaddrof(CPedList::BuildListFromGroup_NoLeader), this, pedGroupMemberShip);
0AA6: call_method 0x699DD0 struct [CPedList] num_params 1 pop 0 [pedGroupMemberShip]
</pre>

#### CPedList::BuildListFromGroup_NotInCar_NoLeader

<pre>
plugin::CallMethodDynGlobal<CPedList *, CPedGroupMembership *>(gaddrof(CPedList::BuildListFromGroup_NotInCar_NoLeader), this, pedGroupMembership);
0AA6: call_method 0x69A340 struct [CPedList] num_params 1 pop 0 [pedGroupMembership]
</pre>

#### CPedList::BuildListOfPedsOfPedType

<pre>
plugin::CallMethodDynGlobal<CPedList *, int>(gaddrof(CPedList::BuildListOfPedsOfPedType), this, pedtype);
0AA6: call_method 0x69A3B0 struct [CPedList] num_params 1 pop 0 [pedtype]
</pre>

#### CPedList::Empty

<pre>
plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::Empty), this);
0AA6: call_method 0x699DB0 struct [CPedList] num_params 0 pop 0
</pre>

#### CPedList::ExtractPedsWithGuns

<pre>
plugin::CallMethodDynGlobal<CPedList *, CPedList *>(gaddrof(CPedList::ExtractPedsWithGuns), this, pedlist);
0AA6: call_method 0x69A4C0 struct [CPedList] num_params 1 pop 0 [pedlist]
</pre>

#### CPedList::FillUpHoles

<pre>
plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::FillUpHoles), this);
0AA6: call_method 0x699E20 struct [CPedList] num_params 0 pop 0
</pre>

#### CPedList::RemovePedsAttackingPedType

<pre>
plugin::CallMethodDynGlobal<CPedList *, int>(gaddrof(CPedList::RemovePedsAttackingPedType), this, pedtype);
0AA6: call_method 0x69A450 struct [CPedList] num_params 1 pop 0 [pedtype]
</pre>

#### CPedList::RemovePedsThatDontListenToPlayer

<pre>
plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::RemovePedsThatDontListenToPlayer), this);
0AA6: call_method 0x69A420 struct [CPedList] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPedPlacement.cpp

#### CPedPlacement::FindZCoorForPed

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPedPlacement::FindZCoorForPed), pos);
</pre>

#### CPedPlacement::IsPositionClearForPed

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector const *, float, int, CEntity **, unsigned char, unsigned char, unsigned char>(gaddrof(CPedPlacement::IsPositionClearForPed), pos, radius, maxNumObjects, pObjectList, bCheckVehicles, bCheckPeds, bCheckObjects);
</pre>

#### \*CPedPlacement::IsPositionClearOfCars

<pre>
plugin::CallAndReturnDynGlobal<CVehicle *, CVector const *>(gaddrof_o(CPedPlacement::IsPositionClearOfCars, CVehicle *(*)(CVector const *)), pos);
</pre>

#### \*CPedPlacement::IsPositionClearOfCars

<pre>
plugin::CallAndReturnDynGlobal<CVehicle *, CPed const *>(gaddrof_o(CPedPlacement::IsPositionClearOfCars, CVehicle *(*)(CPed const *)), ped);
</pre>

### plugin_sa\game_sa\CPedTaskPair.cpp

#### CPedTaskPair::Flush

<pre>
plugin::CallMethodDynGlobal<CPedTaskPair *>(gaddrof(CPedTaskPair::Flush), this);
0AA6: call_method 0x5E95B0 struct [CPedTaskPair] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPickup.cpp

#### CPickup::SetPosn

<pre>
plugin::CallMethod<0x454960, CPickup *, float, float, float>(this, x, y, z);
0AA6: call_method 0x454960 struct [CPickup] num_params 3 pop 0 [x] [y] [z]
</pre>

#### CPickup::GetXCoord

<pre>
plugin::CallMethodAndReturn<float, 0x4549F0, CPickup *>(this);
0AA8: call_method_return 0x4549F0 struct [CPickup] num_params 0 pop 0 func_ret [float]
</pre>

#### CPickup::GetYCoord

<pre>
plugin::CallMethodAndReturn<float, 0x454A10, CPickup *>(this);
0AA8: call_method_return 0x454A10 struct [CPickup] num_params 0 pop 0 func_ret [float]
</pre>

#### CPickup::GetZCoord

<pre>
plugin::CallMethodAndReturn<float, 0x454A30, CPickup *>(this);
0AA8: call_method_return 0x454A30 struct [CPickup] num_params 0 pop 0 func_ret [float]
</pre>

#### CPickup::ExtractAmmoFromPickup

<pre>
plugin::CallMethod<0x454BE0, CPickup *, CPlayerPed*>(this, playerPed);
0AA6: call_method 0x454BE0 struct [CPickup] num_params 1 pop 0 [playerPed]
</pre>

#### CPickup::IsVisible

<pre>
plugin::CallMethodAndReturn<bool, 0x454C70, CPickup *>(this);
0AA8: call_method_return 0x454C70 struct [CPickup] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPickup::GetRidOfObjects

<pre>
plugin::CallMethod<0x454CF0, CPickup *>(this);
0AA6: call_method 0x454CF0 struct [CPickup] num_params 0 pop 0
</pre>

#### CPickup::PickUpShouldBeInvisible

<pre>
plugin::CallMethodAndReturn<bool, 0x454D20, CPickup *>(this);
0AA8: call_method_return 0x454D20 struct [CPickup] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPickup::FindTextIndexForString

<pre>
plugin::Call<0x455500, char*>(message);
0AA5: call_function 0x455500 num_params 1 pop 1 [message]
</pre>

#### \*CPickup::FindStringForTextIndex

<pre>
plugin::CallAndReturn<char const *, 0x455540, int>(index);
0AA7: call_function_return 0x455540 num_params 1 pop 1 [index] func_ret [char const *]
</pre>

#### CPickup::Remove

<pre>
plugin::CallMethod<0x4556C0, CPickup *>(this);
0AA6: call_method 0x4556C0 struct [CPickup] num_params 0 pop 0
</pre>

#### CPickup::GiveUsAPickUpObject

<pre>
plugin::CallMethod<0x4567E0, CPickup *, CObject**, int>(this, pObject, objectPoolSlotIndex);
0AA6: call_method 0x4567E0 struct [CPickup] num_params 2 pop 0 [pObject] [objectPoolSlotIndex]
</pre>

#### CPickup::Update

<pre>
plugin::CallMethodAndReturn<bool,0x457410, CPickup *, CPlayerPed*, CVehicle*, int>(this, playerPed, vehicle, playerId);
0AA8: call_method_return 0x457410 struct [CPickup] num_params 3 pop 0 [playerPed] [vehicle] [playerId] func_ret [bool]
</pre>

#### CPickup::ProcessGunShot

<pre>
plugin::CallMethod<0x4588B0, CPickup *, CVector*, CVector*>(this, origin, target);
0AA6: call_method 0x4588B0 struct [CPickup] num_params 2 pop 0 [origin] [target]
</pre>

### plugin_sa\game_sa\CPickups.cpp

#### CPickups::AddToCollectedPickupsArray

<pre>
plugin::Call<0x455240, int>(handle);
0AA5: call_function 0x455240 num_params 1 pop 1 [handle]
</pre>

#### CPickups::CreatePickupCoorsCloseToCoors

<pre>
plugin::Call<0x458A80, float, float, float, float*, float*, float*>(in_x, in_y, in_z, out_x, out_y, out_z);
0AA5: call_function 0x458A80 num_params 6 pop 6 [in_x] [in_y] [in_z] [out_x] [out_y] [out_z]
</pre>

#### CPickups::CreateSomeMoney

<pre>
plugin::Call<0x458970, CVector, int>(coors, amount);
0AA5: call_function 0x458970 num_params 2 pop 2 [coors] [amount]
</pre>

#### CPickups::DetonateMinesHitByGunShot

<pre>
plugin::Call<0x4590C0, CVector*, CVector*>(shotOrigin, shotTarget);
0AA5: call_function 0x4590C0 num_params 2 pop 2 [shotOrigin] [shotTarget]
</pre>

#### CPickups::DoCollectableEffects

<pre>
plugin::Call<0x455E20, CEntity*>(entity);
0AA5: call_function 0x455E20 num_params 1 pop 1 [entity]
</pre>

#### CPickups::DoMineEffects

<pre>
plugin::Call<0x4560E0, CEntity*>(entity);
0AA5: call_function 0x4560E0 num_params 1 pop 1 [entity]
</pre>

#### CPickups::DoMoneyEffects

<pre>
plugin::Call<0x454E80, CEntity*>(entity);
0AA5: call_function 0x454E80 num_params 1 pop 1 [entity]
</pre>

#### CPickups::DoPickUpEffects

<pre>
plugin::Call<0x455720, CEntity*>(entity);
0AA5: call_function 0x455720 num_params 1 pop 1 [entity]
</pre>

#### CPickups::FindPickUpForThisObject

<pre>
plugin::CallAndReturn<CPickup*, 0x4551C0, CObject*>(object);
0AA7: call_function_return 0x4551C0 num_params 1 pop 1 [object] func_ret [CPickup*]
</pre>

#### CPickups::GenerateNewOne

<pre>
plugin::CallAndReturn<int, 0x456F20, CVector, unsigned int, unsigned char, unsigned int, unsigned int, bool, char*>(coors, modelId, pickupType, ammo, moneyPerDay, isEmpty, message);
0AA7: call_function_return 0x456F20 num_params 7 pop 7 [coors] [modelId] [pickupType] [ammo] [moneyPerDay] [isEmpty] [message] func_ret [int]
</pre>

#### CPickups::GenerateNewOne_WeaponType

<pre>
plugin::CallAndReturn<int, 0x457380, CVector, eWeaponType, unsigned char, unsigned int, bool, char*>(coors, weaponType, pickupType, ammo, isEmpty, message);
0AA7: call_function_return 0x457380 num_params 6 pop 6 [coors] [weaponType] [pickupType] [ammo] [isEmpty] [message] func_ret [int]
</pre>

#### CPickups::GetActualPickupIndex

<pre>
plugin::CallAndReturn<int, 0x4552A0, int>(pickupIndex);
0AA7: call_function_return 0x4552A0 num_params 1 pop 1 [pickupIndex] func_ret [int]
</pre>

#### CPickups::GetNewUniquePickupIndex

<pre>
plugin::CallAndReturn<int, 0x456A30, int>(pickupIndex);
0AA7: call_function_return 0x456A30 num_params 1 pop 1 [pickupIndex] func_ret [int]
</pre>

#### CPickups::GetUniquePickupIndex

<pre>
plugin::CallAndReturn<int, 0x455280, int>(pickupIndex);
0AA7: call_function_return 0x455280 num_params 1 pop 1 [pickupIndex] func_ret [int]
</pre>

#### CPickups::GivePlayerGoodiesWithPickUpMI

<pre>
plugin::CallAndReturn<bool, 0x4564F0, unsigned short, int>(modelId, playerId);
0AA7: call_function_return 0x4564F0 num_params 2 pop 2 [modelId] [playerId] func_ret [bool]
</pre>

#### CPickups::Init

<pre>
plugin::Call<0x454A70>();
0AA5: call_function 0x454A70 num_params 0 pop 0
</pre>

#### CPickups::IsPickUpPickedUp

<pre>
plugin::CallAndReturn<bool, 0x454B40, int>(pickupHandle);
0AA7: call_function_return 0x454B40 num_params 1 pop 1 [pickupHandle] func_ret [bool]
</pre>

#### CPickups::Load

<pre>
plugin::CallAndReturn<bool, 0x5D35A0>();
0AA7: call_function_return 0x5D35A0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPickups::ModelForWeapon

<pre>
plugin::CallAndReturn<int, 0x454AC0, eWeaponType>(weaponType);
0AA7: call_function_return 0x454AC0 num_params 1 pop 1 [weaponType] func_ret [int]
</pre>

#### CPickups::PassTime

<pre>
plugin::Call<0x455200, unsigned int>(time);
0AA5: call_function 0x455200 num_params 1 pop 1 [time]
</pre>

#### CPickups::PickedUpHorseShoe

<pre>
plugin::Call<0x455390>();
0AA5: call_function 0x455390 num_params 0 pop 0
</pre>

#### CPickups::PickedUpOyster

<pre>
plugin::Call<0x4552D0>();
0AA5: call_function 0x4552D0 num_params 0 pop 0
</pre>

#### CPickups::PictureTaken

<pre>
plugin::Call<0x456A70>();
0AA5: call_function 0x456A70 num_params 0 pop 0
</pre>

#### CPickups::PlayerCanPickUpThisWeaponTypeAtThisMoment

<pre>
plugin::CallAndReturn<bool, 0x4554C0, eWeaponType>(weaponType);
0AA7: call_function_return 0x4554C0 num_params 1 pop 1 [weaponType] func_ret [bool]
</pre>

#### CPickups::ReInit

<pre>
plugin::Call<0x456E60>();
0AA5: call_function 0x456E60 num_params 0 pop 0
</pre>

#### CPickups::RemoveMissionPickUps

<pre>
plugin::Call<0x456DE0>();
0AA5: call_function 0x456DE0 num_params 0 pop 0
</pre>

#### CPickups::RemovePickUp

<pre>
plugin::Call<0x4573D0, int>(pickupHandle);
0AA5: call_function 0x4573D0 num_params 1 pop 1 [pickupHandle]
</pre>

#### CPickups::RemovePickUpsInArea

<pre>
plugin::Call<0x456D30, float, float, float, float, float, float>(cornerA_x, cornerA_y, cornerA_z, cornerB_x, cornerB_y, cornerB_z);
0AA5: call_function 0x456D30 num_params 6 pop 6 [cornerA_x] [cornerA_y] [cornerA_z] [cornerB_x] [cornerB_y] [cornerB_z]
</pre>

#### CPickups::RemovePickupObjects

<pre>
plugin::Call<0x455470>();
0AA5: call_function 0x455470 num_params 0 pop 0
</pre>

#### CPickups::RemoveUnnecessaryPickups

<pre>
plugin::Call<0x4563A0, CVector const&, float>(posn, radius);
0AA5: call_function 0x4563A0 num_params 2 pop 2 [posn] [radius]
</pre>

#### CPickups::RenderPickUpText

<pre>
plugin::Call<0x455000>();
0AA5: call_function 0x455000 num_params 0 pop 0
</pre>

#### CPickups::Save

<pre>
plugin::CallAndReturn<bool, 0x5D3540>();
0AA7: call_function_return 0x5D3540 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPickups::TestForPickupsInBubble

<pre>
plugin::CallAndReturn<bool, 0x456450, CVector, float>(posn, radius);
0AA7: call_function_return 0x456450 num_params 2 pop 2 [posn] [radius] func_ret [bool]
</pre>

#### CPickups::TryToMerge_WeaponType

<pre>
plugin::CallAndReturn<bool, 0x4555A0, CVector, eWeaponType, unsigned char, unsigned int, bool>(posn, weaponType, pickupType, ammo, arg4);
0AA7: call_function_return 0x4555A0 num_params 5 pop 5 [posn] [weaponType] [pickupType] [ammo] [arg4] func_ret [bool]
</pre>

#### CPickups::Update

<pre>
plugin::Call<0x458DE0>();
0AA5: call_function 0x458DE0 num_params 0 pop 0
</pre>

#### CPickups::UpdateMoneyPerDay

<pre>
plugin::Call<0x455680, int, unsigned short>(pickupHandle, money);
0AA5: call_function 0x455680 num_params 2 pop 2 [pickupHandle] [money]
</pre>

#### CPickups::WeaponForModel

<pre>
plugin::CallAndReturn<int, 0x454AE0, int>(modelId);
0AA7: call_function_return 0x454AE0 num_params 1 pop 1 [modelId] func_ret [int]
</pre>

#### ModifyStringLabelForControlSetting

<pre>
plugin::Call<0x454B70, char*>(stringLabel);
0AA5: call_function 0x454B70 num_params 1 pop 1 [stringLabel]
</pre>

### plugin_sa\game_sa\CPlayerInfo.cpp

### plugin_sa\game_sa\CPlayerPed.cpp

#### CPlayerPed::CPlayerPed

<pre>
plugin::CallMethod<0x60D5B0, CPlayerPed *, int, bool>(this, playerId, bGroupCreated);
0AA6: call_method 0x60D5B0 struct [CPlayerPed] num_params 2 pop 0 [playerId] [bGroupCreated]
</pre>

#### CPlayerPed::RemovePlayerPed

<pre>
plugin::Call<0x6094A0, int>(playerId);
0AA5: call_function 0x6094A0 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::DeactivatePlayerPed

<pre>
plugin::Call<0x609520, int>(playerId);
0AA5: call_function 0x609520 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::ReactivatePlayerPed

<pre>
plugin::Call<0x609540, int>(playerId);
0AA5: call_function 0x609540 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::GetPadFromPlayer

<pre>
plugin::CallMethodAndReturn<CPad*, 0x609560, CPlayerPed *>(this);
0AA8: call_method_return 0x609560 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPad*]
</pre>

#### CPlayerPed::CanPlayerStartMission

<pre>
plugin::CallMethodAndReturn<bool, 0x609590, CPlayerPed *>(this);
0AA8: call_method_return 0x609590 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::IsHidden

<pre>
plugin::CallMethodAndReturn<bool, 0x609620, CPlayerPed *>(this);
0AA8: call_method_return 0x609620 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::ReApplyMoveAnims

<pre>
plugin::CallMethod<0x609650, CPlayerPed *>(this);
0AA6: call_method 0x609650 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DoesPlayerWantNewWeapon

<pre>
plugin::CallMethodAndReturn<bool, 0x609710, CPlayerPed *, eWeaponType, bool>(this, weaponType, arg1);
0AA8: call_method_return 0x609710 struct [CPlayerPed] num_params 2 pop 0 [weaponType] [arg1] func_ret [bool]
</pre>

#### CPlayerPed::ProcessPlayerWeapon

<pre>
plugin::CallMethod<0x6097F0, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x6097F0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PickWeaponAllowedFor2Player

<pre>
plugin::CallMethod<0x609800, CPlayerPed *>(this);
0AA6: call_method 0x609800 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::UpdateCameraWeaponModes

<pre>
plugin::CallMethod<0x609830, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x609830 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ProcessAnimGroups

<pre>
plugin::CallMethod<0x6098F0, CPlayerPed *>(this);
0AA6: call_method 0x6098F0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ClearWeaponTarget

<pre>
plugin::CallMethod<0x609C80, CPlayerPed *>(this);
0AA6: call_method 0x609C80 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::GetWeaponRadiusOnScreen

<pre>
plugin::CallMethodAndReturn<float, 0x609CD0, CPlayerPed *>(this);
0AA8: call_method_return 0x609CD0 struct [CPlayerPed] num_params 0 pop 0 func_ret [float]
</pre>

#### CPlayerPed::PedCanBeTargettedVehicleWise

<pre>
plugin::CallAndReturn<bool, 0x609D90, CPed*>(ped);
0AA7: call_function_return 0x609D90 num_params 1 pop 1 [ped] func_ret [bool]
</pre>

#### CPlayerPed::FindTargetPriority

<pre>
plugin::CallMethodAndReturn<float, 0x609DE0, CPlayerPed *, CEntity*>(this, entity);
0AA8: call_method_return 0x609DE0 struct [CPlayerPed] num_params 1 pop 0 [entity] func_ret [float]
</pre>

#### CPlayerPed::Clear3rdPersonMouseTarget

<pre>
plugin::CallMethod<0x609ED0, CPlayerPed *>(this);
0AA6: call_method 0x609ED0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::Busted

<pre>
plugin::CallMethod<0x609EF0, CPlayerPed *>(this);
0AA6: call_method 0x609EF0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetWantedLevel

<pre>
plugin::CallMethod<0x609F10, CPlayerPed *, int>(this, level);
0AA6: call_method 0x609F10 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::SetWantedLevelNoDrop

<pre>
plugin::CallMethod<0x609F30, CPlayerPed *, int>(this, level);
0AA6: call_method 0x609F30 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::CheatWantedLevel

<pre>
plugin::CallMethod<0x609F50, CPlayerPed *, int>(this, level);
0AA6: call_method 0x609F50 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::CanIKReachThisTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x609F80, CPlayerPed *, CVector, CWeapon*, bool>(this, posn, weapon, arg2);
0AA8: call_method_return 0x609F80 struct [CPlayerPed] num_params 3 pop 0 [posn] [weapon] [arg2] func_ret [bool]
</pre>

#### CPlayerPed::GetPlayerInfoForThisPlayerPed

<pre>
plugin::CallMethodAndReturn<CPlayerInfo*, 0x609FF0, CPlayerPed *>(this);
0AA8: call_method_return 0x609FF0 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPlayerInfo*]
</pre>

#### CPlayerPed::DoStuffToGoOnFire

<pre>
plugin::CallMethod<0x60A020, CPlayerPed *>(this);
0AA6: call_method 0x60A020 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::AnnoyPlayerPed

<pre>
plugin::CallMethod<0x60A040, CPlayerPed *, bool>(this, arg0);
0AA6: call_method 0x60A040 struct [CPlayerPed] num_params 1 pop 0 [arg0]
</pre>

#### CPlayerPed::ClearAdrenaline

<pre>
plugin::CallMethod<0x60A070, CPlayerPed *>(this);
0AA6: call_method 0x60A070 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DisbandPlayerGroup

<pre>
plugin::CallMethod<0x60A0A0, CPlayerPed *>(this);
0AA6: call_method 0x60A0A0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::MakeGroupRespondToPlayerTakingDamage

<pre>
plugin::CallMethod<0x60A110, CPlayerPed *, CEventDamage const&>(this, damageEvent);
0AA6: call_method 0x60A110 struct [CPlayerPed] num_params 1 pop 0 [damageEvent]
</pre>

#### CPlayerPed::TellGroupToStartFollowingPlayer

<pre>
plugin::CallMethod<0x60A1D0, CPlayerPed *, bool, bool, bool>(this, arg0, arg1, arg2);
0AA6: call_method 0x60A1D0 struct [CPlayerPed] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CPlayerPed::MakePlayerGroupDisappear

<pre>
plugin::CallMethod<0x60A440, CPlayerPed *>(this);
0AA6: call_method 0x60A440 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::MakePlayerGroupReappear

<pre>
plugin::CallMethod<0x60A4B0, CPlayerPed *>(this);
0AA6: call_method 0x60A4B0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ResetSprintEnergy

<pre>
plugin::CallMethod<0x60A530, CPlayerPed *>(this);
0AA6: call_method 0x60A530 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::HandleSprintEnergy

<pre>
plugin::CallMethodAndReturn<bool, 0x60A550, CPlayerPed *, bool, float>(this, arg0, arg1);
0AA8: call_method_return 0x60A550 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1] func_ret [bool]
</pre>

#### CPlayerPed::ControlButtonSprint

<pre>
plugin::CallMethodAndReturn<float, 0x60A610, CPlayerPed *, eSprintType>(this, sprintType);
0AA8: call_method_return 0x60A610 struct [CPlayerPed] num_params 1 pop 0 [sprintType] func_ret [float]
</pre>

#### CPlayerPed::GetButtonSprintResults

<pre>
plugin::CallMethodAndReturn<float, 0x60A820, CPlayerPed *, eSprintType>(this, sprintType);
0AA8: call_method_return 0x60A820 struct [CPlayerPed] num_params 1 pop 0 [sprintType] func_ret [float]
</pre>

#### CPlayerPed::ResetPlayerBreath

<pre>
plugin::CallMethod<0x60A8A0, CPlayerPed *>(this);
0AA6: call_method 0x60A8A0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::HandlePlayerBreath

<pre>
plugin::CallMethod<0x60A8D0, CPlayerPed *, bool, float>(this, arg0, arg1);
0AA6: call_method 0x60A8D0 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPlayerPed::SetRealMoveAnim

<pre>
plugin::CallMethod<0x60A9C0, CPlayerPed *>(this);
0AA6: call_method 0x60A9C0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::MakeChangesForNewWeapon

<pre>
plugin::CallMethod<0x60B460, CPlayerPed *, eWeaponType>(this, weaponType);
0AA6: call_method 0x60B460 struct [CPlayerPed] num_params 1 pop 0 [weaponType]
</pre>

#### LOSBlockedBetweenPeds

<pre>
plugin::CallAndReturn<bool, 0x60B550, CEntity*, CEntity*>(entity1, entity2);
0AA7: call_function_return 0x60B550 num_params 2 pop 2 [entity1] [entity2] func_ret [bool]
</pre>

#### CPlayerPed::Compute3rdPersonMouseTarget

<pre>
plugin::CallMethod<0x60B650, CPlayerPed *, bool>(this, meleeWeapon);
0AA6: call_method 0x60B650 struct [CPlayerPed] num_params 1 pop 0 [meleeWeapon]
</pre>

#### CPlayerPed::DrawTriangleForMouseRecruitPed

<pre>
plugin::CallMethod<0x60BA80, CPlayerPed *>(this);
0AA6: call_method 0x60BA80 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DoesTargetHaveToBeBroken

<pre>
plugin::CallMethodAndReturn<bool, 0x60C0C0, CPlayerPed *, CEntity*, CWeapon*>(this, entity, weapon);
0AA8: call_method_return 0x60C0C0 struct [CPlayerPed] num_params 2 pop 0 [entity] [weapon] func_ret [bool]
</pre>

#### CPlayerPed::KeepAreaAroundPlayerClear

<pre>
plugin::CallMethod<0x60C1E0, CPlayerPed *>(this);
0AA6: call_method 0x60C1E0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetPlayerMoveBlendRatio

<pre>
plugin::CallMethod<0x60C520, CPlayerPed *, CVector*>(this, arg0);
0AA6: call_method 0x60C520 struct [CPlayerPed] num_params 1 pop 0 [arg0]
</pre>

#### CPlayerPed::FindPedToAttack

<pre>
plugin::CallMethodAndReturn<CPed*, 0x60C5F0, CPlayerPed *>(this);
0AA8: call_method_return 0x60C5F0 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPed*]
</pre>

#### CPlayerPed::ForceGroupToAlwaysFollow

<pre>
plugin::CallMethod<0x60C7C0, CPlayerPed *, bool>(this, enable);
0AA6: call_method 0x60C7C0 struct [CPlayerPed] num_params 1 pop 0 [enable]
</pre>

#### CPlayerPed::ForceGroupToNeverFollow

<pre>
plugin::CallMethod<0x60C800, CPlayerPed *, bool>(this, enable);
0AA6: call_method 0x60C800 struct [CPlayerPed] num_params 1 pop 0 [enable]
</pre>

#### CPlayerPed::MakeThisPedJoinOurGroup

<pre>
plugin::CallMethod<0x60C840, CPlayerPed *, CPed*>(this, ped);
0AA6: call_method 0x60C840 struct [CPlayerPed] num_params 1 pop 0 [ped]
</pre>

#### CPlayerPed::PlayerWantsToAttack

<pre>
plugin::CallMethodAndReturn<bool, 0x60CC50, CPlayerPed *>(this);
0AA8: call_method_return 0x60CC50 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::SetInitialState

<pre>
plugin::CallMethod<0x60CD20, CPlayerPed *, bool>(this, bGroupCreated);
0AA6: call_method 0x60CD20 struct [CPlayerPed] num_params 1 pop 0 [bGroupCreated]
</pre>

#### CPlayerPed::MakeChangesForNewWeapon

<pre>
plugin::CallMethod<0x60D000, CPlayerPed *, int>(this, weaponSlot);
0AA6: call_method 0x60D000 struct [CPlayerPed] num_params 1 pop 0 [weaponSlot]
</pre>

#### CPlayerPed::EvaluateTarget

<pre>
plugin::CallMethod<0x60D020, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5);
0AA6: call_method 0x60D020 struct [CPlayerPed] num_params 6 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5]
</pre>

#### CPlayerPed::EvaluateNeighbouringTarget

<pre>
plugin::CallMethod<0x60D1C0, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5);
0AA6: call_method 0x60D1C0 struct [CPlayerPed] num_params 6 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5]
</pre>

#### CPlayerPed::ProcessGroupBehaviour

<pre>
plugin::CallMethod<0x60D350, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x60D350 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerHasJustAttackedSomeone

<pre>
plugin::CallMethodAndReturn<bool, 0x60D5A0, CPlayerPed *>(this);
0AA8: call_method_return 0x60D5A0 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::SetupPlayerPed

<pre>
plugin::Call<0x60D790, int>(playerId);
0AA5: call_function 0x60D790 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::ProcessWeaponSwitch

<pre>
plugin::CallMethod<0x60D850, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x60D850 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::FindWeaponLockOnTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x60DC50, CPlayerPed *>(this);
0AA8: call_method_return 0x60DC50 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::FindNextWeaponLockOnTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x60E530, CPlayerPed *, CEntity*, bool>(this, arg0, arg1);
0AA8: call_method_return 0x60E530 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1] func_ret [bool]
</pre>

#### CPlayerPed::GetWantedLevel

<pre>
plugin::CallMethodAndReturn<int, 0x41BE60, CPlayerPed *>(this);
0AA8: call_method_return 0x41BE60 struct [CPlayerPed] num_params 0 pop 0 func_ret [int]
</pre>

### plugin_sa\game_sa\CPointLights.cpp

#### CPointLights::Init

<pre>
plugin::Call<0x6FFB40>();
0AA5: call_function 0x6FFB40 num_params 0 pop 0
</pre>

#### CPointLights::GenerateLightsAffectingObject

<pre>
plugin::CallAndReturn<float, 0x6FFBB0, CVector const*, float*, CEntity*>(point, totalLighting, entity);
0AA7: call_function_return 0x6FFBB0 num_params 3 pop 3 [point] [totalLighting] [entity] func_ret [float]
</pre>

#### CPointLights::GetLightMultiplier

<pre>
plugin::CallAndReturn<float, 0x6FFE70, CVector const*>(point);
0AA7: call_function_return 0x6FFE70 num_params 1 pop 1 [point] func_ret [float]
</pre>

#### CPointLights::RemoveLightsAffectingObject

<pre>
plugin::Call<0x6FFFE0>();
0AA5: call_function 0x6FFFE0 num_params 0 pop 0
</pre>

#### CPointLights::ProcessVerticalLineUsingCache

<pre>
plugin::CallAndReturn<bool, 0x6FFFF0, CVector, float*>(point, outZ);
0AA7: call_function_return 0x6FFFF0 num_params 2 pop 2 [point] [outZ] func_ret [bool]
</pre>

#### CPointLights::AddLight

<pre>
plugin::Call<0x7000E0, unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool, CEntity*>(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows, entityAffected);
0AA5: call_function 0x7000E0 num_params 10 pop 10 [lightType] [point] [direction] [radius] [red] [green] [blue] [fogType] [generateExtraShadows] [entityAffected]
</pre>

#### CPointLights::RenderFogEffect

<pre>
plugin::Call<0x7002D0>();
0AA5: call_function 0x7002D0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPointList.cpp

#### CPointList::Empty

<pre>
plugin::CallMethodDynGlobal<CPointList *>(gaddrof(CPointList::Empty), this);
0AA6: call_method 0x699F00 struct [CPointList] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPools.cpp

#### CPools::CheckBuildingAtomics

<pre>
plugin::CallAndReturn<int, 0x550170>();
0AA7: call_function_return 0x550170 num_params 0 pop 0 func_ret [int]
</pre>

#### CPools::CheckPoolsEmpty

<pre>
plugin::Call<0x551950>();
0AA5: call_function 0x551950 num_params 0 pop 0
</pre>

#### CPools::GetObject

<pre>
plugin::CallAndReturn<CObject*, 0x550050, int>(handle);
0AA7: call_function_return 0x550050 num_params 1 pop 1 [handle] func_ret [CObject*]
</pre>

#### CPools::GetObjectRef

<pre>
plugin::CallAndReturn<int, 0x550020, CObject*>(object);
0AA7: call_function_return 0x550020 num_params 1 pop 1 [object] func_ret [int]
</pre>

#### CPools::GetPed

<pre>
plugin::CallAndReturn<CPed*, 0x54FF90, int>(handle);
0AA7: call_function_return 0x54FF90 num_params 1 pop 1 [handle] func_ret [CPed*]
</pre>

#### CPools::GetPedRef

<pre>
plugin::CallAndReturn<int, 0x54FF60, CPed*>(ped);
0AA7: call_function_return 0x54FF60 num_params 1 pop 1 [ped] func_ret [int]
</pre>

#### CPools::GetVehicle

<pre>
plugin::CallAndReturn<CVehicle*, 0x54FFF0, int>(handle);
0AA7: call_function_return 0x54FFF0 num_params 1 pop 1 [handle] func_ret [CVehicle*]
</pre>

#### CPools::GetVehicleRef

<pre>
plugin::CallAndReturn<int, 0x54FFC0, CVehicle*>(vehicle);
0AA7: call_function_return 0x54FFC0 num_params 1 pop 1 [vehicle] func_ret [int]
</pre>

#### CPools::Initialise

<pre>
plugin::Call<0x550F10>();
0AA5: call_function 0x550F10 num_params 0 pop 0
</pre>

#### CPools::Load

<pre>
plugin::CallAndReturn<bool, 0x5D0890>();
0AA7: call_function_return 0x5D0890 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::LoadObjectPool

<pre>
plugin::CallAndReturn<bool, 0x5D4A40>();
0AA7: call_function_return 0x5D4A40 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::LoadPedPool

<pre>
plugin::CallAndReturn<bool, 0x5D2D70>();
0AA7: call_function_return 0x5D2D70 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::LoadVehiclePool

<pre>
plugin::CallAndReturn<bool, 0x5D2A20>();
0AA7: call_function_return 0x5D2A20 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::MakeSureSlotInObjectPoolIsEmpty

<pre>
plugin::Call<0x550080, int>(slot);
0AA5: call_function 0x550080 num_params 1 pop 1 [slot]
</pre>

#### CPools::Save

<pre>
plugin::CallAndReturn<bool, 0x5D0880>();
0AA7: call_function_return 0x5D0880 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::SaveObjectPool

<pre>
plugin::CallAndReturn<bool, 0x5D4940>();
0AA7: call_function_return 0x5D4940 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::SavePedPool

<pre>
plugin::CallAndReturn<bool, 0x5D4B40>();
0AA7: call_function_return 0x5D4B40 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::SaveVehiclePool

<pre>
plugin::CallAndReturn<bool, 0x5D4800>();
0AA7: call_function_return 0x5D4800 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPools::ShutDown

<pre>
plugin::Call<0x5519F0>();
0AA5: call_function 0x5519F0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CPopCycle.cpp

#### CPopCycle::FindNewPedType

<pre>
plugin::CallAndReturn<bool, 0x60FBD0, ePedType*, int*, bool, bool>(arg1, modelindex, arg3, arg4);
0AA7: call_function_return 0x60FBD0 num_params 4 pop 4 [arg1] [modelindex] [arg3] [arg4] func_ret [bool]
</pre>

#### CPopCycle::GetCurrentPercOther_Peds

<pre>
plugin::CallAndReturn<float, 0x610310>();
0AA7: call_function_return 0x610310 num_params 0 pop 0 func_ret [float]
</pre>

#### CPopCycle::Initialise

<pre>
plugin::Call<0x5BC090>();
0AA5: call_function 0x5BC090 num_params 0 pop 0
</pre>

#### CPopCycle::IsPedAppropriateForCurrentZone

<pre>
plugin::CallAndReturn<bool, 0x610150, int>(modelindex);
0AA7: call_function_return 0x610150 num_params 1 pop 1 [modelindex] func_ret [bool]
</pre>

#### CPopCycle::IsPedInGroup

<pre>
plugin::CallAndReturn<bool, 0x610210, int, int>(modelIndex, PopCycle_Group);
0AA7: call_function_return 0x610210 num_params 2 pop 2 [modelIndex] [PopCycle_Group] func_ret [bool]
</pre>

#### CPopCycle::PedIsAcceptableInCurrentZone

<pre>
plugin::CallAndReturn<bool, 0x610720, int>(modelIndex);
0AA7: call_function_return 0x610720 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopCycle::PickARandomGroupOfOtherPeds

<pre>
plugin::CallAndReturn<int, 0x610420>();
0AA7: call_function_return 0x610420 num_params 0 pop 0 func_ret [int]
</pre>

#### CPopCycle::PlayerKilledADealer

<pre>
plugin::Call<0x610490>();
0AA5: call_function 0x610490 num_params 0 pop 0
</pre>

#### CPopCycle::Update

<pre>
plugin::Call<0x610BF0>();
0AA5: call_function 0x610BF0 num_params 0 pop 0
</pre>

#### CPopCycle::UpdateAreaDodgyness

<pre>
plugin::Call<0x610560>();
0AA5: call_function 0x610560 num_params 0 pop 0
</pre>

#### CPopCycle::UpdateDealerStrengths

<pre>
plugin::Call<0x6104B0>();
0AA5: call_function 0x6104B0 num_params 0 pop 0
</pre>

#### CPopCycle::UpdatePercentages

<pre>
plugin::Call<0x610770>();
0AA5: call_function 0x610770 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CProjectileInfo.cpp

#### CProjectileInfo::Initialise

<pre>
plugin::Call<0x737B40>();
0AA5: call_function 0x737B40 num_params 0 pop 0
</pre>

#### CProjectileInfo::RemoveFXSystem

<pre>
plugin::Call<0x737B80, unsigned char>(bInstantly);
0AA5: call_function 0x737B80 num_params 1 pop 1 [bInstantly]
</pre>

#### CProjectileInfo::Shutdown

<pre>
plugin::Call<0x737BC0>();
0AA5: call_function 0x737BC0 num_params 0 pop 0
</pre>

#### CProjectileInfo::GetProjectileInfo

<pre>
plugin::CallAndReturn<CProjectileInfo*, 0x737BF0, int>(infoId);
0AA7: call_function_return 0x737BF0 num_params 1 pop 1 [infoId] func_ret [CProjectileInfo*]
</pre>

#### CProjectileInfo::RemoveNotAdd

<pre>
plugin::Call<0x737C00, CEntity*, eWeaponType, CVector>(creator, weaponType, posn);
0AA5: call_function 0x737C00 num_params 3 pop 3 [creator] [weaponType] [posn]
</pre>

#### CProjectileInfo::AddProjectile

<pre>
plugin::CallAndReturn<bool, 0x737C80, CEntity*, eWeaponType, CVector, float, CVector*, CEntity*>(creator, weaponType, posn, force, direction, victim);
0AA7: call_function_return 0x737C80 num_params 6 pop 6 [creator] [weaponType] [posn] [force] [direction] [victim] func_ret [bool]
</pre>

#### CProjectileInfo::RemoveDetonatorProjectiles

<pre>
plugin::Call<0x738860>();
0AA5: call_function 0x738860 num_params 0 pop 0
</pre>

#### CProjectileInfo::RemoveProjectile

<pre>
plugin::Call<0x7388F0, CProjectileInfo*, CProjectile*>(projectileInfo, projectileObject);
0AA5: call_function 0x7388F0 num_params 2 pop 2 [projectileInfo] [projectileObject]
</pre>

#### CProjectileInfo::Update

<pre>
plugin::Call<0x738B20>();
0AA5: call_function 0x738B20 num_params 0 pop 0
</pre>

#### CProjectileInfo::IsProjectileInRange

<pre>
plugin::CallAndReturn<bool, 0x739860, float, float, float, float, float, float, bool>(x1, y1, z1, x2, y2, z2, bDestroy);
0AA7: call_function_return 0x739860 num_params 7 pop 7 [x1] [y1] [z1] [x2] [y2] [z2] [bDestroy] func_ret [bool]
</pre>

#### CProjectileInfo::RemoveAllProjectiles

<pre>
plugin::Call<0x7399B0>();
0AA5: call_function 0x7399B0 num_params 0 pop 0
</pre>

#### CProjectileInfo::RemoveIfThisIsAProjectile

<pre>
plugin::CallAndReturn<bool, 0x739A40, CObject*>(object);
0AA7: call_function_return 0x739A40 num_params 1 pop 1 [object] func_ret [bool]
</pre>

### plugin_sa\game_sa\CPtrList.cpp

#### CPtrList::CountElements

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5521B0, CPtrList *>(this);
0AA8: call_method_return 0x5521B0 struct [CPtrList] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CPtrList::IsMemberOfList

<pre>
plugin::CallMethodAndReturn<bool, 0x5521D0, CPtrList *, void*>(this, memberNode);
0AA8: call_method_return 0x5521D0 struct [CPtrList] num_params 1 pop 0 [memberNode] func_ret [bool]
</pre>

### plugin_sa\game_sa\CPtrListDoubleLink.cpp

#### CPtrListDoubleLink::Flush

<pre>
plugin::CallMethod<0x552470, CPtrListDoubleLink *>(this);
0AA6: call_method 0x552470 struct [CPtrListDoubleLink] num_params 0 pop 0
</pre>

#### CPtrListDoubleLink::AddItem

<pre>
plugin::CallMethod<0x533670, CPtrListDoubleLink *, void*>(this, item);
0AA6: call_method 0x533670 struct [CPtrListDoubleLink] num_params 1 pop 0 [item]
</pre>

#### CPtrListDoubleLink::DeleteItem

<pre>
plugin::CallMethod<0x5336B0, CPtrListDoubleLink *, void*>(this, item);
0AA6: call_method 0x5336B0 struct [CPtrListDoubleLink] num_params 1 pop 0 [item]
</pre>

### plugin_sa\game_sa\CPtrListSingleLink.cpp

#### CPtrListSingleLink::Flush

<pre>
plugin::CallMethod<0x552400, CPtrListSingleLink *>(this);
0AA6: call_method 0x552400 struct [CPtrListSingleLink] num_params 0 pop 0
</pre>

#### CPtrListSingleLink::AddItem

<pre>
plugin::CallMethod<0x5335E0, CPtrListSingleLink *, void*>(this, item);
0AA6: call_method 0x5335E0 struct [CPtrListSingleLink] num_params 1 pop 0 [item]
</pre>

#### CPtrListSingleLink::DeleteItem

<pre>
plugin::CallMethod<0x533610, CPtrListSingleLink *, void*>(this, item);
0AA6: call_method 0x533610 struct [CPtrListSingleLink] num_params 1 pop 0 [item]
</pre>

### plugin_sa\game_sa\CPtrNodeDoubleLink.cpp

#### CPtrNodeDoubleLink::operator new

<pre>
plugin::CallAndReturn<void*, 0x5523C0, unsigned int>(size);
0AA7: call_function_return 0x5523C0 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CPtrNodeDoubleLink::operator delete

<pre>
plugin::Call<0x5523D0, void*>(data);
0AA5: call_function 0x5523D0 num_params 1 pop 1 [data]
</pre>

### plugin_sa\game_sa\CPtrNodeSingleLink.cpp

#### CPtrNodeSingleLink::operator new

<pre>
plugin::CallAndReturn<void*, 0x552380, unsigned int>(size);
0AA7: call_function_return 0x552380 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CPtrNodeSingleLink::operator delete

<pre>
plugin::Call<0x552390, void*>(data);
0AA5: call_function 0x552390 num_params 1 pop 1 [data]
</pre>

### plugin_sa\game_sa\CQuadTreeNode.cpp

#### CQuadTreeNode::AddItem

<pre>
plugin::CallMethod<0x552CD0, CQuadTreeNode *, void*, CRect const&>(this, item, rect);
0AA6: call_method 0x552CD0 struct [CQuadTreeNode] num_params 2 pop 0 [item] [rect]
</pre>

#### CQuadTreeNode::CQuadTreeNode

<pre>
plugin::CallMethod<0x552830, CQuadTreeNode *, CRect const&, int>(this, rect, startLevel);
0AA6: call_method 0x552830 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [startLevel]
</pre>

#### CQuadTreeNode::DeleteItem

<pre>
plugin::CallMethod<0x552A40, CQuadTreeNode *, void*>(this, item);
0AA6: call_method 0x552A40 struct [CQuadTreeNode] num_params 1 pop 0 [item]
</pre>

#### CQuadTreeNode::DeleteItem

<pre>
plugin::CallMethod<0x552A90, CQuadTreeNode *, void*, CRect const&>(this, item, rect);
0AA6: call_method 0x552A90 struct [CQuadTreeNode] num_params 2 pop 0 [item] [rect]
</pre>

#### CQuadTreeNode::FindSector

<pre>
plugin::CallMethodAndReturn<int, 0x5525A0, CQuadTreeNode *, CRect const&>(this, rect);
0AA8: call_method_return 0x5525A0 struct [CQuadTreeNode] num_params 1 pop 0 [rect] func_ret [int]
</pre>

#### CQuadTreeNode::FindSector

<pre>
plugin::CallMethodAndReturn<int, 0x552640, CQuadTreeNode *, CVector2D const&>(this, posn);
0AA8: call_method_return 0x552640 struct [CQuadTreeNode] num_params 1 pop 0 [posn] func_ret [int]
</pre>

#### CQuadTreeNode::ForAllMatching

<pre>
plugin::CallMethod<0x552980, CQuadTreeNode *, CRect const&, void(*)(CRect const&, void *)>(this, rect, callback);
0AA6: call_method 0x552980 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [callback]
</pre>

#### CQuadTreeNode::ForAllMatching

<pre>
plugin::CallMethod<0x5529F0, CQuadTreeNode *, CVector2D const&, void(*)(CVector2D const&, void *)>(this, posn, callback);
0AA6: call_method 0x5529F0 struct [CQuadTreeNode] num_params 2 pop 0 [posn] [callback]
</pre>

#### CQuadTreeNode::GetAll

<pre>
plugin::CallMethod<0x552870, CQuadTreeNode *, CPtrListSingleLink&>(this, list);
0AA6: call_method 0x552870 struct [CQuadTreeNode] num_params 1 pop 0 [list]
</pre>

#### CQuadTreeNode::GetAllMatching

<pre>
plugin::CallMethod<0x5528C0, CQuadTreeNode *, CRect const&, CPtrListSingleLink&>(this, rect, list);
0AA6: call_method 0x5528C0 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [list]
</pre>

#### CQuadTreeNode::GetAllMatching

<pre>
plugin::CallMethod<0x552930, CQuadTreeNode *, CVector2D const&, CPtrListSingleLink&>(this, posn, list);
0AA6: call_method 0x552930 struct [CQuadTreeNode] num_params 2 pop 0 [posn] [list]
</pre>

#### CQuadTreeNode::InSector

<pre>
plugin::CallMethodAndReturn<bool, 0x5526A0, CQuadTreeNode *, CRect const&, int>(this, rect, sector);
0AA8: call_method_return 0x5526A0 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [sector] func_ret [bool]
</pre>

#### CQuadTreeNode::InitPool

<pre>
plugin::CallMethod<0x552C00, CQuadTreeNode *>(this);
0AA6: call_method 0x552C00 struct [CQuadTreeNode] num_params 0 pop 0
</pre>

#### CQuadTreeNode::operator delete

<pre>
plugin::Call<0x552C90, void*>(data);
0AA5: call_function 0x552C90 num_params 1 pop 1 [data]
</pre>

#### CQuadTreeNode::operator new

<pre>
plugin::CallAndReturn<void*, 0x552C80, unsigned int>(size);
0AA7: call_function_return 0x552C80 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CQuadTreeNode::~CQuadTreeNode

<pre>
plugin::CallMethod<0x552520, CQuadTreeNode *>(this);
0AA6: call_method 0x552520 struct [CQuadTreeNode] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CRegisteredMotionBlurStreak.cpp

#### CRegisteredMotionBlurStreak::Update

<pre>
plugin::CallMethod<0x721EE0, CRegisteredMotionBlurStreak *>(this);
0AA6: call_method 0x721EE0 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0
</pre>

#### CRegisteredMotionBlurStreak::Render

<pre>
plugin::CallMethod<0x721F70, CRegisteredMotionBlurStreak *>(this);
0AA6: call_method 0x721F70 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CRenderer.cpp

#### CRenderer::Init

<pre>
plugin::Call<0x5531C0>();
0AA5: call_function 0x5531C0 num_params 0 pop 0
</pre>

#### CRenderer::Shutdown

<pre>
plugin::Call<0x5531D0>();
0AA5: call_function 0x5531D0 num_params 0 pop 0
</pre>

#### CRenderer::RenderFadingInEntities

<pre>
plugin::Call<0x5531E0>();
0AA5: call_function 0x5531E0 num_params 0 pop 0
</pre>

#### CRenderer::RenderFadingInUnderwaterEntities

<pre>
plugin::Call<0x553220>();
0AA5: call_function 0x553220 num_params 0 pop 0
</pre>

#### CRenderer::RenderOneRoad

<pre>
plugin::Call<0x553230, CEntity*>(entity);
0AA5: call_function 0x553230 num_params 1 pop 1 [entity]
</pre>

#### CRenderer::RenderOneNonRoad

<pre>
plugin::Call<0x553260, CEntity*>(entity);
0AA5: call_function 0x553260 num_params 1 pop 1 [entity]
</pre>

#### CRenderer::RemoveVehiclePedLights

<pre>
plugin::Call<0x553390, CPhysical*>(entity);
0AA5: call_function 0x553390 num_params 1 pop 1 [entity]
</pre>

#### CRenderer::AddEntityToRenderList

<pre>
plugin::Call<0x5534B0, CEntity*, float>(entity, distance);
0AA5: call_function 0x5534B0 num_params 2 pop 2 [entity] [distance]
</pre>

#### CRenderer::ScanSectorList_ListModels

<pre>
plugin::Call<0x5535D0, int, int>(sector_x, sector_y);
0AA5: call_function 0x5535D0 num_params 2 pop 2 [sector_x] [sector_y]
</pre>

#### CRenderer::ScanSectorList_ListModelsVisible

<pre>
plugin::Call<0x553650, int, int>(sector_x, sector_y);
0AA5: call_function 0x553650 num_params 2 pop 2 [sector_x] [sector_y]
</pre>

#### CRenderer::GetLodRenderListBase

<pre>
plugin::CallAndReturn<tRenderListEntry*, 0x5536D0>();
0AA7: call_function_return 0x5536D0 num_params 0 pop 0 func_ret [tRenderListEntry*]
</pre>

#### CRenderer::GetLodDontRenderListBase

<pre>
plugin::CallAndReturn<tRenderListEntry*, 0x5536E0>();
0AA7: call_function_return 0x5536E0 num_params 0 pop 0 func_ret [tRenderListEntry*]
</pre>

#### CRenderer::ResetLodRenderLists

<pre>
plugin::Call<0x5536F0>();
0AA5: call_function 0x5536F0 num_params 0 pop 0
</pre>

#### CRenderer::AddToLodRenderList

<pre>
plugin::Call<0x553710, CEntity*, float>(entity, distance);
0AA5: call_function 0x553710 num_params 2 pop 2 [entity] [distance]
</pre>

#### CRenderer::AddToLodDontRenderList

<pre>
plugin::Call<0x553740, CEntity*, float>(entity, distance);
0AA5: call_function 0x553740 num_params 2 pop 2 [entity] [distance]
</pre>

#### CRenderer::ProcessLodRenderLists

<pre>
plugin::Call<0x553770>();
0AA5: call_function 0x553770 num_params 0 pop 0
</pre>

#### CRenderer::PreRender

<pre>
plugin::Call<0x553910>();
0AA5: call_function 0x553910 num_params 0 pop 0
</pre>

#### CRenderer::RenderRoads

<pre>
plugin::Call<0x553A10>();
0AA5: call_function 0x553A10 num_params 0 pop 0
</pre>

#### CRenderer::RenderEverythingBarRoads

<pre>
plugin::Call<0x553AA0>();
0AA5: call_function 0x553AA0 num_params 0 pop 0
</pre>

#### CRenderer::RenderFirstPersonVehicle

<pre>
plugin::Call<0x553D00>();
0AA5: call_function 0x553D00 num_params 0 pop 0
</pre>

#### CRenderer::SetupLightingForEntity

<pre>
plugin::CallAndReturn<bool, 0x553E40, CEntity*>(entity);
0AA7: call_function_return 0x553E40 num_params 1 pop 1 [entity] func_ret [bool]
</pre>

#### CRenderer::SetupMapEntityVisibility

<pre>
plugin::CallAndReturn<int, 0x553F60, CEntity*, CBaseModelInfo*, float, bool>(entity, modelInfo, distance, arg3);
0AA7: call_function_return 0x553F60 num_params 4 pop 4 [entity] [modelInfo] [distance] [arg3] func_ret [int]
</pre>

#### CRenderer::SetupEntityVisibility

<pre>
plugin::CallAndReturn<int, 0x554230, CEntity*, float&>(entity, outDistance);
0AA7: call_function_return 0x554230 num_params 2 pop 2 [entity] [outDistance] func_ret [int]
</pre>

#### CRenderer::SetupBigBuildingVisibility

<pre>
plugin::CallAndReturn<int, 0x554650, CEntity*, float&>(entity, outDistance);
0AA7: call_function_return 0x554650 num_params 2 pop 2 [entity] [outDistance] func_ret [int]
</pre>

#### CRenderer::ScanSectorList

<pre>
plugin::Call<0x554840, int, int>(sector_x, sector_y);
0AA5: call_function 0x554840 num_params 2 pop 2 [sector_x] [sector_y]
</pre>

#### CRenderer::ScanBigBuildingList

<pre>
plugin::Call<0x554B10, int, int>(sector_x, sector_y);
0AA5: call_function 0x554B10 num_params 2 pop 2 [sector_x] [sector_y]
</pre>

#### CRenderer::GetObjectsInFrustum

<pre>
plugin::CallAndReturn<int, 0x554C60, CEntity**, float, RwMatrixTag*>(outEntities, distance, transformMat);
0AA7: call_function_return 0x554C60 num_params 3 pop 3 [outEntities] [distance] [transformMat] func_ret [int]
</pre>

#### CRenderer::ShouldModelBeStreamed

<pre>
plugin::CallAndReturn<bool, 0x554EB0, CEntity*, CVector const&, float>(entity, origin, farClip);
0AA7: call_function_return 0x554EB0 num_params 3 pop 3 [entity] [origin] [farClip] func_ret [bool]
</pre>

#### CRenderer::ScanWorld

<pre>
plugin::Call<0x554FE0>();
0AA5: call_function 0x554FE0 num_params 0 pop 0
</pre>

#### CRenderer::ScanPtrList_RequestModels

<pre>
plugin::Call<0x555680, CPtrList&>(ptrList);
0AA5: call_function 0x555680 num_params 1 pop 1 [ptrList]
</pre>

#### CRenderer::ConstructRenderList

<pre>
plugin::Call<0x5556E0>();
0AA5: call_function 0x5556E0 num_params 0 pop 0
</pre>

#### CRenderer::ScanSectorList_RequestModels

<pre>
plugin::Call<0x555900, int, int>(sector_x, sector_y);
0AA5: call_function 0x555900 num_params 2 pop 2 [sector_x] [sector_y]
</pre>

#### CRenderer::RequestObjectsInFrustum

<pre>
plugin::Call<0x555960, RwMatrixTag*, int>(transformMat, modelRequesFlags);
0AA5: call_function 0x555960 num_params 2 pop 2 [transformMat] [modelRequesFlags]
</pre>

#### CRenderer::RequestObjectsInDirection

<pre>
plugin::Call<0x555CB0, CVector const&, float, int>(posn, angle, modelRequesFlags);
0AA5: call_function 0x555CB0 num_params 3 pop 3 [posn] [angle] [modelRequesFlags]
</pre>

#### CRenderer::SetupScanLists

<pre>
plugin::Call<0x553540, int, int>(sector_x, sector_y);
0AA5: call_function 0x553540 num_params 2 pop 2 [sector_x] [sector_y]
</pre>

### plugin_sa\game_sa\CRoadBlocks.cpp

#### CRoadBlocks::RegisterScriptRoadBlock

<pre>
plugin::CallDynGlobal<CVector *, CVector *, byte>(gaddrof(CRoadBlocks::RegisterScriptRoadBlock), cornerA, cornerB, type);
</pre>

#### CRoadBlocks::ClearScriptRoadBlocks

<pre>
plugin::CallDynGlobal<>(gaddrof(CRoadBlocks::ClearScriptRoadBlocks));
</pre>

#### CRoadBlocks::Init

<pre>
plugin::CallDynGlobal<>(gaddrof(CRoadBlocks::Init));
</pre>

#### CRoadBlocks::GenerateRoadBlockCopsForCar

<pre>
plugin::CallDynGlobal<CVehicle *, int, byte>(gaddrof(CRoadBlocks::GenerateRoadBlockCopsForCar), car, pedsPositionsType, type);
</pre>

#### CRoadBlocks::CreateRoadBlockBetween2Points

<pre>
plugin::CallDynGlobal<CVector *, CVector *, byte>(gaddrof(CRoadBlocks::CreateRoadBlockBetween2Points), a, b, type);
</pre>

#### CRoadBlocks::GenerateRoadBlocks

<pre>
plugin::CallDynGlobal<>(gaddrof(CRoadBlocks::GenerateRoadBlocks));
</pre>

### plugin_sa\game_sa\CRunningScript.cpp

#### CRunningScript::AddScriptToList

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript **>(gaddrof(CRunningScript::AddScriptToList), this, queuelist);
0AA6: call_method 0x464C00 struct [CRunningScript] num_params 1 pop 0 [queuelist]
</pre>

#### CRunningScript::CarInAreaCheckCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CarInAreaCheckCommand), this, commandID);
0AA6: call_method 0x488EC0 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::CharInAngledAreaCheckCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CharInAngledAreaCheckCommand), this, commandID);
0AA6: call_method 0x487F60 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::CharInAreaCheckCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CharInAreaCheckCommand), this, commandID);
0AA6: call_method 0x488B50 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::CollectNextParameterWithoutIncreasingPC

<pre>
plugin::CallMethodAndReturnDynGlobal<tScriptParam, CRunningScript *>(gaddrof(CRunningScript::CollectNextParameterWithoutIncreasingPC), this);
0AA8: call_method_return 0x464250 struct [CRunningScript] num_params 0 pop 0 func_ret [tScriptParam]
</pre>

#### CRunningScript::CollectParameters

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, short>(gaddrof(CRunningScript::CollectParameters), this, count);
0AA6: call_method 0x464080 struct [CRunningScript] num_params 1 pop 0 [count]
</pre>

#### CRunningScript::DoDeatharrestCheck

<pre>
plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::DoDeatharrestCheck), this);
0AA6: call_method 0x485A50 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::FlameInAngledAreaCheckCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::FlameInAngledAreaCheckCommand), this, commandID);
0AA6: call_method 0x488780 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::GetCorrectPedModelIndexForEmergencyServiceType

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, ePedType, int *>(gaddrof(CRunningScript::GetCorrectPedModelIndexForEmergencyServiceType), this, pedType, pModelId);
0AA6: call_method 0x464F50 struct [CRunningScript] num_params 2 pop 0 [pedType] [pModelId]
</pre>

#### CRunningScript::GetIndexOfGlobalVariable

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CRunningScript *>(gaddrof(CRunningScript::GetIndexOfGlobalVariable), this);
0AA8: call_method_return 0x464700 struct [CRunningScript] num_params 0 pop 0 func_ret [short]
</pre>

#### CRunningScript::GetPadState

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CRunningScript *, unsigned short, unsigned short>(gaddrof(CRunningScript::GetPadState), this, playerIndex, buttonID);
0AA8: call_method_return 0x485B10 struct [CRunningScript] num_params 2 pop 0 [playerIndex] [buttonID] func_ret [short]
</pre>

#### \*CRunningScript::GetPointerToLocalArrayElement

<pre>
plugin::CallMethodAndReturnDynGlobal<void*,CRunningScript *, int, unsigned short, unsigned char>(gaddrof(CRunningScript::GetPointerToLocalArrayElement), this, off, idx, mul);
0AA8: call_method_return 0x463CC0 struct [*CRunningScript] num_params 3 pop 0 [off] [idx] [mul] func_ret [void*]
</pre>

#### \*CRunningScript::GetPointerToLocalVariable

<pre>
plugin::CallMethodAndReturnDynGlobal<void* ,CRunningScript *, int>(gaddrof(CRunningScript::GetPointerToLocalVariable), this, varId);
0AA8: call_method_return 0x463CA0 struct [*CRunningScript] num_params 1 pop 0 [varId] func_ret [void*]
</pre>

#### \*CRunningScript::GetPointerToScriptVariable

<pre>
plugin::CallMethodAndReturnDynGlobal<tScriptParam *, CRunningScript *, unsigned char>(gaddrof(CRunningScript::GetPointerToScriptVariable), this, variableType);
0AA8: call_method_return 0x464790 struct [*CRunningScript] num_params 1 pop 0 [variableType] func_ret [tScriptParam *]
</pre>

#### CRunningScript::GivePedScriptedTask

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int, CTask *, int>(gaddrof(CRunningScript::GivePedScriptedTask), this, pedHandle, task, commandID);
0AA6: call_method 0x465C20 struct [CRunningScript] num_params 3 pop 0 [pedHandle] [task] [commandID]
</pre>

#### CRunningScript::Init

<pre>
plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::Init), this);
0AA6: call_method 0x4648E0 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::IsPedDead

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CRunningScript *, CPed *>(gaddrof(CRunningScript::IsPedDead), this, pPed);
0AA8: call_method_return 0x464D70 struct [CRunningScript] num_params 1 pop 0 [pPed] func_ret [bool]
</pre>

#### CRunningScript::LocateCarCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCarCommand), this, commandID);
0AA6: call_method 0x487A20 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::LocateCharCarCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCarCommand), this, commandID);
0AA6: call_method 0x487420 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::LocateCharCharCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCharCommand), this, commandID);
0AA6: call_method 0x4870F0 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::LocateCharCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCommand), this, commandID);
0AA6: call_method 0x486D80 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::LocateCharObjectCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharObjectCommand), this, commandID);
0AA6: call_method 0x487720 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::LocateObjectCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateObjectCommand), this, commandID);
0AA6: call_method 0x487D10 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::ObjectInAngledAreaCheckCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ObjectInAngledAreaCheckCommand), this, commandID);
0AA6: call_method 0x4883F0 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::ObjectInAreaCheckCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ObjectInAreaCheckCommand), this, commandID);
0AA6: call_method 0x489150 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::PlayAnimScriptCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::PlayAnimScriptCommand), this, commandID);
0AA6: call_method 0x470150 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::Process

<pre>
plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::Process), this);
0AA6: call_method 0x469F00 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::ProcessCommands0To99

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands0To99), this, commandID);
0AA8: call_method_return 0x465E60 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1000To1099

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1000To1099), this, commandID);
0AA8: call_method_return 0x489500 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands100To199

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands100To199), this, commandID);
0AA8: call_method_return 0x466DE0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1100To1199

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1100To1199), this, commandID);
0AA8: call_method_return 0x48A320 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1200To1299

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1200To1299), this, commandID);
0AA8: call_method_return 0x48B590 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1300To1399

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1300To1399), this, commandID);
0AA8: call_method_return 0x48CDD0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1400To1499

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1400To1499), this, commandID);
0AA8: call_method_return 0x48EAA0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1500To1599

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1500To1599), this, commandID);
0AA8: call_method_return 0x490DB0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1600To1699

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1600To1699), this, commandID);
0AA8: call_method_return 0x493FE0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1700To1799

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1700To1799), this, commandID);
0AA8: call_method_return 0x496E00 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1800To1899

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1800To1899), this, commandID);
0AA8: call_method_return 0x46D050 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands1900To1999

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1900To1999), this, commandID);
0AA8: call_method_return 0x46B460 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2000To2099

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2000To2099), this, commandID);
0AA8: call_method_return 0x472310 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands200To299

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands200To299), this, commandID);
0AA8: call_method_return 0x469390 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2100To2199

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2100To2199), this, commandID);
0AA8: call_method_return 0x470A90 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2200To2299

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2200To2299), this, commandID);
0AA8: call_method_return 0x474900 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2300To2399

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2300To2399), this, commandID);
0AA8: call_method_return 0x4762D0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2400To2499

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2400To2499), this, commandID);
0AA8: call_method_return 0x478000 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2500To2599

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2500To2599), this, commandID);
0AA8: call_method_return 0x47A760 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands2600To2699

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2600To2699), this, commandID);
0AA8: call_method_return 0x479DA0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands300To399

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands300To399), this, commandID);
0AA8: call_method_return 0x47C100 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands400To499

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands400To499), this, commandID);
0AA8: call_method_return 0x47D210 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands500To599

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands500To599), this, commandID);
0AA8: call_method_return 0x47E090 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands600To699

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands600To699), this, commandID);
0AA8: call_method_return 0x47F370 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands700To799

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands700To799), this, commandID);
0AA8: call_method_return 0x47FA30 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands800To899

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands800To899), this, commandID);
0AA8: call_method_return 0x481300 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessCommands900To999

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands900To999), this, commandID);
0AA8: call_method_return 0x483BD0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]
</pre>

#### CRunningScript::ProcessOneCommand

<pre>
plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::ProcessOneCommand), this);
0AA6: call_method 0x469EB0 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::ReadArrayInformation

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int, unsigned short *, int *>(gaddrof(CRunningScript::ReadArrayInformation), this, move, pOffset, pIdx);
0AA6: call_method 0x463CF0 struct [CRunningScript] num_params 3 pop 0 [move] [pOffset] [pIdx]
</pre>

#### CRunningScript::ReadParametersForNewlyStartedScript

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript *>(gaddrof(CRunningScript::ReadParametersForNewlyStartedScript), this, pNewScript);
0AA6: call_method 0x464500 struct [CRunningScript] num_params 1 pop 0 [pNewScript]
</pre>

#### CRunningScript::ReadTextLabelFromScript

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, char *, unsigned char>(gaddrof(CRunningScript::ReadTextLabelFromScript), this, pBuffer, nBufferLength);
0AA6: call_method 0x463D50 struct [CRunningScript] num_params 2 pop 0 [pBuffer] [nBufferLength]
</pre>

#### CRunningScript::RemoveScriptFromList

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript **>(gaddrof(CRunningScript::RemoveScriptFromList), this, queuelist);
0AA6: call_method 0x464BD0 struct [CRunningScript] num_params 1 pop 0 [queuelist]
</pre>

#### CRunningScript::ScriptTaskPickUpObject

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ScriptTaskPickUpObject), this, commandID);
0AA6: call_method 0x46AF50 struct [CRunningScript] num_params 1 pop 0 [commandID]
</pre>

#### CRunningScript::SetCharCoordinates

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, CPed *, float, float, float, bool, bool>(gaddrof(CRunningScript::SetCharCoordinates), this, pPed, x_coord, y_coord, z_coord, bWarpGang, bOffset);
0AA6: call_method 0x464DC0 struct [CRunningScript] num_params 6 pop 0 [pPed] [x_coord] [y_coord] [z_coord] [bWarpGang] [bOffset]
</pre>

#### CRunningScript::ShutdownThisScript

<pre>
plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::ShutdownThisScript), this);
0AA6: call_method 0x465AA0 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::StoreParameters

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, short>(gaddrof(CRunningScript::StoreParameters), this, count);
0AA6: call_method 0x464370 struct [CRunningScript] num_params 1 pop 0 [count]
</pre>

#### CRunningScript::ThisIsAValidRandomPed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CRunningScript *, ePedType, bool, bool, bool>(gaddrof(CRunningScript::ThisIsAValidRandomPed), this, pedType, civilian, gang, criminal);
0AA8: call_method_return 0x489490 struct [CRunningScript] num_params 4 pop 0 [pedType] [civilian] [gang] [criminal] func_ret [bool]
</pre>

#### CRunningScript::UpdateCompareFlag

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, bool>(gaddrof(CRunningScript::UpdateCompareFlag), this, state);
0AA6: call_method 0x4859D0 struct [CRunningScript] num_params 1 pop 0 [state]
</pre>

#### CRunningScript::UpdatePC

<pre>
plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::UpdatePC), this, newIP);
0AA6: call_method 0x464DA0 struct [CRunningScript] num_params 1 pop 0 [newIP]
</pre>

### plugin_sa\game_sa\CScriptResourceManager.cpp

#### CScriptResourceManager::AddToResourceManager

<pre>
plugin::CallMethodDynGlobal<CScriptResourceManager *, int, unsigned int, CRunningScript *>(gaddrof(CScriptResourceManager::AddToResourceManager), this, modelID, ResourceType, pScript);
0AA6: call_method 0x4704B0 struct [CScriptResourceManager] num_params 3 pop 0 [modelID] [ResourceType] [pScript]
</pre>

#### CScriptResourceManager::HasResourceBeenRequested

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CScriptResourceManager *, int, unsigned int>(gaddrof(CScriptResourceManager::HasResourceBeenRequested), this, ModelId, a4);
0AA8: call_method_return 0x470620 struct [CScriptResourceManager] num_params 2 pop 0 [ModelId] [a4] func_ret [bool]
</pre>

#### CScriptResourceManager::RemoveFromResourceManager

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CScriptResourceManager *, int, unsigned int, CRunningScript *>(gaddrof(CScriptResourceManager::RemoveFromResourceManager), this, modelID, ResourceType, pScript);
0AA8: call_method_return 0x470510 struct [CScriptResourceManager] num_params 3 pop 0 [modelID] [ResourceType] [pScript] func_ret [bool]
</pre>

### plugin_sa\game_sa\CScriptsForBrains.cpp

#### CScriptsForBrains::AddNewScriptBrain

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, short, short, unsigned short, signed char, signed char, float>(gaddrof(CScriptsForBrains::AddNewScriptBrain), this, ImgIndex, Model, Priority, attachType, Type, Radius);
0AA6: call_method 0x46A930 struct [CScriptsForBrains] num_params 6 pop 0 [ImgIndex] [Model] [Priority] [attachType] [Type] [Radius]
</pre>

#### CScriptsForBrains::AddNewStreamedScriptBrainForCodeUse

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, short, char *, signed char>(gaddrof(CScriptsForBrains::AddNewStreamedScriptBrainForCodeUse), this, a2, a3, attachtype);
0AA6: call_method 0x46A9C0 struct [CScriptsForBrains] num_params 3 pop 0 [a2] [a3] [attachtype]
</pre>

#### CScriptsForBrains::CheckIfNewEntityNeedsScript

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, CEntity *, signed char, void *>(gaddrof(CScriptsForBrains::CheckIfNewEntityNeedsScript), this, pEntity, attachType, unused);
0AA6: call_method 0x46FF20 struct [CScriptsForBrains] num_params 3 pop 0 [pEntity] [attachType] [unused]
</pre>

#### CScriptsForBrains::GetIndexOfScriptBrainWithThisName

<pre>
plugin::CallMethodAndReturnDynGlobal<signed short, CScriptsForBrains *, char const *, signed char>(gaddrof(CScriptsForBrains::GetIndexOfScriptBrainWithThisName), this, name, Attachtype);
0AA8: call_method_return 0x46AA30 struct [CScriptsForBrains] num_params 2 pop 0 [name] [Attachtype] func_ret [signed short]
</pre>

#### CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded), this, name);
0AA8: call_method_return 0x46AB20 struct [CScriptsForBrains] num_params 1 pop 0 [name] func_ret [bool]
</pre>

#### CScriptsForBrains::Init

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *>(gaddrof(CScriptsForBrains::Init), this);
0AA6: call_method 0x46A8C0 struct [CScriptsForBrains] num_params 0 pop 0
</pre>

#### CScriptsForBrains::IsObjectWithinBrainActivationRange

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CScriptsForBrains *, CObject *, CVector const *>(gaddrof(CScriptsForBrains::IsObjectWithinBrainActivationRange), this, entity, point);
0AA8: call_method_return 0x46B3D0 struct [CScriptsForBrains] num_params 2 pop 0 [entity] [point] func_ret [bool]
</pre>

#### CScriptsForBrains::MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded), this, name);
0AA6: call_method 0x46AAE0 struct [CScriptsForBrains] num_params 1 pop 0 [name]
</pre>

#### CScriptsForBrains::RequestAttractorScriptBrainWithThisName

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::RequestAttractorScriptBrainWithThisName), this, name);
0AA6: call_method 0x46AA80 struct [CScriptsForBrains] num_params 1 pop 0 [name]
</pre>

#### CScriptsForBrains::StartAttractorScriptBrainWithThisName

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *, CEntity *, unsigned char>(gaddrof(CScriptsForBrains::StartAttractorScriptBrainWithThisName), this, name, pEntity, bHasAScriptBrain);
0AA6: call_method 0x46B390 struct [CScriptsForBrains] num_params 3 pop 0 [name] [pEntity] [bHasAScriptBrain]
</pre>

#### CScriptsForBrains::StartNewStreamedScriptBrain

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, unsigned char, CEntity *, unsigned char>(gaddrof(CScriptsForBrains::StartNewStreamedScriptBrain), this, index, pEntity, bHasAScriptBrain);
0AA6: call_method 0x46B270 struct [CScriptsForBrains] num_params 3 pop 0 [index] [pEntity] [bHasAScriptBrain]
</pre>

#### CScriptsForBrains::StartOrRequestNewStreamedScriptBrain

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, unsigned char, CEntity *, signed char, unsigned char>(gaddrof(CScriptsForBrains::StartOrRequestNewStreamedScriptBrain), this, index, pEntity, attachType, bAddToWaitingArray);
0AA6: call_method 0x46CD80 struct [CScriptsForBrains] num_params 4 pop 0 [index] [pEntity] [attachType] [bAddToWaitingArray]
</pre>

#### CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *, CEntity *, signed char>(gaddrof(CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName), this, name, pEntity, attachType);
0AA6: call_method 0x46CED0 struct [CScriptsForBrains] num_params 3 pop 0 [name] [pEntity] [attachType]
</pre>

#### CScriptsForBrains::SwitchAllObjectBrainsWithThisID

<pre>
plugin::CallMethodDynGlobal<CScriptsForBrains *, signed char, bool>(gaddrof(CScriptsForBrains::SwitchAllObjectBrainsWithThisID), this, ID, bStatus);
0AA6: call_method 0x46A900 struct [CScriptsForBrains] num_params 2 pop 0 [ID] [bStatus]
</pre>

### plugin_sa\game_sa\CSetPiece.cpp

#### CSetPiece::TryToGenerateCopPed

<pre>
plugin::CallMethodAndReturn<CCopPed*, 0x499690, CSetPiece *, CVector2D>(this, posn);
0AA8: call_method_return 0x499690 struct [CSetPiece] num_params 1 pop 0 [posn] func_ret [CCopPed*]
</pre>

#### CSetPiece::TryToGenerateCopCar

<pre>
plugin::CallMethodAndReturn<CVehicle*, 0x4998A0, CSetPiece *, CVector2D, CVector2D>(this, posn, target);
0AA8: call_method_return 0x4998A0 struct [CSetPiece] num_params 2 pop 0 [posn] [target] func_ret [CVehicle*]
</pre>

#### CSetPiece::Update

<pre>
plugin::CallMethod<0x499A80, CSetPiece *>(this);
0AA6: call_method 0x499A80 struct [CSetPiece] num_params 0 pop 0
</pre>

#### CSetPiece::SetCornerA

<pre>
plugin::CallMethod<0x499120, CSetPiece *, CVector2D>(this, coord);
0AA6: call_method 0x499120 struct [CSetPiece] num_params 1 pop 0 [coord]
</pre>

#### CSetPiece::SetCornerB

<pre>
plugin::CallMethod<0x499150, CSetPiece *, CVector2D>(this, coord);
0AA6: call_method 0x499150 struct [CSetPiece] num_params 1 pop 0 [coord]
</pre>

#### CSetPiece::SetSpawnCoord1

<pre>
plugin::CallMethod<0x499180, CSetPiece *, CVector2D>(this, coord);
0AA6: call_method 0x499180 struct [CSetPiece] num_params 1 pop 0 [coord]
</pre>

#### CSetPiece::SetSpawnCoord2

<pre>
plugin::CallMethod<0x4991B0, CSetPiece *, CVector2D>(this, coord);
0AA6: call_method 0x4991B0 struct [CSetPiece] num_params 1 pop 0 [coord]
</pre>

#### CSetPiece::SetTargetCoord1

<pre>
plugin::CallMethod<0x4991E0, CSetPiece *, CVector2D>(this, coord);
0AA6: call_method 0x4991E0 struct [CSetPiece] num_params 1 pop 0 [coord]
</pre>

#### CSetPiece::SetTargetCoord2

<pre>
plugin::CallMethod<0x499210, CSetPiece *, CVector2D>(this, coord);
0AA6: call_method 0x499210 struct [CSetPiece] num_params 1 pop 0 [coord]
</pre>

#### CSetPiece::GetCornerAX

<pre>
plugin::CallMethodAndReturn<float, 0x499240, CSetPiece *>(this);
0AA8: call_method_return 0x499240 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetCornerAY

<pre>
plugin::CallMethodAndReturn<float, 0x499260, CSetPiece *>(this);
0AA8: call_method_return 0x499260 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetCornerBX

<pre>
plugin::CallMethodAndReturn<float, 0x499280, CSetPiece *>(this);
0AA8: call_method_return 0x499280 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetCornerBY

<pre>
plugin::CallMethodAndReturn<float, 0x4992A0, CSetPiece *>(this);
0AA8: call_method_return 0x4992A0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetSpawnCoord1X

<pre>
plugin::CallMethodAndReturn<float, 0x4992C0, CSetPiece *>(this);
0AA8: call_method_return 0x4992C0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetSpawnCoord1Y

<pre>
plugin::CallMethodAndReturn<float, 0x4992E0, CSetPiece *>(this);
0AA8: call_method_return 0x4992E0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetSpawnCoord2X

<pre>
plugin::CallMethodAndReturn<float, 0x499300, CSetPiece *>(this);
0AA8: call_method_return 0x499300 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetSpawnCoord2Y

<pre>
plugin::CallMethodAndReturn<float, 0x499320, CSetPiece *>(this);
0AA8: call_method_return 0x499320 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetTargetCoord1X

<pre>
plugin::CallMethodAndReturn<float, 0x499340, CSetPiece *>(this);
0AA8: call_method_return 0x499340 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetTargetCoord1Y

<pre>
plugin::CallMethodAndReturn<float, 0x499360, CSetPiece *>(this);
0AA8: call_method_return 0x499360 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetTargetCoord2X

<pre>
plugin::CallMethodAndReturn<float, 0x499380, CSetPiece *>(this);
0AA8: call_method_return 0x499380 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::GetTargetCoord2Y

<pre>
plugin::CallMethodAndReturn<float, 0x4993A0, CSetPiece *>(this);
0AA8: call_method_return 0x4993A0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]
</pre>

#### CSetPiece::CSetPiece

<pre>
plugin::CallMethod<0x4993C0, CSetPiece *>(this);
0AA6: call_method 0x4993C0 struct [CSetPiece] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CSetPieces.cpp

#### CSetPieces::AddOne

<pre>
plugin::Call<0x499500, unsigned char, CVector2D, CVector2D, CVector2D, CVector2D, CVector2D, CVector2D>(type, cornerA, cornerB, spawnCoord1, targetCoord1, spawnCoord2, targetCoord2);
0AA5: call_function 0x499500 num_params 7 pop 7 [type] [cornerA] [cornerB] [spawnCoord1] [targetCoord1] [spawnCoord2] [targetCoord2]
</pre>

#### CSetPieces::Init

<pre>
plugin::Call<0x4994F0>();
0AA5: call_function 0x4994F0 num_params 0 pop 0
</pre>

#### CSetPieces::Load

<pre>
plugin::CallAndReturn<bool, 0x5D3CA0>();
0AA7: call_function_return 0x5D3CA0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSetPieces::Save

<pre>
plugin::CallAndReturn<bool, 0x5D3C70>();
0AA7: call_function_return 0x5D3C70 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSetPieces::Update

<pre>
plugin::Call<0x49AA00>();
0AA5: call_function 0x49AA00 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CShinyTexts.cpp

#### CShinyTexts::Init

<pre>
plugin::Call<0x7221B0>();
0AA5: call_function 0x7221B0 num_params 0 pop 0
</pre>

#### CShinyTexts::RenderOutGeometryBuffer

<pre>
plugin::Call<0x7221C0>();
0AA5: call_function 0x7221C0 num_params 0 pop 0
</pre>

#### CShinyTexts::Render

<pre>
plugin::Call<0x724890>();
0AA5: call_function 0x724890 num_params 0 pop 0
</pre>

#### CShinyTexts::RegisterOne

<pre>
plugin::Call<0x724B60, CVector, CVector, CVector, CVector, float, float, float, float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, float>(cornerAA, cornerBA, cornerBB, cornerAB, u1, v1, u2, v2, u3, v3, u4, v4, red, green, blue, alpha, maxDistance);
0AA5: call_function 0x724B60 num_params 17 pop 17 [cornerAA] [cornerBA] [cornerBB] [cornerAB] [u1] [v1] [u2] [v2] [u3] [v3] [u4] [v4] [red] [green] [blue] [alpha] [maxDistance]
</pre>

### plugin_sa\game_sa\CShotInfo.cpp

#### CShotInfo::Initialise

<pre>
plugin::Call<0x739B60>();
0AA5: call_function 0x739B60 num_params 0 pop 0
</pre>

#### CShotInfo::Shutdown

<pre>
plugin::Call<0x739C20>();
0AA5: call_function 0x739C20 num_params 0 pop 0
</pre>

#### CShotInfo::AddShot

<pre>
plugin::CallAndReturn<bool, 0x739C30, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, origin, target);
0AA7: call_function_return 0x739C30 num_params 4 pop 4 [creator] [weaponType] [origin] [target] func_ret [bool]
</pre>

#### CShotInfo::GetFlameThrowerShotPosn

<pre>
plugin::CallAndReturn<bool, 0x739DE0, unsigned char, CVector*>(shotId, outPosn);
0AA7: call_function_return 0x739DE0 num_params 2 pop 2 [shotId] [outPosn] func_ret [bool]
</pre>

#### CShotInfo::Update

<pre>
plugin::Call<0x739E60>();
0AA5: call_function 0x739E60 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CSpecialFX.cpp

#### CSpecialFX::AddWeaponStreak

<pre>
plugin::Call<0x7233F0, int>(weaponType);
0AA5: call_function 0x7233F0 num_params 1 pop 1 [weaponType]
</pre>

#### CSpecialFX::Init

<pre>
plugin::Call<0x7268F0>();
0AA5: call_function 0x7268F0 num_params 0 pop 0
</pre>

#### CSpecialFX::Render

<pre>
plugin::Call<0x726AD0>();
0AA5: call_function 0x726AD0 num_params 0 pop 0
</pre>

#### CSpecialFX::Render2DFXs

<pre>
plugin::Call<0x721660>();
0AA5: call_function 0x721660 num_params 0 pop 0
</pre>

#### CSpecialFX::ReplayStarted

<pre>
plugin::Call<0x721D30>();
0AA5: call_function 0x721D30 num_params 0 pop 0
</pre>

#### CSpecialFX::Shutdown

<pre>
plugin::Call<0x723390>();
0AA5: call_function 0x723390 num_params 0 pop 0
</pre>

#### CSpecialFX::Update

<pre>
plugin::Call<0x726AA0>();
0AA5: call_function 0x726AA0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CSpecialPlateHandler.cpp

#### CSpecialPlateHandler::Init

<pre>
plugin::CallMethod<0x6F2D10, CSpecialPlateHandler *>(this);
0AA6: call_method 0x6F2D10 struct [CSpecialPlateHandler] num_params 0 pop 0
</pre>

#### CSpecialPlateHandler::Find

<pre>
plugin::CallMethodAndReturn<int, 0x6F2D30, CSpecialPlateHandler *, int, char*>(this, carGenId, outText);
0AA8: call_method_return 0x6F2D30 struct [CSpecialPlateHandler] num_params 2 pop 0 [carGenId] [outText] func_ret [int]
</pre>

#### CSpecialPlateHandler::Add

<pre>
plugin::CallMethod<0x6F2D90, CSpecialPlateHandler *, int, char*>(this, carGenId, plateText);
0AA6: call_method 0x6F2D90 struct [CSpecialPlateHandler] num_params 2 pop 0 [carGenId] [plateText]
</pre>

#### CSpecialPlateHandler::Remove

<pre>
plugin::CallMethod<0x6F2DD0, CSpecialPlateHandler *, int>(this, plateTextId);
0AA6: call_method 0x6F2DD0 struct [CSpecialPlateHandler] num_params 1 pop 0 [plateTextId]
</pre>

### plugin_sa\game_sa\CStats.cpp

#### CStats::GetStatID

<pre>
plugin::CallAndReturn<char*, 0x558DE0, unsigned short>(stat);
0AA7: call_function_return 0x558DE0 num_params 1 pop 1 [stat] func_ret [char*]
</pre>

#### CStats::GetStatType

<pre>
plugin::CallAndReturn<bool, 0x558E30, unsigned short>(stat);
0AA7: call_function_return 0x558E30 num_params 1 pop 1 [stat] func_ret [bool]
</pre>

#### CStats::GetStatValue

<pre>
plugin::CallAndReturn<float, 0x558E40, unsigned short>(stat);
0AA7: call_function_return 0x558E40 num_params 1 pop 1 [stat] func_ret [float]
</pre>

#### CStats::GetTimesMissionAttempted

<pre>
plugin::CallAndReturn<char, 0x558E70, unsigned char>(missionId);
0AA7: call_function_return 0x558E70 num_params 1 pop 1 [missionId] func_ret [char]
</pre>

#### CStats::RegisterMissionAttempted

<pre>
plugin::Call<0x558E80, unsigned char>(missionId);
0AA5: call_function 0x558E80 num_params 1 pop 1 [missionId]
</pre>

#### CStats::RegisterMissionPassed

<pre>
plugin::Call<0x558EA0, unsigned char>(missionId);
0AA5: call_function 0x558EA0 num_params 1 pop 1 [missionId]
</pre>

#### CStats::PopulateFavoriteRadioStationList

<pre>
plugin::CallAndReturn<bool, 0x558EC0>();
0AA7: call_function_return 0x558EC0 num_params 0 pop 0 func_ret [bool]
</pre>

#### \*CStats::GetFullFavoriteRadioStationList

<pre>
plugin::CallAndReturn<int*, 0x558F90>();
0AA7: call_function_return 0x558F90 num_params 0 pop 0 func_ret [int*]
</pre>

#### CStats::FindMostFavoriteRadioStation

<pre>
plugin::CallAndReturn<int, 0x558FA0>();
0AA7: call_function_return 0x558FA0 num_params 0 pop 0 func_ret [int]
</pre>

#### CStats::FindLeastFavoriteRadioStation

<pre>
plugin::CallAndReturn<int, 0x559010>();
0AA7: call_function_return 0x559010 num_params 0 pop 0 func_ret [int]
</pre>

#### CStats::FindCriminalRatingNumber

<pre>
plugin::CallAndReturn<int, 0x559080>();
0AA7: call_function_return 0x559080 num_params 0 pop 0 func_ret [int]
</pre>

#### CStats::GetPercentageProgress

<pre>
plugin::CallAndReturn<float, 0x5591E0>();
0AA7: call_function_return 0x5591E0 num_params 0 pop 0 func_ret [float]
</pre>

#### CStats::BuildStatLine

<pre>
plugin::Call<0x559230, char*, void*, int, void*, int>(line, pValue1, metrics, pValue2, type);
0AA5: call_function 0x559230 num_params 5 pop 5 [line] [pValue1] [metrics] [pValue2] [type]
</pre>

#### CStats::ConvertToMins

<pre>
plugin::CallAndReturn<int, 0x559540, int>(value);
0AA7: call_function_return 0x559540 num_params 1 pop 1 [value] func_ret [int]
</pre>

#### CStats::ConvertToSecs

<pre>
plugin::CallAndReturn<int, 0x559560, int>(value);
0AA7: call_function_return 0x559560 num_params 1 pop 1 [value] func_ret [int]
</pre>

#### CStats::SafeToShowThisStat

<pre>
plugin::CallAndReturn<bool, 0x559590, unsigned char>(stat);
0AA7: call_function_return 0x559590 num_params 1 pop 1 [stat] func_ret [bool]
</pre>

#### CStats::CheckForThreshold

<pre>
plugin::CallAndReturn<bool, 0x5595F0, float*, float>(pValue, range);
0AA7: call_function_return 0x5595F0 num_params 2 pop 2 [pValue] [range] func_ret [bool]
</pre>

#### CStats::IsStatCapped

<pre>
plugin::CallAndReturn<bool, 0x559630, unsigned short>(stat);
0AA7: call_function_return 0x559630 num_params 1 pop 1 [stat] func_ret [bool]
</pre>

#### CStats::ProcessReactionStatsOnDecrement

<pre>
plugin::Call<0x559730, unsigned char>(stat);
0AA5: call_function 0x559730 num_params 1 pop 1 [stat]
</pre>

#### CStats::CheckForStatsMessage

<pre>
plugin::Call<0x559760>();
0AA5: call_function 0x559760 num_params 0 pop 0
</pre>

#### CStats::LoadStatUpdateConditions

<pre>
plugin::Call<0x559860>();
0AA5: call_function 0x559860 num_params 0 pop 0
</pre>

#### CStats::LoadActionReactionStats

<pre>
plugin::Call<0x5599B0>();
0AA5: call_function 0x5599B0 num_params 0 pop 0
</pre>

#### CStats::FindMaxNumberOfGroupMembers

<pre>
plugin::CallAndReturn<int, 0x559A50>();
0AA7: call_function_return 0x559A50 num_params 0 pop 0 func_ret [int]
</pre>

#### CStats::GetFatAndMuscleModifier

<pre>
plugin::CallAndReturn<float, 0x559AF0, eStatModAbilities>(statMod);
0AA7: call_function_return 0x559AF0 num_params 1 pop 1 [statMod] func_ret [float]
</pre>

#### CStats::DecrementStat

<pre>
plugin::Call<0x559FA0, unsigned short, float>(stat, value);
0AA5: call_function 0x559FA0 num_params 2 pop 2 [stat] [value]
</pre>

#### CStats::SetStatValue

<pre>
plugin::Call<0x55A070, unsigned short, float>(stat, value);
0AA5: call_function 0x55A070 num_params 2 pop 2 [stat] [value]
</pre>

#### CStats::RegisterFastestTime

<pre>
plugin::Call<0x55A0B0, int, int>(stat, time);
0AA5: call_function 0x55A0B0 num_params 2 pop 2 [stat] [time]
</pre>

#### CStats::RegisterBestPosition

<pre>
plugin::Call<0x55A160, int, int>(stat, position);
0AA5: call_function 0x55A160 num_params 2 pop 2 [stat] [position]
</pre>

#### CStats::FindCriminalRatingString

<pre>
plugin::CallAndReturn<char*, 0x55A210>();
0AA7: call_function_return 0x55A210 num_params 0 pop 0 func_ret [char*]
</pre>

#### CStats::ConstructStatLine

<pre>
plugin::CallAndReturn<int, 0x55A780, int, unsigned char>(arg0, arg1);
0AA7: call_function_return 0x55A780 num_params 2 pop 2 [arg0] [arg1] func_ret [int]
</pre>

#### CStats::ProcessReactionStatsOnIncrement

<pre>
plugin::Call<0x55B900, unsigned char>(stat);
0AA5: call_function 0x55B900 num_params 1 pop 1 [stat]
</pre>

#### CStats::DisplayScriptStatUpdateMessage

<pre>
plugin::Call<0x55B980, unsigned char, unsigned int, float>(state, stat, value);
0AA5: call_function 0x55B980 num_params 3 pop 3 [state] [stat] [value]
</pre>

#### CStats::UpdateRespectStat

<pre>
plugin::Call<0x55BC50, unsigned char>(arg0);
0AA5: call_function 0x55BC50 num_params 1 pop 1 [arg0]
</pre>

#### CStats::UpdateSexAppealStat

<pre>
plugin::Call<0x55BF20>();
0AA5: call_function 0x55BF20 num_params 0 pop 0
</pre>

#### CStats::Init

<pre>
plugin::Call<0x55C0C0>();
0AA5: call_function 0x55C0C0 num_params 0 pop 0
</pre>

#### CStats::IncrementStat

<pre>
plugin::Call<0x55C180, unsigned short, float>(stat, value);
0AA5: call_function 0x55C180 num_params 2 pop 2 [stat] [value]
</pre>

#### CStats::SetNewRecordStat

<pre>
plugin::Call<0x55C410, unsigned short, float>(stat, value);
0AA5: call_function 0x55C410 num_params 2 pop 2 [stat] [value]
</pre>

#### CStats::UpdateFatAndMuscleStats

<pre>
plugin::Call<0x55C470, unsigned int>(value);
0AA5: call_function 0x55C470 num_params 1 pop 1 [value]
</pre>

#### CStats::UpdateStatsWhenSprinting

<pre>
plugin::Call<0x55C660>();
0AA5: call_function 0x55C660 num_params 0 pop 0
</pre>

#### CStats::UpdateStatsWhenRunning

<pre>
plugin::Call<0x55C6F0>();
0AA5: call_function 0x55C6F0 num_params 0 pop 0
</pre>

#### CStats::UpdateStatsWhenCycling

<pre>
plugin::Call<0x55C780, bool, CBmx*>(arg0, bmx);
0AA5: call_function 0x55C780 num_params 2 pop 2 [arg0] [bmx]
</pre>

#### CStats::UpdateStatsWhenSwimming

<pre>
plugin::Call<0x55C990, bool, bool>(arg0, arg1);
0AA5: call_function 0x55C990 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CStats::UpdateStatsWhenDriving

<pre>
plugin::Call<0x55CAC0, CVehicle*>(vehicle);
0AA5: call_function 0x55CAC0 num_params 1 pop 1 [vehicle]
</pre>

#### CStats::UpdateStatsWhenFlying

<pre>
plugin::Call<0x55CC00, CVehicle*>(vehicle);
0AA5: call_function 0x55CC00 num_params 1 pop 1 [vehicle]
</pre>

#### CStats::UpdateStatsWhenOnMotorBike

<pre>
plugin::Call<0x55CD60, CBike*>(bike);
0AA5: call_function 0x55CD60 num_params 1 pop 1 [bike]
</pre>

#### CStats::UpdateStatsWhenWeaponHit

<pre>
plugin::Call<0x55CEB0, int>(weaponType);
0AA5: call_function 0x55CEB0 num_params 1 pop 1 [weaponType]
</pre>

#### CStats::UpdateStatsWhenFighting

<pre>
plugin::Call<0x55CFA0>();
0AA5: call_function 0x55CFA0 num_params 0 pop 0
</pre>

#### CStats::UpdateStatsOnRespawn

<pre>
plugin::Call<0x55CFC0>();
0AA5: call_function 0x55CFC0 num_params 0 pop 0
</pre>

#### CStats::UpdateStatsAddToHealth

<pre>
plugin::Call<0x55D030, unsigned int>(addToHealth);
0AA5: call_function 0x55D030 num_params 1 pop 1 [addToHealth]
</pre>

#### CStats::ModifyStat

<pre>
plugin::Call<0x55D090, unsigned short, float>(stat, value);
0AA5: call_function 0x55D090 num_params 2 pop 2 [stat] [value]
</pre>

#### CStats::Save

<pre>
plugin::CallAndReturn<bool, 0x5D3B40>();
0AA7: call_function_return 0x5D3B40 num_params 0 pop 0 func_ret [bool]
</pre>

#### CStats::Load

<pre>
plugin::CallAndReturn<bool, 0x5D3BF0>();
0AA7: call_function_return 0x5D3BF0 num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_sa\game_sa\CStreamedScripts.cpp

#### CStreamedScripts::FindStreamedScript

<pre>
plugin::CallMethodAndReturnDynGlobal<signed int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::FindStreamedScript), this, scriptname);
0AA8: call_method_return 0x470740 struct [CStreamedScripts] num_params 1 pop 0 [scriptname] func_ret [signed int]
</pre>

#### CStreamedScripts::FindStreamedScriptQuiet

<pre>
plugin::CallMethodAndReturnDynGlobal<signed int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::FindStreamedScriptQuiet), this, scriptName);
0AA8: call_method_return 0x4706F0 struct [CStreamedScripts] num_params 1 pop 0 [scriptName] func_ret [signed int]
</pre>

#### CStreamedScripts::GetProperIndexFromIndexUsedByScript

<pre>
plugin::CallMethodAndReturnDynGlobal<signed short, CStreamedScripts *, short>(gaddrof(CStreamedScripts::GetProperIndexFromIndexUsedByScript), this, scmIndex);
0AA8: call_method_return 0x470810 struct [CStreamedScripts] num_params 1 pop 0 [scmIndex] func_ret [signed short]
</pre>

#### \*CStreamedScripts::GetStreamedScriptFilename

<pre>
plugin::CallMethodAndReturnDynGlobal<char const *, CStreamedScripts *, unsigned short>(gaddrof(CStreamedScripts::GetStreamedScriptFilename), this, index);
0AA8: call_method_return 0x470900 struct [*CStreamedScripts] num_params 1 pop 0 [index] func_ret [char const *]
</pre>

#### CStreamedScripts::GetStreamedScriptWithThisStartAddress

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned short, CStreamedScripts *, unsigned char *>(gaddrof(CStreamedScripts::GetStreamedScriptWithThisStartAddress), this, dataPtr);
0AA8: call_method_return 0x470910 struct [CStreamedScripts] num_params 1 pop 0 [dataPtr] func_ret [unsigned short]
</pre>

#### CStreamedScripts::Initialise

<pre>
plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::Initialise), this);
0AA6: call_method 0x470660 struct [CStreamedScripts] num_params 0 pop 0
</pre>

#### CStreamedScripts::LoadStreamedScript

<pre>
plugin::CallMethodDynGlobal<CStreamedScripts *, RwStream *, int>(gaddrof(CStreamedScripts::LoadStreamedScript), this, stream, index);
0AA6: call_method 0x470840 struct [CStreamedScripts] num_params 2 pop 0 [stream] [index]
</pre>

#### CStreamedScripts::ReInitialise

<pre>
plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::ReInitialise), this);
0AA6: call_method 0x4706A0 struct [CStreamedScripts] num_params 0 pop 0
</pre>

#### CStreamedScripts::ReadStreamedScriptData

<pre>
plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::ReadStreamedScriptData), this);
0AA6: call_method 0x470750 struct [CStreamedScripts] num_params 0 pop 0
</pre>

#### CStreamedScripts::RegisterScript

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::RegisterScript), this, scriptName);
0AA8: call_method_return 0x4706C0 struct [CStreamedScripts] num_params 1 pop 0 [scriptName] func_ret [int]
</pre>

#### CStreamedScripts::RemoveStreamedScriptFromMemory

<pre>
plugin::CallMethodDynGlobal<CStreamedScripts *, int>(gaddrof(CStreamedScripts::RemoveStreamedScriptFromMemory), this, index);
0AA6: call_method 0x4708E0 struct [CStreamedScripts] num_params 1 pop 0 [index]
</pre>

#### \*CStreamedScripts::StartNewStreamedScript

<pre>
plugin::CallMethodAndReturnDynGlobal<CRunningScript *, CStreamedScripts *, int>(gaddrof(CStreamedScripts::StartNewStreamedScript), this, index);
0AA8: call_method_return 0x470890 struct [*CStreamedScripts] num_params 1 pop 0 [index] func_ret [CRunningScript *]
</pre>

### plugin_sa\game_sa\CStreaming.cpp

#### \*CStreaming::AddEntity

<pre>
plugin::CallAndReturnDynGlobal<void *, CEntity *>(gaddrof(CStreaming::AddEntity), a2);
</pre>

#### CStreaming::AddImageToList

<pre>
plugin::CallAndReturnDynGlobal<int, char const *, bool>(gaddrof(CStreaming::AddImageToList), lpFileName, bNotPlayerImg);
</pre>

#### CStreaming::AddLodsToRequestList

<pre>
plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddLodsToRequestList), Posn, Streamingflags);
</pre>

#### CStreaming::AddModelsToRequestList

<pre>
plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddModelsToRequestList), posn, StreamingFlags);
</pre>

#### CStreaming::AddToLoadedVehiclesList

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::AddToLoadedVehiclesList));
</pre>

#### CStreaming::AreAnimsUsedByRequestedModels

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreAnimsUsedByRequestedModels), AnimFileIndex);
</pre>

#### CStreaming::AreTexturesUsedByRequestedModels

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreTexturesUsedByRequestedModels), txdIndex);
</pre>

#### CStreaming::ClearFlagForAll

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CStreaming::ClearFlagForAll), eStreamingFlag);
</pre>

#### CStreaming::ClearSlots

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::ClearSlots), NumOfSlots);
</pre>

#### CStreaming::ConvertBufferToObject

<pre>
plugin::CallAndReturnDynGlobal<char, char *, int, int>(gaddrof(CStreaming::ConvertBufferToObject), pFileContect, index, ChannelIndex);
</pre>

#### CStreaming::DeleteLeastUsedEntityRwObject

<pre>
plugin::CallAndReturnDynGlobal<bool, bool, unsigned int>(gaddrof(CStreaming::DeleteLeastUsedEntityRwObject), bNotOnScreen, StreamingFlags);
</pre>

#### CStreaming::DeleteRwObjectsAfterDeath

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteRwObjectsAfterDeath), PlayerPosn);
</pre>

#### CStreaming::DeleteRwObjectsBehindCamera

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::DeleteRwObjectsBehindCamera), memoryToCleanInBytes);
</pre>

#### CStreaming::DeleteRwObjectsBehindCameraInSectorList

<pre>
plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsBehindCameraInSectorList), List, memoryToCleanInBytes);
</pre>

#### CStreaming::DeleteRwObjectsInSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, int, int>(gaddrof(CStreaming::DeleteRwObjectsInSectorList), PtrList, arg2, arg3);
</pre>

#### CStreaming::DeleteRwObjectsNotInFrustumInSectorList

<pre>
plugin::CallAndReturnDynGlobal<char, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsNotInFrustumInSectorList), List, memoryToCleanInBytes);
</pre>

#### CStreaming::DisableCopBikes

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CStreaming::DisableCopBikes), bDisable);
</pre>

#### CStreaming::FindMIPedSlotForInterior

<pre>
plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CStreaming::FindMIPedSlotForInterior), RandFactor);
</pre>

#### CStreaming::FinishLoadingLargeFile

<pre>
plugin::CallAndReturnDynGlobal<bool, char *, int>(gaddrof(CStreaming::FinishLoadingLargeFile), FileName, modelIndex);
</pre>

#### CStreaming::FlushChannels

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::FlushChannels));
</pre>

#### CStreaming::FlushRequestList

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::FlushRequestList));
</pre>

#### CStreaming::ForceLayerToRead

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::ForceLayerToRead), arg1);
</pre>

#### CStreaming::GetDefaultCabDriverModel

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultCabDriverModel));
</pre>

#### CStreaming::GetDefaultCopCarModel

<pre>
plugin::CallAndReturnDynGlobal<int, unsigned int>(gaddrof(CStreaming::GetDefaultCopCarModel), bIncludeCopBike);
</pre>

#### CStreaming::GetDefaultCopModel

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultCopModel));
</pre>

#### CStreaming::GetDefaultFiremanModel

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultFiremanModel));
</pre>

#### CStreaming::GetDefaultMedicModel

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultMedicModel));
</pre>

#### CStreaming::GetDiscInDrive

<pre>
plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CStreaming::GetDiscInDrive));
</pre>

#### CStreaming::GetNextFileOnCd

<pre>
plugin::CallAndReturnDynGlobal<int, int, bool>(gaddrof(CStreaming::GetNextFileOnCd), pos, bNotPriority);
</pre>

#### CStreaming::HasSpecialCharLoaded

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasSpecialCharLoaded), slot);
</pre>

#### CStreaming::HasVehicleUpgradeLoaded

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasVehicleUpgradeLoaded), ModelIndex);
</pre>

#### CStreaming::InstanceLoadedModels

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::InstanceLoadedModels), posn);
</pre>

#### CStreaming::IsCarModelNeededInCurrentZone

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsCarModelNeededInCurrentZone), VehicleModelIndex);
</pre>

#### CStreaming::IsInitialised

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::IsInitialised));
</pre>

#### CStreaming::IsObjectInCdImage

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsObjectInCdImage), ModelInex);
</pre>

#### CStreaming::IsVeryBusy

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::IsVeryBusy));
</pre>

#### CStreaming::LoadAllRequestedModels

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CStreaming::LoadAllRequestedModels), bOnlyPriorityRequests);
</pre>

#### CStreaming::LoadCdDirectory

<pre>
plugin::CallDynGlobal<char const *, int>(gaddrof_o(CStreaming::LoadCdDirectory, void (*)(char const *, int)), ArchiveName, archiveID);
</pre>

#### CStreaming::LoadScene

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadScene), Posn);
</pre>

#### CStreaming::LoadSceneCollision

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadSceneCollision), Posn);
</pre>

#### CStreaming::LoadZoneVehicle

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadZoneVehicle), posn);
</pre>

#### CStreaming::MakeSpaceFor

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::MakeSpaceFor), memoryToCleanInBytes);
</pre>

#### CStreaming::PossiblyStreamCarOutAfterCreation

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::PossiblyStreamCarOutAfterCreation), modelId);
</pre>

#### CStreaming::ProcessEntitiesInSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, float, float, float, float, float, float, float, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, float, float, float, float, float, float, float, unsigned int)), list, posn_x, posn_y, min_posn_x, min_posn_y, max_posn_x, max_posn_y, distance, Streamingflags);
</pre>

#### CStreaming::ProcessEntitiesInSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, unsigned int)), list, streamingFlags);
</pre>

#### CStreaming::ProcessLoadingChannel

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::ProcessLoadingChannel), channelIndex);
</pre>

#### CStreaming::ReInit

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CStreaming::ReInit));
</pre>

#### CStreaming::RemoveBuildingsNotInArea

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveBuildingsNotInArea), AreaCode);
</pre>

#### CStreaming::RemoveCarModel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveCarModel), modelIndex);
</pre>

#### CStreaming::RemoveEntity

<pre>
plugin::CallDynGlobal<CLink<CEntity*> *>(gaddrof(CStreaming::RemoveEntity), streamingLink);
</pre>

#### CStreaming::RemoveLeastUsedModel

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CStreaming::RemoveLeastUsedModel), StreamingFlags);
</pre>

#### CStreaming::RemoveLoadedVehicle

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedVehicle));
</pre>

#### CStreaming::RemoveLoadedZoneModel

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedZoneModel));
</pre>

#### CStreaming::RemoveModel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveModel), Modelindex);
</pre>

#### CStreaming::RemoveUnusedModelsInLoadedList

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CStreaming::RemoveUnusedModelsInLoadedList));
</pre>

#### CStreaming::RenderEntity

<pre>
plugin::CallDynGlobal<CLink<CEntity*> *>(gaddrof(CStreaming::RenderEntity), streamingLink);
</pre>

#### CStreaming::RequestBigBuildings

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::RequestBigBuildings), posn);
</pre>

#### CStreaming::RequestFile

<pre>
plugin::CallDynGlobal<int, int, int, int, int>(gaddrof(CStreaming::RequestFile), index, offset, size, imgId, streamingFlags);
</pre>

#### CStreaming::RequestFilesInChannel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestFilesInChannel), channelId);
</pre>

#### CStreaming::RequestModel

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestModel), dwModelId, Streamingflags);
</pre>

#### CStreaming::RequestModelStream

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestModelStream), streamNum);
</pre>

#### CStreaming::RequestPlayerSection

<pre>
plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestPlayerSection), modelIndex, string, streamingFlags);
</pre>

#### CStreaming::RequestSpecialChar

<pre>
plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialChar), slot, Name, streamingFlags);
</pre>

#### CStreaming::RequestSpecialModel

<pre>
plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialModel), slot, name, StreamingFlags);
</pre>

#### CStreaming::RequestTxdModel

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestTxdModel), TxdModelID, Streamingflags);
</pre>

#### CStreaming::RequestVehicleUpgrade

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestVehicleUpgrade), modelIndex, StreamingFlags);
</pre>

#### CStreaming::RetryLoadFile

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RetryLoadFile), streamNum);
</pre>

#### CStreaming::SetLoadVehiclesInLoadScene

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CStreaming::SetLoadVehiclesInLoadScene), bEnable);
</pre>

#### CStreaming::SetMissionDoesntRequireAnim

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireAnim), slot);
</pre>

#### CStreaming::SetMissionDoesntRequireModel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireModel), modelIndex);
</pre>

#### CStreaming::SetMissionDoesntRequireSpecialChar

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireSpecialChar), slot);
</pre>

#### CStreaming::SetModelIsDeletable

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelIsDeletable), modelIndex);
</pre>

#### CStreaming::SetModelTxdIsDeletable

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelTxdIsDeletable), modelIndex);
</pre>

#### CStreaming::SetSpecialCharIsDeletable

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetSpecialCharIsDeletable), slot);
</pre>

#### CStreaming::StreamAmbulanceAndMedic

<pre>
plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CStreaming::StreamAmbulanceAndMedic), bStreamForAccident);
</pre>

#### CStreaming::StreamCopModels

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::StreamCopModels), townID);
</pre>

#### CStreaming::StreamFireEngineAndFireman

<pre>
plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CStreaming::StreamFireEngineAndFireman), bStreamForFire);
</pre>

#### CStreaming::StreamPedsForInterior

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::StreamPedsForInterior), interiorType);
</pre>

#### CStreaming::StreamPedsIntoRandomSlots

<pre>
plugin::CallDynGlobal<int *>(gaddrof(CStreaming::StreamPedsIntoRandomSlots), pModelID);
</pre>

#### CStreaming::StreamVehiclesAndPeds_Always

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamVehiclesAndPeds_Always), posn);
</pre>

#### CStreaming::StreamZoneModels

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels), posn);
</pre>

#### CStreaming::StreamZoneModels_Gangs

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels_Gangs), unused);
</pre>

#### CStreaming::WeAreTryingToPhaseVehicleOut

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::WeAreTryingToPhaseVehicleOut), modelIndex);
</pre>

### plugin_sa\game_sa\CStreamingInfo.cpp

#### CStreamingInfo::AddToList

<pre>
plugin::CallMethodDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::AddToList), this, listStart);
0AA6: call_method 0x407480 struct [CStreamingInfo] num_params 1 pop 0 [listStart]
</pre>

#### CStreamingInfo::GetCdPosn

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CStreamingInfo *>(gaddrof(CStreamingInfo::GetCdPosn), this);
0AA8: call_method_return 0x407570 struct [CStreamingInfo] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CStreamingInfo::GetCdPosnAndSize

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CStreamingInfo *, unsigned int *, unsigned int *>(gaddrof(CStreamingInfo::GetCdPosnAndSize), this, CdPosn, CdSize);
0AA8: call_method_return 0x4075A0 struct [CStreamingInfo] num_params 2 pop 0 [CdPosn] [CdSize] func_ret [bool]
</pre>

#### CStreamingInfo::GetCdSize

<pre>
plugin::CallMethodAndReturnDynGlobal<unsigned int, CStreamingInfo *>(gaddrof(CStreamingInfo::GetCdSize), this);
0AA8: call_method_return 0x407590 struct [CStreamingInfo] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### \*CStreamingInfo::GetNext

<pre>
plugin::CallMethodAndReturnDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::GetNext), this);
0AA8: call_method_return 0x407520 struct [*CStreamingInfo] num_params 0 pop 0 func_ret [CStreamingInfo *]
</pre>

#### \*CStreamingInfo::GetPrev

<pre>
plugin::CallMethodAndReturnDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::GetPrev), this);
0AA8: call_method_return 0x407540 struct [*CStreamingInfo] num_params 0 pop 0 func_ret [CStreamingInfo *]
</pre>

#### CStreamingInfo::InList

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CStreamingInfo *>(gaddrof(CStreamingInfo::InList), this);
0AA8: call_method_return 0x407560 struct [CStreamingInfo] num_params 0 pop 0 func_ret [bool]
</pre>

#### CStreamingInfo::Init

<pre>
plugin::CallMethodDynGlobal<CStreamingInfo *>(gaddrof(CStreamingInfo::Init), this);
0AA6: call_method 0x407460 struct [CStreamingInfo] num_params 0 pop 0
</pre>

#### CStreamingInfo::RemoveFromList

<pre>
plugin::CallMethodDynGlobal<CStreamingInfo *>(gaddrof(CStreamingInfo::RemoveFromList), this);
0AA6: call_method 0x4074E0 struct [CStreamingInfo] num_params 0 pop 0
</pre>

#### CStreamingInfo::SetCdPosnAndSize

<pre>
plugin::CallMethodDynGlobal<CStreamingInfo *, unsigned int, unsigned int>(gaddrof(CStreamingInfo::SetCdPosnAndSize), this, CdPosn, CdSize);
0AA6: call_method 0x4075E0 struct [CStreamingInfo] num_params 2 pop 0 [CdPosn] [CdSize]
</pre>

### plugin_sa\game_sa\CStuckCarCheck.cpp

#### CStuckCarCheck::AddCarToCheck

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *, int, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, signed char>(gaddrof(CStuckCarCheck::AddCarToCheck), this, carHandle, distance, time, a5, bStuck, bFlipped, bWarp, pathID);
0AA6: call_method 0x465970 struct [CStuckCarCheck] num_params 8 pop 0 [carHandle] [distance] [time] [a5] [bStuck] [bFlipped] [bWarp] [pathID]
</pre>

#### CStuckCarCheck::AttemptToWarpVehicle

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, CVehicle *, CVector *, float>(gaddrof(CStuckCarCheck::AttemptToWarpVehicle), this, vehicle, origin, orientation);
0AA8: call_method_return 0x463A60 struct [CStuckCarCheck] num_params 3 pop 0 [vehicle] [origin] [orientation] func_ret [bool]
</pre>

#### CStuckCarCheck::ClearStuckFlagForCar

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::ClearStuckFlagForCar), this, carHandle);
0AA6: call_method 0x463C40 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle]
</pre>

#### CStuckCarCheck::HasCarBeenStuckForAWhile

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::HasCarBeenStuckForAWhile), this, carHandle);
0AA8: call_method_return 0x463C00 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle] func_ret [bool]
</pre>

#### CStuckCarCheck::Init

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Init), this);
0AA6: call_method 0x4639E0 struct [CStuckCarCheck] num_params 0 pop 0
</pre>

#### CStuckCarCheck::IsCarInStuckCarArray

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::IsCarInStuckCarArray), this, carHandle);
0AA8: call_method_return 0x463C70 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle] func_ret [bool]
</pre>

#### CStuckCarCheck::Process

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Process), this);
0AA6: call_method 0x465680 struct [CStuckCarCheck] num_params 0 pop 0
</pre>

#### CStuckCarCheck::RemoveCarFromCheck

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::RemoveCarFromCheck), this, carHandle);
0AA6: call_method 0x463B80 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle]
</pre>

#### CStuckCarCheck::ResetArrayElement

<pre>
plugin::CallMethodDynGlobal<CStuckCarCheck *, unsigned short>(gaddrof(CStuckCarCheck::ResetArrayElement), this, index);
0AA6: call_method 0x463970 struct [CStuckCarCheck] num_params 1 pop 0 [index]
</pre>

### plugin_sa\game_sa\CTaskComplex.cpp

### plugin_sa\game_sa\CTaskComplexClimb.cpp

### plugin_sa\game_sa\CTaskComplexDie.cpp

### plugin_sa\game_sa\CTaskComplexEnterBoatAsDriver.cpp

### plugin_sa\game_sa\CTaskComplexEnterCar.cpp

### plugin_sa\game_sa\CTaskComplexEnterCarAsDriver.cpp

### plugin_sa\game_sa\CTaskComplexEnterCarAsPassenger.cpp

### plugin_sa\game_sa\CTaskComplexFacial.cpp

### plugin_sa\game_sa\CTaskComplexJump.cpp

### plugin_sa\game_sa\CTaskComplexLeaveCar.cpp

### plugin_sa\game_sa\CTaskComplexProstituteSolicit.cpp

#### CTaskComplexProstituteSolicit::CTaskComplexProstituteSolicit

<pre>
plugin::CallMethod<0x661A60, CTaskComplexProstituteSolicit *, CPed*>(this, pClient);
0AA6: call_method 0x661A60 struct [CTaskComplexProstituteSolicit] num_params 1 pop 0 [pClient]
</pre>

#### CTaskComplexProstituteSolicit::CreateSubTask

<pre>
plugin::CallMethodAndReturn<CTask*, 0x666360, CTaskComplexProstituteSolicit *, int, CPed*>(this, taskId, pProstitute);
0AA8: call_method_return 0x666360 struct [CTaskComplexProstituteSolicit] num_params 2 pop 0 [taskId] [pProstitute] func_ret [CTask*]
</pre>

#### CTaskComplexProstituteSolicit::GetRidOfPlayerProstitute

<pre>
plugin::Call<0x661D30>();
0AA5: call_function 0x661D30 num_params 0 pop 0
</pre>

#### CTaskComplexProstituteSolicit::IsTaskValid

<pre>
plugin::CallAndReturn<bool, 0x661BB0, CPed*, CPed*>(pProstitute, pClient);
0AA7: call_function_return 0x661BB0 num_params 2 pop 2 [pProstitute] [pClient] func_ret [bool]
</pre>

### plugin_sa\game_sa\CTaskComplexSequence.cpp

### plugin_sa\game_sa\CTaskComplexStuckInAir.cpp

### plugin_sa\game_sa\CTaskComplexSunbathe.cpp

### plugin_sa\game_sa\CTaskComplexUseMobilePhone.cpp

### plugin_sa\game_sa\CTaskComplexWander.cpp

### plugin_sa\game_sa\CTaskComplexWanderStandard.cpp

### plugin_sa\game_sa\CTaskSimpleAnim.cpp

### plugin_sa\game_sa\CTaskSimpleCarSetPedInAsPassenger.cpp

### plugin_sa\game_sa\CTaskSimpleCarSetPedOut.cpp

### plugin_sa\game_sa\CTaskSimpleChoking.cpp

### plugin_sa\game_sa\CTaskSimpleClimb.cpp

### plugin_sa\game_sa\CTaskSimpleDuck.cpp

### plugin_sa\game_sa\CTaskSimpleDuckToggle.cpp

### plugin_sa\game_sa\CTaskSimpleFacial.cpp

### plugin_sa\game_sa\CTaskSimpleFight.cpp

### plugin_sa\game_sa\CTaskSimpleGangDriveBy.cpp

### plugin_sa\game_sa\CTaskSimpleIKChain.cpp

### plugin_sa\game_sa\CTaskSimpleIKLookAt.cpp

### plugin_sa\game_sa\CTaskSimpleIKManager.cpp

### plugin_sa\game_sa\CTaskSimpleInAir.cpp

### plugin_sa\game_sa\CTaskSimpleJetPack.cpp

### plugin_sa\game_sa\CTaskSimpleJump.cpp

### plugin_sa\game_sa\CTaskSimplePlayerOnFoot.cpp

### plugin_sa\game_sa\CTaskSimpleRunAnim.cpp

### plugin_sa\game_sa\CTaskSimpleRunNamedAnim.cpp

### plugin_sa\game_sa\CTaskSimpleStandStill.cpp

### plugin_sa\game_sa\CTaskSimpleStealthKill.cpp

### plugin_sa\game_sa\CTaskSimpleSwim.cpp

### plugin_sa\game_sa\CTaskSimpleThrowProjectile.cpp

### plugin_sa\game_sa\CTaskSimpleTriggerLookAt.cpp

### plugin_sa\game_sa\CTaskSimpleUseGun.cpp

### plugin_sa\game_sa\CTaskUtilityLineUpPedWithCar.cpp

#### CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor

<pre>
plugin::CallMethodAndReturn<CVector*, 0x64FC10, CTaskUtilityLineUpPedWithCar *, int, CVehicle*, float, CAnimBlendAssociation*>(this, unused, pVehicle, arg3, pAnimBlendAssoc);
0AA8: call_method_return 0x64FC10 struct [CTaskUtilityLineUpPedWithCar] num_params 4 pop 0 [unused] [pVehicle] [arg3] [pAnimBlendAssoc] func_ret [CVector*]
</pre>

#### CTaskUtilityLineUpPedWithCar::ProcessPed

<pre>
plugin::CallMethod<0x6513A0, CTaskUtilityLineUpPedWithCar *, CPed*, CVehicle*, CAnimBlendAssociation*>(this, pPed, pVehicle, pAnimBlendAssoc);
0AA6: call_method 0x6513A0 struct [CTaskUtilityLineUpPedWithCar] num_params 3 pop 0 [pPed] [pVehicle] [pAnimBlendAssoc]
</pre>

#### CTaskUtilityLineUpPedWithCar::GetPositionToOpenCarDoor

<pre>
plugin::CallMethodAndReturn<RwV3d*, 0x650A80, CTaskUtilityLineUpPedWithCar *, int, CVehicle*, float, CAnimBlendAssociation*>(this, unused, pVehicle, arg2, pAnimBlendAssoc);
0AA8: call_method_return 0x650A80 struct [CTaskUtilityLineUpPedWithCar] num_params 4 pop 0 [unused] [pVehicle] [arg2] [pAnimBlendAssoc] func_ret [RwV3d*]
</pre>

### plugin_sa\game_sa\CTheCarGenerators.cpp

#### CTheCarGenerators::CreateCarGenerator

<pre>
plugin::CallAndReturnDynGlobal<signed int, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short, unsigned char, unsigned char>(gaddrof(CTheCarGenerators::CreateCarGenerator), x, y, z, angle, modelId, color1, color2, forceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer);
</pre>

#### CTheCarGenerators::RemoveCarGenerators

<pre>
plugin::CallDynGlobal<unsigned char>(gaddrof(CTheCarGenerators::RemoveCarGenerators), IplID);
</pre>

### plugin_sa\game_sa\CTheScripts.cpp

#### CTheScripts::AddScriptCheckpoint

<pre>
plugin::CallAndReturnDynGlobal<int, float, float, float, float, float, float, float, int>(gaddrof(CTheScripts::AddScriptCheckpoint), at_X, at_Y, at_Z, PointTo_X, PointTo_Y, PointTo_Z, radius, type);
</pre>

#### CTheScripts::AddScriptEffectSystem

<pre>
plugin::CallAndReturnDynGlobal<int, FxSystem_c *>(gaddrof(CTheScripts::AddScriptEffectSystem), a1);
</pre>

#### CTheScripts::AddScriptSearchLight

<pre>
plugin::CallAndReturnDynGlobal<int, float, float, float, CEntity *, float, float, float, float, float>(gaddrof(CTheScripts::AddScriptSearchLight), startX, startY, startZ, entity, targetX, targetY, targetZ, targetRadius, baseRadius);
</pre>

#### CTheScripts::AddScriptSphere

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, CVector, float>(gaddrof(CTheScripts::AddScriptSphere), id, posn, radius);
</pre>

#### CTheScripts::AddToBuildingSwapArray

<pre>
plugin::CallDynGlobal<CBuilding *, int, int>(gaddrof(CTheScripts::AddToBuildingSwapArray), a1, newModelId, oldModelId);
</pre>

#### CTheScripts::AddToInvisibilitySwapArray

<pre>
plugin::CallDynGlobal<CEntity *, bool>(gaddrof(CTheScripts::AddToInvisibilitySwapArray), a2, bVisible);
</pre>

#### CTheScripts::AddToListOfConnectedLodObjects

<pre>
plugin::CallDynGlobal<CObject *, CObject *>(gaddrof(CTheScripts::AddToListOfConnectedLodObjects), pObject1, pObject2);
</pre>

#### CTheScripts::AddToListOfSpecialAnimGroupsAttachedToCharModels

<pre>
plugin::CallDynGlobal<int, char *>(gaddrof(CTheScripts::AddToListOfSpecialAnimGroupsAttachedToCharModels), modelid, ifpName);
</pre>

#### CTheScripts::AddToSwitchJumpTable

<pre>
plugin::CallAndReturnDynGlobal<double, int, int>(gaddrof(CTheScripts::AddToSwitchJumpTable), switchValue, switchLabelLocalAddress);
</pre>

#### CTheScripts::AddToVehicleModelsBlockedByScript

<pre>
plugin::CallDynGlobal<int>(gaddrof(CTheScripts::AddToVehicleModelsBlockedByScript), modelindex);
</pre>

#### CTheScripts::AddToWaitingForScriptBrainArray

<pre>
plugin::CallDynGlobal<CEntity *, short>(gaddrof(CTheScripts::AddToWaitingForScriptBrainArray), pEntity, arg2);
</pre>

#### CTheScripts::AttachSearchlightToSearchlightObject

<pre>
plugin::CallDynGlobal<int, CObject *, CObject *, CObject *, float, float, float>(gaddrof(CTheScripts::AttachSearchlightToSearchlightObject), searchlightid, tower, housing, bulb, offsetX, offsetY, offsetZ);
</pre>

#### CTheScripts::CheckStreamedScriptVersion

<pre>
plugin::CallAndReturnDynGlobal<char, RwStream *, char *>(gaddrof(CTheScripts::CheckStreamedScriptVersion), arg1, arg2);
</pre>

#### CTheScripts::CleanUpThisObject

<pre>
plugin::CallDynGlobal<CObject *>(gaddrof(CTheScripts::CleanUpThisObject), pObject);
</pre>

#### CTheScripts::CleanUpThisPed

<pre>
plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::CleanUpThisPed), ped);
</pre>

#### CTheScripts::CleanUpThisVehicle

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CTheScripts::CleanUpThisVehicle), pVehicle);
</pre>

#### CTheScripts::ClearSpaceForMissionEntity

<pre>
plugin::CallDynGlobal<CVector const &, CEntity *>(gaddrof(CTheScripts::ClearSpaceForMissionEntity), pos, pEntity);
</pre>

#### CTheScripts::DrawDebugAngledSquare

<pre>
plugin::CallDynGlobal<float, float, float, float, float, float, float, float>(gaddrof(CTheScripts::DrawDebugAngledSquare), x1, y1, x2, y2, x3, y3, x4, y4);
</pre>

#### CTheScripts::DrawDebugCube

<pre>
plugin::CallDynGlobal<float, float, float, float>(gaddrof(CTheScripts::DrawDebugCube), x1, y1, x2, y2);
</pre>

#### CTheScripts::DrawScriptSpritesAndRectangles

<pre>
plugin::CallDynGlobal<char>(gaddrof(CTheScripts::DrawScriptSpritesAndRectangles), bDrawBeforeFade);
</pre>

#### CTheScripts::GetActualScriptThingIndex

<pre>
plugin::CallAndReturnDynGlobal<signed int, int, unsigned char>(gaddrof(CTheScripts::GetActualScriptThingIndex), index, type);
</pre>

#### CTheScripts::GetNewUniqueScriptThingIndex

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, char>(gaddrof(CTheScripts::GetNewUniqueScriptThingIndex), index, type);
</pre>

#### CTheScripts::GetScriptIndexFromPointer

<pre>
plugin::CallAndReturnDynGlobal<int, CRunningScript *>(gaddrof(CTheScripts::GetScriptIndexFromPointer), thread);
</pre>

#### CTheScripts::GetUniqueScriptThingIndex

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, int, unsigned char>(gaddrof(CTheScripts::GetUniqueScriptThingIndex), playergroup, type);
</pre>

#### CTheScripts::HasVehicleModelBeenBlockedByScript

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CTheScripts::HasVehicleModelBeenBlockedByScript), modelindex);
</pre>

#### CTheScripts::HighlightImportantAngledArea

<pre>
plugin::CallDynGlobal<unsigned int, float, float, float, float, float, float, float, float, float>(gaddrof(CTheScripts::HighlightImportantAngledArea), markerid, from_X, from_Y, to_X, to_Y, angledTo_X, angledTo_Y, angledFrom_X, angledFrom_Y, height);
</pre>

#### CTheScripts::HighlightImportantArea

<pre>
plugin::CallDynGlobal<int, float, float, float, float, float>(gaddrof(CTheScripts::HighlightImportantArea), markerid, from_X, from_Y, to_X, to_Y, height);
</pre>

#### CTheScripts::InitialiseConnectLodObjects

<pre>
plugin::CallDynGlobal<unsigned short>(gaddrof(CTheScripts::InitialiseConnectLodObjects), a1);
</pre>

#### CTheScripts::InitialiseSpecialAnimGroup

<pre>
plugin::CallDynGlobal<unsigned short>(gaddrof(CTheScripts::InitialiseSpecialAnimGroup), a1);
</pre>

#### CTheScripts::IsEntityWithinAnySearchLight

<pre>
plugin::CallAndReturnDynGlobal<bool, CEntity *, int *>(gaddrof(CTheScripts::IsEntityWithinAnySearchLight), pEntity, pIndex);
</pre>

#### CTheScripts::IsEntityWithinSearchLight

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned int, CEntity *>(gaddrof(CTheScripts::IsEntityWithinSearchLight), index, pEntity);
</pre>

#### CTheScripts::IsPedStopped

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CTheScripts::IsPedStopped), ped);
</pre>

#### CTheScripts::IsPlayerOnAMission

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTheScripts::IsPlayerOnAMission));
</pre>

#### CTheScripts::IsPointWithinSearchLight

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector *, int>(gaddrof(CTheScripts::IsPointWithinSearchLight), pointPosn, index);
</pre>

#### CTheScripts::IsVehicleStopped

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTheScripts::IsVehicleStopped), pVehicle);
</pre>

#### CTheScripts::MoveSearchLightBetweenTwoPoints

<pre>
plugin::CallDynGlobal<int, float, float, float, float, float, float, float>(gaddrof(CTheScripts::MoveSearchLightBetweenTwoPoints), index, x1, y1, z1, x2, y2, z2, pathSpeed);
</pre>

#### CTheScripts::MoveSearchLightToEntity

<pre>
plugin::CallDynGlobal<int, CEntity *, float>(gaddrof(CTheScripts::MoveSearchLightToEntity), index, pEntity, pathSpeed);
</pre>

#### CTheScripts::MoveSearchLightToPointAndStop

<pre>
plugin::CallDynGlobal<int, float, float, float, float>(gaddrof(CTheScripts::MoveSearchLightToPointAndStop), index, x, y, z, pathSpeed);
</pre>

#### CTheScripts::RemoveFromVehicleModelsBlockedByScript

<pre>
plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveFromVehicleModelsBlockedByScript), modelindex);
</pre>

#### CTheScripts::RemoveFromWaitingForScriptBrainArray

<pre>
plugin::CallAndReturnDynGlobal<int, CEntity *, short>(gaddrof(CTheScripts::RemoveFromWaitingForScriptBrainArray), a1, modelIndex);
</pre>

#### CTheScripts::RemoveScriptCheckpoint

<pre>
plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptCheckpoint), arg1);
</pre>

#### CTheScripts::RemoveScriptEffectSystem

<pre>
plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptEffectSystem), arg1);
</pre>

#### CTheScripts::RemoveScriptSearchLight

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CTheScripts::RemoveScriptSearchLight), index);
</pre>

#### CTheScripts::RemoveScriptSphere

<pre>
plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptSphere), index);
</pre>

#### CTheScripts::RemoveThisPed

<pre>
plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::RemoveThisPed), ped);
</pre>

#### CTheScripts::ScriptAttachAnimGroupToCharModel

<pre>
plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CTheScripts::ScriptAttachAnimGroupToCharModel), modelId, ifpName);
</pre>

#### CTheScripts::ScriptConnectLodsFunction

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CTheScripts::ScriptConnectLodsFunction), objecthandle1, objecthandle2);
</pre>

#### CTheScripts::ScriptDebugCircle2D

<pre>
plugin::CallDynGlobal<float, float, float, float, CRGBA>(gaddrof(CTheScripts::ScriptDebugCircle2D), x, y, width, height, color);
</pre>

#### \*CTheScripts::StartNewScript

<pre>
plugin::CallAndReturnDynGlobal<CRunningScript *, unsigned char *>(gaddrof_o(CTheScripts::StartNewScript, CRunningScript *(*)(unsigned char *)), startIP);
</pre>

#### CTheScripts::StartNewScript

<pre>
plugin::CallAndReturnDynGlobal<int, unsigned char *, unsigned short>(gaddrof_o(CTheScripts::StartNewScript, int(*)(unsigned char *, unsigned short)), startIP, index);
</pre>

#### CTheScripts::UseSwitchJumpTable

<pre>
plugin::CallDynGlobal<int *>(gaddrof(CTheScripts::UseSwitchJumpTable), pSwitchLabelAddress);
</pre>

### plugin_sa\game_sa\CTimeCycle.cpp

#### CTimeCycle::AddOne

<pre>
plugin::Call<0x55FF40, CBox&, short, int, float, float, float>(box, farclip, extracolor, strength, falloff, lodDistMult);
0AA5: call_function 0x55FF40 num_params 6 pop 6 [box] [farclip] [extracolor] [strength] [falloff] [lodDistMult]
</pre>

#### CTimeCycle::CalcColoursForPoint

<pre>
plugin::Call<0x5603D0, CVector, CColourSet*>(point, pCurrentColourSet);
0AA5: call_function 0x5603D0 num_params 2 pop 2 [point] [pCurrentColourSet]
</pre>

#### CTimeCycle::FindFarClipForCoors

<pre>
plugin::Call<0x5616E0, CVector>(cam_pos);
0AA5: call_function 0x5616E0 num_params 1 pop 1 [cam_pos]
</pre>

#### CTimeCycle::FindTimeCycleBox

<pre>
plugin::Call<0x55FFD0, CVector, CTimeCycleBox**, float*, bool, bool, CTimeCycleBox*>(pos, outbox, interpolation, bCheckLod, bCheckFar, exclude);
0AA5: call_function 0x55FFD0 num_params 6 pop 6 [pos] [outbox] [interpolation] [bCheckLod] [bCheckFar] [exclude]
</pre>

#### CTimeCycle::GetAmbientBlue

<pre>
plugin::CallAndReturn<float, 0x560350>();
0AA7: call_function_return 0x560350 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientBlue_BeforeBrightness

<pre>
plugin::CallAndReturn<float, 0x5603B0>();
0AA7: call_function_return 0x5603B0 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientBlue_Obj

<pre>
plugin::CallAndReturn<float, 0x560380>();
0AA7: call_function_return 0x560380 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientGreen

<pre>
plugin::CallAndReturn<float, 0x560340>();
0AA7: call_function_return 0x560340 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientGreen_BeforeBrightness

<pre>
plugin::CallAndReturn<float, 0x5603A0>();
0AA7: call_function_return 0x5603A0 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientGreen_Obj

<pre>
plugin::CallAndReturn<float, 0x560370>();
0AA7: call_function_return 0x560370 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientRed

<pre>
plugin::CallAndReturn<float, 0x560330>();
0AA7: call_function_return 0x560330 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientRed_BeforeBrightness

<pre>
plugin::CallAndReturn<float, 0x560390>();
0AA7: call_function_return 0x560390 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::GetAmbientRed_Obj

<pre>
plugin::CallAndReturn<float, 0x560360>();
0AA7: call_function_return 0x560360 num_params 0 pop 0 func_ret [float]
</pre>

#### CTimeCycle::InitForRestart

<pre>
plugin::Call<0x5601F0>();
0AA5: call_function 0x5601F0 num_params 0 pop 0
</pre>

#### CTimeCycle::Initialise

<pre>
plugin::Call<0x5BBAC0>();
0AA5: call_function 0x5BBAC0 num_params 0 pop 0
</pre>

#### CTimeCycle::SetConstantParametersForPostFX

<pre>
plugin::Call<0x560210>();
0AA5: call_function 0x560210 num_params 0 pop 0
</pre>

#### CTimeCycle::Shutdown

<pre>
plugin::Call<0x5601E0>();
0AA5: call_function 0x5601E0 num_params 0 pop 0
</pre>

#### CTimeCycle::StartExtraColour

<pre>
plugin::Call<0x55FEC0, int, bool>(colour, bNoExtraColorInterior);
0AA5: call_function 0x55FEC0 num_params 2 pop 2 [colour] [bNoExtraColorInterior]
</pre>

#### CTimeCycle::StopExtraColour

<pre>
plugin::Call<0x55FF20, bool>(bNoExtraColorInterior);
0AA5: call_function 0x55FF20 num_params 1 pop 1 [bNoExtraColorInterior]
</pre>

#### CTimeCycle::Update

<pre>
plugin::Call<0x561760>();
0AA5: call_function 0x561760 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CUpsideDownCarCheck.cpp

#### CUpsideDownCarCheck::AddCarToCheck

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::AddCarToCheck), this, carHandle);
0AA6: call_method 0x4638D0 struct [CUpsideDownCarCheck] num_params 1 pop 0 [carHandle]
</pre>

#### CUpsideDownCarCheck::AreAnyCarsUpsideDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::AreAnyCarsUpsideDown), this);
0AA8: call_method_return 0x4638A0 struct [CUpsideDownCarCheck] num_params 0 pop 0 func_ret [bool]
</pre>

#### CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile

<pre>
plugin::CallMethodAndReturnDynGlobal<char, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile), this, carHandle);
0AA8: call_method_return 0x463940 struct [CUpsideDownCarCheck] num_params 1 pop 0 [carHandle] func_ret [char]
</pre>

#### CUpsideDownCarCheck::Init

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::Init), this);
0AA6: call_method 0x463810 struct [CUpsideDownCarCheck] num_params 0 pop 0
</pre>

#### CUpsideDownCarCheck::RemoveCarFromCheck

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::RemoveCarFromCheck), this, carHandle);
0AA6: call_method 0x463910 struct [CUpsideDownCarCheck] num_params 1 pop 0 [carHandle]
</pre>

#### CUpsideDownCarCheck::UpdateTimers

<pre>
plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::UpdateTimers), this);
0AA6: call_method 0x4655E0 struct [CUpsideDownCarCheck] num_params 0 pop 0
</pre>

#### CUpsideDownCarCheck::IsCarUpsideDown

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof_o(CUpsideDownCarCheck::IsCarUpsideDown, bool (*)(CVehicle *)), pVehicle);
</pre>

#### CUpsideDownCarCheck::IsCarUpsideDown

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof_o(CUpsideDownCarCheck::IsCarUpsideDown, bool (*)(int)), carhandle);
</pre>

### plugin_sa\game_sa\CVisibilityPlugins.cpp

#### CVisibilityPlugins::AtomicConstructor

<pre>
plugin::Call<0x732150, void*>(object);
0AA5: call_function 0x732150 num_params 1 pop 1 [object]
</pre>

#### CVisibilityPlugins::AtomicCopyConstructor

<pre>
plugin::Call<0x732170, void*, void const*>(object, originalObject);
0AA5: call_function 0x732170 num_params 2 pop 2 [object] [originalObject]
</pre>

#### CVisibilityPlugins::AtomicDestructor

<pre>
plugin::CallAndReturn<void*, 0x7321A0, void*>(object);
0AA7: call_function_return 0x7321A0 num_params 1 pop 1 [object] func_ret [void*]
</pre>

#### CVisibilityPlugins::CalculateFadingAtomicAlpha

<pre>
plugin::CallAndReturn<int, 0x732500, CBaseModelInfo*, CEntity*, float>(pBaseModelInfo, pEntity, arg3);
0AA7: call_function_return 0x732500 num_params 3 pop 3 [pBaseModelInfo] [pEntity] [arg3] func_ret [int]
</pre>

#### CVisibilityPlugins::ClearAtomicFlag

<pre>
plugin::Call<0x732310, RpAtomic*, int>(pRpAtomic, flag);
0AA5: call_function 0x732310 num_params 2 pop 2 [pRpAtomic] [flag]
</pre>

#### CVisibilityPlugins::ClearAtomicFlag

<pre>
plugin::Call<0x732330, RpAtomic*, unsigned short>(pRpAtomic, flag);
0AA5: call_function 0x732330 num_params 2 pop 2 [pRpAtomic] [flag]
</pre>

#### CVisibilityPlugins::ClearClumpForAllAtomicsFlag

<pre>
plugin::Call<0x732350, RpClump*, int>(pRpClump, flag);
0AA5: call_function 0x732350 num_params 2 pop 2 [pRpClump] [flag]
</pre>

#### CVisibilityPlugins::ClumpConstructor

<pre>
plugin::Call<0x732E10, void*>(object);
0AA5: call_function 0x732E10 num_params 1 pop 1 [object]
</pre>

#### CVisibilityPlugins::ClumpCopyConstructor

<pre>
plugin::Call<0x732200, void*, void const*>(object, originalObject);
0AA5: call_function 0x732200 num_params 2 pop 2 [object] [originalObject]
</pre>

#### CVisibilityPlugins::ClumpDestructor

<pre>
plugin::CallAndReturn<void*, 0x732220, void*>(object);
0AA7: call_function_return 0x732220 num_params 1 pop 1 [object] func_ret [void*]
</pre>

#### CVisibilityPlugins::DefaultVisibilityCB

<pre>
plugin::CallAndReturn<int, 0x732A30>();
0AA7: call_function_return 0x732A30 num_params 0 pop 0 func_ret [int]
</pre>

#### CVisibilityPlugins::FrameConstructor

<pre>
plugin::Call<0x7321B0, void*>(object);
0AA5: call_function 0x7321B0 num_params 1 pop 1 [object]
</pre>

#### CVisibilityPlugins::FrameCopyConstructor

<pre>
plugin::Call<0x7321D0, void*, void const*>(object, originalObject);
0AA5: call_function 0x7321D0 num_params 2 pop 2 [object] [originalObject]
</pre>

#### CVisibilityPlugins::FrameDestructor

<pre>
plugin::CallAndReturn<void*, 0x7321F0, void*, int, int>(arg0, arg1, arg2);
0AA7: call_function_return 0x7321F0 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [void*]
</pre>

#### CVisibilityPlugins::FrustumSphereCB

<pre>
plugin::CallAndReturn<bool, 0x732A40, RpClump*>(pRpClump);
0AA7: call_function_return 0x732A40 num_params 1 pop 1 [pRpClump] func_ret [bool]
</pre>

#### CVisibilityPlugins::GetAtomicId

<pre>
plugin::CallAndReturn<short, 0x732370, RpAtomic*>(pRpAtomic);
0AA7: call_function_return 0x732370 num_params 1 pop 1 [pRpAtomic] func_ret [short]
</pre>

#### CVisibilityPlugins::GetAtomicModelInfo

<pre>
plugin::CallAndReturn<CAtomicModelInfo*, 0x732260, RpAtomic*>(pRpAtomic);
0AA7: call_function_return 0x732260 num_params 1 pop 1 [pRpAtomic] func_ret [CAtomicModelInfo*]
</pre>

#### CVisibilityPlugins::GetClumpAlpha

<pre>
plugin::CallAndReturn<int, 0x732B20, RpClump*>(pRpClump);
0AA7: call_function_return 0x732B20 num_params 1 pop 1 [pRpClump] func_ret [int]
</pre>

#### CVisibilityPlugins::GetClumpModelInfo

<pre>
plugin::CallAndReturn<CClumpModelInfo*, 0x732AC0, RpClump*>(pRpClump);
0AA7: call_function_return 0x732AC0 num_params 1 pop 1 [pRpClump] func_ret [CClumpModelInfo*]
</pre>

#### CVisibilityPlugins::GetDistanceSquaredFromCamera

<pre>
plugin::CallAndReturn<float, 0x732C80, RwFrame*>(pRwFrame);
0AA7: call_function_return 0x732C80 num_params 1 pop 1 [pRwFrame] func_ret [float]
</pre>

#### CVisibilityPlugins::GetDistanceSquaredFromCamera

<pre>
plugin::CallAndReturn<float, 0x732CC0, RwV3d*>(pRwV3d);
0AA7: call_function_return 0x732CC0 num_params 1 pop 1 [pRwV3d] func_ret [float]
</pre>

#### CVisibilityPlugins::GetDotProductWithCameraVector

<pre>
plugin::CallAndReturn<float, 0x7326D0, RwMatrixTag*, RwMatrixTag*, unsigned int>(atomicMat, rootMat, flags);
0AA7: call_function_return 0x7326D0 num_params 3 pop 3 [atomicMat] [rootMat] [flags] func_ret [float]
</pre>

#### CVisibilityPlugins::GetFrameHierarchyId

<pre>
plugin::CallAndReturn<int, 0x732A20, RwFrame*>(pRwFrame);
0AA7: call_function_return 0x732A20 num_params 1 pop 1 [pRwFrame] func_ret [int]
</pre>

#### CVisibilityPlugins::GetModelInfoIndex

<pre>
plugin::CallAndReturn<short, 0x732250, RpAtomic*>(pRpAtomic);
0AA7: call_function_return 0x732250 num_params 1 pop 1 [pRpAtomic] func_ret [short]
</pre>

#### CVisibilityPlugins::GetUserValue

<pre>
plugin::CallAndReturn<short, 0x7323A0, RpAtomic*>(pRpAtomic);
0AA7: call_function_return 0x7323A0 num_params 1 pop 1 [pRpAtomic] func_ret [short]
</pre>

#### CVisibilityPlugins::InitAlphaAtomicList

<pre>
plugin::Call<0x734530>();
0AA5: call_function 0x734530 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::InitAlphaEntityList

<pre>
plugin::Call<0x734540>();
0AA5: call_function 0x734540 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::Initialise

<pre>
plugin::Call<0x733A20>();
0AA5: call_function 0x733A20 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::InsertAtomicIntoReallyDrawLastList

<pre>
plugin::CallAndReturn<bool, 0x733E10, RpAtomic*, float>(pRpAtomic, arg2);
0AA7: call_function_return 0x733E10 num_params 2 pop 2 [pRpAtomic] [arg2] func_ret [bool]
</pre>

#### CVisibilityPlugins::InsertEntityIntoReallyDrawLastList

<pre>
plugin::CallAndReturn<bool, 0x733E50, CEntity*, float>(pEntity, arg2);
0AA7: call_function_return 0x733E50 num_params 2 pop 2 [pEntity] [arg2] func_ret [bool]
</pre>

#### CVisibilityPlugins::InsertEntityIntoSortedList

<pre>
plugin::CallAndReturn<bool, 0x734570, CEntity*, float>(pEntity, distance);
0AA7: call_function_return 0x734570 num_params 2 pop 2 [pEntity] [distance] func_ret [bool]
</pre>

#### CVisibilityPlugins::IsAtomicVisible

<pre>
plugin::CallAndReturn<bool, 0x732990, RpAtomic*>(pRpAtomic);
0AA7: call_function_return 0x732990 num_params 1 pop 1 [pRpAtomic] func_ret [bool]
</pre>

#### CVisibilityPlugins::IsClumpVisible

<pre>
plugin::CallAndReturn<bool, 0x732AE0, RpClump*>(pRpClump);
0AA7: call_function_return 0x732AE0 num_params 1 pop 1 [pRpClump] func_ret [bool]
</pre>

#### CVisibilityPlugins::PluginAttach

<pre>
plugin::CallAndReturn<bool, 0x732E30>();
0AA7: call_function_return 0x732E30 num_params 0 pop 0 func_ret [bool]
</pre>

#### CVisibilityPlugins::RenderAlphaAtomic

<pre>
plugin::Call<0x732480, RpAtomic*, int>(pRpAtomic, dwAlpha);
0AA5: call_function 0x732480 num_params 2 pop 2 [pRpAtomic] [dwAlpha]
</pre>

#### CVisibilityPlugins::RenderAlphaAtomics

<pre>
plugin::Call<0x733E90>();
0AA5: call_function 0x733E90 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::RenderAtomicWithAlphaCB

<pre>
plugin::Call<0x732660, RpAtomic*, void*>(pRpAtomic, pData);
0AA5: call_function 0x732660 num_params 2 pop 2 [pRpAtomic] [pData]
</pre>

#### CVisibilityPlugins::RenderBoatAlphaAtomics

<pre>
plugin::Call<0x733EC0>();
0AA5: call_function 0x733EC0 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::RenderEntity

<pre>
plugin::Call<0x732B40, void*, bool, float>(entity, unused, arg3);
0AA5: call_function 0x732B40 num_params 3 pop 3 [entity] [unused] [arg3]
</pre>

#### CVisibilityPlugins::RenderFadingAtomic

<pre>
plugin::Call<0x732610, CBaseModelInfo*, RpAtomic*, int>(pBaseModelInfo, pRpAtomic, dwAlpha);
0AA5: call_function 0x732610 num_params 3 pop 3 [pBaseModelInfo] [pRpAtomic] [dwAlpha]
</pre>

#### CVisibilityPlugins::RenderFadingClump

<pre>
plugin::Call<0x732680, CBaseModelInfo*, RpClump*, int>(pBaseModelInfo, pRpClump, dwAlpha);
0AA5: call_function 0x732680 num_params 3 pop 3 [pBaseModelInfo] [pRpClump] [dwAlpha]
</pre>

#### CVisibilityPlugins::RenderFadingClumpCB

<pre>
plugin::Call<0x733630, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733630 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderFadingEntities

<pre>
plugin::Call<0x733F10>();
0AA5: call_function 0x733F10 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::RenderFadingUnderwaterEntities

<pre>
plugin::Call<0x7337D0>();
0AA5: call_function 0x7337D0 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::RenderHeliRotorAlphaCB

<pre>
plugin::Call<0x7340B0, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x7340B0 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderHeliTailRotorAlphaCB

<pre>
plugin::Call<0x734170, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x734170 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderObjNormalAtomic

<pre>
plugin::Call<0x7323E0, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x7323E0 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderOrderedList

<pre>
plugin::Call <0x7337A0, CLinkList<CVisibilityPlugins::AlphaObjectInfo>&>(AlphaObjectInfoList);
</pre>

#### CVisibilityPlugins::RenderPedCB

<pre>
plugin::Call<0x7335B0, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x7335B0 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderPlayerCB

<pre>
plugin::Call<0x732870, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x732870 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderReallyDrawLastObjects

<pre>
plugin::Call<0x733800>();
0AA5: call_function 0x733800 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::RenderTrainHiDetailAlphaCB

<pre>
plugin::Call<0x734240, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x734240 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderTrainHiDetailCB

<pre>
plugin::Call<0x733330, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733330 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleHiDetailAlphaCB

<pre>
plugin::Call<0x733F80, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733F80 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle

<pre>
plugin::Call<0x734370, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x734370 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_Boat

<pre>
plugin::Call<0x7344A0, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x7344A0 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleHiDetailCB

<pre>
plugin::Call<0x733240, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733240 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle

<pre>
plugin::Call<0x733420, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733420 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleHiDetailCB_Boat

<pre>
plugin::Call<0x733550, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733550 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleLoDetailCB_Boat

<pre>
plugin::Call<0x7334F0, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x7334F0 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleReallyLowDetailCB

<pre>
plugin::Call<0x7331E0, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x7331E0 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle

<pre>
plugin::Call<0x732820, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x732820 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderWeaponCB

<pre>
plugin::Call<0x733670, RpAtomic*>(pRpAtomic);
0AA5: call_function 0x733670 num_params 1 pop 1 [pRpAtomic]
</pre>

#### CVisibilityPlugins::RenderWeaponPedsForPC

<pre>
plugin::Call<0x732F30>();
0AA5: call_function 0x732F30 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::SetAtomicFlag

<pre>
plugin::Call<0x7322D0, RpAtomic*, int>(pRpAtomic, flag);
0AA5: call_function 0x7322D0 num_params 2 pop 2 [pRpAtomic] [flag]
</pre>

#### CVisibilityPlugins::SetAtomicFlag

<pre>
plugin::Call<0x7322B0, RpAtomic*, unsigned short>(pRpAtomic, flag);
0AA5: call_function 0x7322B0 num_params 2 pop 2 [pRpAtomic] [flag]
</pre>

#### CVisibilityPlugins::SetAtomicId

<pre>
plugin::Call<0x732230, RpAtomic*, int>(pRpAtomic, id);
0AA5: call_function 0x732230 num_params 2 pop 2 [pRpAtomic] [id]
</pre>

#### CVisibilityPlugins::SetAtomicRenderCallback

<pre>
plugin::Call<0x7328A0,RpAtomic*, RpAtomic * (*)(RpAtomic *)>(pRpAtomic,renderCB);
0AA5: call_function 0x7328A0 num_params 2 pop 2 [pRpAtomic] [renderCB]
</pre>

#### CVisibilityPlugins::SetClumpAlpha

<pre>
plugin::Call<0x732B00, RpClump*, int>(pRpClump, dwAlpha);
0AA5: call_function 0x732B00 num_params 2 pop 2 [pRpClump] [dwAlpha]
</pre>

#### CVisibilityPlugins::SetClumpModelInfo

<pre>
plugin::Call<0x733750, RpClump*, CClumpModelInfo*>(pRpClump, pClumpModelInfo);
0AA5: call_function 0x733750 num_params 2 pop 2 [pRpClump] [pClumpModelInfo]
</pre>

#### CVisibilityPlugins::SetFrameHierarchyId

<pre>
plugin::Call<0x732A00, RwFrame*, int>(pRwFrame, id);
0AA5: call_function 0x732A00 num_params 2 pop 2 [pRwFrame] [id]
</pre>

#### CVisibilityPlugins::SetRenderWareCamera

<pre>
plugin::Call<0x7328C0, RwCamera*>(pRwCamera);
0AA5: call_function 0x7328C0 num_params 1 pop 1 [pRwCamera]
</pre>

#### CVisibilityPlugins::SetUserValue

<pre>
plugin::Call<0x732380, RpAtomic*, unsigned short>(pRpAtomic, value);
0AA5: call_function 0x732380 num_params 2 pop 2 [pRpAtomic] [value]
</pre>

#### CVisibilityPlugins::SetupVehicleVariables

<pre>
plugin::Call<0x733160, RpClump*>(pRpClump);
0AA5: call_function 0x733160 num_params 1 pop 1 [pRpClump]
</pre>

#### CVisibilityPlugins::Shutdown

<pre>
plugin::Call<0x732EB0>();
0AA5: call_function 0x732EB0 num_params 0 pop 0
</pre>

#### CVisibilityPlugins::VehicleVisibilityCB

<pre>
plugin::CallAndReturn<bool, 0x7336F0, RpClump*>(pRpClump);
0AA7: call_function_return 0x7336F0 num_params 1 pop 1 [pRpClump] func_ret [bool]
</pre>

#### CVisibilityPlugins::VehicleVisibilityCB_BigVehicle

<pre>
plugin::CallAndReturn<bool, 0x732AB0, RpClump*>(pRpClump);
0AA7: call_function_return 0x732AB0 num_params 1 pop 1 [pRpClump] func_ret [bool]
</pre>

### plugin_sa\game_sa\CWanted.cpp

#### CWanted::InitialiseStaticVariables

<pre>
plugin::Call<0x561C70>();
0AA5: call_function 0x561C70 num_params 0 pop 0
</pre>

#### CWanted::UpdateWantedLevel

<pre>
plugin::CallMethod<0x561C90, CWanted *>(this);
0AA6: call_method 0x561C90 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::SetMaximumWantedLevel

<pre>
plugin::Call<0x561E70, int>(level);
0AA5: call_function 0x561E70 num_params 1 pop 1 [level]
</pre>

#### CWanted::AreMiamiViceRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x561F30, CWanted *>(this);
0AA8: call_method_return 0x561F30 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreSwatRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x561F40, CWanted *>(this);
0AA8: call_method_return 0x561F40 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreFbiRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x561F60, CWanted *>(this);
0AA8: call_method_return 0x561F60 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreArmyRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x561F80, CWanted *>(this);
0AA8: call_method_return 0x561F80 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::NumOfHelisRequired

<pre>
plugin::CallMethodAndReturn<int, 0x561FA0, CWanted *>(this);
0AA8: call_method_return 0x561FA0 struct [CWanted] num_params 0 pop 0 func_ret [int]
</pre>

#### CWanted::ResetPolicePursuit

<pre>
plugin::Call<0x561FD0>();
0AA5: call_function 0x561FD0 num_params 0 pop 0
</pre>

#### CWanted::ClearQdCrimes

<pre>
plugin::CallMethod<0x561FE0, CWanted *>(this);
0AA6: call_method 0x561FE0 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::AddCrimeToQ

<pre>
plugin::CallMethodAndReturn<bool, 0x562000, CWanted *, eCrimeType, int, CVector const&, bool, bool>(this, crimeType, crimeId, posn, bAlreadyReported, bPoliceDontReallyCare);
0AA8: call_method_return 0x562000 struct [CWanted] num_params 5 pop 0 [crimeType] [crimeId] [posn] [bAlreadyReported] [bPoliceDontReallyCare] func_ret [bool]
</pre>

#### CWanted::ReportCrimeNow

<pre>
plugin::CallMethod<0x562120, CWanted *, eCrimeType, CVector const&, bool>(this, crimeType, posn, bPoliceDontReallyCare);
0AA6: call_method 0x562120 struct [CWanted] num_params 3 pop 0 [crimeType] [posn] [bPoliceDontReallyCare]
</pre>

#### CWanted::RemovePursuitCop

<pre>
plugin::Call<0x562300, CCopPed*, CCopPed**, unsigned char&>(cop, copsArray, copsCounter);
0AA5: call_function 0x562300 num_params 3 pop 3 [cop] [copsArray] [copsCounter]
</pre>

#### CWanted::IsInPursuit

<pre>
plugin::CallMethodAndReturn<bool, 0x562330, CWanted *, CCopPed*>(this, cop);
0AA8: call_method_return 0x562330 struct [CWanted] num_params 1 pop 0 [cop] func_ret [bool]
</pre>

#### CWanted::UpdateEachFrame

<pre>
plugin::Call<0x562360>();
0AA5: call_function 0x562360 num_params 0 pop 0
</pre>

#### CWanted::Initialise

<pre>
plugin::CallMethod<0x562390, CWanted *>(this);
0AA6: call_method 0x562390 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::Reset

<pre>
plugin::CallMethod<0x562400, CWanted *>(this);
0AA6: call_method 0x562400 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::RegisterCrime

<pre>
plugin::CallMethod<0x562410, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, posn, crimeId, bPoliceDontReallyCare);
0AA6: call_method 0x562410 struct [CWanted] num_params 4 pop 0 [crimeType] [posn] [crimeId] [bPoliceDontReallyCare]
</pre>

#### CWanted::RegisterCrime_Immediately

<pre>
plugin::CallMethod<0x562430, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, posn, crimeId, bPoliceDontReallyCare);
0AA6: call_method 0x562430 struct [CWanted] num_params 4 pop 0 [crimeType] [posn] [crimeId] [bPoliceDontReallyCare]
</pre>

#### CWanted::SetWantedLevel

<pre>
plugin::CallMethod<0x562470, CWanted *, int>(this, level);
0AA6: call_method 0x562470 struct [CWanted] num_params 1 pop 0 [level]
</pre>

#### CWanted::CheatWantedLevel

<pre>
plugin::CallMethod<0x562540, CWanted *, int>(this, level);
0AA6: call_method 0x562540 struct [CWanted] num_params 1 pop 0 [level]
</pre>

#### CWanted::SetWantedLevelNoDrop

<pre>
plugin::CallMethod<0x562570, CWanted *, int>(this, level);
0AA6: call_method 0x562570 struct [CWanted] num_params 1 pop 0 [level]
</pre>

#### CWanted::ClearWantedLevelAndGoOnParole

<pre>
plugin::CallMethod<0x5625A0, CWanted *>(this);
0AA6: call_method 0x5625A0 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::WorkOutPolicePresence

<pre>
plugin::CallAndReturn<int, 0x5625F0, CVector, float>(posn, radius);
0AA7: call_function_return 0x5625F0 num_params 2 pop 2 [posn] [radius] func_ret [int]
</pre>

#### CWanted::UpdateCrimesQ

<pre>
plugin::CallMethod<0x562760, CWanted *>(this);
0AA6: call_method 0x562760 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::IsClosestCop

<pre>
plugin::CallMethodAndReturn<bool, 0x5627D0, CWanted *, CPed*, int>(this, ped, numCopsToCheck);
0AA8: call_method_return 0x5627D0 struct [CWanted] num_params 2 pop 0 [ped] [numCopsToCheck] func_ret [bool]
</pre>

#### CWanted::ComputePursuitCopToDisplace

<pre>
plugin::CallAndReturn<CCopPed*, 0x562B00, CCopPed*, CCopPed**>(cop, copsArray);
0AA7: call_function_return 0x562B00 num_params 2 pop 2 [cop] [copsArray] func_ret [CCopPed*]
</pre>

#### CWanted::RemovePursuitCop

<pre>
plugin::CallMethod<0x562C10, CWanted *, CCopPed*>(this, cop);
0AA6: call_method 0x562C10 struct [CWanted] num_params 1 pop 0 [cop]
</pre>

#### CWanted::RemoveExcessPursuitCops

<pre>
plugin::CallMethod<0x562C40, CWanted *>(this);
0AA6: call_method 0x562C40 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::Update

<pre>
plugin::CallMethod<0x562C90, CWanted *>(this);
0AA6: call_method 0x562C90 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::CanCopJoinPursuit

<pre>
plugin::CallAndReturn<bool, 0x562F60, CCopPed*, unsigned char, CCopPed**, unsigned char&>(cop, maxCopsCount, copsArray, copsCounter);
0AA7: call_function_return 0x562F60 num_params 4 pop 4 [cop] [maxCopsCount] [copsArray] [copsCounter] func_ret [bool]
</pre>

#### CWanted::CanCopJoinPursuit

<pre>
plugin::CallMethodAndReturn<bool, 0x562FB0, CWanted *, CCopPed*>(this, cop);
0AA8: call_method_return 0x562FB0 struct [CWanted] num_params 1 pop 0 [cop] func_ret [bool]
</pre>

#### CWanted::SetPursuitCop

<pre>
plugin::CallMethodAndReturn<bool, 0x563060, CWanted *, CCopPed*>(this, cop);
0AA8: call_method_return 0x563060 struct [CWanted] num_params 1 pop 0 [cop] func_ret [bool]
</pre>

### plugin_sa\game_sa\CWeapon.cpp

#### CWeapon::InitialiseWeapons

<pre>
plugin::Call<0x73A300>();
0AA5: call_function 0x73A300 num_params 0 pop 0
</pre>

#### CWeapon::ShutdownWeapons

<pre>
plugin::Call<0x73A330>();
0AA5: call_function 0x73A330 num_params 0 pop 0
</pre>

#### CWeapon::UpdateWeapons

<pre>
plugin::Call<0x73A360>();
0AA5: call_function 0x73A360 num_params 0 pop 0
</pre>

#### CWeapon::Shutdown

<pre>
plugin::CallMethod<0x73A380, CWeapon *>(this);
0AA6: call_method 0x73A380 struct [CWeapon] num_params 0 pop 0
</pre>

#### CWeapon::AddGunshell

<pre>
plugin::CallMethod<0x73A3E0, CWeapon *, CEntity*, CVector const&, CVector2D const&, float>(this, creator, position, direction, size);
0AA6: call_method 0x73A3E0 struct [CWeapon] num_params 4 pop 0 [creator] [position] [direction] [size]
</pre>

#### CWeapon::GenerateDamageEvent

<pre>
plugin::Call<0x73A530, CPed*, CEntity*, eWeaponType, int, ePedPieceTypes, int>(victim, creator, weaponType, damageFactor, pedPiece, direction);
0AA5: call_function 0x73A530 num_params 6 pop 6 [victim] [creator] [weaponType] [damageFactor] [pedPiece] [direction]
</pre>

#### CWeapon::LaserScopeDot

<pre>
plugin::CallMethodAndReturn<bool, 0x73A8D0, CWeapon *, CVector*, float*>(this, outCoord, outSize);
0AA8: call_method_return 0x73A8D0 struct [CWeapon] num_params 2 pop 0 [outCoord] [outSize] func_ret [bool]
</pre>

#### CWeapon::FireSniper

<pre>
plugin::CallMethodAndReturn<bool, 0x73AAC0, CWeapon *, CPed*, CEntity*, CVector*>(this, creator, victim, target);
0AA8: call_method_return 0x73AAC0 struct [CWeapon] num_params 3 pop 0 [creator] [victim] [target] func_ret [bool]
</pre>

#### CWeapon::Reload

<pre>
plugin::CallMethod<0x73AEB0, CWeapon *, CPed*>(this, owner);
0AA6: call_method 0x73AEB0 struct [CWeapon] num_params 1 pop 0 [owner]
</pre>

#### FireOneInstantHitRound

<pre>
plugin::Call<0x73AF00, CVector*, CVector*, int>(startPoint, endPoint, intensity);
0AA5: call_function 0x73AF00 num_params 3 pop 3 [startPoint] [endPoint] [intensity]
</pre>

#### CWeapon::IsTypeMelee

<pre>
plugin::CallMethodAndReturn<bool, 0x73B1C0, CWeapon *>(this);
0AA8: call_method_return 0x73B1C0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::IsType2Handed

<pre>
plugin::CallMethodAndReturn<bool, 0x73B1E0, CWeapon *>(this);
0AA8: call_method_return 0x73B1E0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::IsTypeProjectile

<pre>
plugin::CallMethodAndReturn<bool, 0x73B210, CWeapon *>(this);
0AA8: call_method_return 0x73B210 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::CanBeUsedFor2Player

<pre>
plugin::CallAndReturn<bool, 0x73B240, eWeaponType>(weaponType);
0AA7: call_function_return 0x73B240 num_params 1 pop 1 [weaponType] func_ret [bool]
</pre>

#### CWeapon::HasWeaponAmmoToBeUsed

<pre>
plugin::CallMethodAndReturn<bool, 0x73B2A0, CWeapon *>(this);
0AA8: call_method_return 0x73B2A0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::ProcessLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x73B300, CVector const&, CVector const&, CColPoint&, CEntity*&, eWeaponType, CEntity*, bool, bool, bool, bool, bool, bool, bool>(startPoint, endPoint, outColPoint, outEntity, weaponType, arg5, buildings, vehicles, peds, objects, dummies, arg11, doIgnoreCameraCheck);
0AA7: call_function_return 0x73B300 num_params 13 pop 13 [startPoint] [endPoint] [outColPoint] [outEntity] [weaponType] [arg5] [buildings] [vehicles] [peds] [objects] [dummies] [arg11] [doIgnoreCameraCheck] func_ret [bool]
</pre>

#### CWeapon::StopWeaponEffect

<pre>
plugin::CallMethod<0x73B360, CWeapon *>(this);
0AA6: call_method 0x73B360 struct [CWeapon] num_params 0 pop 0
</pre>

#### CWeapon::TargetWeaponRangeMultiplier

<pre>
plugin::CallAndReturn<float, 0x73B380, CEntity*, CEntity*>(victim, weaponOwner);
0AA7: call_function_return 0x73B380 num_params 2 pop 2 [victim] [weaponOwner] func_ret [float]
</pre>

#### CWeapon::CWeapon

<pre>
plugin::CallMethod<0x73B430, CWeapon *, eWeaponType, int>(this, weaponType, ammo);
0AA6: call_method 0x73B430 struct [CWeapon] num_params 2 pop 0 [weaponType] [ammo]
</pre>

#### CWeapon::Initialise

<pre>
plugin::CallMethod<0x73B4A0, CWeapon *, eWeaponType, int, CPed*>(this, weaponType, ammo, owner);
0AA6: call_method 0x73B4A0 struct [CWeapon] num_params 3 pop 0 [weaponType] [ammo] [owner]
</pre>

#### CWeapon::DoBulletImpact

<pre>
plugin::CallMethod<0x73B550, CWeapon *, CEntity*, CEntity*, CVector*, CVector*, CColPoint*, int>(this, owner, victim, startPoint, endPoint, colPoint, arg5);
0AA6: call_method 0x73B550 struct [CWeapon] num_params 6 pop 0 [owner] [victim] [startPoint] [endPoint] [colPoint] [arg5]
</pre>

#### CWeapon::TakePhotograph

<pre>
plugin::CallMethodAndReturn<bool, 0x73C1F0, CWeapon *, CEntity*, CVector*>(this, owner, point);
0AA8: call_method_return 0x73C1F0 struct [CWeapon] num_params 2 pop 0 [owner] [point] func_ret [bool]
</pre>

#### CWeapon::SetUpPelletCol

<pre>
plugin::CallMethod<0x73C710, CWeapon *, int, CEntity*, CEntity*, CVector&, CColPoint&, CMatrix&>(this, numPellets, owner, victim, point, colPoint, outMatrix);
0AA6: call_method 0x73C710 struct [CWeapon] num_params 6 pop 0 [numPellets] [owner] [victim] [point] [colPoint] [outMatrix]
</pre>

#### CWeapon::FireInstantHitFromCar2

<pre>
plugin::CallMethod<0x73CBA0, CWeapon *, CVector, CVector, CVehicle*, CEntity*>(this, startPoint, endPoint, vehicle, owner);
0AA6: call_method 0x73CBA0 struct [CWeapon] num_params 4 pop 0 [startPoint] [endPoint] [vehicle] [owner]
</pre>

#### CWeapon::DoDoomAiming

<pre>
plugin::Call<0x73CDC0, CEntity*, CVector*, CVector*>(owner, start, end);
0AA5: call_function 0x73CDC0 num_params 3 pop 3 [owner] [start] [end]
</pre>

#### CWeapon::DoTankDoomAiming

<pre>
plugin::Call<0x73D1E0, CEntity*, CEntity*, CVector*, CVector*>(vehicle, owner, startPoint, endPoint);
0AA5: call_function 0x73D1E0 num_params 4 pop 4 [vehicle] [owner] [startPoint] [endPoint]
</pre>

#### CWeapon::DoDriveByAutoAiming

<pre>
plugin::Call<0x73D720, CEntity*, CVehicle*, CVector*, CVector*, bool>(owner, vehicle, startPoint, endPoint, canAimVehicles);
0AA5: call_function 0x73D720 num_params 5 pop 5 [owner] [vehicle] [startPoint] [endPoint] [canAimVehicles]
</pre>

#### CWeapon::Update

<pre>
plugin::CallMethod<0x73DB40, CWeapon *, CPed*>(this, owner);
0AA6: call_method 0x73DB40 struct [CWeapon] num_params 1 pop 0 [owner]
</pre>

#### CWeapon::CanBeUsedFor2Player

<pre>
plugin::CallMethodAndReturn<bool, 0x73DEF0, CWeapon *>(this);
0AA8: call_method_return 0x73DEF0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWeapon::FindNearestTargetEntityWithScreenCoors

<pre>
plugin::Call<0x73E240, float, float, float, CVector, float*, float*>(screenX, screenY, range, point, outX, outY);
0AA5: call_function 0x73E240 num_params 6 pop 6 [screenX] [screenY] [range] [point] [outX] [outY]
</pre>

#### CWeapon::EvaluateTargetForHeatSeekingMissile

<pre>
plugin::CallAndReturn<float, 0x73E560, CEntity*, CVector&, CVector&, float, bool, CEntity*>(entity, posn, direction, distanceMultiplier, fromVehicle, lastEntity);
0AA7: call_function_return 0x73E560 num_params 6 pop 6 [entity] [posn] [direction] [distanceMultiplier] [fromVehicle] [lastEntity] func_ret [float]
</pre>

#### CWeapon::DoWeaponEffect

<pre>
plugin::CallMethod<0x73E690, CWeapon *, CVector, CVector>(this, origin, target);
0AA6: call_method 0x73E690 struct [CWeapon] num_params 2 pop 0 [origin] [target]
</pre>

#### CWeapon::FireAreaEffect

<pre>
plugin::CallMethodAndReturn<bool, 0x73E800, CWeapon *, CEntity*, CVector*, CEntity*, CVector*>(this, firingEntity, origin, targetEntity, target);
0AA8: call_method_return 0x73E800 struct [CWeapon] num_params 4 pop 0 [firingEntity] [origin] [targetEntity] [target] func_ret [bool]
</pre>

#### CWeapon::FireInstantHitFromCar

<pre>
plugin::CallMethodAndReturn<bool, 0x73EC40, CWeapon *, CVehicle*, bool, bool>(this, vehicle, leftSide, rightSide);
0AA8: call_method_return 0x73EC40 struct [CWeapon] num_params 3 pop 0 [vehicle] [leftSide] [rightSide] func_ret [bool]
</pre>

#### CWeapon::CheckForShootingVehicleOccupant

<pre>
plugin::CallAndReturn<bool, 0x73F480, CEntity**, CColPoint*, eWeaponType, CVector const&, CVector const&>(pCarEntity, colPoint, weaponType, origin, target);
0AA7: call_function_return 0x73F480 num_params 5 pop 5 [pCarEntity] [colPoint] [weaponType] [origin] [target] func_ret [bool]
</pre>

#### CWeapon::PickTargetForHeatSeekingMissile

<pre>
plugin::CallAndReturn<CEntity*, 0x73F910, CVector, CVector, float, CEntity*, bool, CEntity*>(origin, direction, distanceMultiplier, ignoreEntity, fromVehicle, lastEntity);
0AA7: call_function_return 0x73F910 num_params 6 pop 6 [origin] [direction] [distanceMultiplier] [ignoreEntity] [fromVehicle] [lastEntity] func_ret [CEntity*]
</pre>

#### CWeapon::FireFromCar

<pre>
plugin::CallMethod<0x73FA20, CWeapon *, CVehicle*, bool, bool>(this, vehicle, leftSide, rightSide);
0AA6: call_method 0x73FA20 struct [CWeapon] num_params 3 pop 0 [vehicle] [leftSide] [rightSide]
</pre>

#### CWeapon::FireInstantHit

<pre>
plugin::CallMethodAndReturn<bool, 0x73FB10, CWeapon *, CEntity*, CVector*, CVector*, CEntity*, CVector*, CVector*, bool, bool>(this, firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy, arg6, muzzle);
0AA8: call_method_return 0x73FB10 struct [CWeapon] num_params 8 pop 0 [firingEntity] [origin] [muzzlePosn] [targetEntity] [target] [originForDriveBy] [arg6] [muzzle] func_ret [bool]
</pre>

#### CWeapon::FireProjectile

<pre>
plugin::CallMethodAndReturn<bool, 0x741360, CWeapon *, CEntity*, CVector*, CEntity*, CVector*, float>(this, firingEntity, origin, targetEntity, target, force);
0AA8: call_method_return 0x741360 struct [CWeapon] num_params 5 pop 0 [firingEntity] [origin] [targetEntity] [target] [force] func_ret [bool]
</pre>

#### CWeapon::FireM16_1stPerson

<pre>
plugin::CallMethodAndReturn<bool, 0x741C00, CWeapon *, CEntity*>(this, owner);
0AA8: call_method_return 0x741C00 struct [CWeapon] num_params 1 pop 0 [owner] func_ret [bool]
</pre>

#### CWeapon::Fire

<pre>
plugin::CallMethodAndReturn<bool, 0x742300, CWeapon *, CEntity*, CVector*, CVector*, CEntity*, CVector*, CVector*>(this, firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy);
0AA8: call_method_return 0x742300 struct [CWeapon] num_params 6 pop 0 [firingEntity] [origin] [muzzlePosn] [targetEntity] [target] [originForDriveBy] func_ret [bool]
</pre>

### plugin_sa\game_sa\CWeaponEffects.cpp

#### CWeaponEffects::CWeaponEffects

<pre>
plugin::CallMethod<0x742A90, CWeaponEffects *>(this);
0AA6: call_method 0x742A90 struct [CWeaponEffects] num_params 0 pop 0
</pre>

#### CWeaponEffects::~CWeaponEffects

<pre>
plugin::CallMethod<0x742AA0, CWeaponEffects *>(this);
0AA6: call_method 0x742AA0 struct [CWeaponEffects] num_params 0 pop 0
</pre>

#### CWeaponEffects::Init

<pre>
plugin::Call<0x742AB0>();
0AA5: call_function 0x742AB0 num_params 0 pop 0
</pre>

#### CWeaponEffects::Shutdown

<pre>
plugin::Call<0x742B80>();
0AA5: call_function 0x742B80 num_params 0 pop 0
</pre>

#### CWeaponEffects::IsLockedOn

<pre>
plugin::CallAndReturn<bool, 0x742BD0, int>(crosshairId);
0AA7: call_function_return 0x742BD0 num_params 1 pop 1 [crosshairId] func_ret [bool]
</pre>

#### CWeaponEffects::MarkTarget

<pre>
plugin::Call<0x742BF0, int, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float, unsigned char>(crosshairId, posn, red, green, blue, alpha, size, arg7);
0AA5: call_function 0x742BF0 num_params 8 pop 8 [crosshairId] [posn] [red] [green] [blue] [alpha] [size] [arg7]
</pre>

#### CWeaponEffects::ClearCrossHair

<pre>
plugin::Call<0x742C60, int>(crosshairId);
0AA5: call_function 0x742C60 num_params 1 pop 1 [crosshairId]
</pre>

#### CWeaponEffects::ClearCrossHairs

<pre>
plugin::Call<0x742C80>();
0AA5: call_function 0x742C80 num_params 0 pop 0
</pre>

#### CWeaponEffects::ClearCrossHairImmediately

<pre>
plugin::Call<0x742CA0, int>(crosshairId);
0AA5: call_function 0x742CA0 num_params 1 pop 1 [crosshairId]
</pre>

#### CWeaponEffects::ClearCrossHairsImmediately

<pre>
plugin::Call<0x742CC0>();
0AA5: call_function 0x742CC0 num_params 0 pop 0
</pre>

#### CWeaponEffects::Render

<pre>
plugin::Call<0x742CF0>();
0AA5: call_function 0x742CF0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\CWeather.cpp

#### CWeather::AddRain

<pre>
plugin::Call<0x72A9A0>();
0AA5: call_function 0x72A9A0 num_params 0 pop 0
</pre>

#### CWeather::AddSandStormParticles

<pre>
plugin::Call<0x72A820>();
0AA5: call_function 0x72A820 num_params 0 pop 0
</pre>

#### CWeather::FindWeatherTypesList

<pre>
plugin::CallAndReturn<unsigned char*, 0x72A520>();
0AA7: call_function_return 0x72A520 num_params 0 pop 0 func_ret [unsigned char*]
</pre>

#### CWeather::ForceWeather

<pre>
plugin::Call<0x72A4E0, short>(weatherType);
0AA5: call_function 0x72A4E0 num_params 1 pop 1 [weatherType]
</pre>

#### CWeather::ForceWeatherNow

<pre>
plugin::Call<0x72A4F0, short>(weatherType);
0AA5: call_function 0x72A4F0 num_params 1 pop 1 [weatherType]
</pre>

#### CWeather::ForecastWeather

<pre>
plugin::CallAndReturn<bool, 0x72A590, int, int>(weatherType, numSteps);
0AA7: call_function_return 0x72A590 num_params 2 pop 2 [weatherType] [numSteps] func_ret [bool]
</pre>

#### CWeather::Init

<pre>
plugin::Call<0x72A480>();
0AA5: call_function 0x72A480 num_params 0 pop 0
</pre>

#### CWeather::ReleaseWeather

<pre>
plugin::Call<0x72A510>();
0AA5: call_function 0x72A510 num_params 0 pop 0
</pre>

#### CWeather::RenderRainStreaks

<pre>
plugin::Call<0x72AF70>();
0AA5: call_function 0x72AF70 num_params 0 pop 0
</pre>

#### CWeather::SetWeatherToAppropriateTypeNow

<pre>
plugin::Call<0x72A790>();
0AA5: call_function 0x72A790 num_params 0 pop 0
</pre>

#### CWeather::Update

<pre>
plugin::Call<0x72B850>();
0AA5: call_function 0x72B850 num_params 0 pop 0
</pre>

#### CWeather::UpdateInTunnelness

<pre>
plugin::Call<0x72B630>();
0AA5: call_function 0x72B630 num_params 0 pop 0
</pre>

#### CWeather::UpdateWeatherRegion

<pre>
plugin::Call<0x72A640, CVector*>(posn);
0AA5: call_function 0x72A640 num_params 1 pop 1 [posn]
</pre>

### plugin_sa\game_sa\CWorld.cpp

#### CWorld::ResetLineTestOptions

<pre>
plugin::Call<0x5631C0>();
0AA5: call_function 0x5631C0 num_params 0 pop 0
</pre>

#### CWorld::Initialise

<pre>
plugin::Call<0x5631E0>();
0AA5: call_function 0x5631E0 num_params 0 pop 0
</pre>

#### CWorld::Add

<pre>
plugin::Call<0x563220, CEntity*>(entity);
0AA5: call_function 0x563220 num_params 1 pop 1 [entity]
</pre>

#### CWorld::Remove

<pre>
plugin::Call<0x563280, CEntity*>(entity);
0AA5: call_function 0x563280 num_params 1 pop 1 [entity]
</pre>

#### CWorld::ProcessVerticalLineSectorList

<pre>
plugin::CallAndReturn<bool, 0x5632B0, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, CStoredCollPoly*>(ptrList, colLine, colPoint, maxTouchDistance, outEntity, doSeeThroughCheck, collPoly);
0AA7: call_function_return 0x5632B0 num_params 7 pop 7 [ptrList] [colLine] [colPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [collPoly] func_ret [bool]
</pre>

#### CWorld::CastShadowSectorList

<pre>
plugin::Call<0x563390, CPtrList&, float, float, float, float>(ptrList, arg1, arg2, arg3, arg4);
0AA5: call_function 0x563390 num_params 5 pop 5 [ptrList] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CWorld::ProcessForAnimViewer

<pre>
plugin::Call<0x5633D0>();
0AA5: call_function 0x5633D0 num_params 0 pop 0
</pre>

#### CWorld::ProcessPedsAfterPreRender

<pre>
plugin::Call<0x563430>();
0AA5: call_function 0x563430 num_params 0 pop 0
</pre>

#### CWorld::ClearScanCodes

<pre>
plugin::Call<0x563470>();
0AA5: call_function 0x563470 num_params 0 pop 0
</pre>

#### CWorld::FindObjectsInRangeSectorList

<pre>
plugin::Call<0x563500, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(arg0, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x563500 num_params 7 pop 7 [arg0] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsOfTypeInRangeSectorList

<pre>
plugin::Call<0x5635C0, unsigned int, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(modelId, ptrList, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x5635C0 num_params 8 pop 8 [modelId] [ptrList] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints

<pre>
plugin::CallAndReturn<bool, 0x5636A0, CPtrList&, CColLine const&, CEntity*&, bool, CStoredCollPoly*>(ptrList, colLine, outEntity, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x5636A0 num_params 5 pop 5 [ptrList] [colLine] [outEntity] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::RemoveStaticObjects

<pre>
plugin::Call<0x563840>();
0AA5: call_function 0x563840 num_params 0 pop 0
</pre>

#### CWorld::TestForBuildingsOnTopOfEachOther

<pre>
plugin::Call<0x563950, CPtrList&>(ptrList);
0AA5: call_function 0x563950 num_params 1 pop 1 [ptrList]
</pre>

#### CWorld::TestForUnusedModels

<pre>
plugin::Call<0x5639D0, CPtrList&, int*>(ptrList, models);
0AA5: call_function 0x5639D0 num_params 2 pop 2 [ptrList] [models]
</pre>

#### CWorld::RemoveEntityInsteadOfProcessingIt

<pre>
plugin::Call<0x563A10, CEntity*>(entity);
0AA5: call_function 0x563A10 num_params 1 pop 1 [entity]
</pre>

#### CWorld::CallOffChaseForAreaSectorListVehicles

<pre>
plugin::Call<0x563A80, CPtrList&, float, float, float, float, float, float, float, float>(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
0AA5: call_function 0x563A80 num_params 9 pop 9 [ptrList] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CWorld::CallOffChaseForAreaSectorListPeds

<pre>
plugin::Call<0x563D00, CPtrList&, float, float, float, float, float, float, float, float>(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
0AA5: call_function 0x563D00 num_params 9 pop 9 [ptrList] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CWorld::CameraToIgnoreThisObject

<pre>
plugin::CallAndReturn<bool, 0x563F40, CEntity*>(entity);
0AA7: call_function_return 0x563F40 num_params 1 pop 1 [entity] func_ret [bool]
</pre>

#### CWorld::FindPlayerSlotWithPedPointer

<pre>
plugin::CallAndReturn<int, 0x563FA0, void*>(ptr);
0AA7: call_function_return 0x563FA0 num_params 1 pop 1 [ptr] func_ret [int]
</pre>

#### CWorld::FindPlayerSlotWithRemoteVehiclePointer

<pre>
plugin::CallAndReturn<int, 0x563FD0, void*>(ptr);
0AA7: call_function_return 0x563FD0 num_params 1 pop 1 [ptr] func_ret [int]
</pre>

#### CWorld::FindPlayerSlotWithVehiclePointer

<pre>
plugin::Call<0x564000, CEntity*>(vehiclePtr);
0AA5: call_function 0x564000 num_params 1 pop 1 [vehiclePtr]
</pre>

#### CWorld::ShutDown

<pre>
plugin::Call<0x564050>();
0AA5: call_function 0x564050 num_params 0 pop 0
</pre>

#### CWorld::ClearForRestart

<pre>
plugin::Call<0x564360>();
0AA5: call_function 0x564360 num_params 0 pop 0
</pre>

#### CWorld::ProcessVerticalLineSector_FillGlobeColPoints

<pre>
plugin::CallAndReturn<bool, 0x564420, CSector&, CRepeatSector&, CColLine const&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, repeatSector, colLine, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x564420 num_params 11 pop 11 [sector] [repeatSector] [colLine] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLineSector

<pre>
plugin::CallAndReturn<bool, 0x564500, CSector&, CRepeatSector&, CColLine const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, repeatSector, colLine, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x564500 num_params 12 pop 12 [sector] [repeatSector] [colLine] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::CastShadow

<pre>
plugin::Call<0x564600, float, float, float, float>(x1, y1, x2, y2);
0AA5: call_function 0x564600 num_params 4 pop 4 [x1] [y1] [x2] [y2]
</pre>

#### CWorld::ProcessAttachedEntities

<pre>
plugin::Call<0x5647F0>();
0AA5: call_function 0x5647F0 num_params 0 pop 0
</pre>

#### CWorld::GetIsLineOfSightSectorListClear

<pre>
plugin::CallAndReturn<bool, 0x564970, CPtrList&, CColLine const&, bool, bool>(ptrList, colLine, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x564970 num_params 4 pop 4 [ptrList] [colLine] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::FindObjectsInRange

<pre>
plugin::Call<0x564A20, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x564A20 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsOfTypeInRange

<pre>
plugin::Call<0x564C70, unsigned int, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x564C70 num_params 12 pop 12 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindLodOfTypeInRange

<pre>
plugin::Call<0x564ED0, unsigned int, CVector const&, float, bool, short*, short, CEntity**>(modelId, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x564ED0 num_params 7 pop 7 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsKindaCollidingSectorList

<pre>
plugin::Call<0x565000, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(ptrList, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x565000 num_params 7 pop 7 [ptrList] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsIntersectingCubeSectorList

<pre>
plugin::Call<0x5650E0, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**>(ptrList, cornerA, cornerB, outCount, maxCount, outEntities);
0AA5: call_function 0x5650E0 num_params 6 pop 6 [ptrList] [cornerA] [cornerB] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList

<pre>
plugin::Call<0x565200, CPtrList&, CBox const&, CMatrix const&, CVector const&, short*, short, CEntity**>(ptrList, box, transform, point, outCount, maxCount, outEntities);
0AA5: call_function 0x565200 num_params 7 pop 7 [ptrList] [box] [transform] [point] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindMissionEntitiesIntersectingCubeSectorList

<pre>
plugin::Call<0x565300, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(ptrList, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);
0AA5: call_function 0x565300 num_params 9 pop 9 [ptrList] [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehiclesList] [pedsList] [objectsList]
</pre>

#### CWorld::FindNearestObjectOfTypeSectorList

<pre>
plugin::Call<0x565450, int, CPtrList&, CVector const&, float, bool, CEntity**, float*>(modelId, ptrList, point, radius, b2D, outEntities, outDistance);
0AA5: call_function 0x565450 num_params 7 pop 7 [modelId] [ptrList] [point] [radius] [b2D] [outEntities] [outDistance]
</pre>

#### CWorld::RemoveReferencesToDeletedObject

<pre>
plugin::Call<0x565510, CEntity*>(entity);
0AA5: call_function 0x565510 num_params 1 pop 1 [entity]
</pre>

#### CWorld::SetPedsOnFire

<pre>
plugin::Call<0x565610, float, float, float, float, CEntity*>(x1, y1, x2, y2, fireCreator);
0AA5: call_function 0x565610 num_params 5 pop 5 [x1] [y1] [x2] [y2] [fireCreator]
</pre>

#### CWorld::SetPedsChoking

<pre>
plugin::Call<0x565800, float, float, float, float, CEntity*>(x1, y1, x2, y2, gasCreator);
0AA5: call_function 0x565800 num_params 5 pop 5 [x1] [y1] [x2] [y2] [gasCreator]
</pre>

#### CWorld::SetCarsOnFire

<pre>
plugin::Call<0x5659F0, float, float, float, float, CEntity*>(x1, y1, x2, y2, fireCreator);
0AA5: call_function 0x5659F0 num_params 5 pop 5 [x1] [y1] [x2] [y2] [fireCreator]
</pre>

#### CWorld::SprayPaintWorld

<pre>
plugin::CallAndReturn<bool, 0x565B70, CVector&, CVector&, float, bool>(posn, outDir, radius, processTagAlphaState);
0AA7: call_function_return 0x565B70 num_params 4 pop 4 [posn] [outDir] [radius] [processTagAlphaState] func_ret [bool]
</pre>

#### CWorld::RemoveFallenPeds

<pre>
plugin::Call<0x565CB0>();
0AA5: call_function 0x565CB0 num_params 0 pop 0
</pre>

#### CWorld::RemoveFallenCars

<pre>
plugin::Call<0x565E80>();
0AA5: call_function 0x565E80 num_params 0 pop 0
</pre>

#### CWorld::UseDetonator

<pre>
plugin::Call<0x5660B0, CEntity*>(creator);
0AA5: call_function 0x5660B0 num_params 1 pop 1 [creator]
</pre>

#### CWorld::TestSphereAgainstSectorList

<pre>
plugin::CallAndReturn<CEntity*, 0x566140, CPtrList&, CVector, float, CEntity*, bool>(ptrList, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);
0AA7: call_function_return 0x566140 num_params 5 pop 5 [ptrList] [sphereCenter] [sphereRadius] [ignoreEntity] [doCameraIgnoreCheck] func_ret [CEntity*]
</pre>

#### CWorld::PrintCarChanges

<pre>
plugin::Call<0x566420>();
0AA5: call_function 0x566420 num_params 0 pop 0
</pre>

#### CWorld::TestForBuildingsOnTopOfEachOther

<pre>
plugin::Call<0x5664A0>();
0AA5: call_function 0x5664A0 num_params 0 pop 0
</pre>

#### CWorld::TestForUnusedModels

<pre>
plugin::Call<0x566510>();
0AA5: call_function 0x566510 num_params 0 pop 0
</pre>

#### CWorld::ClearCarsFromArea

<pre>
plugin::Call<0x566610, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x566610 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CWorld::ClearPedsFromArea

<pre>
plugin::Call<0x5667F0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x5667F0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CWorld::SetAllCarsCanBeDamaged

<pre>
plugin::Call<0x5668F0, bool>(enable);
0AA5: call_function 0x5668F0 num_params 1 pop 1 [enable]
</pre>

#### CWorld::ExtinguishAllCarFiresInArea

<pre>
plugin::Call<0x566950, CVector, float>(point, radius);
0AA5: call_function 0x566950 num_params 2 pop 2 [point] [radius]
</pre>

#### CWorld::CallOffChaseForArea

<pre>
plugin::Call<0x566A60, float, float, float, float>(x1, y1, x2, y2);
0AA5: call_function 0x566A60 num_params 4 pop 4 [x1] [y1] [x2] [y2]
</pre>

#### CWorld::StopAllLawEnforcersInTheirTracks

<pre>
plugin::Call<0x566C10>();
0AA5: call_function 0x566C10 num_params 0 pop 0
</pre>

#### CWorld::FindUnsuspectingTargetCar

<pre>
plugin::CallAndReturn<CVehicle*, 0x566C90, CVector, CVector>(point, playerPosn);
0AA7: call_function_return 0x566C90 num_params 2 pop 2 [point] [playerPosn] func_ret [CVehicle*]
</pre>

#### CWorld::FindUnsuspectingTargetPed

<pre>
plugin::CallAndReturn<CPed*, 0x566DA0, CVector, CVector>(point, playerPosn);
0AA7: call_function_return 0x566DA0 num_params 2 pop 2 [point] [playerPosn] func_ret [CPed*]
</pre>

#### CWorld::ProcessLineOfSightSectorList

<pre>
plugin::CallAndReturn<bool, 0x566EE0, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool>(ptrList, colLine, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doIgnoreCameraCheck, doShootThroughCheck);
0AA7: call_function_return 0x566EE0 num_params 8 pop 8 [ptrList] [colLine] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [doIgnoreCameraCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x5674E0, CVector const&, float, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x5674E0 num_params 11 pop 11 [origin] [distance] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLine_FillGlobeColPoints

<pre>
plugin::CallAndReturn<bool, 0x567620, CVector const&, float, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x567620 num_params 10 pop 10 [origin] [distance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::TriggerExplosionSectorList

<pre>
plugin::Call<0x567750, CPtrList&, CVector const&, float, float, CEntity*, CEntity*, bool, float>(ptrList, point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage);
0AA5: call_function 0x567750 num_params 8 pop 8 [ptrList] [point] [radius] [visibleDistance] [victim] [creator] [processVehicleBombTimer] [damage]
</pre>

#### CWorld::Process

<pre>
plugin::Call<0x5684A0>();
0AA5: call_function 0x5684A0 num_params 0 pop 0
</pre>

#### CWorld::GetIsLineOfSightSectorClear

<pre>
plugin::CallAndReturn<bool, 0x568AD0, CSector&, CRepeatSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, repeatSector, colLine, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doIgnoreCameraCheck);
0AA7: call_function_return 0x568AD0 num_params 10 pop 10 [sector] [repeatSector] [colLine] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doIgnoreCameraCheck] func_ret [bool]
</pre>

#### CWorld::FindObjectsKindaColliding

<pre>
plugin::Call<0x568B80, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x568B80 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsIntersectingCube

<pre>
plugin::Call<0x568DD0, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x568DD0 num_params 10 pop 10 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsIntersectingAngledCollisionBox

<pre>
plugin::Call<0x568FF0, CBox const&, CMatrix const&, CVector const&, float, float, float, float, short*, short, CEntity**, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x568FF0 num_params 15 pop 15 [box] [transform] [point] [x1] [y1] [x2] [y2] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindMissionEntitiesIntersectingCube

<pre>
plugin::Call<0x569240, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);
0AA5: call_function 0x569240 num_params 8 pop 8 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehicles] [peds] [objects]
</pre>

#### CWorld::FindNearestObjectOfType

<pre>
plugin::Call<0x5693F0, int, CVector const&, float, bool, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x5693F0 num_params 9 pop 9 [modelId] [point] [radius] [b2D] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindGroundZForCoord

<pre>
plugin::CallAndReturn<float, 0x569660, float, float>(x, y);
0AA7: call_function_return 0x569660 num_params 2 pop 2 [x] [y] func_ret [float]
</pre>

#### CWorld::FindGroundZFor3DCoord

<pre>
plugin::CallAndReturn<float, 0x5696C0, float, float, float, bool*, CEntity**>(x, y, z, outResult, outEntity);
0AA7: call_function_return 0x5696C0 num_params 5 pop 5 [x] [y] [z] [outResult] [outEntity] func_ret [float]
</pre>

#### CWorld::FindRoofZFor3DCoord

<pre>
plugin::CallAndReturn<float, 0x569750, float, float, float, bool*>(x, y, z, outResult);
0AA7: call_function_return 0x569750 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]
</pre>

#### CWorld::FindLowestZForCoord

<pre>
plugin::CallAndReturn<float, 0x5697F0, float, float>(x, y);
0AA7: call_function_return 0x5697F0 num_params 2 pop 2 [x] [y] func_ret [float]
</pre>

#### CWorld::RepositionOneObject

<pre>
plugin::Call<0x569850, CEntity*>(object);
0AA5: call_function 0x569850 num_params 1 pop 1 [object]
</pre>

#### CWorld::TestSphereAgainstWorld

<pre>
plugin::CallAndReturn<CEntity*, 0x569E20, CVector, float, CEntity*, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, arg2, buildings, vehicles, peds, objects, dummies, doCameraIgnoreCheck);
0AA7: call_function_return 0x569E20 num_params 9 pop 9 [sphereCenter] [sphereRadius] [arg2] [buildings] [vehicles] [peds] [objects] [dummies] [doCameraIgnoreCheck] func_ret [CEntity*]
</pre>

#### CWorld::ClearExcitingStuffFromArea

<pre>
plugin::Call<0x56A0D0, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);
0AA5: call_function 0x56A0D0 num_params 3 pop 3 [point] [radius] [bRemoveProjectilesAndShadows]
</pre>

#### CWorld::GetIsLineOfSightClear

<pre>
plugin::CallAndReturn<bool, 0x56A490, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x56A490 num_params 9 pop 9 [origin] [target] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::ProcessLineOfSightSector

<pre>
plugin::CallAndReturn<bool, 0x56B5E0, CSector&, CRepeatSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(sector, repeatSector, colLine, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
0AA7: call_function_return 0x56B5E0 num_params 14 pop 14 [sector] [repeatSector] [colLine] [outColPoint] [maxTouchDistance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CWorld::TriggerExplosion

<pre>
plugin::Call<0x56B790, CVector const&, float, float, CEntity*, CEntity*, bool, float>(point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage);
0AA5: call_function 0x56B790 num_params 7 pop 7 [point] [radius] [visibleDistance] [victim] [creator] [processVehicleBombTimer] [damage]
</pre>

#### CWorld::SetWorldOnFire

<pre>
plugin::Call<0x56B910, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
0AA5: call_function 0x56B910 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]
</pre>

#### CWorld::RepositionCertainDynamicObjects

<pre>
plugin::Call<0x56B9C0>();
0AA5: call_function 0x56B9C0 num_params 0 pop 0
</pre>

#### CWorld::ProcessLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x56BA00, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
0AA7: call_function_return 0x56BA00 num_params 12 pop 12 [origin] [target] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### GetCurrentScanCode

<pre>
plugin::CallAndReturn<short, 0x407250>();
0AA7: call_function_return 0x407250 num_params 0 pop 0 func_ret [short]
</pre>

#### GetSector

<pre>
plugin::CallAndReturn<CSector*, 0x407260, int, int>(x, y);
0AA7: call_function_return 0x407260 num_params 2 pop 2 [x] [y] func_ret [CSector*]
</pre>

#### GetRepeatSector

<pre>
plugin::CallAndReturn<CRepeatSector*, 0x4072A0, int, int>(x, y);
0AA7: call_function_return 0x4072A0 num_params 2 pop 2 [x] [y] func_ret [CRepeatSector*]
</pre>

#### GetLodPtrList

<pre>
plugin::CallAndReturn<CPtrListSingleLink*, 0x4072C0, int, int>(x, y);
0AA7: call_function_return 0x4072C0 num_params 2 pop 2 [x] [y] func_ret [CPtrListSingleLink*]
</pre>

#### SetNextScanCode

<pre>
plugin::Call<0x4072E0>();
0AA5: call_function 0x4072E0 num_params 0 pop 0
</pre>

### plugin_sa\game_sa\D3DIndexDataBuffer.cpp

#### D3DIndexDataBuffer::Clear

<pre>
plugin::CallMethod<0x7301D0, D3DIndexDataBuffer *>(this);
0AA6: call_method 0x7301D0 struct [D3DIndexDataBuffer] num_params 0 pop 0
</pre>

#### D3DIndexDataBuffer::Destroy

<pre>
plugin::CallMethod<0x730200, D3DIndexDataBuffer *>(this);
0AA6: call_method 0x730200 struct [D3DIndexDataBuffer] num_params 0 pop 0
</pre>

#### D3DIndexDataBuffer::GetTotalDataSize

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x7303B0, D3DIndexDataBuffer *>(this);
0AA8: call_method_return 0x7303B0 struct [D3DIndexDataBuffer] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### D3DIndexDataBuffer::Resize

<pre>
plugin::CallMethod<0x730330, D3DIndexDataBuffer *, unsigned int>(this, newCapacity);
0AA6: call_method 0x730330 struct [D3DIndexDataBuffer] num_params 1 pop 0 [newCapacity]
</pre>

#### D3DIndexDataBuffer::Setup

<pre>
plugin::CallMethod<0x730190, D3DIndexDataBuffer *, unsigned int, int, unsigned int>(this, format, _f4, capacity);
0AA6: call_method 0x730190 struct [D3DIndexDataBuffer] num_params 3 pop 0 [format] [_f4] [capacity]
</pre>

#### D3DIndexDataBuffer::Pop

<pre>
plugin::CallMethodAndReturn<IDirect3DIndexBuffer9*, 0x730250, D3DIndexDataBuffer *>(this);
0AA8: call_method_return 0x730250 struct [D3DIndexDataBuffer] num_params 0 pop 0 func_ret [IDirect3DIndexBuffer9*]
</pre>

#### D3DIndexDataBuffer::Pop

<pre>
plugin::CallMethodAndReturn<IDirect3DIndexBuffer9*, 0x730270, D3DIndexDataBuffer *, unsigned int>(this, indexCount);
0AA8: call_method_return 0x730270 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexCount] func_ret [IDirect3DIndexBuffer9*]
</pre>

#### D3DIndexDataBuffer::Push

<pre>
plugin::CallMethodAndReturn<bool, 0x730300, D3DIndexDataBuffer *, IDirect3DIndexBuffer9*>(this, indexBuffer);
0AA8: call_method_return 0x730300 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]
</pre>

#### D3DIndexDataBuffer::PushWithoutIncreasingCounter

<pre>
plugin::CallMethodAndReturn<bool, 0x730B00, D3DIndexDataBuffer *, IDirect3DIndexBuffer9*>(this, indexBuffer);
0AA8: call_method_return 0x730B00 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]
</pre>

#### D3DIndexDataBuffer::Pop

<pre>
plugin::CallMethodAndReturn<void*, 0x730250, D3DIndexDataBuffer *>(this);
0AA8: call_method_return 0x730250 struct [D3DIndexDataBuffer] num_params 0 pop 0 func_ret [void*]
</pre>

#### D3DIndexDataBuffer::Pop

<pre>
plugin::CallMethodAndReturn<void*, 0x730270, D3DIndexDataBuffer *, unsigned int>(this, indexCount);
0AA8: call_method_return 0x730270 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexCount] func_ret [void*]
</pre>

#### D3DIndexDataBuffer::Push

<pre>
plugin::CallMethodAndReturn<bool, 0x730300, D3DIndexDataBuffer *, void*>(this, indexBuffer);
0AA8: call_method_return 0x730300 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]
</pre>

#### D3DIndexDataBuffer::PushWithoutIncreasingCounter

<pre>
plugin::CallMethodAndReturn<bool, 0x730B00, D3DIndexDataBuffer *, void*>(this, indexBuffer);
0AA8: call_method_return 0x730B00 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]
</pre>

### plugin_sa\game_sa\D3DResourceSystem.cpp

#### D3DResourceSystem::CancelBuffering

<pre>
plugin::Call<0x730900>();
0AA5: call_function 0x730900 num_params 0 pop 0
</pre>

#### D3DResourceSystem::GetTotalIndexDataSize

<pre>
plugin::CallAndReturn<unsigned int, 0x7307F0>();
0AA7: call_function_return 0x7307F0 num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### D3DResourceSystem::GetTotalPixelsSize

<pre>
plugin::CallAndReturn<unsigned int, 0x730660>();
0AA7: call_function_return 0x730660 num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### D3DResourceSystem::Init

<pre>
plugin::Call<0x730830>();
0AA5: call_function 0x730830 num_params 0 pop 0
</pre>

#### D3DResourceSystem::SetUseD3DResourceBuffering

<pre>
plugin::Call<0x730AC0, bool>(bUse);
0AA5: call_function 0x730AC0 num_params 1 pop 1 [bUse]
</pre>

#### D3DResourceSystem::Shutdown

<pre>
plugin::Call<0x730A00>();
0AA5: call_function 0x730A00 num_params 0 pop 0
</pre>

#### D3DResourceSystem::TidyUpD3DIndexBuffers

<pre>
plugin::Call<0x730740, unsigned int>(count);
0AA5: call_function 0x730740 num_params 1 pop 1 [count]
</pre>

#### D3DResourceSystem::TidyUpD3DTextures

<pre>
plugin::Call<0x7305E0, unsigned int>(count);
0AA5: call_function 0x7305E0 num_params 1 pop 1 [count]
</pre>

#### D3DResourceSystem::CreateIndexBuffer

<pre>
plugin::CallAndReturn<HRESULT, 0x7306A0, unsigned int, unsigned int, IDirect3DIndexBuffer9**>(numIndices, format, ppIndexBuffer);
0AA7: call_function_return 0x7306A0 num_params 3 pop 3 [numIndices] [format] [ppIndexBuffer] func_ret [HRESULT]
</pre>

#### D3DResourceSystem::CreateTexture

<pre>
plugin::CallAndReturn<HRESULT, 0x730510, int, int, unsigned int, IDirect3DTexture9**>(width, height, format, ppTexture);
0AA7: call_function_return 0x730510 num_params 4 pop 4 [width] [height] [format] [ppTexture] func_ret [HRESULT]
</pre>

#### D3DResourceSystem::DestroyIndexBuffer

<pre>
plugin::Call<0x730D30, IDirect3DIndexBuffer9*>(pIndexBuffer);
0AA5: call_function 0x730D30 num_params 1 pop 1 [pIndexBuffer]
</pre>

#### D3DResourceSystem::DestroyTexture

<pre>
plugin::Call<0x730B70, IDirect3DTexture9*>(pTexture);
0AA5: call_function 0x730B70 num_params 1 pop 1 [pTexture]
</pre>

#### D3DResourceSystem::CreateIndexBuffer

<pre>
plugin::CallAndReturn<int, 0x7306A0, unsigned int, unsigned int, void**>(numIndices, format, ppIndexBuffer);
0AA7: call_function_return 0x7306A0 num_params 3 pop 3 [numIndices] [format] [ppIndexBuffer] func_ret [int]
</pre>

#### D3DResourceSystem::CreateTexture

<pre>
plugin::CallAndReturn<int, 0x730510, int, int, unsigned int, void**>(width, height, format, ppTexture);
0AA7: call_function_return 0x730510 num_params 4 pop 4 [width] [height] [format] [ppTexture] func_ret [int]
</pre>

#### D3DResourceSystem::DestroyIndexBuffer

<pre>
plugin::Call<0x730D30, void*>(pIndexBuffer);
0AA5: call_function 0x730D30 num_params 1 pop 1 [pIndexBuffer]
</pre>

#### D3DResourceSystem::DestroyTexture

<pre>
plugin::Call<0x730B70, void*>(pTexture);
0AA5: call_function 0x730B70 num_params 1 pop 1 [pTexture]
</pre>

### plugin_sa\game_sa\D3DTextureBuffer.cpp

#### D3DTextureBuffer::Clear

<pre>
plugin::CallMethod<0x72FEC0, D3DTextureBuffer *>(this);
0AA6: call_method 0x72FEC0 struct [D3DTextureBuffer] num_params 0 pop 0
</pre>

#### D3DTextureBuffer::Destroy

<pre>
plugin::CallMethod<0x72FEF0, D3DTextureBuffer *>(this);
0AA6: call_method 0x72FEF0 struct [D3DTextureBuffer] num_params 0 pop 0
</pre>

#### D3DTextureBuffer::GetTotalDataSize

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x7300A0, D3DTextureBuffer *>(this);
0AA8: call_method_return 0x7300A0 struct [D3DTextureBuffer] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### D3DTextureBuffer::Resize

<pre>
plugin::CallMethod<0x730020, D3DTextureBuffer *, unsigned int>(this, newCapacity);
0AA6: call_method 0x730020 struct [D3DTextureBuffer] num_params 1 pop 0 [newCapacity]
</pre>

#### D3DTextureBuffer::Setup

<pre>
plugin::CallMethod<0x72FE80, D3DTextureBuffer *, unsigned int, int, int, unsigned int>(this, format, width, bOneLevel, capacity);
0AA6: call_method 0x72FE80 struct [D3DTextureBuffer] num_params 4 pop 0 [format] [width] [bOneLevel] [capacity]
</pre>

#### D3DTextureBuffer::Pop

<pre>
plugin::CallMethodAndReturn<IDirect3DTexture9*, 0x72FF40, D3DTextureBuffer *>(this);
0AA8: call_method_return 0x72FF40 struct [D3DTextureBuffer] num_params 0 pop 0 func_ret [IDirect3DTexture9*]
</pre>

#### D3DTextureBuffer::Pop

<pre>
plugin::CallMethodAndReturn<IDirect3DTexture9*, 0x72FF60, D3DTextureBuffer *, unsigned int, int, int, int>(this, format, width, height, bOneLevel);
0AA8: call_method_return 0x72FF60 struct [D3DTextureBuffer] num_params 4 pop 0 [format] [width] [height] [bOneLevel] func_ret [IDirect3DTexture9*]
</pre>

#### D3DTextureBuffer::Push

<pre>
plugin::CallMethodAndReturn<bool, 0x72FFF0, D3DTextureBuffer *, IDirect3DTexture9*>(this, texture);
0AA8: call_method_return 0x72FFF0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]
</pre>

#### D3DTextureBuffer::PushWithoutIncreasingCounter

<pre>
plugin::CallMethodAndReturn<bool, 0x730AD0, D3DTextureBuffer *, IDirect3DTexture9*>(this, texture);
0AA8: call_method_return 0x730AD0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]
</pre>

#### D3DTextureBuffer::Pop

<pre>
plugin::CallMethodAndReturn<void*, 0x72FF40, D3DTextureBuffer *>(this);
0AA8: call_method_return 0x72FF40 struct [D3DTextureBuffer] num_params 0 pop 0 func_ret [void*]
</pre>

#### D3DTextureBuffer::Pop

<pre>
plugin::CallMethodAndReturn<void*, 0x72FF60, D3DTextureBuffer *, unsigned int, int, int, int>(this, format, width, height, bOneLevel);
0AA8: call_method_return 0x72FF60 struct [D3DTextureBuffer] num_params 4 pop 0 [format] [width] [height] [bOneLevel] func_ret [void*]
</pre>

#### D3DTextureBuffer::Push

<pre>
plugin::CallMethodAndReturn<bool, 0x72FFF0, D3DTextureBuffer *, void*>(this, texture);
0AA8: call_method_return 0x72FFF0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]
</pre>

#### D3DTextureBuffer::PushWithoutIncreasingCounter

<pre>
plugin::CallMethodAndReturn<bool, 0x730AD0, D3DTextureBuffer *, void*>(this, texture);
0AA8: call_method_return 0x730AD0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]
</pre>

### plugin_sa\game_sa\JPegCompress.cpp

#### assert

<pre>
plugin::Call<0x005D0820>(pCamera, pszPath);
0AA5: call_function 0x005D0820 num_params 2 pop 2 [pCamera] [pszPath]
</pre>

#### assert

<pre>
plugin::Call<0x005D0740>(pCamera, pBuffer, pSize);
0AA5: call_function 0x005D0740 num_params 3 pop 3 [pCamera] [pBuffer] [pSize]
</pre>

#### assert

<pre>
plugin::CallAndReturn<RwBool, 0x005D07A0>(pRaster, pBuffer);
0AA7: call_function_return 0x005D07A0 num_params 2 pop 2 [pRaster] [pBuffer] func_ret [RwBool]
</pre>

### plugin_sa\game_sa\List_c.cpp

#### List_c::List_c

<pre>
plugin::CallMethod<0x004A8DD0>(this);
0AA6: call_method 0x004A8DD0 struct [List_c] num_params 0 pop 0
</pre>

#### List_c::~List_c

<pre>
plugin::CallMethod<0x004A8DE0>(this);
0AA6: call_method 0x004A8DE0 struct [List_c] num_params 0 pop 0
</pre>

#### assert

<pre>
plugin::CallMethod<0x004A8DF0, List_c *, ListItem_c *>(this, pItem);</pre>

#### assert

<pre>
plugin::CallMethod<0x004A8E30, List_c *, ListItem_c *>(this, pItem);</pre>

#### List_c::RemoveHead

<pre>
plugin::CallMethodAndReturn<ListItem_c *, 0x004A8E70, List_c *>(this);
0AA8: call_method_return 0x004A8E70 struct [List_c] num_params 0 pop 0 func_ret [ListItem_c *]
</pre>

#### assert

<pre>
plugin::CallMethodAndReturn<ListItem_c *, 0x004A9000, List_c *, ListItem_c *>(this, pItem);</pre>

#### List_c::GetItemOffset

<pre>
plugin::CallMethodAndReturn<ListItem_c *, 0x004A9010, List_c *, bool, int>(this, bFromHead, iOffset);
0AA8: call_method_return 0x004A9010 struct [List_c] num_params 2 pop 0 [bFromHead] [iOffset] func_ret [ListItem_c *]
</pre>

### plugin_sa\game_sa\ListItem_c.cpp

#### ListItem_c::ListItem_c

<pre>
plugin::CallMethod<0x004A8DB0>(this);
0AA6: call_method 0x004A8DB0 struct [ListItem_c] num_params 0 pop 0
</pre>

#### ListItem_c::~ListItem_c

<pre>
plugin::CallMethod<0x004A8DC0>(this);
0AA6: call_method 0x004A8DC0 struct [ListItem_c] num_params 0 pop 0
</pre>

### plugin_sa\game_sa\PipelinePlugin.cpp

#### PipelinePluginAttach

<pre>
plugin::CallAndReturn<RwBool, 0x0072FBD0>();
0AA7: call_function_return 0x0072FBD0 num_params 0 pop 0 func_ret [RwBool]
</pre>

#### assert

<pre>
plugin::CallAndReturn<RwUInt32, 0x0072FC40>(pAtomic);
0AA7: call_function_return 0x0072FC40 num_params 1 pop 1 [pAtomic] func_ret [RwUInt32]
</pre>

#### assert

<pre>
plugin::Call<0x0072FC50>(pAtomic, uPipelineID);
0AA5: call_function 0x0072FC50 num_params 2 pop 2 [pAtomic] [uPipelineID]
</pre>

### plugin_sa\game_sa\RenderWare.cpp

#### RsEventHandler

<pre>
plugin::CallAndReturn<RsEventStatus, 0x619B60, RsEvent, void*>(e, param);
0AA7: call_function_return 0x619B60 num_params 2 pop 2 [e] [param] func_ret [RsEventStatus]
</pre>

#### \_rwObjectHasFrameSetFrame

<pre>
plugin::Call<0x804EF0, void *, RwFrame *>(object, frame);
0AA5: call_function 0x804EF0 num_params 2 pop 2 [object] [frame]
</pre>

#### \_rwObjectHasFrameReleaseFrame

<pre>
plugin::Call<0x804F40, void *>(object);
0AA5: call_function 0x804F40 num_params 1 pop 1 [object]
</pre>

#### \*\_rpD3D9SkinVertexShaderMatrixUpdate

<pre>
plugin::CallAndReturn<RpAtomic *, 0x7C78A0, RwMatrix *, RpAtomic *, RpSkin *>(matrices, atomic, skin);
0AA7: call_function_return 0x7C78A0 num_params 3 pop 3 [matrices] [atomic] [skin] func_ret [RpAtomic *]
</pre>

#### \_rwD3D9SetStreams

<pre>
plugin::Call<0x7FA090, RxD3D9VertexStream *, RwBool>(streams, useOffsets);
0AA5: call_function 0x7FA090 num_params 2 pop 2 [streams] [useOffsets]
</pre>

#### \_rwD3D9RenderStateVertexAlphaEnable

<pre>
plugin::CallAndReturn<RwBool, 0x7FE0A0, RwBool>(enable);
0AA7: call_function_return 0x7FE0A0 num_params 1 pop 1 [enable] func_ret [RwBool]
</pre>

#### \_rwD3D9RenderStateIsVertexAlphaEnable

<pre>
plugin::CallAndReturn<RwBool, 0x7FE190>();
0AA7: call_function_return 0x7FE190 num_params 0 pop 0 func_ret [RwBool]
</pre>

#### \_rwD3D9CheckValidCameraTextureFormat

<pre>
plugin::CallAndReturn<RwBool, 0x4CBE20, RwUInt32>(format);
0AA7: call_function_return 0x4CBE20 num_params 1 pop 1 [format] func_ret [RwBool]
</pre>

#### \_rwD3D9SetVertexDeclaration

<pre>
plugin::Call<0x7F9F70, void *>(vertexDeclaration);
0AA5: call_function 0x7F9F70 num_params 1 pop 1 [vertexDeclaration]
</pre>

#### \_rwD3D9SetIndices

<pre>
plugin::Call<0x7FA1C0, void *>(indices);
0AA5: call_function 0x7FA1C0 num_params 1 pop 1 [indices]
</pre>

#### \_rwD3D9DrawPrimitive

<pre>
plugin::Call<0x7FA360, RwUInt32, RwUInt32, RwUInt32>(primitiveType, startIndex, primitiveCount);
0AA5: call_function 0x7FA360 num_params 3 pop 3 [primitiveType] [startIndex] [primitiveCount]
</pre>

#### \_rwStreamReadChunkHeader

<pre>
plugin::CallAndReturn<RwBool, 0x7ED0F0, RwStream *, RwUInt32 *, RwUInt32 *, RwUInt32 *, RwUInt32 *>(stream, pType, pLength, pVersion, pBuild);
0AA7: call_function_return 0x7ED0F0 num_params 5 pop 5 [stream] [pType] [pLength] [pVersion] [pBuild] func_ret [RwBool]
</pre>

### plugin_sa\game_sa\meta\meta.CAnimBlendAssociation.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendHierarchy &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendHierarchy &)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), rhs);</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendAssociation, void(RpClump *, CAnimBlendHierarchy *)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), clump, hier);</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), rhs);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(dtor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), &objArray[i]);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendHierarchy &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendHierarchy &)), obj, rhs);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendAssociation, void(RpClump *, CAnimBlendHierarchy *)), obj, clump, hier);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &)), obj, rhs);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendAssociation *, unsigned char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendAssociation *, unsigned char>(&objArray[i], 1);
</pre>

### plugin_sa\game_sa\meta\meta.CAnimBlendStaticAssociation.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff));</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendStaticAssociation, void(RpClump *, CAnimBlendHierarchy *)), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff), clump, hierarchy);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(dtor_gaddr(CAnimBlendStaticAssociation), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), &objArray[i]);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendStaticAssociation, void(RpClump *, CAnimBlendHierarchy *)), obj, clump, hierarchy);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendStaticAssociation *, unsigned char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CAnimBlendStaticAssociation *, unsigned char>(objArray, 3);
</pre>

### plugin_sa\game_sa\meta\meta.CCamera.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CCamera *>(dtor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), &objArray[i]);</pre>

####

<pre>
plugin::CallVirtualMethod<0, CCamera *, char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<0, CCamera *, char>(&objArray[i], 1);
</pre>

### plugin_sa\game_sa\meta\meta.CEntryExit.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), reinterpret_cast<CEntryExit *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), &objArray[i]);</pre>

### plugin_sa\game_sa\meta\meta.CGangInfo.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), &objArray[i]);</pre>

### plugin_sa\game_sa\meta\meta.CMatrixLink.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), reinterpret_cast<CMatrixLink *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), reinterpret_cast<CMatrixLink *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), &objArray[i]);</pre>

### plugin_sa\game_sa\meta\meta.CPedGroup.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), reinterpret_cast<CPedGroup *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), reinterpret_cast<CPedGroup *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), &objArray[i]);</pre>

### plugin_sa\game_sa\meta\meta.CPedGroupIntelligence.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), reinterpret_cast<CPedGroupIntelligence *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), reinterpret_cast<CPedGroupIntelligence *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), &objArray[i]);</pre>

### plugin_sa\game_sa\meta\meta.CPedGroupMembership.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), reinterpret_cast<CPedGroupMembership *>(objBuff));</pre>

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(ctor_gaddr_o(CPedGroupMembership, void(CPedGroupMembership const *)), reinterpret_cast<CPedGroupMembership *>(objBuff), Obj);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), reinterpret_cast<CPedGroupMembership *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), &objArray[i]);</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(ctor_gaddr_o(CPedGroupMembership, void(CPedGroupMembership const *)), obj, Obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), &objArray[i]);</pre>

### plugin_vc\game_vc\C_PcSave.cpp

#### C_PcSave::DeleteSlot

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::DeleteSlot), this, slot);
0AA8: call_method_return 0x61D430 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]
</pre>

#### C_PcSave::PcClassSaveRoutine

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int, unsigned char *, unsigned int>(gaddrof(C_PcSave::PcClassSaveRoutine), this, file, data, size);
0AA8: call_method_return 0x61D7A0 struct [C_PcSave] num_params 3 pop 0 [file] [data] [size] func_ret [bool]
</pre>

#### C_PcSave::PopulateSlotInfo

<pre>
plugin::CallMethodDynGlobal<C_PcSave *>(gaddrof(C_PcSave::PopulateSlotInfo), this);
0AA6: call_method 0x61D4A0 struct [C_PcSave] num_params 0 pop 0
</pre>

#### C_PcSave::SaveSlot

<pre>
plugin::CallMethodAndReturnDynGlobal<char, C_PcSave *, int>(gaddrof(C_PcSave::SaveSlot), this, slot);
0AA8: call_method_return 0x61D8B0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [char]
</pre>

#### C_PcSave::SetSaveDirectory

<pre>
plugin::CallDynGlobal<char const *>(gaddrof(C_PcSave::SetSaveDirectory), path);
</pre>

### plugin_vc\game_vc\C3dMarker.cpp

#### C3dMarker::AddMarker

<pre>
plugin::CallMethodDynGlobal<C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned int, float, unsigned short>(gaddrof(C3dMarker::AddMarker), this, nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);
0AA6: call_method 0x570E90 struct [C3dMarker] num_params 10 pop 0 [nId] [nType] [fSize] [bRed] [bGreen] [bBlue] [bAlpha] [nPulsePeriod] [fPulseFraction] [nRotateRate]
</pre>

#### C3dMarker::Render

<pre>
plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::Render), this);
0AA6: call_method 0x570DA0 struct [C3dMarker] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\C3dMarkers.cpp

#### C3dMarkers::PlaceMarkerSet

<pre>
plugin::Call<0x570270, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, pos, size, r, g, b, a, pulsePeriod, pulseFraction, rotateRate);
0AA5: call_function 0x570270 num_params 11 pop 11 [id] [type] [pos] [size] [r] [g] [b] [a] [pulsePeriod] [pulseFraction] [rotateRate]
</pre>

### plugin_vc\game_vc\CAnimBlendAssociation.cpp

#### CAnimBlendAssociation::~CAnimBlendAssociation

<pre>
plugin::CallVirtualMethod<0, CAnimBlendAssociation *>(this, 1);
</pre>

### plugin_vc\game_vc\CAnimManager.cpp

#### CAnimManager::GetAnimationBlockIndex

<pre>
plugin::CallAndReturn<int, 0x4059E0, char const*>(name);
0AA7: call_function_return 0x4059E0 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### \*CAnimManager::GetAnimationBlock

<pre>
plugin::CallAndReturn<CAnimBlock*, 0x405A50, char const*>(name);
0AA7: call_function_return 0x405A50 num_params 1 pop 1 [name] func_ret [CAnimBlock*]
</pre>

#### \*CAnimManager::BlendAnimation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x405640, RpClump*, int, int, float>(clump, assocGroupId, animationId, clumpAssocBlendData);
0AA7: call_function_return 0x405640 num_params 4 pop 4 [clump] [assocGroupId] [animationId] [clumpAssocBlendData] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::AddAnimation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4058B0, RpClump*, int, int>(clump, assocGroupId, animationId);
0AA7: call_function_return 0x4058B0 num_params 3 pop 3 [clump] [assocGroupId] [animationId] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::GetAnimAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x405940, int, const char*>(assocGroupId, name);
0AA7: call_function_return 0x405940 num_params 2 pop 2 [assocGroupId] [name] func_ret [CAnimBlendAssociation*]
</pre>

#### CAnimManager::GetAnimAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x405960, int, int>(assocGroupId, animationId);
0AA7: call_function_return 0x405960 num_params 2 pop 2 [assocGroupId] [animationId] func_ret [CAnimBlendAssociation*]
</pre>

### plugin_vc\game_vc\cAudioManager.cpp

#### cAudioManager::FindVehicleOfPlayer

<pre>
plugin::CallAndReturn<CVehicle*, 0x5F5A60>();
0AA7: call_function_return 0x5F5A60 num_params 0 pop 0 func_ret [CVehicle*]
</pre>

### plugin_vc\game_vc\cAudioScriptObject.cpp

#### cAudioScriptObject::LoadAllAudioScriptObjects

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(cAudioScriptObject::LoadAllAudioScriptObjects), buffer, size);
</pre>

#### cAudioScriptObject::SaveAllAudioScriptObjects

<pre>
plugin::CallDynGlobal<unsigned char *, int *>(gaddrof(cAudioScriptObject::SaveAllAudioScriptObjects), buffer, outSize);
</pre>

### plugin_vc\game_vc\CAutomobile.cpp

#### CAutomobile::AddDamagedVehicleParticles

<pre>
plugin::CallMethod<0x5920A0, CAutomobile *>(this);
0AA6: call_method 0x5920A0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::AddWheelDirtAndWater

<pre>
plugin::CallMethodAndReturn<bool, 0x591B90, CAutomobile *, CColPoint&, unsigned int>(this, colPoint, arg1);
0AA8: call_method_return 0x591B90 struct [CAutomobile] num_params 2 pop 0 [colPoint] [arg1] func_ret [bool]
</pre>

#### CAutomobile::BlowUpCarsInPath

<pre>
plugin::CallMethod<0x5863D0, CAutomobile *>(this);
0AA6: call_method 0x5863D0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::CAutomobile

<pre>
plugin::CallMethod<0x59E620, CAutomobile *, int, unsigned char>(this, modelIndex, createdBy);
0AA6: call_method 0x59E620 struct [CAutomobile] num_params 2 pop 0 [modelIndex] [createdBy]
</pre>

#### CAutomobile::ClearHeliOrientation

<pre>
plugin::CallMethod<0x59B490, CAutomobile *>(this);
0AA6: call_method 0x59B490 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::CloseBoot

<pre>
plugin::CallMethod<0x585D80, CAutomobile *>(this);
0AA6: call_method 0x585D80 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::DoDriveByShootings

<pre>
plugin::CallMethod<0x5C97B0, CAutomobile *>(this);
0AA6: call_method 0x5C97B0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::DoHoverSuspensionRatios

<pre>
plugin::CallMethod<0x585B60, CAutomobile *>(this);
0AA6: call_method 0x585B60 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::FireTruckControl

<pre>
plugin::CallMethod<0x57AB30, CAutomobile *, float>(this, arg0);
0AA6: call_method 0x57AB30 struct [CAutomobile] num_params 1 pop 0 [arg0]
</pre>

#### CAutomobile::Fix

<pre>
plugin::CallMethod<0x588530, CAutomobile *>(this);
0AA6: call_method 0x588530 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::HasCarStoppedBecauseOfLight

<pre>
plugin::CallMethodAndReturn<bool, 0x435570, CAutomobile *>(this);
0AA8: call_method_return 0x435570 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAutomobile::HydraulicControl

<pre>
plugin::CallMethod<0x59D260, CAutomobile *>(this);
0AA6: call_method 0x59D260 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::KnockPedOutCar

<pre>
plugin::CallMethodAndReturn<CPed*, 0x585F20, CAutomobile *, eWeaponType, unsigned short, CPed*>(this, weapon, arg1, ped);
0AA8: call_method_return 0x585F20 struct [CAutomobile] num_params 3 pop 0 [weapon] [arg1] [ped] func_ret [CPed*]
</pre>

#### CAutomobile::PlaceOnRoadProperly

<pre>
plugin::CallMethod<0x586110, CAutomobile *>(this);
0AA6: call_method 0x586110 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::PlayHornIfNecessary

<pre>
plugin::CallMethod<0x5881F0, CAutomobile *>(this);
0AA6: call_method 0x5881F0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::PopBoot

<pre>
plugin::CallMethod<0x585E60, CAutomobile *>(this);
0AA6: call_method 0x585E60 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::PopBootUsingPhysics

<pre>
plugin::CallMethod<0x585E20, CAutomobile *>(this);
0AA6: call_method 0x585E20 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ProcessAutoBusDoors

<pre>
plugin::CallMethod<0x586EC0, CAutomobile *>(this);
0AA6: call_method 0x586EC0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ProcessBuoyancy

<pre>
plugin::CallMethod<0x599B30, CAutomobile *>(this);
0AA6: call_method 0x599B30 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::ProcessSwingingDoor

<pre>
plugin::CallMethod<0x592C40, CAutomobile *, int, eDoors>(this, nodeIndex, door);
0AA6: call_method 0x592C40 struct [CAutomobile] num_params 2 pop 0 [nodeIndex] [door]
</pre>

#### CAutomobile::RcbanditCheck1CarWheels

<pre>
plugin::CallMethodAndReturn<bool, 0x5878E0, CAutomobile *, CPtrList&>(this, ptrlist);
0AA8: call_method_return 0x5878E0 struct [CAutomobile] num_params 1 pop 0 [ptrlist] func_ret [bool]
</pre>

#### CAutomobile::RcbanditCheckHitWheels

<pre>
plugin::CallMethodAndReturn<bool, 0x587B40, CAutomobile *>(this);
0AA8: call_method_return 0x587B40 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]
</pre>

#### CAutomobile::ReduceHornCounter

<pre>
plugin::CallMethod<0x59AA90, CAutomobile *>(this);
0AA6: call_method 0x59AA90 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::RemoveBonnetInPedCollision

<pre>
plugin::CallMethodAndReturn<CObject*, 0x592BA0, CAutomobile *>(this);
0AA8: call_method_return 0x592BA0 struct [CAutomobile] num_params 0 pop 0 func_ret [CObject*]
</pre>

#### CAutomobile::ScanForCrimes

<pre>
plugin::CallMethod<0x588120, CAutomobile *>(this);
0AA6: call_method 0x588120 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::SetBumperDamage

<pre>
plugin::CallMethod<0x59B370, CAutomobile *, int, ePanels, bool>(this, arg0, panel, withoutVisualEffect);
0AA6: call_method 0x59B370 struct [CAutomobile] num_params 3 pop 0 [arg0] [panel] [withoutVisualEffect]
</pre>

#### CAutomobile::SetBusDoorTimer

<pre>
plugin::CallMethod<0x587080, CAutomobile *, unsigned int, unsigned char>(this, time, arg1);
0AA6: call_method 0x587080 struct [CAutomobile] num_params 2 pop 0 [time] [arg1]
</pre>

#### CAutomobile::SetDoorDamage

<pre>
plugin::CallMethod<0x59B150, CAutomobile *, int, eDoors, bool>(this, nodeIndex, door, withoutVisualEffect);
0AA6: call_method 0x59B150 struct [CAutomobile] num_params 3 pop 0 [nodeIndex] [door] [withoutVisualEffect]
</pre>

#### CAutomobile::SetHeliOrientation

<pre>
plugin::CallMethod<0x59B4A0, CAutomobile *, float>(this, angle);
0AA6: call_method 0x59B4A0 struct [CAutomobile] num_params 1 pop 0 [angle]
</pre>

#### CAutomobile::SetPanelDamage

<pre>
plugin::CallMethod<0x59B2A0, CAutomobile *, int, ePanels, bool>(this, nodeIndex, panel, createWindowGlass);
0AA6: call_method 0x59B2A0 struct [CAutomobile] num_params 3 pop 0 [nodeIndex] [panel] [createWindowGlass]
</pre>

#### CAutomobile::SetTaxiLight

<pre>
plugin::CallMethod<0x5882F0, CAutomobile *, bool>(this, enable);
0AA6: call_method 0x5882F0 struct [CAutomobile] num_params 1 pop 0 [enable]
</pre>

#### CAutomobile::SetupDamageAfterLoad

<pre>
plugin::CallMethod<0x588310, CAutomobile *>(this);
0AA6: call_method 0x588310 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::SetupSuspensionLines

<pre>
plugin::CallMethod<0x59E2B0, CAutomobile *>(this);
0AA6: call_method 0x59E2B0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::SpawnFlyingComponent

<pre>
plugin::CallMethodAndReturn<CObject*, 0x59AAA0, CAutomobile *, int, unsigned int>(this, nodeIndex, collisionType);
0AA8: call_method_return 0x59AAA0 struct [CAutomobile] num_params 2 pop 0 [nodeIndex] [collisionType] func_ret [CObject*]
</pre>

#### CAutomobile::TankControl

<pre>
plugin::CallMethod<0x5864C0, CAutomobile *>(this);
0AA6: call_method 0x5864C0 struct [CAutomobile] num_params 0 pop 0
</pre>

#### CAutomobile::TellHeliToGoToCoors

<pre>
plugin::CallMethod<0x59B4B0, CAutomobile *, float, float, float, unsigned char>(this, x, y, z, arg3);
0AA6: call_method 0x59B4B0 struct [CAutomobile] num_params 4 pop 0 [x] [y] [z] [arg3]
</pre>

#### CAutomobile::TellPlaneToGoToCoors

<pre>
plugin::CallMethod<0x59B420, CAutomobile *, float, float, float, unsigned char>(this, x, y, z, arg3);
0AA6: call_method 0x59B420 struct [CAutomobile] num_params 4 pop 0 [x] [y] [z] [arg3]
</pre>

#### CAutomobile::VehicleDamage

<pre>
plugin::CallMethod<0x59B550, CAutomobile *, float, int>(this, damageIntensity, arg1);
0AA6: call_method 0x59B550 struct [CAutomobile] num_params 2 pop 0 [damageIntensity] [arg1]
</pre>

#### CAutomobile::dmgDrawCarCollidingParticles

<pre>
plugin::CallMethod<0x59C480, CAutomobile *, CVector const&, float>(this, position, force);
0AA6: call_method 0x59C480 struct [CAutomobile] num_params 2 pop 0 [position] [force]
</pre>

### plugin_vc\game_vc\CBaseModelInfo.cpp

#### CBaseModelInfo::Shutdown

<pre>
plugin::CallVirtualMethod<1, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::DeleteRwObject

<pre>
plugin::CallVirtualMethod<2, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject*, 3, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::CreateInstance

<pre>
plugin::CallVirtualMethodAndReturn<RwObject*, 4, CBaseModelInfo *, RwMatrixTag*>(this, tranform);
</pre>

#### CBaseModelInfo::GetRwObject

<pre>
plugin::CallVirtualMethodAndReturn<RwObject*, 5, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::SetAnimFile

<pre>
plugin::CallVirtualMethod<6, CBaseModelInfo *, char const*>(this, filename);
</pre>

#### CBaseModelInfo::ConvertAnimFileIndex

<pre>
plugin::CallVirtualMethod<7, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::GetAnimFileIndex

<pre>
plugin::CallVirtualMethodAndReturn<int, 8, CBaseModelInfo *>(this);
</pre>

#### CBaseModelInfo::RemoveRef

<pre>
plugin::CallMethod<0x53F1A0, CBaseModelInfo *>(this);
0AA6: call_method 0x53F1A0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::AddRef

<pre>
plugin::CallMethod<0x53F1B0, CBaseModelInfo *>(this);
0AA6: call_method 0x53F1B0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::RemoveTexDictionaryRef

<pre>
plugin::CallMethod<0x53F1C0, CBaseModelInfo *>(this);
0AA6: call_method 0x53F1C0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::AddTexDictionaryRef

<pre>
plugin::CallMethod<0x53F1D0, CBaseModelInfo *>(this);
0AA6: call_method 0x53F1D0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::ClearTexDictionary

<pre>
plugin::CallMethod<0x53F1E0, CBaseModelInfo *>(this);
0AA6: call_method 0x53F1E0 struct [CBaseModelInfo] num_params 0 pop 0
</pre>

#### CBaseModelInfo::SetTexDictionary

<pre>
plugin::CallMethod<0x53F1F0, CBaseModelInfo *, char*>(this, txdName);
0AA6: call_method 0x53F1F0 struct [CBaseModelInfo] num_params 1 pop 0 [txdName]
</pre>

#### CBaseModelInfo::Add2dEffect

<pre>
plugin::CallMethod<0x53F220, CBaseModelInfo *, C2dEffect*>(this, effect);
0AA6: call_method 0x53F220 struct [CBaseModelInfo] num_params 1 pop 0 [effect]
</pre>

#### CBaseModelInfo::Get2dEffect

<pre>
plugin::CallMethodAndReturn<C2dEffect*, 0x53F260, CBaseModelInfo *, int>(this, effectNumber);
0AA8: call_method_return 0x53F260 struct [CBaseModelInfo] num_params 1 pop 0 [effectNumber] func_ret [C2dEffect*]
</pre>

#### CBaseModelInfo::GetColModel

<pre>
plugin::CallMethodAndReturn<CColModel *, 0x4739B2, CBaseModelInfo *>(this);
0AA8: call_method_return 0x4739B2 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [CColModel *]
</pre>

### plugin_vc\game_vc\CBike.cpp

#### CBike::AddDamagedVehicleParticles

<pre>
plugin::CallMethod<0x60DD20, CBike *>(this);
0AA6: call_method 0x60DD20 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::AddWheelDirtAndWater

<pre>
plugin::CallMethodAndReturn<bool, 0x60D7F0, CBike *, CColPoint&, unsigned int>(this, colPoint, arg1);
0AA8: call_method_return 0x60D7F0 struct [CBike] num_params 2 pop 0 [colPoint] [arg1] func_ret [bool]
</pre>

#### CBike::CBike

<pre>
plugin::CallMethod<0x615740, CBike *, int, unsigned char>(this, modelIndex, createdBy);
0AA6: call_method 0x615740 struct [CBike] num_params 2 pop 0 [modelIndex] [createdBy]
</pre>

#### CBike::CalculateLeanMatrix

<pre>
plugin::CallMethod<0x609C90, CBike *>(this);
0AA6: call_method 0x609C90 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::DoDriveByShootings

<pre>
plugin::CallMethod<0x5C91E0, CBike *>(this);
0AA6: call_method 0x5C91E0 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::Fix

<pre>
plugin::CallMethod<0x609F00, CBike *>(this);
0AA6: call_method 0x609F00 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::GetCorrectedWorldDoorPosition

<pre>
plugin::CallMethod<0x609720, CBike *, CVector&, CVector, CVector>(this, out, arg1, arg2);
0AA6: call_method 0x609720 struct [CBike] num_params 3 pop 0 [out] [arg1] [arg2]
</pre>

#### CBike::KnockOffRider

<pre>
plugin::CallMethodAndReturn<CPed*, 0x613920, CBike *, eWeaponType, unsigned char, CPed*, bool>(this, arg0, arg1, arg2, arg3);
0AA8: call_method_return 0x613920 struct [CBike] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3] func_ret [CPed*]
</pre>

#### CBike::PlayHornIfNecessary

<pre>
plugin::CallMethod<0x609E10, CBike *>(this);
0AA6: call_method 0x609E10 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::ProcessBuoyancy

<pre>
plugin::CallMethod<0x613540, CBike *>(this);
0AA6: call_method 0x613540 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::ReduceHornCounter

<pre>
plugin::CallMethod<0x613910, CBike *>(this);
0AA6: call_method 0x613910 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::SetupSuspensionLines

<pre>
plugin::CallMethod<0x615080, CBike *>(this);
0AA6: call_method 0x615080 struct [CBike] num_params 0 pop 0
</pre>

#### CBike::VehicleDamage

<pre>
plugin::CallMethod<0x614860, CBike *>(this);
0AA6: call_method 0x614860 struct [CBike] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CBoat.cpp

#### CBoat::AddWakePoint

<pre>
plugin::CallMethod<0x59F580, CBoat *, CVector>(this, posn);
0AA6: call_method 0x59F580 struct [CBoat] num_params 1 pop 0 [posn]
</pre>

#### CBoat::ApplyWaterResistance

<pre>
plugin::CallMethod<0x59FB30, CBoat *>(this);
0AA6: call_method 0x59FB30 struct [CBoat] num_params 0 pop 0
</pre>

#### CBoat::CBoat

<pre>
plugin::CallMethod<0x5A6470, CBoat *, int, unsigned char>(this, modelIndex, createdBy);
0AA6: call_method 0x5A6470 struct [CBoat] num_params 2 pop 0 [modelIndex] [createdBy]
</pre>

#### CBoat::DoDriveByShootings

<pre>
plugin::CallMethod<0x5C9540, CBoat *>(this);
0AA6: call_method 0x5C9540 struct [CBoat] num_params 0 pop 0
</pre>

#### CBoat::FillBoatList

<pre>
plugin::Call<0x59F360>();
0AA5: call_function 0x59F360 num_params 0 pop 0
</pre>

#### CBoat::PruneWakeTrail

<pre>
plugin::CallMethod<0x59F6F0, CBoat *>(this);
0AA6: call_method 0x59F6F0 struct [CBoat] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CBox.cpp

#### CBox::Set

<pre>
plugin::Call<0x410910, CVector const&, CVector const&>(vecMin, vecMax);
0AA5: call_function 0x410910 num_params 2 pop 2 [vecMin] [vecMax]
</pre>

### plugin_vc\game_vc\CBrightLights.cpp

#### CBrightLight::CBrightLight

<pre>
plugin::CallMethod<0x575140, CBrightLight *>(this);
0AA6: call_method 0x575140 struct [CBrightLight] num_params 0 pop 0
</pre>

#### CBrightLights::RegisterOne

<pre>
plugin::Call<0x571820, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(posn, right, up, at, red, green, blue, alpha);
0AA5: call_function 0x571820 num_params 8 pop 8 [posn] [right] [up] [at] [red] [green] [blue] [alpha]
</pre>

#### CBrightLights::Render

<pre>
plugin::Call<0x5719B0>();
0AA5: call_function 0x5719B0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CBulletInfo.cpp

#### CBulletInfo::AddBullet

<pre>
plugin::Call<0x5C47C0, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, position, velocity);
0AA5: call_function 0x5C47C0 num_params 4 pop 4 [creator] [weaponType] [position] [velocity]
</pre>

#### CBulletInfo::CBulletInfo

<pre>
plugin::CallMethod<0x5C4B10, CBulletInfo *>(this);
0AA6: call_method 0x5C4B10 struct [CBulletInfo] num_params 0 pop 0
</pre>

#### CBulletInfo::Initialise

<pre>
plugin::Call<0x5C48C0>();
0AA5: call_function 0x5C48C0 num_params 0 pop 0
</pre>

#### CBulletInfo::Shutdown

<pre>
plugin::Call<0x5C48A0>();
0AA5: call_function 0x5C48A0 num_params 0 pop 0
</pre>

#### CBulletInfo::TestForSniperBullet

<pre>
plugin::Call<0x5C3B20, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x5C3B20 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CBulletInfo::Update

<pre>
plugin::Call<0x5C3DE0>();
0AA5: call_function 0x5C3DE0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CBulletTraces.cpp

#### CBulletTraces::AddTrace

<pre>
plugin::CallDynGlobal<CVector *, CVector *, float, unsigned int, unsigned char>(gaddrof_o(CBulletTraces::AddTrace, void (*)(CVector *, CVector *, float, unsigned int, unsigned char)), origin, target, radius, time, transparency);
</pre>

#### CBulletTraces::AddTrace

<pre>
plugin::CallDynGlobal<CVector *, CVector *, int, CEntity *>(gaddrof_o(CBulletTraces::AddTrace, void (*)(CVector *, CVector *, int, CEntity *)), origin, target, weaponType, entity);
</pre>

### plugin_vc\game_vc\cBuoyancy.cpp

#### cBuoyancy::ProcessBuoyancy

<pre>
plugin::CallMethodAndReturn<bool, 0x5AAC90, cBuoyancy*, CPhysical *, float, CVector*, CVector*>(this, phys, buoyancy, point, impulse);
0AA8: call_method_return 0x5AAC90 struct [cBuoyancy] num_params 4 pop 0 [phys] [buoyancy] [point] [impulse] func_ret [bool]
</pre>

### plugin_vc\game_vc\CCamera.cpp

#### CCamera::AvoidTheGeometry

<pre>
plugin::CallMethod<0x473AA4, CCamera *, CVector const&, CVector const&, CVector&, float>(this, Vector1, Vector2, Vector3, arg4);
0AA6: call_method 0x473AA4 struct [CCamera] num_params 4 pop 0 [Vector1] [Vector2] [Vector3] [arg4]
</pre>

#### CCamera::CalculateDerivedValues

<pre>
plugin::CallMethod<0x46C3B6, CCamera *>(this);
0AA6: call_method 0x46C3B6 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::CamControl

<pre>
plugin::CallMethod<0x4700E7, CCamera *>(this);
0AA6: call_method 0x4700E7 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::CamShake

<pre>
plugin::CallMethod<0x46FF21, CCamera *, float, float, float, float>(this, arg1, x_coord, y_coord, z_coord);
0AA6: call_method 0x46FF21 struct [CCamera] num_params 4 pop 0 [arg1] [x_coord] [y_coord] [z_coord]
</pre>

#### CCamera::ClearPlayerWeaponMode

<pre>
plugin::CallMethod<0x46FE51, CCamera *>(this);
0AA6: call_method 0x46FE51 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::DeleteCutSceneCamDataMemory

<pre>
plugin::CallMethod<0x46FE25, CCamera *>(this);
0AA6: call_method 0x46FE25 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::DontProcessObbeCinemaCamera

<pre>
plugin::Call<0x46FE13>();
0AA5: call_function 0x46FE13 num_params 0 pop 0
</pre>

#### CCamera::DrawBordersForWideScreen

<pre>
plugin::CallMethod<0x46FC1C, CCamera *>(this);
0AA6: call_method 0x46FC1C struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Fade

<pre>
plugin::CallMethod<0x46FBCB, CCamera *, float, short>(this, timeToFade, FadingDirection);
0AA6: call_method 0x46FBCB struct [CCamera] num_params 2 pop 0 [timeToFade] [FadingDirection]
</pre>

#### CCamera::Find3rdPersonCamTargetVector

<pre>
plugin::CallMethodAndReturn<bool, 0x46F890, CCamera *, float, CVector, CVector&, CVector&>(this, arg1, vector1, vector2, vector3);
0AA8: call_method_return 0x46F890 struct [CCamera] num_params 4 pop 0 [arg1] [vector1] [vector2] [vector3] func_ret [bool]
</pre>

#### CCamera::Find3rdPersonQuickAimPitch

<pre>
plugin::CallMethodAndReturn<float, 0x46F7C6, CCamera *>(this);
0AA8: call_method_return 0x46F7C6 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::FinishCutscene

<pre>
plugin::CallMethod<0x46FB3C, CCamera *>(this);
0AA6: call_method 0x46FB3C struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::GetArrPosForVehicleType

<pre>
plugin::CallAndReturn<bool, 0x46F659, int, int&>(vehicleType, ArrPos);
0AA7: call_function_return 0x46F659 num_params 2 pop 2 [vehicleType] [ArrPos] func_ret [bool]
</pre>

#### CCamera::GetCutSceneFinishTime

<pre>
plugin::CallMethodAndReturn<int, 0x46F77E, CCamera *>(this);
0AA8: call_method_return 0x46F77E struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### CCamera::GetFading

<pre>
plugin::CallMethodAndReturn<bool, 0x46F777, CCamera *>(this);
0AA8: call_method_return 0x46F777 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetGameCamPosition

<pre>
plugin::CallMethodAndReturn<CVector*, 0x46F730, CCamera *>(this);
0AA8: call_method_return 0x46F730 struct [CCamera] num_params 0 pop 0 func_ret [CVector*]
</pre>

#### CCamera::GetLookDirection

<pre>
plugin::CallMethodAndReturn<int, 0x46F6CE, CCamera *>(this);
0AA8: call_method_return 0x46F6CE struct [CCamera] num_params 0 pop 0 func_ret [int]
</pre>

#### CCamera::GetLookingForwardFirstPerson

<pre>
plugin::CallMethodAndReturn<bool, 0x46F6A9, CCamera *>(this);
0AA8: call_method_return 0x46F6A9 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetLookingLRBFirstPerson

<pre>
plugin::CallMethodAndReturn<bool, 0x46F70B, CCamera *>(this);
0AA8: call_method_return 0x46F70B struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetPositionAlongSpline

<pre>
plugin::CallMethodAndReturn<float, 0x46F652, CCamera *>(this);
0AA8: call_method_return 0x46F652 struct [CCamera] num_params 0 pop 0 func_ret [float]
</pre>

#### CCamera::GetScreenFadeStatus

<pre>
plugin::CallMethodAndReturn<bool, 0x46F737, CCamera *>(this);
0AA8: call_method_return 0x46F737 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::GetScreenRect

<pre>
plugin::CallMethod<0x46FD5D, CCamera *, CRect&>(this, Rect);
0AA6: call_method 0x46FD5D struct [CCamera] num_params 1 pop 0 [Rect]
</pre>

#### CCamera::Get_Just_Switched_Status

<pre>
plugin::CallMethodAndReturn<bool, 0x46F773, CCamera *>(this);
0AA8: call_method_return 0x46F773 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCamera::Init

<pre>
plugin::CallMethod<0x46F108, CCamera *>(this);
0AA6: call_method 0x46F108 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::IsItTimeForNewcam

<pre>
plugin::CallMethodAndReturn<bool, 0x46E2C4, CCamera *, int, int>(this, arg1, timer);
0AA8: call_method_return 0x46E2C4 struct [CCamera] num_params 2 pop 0 [arg1] [timer] func_ret [bool]
</pre>

#### CCamera::LoadPathSplines

<pre>
plugin::Call<0x46E140, int>(FilePtr);
0AA5: call_function 0x46E140 num_params 1 pop 1 [FilePtr]
</pre>

#### CCamera::Process

<pre>
plugin::CallMethod<0x46C58C, CCamera *>(this);
0AA6: call_method 0x46C58C struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessFade

<pre>
plugin::CallMethod<0x46C278, CCamera *>(this);
0AA6: call_method 0x46C278 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessMusicFade

<pre>
plugin::CallMethod<0x46C10D, CCamera *>(this);
0AA6: call_method 0x46C10D struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraCar

<pre>
plugin::CallMethod<0x46BFEE, CCamera *>(this);
0AA6: call_method 0x46BFEE struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraHeli

<pre>
plugin::CallMethod<0x46BEE6, CCamera *>(this);
0AA6: call_method 0x46BEE6 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::ProcessObbeCinemaCameraPed

<pre>
plugin::CallMethod<0x46BE18, CCamera *>(this);
0AA6: call_method 0x46BE18 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RenderMotionBlur

<pre>
plugin::CallMethod<0x46BDE0, CCamera *>(this);
0AA6: call_method 0x46BDE0 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Restore

<pre>
plugin::CallMethod<0x46BC7D, CCamera *>(this);
0AA6: call_method 0x46BC7D struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::RestoreWithJumpCut

<pre>
plugin::CallMethod<0x46BB24, CCamera *>(this);
0AA6: call_method 0x46BB24 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetCamCutSceneOffSet

<pre>
plugin::CallMethod<0x46BB03, CCamera *, CVector const&>(this, vecCutSceneOffset);
0AA6: call_method 0x46BB03 struct [CCamera] num_params 1 pop 0 [vecCutSceneOffset]
</pre>

#### CCamera::SetCamPositionForFixedMode

<pre>
plugin::CallMethod<0x46BA72, CCamera *, CVector const&, CVector const&>(this, vecFixedModeSource, vecFixedModeUpOffSet);
0AA6: call_method 0x46BA72 struct [CCamera] num_params 2 pop 0 [vecFixedModeSource] [vecFixedModeUpOffSet]
</pre>

#### CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString

<pre>
plugin::CallMethod<0x46BADE, CCamera *>(this);
0AA6: call_method 0x46BADE struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString

<pre>
plugin::CallMethod<0x46BAB9, CCamera *>(this);
0AA6: call_method 0x46BAB9 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetFadeColour

<pre>
plugin::CallMethod<0x46BA35, CCamera *, unsigned char, unsigned char, unsigned char>(this, red, green, blue);
0AA6: call_method 0x46BA35 struct [CCamera] num_params 3 pop 0 [red] [green] [blue]
</pre>

#### CCamera::SetMotionBlur

<pre>
plugin::CallMethod<0x46BA00, CCamera *, int, int, int, int, int>(this, red, green, blue, motionblur, blurtype);
0AA6: call_method 0x46BA00 struct [CCamera] num_params 5 pop 0 [red] [green] [blue] [motionblur] [blurtype]
</pre>

#### CCamera::SetMotionBlurAlpha

<pre>
plugin::CallMethod<0x46B9F3, CCamera *, int>(this, alpha);
0AA6: call_method 0x46B9F3 struct [CCamera] num_params 1 pop 0 [alpha]
</pre>

#### CCamera::SetNearClipScript

<pre>
plugin::CallMethod<0x46B9E2, CCamera *, float>(this, fNearClipScript);
0AA6: call_method 0x46B9E2 struct [CCamera] num_params 1 pop 0 [fNearClipScript]
</pre>

#### CCamera::SetNewPlayerWeaponMode

<pre>
plugin::CallMethod<0x46B90D, CCamera *, short, short, short>(this, Mode, MinZoom, MaxZoom);
0AA6: call_method 0x46B90D struct [CCamera] num_params 3 pop 0 [Mode] [MinZoom] [MaxZoom]
</pre>

#### CCamera::SetParametersForScriptInterpolation

<pre>
plugin::CallMethod<0x46B8AE, CCamera *, float, float, unsigned int>(this, fScriptInterToStopMoving, fScriptInterToCatchUp, fScriptTimeForInterPolation);
0AA6: call_method 0x46B8AE struct [CCamera] num_params 3 pop 0 [fScriptInterToStopMoving] [fScriptInterToCatchUp] [fScriptTimeForInterPolation]
</pre>

#### CCamera::SetRwCamera

<pre>
plugin::CallMethod<0x46B87A, CCamera *, RwCamera*>(this, pRwCam);
0AA6: call_method 0x46B87A struct [CCamera] num_params 1 pop 0 [pRwCam]
</pre>

#### CCamera::SetWideScreenOff

<pre>
plugin::CallMethod<0x46B863, CCamera *>(this);
0AA6: call_method 0x46B863 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetWideScreenOn

<pre>
plugin::CallMethod<0x46B875, CCamera *>(this);
0AA6: call_method 0x46B875 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::SetZoomValueCamStringScript

<pre>
plugin::CallMethod<0x46B743, CCamera *, short>(this, mode);
0AA6: call_method 0x46B743 struct [CCamera] num_params 1 pop 0 [mode]
</pre>

#### CCamera::SetZoomValueFollowPedScript

<pre>
plugin::CallMethod<0x46B817, CCamera *, short>(this, mode);
0AA6: call_method 0x46B817 struct [CCamera] num_params 1 pop 0 [mode]
</pre>

#### CCamera::StartTransition

<pre>
plugin::CallMethod<0x46AB08, CCamera *, short>(this, mode);
0AA6: call_method 0x46AB08 struct [CCamera] num_params 1 pop 0 [mode]
</pre>

#### CCamera::StartTransitionWhenNotFinishedInter

<pre>
plugin::CallMethod<0x46AAF5, CCamera *, short>(this, mode);
0AA6: call_method 0x46AAF5 struct [CCamera] num_params 1 pop 0 [mode]
</pre>

#### CCamera::StoreValuesDuringInterPol

<pre>
plugin::CallMethod<0x46AA01, CCamera *, CVector&, CVector&, CVector&, float&>(this, _SourceDuringInter, _TargetDuringInter, _UpDuringInter, _FOVDuringInter);
0AA6: call_method 0x46AA01 struct [CCamera] num_params 4 pop 0 [_SourceDuringInter] [_TargetDuringInter] [_UpDuringInter] [_FOVDuringInter]
</pre>

#### CCamera::TakeControl

<pre>
plugin::CallMethod<0x46A4F8, CCamera *, CEntity*, short, short, int>(this, pEntity, mode, _TypeOfSwitch, _WhoIsInControlOfTheCamera);
0AA6: call_method 0x46A4F8 struct [CCamera] num_params 4 pop 0 [pEntity] [mode] [_TypeOfSwitch] [_WhoIsInControlOfTheCamera]
</pre>

#### CCamera::TakeControlNoEntity

<pre>
plugin::CallMethod<0x46A494, CCamera *, CVector const&, short, int>(this, vecFixedModeVector, _TypeOfSwitch, _WhoIsInControlOfTheCamera);
0AA6: call_method 0x46A494 struct [CCamera] num_params 3 pop 0 [vecFixedModeVector] [_TypeOfSwitch] [_WhoIsInControlOfTheCamera]
</pre>

#### CCamera::TakeControlWithSpline

<pre>
plugin::CallMethod<0x46A46A, CCamera *, short>(this, TypeOfSwitch);
0AA6: call_method 0x46A46A struct [CCamera] num_params 1 pop 0 [TypeOfSwitch]
</pre>

#### CCamera::TryToStartNewCamMode

<pre>
plugin::CallMethodAndReturn<bool, 0x467AAD, CCamera *, int>(this, mode);
0AA8: call_method_return 0x467AAD struct [CCamera] num_params 1 pop 0 [mode] func_ret [bool]
</pre>

#### CCamera::UpdateAimingCoors

<pre>
plugin::CallMethod<0x467A8C, CCamera *, CVector const&>(this, vecAimingTarget);
0AA6: call_method 0x467A8C struct [CCamera] num_params 1 pop 0 [vecAimingTarget]
</pre>

#### CCamera::UpdateSoundDistances

<pre>
plugin::CallMethod<0x46A885, CCamera *>(this);
0AA6: call_method 0x46A885 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::UpdateTargetEntity

<pre>
plugin::CallMethod<0x46A5A3, CCamera *>(this);
0AA6: call_method 0x46A5A3 struct [CCamera] num_params 0 pop 0
</pre>

#### CCamera::Using1stPersonWeaponMode

<pre>
plugin::CallMethodAndReturn<bool, 0x46B8E2, CCamera *>(this);
0AA8: call_method_return 0x46B8E2 struct [CCamera] num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_vc\game_vc\CCarAI.cpp

#### CCarAI::AddAmbulanceOccupants

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddAmbulanceOccupants), vehicle);
</pre>

#### CCarAI::AddFiretruckOccupants

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddFiretruckOccupants), vehicle);
</pre>

#### CCarAI::AddPoliceCarOccupants

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddPoliceCarOccupants), vehicle);
</pre>

#### CCarAI::CarHasReasonToStop

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::CarHasReasonToStop), vehicle);
</pre>

#### CCarAI::FindPoliceBoatMissionForWantedLevel

<pre>
plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceBoatMissionForWantedLevel));
</pre>

#### CCarAI::FindPoliceCarMissionForWantedLevel

<pre>
plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceCarMissionForWantedLevel));
</pre>

#### CCarAI::FindPoliceCarSpeedForWantedLevel

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CCarAI::FindPoliceCarSpeedForWantedLevel), vehicle);
</pre>

#### CCarAI::GetCarToGoToCoors

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToGoToCoors), vehicle, coors);
</pre>

#### CCarAI::GetCarToParkAtCoors

<pre>
plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToParkAtCoors), vehicle, coors);
</pre>

#### CCarAI::MakeWayForCarWithSiren

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MakeWayForCarWithSiren), vehicle);
</pre>

#### CCarAI::MellowOutChaseSpeed

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeed), vehicle);
</pre>

#### CCarAI::MellowOutChaseSpeedBoat

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeedBoat), vehicle);
</pre>

#### CCarAI::TellCarToRamOtherCar

<pre>
plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToRamOtherCar), vehicle, ramVehicle);
</pre>

#### CCarAI::TellOccupantsToFleeCar

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToFleeCar), vehicle);
</pre>

#### CCarAI::TellOccupantsToLeaveCar

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToLeaveCar), vehicle);
</pre>

#### CCarAI::UpdateCarAI

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::UpdateCarAI), vehicle);
</pre>

### plugin_vc\game_vc\CCarCtrl.cpp

#### CCarCtrl::AddToLoadedVehicleArray

<pre>
plugin::CallAndReturn<int, 0x4267D0, int, int, int>(arg0, arg1, arg2);
0AA7: call_function_return 0x4267D0 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [int]
</pre>

#### CCarCtrl::AddToVehicleArray

<pre>
plugin::CallAndReturn<int, 0x426820, int, int>(arg0, arg1);
0AA7: call_function_return 0x426820 num_params 2 pop 2 [arg0] [arg1] func_ret [int]
</pre>

#### CCarCtrl::ChooseCarModel

<pre>
plugin::CallAndReturn<int, 0x426AA0, int>(arg0);
0AA7: call_function_return 0x426AA0 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CCarCtrl::ChooseCarModelToLoad

<pre>
plugin::CallAndReturn<int, 0x426A30, int>(arg0);
0AA7: call_function_return 0x426A30 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CCarCtrl::ChooseCarRating

<pre>
plugin::CallAndReturn<int, 0x426D40, CZoneInfo*>(arg0);
0AA7: call_function_return 0x426D40 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CCarCtrl::ChooseModel

<pre>
plugin::CallAndReturn<int, 0x426B40, CZoneInfo*, int*>(arg0, arg1);
0AA7: call_function_return 0x426B40 num_params 2 pop 2 [arg0] [arg1] func_ret [int]
</pre>

#### CCarCtrl::ChoosePoliceCarModel

<pre>
plugin::CallAndReturn<int, 0x426850>();
0AA7: call_function_return 0x426850 num_params 0 pop 0 func_ret [int]
</pre>

#### CCarCtrl::ClearInterestingVehicleList

<pre>
plugin::Call<0x41D300>();
0AA5: call_function 0x41D300 num_params 0 pop 0
</pre>

#### CCarCtrl::DragCarToPoint

<pre>
plugin::Call<0x4208B0, CVehicle*, CVector*>(vehicle, coords);
0AA5: call_function 0x4208B0 num_params 2 pop 2 [vehicle] [coords]
</pre>

#### CCarCtrl::FindAngleToWeaveThroughTraffic

<pre>
plugin::CallAndReturn<float, 0x423C00, CVehicle*, CPhysical*, float, float>(vehicle, physical, arg2, arg3);
0AA7: call_function_return 0x423C00 num_params 4 pop 4 [vehicle] [physical] [arg2] [arg3] func_ret [float]
</pre>

#### CCarCtrl::FindLinksToGoWithTheseNodes

<pre>
plugin::CallAndReturn<int, 0x41CC20, CVehicle*>(vehicle);
0AA7: call_function_return 0x41CC20 num_params 1 pop 1 [vehicle] func_ret [int]
</pre>

#### CCarCtrl::FindMaximumSpeedForThisCarInTraffic

<pre>
plugin::CallAndReturn<float, 0x425880, CVehicle*>(vehicle);
0AA7: call_function_return 0x425880 num_params 1 pop 1 [vehicle] func_ret [float]
</pre>

#### CCarCtrl::FindPathDirection

<pre>
plugin::CallAndReturn<char, 0x421DC0, int, int, int>(arg0, arg1, arg2);
0AA7: call_function_return 0x421DC0 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [char]
</pre>

#### CCarCtrl::GenerateEmergencyServicesCar

<pre>
plugin::Call<0x41C940>();
0AA5: call_function 0x41C940 num_params 0 pop 0
</pre>

#### CCarCtrl::GenerateOneEmergencyServicesCar

<pre>
plugin::CallAndReturn<bool, 0x41C460, unsigned int, CVector>(model, driveToCoord);
0AA7: call_function_return 0x41C460 num_params 2 pop 2 [model] [driveToCoord] func_ret [bool]
</pre>

#### CCarCtrl::GenerateOneRandomCar

<pre>
plugin::Call<0x426DB0>();
0AA5: call_function 0x426DB0 num_params 0 pop 0
</pre>

#### CCarCtrl::GenerateRandomCars

<pre>
plugin::Call<0x4292A0>();
0AA5: call_function 0x4292A0 num_params 0 pop 0
</pre>

#### CCarCtrl::Init

<pre>
plugin::Call<0x4293D0>();
0AA5: call_function 0x4293D0 num_params 0 pop 0
</pre>

#### CCarCtrl::IsThisVehicleInteresting

<pre>
plugin::CallAndReturn<bool, 0x41D350, CVehicle*>(vehicle);
0AA7: call_function_return 0x41D350 num_params 1 pop 1 [vehicle] func_ret [bool]
</pre>

#### CCarCtrl::JoinCarWithRoadSystem

<pre>
plugin::Call<0x41D000, CVehicle*>(vehicle);
0AA5: call_function 0x41D000 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::JoinCarWithRoadSystemGotoCoors

<pre>
plugin::CallAndReturn<bool, 0x41CEB0, CVehicle*, CVector, bool>(vehicle, arg1, arg2);
0AA7: call_function_return 0x41CEB0 num_params 3 pop 3 [vehicle] [arg1] [arg2] func_ret [bool]
</pre>

#### CCarCtrl::MapCouldMoveInThisArea

<pre>
plugin::CallAndReturn<bool, 0x41C2F0, float, float>(arg0, arg1);
0AA7: call_function_return 0x41C2F0 num_params 2 pop 2 [arg0] [arg1] func_ret [bool]
</pre>

#### CCarCtrl::PickNextNodeAccordingStrategy

<pre>
plugin::CallAndReturn<char, 0x422A10, CVehicle*>(vehicle);
0AA7: call_function_return 0x422A10 num_params 1 pop 1 [vehicle] func_ret [char]
</pre>

#### CCarCtrl::PickNextNodeRandomly

<pre>
plugin::CallAndReturn<int, 0x421F70, CVehicle*>(vehicle);
0AA7: call_function_return 0x421F70 num_params 1 pop 1 [vehicle] func_ret [int]
</pre>

#### CCarCtrl::PickNextNodeToChaseCar

<pre>
plugin::CallAndReturn<int, 0x4213A0, CVehicle*, float, float, CVehicle*>(vehicle, arg1, arg2, arg3);
0AA7: call_function_return 0x4213A0 num_params 4 pop 4 [vehicle] [arg1] [arg2] [arg3] func_ret [int]
</pre>

#### CCarCtrl::PickNextNodeToFollowPath

<pre>
plugin::CallAndReturn<bool, 0x420D50, CVehicle*>(vehicle);
0AA7: call_function_return 0x420D50 num_params 1 pop 1 [vehicle] func_ret [bool]
</pre>

#### CCarCtrl::PossiblyRemoveVehicle

<pre>
plugin::Call<0x426030, CVehicle*>(vehicle);
0AA5: call_function 0x426030 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::ReInit

<pre>
plugin::Call<0x429320>();
0AA5: call_function 0x429320 num_params 0 pop 0
</pre>

#### CCarCtrl::RegisterVehicleOfInterest

<pre>
plugin::Call<0x41D370, CVehicle*>(vehicle);
0AA5: call_function 0x41D370 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::RemoveCarsIfThePoolGetsFull

<pre>
plugin::Call<0x4264C0>();
0AA5: call_function 0x4264C0 num_params 0 pop 0
</pre>

#### CCarCtrl::RemoveDistantCars

<pre>
plugin::Call<0x426640>();
0AA5: call_function 0x426640 num_params 0 pop 0
</pre>

#### CCarCtrl::RemoveFromInterestingVehicleList

<pre>
plugin::Call<0x41D320, CVehicle*>(vehicle);
0AA5: call_function 0x41D320 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::RemoveFromLoadedVehicleArray

<pre>
plugin::Call<0x426740, int, int>(arg0, arg1);
0AA5: call_function 0x426740 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CCarCtrl::ScanForPedDanger

<pre>
plugin::Call<0x4255E0, CVehicle*>(vehicle);
0AA5: call_function 0x4255E0 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::SlowCarDownForCarsSectorList

<pre>
plugin::Call<0x424B50, CPtrList&, CVehicle*, float, float, float, float, float*, float>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);
0AA5: call_function 0x424B50 num_params 8 pop 8 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]
</pre>

#### CCarCtrl::SlowCarDownForOtherCar

<pre>
plugin::Call<0x424780, CEntity*, CVehicle*, float*, float>(entity, vehicle, arg2, arg3);
0AA5: call_function 0x424780 num_params 4 pop 4 [entity] [vehicle] [arg2] [arg3]
</pre>

#### CCarCtrl::SlowCarDownForPedsSectorList

<pre>
plugin::Call<0x424C70, CPtrList&, CVehicle*, float, float, float, float, float*, float>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);
0AA5: call_function 0x424C70 num_params 8 pop 8 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]
</pre>

#### CCarCtrl::SlowCarOnRailsDownForTrafficAndLights

<pre>
plugin::Call<0x4254C0, CVehicle*>(vehicle);
0AA5: call_function 0x4254C0 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer

<pre>
plugin::Call<0x41DFA0, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
0AA5: call_function 0x41DFA0 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget

<pre>
plugin::Call<0x41E2D0, CVehicle*, float, float, float*, float*, float*>(vehicle, arg1, arg2, arg3, arg4, arg5);
0AA5: call_function 0x41E2D0 num_params 6 pop 6 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CCarCtrl::SteerAICarBlockingPlayerForwardAndBack

<pre>
plugin::Call<0x41E520, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
0AA5: call_function 0x41E520 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CCarCtrl::SteerAICarWithPhysics

<pre>
plugin::Call<0x420580, CVehicle*>(vehicle);
0AA5: call_function 0x420580 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsFollowPath

<pre>
plugin::Call<0x41EEE0, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
0AA5: call_function 0x41EEE0 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsHeadingForTarget

<pre>
plugin::Call<0x41EAB0, CVehicle*, CPhysical*, float, float, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0AA5: call_function 0x41EAB0 num_params 8 pop 8 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]
</pre>

#### CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop

<pre>
plugin::Call<0x41E830, CVehicle*, float, float, float, float, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x41E830 num_params 9 pop 9 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::SteerAICarWithPhysics_OnlyMission

<pre>
plugin::Call<0x41FD10, CVehicle*, float*, float*, float*, bool*>(vehicle, arg1, arg2, arg3, arg4);
0AA5: call_function 0x41FD10 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CCarCtrl::SteerAIHeliTowardsTargetCoors

<pre>
plugin::Call<0x41D900, CAutomobile*>(automobile);
0AA5: call_function 0x41D900 num_params 1 pop 1 [automobile]
</pre>

#### CCarCtrl::SteerAIPlaneTowardsTargetCoors

<pre>
plugin::Call<0x41D410, CAutomobile*>(automobile);
0AA5: call_function 0x41D410 num_params 1 pop 1 [automobile]
</pre>

#### CCarCtrl::SwitchVehicleToRealPhysics

<pre>
plugin::Call<0x41D2D0, CVehicle*>(vehicle);
0AA5: call_function 0x41D2D0 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::TestCollisionBetween2MovingRects

<pre>
plugin::CallAndReturn<float, 0x424210, CVehicle*, CVehicle*, float, float, CVector*, CVector*, unsigned char>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6);
0AA7: call_function_return 0x424210 num_params 7 pop 7 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] func_ret [float]
</pre>

#### CCarCtrl::UpdateCarCount

<pre>
plugin::Call<0x41C350, CVehicle*, unsigned char>(vehicle, arg1);
0AA5: call_function 0x41C350 num_params 2 pop 2 [vehicle] [arg1]
</pre>

#### CCarCtrl::UpdateCarOnRails

<pre>
plugin::Call<0x425BF0, CVehicle*>(vehicle);
0AA5: call_function 0x425BF0 num_params 1 pop 1 [vehicle]
</pre>

#### CCarCtrl::WeaveThroughCarsSectorList

<pre>
plugin::Call<0x423490, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x423490 num_params 9 pop 9 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CCarCtrl::WeaveThroughObjectsSectorList

<pre>
plugin::Call<0x422B00, CPtrList&, CVehicle*, float, float, float, float, float*, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);
0AA5: call_function 0x422B00 num_params 8 pop 8 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]
</pre>

#### CCarCtrl::WeaveThroughPedsSectorList

<pre>
plugin::Call<0x4230F0, CPtrList&, CVehicle*, CPhysical*, float, float, float, float, float*, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x4230F0 num_params 9 pop 9 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

### plugin_vc\game_vc\CCarGenerator.cpp

#### CCarGenerator::CheckForBlockage

<pre>
plugin::CallMethodAndReturn<bool, 0x5A6FC0, CCarGenerator *, int>(this, modelId);
0AA8: call_method_return 0x5A6FC0 struct [CCarGenerator] num_params 1 pop 0 [modelId] func_ret [bool]
</pre>

#### CCarGenerator::CheckIfWithinRangeOfAnyPlayers

<pre>
plugin::CallMethodAndReturn<bool, 0x5A6D00, CCarGenerator *>(this);
0AA8: call_method_return 0x5A6D00 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]
</pre>

#### CCarGenerator::DoInternalProcessing

<pre>
plugin::CallMethod<0x5A71C0, CCarGenerator *>(this);
0AA6: call_method 0x5A71C0 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::Process

<pre>
plugin::CallMethod<0x5A7130, CCarGenerator *>(this);
0AA6: call_method 0x5A7130 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::Setup

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A70B0, CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(this, x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay);
0AA8: call_method_return 0x5A70B0 struct [CCarGenerator] num_params 12 pop 0 [x] [y] [z] [angle] [modelId] [primaryColor] [secondaryColor] [forceSpawn] [alarm] [doorLock] [minDelay] [maxDelay] func_ret [unsigned int]
</pre>

#### CCarGenerator::SwitchOff

<pre>
plugin::CallMethod<0x5A7670, CCarGenerator *>(this);
0AA6: call_method 0x5A7670 struct [CCarGenerator] num_params 0 pop 0
</pre>

#### CCarGenerator::SwitchOn

<pre>
plugin::CallMethod<0x5A7650, CCarGenerator *>(this);
0AA6: call_method 0x5A7650 struct [CCarGenerator] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CCivilianPed.cpp

#### CCivilianPed::CCivilianPed

<pre>
plugin::CallMethod<0x4EAE00, CCivilianPed *, ePedType, unsigned int>(this, pedType, modelIndex);
0AA6: call_method 0x4EAE00 struct [CCivilianPed] num_params 2 pop 0 [pedType] [modelIndex]
</pre>

#### CCivilianPed::CivilianAI

<pre>
plugin::CallMethod<0x4E8E20, CCivilianPed *>(this);
0AA6: call_method 0x4E8E20 struct [CCivilianPed] num_params 0 pop 0
</pre>

#### CCivilianPed::EnterVacantNearbyCars

<pre>
plugin::CallMethod<0x4E99C0, CCivilianPed *>(this);
0AA6: call_method 0x4E99C0 struct [CCivilianPed] num_params 0 pop 0
</pre>

#### CCivilianPed::UseNearbyAttractors

<pre>
plugin::CallMethod<0x4E9E90, CCivilianPed *>(this);
0AA6: call_method 0x4E9E90 struct [CCivilianPed] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CClock.cpp

#### CClock::GetGameClockMinutesUntil

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);
</pre>

#### CClock::GetIsTimeInRange

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);
</pre>

#### CClock::Initialise

<pre>
plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);
</pre>

#### CClock::SetGameClock

<pre>
plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes);
</pre>

### plugin_vc\game_vc\CClouds.cpp

#### CClouds::Init

<pre>
plugin::Call<0x540FB0>();
0AA5: call_function 0x540FB0 num_params 0 pop 0
</pre>

#### CClouds::Render

<pre>
plugin::Call<0x53FC50>();
0AA5: call_function 0x53FC50 num_params 0 pop 0
</pre>

#### CClouds::RenderBackground

<pre>
plugin::Call<0x53F650, short, short, short, short, short, short, short>(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
0AA5: call_function 0x53F650 num_params 7 pop 7 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6]
</pre>

#### CClouds::RenderHorizon

<pre>
plugin::Call<0x53F380>();
0AA5: call_function 0x53F380 num_params 0 pop 0
</pre>

#### CClouds::Shutdown

<pre>
plugin::Call<0x540F40>();
0AA5: call_function 0x540F40 num_params 0 pop 0
</pre>

#### CClouds::Update

<pre>
plugin::Call<0x540E90>();
0AA5: call_function 0x540E90 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CClumpModelInfo.cpp

#### CClumpModelInfo::SetClump

<pre>
plugin::CallVirtualMethod<9, CClumpModelInfo *, RpClump*>(this, clump);
</pre>

#### CClumpModelInfo::CClumpModelInfo

<pre>
plugin::CallMethod<0x5601C0, CClumpModelInfo *>(this);
0AA6: call_method 0x5601C0 struct [CClumpModelInfo] num_params 0 pop 0
</pre>

#### CClumpModelInfo::FillFrameArray

<pre>
plugin::Call<0x541100, RpClump*, RwFrame**>(clump, frames);
0AA5: call_function 0x541100 num_params 2 pop 2 [clump] [frames]
</pre>

#### CClumpModelInfo::FindFrameFromIdCB

<pre>
plugin::CallAndReturn<RwFrame*, 0x541160, RwFrame*, void*>(frame, searchData);
0AA7: call_function_return 0x541160 num_params 2 pop 2 [frame] [searchData] func_ret [RwFrame*]
</pre>

#### CClumpModelInfo::FindFrameFromNameCB

<pre>
plugin::CallAndReturn<RwFrame*, 0x5411E0, RwFrame*, void*>(frame, searchData);
0AA7: call_function_return 0x5411E0 num_params 2 pop 2 [frame] [searchData] func_ret [RwFrame*]
</pre>

#### CClumpModelInfo::FindFrameFromNameWithoutIdCB

<pre>
plugin::CallAndReturn<RwFrame*, 0x541190, RwFrame*, void*>(frame, searchData);
0AA7: call_function_return 0x541190 num_params 2 pop 2 [frame] [searchData] func_ret [RwFrame*]
</pre>

#### CClumpModelInfo::GetFrameFromId

<pre>
plugin::CallAndReturn<RwFrame*, 0x541120, RpClump*, int>(clump, id);
0AA7: call_function_return 0x541120 num_params 2 pop 2 [clump] [id] func_ret [RwFrame*]
</pre>

#### CClumpModelInfo::SetAtomicRendererCB

<pre>
plugin::Call<0x5412A0, RpAtomic*, void*>(atomic, renderFunc);
0AA5: call_function 0x5412A0 num_params 2 pop 2 [atomic] [renderFunc]
</pre>

#### CClumpModelInfo::SetFrameIds

<pre>
plugin::CallMethod<0x541090, CClumpModelInfo *, RwObjectNameIdAssocation*>(this, data);
0AA6: call_method 0x541090 struct [CClumpModelInfo] num_params 1 pop 0 [data]
</pre>

#### ClumpModelStore::~ClumpModelStore

<pre>
plugin::CallMethod<0x560190, ClumpModelStore *>(this);
0AA6: call_method 0x560190 struct [ClumpModelStore] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CColBox.cpp

#### CColBox::Set

<pre>
plugin::CallMethod<0x4108D0, CColBox *, CVector const&, CVector const&, unsigned char, unsigned char>(this, sup, inf, material, flags);
0AA6: call_method 0x4108D0 struct [CColBox] num_params 4 pop 0 [sup] [inf] [material] [flags]
</pre>

#### CColBox::operator=

<pre>
plugin::CallMethod<0x410890, CColBox *, CColBox const&>(this, right);
0AA6: call_method 0x410890 struct [CColBox] num_params 1 pop 0 [right]
</pre>

### plugin_vc\game_vc\CColLine.cpp

#### CColLine::CColLine

<pre>
plugin::CallMethod<0x410940, CColLine *, CVector const&, CVector const&>(this, start, end);
0AA6: call_method 0x410940 struct [CColLine] num_params 2 pop 0 [start] [end]
</pre>

### plugin_vc\game_vc\CColModel.cpp

#### CColModel::CColModel

<pre>
plugin::CallMethod<0x417120, CColModel *>(this);
0AA6: call_method 0x417120 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::CalculateTrianglePlanes

<pre>
plugin::CallMethod<0x416AE0, CColModel *>(this);
0AA6: call_method 0x416AE0 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::GetLinkPtr

<pre>
plugin::CallMethodAndReturn<int, 0x416A70, CColModel *>(this);
0AA8: call_method_return 0x416A70 struct [CColModel] num_params 0 pop 0 func_ret [int]
</pre>

#### CColModel::GetTrianglePoint

<pre>
plugin::CallMethodAndReturn<int, 0x416B40, CColModel *, CVector&, int>(this, arg0, arg1);
0AA8: call_method_return 0x416B40 struct [CColModel] num_params 2 pop 0 [arg0] [arg1] func_ret [int]
</pre>

#### CColModel::RemoveCollisionVolumes

<pre>
plugin::CallMethod<0x4169B0, CColModel *>(this);
0AA6: call_method 0x4169B0 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::RemoveTrianglePlanes

<pre>
plugin::CallMethod<0x416AB0, CColModel *>(this);
0AA6: call_method 0x416AB0 struct [CColModel] num_params 0 pop 0
</pre>

#### CColModel::operator delete

<pre>
plugin::Call<0x4170E0, void*>(data);
0AA5: call_function 0x4170E0 num_params 1 pop 1 [data]
</pre>

#### CColModel::operator new

<pre>
plugin::CallAndReturn<void*, 0x417100, unsigned int>(size);
0AA7: call_function_return 0x417100 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CColModel::operator=

<pre>
plugin::CallMethod<0x416B80, CColModel *, CColModel const&>(this, arg0);
0AA6: call_method 0x416B80 struct [CColModel] num_params 1 pop 0 [arg0]
</pre>

### plugin_vc\game_vc\CColSphere.cpp

#### CColSphere::IntersectRay

<pre>
plugin::CallMethodAndReturn<bool, 0x417260, CColSphere *, CVector const&, CVector const&, CVector&, CVector&>(this, rayStart, rayEnd, intPoint1, intPoint2);
0AA8: call_method_return 0x417260 struct [CColSphere] num_params 4 pop 0 [rayStart] [rayEnd] [intPoint1] [intPoint2] func_ret [bool]
</pre>

#### CColSphere::Set

<pre>
plugin::CallMethod<0x4173A0, CColSphere *, float, CVector const&, unsigned char, unsigned char>(this, radius, center, material, flags);
0AA6: call_method 0x4173A0 struct [CColSphere] num_params 4 pop 0 [radius] [center] [material] [flags]
</pre>

### plugin_vc\game_vc\CControllerState.cpp

#### CControllerState::CheckForInput

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CControllerState *>(gaddrof(CControllerState::CheckForInput), this);
0AA8: call_method_return 0x4AE470 struct [CControllerState] num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_vc\game_vc\CCopPed.cpp

#### CCopPed::ArrestPlayer

<pre>
plugin::CallMethod<0x4EB470, CCopPed *>(this);
0AA6: call_method 0x4EB470 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::CCopPed

<pre>
plugin::CallMethod<0x4ED720, CCopPed *, eCopType, int>(this, copType, arg1);
0AA6: call_method 0x4ED720 struct [CCopPed] num_params 2 pop 0 [copType] [arg1]
</pre>

#### CCopPed::ClearPursuit

<pre>
plugin::CallMethod<0x4EB770, CCopPed *>(this);
0AA6: call_method 0x4EB770 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::CopAI

<pre>
plugin::CallMethod<0x4EBC10, CCopPed *>(this);
0AA6: call_method 0x4EBC10 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::ProcessHeliSwat

<pre>
plugin::CallMethod<0x4EB280, CCopPed *>(this);
0AA6: call_method 0x4EB280 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::ProcessStingerCop

<pre>
plugin::CallMethod<0x4EB010, CCopPed *>(this);
0AA6: call_method 0x4EB010 struct [CCopPed] num_params 0 pop 0
</pre>

#### CCopPed::ScanForCrimes

<pre>
plugin::CallMethodAndReturn<int, 0x4EBAD0, CCopPed *>(this);
0AA8: call_method_return 0x4EBAD0 struct [CCopPed] num_params 0 pop 0 func_ret [int]
</pre>

#### CCopPed::SetArrestPlayer

<pre>
plugin::CallMethod<0x4EB5F0, CCopPed *, CPed*>(this, ped);
0AA6: call_method 0x4EB5F0 struct [CCopPed] num_params 1 pop 0 [ped]
</pre>

#### CCopPed::SetPursuit

<pre>
plugin::CallMethod<0x4EB9C0, CCopPed *, bool>(this, arg0);
0AA6: call_method 0x4EB9C0 struct [CCopPed] num_params 1 pop 0 [arg0]
</pre>

### plugin_vc\game_vc\CCoronas.cpp

#### CCoronas::DoSunAndMoon

<pre>
plugin::Call<0x542210>();
0AA5: call_function 0x542210 num_params 0 pop 0
</pre>

#### CCoronas::UpdateCoronaCoors

<pre>
plugin::Call<0x5423E0, unsigned int, CVector const&, float, float>(id, posn, farClip, angle);
0AA5: call_function 0x5423E0 num_params 4 pop 4 [id] [posn] [farClip] [angle]
</pre>

#### CCoronas::RegisterCorona

<pre>
plugin::Call<0x542490, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, RwTexture*, unsigned char, unsigned char, unsigned char, unsigned char, float, bool, float>(coronaId, red, green, blue, alpha, pos, radius, farClip, texture, flare, reflection, arg11, arg12, normalAngle, arg14, arg15);
0AA5: call_function 0x542490 num_params 16 pop 16 [coronaId] [red] [green] [blue] [alpha] [pos] [radius] [farClip] [texture] [flare] [reflection] [arg11] [arg12] [normalAngle] [arg14] [arg15]
</pre>

#### CCoronas::RegisterCorona

<pre>
plugin::Call<0x5427A0, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float, bool, float>(coronaId, red, green, blue, alpha, pos, radius, farClip, arg8, flare, reflection, arg11, arg12, normalAngle, arg14, arg15);
0AA5: call_function 0x5427A0 num_params 16 pop 16 [coronaId] [red] [green] [blue] [alpha] [pos] [radius] [farClip] [arg8] [flare] [reflection] [arg11] [arg12] [normalAngle] [arg14] [arg15]
</pre>

#### CCoronas::Shutdown

<pre>
plugin::Call<0x542800>();
0AA5: call_function 0x542800 num_params 0 pop 0
</pre>

#### CCoronas::Init

<pre>
plugin::Call<0x542830>();
0AA5: call_function 0x542830 num_params 0 pop 0
</pre>

#### CCoronas::RenderSunReflection

<pre>
plugin::Call<0x542970>();
0AA5: call_function 0x542970 num_params 0 pop 0
</pre>

#### CCoronas::RenderReflections

<pre>
plugin::Call<0x542FF0>();
0AA5: call_function 0x542FF0 num_params 0 pop 0
</pre>

#### CCoronas::Render

<pre>
plugin::Call<0x543500>();
0AA5: call_function 0x543500 num_params 0 pop 0
</pre>

#### CCoronas::Update

<pre>
plugin::Call<0x544130>();
0AA5: call_function 0x544130 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CCranes.cpp

#### CCranes::AddThisOneCrane

<pre>
plugin::CallAndReturnDynGlobal<int, CEntity *>(gaddrof(CCranes::AddThisOneCrane), pEnity);
</pre>

#### CCranes::DoesMilitaryCraneHaveThisOneAlready

<pre>
plugin::CallAndReturnDynGlobal<bool, unsigned short>(gaddrof(CCranes::DoesMilitaryCraneHaveThisOneAlready), arg1);
</pre>

#### CCranes::IsThisCarBeingCarriedByAnyCrane

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingCarriedByAnyCrane), pVehicle);
</pre>

#### CCranes::IsThisCarBeingTargettedByAnyCrane

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingTargettedByAnyCrane), pVehicle);
</pre>

#### CCranes::RegisterCarForMilitaryCrane

<pre>
plugin::CallDynGlobal<unsigned short>(gaddrof(CCranes::RegisterCarForMilitaryCrane), arg1);
</pre>

### plugin_vc\game_vc\CCutsceneObject.cpp

#### CCutsceneObject::CCutsceneObject

<pre>
plugin::CallMethod<0x4E04D0, CCutsceneObject *>(this);
0AA6: call_method 0x4E04D0 struct [CCutsceneObject] num_params 0 pop 0
</pre>

#### CCutsceneObject::CreateShadow

<pre>
plugin::CallMethod<0x4E03E0, CCutsceneObject *>(this);
0AA6: call_method 0x4E03E0 struct [CCutsceneObject] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CCutsceneShadow.cpp

#### CCutsceneShadow::Create

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCutsceneShadow *, RwObject *, int, bool, int, bool>(gaddrof(CCutsceneShadow::Create), this, object, rasterSize, resample, blurPasses, gradient);
0AA8: call_method_return 0x625E60 struct [CCutsceneShadow] num_params 5 pop 0 [object] [rasterSize] [resample] [blurPasses] [gradient] func_ret [bool]
</pre>

#### CCutsceneShadow::DrawBorderAroundTexture

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *, RwRGBA const &>(gaddrof(CCutsceneShadow::DrawBorderAroundTexture), this, color);
0AA6: call_method 0x625B60 struct [CCutsceneShadow] num_params 1 pop 0 [color]
</pre>

#### \*CCutsceneShadow::GetShadowCamera

<pre>
plugin::CallMethodAndReturnDynGlobal<CShadowCamera *, CCutsceneShadow *, int>(gaddrof(CCutsceneShadow::GetShadowCamera), this, camType);
0AA8: call_method_return 0x625D50 struct [*CCutsceneShadow] num_params 1 pop 0 [camType] func_ret [CShadowCamera *]
</pre>

#### \*CCutsceneShadow::GetShadowRwTexture

<pre>
plugin::CallMethodAndReturnDynGlobal<RwTexture *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::GetShadowRwTexture), this);
0AA8: call_method_return 0x625B80 struct [*CCutsceneShadow] num_params 0 pop 0 func_ret [RwTexture *]
</pre>

#### CCutsceneShadow::IsInitialized

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CCutsceneShadow *>(gaddrof(CCutsceneShadow::IsInitialized), this);
0AA8: call_method_return 0x625D80 struct [CCutsceneShadow] num_params 0 pop 0 func_ret [bool]
</pre>

#### \*CCutsceneShadow::SetLightProperties

<pre>
plugin::CallMethodAndReturnDynGlobal<RwFrame *, CCutsceneShadow *, float, float, bool>(gaddrof(CCutsceneShadow::SetLightProperties), this, angleY, angleX, setLight);
0AA8: call_method_return 0x625D90 struct [*CCutsceneShadow] num_params 3 pop 0 [angleY] [angleX] [setLight] func_ret [RwFrame *]
</pre>

#### \*CCutsceneShadow::Update

<pre>
plugin::CallMethodAndReturnDynGlobal<RwRaster *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::Update), this);
0AA8: call_method_return 0x625BC0 struct [*CCutsceneShadow] num_params 0 pop 0 func_ret [RwRaster *]
</pre>

#### \*CCutsceneShadow::UpdateForCutscene

<pre>
plugin::CallMethodAndReturnDynGlobal<RwTexture *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::UpdateForCutscene), this);
0AA8: call_method_return 0x625BA0 struct [*CCutsceneShadow] num_params 0 pop 0 func_ret [RwTexture *]
</pre>

### plugin_vc\game_vc\CDamageManager.cpp

#### CDamageManager::ApplyDamage

<pre>
plugin::CallMethodAndReturn<bool, 0x5A9650, CDamageManager *, tComponent, float, float>(this, component, intensity, arg2);
0AA8: call_method_return 0x5A9650 struct [CDamageManager] num_params 3 pop 0 [component] [intensity] [arg2] func_ret [bool]
</pre>

#### CDamageManager::FuckCarCompletely

<pre>
plugin::CallMethod<0x5A9600, CDamageManager *>(this);
0AA6: call_method 0x5A9600 struct [CDamageManager] num_params 0 pop 0
</pre>

#### CDamageManager::GetComponentGroup

<pre>
plugin::CallMethodAndReturn<bool, 0x5A98D0, CDamageManager *, tComponent, tComponentGroup*, unsigned char*>(this, component, group, damageCompId);
0AA8: call_method_return 0x5A98D0 struct [CDamageManager] num_params 3 pop 0 [component] [group] [damageCompId] func_ret [bool]
</pre>

#### CDamageManager::GetDoorStatus

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A9810, CDamageManager *, eDoors>(this, door);
0AA8: call_method_return 0x5A9810 struct [CDamageManager] num_params 1 pop 0 [door] func_ret [unsigned int]
</pre>

#### CDamageManager::GetEngineStatus

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A97E0, CDamageManager *>(this);
0AA8: call_method_return 0x5A97E0 struct [CDamageManager] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CDamageManager::GetLightStatus

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A9870, CDamageManager *, eLights>(this, light);
0AA8: call_method_return 0x5A9870 struct [CDamageManager] num_params 1 pop 0 [light] func_ret [unsigned int]
</pre>

#### CDamageManager::GetPanelStatus

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A9850, CDamageManager *, ePanels>(this, panel);
0AA8: call_method_return 0x5A9850 struct [CDamageManager] num_params 1 pop 0 [panel] func_ret [unsigned int]
</pre>

#### CDamageManager::GetWheelStatus

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x5A9830, CDamageManager *, int>(this, wheel);
0AA8: call_method_return 0x5A9830 struct [CDamageManager] num_params 1 pop 0 [wheel] func_ret [unsigned int]
</pre>

#### CDamageManager::ProgressPanelDamage

<pre>
plugin::CallMethodAndReturn<bool, 0x5A9790, CDamageManager *, unsigned char>(this, panel);
0AA8: call_method_return 0x5A9790 struct [CDamageManager] num_params 1 pop 0 [panel] func_ret [bool]
</pre>

#### CDamageManager::ResetDamageStatus

<pre>
plugin::CallMethod<0x5A9890, CDamageManager *>(this);
0AA6: call_method 0x5A9890 struct [CDamageManager] num_params 0 pop 0
</pre>

#### CDamageManager::SetDoorStatus

<pre>
plugin::CallMethod<0x5A9820, CDamageManager *, eDoors, unsigned int>(this, door, status);
0AA6: call_method 0x5A9820 struct [CDamageManager] num_params 2 pop 0 [door] [status]
</pre>

#### CDamageManager::SetEngineStatus

<pre>
plugin::CallMethod<0x5A97F0, CDamageManager *, unsigned int>(this, status);
0AA6: call_method 0x5A97F0 struct [CDamageManager] num_params 1 pop 0 [status]
</pre>

#### CDamageManager::SetWheelStatus

<pre>
plugin::CallMethod<0x5A9840, CDamageManager *, int, unsigned int>(this, wheel, status);
0AA6: call_method 0x5A9840 struct [CDamageManager] num_params 2 pop 0 [wheel] [status]
</pre>

### plugin_vc\game_vc\CDarkel.cpp

#### CDarkel::DealWithWeaponChangeAtEndOfFrenzy

<pre>
plugin::Call<0x429910>();
0AA5: call_function 0x429910 num_params 0 pop 0
</pre>

#### CDarkel::DrawMessages

<pre>
plugin::Call<0x429FE0>();
0AA5: call_function 0x429FE0 num_params 0 pop 0
</pre>

#### CDarkel::FrenzyOnGoing

<pre>
plugin::CallAndReturn<bool, 0x429FC0>();
0AA7: call_function_return 0x429FC0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CDarkel::Init

<pre>
plugin::Call<0x42A7A0>();
0AA5: call_function 0x42A7A0 num_params 0 pop 0
</pre>

#### CDarkel::QueryModelsKilledByPlayer

<pre>
plugin::CallAndReturn<short, 0x429AF0, int>(arg0);
0AA7: call_function_return 0x429AF0 num_params 1 pop 1 [arg0] func_ret [short]
</pre>

#### CDarkel::ReadStatus

<pre>
plugin::CallAndReturn<short, 0x429FD0>();
0AA7: call_function_return 0x429FD0 num_params 0 pop 0 func_ret [short]
</pre>

#### CDarkel::RegisterCarBlownUpByPlayer

<pre>
plugin::CallAndReturn<int, 0x429DF0, CVehicle*>(vehicle);
0AA7: call_function_return 0x429DF0 num_params 1 pop 1 [vehicle] func_ret [int]
</pre>

#### CDarkel::RegisterKillByPlayer

<pre>
plugin::Call<0x429E90, CPed*, eWeaponType, bool>(ped, weaponType, arg2);
0AA5: call_function 0x429E90 num_params 3 pop 3 [ped] [weaponType] [arg2]
</pre>

#### CDarkel::RegisterKillNotByPlayer

<pre>
plugin::Call<0x429E80, CPed*, eWeaponType>(arg0, weaponType);
0AA5: call_function 0x429E80 num_params 2 pop 2 [arg0] [weaponType]
</pre>

#### CDarkel::ResetModelsKilledByPlayer

<pre>
plugin::Call<0x429B00>();
0AA5: call_function 0x429B00 num_params 0 pop 0
</pre>

#### CDarkel::ResetOnPlayerDeath

<pre>
plugin::Call<0x429F90>();
0AA5: call_function 0x429F90 num_params 0 pop 0
</pre>

#### CDarkel::StartFrenzy

<pre>
plugin::Call<0x429B60, eWeaponType, int, unsigned short, int, unsigned short*, int, int, int, bool, bool>(weaponType, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
0AA5: call_function 0x429B60 num_params 10 pop 10 [weaponType] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]
</pre>

#### CDarkel::Update

<pre>
plugin::Call<0x42A650>();
0AA5: call_function 0x42A650 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CDirectory.cpp

#### CDirectory::AddItem

<pre>
plugin::CallMethodDynGlobal<CDirectory *, const CDirectory::DirectoryInfo *>(gaddrof(CDirectory::AddItem), this, entry);
0AA6: call_method 0x4873F0 struct [CDirectory] num_params 1 pop 0 [entry]
</pre>

#### CDirectory::FindItem

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *, unsigned int *, unsigned int *>(gaddrof(CDirectory::FindItem), this, name, outOffset, outSize);
0AA8: call_method_return 0x487220 struct [CDirectory] num_params 3 pop 0 [name] [outOffset] [outSize] func_ret [bool]
</pre>

#### CDirectory::ReadDirFile

<pre>
plugin::CallMethodDynGlobal<CDirectory *, char const *>(gaddrof(CDirectory::ReadDirFile), this, filename);
0AA6: call_method 0x487370 struct [CDirectory] num_params 1 pop 0 [filename]
</pre>

#### CDirectory::WriteDirFile

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *>(gaddrof(CDirectory::WriteDirFile), this, filename);
0AA8: call_method_return 0x487320 struct [CDirectory] num_params 1 pop 0 [filename] func_ret [bool]
</pre>

### plugin_vc\game_vc\cDMAudio.cpp

#### cDMAudio::PlayFrontEndSound

<pre>
plugin::CallMethod<0x5F9960, cDMAudio*, unsigned short, unsigned int>(this, frontend, volume);
0AA6: call_method 0x5F9960 struct [cDMAudio] num_params 2 pop 0 [frontend] [volume]
</pre>

#### cDMAudio::PlayLoadedMissionAudio

<pre>
plugin::CallMethod<0x5F97B0, cDMAudio*, unsigned char>(this, slot);
0AA6: call_method 0x5F97B0 struct [cDMAudio] num_params 1 pop 0 [slot]
</pre>

#### cDMAudio::ClearMissionAudio

<pre>
plugin::CallMethod<0x5F9770, cDMAudio*, unsigned char>(this, slot);
0AA6: call_method 0x5F9770 struct [cDMAudio] num_params 1 pop 0 [slot]
</pre>

#### cDMAudio::PreloadMissionAudio

<pre>
plugin::CallMethod<0x5F9820, cDMAudio*, unsigned char, const char*>(this, slot, missionAudio);
0AA6: call_method 0x5F9820 struct [cDMAudio] num_params 2 pop 0 [slot] [missionAudio]
</pre>

#### cDMAudio::PlayOneShot

<pre>
plugin::CallMethod<0x5F9DA0, cDMAudio*, int, unsigned short, float>(this, audioEntity, shot, volume);
0AA6: call_method 0x5F9DA0 struct [cDMAudio] num_params 3 pop 0 [audioEntity] [shot] [volume]
</pre>

#### cDMAudio::SetRadioInCar

<pre>
plugin::CallMethod<0x5F9730, cDMAudio*, unsigned int>(this, radio);
0AA6: call_method 0x5F9730 struct [cDMAudio] num_params 1 pop 0 [radio]
</pre>

#### cDMAudio::PlayFrontEndTrack

<pre>
plugin::CallMethod<0x5F9910, cDMAudio*, unsigned int, char>(this, track, flag);
0AA6: call_method 0x5F9910 struct [cDMAudio] num_params 2 pop 0 [track] [flag]
</pre>

#### cDMAudio::StopFrontEndTrack

<pre>
plugin::CallMethod<0x5F98F0, cDMAudio*>(this);
0AA6: call_method 0x5F98F0 struct [cDMAudio] num_params 0 pop 0
</pre>

#### cDMAudio::IsMP3RadioChannelAvailable

<pre>
plugin::CallMethodAndReturn<bool, 0x5F9BB0, cDMAudio*>(this);
0AA8: call_method_return 0x5F9BB0 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_vc\game_vc\CDraw.cpp

#### CDraw::CalculateAspectRatio

<pre>
plugin::Call<0x54A270>();
0AA5: call_function 0x54A270 num_params 0 pop 0
</pre>

#### CDraw::SetFOV

<pre>
plugin::Call<0x54A2E0, float>(fov);
0AA5: call_function 0x54A2E0 num_params 1 pop 1 [fov]
</pre>

### plugin_vc\game_vc\CEmergencyPed.cpp

#### CEmergencyPed::CEmergencyPed

<pre>
plugin::CallMethod<0x4EEB40, CEmergencyPed *, unsigned int>(this, emergencyType);
0AA6: call_method 0x4EEB40 struct [CEmergencyPed] num_params 1 pop 0 [emergencyType]
</pre>

#### CEmergencyPed::FiremanAI

<pre>
plugin::CallMethod<0x4EDA80, CEmergencyPed *>(this);
0AA6: call_method 0x4EDA80 struct [CEmergencyPed] num_params 0 pop 0
</pre>

#### CEmergencyPed::MedicAI

<pre>
plugin::CallMethod<0x4EDC90, CEmergencyPed *>(this);
0AA6: call_method 0x4EDC90 struct [CEmergencyPed] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CEscalators.cpp

#### CEscalators::AddOne

<pre>
plugin::CallMethod<0x54B0A0, CEscalators *, CVector const&, CVector const&, CVector const&, CVector const&, bool>(this, arg0, arg1, arg2, arg3, arg4);
0AA6: call_method 0x54B0A0 struct [CEscalators] num_params 5 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CEscalators::Init

<pre>
plugin::Call<0x54B460>();
0AA5: call_function 0x54B460 num_params 0 pop 0
</pre>

#### CEscalators::Shutdown

<pre>
plugin::Call<0x54B3A0>();
0AA5: call_function 0x54B3A0 num_params 0 pop 0
</pre>

#### CEscalators::Update

<pre>
plugin::CallMethod<0x54A9B0, CEscalators *>(this);
0AA6: call_method 0x54A9B0 struct [CEscalators] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CFileLoader.cpp

#### CFileLoader::LoadAtomicFile2Return

<pre>
plugin::CallAndReturn<RpClump*, 0x48D7C0, const char*>(file);
0AA7: call_function_return 0x48D7C0 num_params 1 pop 1 [file] func_ret [RpClump*]
</pre>

### plugin_vc\game_vc\CFileMgr.cpp

#### CFileMgr::GetErrorReadWrite

<pre>
plugin::CallAndReturn<int, 0x48DE90, int>(fileHandle);
0AA7: call_function_return 0x48DE90 num_params 1 pop 1 [fileHandle] func_ret [int]
</pre>

#### CFileMgr::CloseFile

<pre>
plugin::CallAndReturn<int, 0x48DEA0, int>(fileHandle);
0AA7: call_function_return 0x48DEA0 num_params 1 pop 1 [fileHandle] func_ret [int]
</pre>

#### CFileMgr::ReadLine

<pre>
plugin::CallAndReturn<bool, 0x48DEB0, int, char*, int>(fileHandle, buffer, maxSize);
0AA7: call_function_return 0x48DEB0 num_params 3 pop 3 [fileHandle] [buffer] [maxSize] func_ret [bool]
</pre>

#### CFileMgr::Seek

<pre>
plugin::CallAndReturn<bool, 0x48DEE0, int, int, int>(fileHandle, offset, origin);
0AA7: call_function_return 0x48DEE0 num_params 3 pop 3 [fileHandle] [offset] [origin] func_ret [bool]
</pre>

#### CFileMgr::Write

<pre>
plugin::CallAndReturn<int, 0x48DF30, int, char*, int>(fileHandle, buffer, size);
0AA7: call_function_return 0x48DF30 num_params 3 pop 3 [fileHandle] [buffer] [size] func_ret [int]
</pre>

#### CFileMgr::Read

<pre>
plugin::CallAndReturn<int, 0x48DF50, int, char*, int>(fileHandle, buffer, size);
0AA7: call_function_return 0x48DF50 num_params 3 pop 3 [fileHandle] [buffer] [size] func_ret [int]
</pre>

#### CFileMgr::OpenFileForWriting

<pre>
plugin::CallAndReturn<int, 0x48DF70, char const*>(filepath);
0AA7: call_function_return 0x48DF70 num_params 1 pop 1 [filepath] func_ret [int]
</pre>

#### CFileMgr::OpenFile

<pre>
plugin::CallAndReturn<int, 0x48DF90, char const*, char const*>(filepath, mode);
0AA7: call_function_return 0x48DF90 num_params 2 pop 2 [filepath] [mode] func_ret [int]
</pre>

#### CFileMgr::LoadFile

<pre>
plugin::CallAndReturn<int, 0x48DFB0, char const*, unsigned char*, int, char const*>(filepath, buffer, size, mode);
0AA7: call_function_return 0x48DFB0 num_params 4 pop 4 [filepath] [buffer] [size] [mode] func_ret [int]
</pre>

#### CFileMgr::SetDirMyDocuments

<pre>
plugin::Call<0x48E020>();
0AA5: call_function 0x48E020 num_params 0 pop 0
</pre>

#### CFileMgr::SetDir

<pre>
plugin::Call<0x48E030, char const*>(dir);
0AA5: call_function 0x48E030 num_params 1 pop 1 [dir]
</pre>

#### CFileMgr::ChangeDir

<pre>
plugin::Call<0x48E090, char const*>(dir);
0AA5: call_function 0x48E090 num_params 1 pop 1 [dir]
</pre>

#### CFileMgr::Initialise

<pre>
plugin::Call<0x48E100>();
0AA5: call_function 0x48E100 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CFont.cpp

#### CFont::character_code

<pre>
plugin::CallAndReturn<short, 0x54FE50, unsigned char>(character);
0AA7: call_function_return 0x54FE50 num_params 1 pop 1 [character] func_ret [short]
</pre>

#### CFont::FindNewCharacter

<pre>
plugin::CallAndReturn<int, 0x54FE70, short>(character);
0AA7: call_function_return 0x54FE70 num_params 1 pop 1 [character] func_ret [int]
</pre>

#### CFont::SetDropShadowPosition

<pre>
plugin::Call<0x54FF20, short>(position);
0AA5: call_function 0x54FF20 num_params 1 pop 1 [position]
</pre>

#### CFont::SetDropColor

<pre>
plugin::Call<0x54FF30, CRGBA *>(&color);
0AA5: call_function 0x54FF30 num_params 1 pop 1 [&color]
</pre>

#### CFont::SetAlphaFade

<pre>
plugin::Call<0x54FFC0, float>(fade);
0AA5: call_function 0x54FFC0 num_params 1 pop 1 [fade]
</pre>

#### CFont::SetRightJustifyWrap

<pre>
plugin::Call<0x54FFD0, float>(wrap);
0AA5: call_function 0x54FFD0 num_params 1 pop 1 [wrap]
</pre>

#### CFont::SetFontStyle

<pre>
plugin::Call<0x54FFE0, short>(style);
0AA5: call_function 0x54FFE0 num_params 1 pop 1 [style]
</pre>

#### CFont::SetPropOn

<pre>
plugin::Call<0x550020>();
0AA5: call_function 0x550020 num_params 0 pop 0
</pre>

#### CFont::SetPropOff

<pre>
plugin::Call<0x550030>();
0AA5: call_function 0x550030 num_params 0 pop 0
</pre>

#### CFont::SetRightJustifyOff

<pre>
plugin::Call<0x550040>();
0AA5: call_function 0x550040 num_params 0 pop 0
</pre>

#### CFont::SetRightJustifyOn

<pre>
plugin::Call<0x550060>();
0AA5: call_function 0x550060 num_params 0 pop 0
</pre>

#### CFont::SetBackGroundOnlyTextOff

<pre>
plugin::Call<0x550080>();
0AA5: call_function 0x550080 num_params 0 pop 0
</pre>

#### CFont::SetBackGroundOnlyTextOn

<pre>
plugin::Call<0x550090>();
0AA5: call_function 0x550090 num_params 0 pop 0
</pre>

#### CFont::SetBackgroundColor

<pre>
plugin::Call<0x5500A0, CRGBA *>(&color);
0AA5: call_function 0x5500A0 num_params 1 pop 1 [&color]
</pre>

#### CFont::SetBackgroundOff

<pre>
plugin::Call<0x5500D0>();
0AA5: call_function 0x5500D0 num_params 0 pop 0
</pre>

#### CFont::SetBackgroundOn

<pre>
plugin::Call<0x5500E0>();
0AA5: call_function 0x5500E0 num_params 0 pop 0
</pre>

#### CFont::SetCentreSize

<pre>
plugin::Call<0x5500F0, float>(size);
0AA5: call_function 0x5500F0 num_params 1 pop 1 [size]
</pre>

#### CFont::SetWrapx

<pre>
plugin::Call<0x550100, float>(wrap);
0AA5: call_function 0x550100 num_params 1 pop 1 [wrap]
</pre>

#### CFont::SetCentreOff

<pre>
plugin::Call<0x550110>();
0AA5: call_function 0x550110 num_params 0 pop 0
</pre>

#### CFont::SetCentreOn

<pre>
plugin::Call<0x550120>();
0AA5: call_function 0x550120 num_params 0 pop 0
</pre>

#### CFont::SetJustifyOff

<pre>
plugin::Call<0x550140>();
0AA5: call_function 0x550140 num_params 0 pop 0
</pre>

#### CFont::SetJustifyOn

<pre>
plugin::Call<0x550150>();
0AA5: call_function 0x550150 num_params 0 pop 0
</pre>

#### CFont::SetColor

<pre>
plugin::Call<0x550170, CRGBA *>(&color);
0AA5: call_function 0x550170 num_params 1 pop 1 [&color]
</pre>

#### CFont::SetSlant

<pre>
plugin::Call<0x550200, float>(slant);
0AA5: call_function 0x550200 num_params 1 pop 1 [slant]
</pre>

#### CFont::SetSlantRefPoint

<pre>
plugin::Call<0x550210, float, float>(x, y);
0AA5: call_function 0x550210 num_params 2 pop 2 [x] [y]
</pre>

#### CFont::SetScale

<pre>
plugin::Call<0x550230, float, float>(width, height);
0AA5: call_function 0x550230 num_params 2 pop 2 [width] [height]
</pre>

#### CFont::DrawFonts

<pre>
plugin::Call<0x550250>();
0AA5: call_function 0x550250 num_params 0 pop 0
</pre>

#### CFont::FilterOutTokensFromString

<pre>
plugin::Call<0x550260, const wchar_t*>(str);
0AA5: call_function 0x550260 num_params 1 pop 1 [str]
</pre>

#### CFont::ParseToken

<pre>
plugin::CallAndReturn<wchar_t*, 0x5502D0, wchar_t*>(str);
0AA7: call_function_return 0x5502D0 num_params 1 pop 1 [str] func_ret [wchar_t*]
</pre>

#### CFont::ParseToken

<pre>
plugin::CallAndReturn<wchar_t*, 0x550510, wchar_t*, CRGBA&, bool&, bool&>(str, color, flashing, bold);
0AA7: call_function_return 0x550510 num_params 4 pop 4 [str] [color] [flashing] [bold] func_ret [wchar_t*]
</pre>

#### CFont::GetStringWidth

<pre>
plugin::CallAndReturn<float, 0x550650, const wchar_t*, bool>(str, sentence);
0AA7: call_function_return 0x550650 num_params 2 pop 2 [str] [sentence] func_ret [float]
</pre>

#### CFont::GetTextRect

<pre>
plugin::Call<0x550720, CRect*, float, float, const wchar_t*>(rect_out, x, y, text);
0AA5: call_function 0x550720 num_params 4 pop 4 [rect_out] [x] [y] [text]
</pre>

#### CFont::GetNumberLines

<pre>
plugin::CallAndReturn<int, 0x550C70, float, float, const wchar_t*>(x, y, text);
0AA7: call_function_return 0x550C70 num_params 3 pop 3 [x] [y] [text] func_ret [int]
</pre>

#### CFont::PrintString

<pre>
plugin::Call<0x551040, float, float, const wchar_t*>(x, y, text);
0AA5: call_function 0x551040 num_params 3 pop 3 [x] [y] [text]
</pre>

#### CFont::PrintStringFromBottom

<pre>
plugin::Call<0x551620, float, float, const wchar_t*>(x, y, text);
0AA5: call_function 0x551620 num_params 3 pop 3 [x] [y] [text]
</pre>

#### CFont::PrintString

<pre>
plugin::Call<0x5516C0, float, float, unsigned int, const wchar_t*, const wchar_t*, float>(x, y, arg2, arg3, arg4, arg5);
0AA5: call_function 0x5516C0 num_params 6 pop 6 [x] [y] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CFont::RenderFontBuffer

<pre>
plugin::Call<0x551A30>();
0AA5: call_function 0x551A30 num_params 0 pop 0
</pre>

#### CFont::PrintChar

<pre>
plugin::Call<0x551E70, float, float, short>(x, y, character);
0AA5: call_function 0x551E70 num_params 3 pop 3 [x] [y] [character]
</pre>

#### CFont::InitPerFrame

<pre>
plugin::Call<0x5522B0>();
0AA5: call_function 0x5522B0 num_params 0 pop 0
</pre>

#### CFont::Shutdown

<pre>
plugin::Call<0x5522E0>();
0AA5: call_function 0x5522E0 num_params 0 pop 0
</pre>

#### CFont::Initialise

<pre>
plugin::Call<0x552310>();
0AA5: call_function 0x552310 num_params 0 pop 0
</pre>

#### UnicodeMakeUpperCase

<pre>
plugin::Call<0x552470, wchar_t*, wchar_t const*>(str_out, str_in);
0AA5: call_function 0x552470 num_params 2 pop 2 [str_out] [str_in]
</pre>

#### UnicodeStrlen

<pre>
plugin::CallAndReturn<int, 0x5524B0, wchar_t const*>(str);
0AA7: call_function_return 0x5524B0 num_params 1 pop 1 [str] func_ret [int]
</pre>

#### AsciiToUnicode

<pre>
plugin::Call<0x552500, char const*, wchar_t*>(str_ascii, str_unicode);
0AA5: call_function 0x552500 num_params 2 pop 2 [str_ascii] [str_unicode]
</pre>

### plugin_vc\game_vc\CGame.cpp

#### CGame::CanSeeOutSideFromCurrArea

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeOutSideFromCurrArea));
</pre>

#### CGame::CanSeeWaterFromCurrArea

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeWaterFromCurrArea));
</pre>

#### CGame::Initialise

<pre>
plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);
</pre>

#### CGame::InitialiseOnceAfterRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceAfterRW));
</pre>

#### CGame::InitialiseOnceBeforeRW

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));
</pre>

#### CGame::InitialiseRenderWare

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));
</pre>

#### CGame::Shutdown

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));
</pre>

#### CGame::TidyUpMemory

<pre>
plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), a1, clearD3Dmem);
</pre>

#### AppEventHandler

<pre>
plugin::CallAndReturnDynGlobal<RsEventStatus, RsEvent, void *>(gaddrof(AppEventHandler), event, param);
</pre>

#### InitialiseGame

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(InitialiseGame));
</pre>

#### Idle

<pre>
plugin::CallDynGlobal<void *>(gaddrof(Idle), param);
</pre>

#### LoadingScreen

<pre>
plugin::CallDynGlobal<char const *, char const *, char const *>(gaddrof(LoadingScreen), title, message, screenName);
</pre>

#### \*GetLevelSplashScreen

<pre>
plugin::CallAndReturnDynGlobal<char const *, int>(gaddrof(GetLevelSplashScreen), screenId);
</pre>

#### \*GetRandomSplashScreen

<pre>
plugin::CallAndReturnDynGlobal<char const *>(gaddrof(GetRandomSplashScreen));
</pre>

#### \*LoadSplash

<pre>
plugin::CallAndReturnDynGlobal<CSprite2d *, char const *>(gaddrof(LoadSplash), splashName);
</pre>

#### PluginAttach

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(PluginAttach));
</pre>

#### DoRWStuffStartOfFrame

<pre>
plugin::CallAndReturnDynGlobal<bool, short, short, short, short, short, short, short>(gaddrof(DoRWStuffStartOfFrame), topR, topG, topB, bottomR, bottomG, bottomB, alpha);
</pre>

#### MatchModelString

<pre>
plugin::CallDynGlobal<char *, int>(gaddrof(MatchModelString), modelName, modelIndex);
</pre>

### plugin_vc\game_vc\CGameLogic.cpp

#### CGameLogic::InitAtStartOfGame

<pre>
plugin::Call<0x42C480>();
0AA5: call_function 0x42C480 num_params 0 pop 0
</pre>

#### CGameLogic::Update

<pre>
plugin::Call<0x42BB70>();
0AA5: call_function 0x42BB70 num_params 0 pop 0
</pre>

#### CGameLogic::RestorePlayerStuffDuringResurrection

<pre>
plugin::Call<0x42B900, CPlayerPed*, CVector, float>(arg1, arg2, arg3);
0AA5: call_function 0x42B900 num_params 3 pop 3 [arg1] [arg2] [arg3]
</pre>

#### CGameLogic::ClearShortCut

<pre>
plugin::Call<0x42B730>();
0AA5: call_function 0x42B730 num_params 0 pop 0
</pre>

#### CGameLogic::UpdateShortCut

<pre>
plugin::Call<0x42AE70>();
0AA5: call_function 0x42AE70 num_params 0 pop 0
</pre>

#### CGameLogic::AfterDeathArrestSetUpShortCutTaxi

<pre>
plugin::Call<0x42AC10>();
0AA5: call_function 0x42AC10 num_params 0 pop 0
</pre>

#### CGameLogic::RemoveShortCutDropOffPointForMission

<pre>
plugin::Call<0x42ADE0>();
0AA5: call_function 0x42ADE0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CGangs.cpp

#### CGangs::SetWillAttackPlayerWithCops

<pre>
plugin::Call<0x4EEF30, ePedType, bool>(pedtype, bAttackPlayerWithCops);
0AA5: call_function 0x4EEF30 num_params 2 pop 2 [pedtype] [bAttackPlayerWithCops]
</pre>

#### CGangs::SetGangWeapons

<pre>
plugin::Call<0x4EED70, short, int, int>(gangId, weapon1_Id, weapon2_Id);
0AA5: call_function 0x4EED70 num_params 3 pop 3 [gangId] [weapon1_Id] [weapon2_Id]
</pre>

#### CGangs::SetGangVehicleModel

<pre>
plugin::Call<0x4EEDD0, short, int>(gangId, vehicleModelId);
0AA5: call_function 0x4EEDD0 num_params 2 pop 2 [gangId] [vehicleModelId]
</pre>

#### CGangs::SetGangPedModels

<pre>
plugin::Call<0x4EEDA0, short, int, int>(gangId, pedModel1_Id, pedModel2_Id);
0AA5: call_function 0x4EEDA0 num_params 3 pop 3 [gangId] [pedModel1_Id] [pedModel2_Id]
</pre>

#### CGangs::SaveAllGangData

<pre>
plugin::Call<0x4EECA0, unsigned char*, unsigned int*>(arg0, arg1);
0AA5: call_function 0x4EECA0 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CGangs::Initialise

<pre>
plugin::Call<0x4EEDF0>();
0AA5: call_function 0x4EEDF0 num_params 0 pop 0
</pre>

#### CGangs::ChooseGangPedModel

<pre>
plugin::CallAndReturn<int, 0x4EED20, short>(gangId);
0AA7: call_function_return 0x4EED20 num_params 1 pop 1 [gangId] func_ret [int]
</pre>

#### CGangs::GetWillAttackPlayerWithCops

<pre>
plugin::CallAndReturn<bool, 0x18BB48, ePedType>(pedtype);
0AA7: call_function_return 0x18BB48 num_params 1 pop 1 [pedtype] func_ret [bool]
</pre>

### plugin_vc\game_vc\CGeneral.cpp

#### CGeneral::GetATanOfXY

<pre>
plugin::CallAndReturnDynGlobal<float, float, float>(gaddrof(CGeneral::GetATanOfXY), x, y);
</pre>

#### CGeneral::GetAngleBetweenPoints

<pre>
plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetAngleBetweenPoints), x1, y1, x2, y2);
</pre>

#### CGeneral::GetNodeHeadingFromVector

<pre>
plugin::CallAndReturnDynGlobal<int, float, float>(gaddrof(CGeneral::GetNodeHeadingFromVector), x, y);
</pre>

#### CGeneral::GetRadianAngleBetweenPoints

<pre>
plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetRadianAngleBetweenPoints), x1, y1, x2, y2);
</pre>

#### CGeneral::LimitAngle

<pre>
plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitAngle), angle);
</pre>

#### CGeneral::LimitRadianAngle

<pre>
plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitRadianAngle), angle);
</pre>

#### CGeneral::SolveQuadratic

<pre>
plugin::CallAndReturnDynGlobal<unsigned char, float, float, float, float &, float &>(gaddrof(CGeneral::SolveQuadratic), a, b, c, x1, x2);
</pre>

### plugin_vc\game_vc\cHandlingDataMgr.cpp

#### cHandlingDataMgr::cHandlingDataMgr

<pre>
plugin::CallMethod<0x5ABDC0, cHandlingDataMgr *>(this);
0AA6: call_method 0x5ABDC0 struct [cHandlingDataMgr] num_params 0 pop 0
</pre>

#### cHandlingDataMgr::ConvertDataToGameUnits

<pre>
plugin::CallMethod<0x5ABAA0, cHandlingDataMgr *, tHandlingData*>(this, handling);
0AA6: call_method 0x5ABAA0 struct [cHandlingDataMgr] num_params 1 pop 0 [handling]
</pre>

#### cHandlingDataMgr::FindExactWord

<pre>
plugin::CallMethodAndReturn<int, 0x5ABD30, cHandlingDataMgr *, char*, char*, int, int>(this, line, nameTable, entrySize, entryCount);
0AA8: call_method_return 0x5ABD30 struct [cHandlingDataMgr] num_params 4 pop 0 [line] [nameTable] [entrySize] [entryCount] func_ret [int]
</pre>

#### cHandlingDataMgr::GetBoatPointer

<pre>
plugin::CallMethodAndReturn<tBoatHandlingData*, 0x5ABA40, cHandlingDataMgr *, unsigned char>(this, handlingId);
0AA8: call_method_return 0x5ABA40 struct [cHandlingDataMgr] num_params 1 pop 0 [handlingId] func_ret [tBoatHandlingData*]
</pre>

#### cHandlingDataMgr::GetFlyingPointer

<pre>
plugin::CallMethodAndReturn<tFlyingHandlingData*, 0x5ABA70, cHandlingDataMgr *, unsigned char>(this, handlingId);
0AA8: call_method_return 0x5ABA70 struct [cHandlingDataMgr] num_params 1 pop 0 [handlingId] func_ret [tFlyingHandlingData*]
</pre>

#### cHandlingDataMgr::GetHandlingId

<pre>
plugin::CallMethodAndReturn<int, 0x5ABCC0, cHandlingDataMgr *, char const*>(this, name);
0AA8: call_method_return 0x5ABCC0 struct [cHandlingDataMgr] num_params 1 pop 0 [name] func_ret [int]
</pre>

#### cHandlingDataMgr::Initialise

<pre>
plugin::CallMethod<0x5ABA10, cHandlingDataMgr *>(this);
0AA6: call_method 0x5ABA10 struct [cHandlingDataMgr] num_params 0 pop 0
</pre>

#### cHandlingDataMgr::LoadHandlingData

<pre>
plugin::CallMethod<0x5AAE20, cHandlingDataMgr *>(this);
0AA6: call_method 0x5AAE20 struct [cHandlingDataMgr] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CHeli.cpp

#### CHeli::CHeli

<pre>
plugin::CallMethod<0x5AF7F0, CHeli *, int, unsigned char>(this, modelIndex, createdBy);
0AA6: call_method 0x5AF7F0 struct [CHeli] num_params 2 pop 0 [modelIndex] [createdBy]
</pre>

#### CHeli::InitHelis

<pre>
plugin::Call<0x5AD4A0>();
0AA5: call_function 0x5AD4A0 num_params 0 pop 0
</pre>

#### CHeli::PreRenderAlways

<pre>
plugin::CallMethod<0x5AF2E0, CHeli *>(this);
0AA6: call_method 0x5AF2E0 struct [CHeli] num_params 0 pop 0
</pre>

#### CHeli::SendDownSwat

<pre>
plugin::CallMethodAndReturn<bool, 0x5ABE20, CHeli *>(this);
0AA8: call_method_return 0x5ABE20 struct [CHeli] num_params 0 pop 0 func_ret [bool]
</pre>

#### CHeli::SpawnFlyingComponent

<pre>
plugin::CallMethodAndReturn<CObject*, 0x5AC1E0, CHeli *, int>(this, nodeIndex);
0AA8: call_method_return 0x5AC1E0 struct [CHeli] num_params 1 pop 0 [nodeIndex] func_ret [CObject*]
</pre>

#### CHeli::SpecialHeliPreRender

<pre>
plugin::CallAndReturn<bool, 0x5AC500>();
0AA7: call_function_return 0x5AC500 num_params 0 pop 0 func_ret [bool]
</pre>

#### CHeli::TestBulletCollision

<pre>
plugin::CallAndReturn<bool, 0x5AC6C0, CVector*, CVector*, CVector*, int>(arg0, arg1, arg2, arg3);
0AA7: call_function_return 0x5AC6C0 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3] func_ret [bool]
</pre>

#### CHeli::TestRocketCollision

<pre>
plugin::CallAndReturn<bool, 0x5AC9A0, CVector*>(arg0);
0AA7: call_function_return 0x5AC9A0 num_params 1 pop 1 [arg0] func_ret [bool]
</pre>

#### CHeli::TestSniperCollision

<pre>
plugin::CallAndReturn<bool, 0x5AC520, CVector*, CVector*>(origin, target);
0AA7: call_function_return 0x5AC520 num_params 2 pop 2 [origin] [target] func_ret [bool]
</pre>

#### CHeli::UpdateHelis

<pre>
plugin::Call<0x5ACDA0>();
0AA5: call_function 0x5ACDA0 num_params 0 pop 0
</pre>

#### GenerateHeli

<pre>
plugin::Call<0x5ACB30, bool>(enable);
0AA5: call_function 0x5ACB30 num_params 1 pop 1 [enable]
</pre>

#### StartCatalinaFlyBy

<pre>
plugin::Call<0x5ACAF0>();
0AA5: call_function 0x5ACAF0 num_params 0 pop 0
</pre>

#### GetHeliAtomicObjectCB

<pre>
plugin::CallAndReturn<RwObject*, 0x5AC4E0, RwObject*, void*>(object, data);
0AA7: call_function_return 0x5AC4E0 num_params 2 pop 2 [object] [data] func_ret [RwObject*]
</pre>

### plugin_vc\game_vc\CHud.cpp

#### CHud::DrawFadeState

<pre>
plugin::CallDynGlobal<DRAW_FADE_STATE, int>(gaddrof(CHud::DrawFadeState), fadeState, a2);
</pre>

#### CHud::IsHelpMessageBeingDisplayed

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CHud::IsHelpMessageBeingDisplayed));
</pre>

#### CHud::SetBigMessage

<pre>
plugin::CallDynGlobal<wchar_t const *, unsigned short>(gaddrof_o(CHud::SetBigMessage, void (*)(wchar_t const *, unsigned short)), message, style);
</pre>

#### CHud::SetHelpMessage

<pre>
plugin::CallDynGlobal<wchar_t const *, bool, bool>(gaddrof_o(CHud::SetHelpMessage, void (*)(wchar_t const *, bool, bool)), message, quickMessage, permanent);
</pre>

#### CHud::SetMessage

<pre>
plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetMessage, void (*)(wchar_t const *)), message);
</pre>

#### CHud::SetPagerMessage

<pre>
plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetPagerMessage, void (*)(wchar_t const *)), message);
</pre>

#### CHud::SetVehicleName

<pre>
plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetVehicleName, void (*)(wchar_t const *)), name);
</pre>

#### CHud::SetZoneName

<pre>
plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetZoneName, void (*)(wchar_t const *)), name);
</pre>

### plugin_vc\game_vc\CKeyboardState.cpp

#### CKeyboardState::Clear

<pre>
plugin::CallMethodDynGlobal<CKeyboardState *>(gaddrof(CKeyboardState::Clear), this);
0AA6: call_method 0x4AE1C0 struct [CKeyboardState] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CMenuManager.cpp

#### CMenuManager::MessageScreen

<pre>
plugin::CallMethod<0x498943, CMenuManager*, const char*, bool>(this, pText, bFullscreen);
0AA6: call_method 0x498943 struct [CMenuManager] num_params 2 pop 0 [pText] [bFullscreen]
</pre>

#### CMenuManager::DisplayHelperText

<pre>
plugin::CallMethod<0x48F429, CMenuManager*>(this, text);
0AA6: call_method 0x48F429 struct [CMenuManager] num_params 1 pop 0 [text]
</pre>

#### CMenuManager::SwitchToNewScreen

<pre>
plugin::CallMethod<0x4983EF, CMenuManager*, int>(this, screen);
0AA6: call_method 0x4983EF struct [CMenuManager] num_params 1 pop 0 [screen]
</pre>

#### CMenuManager::SwitchMenuOnAndOff

<pre>
plugin::CallMethod<0x498E5F, CMenuManager*>(this);
0AA6: call_method 0x498E5F struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::CheckSliderMovement

<pre>
plugin::CallMethod<0x4982D3, CMenuManager*>(this);
0AA6: call_method 0x4982D3 struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::Draw

<pre>
plugin::CallMethod<0x49DF40, CMenuManager*>(this, unk);
0AA6: call_method 0x49DF40 struct [CMenuManager] num_params 1 pop 0 [unk]
</pre>

#### CMenuManager::UserInput

<pre>
plugin::CallMethod<0x4965BA, CMenuManager*>(this);
0AA6: call_method 0x4965BA struct [CMenuManager] num_params 0 pop 0
</pre>

#### CMenuManager::PrintMap

<pre>
plugin::CallMethod<0x49A5B7, CMenuManager*>(this);
0AA6: call_method 0x49A5B7 struct [CMenuManager] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CMessages.cpp

#### CMessages::AddBigMessage

<pre>
plugin::Call<0x584050, wchar_t*, unsigned int, unsigned short>(pString, time, style);
0AA5: call_function 0x584050 num_params 3 pop 3 [pString] [time] [style]
</pre>

#### CMessages::AddBigMessageQ

<pre>
plugin::Call<0x583F40, wchar_t*, unsigned int, unsigned short>(pString, time, style);
0AA5: call_function 0x583F40 num_params 3 pop 3 [pString] [time] [style]
</pre>

#### CMessages::AddBigMessageWithNumber

<pre>
plugin::Call<0x583350, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, style, number, number2, number3, number4, number5, number6);
0AA5: call_function 0x583350 num_params 9 pop 9 [pString] [time] [style] [number] [number2] [number3] [number4] [number5] [number6]
</pre>

#### CMessages::AddMessage

<pre>
plugin::Call<0x584410, wchar_t*, unsigned int, unsigned short>(pString, time, flag);
0AA5: call_function 0x584410 num_params 3 pop 3 [pString] [time] [flag]
</pre>

#### CMessages::AddMessageJumpQ

<pre>
plugin::Call<0x584300, wchar_t*, unsigned int, unsigned short>(pString, time, flag);
0AA5: call_function 0x584300 num_params 3 pop 3 [pString] [time] [flag]
</pre>

#### CMessages::AddMessageJumpQWithNumber

<pre>
plugin::Call<0x583440, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, flag, number, number2, number3, number4, number5, number6);
0AA5: call_function 0x583440 num_params 9 pop 9 [pString] [time] [flag] [number] [number2] [number3] [number4] [number5] [number6]
</pre>

#### CMessages::AddMessageJumpQWithString

<pre>
plugin::Call<0x583220, wchar_t*, unsigned int, unsigned short, wchar_t*>(pString1, time, flag, pString2);
0AA5: call_function 0x583220 num_params 4 pop 4 [pString1] [time] [flag] [pString2]
</pre>

#### CMessages::AddMessageWithNumber

<pre>
plugin::Call<0x583560, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, flag, number, number1, number2, number3, number4, number5);
0AA5: call_function 0x583560 num_params 9 pop 9 [pString] [time] [flag] [number] [number1] [number2] [number3] [number4] [number5]
</pre>

#### CMessages::AddToPreviousBriefArray

<pre>
plugin::Call<0x583DE0, wchar_t*, int, int, int, int, int, int, wchar_t*>(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0AA5: call_function 0x583DE0 num_params 8 pop 8 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CMessages::ClearAllMessagesDisplayedByGame

<pre>
plugin::Call<0x582C70>();
0AA5: call_function 0x582C70 num_params 0 pop 0
</pre>

#### CMessages::ClearMessages

<pre>
plugin::Call<0x5841E0>();
0AA5: call_function 0x5841E0 num_params 0 pop 0
</pre>

#### CMessages::ClearSmallMessagesOnly

<pre>
plugin::Call<0x584130>();
0AA5: call_function 0x584130 num_params 0 pop 0
</pre>

#### CMessages::ClearThisBigPrint

<pre>
plugin::Call<0x582CF0, wchar_t*>(pString);
0AA5: call_function 0x582CF0 num_params 1 pop 1 [pString]
</pre>

#### CMessages::ClearThisPrint

<pre>
plugin::Call<0x582FA0, wchar_t*>(pString);
0AA5: call_function 0x582FA0 num_params 1 pop 1 [pString]
</pre>

#### CMessages::Display

<pre>
plugin::Call<0x584550>();
0AA5: call_function 0x584550 num_params 0 pop 0
</pre>

#### CMessages::GetWideStringLength

<pre>
plugin::CallAndReturn<unsigned short, 0x5849A0, wchar_t*>(pString);
0AA7: call_function_return 0x5849A0 num_params 1 pop 1 [pString] func_ret [unsigned short]
</pre>

#### CMessages::Init

<pre>
plugin::Call<0x5849C0>();
0AA5: call_function 0x5849C0 num_params 0 pop 0
</pre>

#### CMessages::InsertNumberInString

<pre>
plugin::Call<0x583C80, wchar_t*, int, int, int, int, int, int, wchar_t*>(pString, number, number1, number2, number3, number4, number5, arg8);
0AA5: call_function 0x583C80 num_params 8 pop 8 [pString] [number] [number1] [number2] [number3] [number4] [number5] [arg8]
</pre>

#### CMessages::InsertPlayerControlKeysInString

<pre>
plugin::Call<0x5836B0, wchar_t*>(pString);
0AA5: call_function 0x5836B0 num_params 1 pop 1 [pString]
</pre>

#### CMessages::InsertStringInString

<pre>
plugin::Call<0x583AF0, wchar_t*, wchar_t*>(pString1, pString2);
0AA5: call_function 0x583AF0 num_params 2 pop 2 [pString1] [pString2]
</pre>

#### CMessages::Process

<pre>
plugin::Call<0x584650>();
0AA5: call_function 0x584650 num_params 0 pop 0
</pre>

#### CMessages::WideStringCompare

<pre>
plugin::CallAndReturn<bool, 0x5848D0, wchar_t*, wchar_t*, unsigned short>(pString1, pString2, lengthToCompare);
0AA7: call_function_return 0x5848D0 num_params 3 pop 3 [pString1] [pString2] [lengthToCompare] func_ret [bool]
</pre>

#### CMessages::WideStringCopy

<pre>
plugin::Call<0x584940, wchar_t*, wchar_t*, unsigned short>(pString1, pString2, lengthToCopy);
0AA5: call_function 0x584940 num_params 3 pop 3 [pString1] [pString2] [lengthToCopy]
</pre>

### plugin_vc\game_vc\CModelInfo.cpp

#### CModelInfo::AddClumpModel

<pre>
plugin::CallAndReturn<CClumpModelInfo*, 0x55F640, int>(index);
0AA7: call_function_return 0x55F640 num_params 1 pop 1 [index] func_ret [CClumpModelInfo*]
</pre>

#### CModelInfo::AddPedModel

<pre>
plugin::CallAndReturn<CPedModelInfo*, 0x55F580, int>(index);
0AA7: call_function_return 0x55F580 num_params 1 pop 1 [index] func_ret [CPedModelInfo*]
</pre>

#### CModelInfo::AddSimpleModel

<pre>
plugin::CallAndReturn<CSimpleModelInfo*, 0x55F730, int>(index);
0AA7: call_function_return 0x55F730 num_params 1 pop 1 [index] func_ret [CSimpleModelInfo*]
</pre>

#### CModelInfo::AddTimeModel

<pre>
plugin::CallAndReturn<CTimeModelInfo*, 0x55F6E0, int>(index);
0AA7: call_function_return 0x55F6E0 num_params 1 pop 1 [index] func_ret [CTimeModelInfo*]
</pre>

#### CModelInfo::AddVehicleModel

<pre>
plugin::CallAndReturn<CVehicleModelInfo*, 0x55F5D0, int>(index);
0AA7: call_function_return 0x55F5D0 num_params 1 pop 1 [index] func_ret [CVehicleModelInfo*]
</pre>

#### CModelInfo::AddWeaponModel

<pre>
plugin::CallAndReturn<CWeaponModelInfo*, 0x55F690, int>(index);
0AA7: call_function_return 0x55F690 num_params 1 pop 1 [index] func_ret [CWeaponModelInfo*]
</pre>

#### CModelInfo::Get2dEffectStore

<pre>
plugin::CallAndReturn<void*, 0x55F570>();
0AA7: call_function_return 0x55F570 num_params 0 pop 0 func_ret [void*]
</pre>

#### CModelInfo::GetModelInfo

<pre>
plugin::CallAndReturn<CBaseModelInfo*, 0x55F7D0, char const*, int*>(name, index);
0AA7: call_function_return 0x55F7D0 num_params 2 pop 2 [name] [index] func_ret [CBaseModelInfo*]
</pre>

#### CModelInfo::GetModelInfo

<pre>
plugin::CallAndReturn<CBaseModelInfo*, 0x55F780, char const*, int, int>(name, minIndex, maxInedx);
0AA7: call_function_return 0x55F780 num_params 3 pop 3 [name] [minIndex] [maxInedx] func_ret [CBaseModelInfo*]
</pre>

#### CModelInfo::Initialise

<pre>
plugin::Call<0x55FA40>();
0AA5: call_function 0x55FA40 num_params 0 pop 0
</pre>

#### CModelInfo::IsBikeModel

<pre>
plugin::CallAndReturn<bool, 0x55F4E0, int>(index);
0AA7: call_function_return 0x55F4E0 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CModelInfo::IsBoatModel

<pre>
plugin::CallAndReturn<bool, 0x55F540, int>(index);
0AA7: call_function_return 0x55F540 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CModelInfo::IsCarModel

<pre>
plugin::CallAndReturn<bool, 0x55F510, int>(index);
0AA7: call_function_return 0x55F510 num_params 1 pop 1 [index] func_ret [bool]
</pre>

#### CModelInfo::ShutDown

<pre>
plugin::Call<0x55F820>();
0AA5: call_function 0x55F820 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CMotionBlurStreaks.cpp

#### CMotionBlurStreaks::RegisterStreak

<pre>
plugin::Call<0x572800, unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(id, red, green, blue, leftPoint, rightPoint);
0AA5: call_function 0x572800 num_params 6 pop 6 [id] [red] [green] [blue] [leftPoint] [rightPoint]
</pre>

#### CMotionBlurStreaks::Render

<pre>
plugin::Call<0x572920>();
0AA5: call_function 0x572920 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CMousePointerStateHelper.cpp

### plugin_vc\game_vc\CMovie.cpp

#### CMovie::CMovie

<pre>
plugin::CallMethod<0x606720, CMovie *>(this);
0AA6: call_method 0x606720 struct [CMovie] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CObject.cpp

#### CObject::CObject

<pre>
plugin::CallMethod<0x4E40F0, CObject *, CDummyObject*>(this, dummyObject);
0AA6: call_method 0x4E40F0 struct [CObject] num_params 1 pop 0 [dummyObject]
</pre>

#### CObject::CObject

<pre>
plugin::CallMethod<0x4E41B0, CObject *, int, bool>(this, arg0, arg1);
0AA6: call_method 0x4E41B0 struct [CObject] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CObject::CObject

<pre>
plugin::CallMethod<0x4E4220, CObject *>(this);
0AA6: call_method 0x4E4220 struct [CObject] num_params 0 pop 0
</pre>

#### CObject::CanBeDeleted

<pre>
plugin::CallMethodAndReturn<bool, 0x4E3E20, CObject *>(this);
0AA8: call_method_return 0x4E3E20 struct [CObject] num_params 0 pop 0 func_ret [bool]
</pre>

#### CObject::DeleteAllMissionObjects

<pre>
plugin::Call<0x4E0820>();
0AA5: call_function 0x4E0820 num_params 0 pop 0
</pre>

#### CObject::DeleteAllTempObjects

<pre>
plugin::Call<0x4E08A0>();
0AA5: call_function 0x4E08A0 num_params 0 pop 0
</pre>

#### CObject::DeleteAllTempObjectsInArea

<pre>
plugin::Call<0x4E0720, CVector, float>(point, radius);
0AA5: call_function 0x4E0720 num_params 2 pop 2 [point] [radius]
</pre>

#### CObject::Init

<pre>
plugin::CallMethod<0x4E3E50, CObject *>(this);
0AA6: call_method 0x4E3E50 struct [CObject] num_params 0 pop 0
</pre>

#### CObject::ObjectDamage

<pre>
plugin::CallMethod<0x4E0990, CObject *, float>(this, damage);
0AA6: call_method 0x4E0990 struct [CObject] num_params 1 pop 0 [damage]
</pre>

#### CObject::RefModelInfo

<pre>
plugin::CallMethod<0x4E0970, CObject *, int>(this, modelIndex);
0AA6: call_method 0x4E0970 struct [CObject] num_params 1 pop 0 [modelIndex]
</pre>

#### CObject::operator delete

<pre>
plugin::Call<0x4E4030, void*>(data);
0AA5: call_function 0x4E4030 num_params 1 pop 1 [data]
</pre>

#### CObject::operator new

<pre>
plugin::CallAndReturn<void*, 0x4E4070, unsigned int>(size);
0AA7: call_function_return 0x4E4070 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CObject::operator new

<pre>
plugin::CallAndReturn<void*, 0x4E4050, unsigned int, int>(size, arg1);
0AA7: call_function_return 0x4E4050 num_params 2 pop 2 [size] [arg1] func_ret [void*]
</pre>

### plugin_vc\game_vc\COcclusion.cpp

#### COcclusion::AddOne

<pre>
plugin::CallDynGlobal<float, float, float, float, float, float, float>(gaddrof(COcclusion::AddOne), x, y, z, width, length, height, angle);
</pre>

#### COcclusion::IsAABoxOccluded

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector, float, float, float>(gaddrof(COcclusion::IsAABoxOccluded), pos, width, length, height);
</pre>

#### COcclusion::IsPositionOccluded

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector, float>(gaddrof(COcclusion::IsPositionOccluded), pos, side);
</pre>

#### COccluder::ProcessLineSegment

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, COccluder *, int, int, CActiveOccluder *>(gaddrof(COccluder::ProcessLineSegment), this, corner1, corner2, occl);
0AA8: call_method_return 0x635270 struct [COccluder] num_params 3 pop 0 [corner1] [corner2] [occl] func_ret [bool]
</pre>

#### COccluder::ProcessOneOccluder

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, COccluder *, CActiveOccluder *>(gaddrof(COccluder::ProcessOneOccluder), this, occl);
0AA8: call_method_return 0x6358D0 struct [COccluder] num_params 1 pop 0 [occl] func_ret [bool]
</pre>

#### DoesInfiniteLineTouchScreen

<pre>
plugin::CallAndReturnDynGlobal<bool, float, float, float, float>(gaddrof(DoesInfiniteLineTouchScreen), lineX, lineY, lineDX, lineDY);
</pre>

### plugin_vc\game_vc\common.cpp

#### FindPlayerHeading

<pre>
plugin::CallAndReturn<float, 0x4BBF70>();
0AA7: call_function_return 0x4BBF70 num_params 0 pop 0 func_ret [float]
</pre>

#### FindPlayerCentreOfWorld_NoSniperShift

<pre>
plugin::CallAndReturn<CVector&, 0x4BC020>();
0AA7: call_function_return 0x4BC020 num_params 0 pop 0 func_ret [CVector&]
</pre>

#### FindPlayerCentreOfWorld

<pre>
plugin::CallAndReturn<CVector&, 0x4BC0A0, int>(playerId);
0AA7: call_function_return 0x4BC0A0 num_params 1 pop 1 [playerId] func_ret [CVector&]
</pre>

#### FindPlayerPed

<pre>
plugin::CallAndReturn<CPlayerPed*, 0x4BC120>();
0AA7: call_function_return 0x4BC120 num_params 0 pop 0 func_ret [CPlayerPed*]
</pre>

#### FindPlayerTrain

<pre>
plugin::CallAndReturn<CTrain*, 0x4BC140>();
0AA7: call_function_return 0x4BC140 num_params 0 pop 0 func_ret [CTrain*]
</pre>

#### FindPlayerEntity

<pre>
plugin::CallAndReturn<CEntity*, 0x4BC1B0>();
0AA7: call_function_return 0x4BC1B0 num_params 0 pop 0 func_ret [CEntity*]
</pre>

#### FindPlayerVehicle

<pre>
plugin::CallAndReturn<CVehicle*, 0x4BC1E0>();
0AA7: call_function_return 0x4BC1E0 num_params 0 pop 0 func_ret [CVehicle*]
</pre>

#### FindPlayerSpeed

<pre>
plugin::CallAndReturn<CVector&, 0x4BC210>();
0AA7: call_function_return 0x4BC210 num_params 0 pop 0 func_ret [CVector&]
</pre>

#### GetFirstTexture

<pre>
plugin::CallAndReturn<RwTexture*, 0x57F900, RwTexDictionary*>(texDictionary);
0AA7: call_function_return 0x57F900 num_params 1 pop 1 [texDictionary] func_ret [RwTexture*]
</pre>

#### GetFirstObject

<pre>
plugin::CallAndReturn<RwObject*, 0x57F940, RwFrame*>(frame);
0AA7: call_function_return 0x57F940 num_params 1 pop 1 [frame] func_ret [RwObject*]
</pre>

#### GetFirstAtomic

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57F980, RpClump*>(clump);
0AA7: call_function_return 0x57F980 num_params 1 pop 1 [clump] func_ret [RpAtomic*]
</pre>

#### SetAmbientColours

<pre>
plugin::Call<0x57FAD0, RwRGBAReal*>(colours);
0AA5: call_function 0x57FAD0 num_params 1 pop 1 [colours]
</pre>

#### SetAmbientColoursForPedsCarsAndObjects

<pre>
plugin::Call<0x57FAF0>();
0AA5: call_function 0x57FAF0 num_params 0 pop 0
</pre>

#### SetAmbientColours

<pre>
plugin::Call<0x57FB10>();
0AA5: call_function 0x57FB10 num_params 0 pop 0
</pre>

#### SetFullAmbient

<pre>
plugin::Call<0x57FB30>();
0AA5: call_function 0x57FB30 num_params 0 pop 0
</pre>

#### ActivateDirectional

<pre>
plugin::Call<0x57FB50>();
0AA5: call_function 0x57FB50 num_params 0 pop 0
</pre>

#### DeActivateDirectional

<pre>
plugin::Call<0x57FB60>();
0AA5: call_function 0x57FB60 num_params 0 pop 0
</pre>

#### ReSetAmbientAndDirectionalColours

<pre>
plugin::Call<0x57FB70>();
0AA5: call_function 0x57FB70 num_params 0 pop 0
</pre>

#### SetBrightMarkerColours

<pre>
plugin::Call<0x57FBA0, float>(power);
0AA5: call_function 0x57FBA0 num_params 1 pop 1 [power]
</pre>

#### SetAmbientAndDirectionalColours

<pre>
plugin::Call<0x57FC50, float>(power);
0AA5: call_function 0x57FC50 num_params 1 pop 1 [power]
</pre>

#### RemoveExtraDirectionalLights

<pre>
plugin::Call<0x57FCD0, RpWorld*>(world);
0AA5: call_function 0x57FCD0 num_params 1 pop 1 [world]
</pre>

#### AddAnExtraDirectionalLight

<pre>
plugin::Call<0x57FD00, RpWorld*, float, float, float, float, float, float>(world, x, y, z, red, green, blue);
0AA5: call_function 0x57FD00 num_params 7 pop 7 [world] [x] [y] [z] [red] [green] [blue]
</pre>

#### WorldReplaceNormalLightsWithScorched

<pre>
plugin::Call<0x57FE40, RpWorld*, float>(world, intensity);
0AA5: call_function 0x57FE40 num_params 2 pop 2 [world] [intensity]
</pre>

#### LightsDestroy

<pre>
plugin::CallAndReturn<RpWorld*, 0x57FE80, RpWorld*>(world);
0AA7: call_function_return 0x57FE80 num_params 1 pop 1 [world] func_ret [RpWorld*]
</pre>

#### LightsCreate

<pre>
plugin::CallAndReturn<RpWorld*, 0x57FF50, RpWorld*>(world);
0AA7: call_function_return 0x57FF50 num_params 1 pop 1 [world] func_ret [RpWorld*]
</pre>

#### SetLightsWithTimeOfDayColour

<pre>
plugin::Call<0x5800F0, RpWorld*>(world);
0AA5: call_function 0x5800F0 num_params 1 pop 1 [world]
</pre>

#### RpAnimBlendAllocateData

<pre>
plugin::CallAndReturn<CAnimBlendClumpData*, 0x407520, RpClump*>(clump);
0AA7: call_function_return 0x407520 num_params 1 pop 1 [clump] func_ret [CAnimBlendClumpData*]
</pre>

#### RpAnimBlendClumpFillFrameArray

<pre>
plugin::Call<0x407AC0, RpClump*, AnimBlendFrameData**>(clump, frameData);
0AA5: call_function 0x407AC0 num_params 2 pop 2 [clump] [frameData]
</pre>

#### RpAnimBlendClumpGetAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x407780, RpClump*, unsigned int>(clump, animId);
0AA7: call_function_return 0x407780 num_params 2 pop 2 [clump] [animId] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetFirstAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x402E20, RpClump*>(clump);
0AA7: call_function_return 0x402E20 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetFirstAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4075F0, RpClump*, unsigned int>(clump, flags);
0AA7: call_function_return 0x4075F0 num_params 2 pop 2 [clump] [flags] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetMainAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x407660, RpClump*, int>(clump, n);
0AA7: call_function_return 0x407660 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpGetMainPartialAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x407620, RpClump*, int>(clump, n);
0AA7: call_function_return 0x407620 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendClumpInit

<pre>
plugin::Call<0x407890, RpClump*>(clump);
0AA5: call_function 0x407890 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendClumpIsInitialized

<pre>
plugin::CallAndReturn<bool, 0x407870, RpClump*>(clump);
0AA7: call_function_return 0x407870 num_params 1 pop 1 [clump] func_ret [bool]
</pre>

#### RpAnimBlendClumpRemoveAllAssociations

<pre>
plugin::Call<0x407800, RpClump*>(clump);
0AA5: call_function 0x407800 num_params 1 pop 1 [clump]
</pre>

#### RpAnimBlendClumpRemoveAssociations

<pre>
plugin::Call<0x4077B0, RpClump*, unsigned int>(clump, flags);
0AA5: call_function 0x4077B0 num_params 2 pop 2 [clump] [flags]
</pre>

#### RpAnimBlendClumpSetBlendDeltas

<pre>
plugin::Call<0x407830, RpClump*, unsigned int, float>(clump, flags, delta);
0AA5: call_function 0x407830 num_params 3 pop 3 [clump] [flags] [delta]
</pre>

#### RpAnimBlendClumpUpdateAnimations

<pre>
plugin::Call<0x404690, RpClump*, float, bool>(clump, step, onScreen);
0AA5: call_function 0x404690 num_params 3 pop 3 [clump] [step] [onScreen]
</pre>

#### RpAnimBlendGetNextAssociation

<pre>
plugin::CallAndReturn<CAnimBlendAssociation*, 0x4075D0, CAnimBlendAssociation*>(association);
0AA7: call_function_return 0x4075D0 num_params 1 pop 1 [association] func_ret [CAnimBlendAssociation*]
</pre>

#### RpAnimBlendPluginAttach

<pre>
plugin::CallAndReturn<bool, 0x4074D0>();
0AA7: call_function_return 0x4074D0 num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_vc\game_vc\COnscreenTimer.cpp

#### COnscreenTimer::AddClock

<pre>
plugin::CallMethod<0x434B30, COnscreenTimer *, unsigned int, char*, bool>(this, arg0, arg1, arg2);
0AA6: call_method 0x434B30 struct [COnscreenTimer] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### COnscreenTimer::AddCounter

<pre>
plugin::CallMethod<0x434AE0, COnscreenTimer *, unsigned int, unsigned short, char*, unsigned short>(this, arg0, arg1, arg2, arg3);
0AA6: call_method 0x434AE0 struct [COnscreenTimer] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3]
</pre>

#### COnscreenTimer::ClearClock

<pre>
plugin::CallMethod<0x434AA0, COnscreenTimer *, unsigned int>(this, arg0);
0AA6: call_method 0x434AA0 struct [COnscreenTimer] num_params 1 pop 0 [arg0]
</pre>

#### COnscreenTimer::ClearCounter

<pre>
plugin::CallMethod<0x434A60, COnscreenTimer *, unsigned int>(this, arg0);
0AA6: call_method 0x434A60 struct [COnscreenTimer] num_params 1 pop 0 [arg0]
</pre>

#### COnscreenTimer::Init

<pre>
plugin::CallMethod<0x434CE0, COnscreenTimer *>(this);
0AA6: call_method 0x434CE0 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::Process

<pre>
plugin::CallMethod<0x434B90, COnscreenTimer *>(this);
0AA6: call_method 0x434B90 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimer::ProcessForDisplay

<pre>
plugin::CallMethod<0x434BD0, COnscreenTimer *>(this);
0AA6: call_method 0x434BD0 struct [COnscreenTimer] num_params 0 pop 0
</pre>

#### COnscreenTimerEntry::Process

<pre>
plugin::CallMethod<0x434DE0, COnscreenTimerEntry *>(this);
0AA6: call_method 0x434DE0 struct [COnscreenTimerEntry] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CPad.cpp

#### CPad::AddToPCCheatString

<pre>
plugin::CallMethodDynGlobal<CPad *, char>(gaddrof(CPad::AddToPCCheatString), this, character);
0AA6: call_method 0x4ABD20 struct [CPad] num_params 1 pop 0 [character]
</pre>

#### CPad::CarGunJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CarGunJustDown), this);
0AA8: call_method_return 0x4AA9F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ChangeStationJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ChangeStationJustDown), this);
0AA8: call_method_return 0x4AA590 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::Clear

<pre>
plugin::CallMethodDynGlobal<CPad *, char>(gaddrof(CPad::Clear), this, bDisablePlayerControls);
0AA6: call_method 0x4ADBE0 struct [CPad] num_params 1 pop 0 [bDisablePlayerControls]
</pre>

#### CPad::CollectPickupJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CollectPickupJustDown), this);
0AA8: call_method_return 0x4A9F80 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleCameraModeDownJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeDownJustDown), this);
0AA8: call_method_return 0x4AA6C0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleCameraModeJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeJustDown), this);
0AA8: call_method_return 0x4AA630 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleCameraModeUpJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeUpJustDown), this);
0AA8: call_method_return 0x4AA700 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleWeaponLeftJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleWeaponLeftJustDown), this);
0AA8: call_method_return 0x4AA560 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::CycleWeaponRightJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleWeaponRightJustDown), this);
0AA8: call_method_return 0x4AA530 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::DuckJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::DuckJustDown), this);
0AA8: call_method_return 0x4AA430 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ExitVehicleJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ExitVehicleJustDown), this);
0AA8: call_method_return 0x4AA870 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ForceCameraBehindPlayer

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ForceCameraBehindPlayer), this);
0AA8: call_method_return 0x4A9F00 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAccelerate

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAccelerate), this);
0AA8: call_method_return 0x4AA760 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetAnalogueLeftRight

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAnalogueLeftRight), this);
0AA8: call_method_return 0x4AADC0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetAnaloguePadDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadDown), this);
0AA8: call_method_return 0x4AA260 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadLeft

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadLeft), this);
0AA8: call_method_return 0x4AA200 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadLeftJustUp

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadLeftJustUp), this);
0AA8: call_method_return 0x4AA0D0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadRight

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadRight), this);
0AA8: call_method_return 0x4AA1A0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadRightJustUp

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadRightJustUp), this);
0AA8: call_method_return 0x4AA000 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnaloguePadUp

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadUp), this);
0AA8: call_method_return 0x4AA2B0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetAnalogueUpDown

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAnalogueUpDown), this);
0AA8: call_method_return 0x4AACC0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetBrake

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetBrake), this);
0AA8: call_method_return 0x4AA960 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetCarGunFired

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetCarGunFired), this);
0AA8: call_method_return 0x4AAA60 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetCarGunLeftRight

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetCarGunLeftRight), this);
0AA8: call_method_return 0x4AAEB0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetCarGunUpDown

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetCarGunUpDown), this);
0AA8: call_method_return 0x4AAF00 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetExitVehicle

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetExitVehicle), this);
0AA8: call_method_return 0x4AA8F0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetHandBrake

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetHandBrake), this);
0AA8: call_method_return 0x4AA9B0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetHorn

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetHorn), this);
0AA8: call_method_return 0x4AAB60 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookBehindForCar

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookBehindForCar), this);
0AA8: call_method_return 0x4AAC30 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookBehindForPed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookBehindForPed), this);
0AA8: call_method_return 0x4AAC00 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookLeft

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookLeft), this);
0AA8: call_method_return 0x4AAC90 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetLookRight

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookRight), this);
0AA8: call_method_return 0x4AAC60 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetPedWalkLeftRight

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetPedWalkLeftRight), this);
0AA8: call_method_return 0x4AAE30 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetPedWalkUpDown

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetPedWalkUpDown), this);
0AA8: call_method_return 0x4AAD40 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetSprint

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetSprint), this);
0AA8: call_method_return 0x4AA390 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetSteeringLeftRight

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetSteeringLeftRight), this);
0AA8: call_method_return 0x4AAFD0 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetSteeringUpDown

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetSteeringUpDown), this);
0AA8: call_method_return 0x4AAF50 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::GetTarget

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetTarget), this);
0AA8: call_method_return 0x4AA4D0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::GetWeapon

<pre>
plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetWeapon), this);
0AA8: call_method_return 0x4AA830 struct [CPad] num_params 0 pop 0 func_ret [short]
</pre>

#### CPad::HornJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::HornJustDown), this);
0AA8: call_method_return 0x4AAAC0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::InputHowLongAgo

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::InputHowLongAgo), this);
0AA8: call_method_return 0x4ADBD0 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::JumpJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::JumpJustDown), this);
0AA8: call_method_return 0x4AA400 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::LookAroundLeftRight

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::LookAroundLeftRight), this);
0AA8: call_method_return 0x4A9A80 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::LookAroundUpDown

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::LookAroundUpDown), this);
0AA8: call_method_return 0x4A98F0 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::ResetAverageWeapon

<pre>
plugin::CallMethodDynGlobal<CPad *>(gaddrof(CPad::ResetAverageWeapon), this);
0AA6: call_method 0x4A98A0 struct [CPad] num_params 0 pop 0
</pre>

#### CPad::SetDrunkInputDelay

<pre>
plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::SetDrunkInputDelay), this, bEnable);
0AA6: call_method 0x4AD340 struct [CPad] num_params 1 pop 0 [bEnable]
</pre>

#### CPad::ShiftTargetLeftJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ShiftTargetLeftJustDown), this);
0AA8: call_method_return 0x4AA360 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::ShiftTargetRightJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ShiftTargetRightJustDown), this);
0AA8: call_method_return 0x4AA300 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SniperModeLookLeftRight

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::SniperModeLookLeftRight), this);
0AA8: call_method_return 0x4A9D40 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::SniperModeLookUpDown

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::SniperModeLookUpDown), this);
0AA8: call_method_return 0x4A9C40 struct [CPad] num_params 0 pop 0 func_ret [int]
</pre>

#### CPad::SniperZoomIn

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::SniperZoomIn), this);
0AA8: call_method_return 0x4A9E90 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::SniperZoomOut

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::SniperZoomOut), this);
0AA8: call_method_return 0x4A9E20 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::StartShake

<pre>
plugin::CallMethodDynGlobal<CPad *, short, unsigned char>(gaddrof(CPad::StartShake), this, duration, frequency);
0AA6: call_method 0x4AD2E0 struct [CPad] num_params 2 pop 0 [duration] [frequency]
</pre>

#### CPad::StopShaking

<pre>
plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::StopShaking), this, a1);
0AA6: call_method 0x4AB070 struct [CPad] num_params 1 pop 0 [a1]
</pre>

#### CPad::TargetJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::TargetJustDown), this);
0AA8: call_method_return 0x4AA460 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::Update

<pre>
plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::Update), this, a2);
0AA6: call_method 0x4AB0C0 struct [CPad] num_params 1 pop 0 [a2]
</pre>

#### CPad::WeaponJustDown

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::WeaponJustDown), this);
0AA8: call_method_return 0x4AA7B0 struct [CPad] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPad::EditCodesForControls

<pre>
plugin::CallDynGlobal<int *, int>(gaddrof(CPad::EditCodesForControls), outKeyCode, a2);
</pre>

#### \*CPad::GetPad

<pre>
plugin::CallAndReturnDynGlobal<CPad *, int>(gaddrof(CPad::GetPad), padNumber);
</pre>

### plugin_vc\game_vc\CParticle.cpp

#### CParticle::AddJetExplosion

<pre>
plugin::CallDynGlobal<CVector const &, float, float>(gaddrof(CParticle::AddJetExplosion), posn, power, size);
</pre>

#### \*CParticle::AddParticle

<pre>
plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const *, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const *, int, int, int, int)), particleType, posn, direction, entity, size, color, rotationSpeed, rotation, startFrame, lifeSpan);
</pre>

#### \*CParticle::AddParticle

<pre>
plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle *(*)(tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int)), particleType, posn, direction, entity, size, rotationSpeed, rotation, startFrame, lifeSpan);
</pre>

#### CParticle::AddParticlesAlongLine

<pre>
plugin::CallDynGlobal<tParticleType, CVector const *, CVector const *, CVector const &, float, CEntity *, float, int, int, int, int>(gaddrof(CParticle::AddParticlesAlongLine), particleType, lineStart, lineEnd, direction, step, entity, size, rotationSpeed, rotation, startFrame, lifeSpan);
</pre>

#### CParticle::HandleShootableBirdsStuff

<pre>
plugin::CallDynGlobal<CEntity *, CVector const &>(gaddrof(CParticle::HandleShootableBirdsStuff), entity, posn);
</pre>

#### CParticle::RemovePSystem

<pre>
plugin::CallDynGlobal<tParticleType>(gaddrof(CParticle::RemovePSystem), particleType);
</pre>

#### CParticle::RemoveParticle

<pre>
plugin::CallDynGlobal<CParticle *, CParticle *, tParticleSystemData *>(gaddrof(CParticle::RemoveParticle), particle, previousParticle, particleSystsem);
</pre>

### plugin_vc\game_vc\cParticleSystemMgr.cpp

#### cParticleSystemMgr::Initialise

<pre>
plugin::CallMethodDynGlobal<cParticleSystemMgr *>(gaddrof(cParticleSystemMgr::Initialise), this);
0AA6: call_method 0x565F60 struct [cParticleSystemMgr] num_params 0 pop 0
</pre>

#### cParticleSystemMgr::LoadParticleData

<pre>
plugin::CallMethodDynGlobal<cParticleSystemMgr *>(gaddrof(cParticleSystemMgr::LoadParticleData), this);
0AA6: call_method 0x565B00 struct [cParticleSystemMgr] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CPathFind.cpp

#### CPathFind::GeneratePedCreationCoors

<pre>
plugin::CallMethodAndReturn<bool, 0x437B10, CPathFind *, float, float, float, float, float, float, CVector*, int*, int*, float*, CMatrix*>(this, arg1, arg2, arg3, arg4, arg5, arg6, ar7, arg8, arg9, arg10, arg11);
0AA8: call_method_return 0x437B10 struct [CPathFind] num_params 11 pop 0 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [ar7] [arg8] [arg9] [arg10] [arg11] func_ret [bool]
</pre>

#### CPathFind::GenerateCarCreationCoors

<pre>
plugin::CallMethodAndReturn<bool, 0x4382B0, CPathFind *, float, float, float, float, float, float, bool, CVector*, int*, int*, float*, bool>(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
0AA8: call_method_return 0x4382B0 struct [CPathFind] num_params 12 pop 0 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12] func_ret [bool]
</pre>

#### CPathFind::FindNodeClosestToCoors

<pre>
plugin::CallMethodAndReturn<int, 0x437150, CPathFind *, CVector, unsigned char, float, bool, bool, bool, bool>(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0AA8: call_method_return 0x437150 struct [CPathFind] num_params 7 pop 0 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] func_ret [int]
</pre>

### plugin_vc\game_vc\CPed.cpp

#### CPed::SetMoveAnim

<pre>
plugin::CallVirtualMethod<18, CPed *>(this);
</pre>

#### CPed::AddInCarAnims

<pre>
plugin::CallMethodAndReturn<int, 0x512520, CPed *, CVehicle*, bool>(this, vehicle, arg1);
0AA8: call_method_return 0x512520 struct [CPed] num_params 2 pop 0 [vehicle] [arg1] func_ret [int]
</pre>

#### CPed::AddWeaponModel

<pre>
plugin::CallMethod<0x4FFE40, CPed *, int>(this, modelIndex);
0AA6: call_method 0x4FFE40 struct [CPed] num_params 1 pop 0 [modelIndex]
</pre>

#### CPed::AimGun

<pre>
plugin::CallMethodAndReturn<char, 0x50B2C0, CPed *>(this);
0AA8: call_method_return 0x50B2C0 struct [CPed] num_params 0 pop 0 func_ret [char]
</pre>

#### CPed::AnswerMobile

<pre>
plugin::CallMethod<0x4F5710, CPed *>(this);
0AA6: call_method 0x4F5710 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::AttachPedToEntity

<pre>
plugin::CallMethodAndReturn<CEntity*, 0x4EF490, CPed *, CEntity*, float, float, float, unsigned short, float, eWeaponType>(this, entity, offsetX, offsetY, offsetZ, position, angle, weaponType);
0AA8: call_method_return 0x4EF490 struct [CPed] num_params 7 pop 0 [entity] [offsetX] [offsetY] [offsetZ] [position] [angle] [weaponType] func_ret [CEntity*]
</pre>

#### CPed::Attack

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x52B070, CPed *>(this);
0AA8: call_method_return 0x52B070 struct [CPed] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CPed::Avoid

<pre>
plugin::CallMethod<0x4FA2E0, CPed *>(this);
0AA6: call_method 0x4FA2E0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::BeingDraggedFromCar

<pre>
plugin::CallMethodAndReturn<int, 0x518250, CPed *>(this);
0AA8: call_method_return 0x518250 struct [CPed] num_params 0 pop 0 func_ret [int]
</pre>

#### CPed::BuildPedLists

<pre>
plugin::CallMethod<0x50D4B0, CPed *>(this);
0AA6: call_method 0x50D4B0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::BuyIceCream

<pre>
plugin::CallMethod<0x4F10D0, CPed *>(this);
0AA6: call_method 0x4F10D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CalculateNewOrientation

<pre>
plugin::CallMethod<0x509F80, CPed *>(this);
0AA6: call_method 0x509F80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CalculateNewVelocity

<pre>
plugin::CallMethod<0x50A640, CPed *>(this);
0AA6: call_method 0x50A640 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CanBeDamagedByThisGangMember

<pre>
plugin::CallMethodAndReturn<bool, 0x50F130, CPed *, CPed*>(this, ped);
0AA8: call_method_return 0x50F130 struct [CPed] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPed::CanBeDeleted

<pre>
plugin::CallMethodAndReturn<bool, 0x4FFEF0, CPed *>(this);
0AA8: call_method_return 0x4FFEF0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanBeDeletedEvenInVehicle

<pre>
plugin::CallMethodAndReturn<bool, 0x4FFEC0, CPed *>(this);
0AA8: call_method_return 0x4FFEC0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanPedDriveOff

<pre>
plugin::CallMethodAndReturn<bool, 0x4EFC90, CPed *>(this);
0AA8: call_method_return 0x4EFC90 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanPedJumpThis

<pre>
plugin::CallMethodAndReturn<bool, 0x4F0590, CPed *, CEntity*, CVector*>(this, entity, arg1);
0AA8: call_method_return 0x4F0590 struct [CPed] num_params 2 pop 0 [entity] [arg1] func_ret [bool]
</pre>

#### CPed::CanSeeEntity

<pre>
plugin::CallMethodAndReturn<bool, 0x51C870, CPed *, CEntity*, float>(this, entity, limitAngle);
0AA8: call_method_return 0x51C870 struct [CPed] num_params 2 pop 0 [entity] [limitAngle] func_ret [bool]
</pre>

#### CPed::CanSetPedState

<pre>
plugin::CallMethodAndReturn<bool, 0x5018D0, CPed *>(this);
0AA8: call_method_return 0x5018D0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanStrafeOrMouseControl

<pre>
plugin::CallMethodAndReturn<bool, 0x501890, CPed *>(this);
0AA8: call_method_return 0x501890 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CanWeRunAndFireWithWeapon

<pre>
plugin::CallMethodAndReturn<bool, 0x50B220, CPed *>(this);
0AA8: call_method_return 0x50B220 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Chat

<pre>
plugin::CallMethodAndReturn<unsigned int, 0x4F6050, CPed *>(this);
0AA8: call_method_return 0x4F6050 struct [CPed] num_params 0 pop 0 func_ret [unsigned int]
</pre>

#### CPed::CheckForExplosions

<pre>
plugin::CallMethodAndReturn<bool, 0x4F4950, CPed *, CVector2D&>(this, arg0);
0AA8: call_method_return 0x4F4950 struct [CPed] num_params 1 pop 0 [arg0] func_ret [bool]
</pre>

#### CPed::CheckForPointBlankPeds

<pre>
plugin::CallMethodAndReturn<char, 0x52C670, CPed *, CPed*>(this, ped);
0AA8: call_method_return 0x52C670 struct [CPed] num_params 1 pop 0 [ped] func_ret [char]
</pre>

#### CPed::CheckIfInTheAir

<pre>
plugin::CallMethodAndReturn<bool, 0x4FD680, CPed *>(this);
0AA8: call_method_return 0x4FD680 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::CheckThreatValidity

<pre>
plugin::CallMethodAndReturn<int, 0x50BD00, CPed *>(this);
0AA8: call_method_return 0x50BD00 struct [CPed] num_params 0 pop 0 func_ret [int]
</pre>

#### CPed::ChooseAttackAI

<pre>
plugin::CallMethodAndReturn<int, 0x529460, CPed *, unsigned char, bool>(this, arg0, arg1);
0AA8: call_method_return 0x529460 struct [CPed] num_params 2 pop 0 [arg0] [arg1] func_ret [int]
</pre>

#### CPed::ChooseAttackPlayer

<pre>
plugin::CallMethodAndReturn<int, 0x528AA0, CPed *, unsigned char, bool>(this, arg0, arg1);
0AA8: call_method_return 0x528AA0 struct [CPed] num_params 2 pop 0 [arg0] [arg1] func_ret [int]
</pre>

#### CPed::ClearAimFlag

<pre>
plugin::CallMethod<0x50B4A0, CPed *>(this);
0AA6: call_method 0x50B4A0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAll

<pre>
plugin::CallMethod<0x509DF0, CPed *>(this);
0AA6: call_method 0x509DF0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAnswerMobile

<pre>
plugin::CallMethod<0x4F58C0, CPed *>(this);
0AA6: call_method 0x4F58C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAttack

<pre>
plugin::CallMethod<0x52D120, CPed *>(this);
0AA6: call_method 0x52D120 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearAttackByRemovingAnim

<pre>
plugin::CallMethod<0x52CF70, CPed *>(this);
0AA6: call_method 0x52CF70 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearChat

<pre>
plugin::CallMethod<0x4F5FA0, CPed *>(this);
0AA6: call_method 0x4F5FA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearDuck

<pre>
plugin::CallMethod<0x512A20, CPed *, bool>(this, arg0);
0AA6: call_method 0x512A20 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::ClearFollowPath

<pre>
plugin::CallMethod<0x4F7920, CPed *>(this);
0AA6: call_method 0x4F7920 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearInvestigateEvent

<pre>
plugin::CallMethod<0x526BA0, CPed *>(this);
0AA6: call_method 0x526BA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearLeader

<pre>
plugin::CallMethod<0x521670, CPed *>(this);
0AA6: call_method 0x521670 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearLookFlag

<pre>
plugin::CallMethod<0x50B9C0, CPed *>(this);
0AA6: call_method 0x50B9C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearObjective

<pre>
plugin::CallMethod<0x521720, CPed *>(this);
0AA6: call_method 0x521720 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearPointGunAt

<pre>
plugin::CallMethod<0x52DBE0, CPed *>(this);
0AA6: call_method 0x52DBE0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearSeek

<pre>
plugin::CallMethod<0x4FC450, CPed *>(this);
0AA6: call_method 0x4FC450 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearWaitState

<pre>
plugin::CallMethod<0x4F3130, CPed *>(this);
0AA6: call_method 0x4F3130 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ClearWeapons

<pre>
plugin::CallMethod<0x4FF740, CPed *>(this);
0AA6: call_method 0x4FF740 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CollideWithPed

<pre>
plugin::CallMethod<0x524920, CPed *, CPed*>(this, ped);
0AA6: call_method 0x524920 struct [CPed] num_params 1 pop 0 [ped]
</pre>

#### CPed::CreateDeadPedMoney

<pre>
plugin::CallMethod<0x43E2C0, CPed *>(this);
0AA6: call_method 0x43E2C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::CreateDeadPedPickupCoors

<pre>
plugin::CallMethod<0x43DAC0, CPed *, float*, float*, float*>(this, pX, pY, pZ);
0AA6: call_method 0x43DAC0 struct [CPed] num_params 3 pop 0 [pX] [pY] [pZ]
</pre>

#### CPed::CreateDeadPedWeaponPickups

<pre>
plugin::CallMethod<0x43DF30, CPed *>(this);
0AA6: call_method 0x43DF30 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::DeadPedMakesTyresBloody

<pre>
plugin::CallMethod<0x587700, CPed *>(this);
0AA6: call_method 0x587700 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::DettachPedFromEntity

<pre>
plugin::CallMethod<0x4EF370, CPed *>(this);
0AA6: call_method 0x4EF370 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Dress

<pre>
plugin::CallMethod<0x4EEFD0, CPed *>(this);
0AA6: call_method 0x4EEFD0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::DriveVehicle

<pre>
plugin::CallMethod<0x522AA0, CPed *>(this);
0AA6: call_method 0x522AA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Duck

<pre>
plugin::CallMethod<0x512A90, CPed *>(this);
0AA6: call_method 0x512A90 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::DuckAndCover

<pre>
plugin::CallMethod<0x513340, CPed *>(this);
0AA6: call_method 0x513340 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::EndFight

<pre>
plugin::CallMethod<0x5289A0, CPed *, unsigned char>(this, arg0);
0AA6: call_method 0x5289A0 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::EnterCar

<pre>
plugin::CallMethod<0x517BA0, CPed *>(this);
0AA6: call_method 0x517BA0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ExitCar

<pre>
plugin::CallMethod<0x516960, CPed *>(this);
0AA6: call_method 0x516960 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::FacePhone

<pre>
plugin::CallMethodAndReturn<bool, 0x4F5CA0, CPed *>(this);
0AA8: call_method_return 0x4F5CA0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Fall

<pre>
plugin::CallMethod<0x4FD740, CPed *>(this);
0AA6: call_method 0x4FD740 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Fight

<pre>
plugin::CallMethod<0x529A00, CPed *>(this);
0AA6: call_method 0x529A00 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::FightHitPed

<pre>
plugin::CallMethod<0x527800, CPed *, CPed*, CVector&, CVector&, short>(this, ped, arg1, arg2, arg3);
0AA6: call_method 0x527800 struct [CPed] num_params 4 pop 0 [ped] [arg1] [arg2] [arg3]
</pre>

#### CPed::FightStrike

<pre>
plugin::CallMethod<0x5282E0, CPed *, CVector&, bool>(this, arg0, arg1);
0AA6: call_method 0x5282E0 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::FindBestCoordsFromNodes

<pre>
plugin::CallMethodAndReturn<bool, 0x513DF0, CPed *, CVector, CVector*>(this, arg0, arg1);
0AA8: call_method_return 0x513DF0 struct [CPed] num_params 2 pop 0 [arg0] [arg1] func_ret [bool]
</pre>

#### CPed::Flee

<pre>
plugin::CallMethod<0x4FB130, CPed *>(this);
0AA6: call_method 0x4FB130 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::FollowPath

<pre>
plugin::CallMethodAndReturn<short, 0x4F76C0, CPed *>(this);
0AA8: call_method_return 0x4F76C0 struct [CPed] num_params 0 pop 0 func_ret [short]
</pre>

#### CPed::GetFormationPosition

<pre>
plugin::CallMethodAndReturn<int, 0x519E30, CPed *>(this);
0AA8: call_method_return 0x519E30 struct [CPed] num_params 0 pop 0 func_ret [int]
</pre>

#### CPed::GetLocalDirection

<pre>
plugin::CallMethodAndReturn<int, 0x5035F0, CPed *, CVector2D const&>(this, arg0);
0AA8: call_method_return 0x5035F0 struct [CPed] num_params 1 pop 0 [arg0] func_ret [int]
</pre>

#### CPed::GetLocalPositionToOpenCarDoor

<pre>
plugin::CallAndReturn<int, 0x512D10, CVehicle*, unsigned int, float>(vehicle, arg1, arg2);
0AA7: call_function_return 0x512D10 num_params 3 pop 3 [vehicle] [arg1] [arg2] func_ret [int]
</pre>

#### CPed::GetNearestDoor

<pre>
plugin::CallMethodAndReturn<int, 0x5160E0, CPed *, CVehicle*, CVector&>(this, vehicle, position);
0AA8: call_method_return 0x5160E0 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [int]
</pre>

#### CPed::GetNearestPassengerDoor

<pre>
plugin::CallMethodAndReturn<bool, 0x515CE0, CPed *, CVehicle*, CVector&>(this, vehicle, position);
0AA8: call_method_return 0x515CE0 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [bool]
</pre>

#### CPed::GetNearestTrainDoor

<pre>
plugin::CallMethodAndReturn<bool, 0x514A70, CPed *, CVehicle*, CVector&>(this, vehicle, position);
0AA8: call_method_return 0x514A70 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [bool]
</pre>

#### CPed::GetNearestTrainPedPosition

<pre>
plugin::CallMethodAndReturn<bool, 0x514650, CPed *, CVehicle*, CVector&>(this, vehicle, position);
0AA8: call_method_return 0x514650 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [bool]
</pre>

#### CPed::GetNextPointOnRoute

<pre>
plugin::CallMethodAndReturn<int, 0x51C9E0, CPed *>(this);
0AA8: call_method_return 0x51C9E0 struct [CPed] num_params 0 pop 0 func_ret [int]
</pre>

#### CPed::GetPositionToOpenCarDoor

<pre>
plugin::CallAndReturn<int, 0x5164D0, CVehicle*, unsigned int>(vehicle, arg1);
0AA7: call_function_return 0x5164D0 num_params 2 pop 2 [vehicle] [arg1] func_ret [int]
</pre>

#### CPed::GetPositionToOpenCarDoor

<pre>
plugin::CallAndReturn<int, 0x513080, CVehicle*, unsigned int, float>(vehicle, arg1, arg2);
0AA7: call_function_return 0x513080 num_params 3 pop 3 [vehicle] [arg1] [arg2] func_ret [int]
</pre>

#### CPed::GetWeaponSlot

<pre>
plugin::CallMethodAndReturn<int, 0x4FFA10, CPed *, eWeaponType>(this, weaponType);
0AA8: call_method_return 0x4FFA10 struct [CPed] num_params 1 pop 0 [weaponType] func_ret [int]
</pre>

#### CPed::GiveDelayedWeapon

<pre>
plugin::CallMethod<0x4FFC30, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);
0AA6: call_method 0x4FFC30 struct [CPed] num_params 2 pop 0 [weaponType] [ammo]
</pre>

#### CPed::GiveWeapon

<pre>
plugin::CallMethod<0x4FFA30, CPed *, eWeaponType, unsigned int, bool>(this, weaponType, ammo, likeUnused);
0AA6: call_method 0x4FFA30 struct [CPed] num_params 3 pop 0 [weaponType] [ammo] [likeUnused]
</pre>

#### CPed::GrantAmmo

<pre>
plugin::CallMethod<0x4FF840, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);
0AA6: call_method 0x4FF840 struct [CPed] num_params 2 pop 0 [weaponType] [ammo]
</pre>

#### CPed::HasAttractor

<pre>
plugin::CallMethodAndReturn<bool, 0x4EF8A0, CPed *>(this);
0AA8: call_method_return 0x4EF8A0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::HaveReachedNextPointOnRoute

<pre>
plugin::CallMethodAndReturn<bool, 0x51C970, CPed *, float>(this, arg0);
0AA8: call_method_return 0x51C970 struct [CPed] num_params 1 pop 0 [arg0] func_ret [bool]
</pre>

#### CPed::Idle

<pre>
plugin::CallMethod<0x4FDEB0, CPed *>(this);
0AA6: call_method 0x4FDEB0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::InTheAir

<pre>
plugin::CallMethod<0x4FD4D0, CPed *>(this);
0AA6: call_method 0x4FD4D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::InflictDamage

<pre>
plugin::CallMethod<0x525B20, CPed *, void*, eWeaponType, float, ePedPieceTypes, unsigned char>(this, arg0, weaponType, arg2, arg3, arg4);
0AA6: call_method 0x525B20 struct [CPed] num_params 5 pop 0 [arg0] [weaponType] [arg2] [arg3] [arg4]
</pre>

#### CPed::InformMyGangOfAttack

<pre>
plugin::CallMethod<0x512950, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x512950 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::Initialise

<pre>
plugin::Call<0x50D9F0>();
0AA5: call_function 0x50D9F0 num_params 0 pop 0
</pre>

#### CPed::InvestigateEvent

<pre>
plugin::CallMethod<0x526C60, CPed *>(this);
0AA6: call_method 0x526C60 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::IsGangMember

<pre>
plugin::CallMethodAndReturn<bool, 0x4F4910, CPed *>(this);
0AA8: call_method_return 0x4F4910 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPedDoingDriveByShooting

<pre>
plugin::CallMethodAndReturn<bool, 0x5C84D0, CPed *>(this);
0AA8: call_method_return 0x5C84D0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPedHeadAbovePos

<pre>
plugin::CallMethodAndReturn<bool, 0x525960, CPed *, float>(this, zPos);
0AA8: call_method_return 0x525960 struct [CPed] num_params 1 pop 0 [zPos] func_ret [bool]
</pre>

#### CPed::IsPedInControl

<pre>
plugin::CallMethodAndReturn<bool, 0x501950, CPed *>(this);
0AA8: call_method_return 0x501950 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPedShootable

<pre>
plugin::CallMethodAndReturn<bool, 0x501930, CPed *>(this);
0AA8: call_method_return 0x501930 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPlayer

<pre>
plugin::CallMethodAndReturn<bool, 0x4F4930, CPed *>(this);
0AA8: call_method_return 0x4F4930 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsPointerValid

<pre>
plugin::CallMethodAndReturn<bool, 0x4F4860, CPed *>(this);
0AA8: call_method_return 0x4F4860 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::IsRoomToBeCarJacked

<pre>
plugin::CallMethodAndReturn<bool, 0x512670, CPed *>(this);
0AA8: call_method_return 0x512670 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::KillCharOnFootArmed

<pre>
plugin::CallMethod<0x50FFC0, CPed *, CVector&, CVector&, CVector&>(this, arg0, arg1, arg2);
0AA6: call_method 0x50FFC0 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CPed::KillCharOnFootMelee

<pre>
plugin::CallMethod<0x50F170, CPed *, CVector&, CVector&, CVector&>(this, arg0, arg1, arg2);
0AA6: call_method 0x50F170 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CPed::KillPedWithCar

<pre>
plugin::CallMethod<0x523CD0, CPed *, CVehicle*, float>(this, vehicle, arg1);
0AA6: call_method 0x523CD0 struct [CPed] num_params 2 pop 0 [vehicle] [arg1]
</pre>

#### CPed::LineUpPedWithCar

<pre>
plugin::CallMethod<0x518AD0, CPed *, unsigned int>(this, arg0);
0AA6: call_method 0x518AD0 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::LoadFightData

<pre>
plugin::Call<0x527570>();
0AA5: call_function 0x527570 num_params 0 pop 0
</pre>

#### CPed::LookForInterestingNodes

<pre>
plugin::CallMethod<0x4F3540, CPed *>(this);
0AA6: call_method 0x4F3540 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::LookForSexyCars

<pre>
plugin::CallMethod<0x4F3EB0, CPed *>(this);
0AA6: call_method 0x4F3EB0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::LookForSexyPeds

<pre>
plugin::CallMethod<0x4F4090, CPed *>(this);
0AA6: call_method 0x4F4090 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::MakePhonecall

<pre>
plugin::CallMethodAndReturn<bool, 0x4F5B40, CPed *>(this);
0AA8: call_method_return 0x4F5B40 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::MakeTyresMuddySectorList

<pre>
plugin::CallMethod<0x5870D0, CPed *, CPtrList&>(this, ptrList);
0AA6: call_method 0x5870D0 struct [CPed] num_params 1 pop 0 [ptrList]
</pre>

#### CPed::MoveHeadToLook

<pre>
plugin::CallMethod<0x50B700, CPed *>(this);
0AA6: call_method 0x50B700 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Mug

<pre>
plugin::CallMethod<0x4FCD30, CPed *>(this);
0AA6: call_method 0x4FCD30 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::OurPedCanSeeThisOne

<pre>
plugin::CallMethodAndReturn<bool, 0x50D360, CPed *, CEntity*, bool>(this, entity, arg1);
0AA8: call_method_return 0x50D360 struct [CPed] num_params 2 pop 0 [entity] [arg1] func_ret [bool]
</pre>

#### CPed::Pause

<pre>
plugin::CallMethod<0x4FDE80, CPed *>(this);
0AA6: call_method 0x4FDE80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PedShuffle

<pre>
plugin::CallMethod<0x51A2F0, CPed *>(this);
0AA6: call_method 0x51A2F0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PlacePedOnDryLand

<pre>
plugin::CallMethodAndReturn<bool, 0x5256A0, CPed *>(this);
0AA8: call_method_return 0x5256A0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::PlayFootSteps

<pre>
plugin::CallMethod<0x503680, CPed *>(this);
0AA6: call_method 0x503680 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PlayHitSound

<pre>
plugin::CallMethod<0x528850, CPed *, CPed*>(this, ped);
0AA6: call_method 0x528850 struct [CPed] num_params 1 pop 0 [ped]
</pre>

#### CPed::PointGunAt

<pre>
plugin::CallMethodAndReturn<short, 0x52DCD0, CPed *>(this);
0AA8: call_method_return 0x52DCD0 struct [CPed] num_params 0 pop 0 func_ret [short]
</pre>

#### CPed::PositionAnyPedOutOfCollision

<pre>
plugin::CallMethodAndReturn<bool, 0x511840, CPed *>(this);
0AA8: call_method_return 0x511840 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::PositionAttachedPed

<pre>
plugin::CallMethod<0x4EF0A0, CPed *>(this);
0AA6: call_method 0x4EF0A0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::PositionPedOutOfCollision

<pre>
plugin::CallMethodAndReturn<bool, 0x511B10, CPed *>(this);
0AA8: call_method_return 0x511B10 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::PossiblyFindBetterPosToSeekCar

<pre>
plugin::CallMethodAndReturn<bool, 0x4F0810, CPed *, CVector*, CVehicle*>(this, arg0, vehicle);
0AA8: call_method_return 0x4F0810 struct [CPed] num_params 2 pop 0 [arg0] [vehicle] func_ret [bool]
</pre>

#### CPed::ProcessBuoyancy

<pre>
plugin::CallMethod<0x509460, CPed *>(this);
0AA6: call_method 0x509460 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ProcessObjective

<pre>
plugin::CallMethod<0x51CA70, CPed *>(this);
0AA6: call_method 0x51CA70 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::QuitEnteringCar

<pre>
plugin::CallMethod<0x5179D0, CPed *>(this);
0AA6: call_method 0x5179D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ReactToAttack

<pre>
plugin::CallMethod<0x51BDA0, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x51BDA0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::ReactToPointGun

<pre>
plugin::CallMethod<0x51C1E0, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x51C1E0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::RegisterThreatWithGangPeds

<pre>
plugin::CallMethod<0x514360, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x514360 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::RemoveDrivebyAnims

<pre>
plugin::CallMethod<0x512480, CPed *>(this);
0AA6: call_method 0x512480 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RemoveInCarAnims

<pre>
plugin::CallMethod<0x512440, CPed *, bool>(this, arg0);
0AA6: call_method 0x512440 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::RemoveWeaponAnims

<pre>
plugin::CallMethod<0x5229B0, CPed *, int, float>(this, likeUnused, blendDelta);
0AA6: call_method 0x5229B0 struct [CPed] num_params 2 pop 0 [likeUnused] [blendDelta]
</pre>

#### CPed::RemoveWeaponModel

<pre>
plugin::CallMethod<0x4FFD80, CPed *, int>(this, modelIndex);
0AA6: call_method 0x4FFD80 struct [CPed] num_params 1 pop 0 [modelIndex]
</pre>

#### CPed::RemoveWeaponWhenEnteringVehicle

<pre>
plugin::CallMethod<0x4FF6A0, CPed *>(this);
0AA6: call_method 0x4FF6A0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ReplaceWeaponWhenExitingVehicle

<pre>
plugin::CallMethod<0x4FF5A0, CPed *>(this);
0AA6: call_method 0x4FF5A0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RequestDelayedWeapon

<pre>
plugin::CallMethod<0x4FFCE0, CPed *>(this);
0AA6: call_method 0x4FFCE0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestartNonPartialAnims

<pre>
plugin::CallMethod<0x50CCF0, CPed *>(this);
0AA6: call_method 0x50CCF0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestoreGunPosition

<pre>
plugin::CallMethod<0x50B250, CPed *>(this);
0AA6: call_method 0x50B250 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestoreHeadPosition

<pre>
plugin::CallMethod<0x50B650, CPed *>(this);
0AA6: call_method 0x50B650 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestoreHeadingRate

<pre>
plugin::CallMethod<0x4F17D0, CPed *>(this);
0AA6: call_method 0x4F17D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestorePreviousObjective

<pre>
plugin::CallMethod<0x520FE0, CPed *>(this);
0AA6: call_method 0x520FE0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::RestorePreviousState

<pre>
plugin::CallMethod<0x50C600, CPed *>(this);
0AA6: call_method 0x50C600 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Say

<pre>
plugin::CallMethod<0x5226B0, CPed *, unsigned short>(this, arg0);
0AA6: call_method 0x5226B0 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::Say

<pre>
plugin::CallMethod<0x4EEFA0, CPed *, unsigned short, int>(this, arg0, arg1);
0AA6: call_method 0x4EEFA0 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::ScanForDelayedResponseThreats

<pre>
plugin::CallMethod<0x50BD80, CPed *>(this);
0AA6: call_method 0x50BD80 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ScanForInterestingStuff

<pre>
plugin::CallMethod<0x50AD50, CPed *>(this);
0AA6: call_method 0x50AD50 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ScanForThreats

<pre>
plugin::CallMethod<0x50BE00, CPed *>(this);
0AA6: call_method 0x50BE00 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::Seek

<pre>
plugin::CallMethodAndReturn<bool, 0x4FBD00, CPed *>(this);
0AA8: call_method_return 0x4FBD00 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::SeekBoatPosition

<pre>
plugin::CallMethod<0x512740, CPed *>(this);
0AA6: call_method 0x512740 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SeekCar

<pre>
plugin::CallMethod<0x4F4AD0, CPed *>(this);
0AA6: call_method 0x4F4AD0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SeekFollowingPath

<pre>
plugin::CallMethod<0x4FA1C0, CPed *>(this);
0AA6: call_method 0x4FA1C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SelectGunIfArmed

<pre>
plugin::CallMethodAndReturn<bool, 0x51C800, CPed *>(this);
0AA8: call_method_return 0x51C800 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::ServiceTalking

<pre>
plugin::CallMethod<0x522850, CPed *>(this);
0AA6: call_method 0x522850 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::ServiceTalkingWhenDead

<pre>
plugin::CallMethodAndReturn<bool, 0x522990, CPed *>(this);
0AA8: call_method_return 0x522990 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::SetAimFlag

<pre>
plugin::CallMethod<0x50B510, CPed *, CEntity*>(this, aimingTo);
0AA6: call_method 0x50B510 struct [CPed] num_params 1 pop 0 [aimingTo]
</pre>

#### CPed::SetAimFlag

<pre>
plugin::CallMethod<0x50B5B0, CPed *, float>(this, heading);
0AA6: call_method 0x50B5B0 struct [CPed] num_params 1 pop 0 [heading]
</pre>

#### CPed::SetAmmo

<pre>
plugin::CallMethod<0x4FF780, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);
0AA6: call_method 0x4FF780 struct [CPed] num_params 2 pop 0 [weaponType] [ammo]
</pre>

#### CPed::SetAnimOffsetForEnterOrExitVehicle

<pre>
plugin::Call<0x5155E0>();
0AA5: call_function 0x5155E0 num_params 0 pop 0
</pre>

#### CPed::SetAnswerMobile

<pre>
plugin::CallMethod<0x4F59C0, CPed *>(this);
0AA6: call_method 0x4F59C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetAttack

<pre>
plugin::CallMethod<0x52D1C0, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x52D1C0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetAttackTimer

<pre>
plugin::CallMethod<0x4FCAB0, CPed *, unsigned int>(this, time);
0AA6: call_method 0x4FCAB0 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetBeingDraggedFromCar

<pre>
plugin::CallMethod<0x518430, CPed *, CVehicle*, unsigned int, bool>(this, vehicle, arg1, arg2);
0AA6: call_method 0x518430 struct [CPed] num_params 3 pop 0 [vehicle] [arg1] [arg2]
</pre>

#### CPed::SetCarJack

<pre>
plugin::CallMethod<0x5188A0, CPed *, CVehicle*>(this, vehicle);
0AA6: call_method 0x5188A0 struct [CPed] num_params 1 pop 0 [vehicle]
</pre>

#### CPed::SetCarJack_AllClear

<pre>
plugin::CallMethod<0x518690, CPed *, CVehicle*, unsigned int, unsigned int>(this, vehicle, arg1, arg2);
0AA6: call_method 0x518690 struct [CPed] num_params 3 pop 0 [vehicle] [arg1] [arg2]
</pre>

#### CPed::SetChat

<pre>
plugin::CallMethod<0x4F6220, CPed *, CEntity*, unsigned int>(this, entity, arg1);
0AA6: call_method 0x4F6220 struct [CPed] num_params 2 pop 0 [entity] [arg1]
</pre>

#### CPed::SetCurrentWeapon

<pre>
plugin::CallMethod<0x4FF8E0, CPed *, eWeaponType>(this, weaponType);
0AA6: call_method 0x4FF8E0 struct [CPed] num_params 1 pop 0 [weaponType]
</pre>

#### CPed::SetCurrentWeapon

<pre>
plugin::CallMethod<0x4FF900, CPed *, int>(this, slot);
0AA6: call_method 0x4FF900 struct [CPed] num_params 1 pop 0 [slot]
</pre>

#### CPed::SetDead

<pre>
plugin::CallMethod<0x4F6430, CPed *>(this);
0AA6: call_method 0x4F6430 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetDie

<pre>
plugin::CallMethod<0x4F65C0, CPed *, AnimationId, float, float>(this, arg0, arg1, arg2);
0AA6: call_method 0x4F65C0 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CPed::SetDirectionToWalkAroundObject

<pre>
plugin::CallMethod<0x5019A0, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x5019A0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetDirectionToWalkAroundVehicle

<pre>
plugin::CallMethod<0x5035B0, CPed *, CVehicle*>(this, vehicle);
0AA6: call_method 0x5035B0 struct [CPed] num_params 1 pop 0 [vehicle]
</pre>

#### CPed::SetDuck

<pre>
plugin::CallMethod<0x512C10, CPed *, unsigned int, bool>(this, arg0, arg1);
0AA6: call_method 0x512C10 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetEnterCar

<pre>
plugin::CallMethod<0x518080, CPed *, CVehicle*, unsigned int>(this, vehicle, arg1);
0AA6: call_method 0x518080 struct [CPed] num_params 2 pop 0 [vehicle] [arg1]
</pre>

#### CPed::SetEnterCar_AllClear

<pre>
plugin::CallMethod<0x517DE0, CPed *, CVehicle*, unsigned int, unsigned int>(this, vehicle, arg1, arg2);
0AA6: call_method 0x517DE0 struct [CPed] num_params 3 pop 0 [vehicle] [arg1] [arg2]
</pre>

#### CPed::SetEvasiveDive

<pre>
plugin::CallMethod<0x4F6A20, CPed *, CPhysical*, unsigned char>(this, arg0, arg1);
0AA6: call_method 0x4F6A20 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetEvasiveStep

<pre>
plugin::CallMethod<0x4F7170, CPed *, CPhysical*, unsigned char>(this, arg0, arg1);
0AA6: call_method 0x4F7170 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetExitBoat

<pre>
plugin::CallMethod<0x517670, CPed *, CVehicle*>(this, boat);
0AA6: call_method 0x517670 struct [CPed] num_params 1 pop 0 [boat]
</pre>

#### CPed::SetExitCar

<pre>
plugin::CallMethod<0x516C60, CPed *, CVehicle*, unsigned int>(this, vehicle, arg1);
0AA6: call_method 0x516C60 struct [CPed] num_params 2 pop 0 [vehicle] [arg1]
</pre>

#### CPed::SetFall

<pre>
plugin::CallMethod<0x4FD9F0, CPed *, int, AnimationId, unsigned char>(this, arg0, arg1, arg2);
0AA6: call_method 0x4FD9F0 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CPed::SetFlee

<pre>
plugin::CallMethod<0x4FB820, CPed *, CEntity*, int>(this, arg0, arg1);
0AA6: call_method 0x4FB820 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetFlee

<pre>
plugin::CallMethod<0x4FBA90, CPed *, CVector2D const&, int>(this, arg0, arg1);
0AA6: call_method 0x4FBA90 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetFollowPath

<pre>
plugin::CallMethod<0x4F9F60, CPed *, CVector const&, float, eMoveState, CEntity*, CEntity*, int>(this, arg0, arg1, arg2, arg3, arg4, arg5);
0AA6: call_method 0x4F9F60 struct [CPed] num_params 6 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5]
</pre>

#### CPed::SetFollowPathDynamic

<pre>
plugin::CallMethodAndReturn<bool, 0x4F7990, CPed *>(this);
0AA8: call_method_return 0x4F7990 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::SetFollowPathStatic

<pre>
plugin::CallMethodAndReturn<bool, 0x4F99F0, CPed *>(this);
0AA8: call_method_return 0x4F99F0 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::SetFormation

<pre>
plugin::CallMethod<0x51A020, CPed *, eFormation>(this, arg0);
0AA6: call_method 0x51A020 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::SetGetUp

<pre>
plugin::CallMethod<0x4FCF60, CPed *>(this);
0AA6: call_method 0x4FCF60 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetIdle

<pre>
plugin::CallMethod<0x4FDFD0, CPed *>(this);
0AA6: call_method 0x4FDFD0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetInTheAir

<pre>
plugin::CallMethod<0x4FD610, CPed *>(this);
0AA6: call_method 0x4FD610 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetInvestigateEvent

<pre>
plugin::CallMethod<0x527490, CPed *, eEventType, CVector2D, float, unsigned short, float>(this, eventType, arg1, arg2, arg3, arg4);
0AA6: call_method 0x527490 struct [CPed] num_params 5 pop 0 [eventType] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CPed::SetJump

<pre>
plugin::CallMethod<0x4F03C0, CPed *>(this);
0AA6: call_method 0x4F03C0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetLanding

<pre>
plugin::CallMethod<0x4FD3A0, CPed *>(this);
0AA6: call_method 0x4FD3A0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetLeader

<pre>
plugin::CallMethod<0x4F07D0, CPed *, CPed*>(this, ped);
0AA6: call_method 0x4F07D0 struct [CPed] num_params 1 pop 0 [ped]
</pre>

#### CPed::SetLook

<pre>
plugin::CallMethod<0x4FCB10, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x4FCB10 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetLookFlag

<pre>
plugin::CallMethod<0x50BB70, CPed *, CEntity*, bool, bool>(this, lookingTo, likeUnused, arg2);
0AA6: call_method 0x50BB70 struct [CPed] num_params 3 pop 0 [lookingTo] [likeUnused] [arg2]
</pre>

#### CPed::SetLookFlag

<pre>
plugin::CallMethod<0x50BC40, CPed *, float, bool, bool>(this, lookHeading, likeUnused, arg2);
0AA6: call_method 0x50BC40 struct [CPed] num_params 3 pop 0 [lookHeading] [likeUnused] [arg2]
</pre>

#### CPed::SetLookTimer

<pre>
plugin::CallMethod<0x4FCAF0, CPed *, unsigned int>(this, time);
0AA6: call_method 0x4FCAF0 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetMoveState

<pre>
plugin::CallMethod<0x50D110, CPed *, eMoveState>(this, moveState);
0AA6: call_method 0x50D110 struct [CPed] num_params 1 pop 0 [moveState]
</pre>

#### CPed::SetNewAttraction

<pre>
plugin::CallMethod<0x4EF7C0, CPed *, CPedAttractor*, CVector const&, float, float, int>(this, arg0, arg1, arg2, arg3, arg4);
0AA6: call_method 0x4EF7C0 struct [CPed] num_params 5 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethod<0x5224B0, CPed *, eObjective>(this, objective);
0AA6: call_method 0x5224B0 struct [CPed] num_params 1 pop 0 [objective]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethod<0x521840, CPed *, eObjective, CVector>(this, objective, arg1);
0AA6: call_method 0x521840 struct [CPed] num_params 2 pop 0 [objective] [arg1]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethod<0x5217E0, CPed *, eObjective, float, CVector const&>(this, objective, arg1, arg2);
0AA6: call_method 0x5217E0 struct [CPed] num_params 3 pop 0 [objective] [arg1] [arg2]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethod<0x521D10, CPed *, eObjective, short, short>(this, objective, arg1, arg2);
0AA6: call_method 0x521D10 struct [CPed] num_params 3 pop 0 [objective] [arg1] [arg2]
</pre>

#### CPed::SetObjective

<pre>
plugin::CallMethod<0x521F10, CPed *, eObjective, void*>(this, objective, arg1);
0AA6: call_method 0x521F10 struct [CPed] num_params 2 pop 0 [objective] [arg1]
</pre>

#### CPed::SetObjectiveTimer

<pre>
plugin::CallMethod<0x522660, CPed *, unsigned int>(this, time);
0AA6: call_method 0x522660 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetPedPositionInCar

<pre>
plugin::CallMethod<0x4F42F0, CPed *>(this);
0AA6: call_method 0x4F42F0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetPedStats

<pre>
plugin::CallMethod<0x50D8E0, CPed *, ePedStats>(this, statsType);
0AA6: call_method 0x50D8E0 struct [CPed] num_params 1 pop 0 [statsType]
</pre>

#### CPed::SetPointGunAt

<pre>
plugin::CallMethod<0x52DDF0, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x52DDF0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::SetRadioStation

<pre>
plugin::CallMethod<0x4EFBD0, CPed *>(this);
0AA6: call_method 0x4EFBD0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetSeek

<pre>
plugin::CallMethod<0x4FC570, CPed *, CEntity*, float>(this, arg0, arg1);
0AA6: call_method 0x4FC570 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetSeek

<pre>
plugin::CallMethod<0x4FC740, CPed *, CVector, float>(this, arg0, arg1);
0AA6: call_method 0x4FC740 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::SetSeekBoatPosition

<pre>
plugin::CallMethod<0x512850, CPed *, CVehicle*>(this, boat);
0AA6: call_method 0x512850 struct [CPed] num_params 1 pop 0 [boat]
</pre>

#### CPed::SetSeekCar

<pre>
plugin::CallMethod<0x4F54D0, CPed *, CVehicle*, unsigned int>(this, car, arg1);
0AA6: call_method 0x4F54D0 struct [CPed] num_params 2 pop 0 [car] [arg1]
</pre>

#### CPed::SetShootTimer

<pre>
plugin::CallMethod<0x4FCA90, CPed *, unsigned int>(this, time);
0AA6: call_method 0x4FCA90 struct [CPed] num_params 1 pop 0 [time]
</pre>

#### CPed::SetSolicit

<pre>
plugin::CallMethod<0x4F1400, CPed *, unsigned int>(this, arg0);
0AA6: call_method 0x4F1400 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::SetStoredObjective

<pre>
plugin::CallMethod<0x522620, CPed *>(this);
0AA6: call_method 0x522620 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetStoredState

<pre>
plugin::CallMethod<0x50CC40, CPed *>(this);
0AA6: call_method 0x50CC40 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SetWaitState

<pre>
plugin::CallMethod<0x4F28A0, CPed *, eWaitState, void*>(this, waitState, arg1);
0AA6: call_method 0x4F28A0 struct [CPed] num_params 2 pop 0 [waitState] [arg1]
</pre>

#### CPed::SetWanderPath

<pre>
plugin::CallMethod<0x4FACC0, CPed *, signed>(this, arg0);
0AA6: call_method 0x4FACC0 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::Solicit

<pre>
plugin::CallMethod<0x4F11D0, CPed *>(this);
0AA6: call_method 0x4F11D0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::SortPeds

<pre>
plugin::CallMethod<0x50D120, CPed *, CPed**, int, int>(this, pedList, arg1, arg2);
0AA6: call_method 0x50D120 struct [CPed] num_params 3 pop 0 [pedList] [arg1] [arg2]
</pre>

#### CPed::SpawnFlyingComponent

<pre>
plugin::CallMethod<0x5259F0, CPed *, int, char>(this, arg0, arg1);
0AA6: call_method 0x5259F0 struct [CPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPed::StartFightAttack

<pre>
plugin::CallMethod<0x52AD70, CPed *, unsigned char>(this, arg0);
0AA6: call_method 0x52AD70 struct [CPed] num_params 1 pop 0 [arg0]
</pre>

#### CPed::StartFightDefend

<pre>
plugin::CallMethod<0x52A340, CPed *, unsigned char, unsigned char, unsigned char>(this, arg0, arg1, arg2);
0AA6: call_method 0x52A340 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]
</pre>

#### CPed::StopNonPartialAnims

<pre>
plugin::CallMethod<0x50CD20, CPed *>(this);
0AA6: call_method 0x50CD20 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::TurnBody

<pre>
plugin::CallMethodAndReturn<bool, 0x4FC970, CPed *>(this);
0AA8: call_method_return 0x4FC970 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Undress

<pre>
plugin::CallMethod<0x4EF030, CPed *, char const*>(this, modelName);
0AA6: call_method 0x4EF030 struct [CPed] num_params 1 pop 0 [modelName]
</pre>

#### CPed::UpdateFromLeader

<pre>
plugin::CallMethod<0x521070, CPed *>(this);
0AA6: call_method 0x521070 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::UpdatePosition

<pre>
plugin::CallMethod<0x50A040, CPed *>(this);
0AA6: call_method 0x50A040 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::UseGroundColModel

<pre>
plugin::CallMethodAndReturn<bool, 0x501900, CPed *>(this);
0AA8: call_method_return 0x501900 struct [CPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPed::Wait

<pre>
plugin::CallMethod<0x4F18A0, CPed *>(this);
0AA6: call_method 0x4F18A0 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::WanderPath

<pre>
plugin::CallMethod<0x4FA680, CPed *>(this);
0AA6: call_method 0x4FA680 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::WarpPedIntoCar

<pre>
plugin::CallMethod<0x4EF8B0, CPed *, CVehicle*>(this, vehicle);
0AA6: call_method 0x4EF8B0 struct [CPed] num_params 1 pop 0 [vehicle]
</pre>

#### CPed::WarpPedToNearEntityOffScreen

<pre>
plugin::CallMethod<0x5110C0, CPed *, CEntity*>(this, entity);
0AA6: call_method 0x5110C0 struct [CPed] num_params 1 pop 0 [entity]
</pre>

#### CPed::WarpPedToNearLeaderOffScreen

<pre>
plugin::CallMethod<0x511480, CPed *>(this);
0AA6: call_method 0x511480 struct [CPed] num_params 0 pop 0
</pre>

#### CPed::WillChat

<pre>
plugin::CallMethodAndReturn<bool, 0x50AC70, CPed *, CPed*>(this, ped);
0AA8: call_method_return 0x50AC70 struct [CPed] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPed::WorkOutHeadingForMovingFirstPerson

<pre>
plugin::CallMethodAndReturn<float, 0x50A530, CPed *, float>(this, heading);
0AA8: call_method_return 0x50A530 struct [CPed] num_params 1 pop 0 [heading] func_ret [float]
</pre>

#### CPed::operator delete

<pre>
plugin::Call<0x50DA20, void*>(data);
0AA5: call_function 0x50DA20 num_params 1 pop 1 [data]
</pre>

#### CPed::operator new

<pre>
plugin::CallAndReturn<void*, 0x50DA60, unsigned int>(size);
0AA7: call_function_return 0x50DA60 num_params 1 pop 1 [size] func_ret [void*]
</pre>

#### CPed::operator new

<pre>
plugin::CallAndReturn<void*, 0x50DA40, unsigned int, int>(size, arg1);
0AA7: call_function_return 0x50DA40 num_params 2 pop 2 [size] [arg1] func_ret [void*]
</pre>

#### plugin::dummy, plugin

<pre>
plugin::CallMethod<0x50DC20, CPed *, ePedType>(this, pedType);
0AA6: call_method 0x50DC20 struct [plugin] num_params 1 pop 0 [pedType]
</pre>

### plugin_vc\game_vc\CPedAtmAttractor.cpp

#### CPedAtmAttractor::GetType

<pre>
plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedAtmAttractor *>(this);
</pre>

#### CPedAtmAttractor::UpdatePedStateOnDeparture

<pre>
plugin::CallVirtualMethod<3, CPedAtmAttractor *, CPed *>(this, ped);
</pre>

### plugin_vc\game_vc\CPedAttractor.cpp

#### CPedAttractor::GetHeadOfQueueWaitTime

<pre>
plugin::CallVirtualMethodAndReturn<float, 0, CPedAttractor *>(this);
</pre>

#### CPedAttractor::IsAtHeadOfQueue

<pre>
plugin::CallVirtualMethodAndReturn<bool, 4, CPedAttractor *, CPed *>(this, ped);
</pre>

#### CPedAttractor::ComputeAttractPos

<pre>
plugin::CallVirtualMethod<5, CPedAttractor *, int, CVector &>(this, qid, pos);
</pre>

#### CPedAttractor::ComputeAttractHeading

<pre>
plugin::CallVirtualMethod<6, CPedAttractor *, int, float &>(this, qid, heading);
</pre>

#### CPedAttractor::BroadcastDeparture

<pre>
plugin::CallVirtualMethodAndReturn<bool, 7, CPedAttractor *, CPed *>(this, ped);
</pre>

#### CPedAttractor::BroadcastArrival

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::BroadcastArrival), this, ped);
0AA8: call_method_return 0x62C940 struct [CPedAttractor] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedAttractor::DeRegisterPed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::DeRegisterPed), this, ped);
0AA8: call_method_return 0x62CA40 struct [CPedAttractor] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CPedAttractor::GetNoOfRegisteredPeds

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPedAttractor *>(gaddrof(CPedAttractor::GetNoOfRegisteredPeds), this);
0AA8: call_method_return 0x62DD60 struct [CPedAttractor] num_params 0 pop 0 func_ret [int]
</pre>

#### CPedAttractor::RegisterPed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::RegisterPed), this, ped);
0AA8: call_method_return 0x62CB80 struct [CPedAttractor] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

### plugin_vc\game_vc\CPedAttractorManager.cpp

#### CPedAttractorManager::BroadcastArrival

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof_o(CPedAttractorManager::BroadcastArrival, bool (CPedAttractorManager::*)(CPed *, CPedAttractor *)), this, ped, attr);
0AA8: call_method_return 0x62B370 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]
</pre>

#### CPedAttractorManager::BroadcastDeparture

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof_o(CPedAttractorManager::BroadcastDeparture, bool (CPedAttractorManager::*)(CPed *, CPedAttractor *)), this, ped, attr);
0AA8: call_method_return 0x62B240 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]
</pre>

#### CPedAttractorManager::DeRegisterPed

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof_o(CPedAttractorManager::DeRegisterPed, bool (CPedAttractorManager::*)(CPed *, CPedAttractor *)), this, ped, attr);
0AA8: call_method_return 0x62B3D0 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]
</pre>

#### CPedAttractorManager::HasEmptySlot

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, C2dEffect const *>(gaddrof(CPedAttractorManager::HasEmptySlot), this, effect);
0AA8: call_method_return 0x62B0F0 struct [CPedAttractorManager] num_params 1 pop 0 [effect] func_ret [bool]
</pre>

#### CPedAttractorManager::IsAtHeadOfQueue

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof(CPedAttractorManager::IsAtHeadOfQueue), this, ped, attr);
0AA8: call_method_return 0x62BEF0 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]
</pre>

#### CPedAttractorManager::IsInQueue

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof(CPedAttractorManager::IsInQueue), this, ped, attr);
0AA8: call_method_return 0x62BC40 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]
</pre>

#### CPedAttractorManager::IsPedRegisteredWithEffect

<pre>
plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *>(gaddrof(CPedAttractorManager::IsPedRegisteredWithEffect), this, ped);
0AA8: call_method_return 0x62B860 struct [CPedAttractorManager] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### \*CPedAttractorManager::RegisterPedWithAttractor

<pre>
plugin::CallMethodAndReturnDynGlobal<CPedAttractor *, CPedAttractorManager *, CPed *, C2dEffect *, CMatrix const &>(gaddrof(CPedAttractorManager::RegisterPedWithAttractor), this, ped, effect, matrix);
0AA8: call_method_return 0x62C3A0 struct [*CPedAttractorManager] num_params 3 pop 0 [ped] [effect] [matrix] func_ret [CPedAttractor *]
</pre>

#### CPedAttractorManager::BroadcastArrival

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &>(gaddrof_o(CPedAttractorManager::BroadcastArrival, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &)), ped, attr, vecAttractors);
</pre>

#### CPedAttractorManager::BroadcastDeparture

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &>(gaddrof_o(CPedAttractorManager::BroadcastDeparture, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &)), ped, attr, vecAttractors);
</pre>

#### CPedAttractorManager::ComputeEffectPos

<pre>
plugin::CallDynGlobal<C2dEffect const *, CMatrix const &, CVector &>(gaddrof(CPedAttractorManager::ComputeEffectPos), effect, matrix, pos);
</pre>

#### CPedAttractorManager::DeRegisterPed

<pre>
plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &>(gaddrof_o(CPedAttractorManager::DeRegisterPed, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &)), ped, attr, vecAttractors);
</pre>

#### CPedAttractorManager::IsApproachable

<pre>
plugin::CallAndReturnDynGlobal<bool, C2dEffect *, CMatrix const &, int, CPed *>(gaddrof(CPedAttractorManager::IsApproachable), effect, matrix, unk, ped);
</pre>

#### \*CPedAttractorManager::RegisterPed

<pre>
plugin::CallAndReturnDynGlobal<CPedAttractor *, CPed *, C2dEffect *, CMatrix const &, std::vector<CPedAttractor *> &>(gaddrof(CPedAttractorManager::RegisterPed), ped, effect, matrix, vecAttractors);
</pre>

#### \*GetPedAttractorManager

<pre>
plugin::CallAndReturnDynGlobal<CPedAttractorManager *>(gaddrof(GetPedAttractorManager));
</pre>

### plugin_vc\game_vc\CPedIceCreamVanAttractor.cpp

#### CPedIceCreamVanAttractor::GetType

<pre>
plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedIceCreamVanAttractor *>(this);
</pre>

#### CPedIceCreamVanAttractor::UpdatePedStateOnDeparture

<pre>
plugin::CallVirtualMethod<3, CPedIceCreamVanAttractor *, CPed *>(this, ped);
</pre>

### plugin_vc\game_vc\CPedIK.cpp

#### CPedIK::MoveLimb

<pre>
plugin::CallMethodAndReturn<MoveLimbResult, 0x52F6E0, CPedIK*, LimbOrientation&, float, float, LimbMovementInfo&>(this, limb, yaw, pitch, moveInfo);
0AA8: call_method_return 0x52F6E0 struct [CPedIK] num_params 4 pop 0 [limb] [yaw] [pitch] [moveInfo] func_ret [MoveLimbResult]
</pre>

#### CPedIK::GetComponentPosition

<pre>
plugin::CallMethod<0x52F9B0, CPedIK*, RwV3d&, unsigned int>(this, returnedPos, boneIndex);
0AA6: call_method 0x52F9B0 struct [CPedIK] num_params 2 pop 0 [returnedPos] [boneIndex]
</pre>

#### CPedIK::ExtractYawAndPitchWorld

<pre>
plugin::CallMethod<0x52F830, CPedIK*, RwMatrix*, float*, float*>(this, matrix, yaw, pitch);
0AA6: call_method 0x52F830 struct [CPedIK] num_params 3 pop 0 [matrix] [yaw] [pitch]
</pre>

### plugin_vc\game_vc\CPedModelInfo.cpp

#### CPedModelInfo::AnimatePedColModelSkinned

<pre>
plugin::CallMethod<0x566150, CPedModelInfo *, RpClump*>(this, clump);
0AA6: call_method 0x566150 struct [CPedModelInfo] num_params 1 pop 0 [clump]
</pre>

#### CPedModelInfo::AnimatePedColModelSkinnedWorld

<pre>
plugin::CallMethod<0x566060, CPedModelInfo *, RpClump*>(this, clump);
0AA6: call_method 0x566060 struct [CPedModelInfo] num_params 1 pop 0 [clump]
</pre>

#### CPedModelInfo::CreateHitColModelSkinned

<pre>
plugin::CallMethod<0x566300, CPedModelInfo *, RpClump*>(this, clump);
0AA6: call_method 0x566300 struct [CPedModelInfo] num_params 1 pop 0 [clump]
</pre>

#### CPedModelInfo::CPedModelInfo

<pre>
plugin::CallMethod<0x560120, CPedModelInfo *>(this);
0AA6: call_method 0x560120 struct [CPedModelInfo] num_params 0 pop 0
</pre>

#### CPedModelInfo::~CPedModelInfo

<pre>
plugin::CallMethod<0x5600E0, CPedModelInfo *>(this);
0AA6: call_method 0x5600E0 struct [CPedModelInfo] num_params 0 pop 0
</pre>

#### PedModelStore::~PedModelStore

<pre>
plugin::CallMethod<0x5600C0, PedModelStore *>(this);
0AA6: call_method 0x5600C0 struct [PedModelStore] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CPedPizzaAttractor.cpp

#### CPedPizzaAttractor::GetHeadOfQueueWaitTime

<pre>
plugin::CallVirtualMethodAndReturn<float, 0, CPedPizzaAttractor *>(this);
</pre>

#### CPedPizzaAttractor::GetType

<pre>
plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedPizzaAttractor *>(this);
</pre>

#### CPedPizzaAttractor::UpdatePedStateOnDeparture

<pre>
plugin::CallVirtualMethod<3, CPedPizzaAttractor *, CPed *>(this, ped);
</pre>

### plugin_vc\game_vc\CPedPlacement.cpp

#### CPedPlacement::FindZCoorForPed

<pre>
plugin::CallAndReturn<bool, 0x52FA60, CVector*>(posn);
0AA7: call_function_return 0x52FA60 num_params 1 pop 1 [posn] func_ret [bool]
</pre>

#### CPedPlacement::IsPositionClearForPed

<pre>
plugin::CallAndReturn<bool, 0x52FBD0, CVector const&, float, int, CEntity**>(posn, arg1, arg2, entity);
0AA7: call_function_return 0x52FBD0 num_params 4 pop 4 [posn] [arg1] [arg2] [entity] func_ret [bool]
</pre>

#### CPedPlacement::IsPositionClearOfCars

<pre>
plugin::CallAndReturn<bool, 0x52FBA0, CVector*>(posn);
0AA7: call_function_return 0x52FBA0 num_params 1 pop 1 [posn] func_ret [bool]
</pre>

### plugin_vc\game_vc\CPedSeatAttractor.cpp

#### CPedSeatAttractor::GetType

<pre>
plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedSeatAttractor *>(this);
</pre>

#### CPedSeatAttractor::UpdatePedStateOnDeparture

<pre>
plugin::CallVirtualMethod<3, CPedSeatAttractor *, CPed *>(this, ped);
</pre>

### plugin_vc\game_vc\CPedShelterAttractor.cpp

#### CPedShelterAttractor::GetType

<pre>
plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedShelterAttractor *>(this);
</pre>

#### CPedShelterAttractor::UpdatePedStateOnDeparture

<pre>
plugin::CallVirtualMethod<3, CPedShelterAttractor *, CPed *>(this, ped);
</pre>

#### CPedShelterAttractor::IsAtHeadOfQueue

<pre>
plugin::CallVirtualMethodAndReturn<bool, 4, CPedShelterAttractor *, CPed *>(this, ped);
</pre>

#### CPedShelterAttractor::ComputeAttractPos

<pre>
plugin::CallVirtualMethod<5, CPedShelterAttractor *, int, CVector &>(this, qid, pos);
</pre>

#### CPedShelterAttractor::ComputeAttractHeading

<pre>
plugin::CallVirtualMethod<6, CPedShelterAttractor *, int, float &>(this, qid, heading);
</pre>

#### CPedShelterAttractor::BroadcastDeparture

<pre>
plugin::CallVirtualMethodAndReturn<bool, 7, CPedShelterAttractor *, CPed *>(this, ped);
</pre>

### plugin_vc\game_vc\CPedStats.cpp

#### CPedStats::Initialise

<pre>
plugin::Call<0x530260>();
0AA5: call_function 0x530260 num_params 0 pop 0
</pre>

#### CPedStats::Shutdown

<pre>
plugin::Call<0x530220>();
0AA5: call_function 0x530220 num_params 0 pop 0
</pre>

#### CPedStats::LoadPedStats

<pre>
plugin::Call<0x530020>();
0AA5: call_function 0x530020 num_params 0 pop 0
</pre>

#### CPedStats::GetPedStatType

<pre>
plugin::CallAndReturn<unsigned int, 0x52FFC0, char*>(pedStatName);
0AA7: call_function_return 0x52FFC0 num_params 1 pop 1 [pedStatName] func_ret [unsigned int]
</pre>

### plugin_vc\game_vc\CPedStopAttractor.cpp

#### CPedStopAttractor::GetType

<pre>
plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedStopAttractor *>(this);
</pre>

#### CPedStopAttractor::UpdatePedStateOnDeparture

<pre>
plugin::CallVirtualMethod<3, CPedStopAttractor *, CPed *>(this, ped);
</pre>

### plugin_vc\game_vc\CPedType.cpp

#### CPedType::Initialise

<pre>
plugin::Call<0x530F00>();
0AA5: call_function 0x530F00 num_params 0 pop 0
</pre>

#### CPedType::Shutdown

<pre>
plugin::Call<0x530EC0>();
0AA5: call_function 0x530EC0 num_params 0 pop 0
</pre>

#### CPedType::LoadPedData

<pre>
plugin::Call<0x530B90>();
0AA5: call_function 0x530B90 num_params 0 pop 0
</pre>

#### CPedType::FindPedType

<pre>
plugin::CallAndReturn<unsigned int, 0x530860, char*>(pedName);
0AA7: call_function_return 0x530860 num_params 1 pop 1 [pedName] func_ret [unsigned int]
</pre>

#### CPedType::FindPedFlag

<pre>
plugin::CallAndReturn<unsigned int, 0x530480, char*>(flagName);
0AA7: call_function_return 0x530480 num_params 1 pop 1 [flagName] func_ret [unsigned int]
</pre>

#### CPedType::Save

<pre>
plugin::Call<0x5303D0, unsigned char*, unsigned int*>(bufferPointer, structSize);
0AA5: call_function 0x5303D0 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CPedType::Load

<pre>
plugin::Call<0x530340, unsigned char*, unsigned int>(bufferPointer, structSize);
0AA5: call_function 0x530340 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

### plugin_vc\game_vc\CPhoneInfo.cpp

#### CPhoneInfo::FindNearestFreePhone

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, CVector *>(gaddrof(CPhoneInfo::FindNearestFreePhone), this, point);
0AA8: call_method_return 0x43CBD0 struct [CPhoneInfo] num_params 1 pop 0 [point] func_ret [int]
</pre>

#### CPhoneInfo::GrabPhone

<pre>
plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, float, float>(gaddrof(CPhoneInfo::GrabPhone), this, x, y);
0AA8: call_method_return 0x43C490 struct [CPhoneInfo] num_params 2 pop 0 [x] [y] func_ret [int]
</pre>

#### CPhoneInfo::Initialise

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Initialise), this);
0AA6: call_method 0x43CC60 struct [CPhoneInfo] num_params 0 pop 0
</pre>

#### CPhoneInfo::Load

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int>(gaddrof(CPhoneInfo::Load), this, bufferPointer, structSize);
0AA6: call_method 0x43C2B0 struct [CPhoneInfo] num_params 2 pop 0 [bufferPointer] [structSize]
</pre>

#### CPhoneInfo::Save

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int *>(gaddrof(CPhoneInfo::Save), this, bufferPointer, structSize);
0AA6: call_method 0x43C370 struct [CPhoneInfo] num_params 2 pop 0 [bufferPointer] [structSize]
</pre>

#### CPhoneInfo::SetPhoneMessage_JustOnce

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_JustOnce), this, index, text_1, text_2, text_3, text_4, text_5, text_6);
0AA6: call_method 0x43C430 struct [CPhoneInfo] num_params 7 pop 0 [index] [text_1] [text_2] [text_3] [text_4] [text_5] [text_6]
</pre>

#### CPhoneInfo::Shutdown

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Shutdown), this);
0AA6: call_method 0x43CC50 struct [CPhoneInfo] num_params 0 pop 0
</pre>

#### CPhoneInfo::Update

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Update), this);
0AA6: call_method 0x43C600 struct [CPhoneInfo] num_params 0 pop 0
</pre>

#### PhonePutDownCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, CPed *>(gaddrof(PhonePutDownCB), association, ped);
</pre>

#### PhonePickUpCB

<pre>
plugin::CallDynGlobal<CAnimBlendAssociation *, CPhone *>(gaddrof(PhonePickUpCB), association, phone);
</pre>

### plugin_vc\game_vc\CPickups.cpp

#### CPickup::GiveUsAPickUpObject

<pre>
plugin::CallMethodAndReturn<int, 0x43D3B0, CPickup *, CObject**, CObject**, int, int>(this, arg0, arg1, arg2, arg3);
0AA8: call_method_return 0x43D3B0 struct [CPickup] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3] func_ret [int]
</pre>

#### CPickup::Update

<pre>
plugin::CallMethod<0x440030, CPickup *, CPlayerPed*, CVehicle*, int>(this, arg0, vehicle, arg2);
0AA6: call_method 0x440030 struct [CPickup] num_params 3 pop 0 [arg0] [vehicle] [arg2]
</pre>

#### CPickup::CPickup

<pre>
plugin::CallMethod<0x441F30, CPickup *>(this);
0AA6: call_method 0x441F30 struct [CPickup] num_params 0 pop 0
</pre>

#### CPickups::CreateSomeMoney

<pre>
plugin::Call<0x43E180, CVector, int>(posn, arg1);
0AA5: call_function 0x43E180 num_params 2 pop 2 [posn] [arg1]
</pre>

#### CPickups::DoCollectableEffects

<pre>
plugin::Call<0x43ED40, CEntity*>(entity);
0AA5: call_function 0x43ED40 num_params 1 pop 1 [entity]
</pre>

#### CPickups::DoMineEffects

<pre>
plugin::Call<0x43E840, CEntity*>(entity);
0AA5: call_function 0x43E840 num_params 1 pop 1 [entity]
</pre>

#### CPickups::DoMoneyEffects

<pre>
plugin::Call<0x43EAC0, CEntity*>(entity);
0AA5: call_function 0x43EAC0 num_params 1 pop 1 [entity]
</pre>

#### CPickups::DoPickUpEffects

<pre>
plugin::Call<0x43F050, CEntity*>(entity);
0AA5: call_function 0x43F050 num_params 1 pop 1 [entity]
</pre>

#### CPickups::GenerateNewOne

<pre>
plugin::CallAndReturn<int, 0x4418C0, CVector, unsigned int, unsigned char, unsigned int, unsigned int, bool, char*>(posn, arg1, arg2, arg3, arg4, arg5, msg);
0AA7: call_function_return 0x4418C0 num_params 7 pop 7 [posn] [arg1] [arg2] [arg3] [arg4] [arg5] [msg] func_ret [int]
</pre>

#### CPickups::GetActualPickupIndex

<pre>
plugin::CallAndReturn<int, 0x43D360, int>(handle);
0AA7: call_function_return 0x43D360 num_params 1 pop 1 [handle] func_ret [int]
</pre>

#### CPickups::GivePlayerGoodiesWithPickUpMI

<pre>
plugin::CallAndReturn<bool, 0x43D910, unsigned short, int>(model, plrIndex);
0AA7: call_function_return 0x43D910 num_params 2 pop 2 [model] [plrIndex] func_ret [bool]
</pre>

#### CPickups::Init

<pre>
plugin::Call<0x441D30>();
0AA5: call_function 0x441D30 num_params 0 pop 0
</pre>

#### CPickups::IsPickUpPickedUp

<pre>
plugin::CallAndReturn<bool, 0x441880, int>(handle);
0AA7: call_function_return 0x441880 num_params 1 pop 1 [handle] func_ret [bool]
</pre>

#### CPickups::Load

<pre>
plugin::Call<0x43CF40, unsigned char*, unsigned int>(arg0, arg1);
0AA5: call_function 0x43CF40 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CPickups::ModelForWeapon

<pre>
plugin::CallAndReturn<int, 0x4418B0, eWeaponType>(weaponType);
0AA7: call_function_return 0x4418B0 num_params 1 pop 1 [weaponType] func_ret [int]
</pre>

#### CPickups::PassTime

<pre>
plugin::Call<0x43D8C0, unsigned int>(time);
0AA5: call_function 0x43D8C0 num_params 1 pop 1 [time]
</pre>

#### CPickups::RemoveAllPickupsOfACertainWeaponGroupWithNoAmmo

<pre>
plugin::Call<0x43D240, eWeaponType>(weaponType);
0AA5: call_function 0x43D240 num_params 1 pop 1 [weaponType]
</pre>

#### CPickups::RemovePickUp

<pre>
plugin::Call<0x4417D0, int>(handle);
0AA5: call_function 0x4417D0 num_params 1 pop 1 [handle]
</pre>

#### CPickups::RemoveUnnecessaryPickups

<pre>
plugin::Call<0x43E4C0, CVector const&, float>(posn, radius);
0AA5: call_function 0x43E4C0 num_params 2 pop 2 [posn] [radius]
</pre>

#### CPickups::RenderPickUpText

<pre>
plugin::Call<0x43E5E0>();
0AA5: call_function 0x43E5E0 num_params 0 pop 0
</pre>

#### CPickups::Save

<pre>
plugin::Call<0x43D0D0, unsigned char*, unsigned int*>(arg0, arg1);
0AA5: call_function 0x43D0D0 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CPickups::Update

<pre>
plugin::Call<0x441BB0>();
0AA5: call_function 0x441BB0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CPlane.cpp

#### CPlane::CPlane

<pre>
plugin::CallMethod<0x5B2B50, CPlane *, int, unsigned char>(this, modelIndex, createdBy);
0AA6: call_method 0x5B2B50 struct [CPlane] num_params 2 pop 0 [modelIndex] [createdBy]
</pre>

#### CPlane::InitPlanes

<pre>
plugin::Call<0x5B21E0>();
0AA5: call_function 0x5B21E0 num_params 0 pop 0
</pre>

#### CPlane::Load

<pre>
plugin::CallAndReturn<bool, 0x5AFAD0>();
0AA7: call_function_return 0x5AFAD0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlane::LoadPath

<pre>
plugin::Call<0x5B1FF0, char const*, int&, float&, bool>(arg0, arg1, arg2, arg3);
0AA5: call_function 0x5B1FF0 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CPlane::Save

<pre>
plugin::CallAndReturn<bool, 0x5AFB80>();
0AA7: call_function_return 0x5AFB80 num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlane::Shutdown

<pre>
plugin::Call<0x5B2160>();
0AA5: call_function 0x5B2160 num_params 0 pop 0
</pre>

#### CPlane::TestRocketCollision

<pre>
plugin::CallAndReturn<bool, 0x5AFC90, CVector*>(arg0);
0AA7: call_function_return 0x5AFC90 num_params 1 pop 1 [arg0] func_ret [bool]
</pre>

#### CPlane::UpdatePlanes

<pre>
plugin::Call<0x5B19D0>();
0AA5: call_function 0x5B19D0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CPlayerPed.cpp

#### CPlayerPed::AnnoyPlayerPed

<pre>
plugin::CallMethod<0x531CF0, CPlayerPed *, bool>(this, arg0);
0AA6: call_method 0x531CF0 struct [CPlayerPed] num_params 1 pop 0 [arg0]
</pre>

#### CPlayerPed::CPlayerPed

<pre>
plugin::CallMethod<0x5384B0, CPlayerPed *>(this);
0AA6: call_method 0x5384B0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ClearAdrenaline

<pre>
plugin::CallMethod<0x531CC0, CPlayerPed *>(this);
0AA6: call_method 0x531CC0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ClearWeaponTarget

<pre>
plugin::CallMethod<0x533B30, CPlayerPed *>(this);
0AA6: call_method 0x533B30 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DeactivatePlayerPed

<pre>
plugin::Call<0x5383C0, int>(playerId);
0AA5: call_function 0x5383C0 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::DoStuffToGoOnFire

<pre>
plugin::CallMethod<0x531D20, CPlayerPed *>(this);
0AA6: call_method 0x531D20 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::DoWeaponSmoothSpray

<pre>
plugin::CallMethodAndReturn<float, 0x536410, CPlayerPed *>(this);
0AA8: call_method_return 0x536410 struct [CPlayerPed] num_params 0 pop 0 func_ret [float]
</pre>

#### CPlayerPed::DoesPlayerWantNewWeapon

<pre>
plugin::CallMethodAndReturn<bool, 0x535240, CPlayerPed *, eWeaponType, bool>(this, weaponType, enable);
0AA8: call_method_return 0x535240 struct [CPlayerPed] num_params 2 pop 0 [weaponType] [enable] func_ret [bool]
</pre>

#### CPlayerPed::EvaluateNeighbouringTarget

<pre>
plugin::CallMethod<0x5320B0, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool, bool, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6, arg7);
0AA6: call_method 0x5320B0 struct [CPlayerPed] num_params 8 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5] [arg6] [arg7]
</pre>

#### CPlayerPed::EvaluateTarget

<pre>
plugin::CallMethod<0x532360, CPlayerPed *, CEntity*, CEntity**, float*, float, float, bool, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6);
0AA6: call_method 0x532360 struct [CPlayerPed] num_params 7 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5] [arg6]
</pre>

#### CPlayerPed::FindMeleeAttackPoint

<pre>
plugin::CallMethodAndReturn<int, 0x531390, CPlayerPed *, CPed*, CVector&, unsigned int&>(this, arg0, arg1, arg2);
0AA8: call_method_return 0x531390 struct [CPlayerPed] num_params 3 pop 0 [arg0] [arg1] [arg2] func_ret [int]
</pre>

#### CPlayerPed::FindNewAttackPoints

<pre>
plugin::CallMethodAndReturn<short, 0x531810, CPlayerPed *>(this);
0AA8: call_method_return 0x531810 struct [CPlayerPed] num_params 0 pop 0 func_ret [short]
</pre>

#### CPlayerPed::FindNextWeaponLockOnTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x532590, CPlayerPed *, CEntity*, bool>(this, target, arg1);
0AA8: call_method_return 0x532590 struct [CPlayerPed] num_params 2 pop 0 [target] [arg1] func_ret [bool]
</pre>

#### CPlayerPed::FindWeaponLockOnTarget

<pre>
plugin::CallMethodAndReturn<bool, 0x533030, CPlayerPed *>(this);
0AA8: call_method_return 0x533030 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]
</pre>

#### CPlayerPed::GetPlayerInfoForThisPlayerPed

<pre>
plugin::CallMethodAndReturn<CPlayerInfo*, 0x531D40, CPlayerPed *>(this);
0AA8: call_method_return 0x531D40 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPlayerInfo*]
</pre>

#### CPlayerPed::KeepAreaAroundPlayerClear

<pre>
plugin::CallMethod<0x531D60, CPlayerPed *>(this);
0AA6: call_method 0x531D60 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::MakeChangesForNewWeapon

<pre>
plugin::CallMethod<0x534450, CPlayerPed *, eWeaponType>(this, weaponType);
0AA6: call_method 0x534450 struct [CPlayerPed] num_params 1 pop 0 [weaponType]
</pre>

#### CPlayerPed::MakeChangesForNewWeapon

<pre>
plugin::CallMethod<0x534580, CPlayerPed *, int>(this, weaponSlot);
0AA6: call_method 0x534580 struct [CPlayerPed] num_params 1 pop 0 [weaponSlot]
</pre>

#### CPlayerPed::MakeObjectTargettable

<pre>
plugin::CallMethod<0x531FD0, CPlayerPed *, int, bool>(this, arg0, arg1);
0AA6: call_method 0x531FD0 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1]
</pre>

#### CPlayerPed::PlayIdleAnimations

<pre>
plugin::CallMethod<0x535D10, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x535D10 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControl1stPersonRunAround

<pre>
plugin::CallMethod<0x5357D0, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x5357D0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlFighter

<pre>
plugin::CallMethod<0x535BB0, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x535BB0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlM16

<pre>
plugin::CallMethod<0x5352B0, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x5352B0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlSniper

<pre>
plugin::CallMethod<0x535550, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x535550 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::PlayerControlZelda

<pre>
plugin::CallMethod<0x535F40, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x535F40 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ProcessAnimGroups

<pre>
plugin::CallMethod<0x533B80, CPlayerPed *>(this);
0AA6: call_method 0x533B80 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ProcessPlayerWeapon

<pre>
plugin::CallMethod<0x534890, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x534890 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ProcessWeaponSwitch

<pre>
plugin::CallMethod<0x5345A0, CPlayerPed *, CPad*>(this, pad);
0AA6: call_method 0x5345A0 struct [CPlayerPed] num_params 1 pop 0 [pad]
</pre>

#### CPlayerPed::ReApplyMoveAnims

<pre>
plugin::CallMethod<0x5371B0, CPlayerPed *>(this);
0AA6: call_method 0x5371B0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::ReactivatePlayerPed

<pre>
plugin::Call<0x5383A0, int>(playerId);
0AA5: call_function 0x5383A0 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::RemovePedFromMeleeList

<pre>
plugin::CallMethod<0x5312A0, CPlayerPed *, CPed*>(this, ped);
0AA6: call_method 0x5312A0 struct [CPlayerPed] num_params 1 pop 0 [ped]
</pre>

#### CPlayerPed::SetInitialState

<pre>
plugin::CallMethod<0x5381F0, CPlayerPed *>(this);
0AA6: call_method 0x5381F0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetNearbyPedsToInteractWithPlayer

<pre>
plugin::CallMethod<0x530FB0, CPlayerPed *>(this);
0AA6: call_method 0x530FB0 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetRealMoveAnim

<pre>
plugin::CallMethod<0x536620, CPlayerPed *>(this);
0AA6: call_method 0x536620 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::SetWantedLevel

<pre>
plugin::CallMethod<0x532090, CPlayerPed *, int>(this, level);
0AA6: call_method 0x532090 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::SetWantedLevelNoDrop

<pre>
plugin::CallMethod<0x532070, CPlayerPed *, int>(this, level);
0AA6: call_method 0x532070 struct [CPlayerPed] num_params 1 pop 0 [level]
</pre>

#### CPlayerPed::SetupPlayerPed

<pre>
plugin::Call<0x5383E0, int>(playerId);
0AA5: call_function 0x5383E0 num_params 1 pop 1 [playerId]
</pre>

#### CPlayerPed::UpdateMeleeAttackers

<pre>
plugin::CallMethod<0x531600, CPlayerPed *>(this);
0AA6: call_method 0x531600 struct [CPlayerPed] num_params 0 pop 0
</pre>

#### CPlayerPed::GetWantedLevel

<pre>
plugin::CallMethodAndReturn<int, 0x599B20, CPlayerPed *>(this);
0AA8: call_method_return 0x599B20 struct [CPlayerPed] num_params 0 pop 0 func_ret [int]
</pre>

### plugin_vc\game_vc\CPlayerSkin.cpp

#### CPlayerSkin::BeginFrontendSkinEdit

<pre>
plugin::Call<0x627D10>();
0AA5: call_function 0x627D10 num_params 0 pop 0
</pre>

#### CPlayerSkin::EndFrontendSkinEdit

<pre>
plugin::Call<0x627CE0>();
0AA5: call_function 0x627CE0 num_params 0 pop 0
</pre>

#### CPlayerSkin::GetSkinTexture

<pre>
plugin::CallAndReturn<int, 0x627E60, char const*>(arg0);
0AA7: call_function_return 0x627E60 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CPlayerSkin::Initialise

<pre>
plugin::Call<0x627FB0>();
0AA5: call_function 0x627FB0 num_params 0 pop 0
</pre>

#### CPlayerSkin::RenderFrontendSkinEdit

<pre>
plugin::Call<0x627BC0>();
0AA5: call_function 0x627BC0 num_params 0 pop 0
</pre>

#### CPlayerSkin::Shutdown

<pre>
plugin::Call<0x627FA0>();
0AA5: call_function 0x627FA0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CPointLights.cpp

#### CPointLights::AddLight

<pre>
plugin::CallDynGlobal<unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool>(gaddrof(CPointLights::AddLight), lightType, point, direction, range, red, green, blue, fogType, generateExtraShadows);
</pre>

#### CPointLights::GenerateLightsAffectingObject

<pre>
plugin::CallAndReturnDynGlobal<float, CVector *>(gaddrof(CPointLights::GenerateLightsAffectingObject), point);
</pre>

### plugin_vc\game_vc\CPools.cpp

#### \*CPools::GetObject

<pre>
plugin::CallAndReturnDynGlobal<CObject *, int>(gaddrof(CPools::GetObject), handle);
</pre>

#### CPools::GetObjectRef

<pre>
plugin::CallAndReturnDynGlobal<int, CObject *>(gaddrof(CPools::GetObjectRef), object);
</pre>

#### \*CPools::GetPed

<pre>
plugin::CallAndReturnDynGlobal<CPed *, int>(gaddrof(CPools::GetPed), handle);
</pre>

#### CPools::GetPedRef

<pre>
plugin::CallAndReturnDynGlobal<int, CPed *>(gaddrof(CPools::GetPedRef), ped);
</pre>

#### \*CPools::GetVehicle

<pre>
plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CPools::GetVehicle), handle);
</pre>

#### CPools::GetVehicleRef

<pre>
plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CPools::GetVehicleRef), vehicle);
</pre>

#### CPools::LoadObjectPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadObjectPool), buffer, size);
</pre>

#### CPools::LoadPedPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadPedPool), buffer, size);
</pre>

#### CPools::LoadVehiclePool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadVehiclePool), buffer, size);
</pre>

#### CPools::MakeSureSlotInObjectPoolIsEmpty

<pre>
plugin::CallDynGlobal<int>(gaddrof(CPools::MakeSureSlotInObjectPoolIsEmpty), slot);
</pre>

#### CPools::SaveObjectPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveObjectPool), buffer, outSize);
</pre>

#### CPools::SavePedPool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SavePedPool), buffer, outSize);
</pre>

#### CPools::SaveVehiclePool

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveVehiclePool), buffer, outSize);
</pre>

### plugin_vc\game_vc\CPopulation.cpp

#### CPopulation::AddDeadPedInFrontOfCar

<pre>
plugin::CallAndReturn<CPed*, 0x53B180, CVector const&, CVehicle*>(posn, vehicle);
0AA7: call_function_return 0x53B180 num_params 2 pop 2 [posn] [vehicle] func_ret [CPed*]
</pre>

#### CPopulation::AddPed

<pre>
plugin::CallAndReturn<CPed*, 0x53B600, ePedType, unsigned int, CVector const&, int>(pedType, modelIndex, posn, arg3);
0AA7: call_function_return 0x53B600 num_params 4 pop 4 [pedType] [modelIndex] [posn] [arg3] func_ret [CPed*]
</pre>

#### CPopulation::AddPedInCar

<pre>
plugin::CallAndReturn<CPed*, 0x53A8A0, CVehicle*, bool>(vehicle, driver);
0AA7: call_function_return 0x53A8A0 num_params 2 pop 2 [vehicle] [driver] func_ret [CPed*]
</pre>

#### CPopulation::AddToPopulation

<pre>
plugin::Call<0x53BA80, float, float, float, float>(arg0, arg1, arg2, arg3);
0AA5: call_function 0x53BA80 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CPopulation::CanJeerAtStripper

<pre>
plugin::CallAndReturn<bool, 0x53A670, int>(modelIndex);
0AA7: call_function_return 0x53A670 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopulation::CanSolicitPlayerInCar

<pre>
plugin::CallAndReturn<bool, 0x53A6A0, int>(modelIndex);
0AA7: call_function_return 0x53A6A0 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopulation::CanSolicitPlayerOnFoot

<pre>
plugin::CallAndReturn<bool, 0x53A6C0, int>(modelIndex);
0AA7: call_function_return 0x53A6C0 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopulation::ChooseCivilianCoupleOccupations

<pre>
plugin::Call<0x53AE90, int, int&, int&>(arg0, arg1, arg2);
0AA5: call_function 0x53AE90 num_params 3 pop 3 [arg0] [arg1] [arg2]
</pre>

#### CPopulation::ChooseCivilianOccupation

<pre>
plugin::CallAndReturn<int, 0x53B070, int>(arg0);
0AA7: call_function_return 0x53B070 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CPopulation::ChooseNextCivilianOccupation

<pre>
plugin::CallAndReturn<int, 0x53AFD0, int>(arg0);
0AA7: call_function_return 0x53AFD0 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CPopulation::ConvertAllObjectsToDummyObjects

<pre>
plugin::Call<0x53D430>();
0AA5: call_function 0x53D430 num_params 0 pop 0
</pre>

#### CPopulation::ConvertToDummyObject

<pre>
plugin::Call<0x53D290, CObject*>(object);
0AA5: call_function 0x53D290 num_params 1 pop 1 [object]
</pre>

#### CPopulation::ConvertToRealObject

<pre>
plugin::Call<0x53D340, CDummyObject*>(dummyObject);
0AA5: call_function 0x53D340 num_params 1 pop 1 [dummyObject]
</pre>

#### CPopulation::GeneratePedsAtStartOfGame

<pre>
plugin::Call<0x53E3E0>();
0AA5: call_function 0x53E3E0 num_params 0 pop 0
</pre>

#### CPopulation::Initialise

<pre>
plugin::Call<0x53EAF0>();
0AA5: call_function 0x53EAF0 num_params 0 pop 0
</pre>

#### CPopulation::IsFemale

<pre>
plugin::CallAndReturn<bool, 0x53AD50, int>(modelIndex);
0AA7: call_function_return 0x53AD50 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopulation::IsMale

<pre>
plugin::CallAndReturn<bool, 0x53ADF0, int>(modelIndex);
0AA7: call_function_return 0x53ADF0 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopulation::IsSkateable

<pre>
plugin::CallAndReturn<bool, 0x53ACA0, CVector const&>(point);
0AA7: call_function_return 0x53ACA0 num_params 1 pop 1 [point] func_ret [bool]
</pre>

#### CPopulation::IsSunbather

<pre>
plugin::CallAndReturn<bool, 0x53A6F0, int>(modelIndex);
0AA7: call_function_return 0x53A6F0 num_params 1 pop 1 [modelIndex] func_ret [bool]
</pre>

#### CPopulation::LoadPedGroups

<pre>
plugin::Call<0x53E9C0>();
0AA5: call_function 0x53E9C0 num_params 0 pop 0
</pre>

#### CPopulation::ManagePopulation

<pre>
plugin::Call<0x53D690>();
0AA5: call_function 0x53D690 num_params 0 pop 0
</pre>

#### CPopulation::PlaceCouple

<pre>
plugin::Call<0x5388F0, ePedType, int, ePedType, int, CVector>(pedType1, modelIndex1, pedType2, modelIndex2, posn);
0AA5: call_function 0x5388F0 num_params 5 pop 5 [pedType1] [modelIndex1] [pedType2] [modelIndex2] [posn]
</pre>

#### CPopulation::PlaceGangMembersInCircle

<pre>
plugin::Call<0x5397F0, ePedType, int, CVector const&>(pedType, modelIndex, posn);
0AA5: call_function 0x5397F0 num_params 3 pop 3 [pedType] [modelIndex] [posn]
</pre>

#### CPopulation::PlaceGangMembersInFormation

<pre>
plugin::Call<0x539FC0, ePedType, int, CVector const&>(pedType, modelIndex, posn);
0AA5: call_function 0x539FC0 num_params 3 pop 3 [pedType] [modelIndex] [posn]
</pre>

#### CPopulation::PlaceMallPedsAsStationaryGroup

<pre>
plugin::Call<0x538E90, CVector const&, int>(posn, modelIndex);
0AA5: call_function 0x538E90 num_params 2 pop 2 [posn] [modelIndex]
</pre>

#### CPopulation::RemovePed

<pre>
plugin::Call<0x53B160, CPed*>(ped);
0AA5: call_function 0x53B160 num_params 1 pop 1 [ped]
</pre>

#### CPopulation::RemovePedsIfThePoolGetsFull

<pre>
plugin::Call<0x53D560>();
0AA5: call_function 0x53D560 num_params 0 pop 0
</pre>

#### CPopulation::TestSafeForRealObject

<pre>
plugin::CallAndReturn<bool, 0x53CF80, CDummyObject*>(dummyObject);
0AA7: call_function_return 0x53CF80 num_params 1 pop 1 [dummyObject] func_ret [bool]
</pre>

#### CPopulation::Update

<pre>
plugin::Call<0x53E5F0, bool>(generatePeds);
0AA5: call_function 0x53E5F0 num_params 1 pop 1 [generatePeds]
</pre>

#### CPopulation::UpdatePedCount

<pre>
plugin::Call<0x53A720, ePedType, unsigned char>(pedType, updateState);
0AA5: call_function 0x53A720 num_params 2 pop 2 [pedType] [updateState]
</pre>

### plugin_vc\game_vc\CProjectile.cpp

#### CProjectile::CProjectile

<pre>
plugin::CallMethod<0x4E8D30, CProjectile *, int>(this, arg0);
0AA6: call_method 0x4E8D30 struct [CProjectile] num_params 1 pop 0 [arg0]
</pre>

### plugin_vc\game_vc\CProjectileInfo.cpp

#### CProjectileInfo::Shutdown

<pre>
plugin::Call<0x5C7C10>();
0AA5: call_function 0x5C7C10 num_params 0 pop 0
</pre>

#### CProjectileInfo::Update

<pre>
plugin::Call<0x5C6A20>();
0AA5: call_function 0x5C6A20 num_params 0 pop 0
</pre>

#### CProjectileInfo::RemoveNotAdd

<pre>
plugin::Call<0x5C7180, CEntity*, eWeaponType, CVector>(pEntity, weapontype, posn);
0AA5: call_function 0x5C7180 num_params 3 pop 3 [pEntity] [weapontype] [posn]
</pre>

#### CProjectileInfo::RemoveIfThisIsAProjectile

<pre>
plugin::CallAndReturn<bool, 0x5C6970, CObject*>(pObject);
0AA7: call_function_return 0x5C6970 num_params 1 pop 1 [pObject] func_ret [bool]
</pre>

#### CProjectileInfo::RemoveDetonatorProjectiles

<pre>
plugin::Call<0x5C71D0>();
0AA5: call_function 0x5C71D0 num_params 0 pop 0
</pre>

#### CProjectileInfo::RemoveAllProjectiles

<pre>
plugin::Call<0x5C69D0>();
0AA5: call_function 0x5C69D0 num_params 0 pop 0
</pre>

#### CProjectileInfo::Initialise

<pre>
plugin::Call<0x5C7C30>();
0AA5: call_function 0x5C7C30 num_params 0 pop 0
</pre>

#### CProjectileInfo::GetProjectileInfo

<pre>
plugin::CallAndReturn<CProjectileInfo*, 0x5C7BF0, int>(ProjIndex);
0AA7: call_function_return 0x5C7BF0 num_params 1 pop 1 [ProjIndex] func_ret [CProjectileInfo*]
</pre>

#### CProjectileInfo::AddProjectile

<pre>
plugin::CallAndReturn<bool, 0x5C7250, CEntity*, eWeaponType, CVector, float>(pEntity, weapontype, posn, fPower);
0AA7: call_function_return 0x5C7250 num_params 4 pop 4 [pEntity] [weapontype] [posn] [fPower] func_ret [bool]
</pre>

### plugin_vc\game_vc\CQuaternion.cpp

#### CQuaternion::Get

<pre>
plugin::CallMethod<0x4DFD30, CQuaternion *, RwMatrixTag*>(this, out);
0AA6: call_method 0x4DFD30 struct [CQuaternion] num_params 1 pop 0 [out]
</pre>

#### CQuaternion::Set

<pre>
plugin::CallMethod<0x4DFE20, CQuaternion *, RwV3d*, float>(this, axis, angle);
0AA6: call_method 0x4DFE20 struct [CQuaternion] num_params 2 pop 0 [axis] [angle]
</pre>

#### CQuaternion::Slerp

<pre>
plugin::CallMethod<0x4DFBE0, CQuaternion *, CQuaternion const&, CQuaternion const&, float, float, float>(this, from, to, halftheta, sintheta_inv, t);
0AA6: call_method 0x4DFBE0 struct [CQuaternion] num_params 5 pop 0 [from] [to] [halftheta] [sintheta_inv] [t]
</pre>

### plugin_vc\game_vc\CRadar.cpp

#### CRadar::CalculateCachedSinCos

<pre>
plugin::Call<0x4C3D80>();
0AA5: call_function 0x4C3D80 num_params 0 pop 0
</pre>

#### CRadar::ChangeBlipBrightness

<pre>
plugin::Call<0x4C38B0, int, int>(i, bright);
0AA5: call_function 0x4C38B0 num_params 2 pop 2 [i] [bright]
</pre>

#### CRadar::ChangeBlipColour

<pre>
plugin::Call<0x4C3930, int, unsigned int>(i, colour);
0AA5: call_function 0x4C3930 num_params 2 pop 2 [i] [colour]
</pre>

#### CRadar::ChangeBlipDisplay

<pre>
plugin::Call<0x4C37E0, int, eBlipDisplay>(i, display);
0AA5: call_function 0x4C37E0 num_params 2 pop 2 [i] [display]
</pre>

#### CRadar::ChangeBlipScale

<pre>
plugin::Call<0x4C3840, int, int>(i, scale);
0AA5: call_function 0x4C3840 num_params 2 pop 2 [i] [scale]
</pre>

#### CRadar::ClearBlip

<pre>
plugin::Call<0x4C3990, int>(i);
0AA5: call_function 0x4C3990 num_params 1 pop 1 [i]
</pre>

#### CRadar::ClearBlipForEntity

<pre>
plugin::Call<0x4C3A70, eBlipType, int>(type, handle);
0AA5: call_function 0x4C3A70 num_params 2 pop 2 [type] [handle]
</pre>

#### CRadar::ClipRadarPoly

<pre>
plugin::CallAndReturn<int, 0x4C2280, CVector2D*, CVector2D const*>(out, in);
0AA7: call_function_return 0x4C2280 num_params 2 pop 2 [out] [in] func_ret [int]
</pre>

#### CRadar::Draw3dMarkers

<pre>
plugin::Call<0x4C3F20>();
0AA5: call_function 0x4C3F20 num_params 0 pop 0
</pre>

#### CRadar::DrawBlips

<pre>
plugin::Call<0x4C4200>();
0AA5: call_function 0x4C4200 num_params 0 pop 0
</pre>

#### CRadar::DrawCoordBlip

<pre>
plugin::Call<0x4C5680, int>(i);
0AA5: call_function 0x4C5680 num_params 1 pop 1 [i]
</pre>

#### CRadar::DrawEntityBlip

<pre>
plugin::Call<0x4C5170, int>(i);
0AA5: call_function 0x4C5170 num_params 1 pop 1 [i]
</pre>

#### CRadar::DrawLegend

<pre>
plugin::Call<0x4C4A10, int, int, int>(x, y, sprite);
0AA5: call_function 0x4C4A10 num_params 3 pop 3 [x] [y] [sprite]
</pre>

#### CRadar::DrawMap

<pre>
plugin::Call<0x4C5C60 >();
0AA5: call_function 0x4C5C60 num_params 0 pop 0
</pre>

#### CRadar::DrawRadarMap

<pre>
plugin::Call<0x4C17C0>();
0AA5: call_function 0x4C17C0 num_params 0 pop 0
</pre>

#### CRadar::DrawRadarMask

<pre>
plugin::Call<0x4C1A20>();
0AA5: call_function 0x4C1A20 num_params 0 pop 0
</pre>

#### CRadar::DrawRadarSection

<pre>
plugin::Call<0x4C1D60>();
0AA5: call_function 0x4C1D60 num_params 0 pop 0
</pre>

#### CRadar::DrawRadarSprite

<pre>
plugin::Call<0x4C2D00, unsigned short, float, float, unsigned char>(sprite, x, y, alpha);
0AA5: call_function 0x4C2D00 num_params 4 pop 4 [sprite] [x] [y] [alpha]
</pre>

#### CRadar::DrawRotatingRadarSprite

<pre>
plugin::Call<0x4C2E70, CSprite2d*, float, float, float, unsigned char>(sprite, x, y, angle, alpha);
0AA5: call_function 0x4C2E70 num_params 5 pop 5 [sprite] [x] [y] [angle] [alpha]
</pre>

#### CRadar::DrawYouAreHereSprite

<pre>
plugin::Call<0x4C2980, float, float>(x, y);
0AA5: call_function 0x4C2980 num_params 2 pop 2 [x] [y]
</pre>

#### CRadar::GetActualBlipArrayIndex

<pre>
plugin::CallAndReturn<int, 0x4C5D70, int>(i);
0AA7: call_function_return 0x4C5D70 num_params 1 pop 1 [i] func_ret [int]
</pre>

#### CRadar::GetRadarTraceColour

<pre>
plugin::CallAndReturn<unsigned int, 0x4C3050, unsigned int, bool>(colour, bright);
0AA7: call_function_return 0x4C3050 num_params 2 pop 2 [colour] [bright] func_ret [unsigned int]
</pre>

#### CRadar::InitFrontEndMap

<pre>
plugin::Call<0x4C5B30>();
0AA5: call_function 0x4C5B30 num_params 0 pop 0
</pre>

#### CRadar::Initialise

<pre>
plugin::Call<0x4C6200>();
0AA5: call_function 0x4C6200 num_params 0 pop 0
</pre>

#### CRadar::LoadAllRadarBlips

<pre>
plugin::Call<0x4C15D0, unsigned char*, unsigned int>(buf, size);
0AA5: call_function 0x4C15D0 num_params 2 pop 2 [buf] [size]
</pre>

#### CRadar::LoadTextures

<pre>
plugin::Call<0x4C5DC0>();
0AA5: call_function 0x4C5DC0 num_params 0 pop 0
</pre>

#### CRadar::RemoveRadarSections

<pre>
plugin::Call<0x4C2930>();
0AA5: call_function 0x4C2930 num_params 0 pop 0
</pre>

#### CRadar::SaveAllRadarBlips

<pre>
plugin::Call<0x4C16B0, unsigned char*, unsigned int*>(buf, size);
0AA5: call_function 0x4C16B0 num_params 2 pop 2 [buf] [size]
</pre>

#### CRadar::SetBlipSprite

<pre>
plugin::Call<0x4C3780, int, int>(i, icon);
0AA5: call_function 0x4C3780 num_params 2 pop 2 [i] [icon]
</pre>

#### CRadar::SetCoordBlip

<pre>
plugin::CallAndReturn<int, 0x4C3C80, eBlipType, CVector const&, unsigned int, eBlipDisplay>(type, pos, colour, display);
0AA7: call_function_return 0x4C3C80 num_params 4 pop 4 [type] [pos] [colour] [display] func_ret [int]
</pre>

#### CRadar::SetEntityBlip

<pre>
plugin::Call<0x4C3B40, eBlipType, int, unsigned int, eBlipDisplay>(type, handle, colour, display);
0AA5: call_function 0x4C3B40 num_params 4 pop 4 [type] [handle] [colour] [display]
</pre>

#### CRadar::SetShortRangeCoordBlip

<pre>
plugin::CallAndReturn<int, 0x4C3C00, eBlipType, CVector const&, unsigned int, eBlipDisplay>(type, pos, color, display);
0AA7: call_function_return 0x4C3C00 num_params 4 pop 4 [type] [pos] [color] [display] func_ret [int]
</pre>

#### CRadar::ShowRadarMarker

<pre>
plugin::Call<0x4C3100, CVector const&, unsigned int, float>(pos, colour, radius);
0AA5: call_function 0x4C3100 num_params 3 pop 3 [pos] [colour] [radius]
</pre>

#### CRadar::ShowRadarTraceWithHeight

<pre>
plugin::Call<0x4C32F0, float, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char>(x, y, size, red, green, blue, alpha, type);
0AA5: call_function 0x4C32F0 num_params 8 pop 8 [x] [y] [size] [red] [green] [blue] [alpha] [type]
</pre>

#### CRadar::Shutdown

<pre>
plugin::Call<0x4C6030>();
0AA5: call_function 0x4C6030 num_params 0 pop 0
</pre>

#### CRadar::StreamRadarSections

<pre>
plugin::Call<0x4C2870, int, int>(x, y);
0AA5: call_function 0x4C2870 num_params 2 pop 2 [x] [y]
</pre>

#### CRadar::StreamRadarSections

<pre>
plugin::Call<0x4C1960, CVector const&>(pos);
0AA5: call_function 0x4C1960 num_params 1 pop 1 [pos]
</pre>

### plugin_vc\game_vc\CRegisteredMotionBlurStreak.cpp

#### CRegisteredMotionBlurStreak::Render

<pre>
plugin::CallMethod<0x572660, CRegisteredMotionBlurStreak *>(this);
0AA6: call_method 0x572660 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0
</pre>

#### CRegisteredMotionBlurStreak::CRegisteredMotionBlurStreak

<pre>
plugin::CallMethod<0x575150, CRegisteredMotionBlurStreak *>(this);
0AA6: call_method 0x575150 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CRestart.cpp

#### CRestart::LoadAllRestartPoints

<pre>
plugin::Call<0x4421D0, unsigned char*, unsigned int>(bufferPointer, structSize);
0AA5: call_function 0x4421D0 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CRestart::SaveAllRestartPoints

<pre>
plugin::Call<0x4425B0, unsigned char*, unsigned int*>(bufferPointer, structSize);
0AA5: call_function 0x4425B0 num_params 2 pop 2 [bufferPointer] [structSize]
</pre>

#### CRestart::CancelOverrideRestart

<pre>
plugin::Call<0x4429D0>();
0AA5: call_function 0x4429D0 num_params 0 pop 0
</pre>

#### CRestart::OverrideNextRestart

<pre>
plugin::Call<0x4429E0, CVector const&, float>(point, angle);
0AA5: call_function 0x4429E0 num_params 2 pop 2 [point] [angle]
</pre>

#### CRestart::FindClosestPoliceRestartPoint

<pre>
plugin::Call<0x442A10, CVector const&, CVector*, float*>(point, storedPoint, storedAngle);
0AA5: call_function 0x442A10 num_params 3 pop 3 [point] [storedPoint] [storedAngle]
</pre>

#### CRestart::FindClosestHospitalRestartPoint

<pre>
plugin::Call<0x442CD0, CVector const&, CVector*, float*>(point, storedPoint, storedAngle);
0AA5: call_function 0x442CD0 num_params 3 pop 3 [point] [storedPoint] [storedAngle]
</pre>

#### CRestart::AddPoliceRestartPoint

<pre>
plugin::Call<0x442FC0, CVector const&, float>(point, angle);
0AA5: call_function 0x442FC0 num_params 2 pop 2 [point] [angle]
</pre>

#### CRestart::AddHospitalRestartPoint

<pre>
plugin::Call<0x443010, CVector const&, float>(point, angle);
0AA5: call_function 0x443010 num_params 2 pop 2 [point] [angle]
</pre>

#### CRestart::Initialise

<pre>
plugin::Call<0x443060>();
0AA5: call_function 0x443060 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CRouteNode.cpp

#### CRouteNode::AddRoutePoint

<pre>
plugin::CallDynGlobal<short, CVector>(gaddrof(CRouteNode::AddRoutePoint), route, pos);
</pre>

#### CRouteNode::GetRouteStart

<pre>
plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteStart), route);
</pre>

#### CRouteNode::GetRouteThisPointIsOn

<pre>
plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteThisPointIsOn), point);
</pre>

#### CRouteNode::RemoveRoute

<pre>
plugin::CallDynGlobal<short>(gaddrof(CRouteNode::RemoveRoute), route);
</pre>

### plugin_vc\game_vc\CRubbish.cpp

#### CRubbish::SetVisibility

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CRubbish::SetVisibility), bVisibility);
</pre>

#### CRubbish::StirUp

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CRubbish::StirUp), pVehicle);
</pre>

### plugin_vc\game_vc\CRunningScript.cpp

#### CRunningScript::Init

<pre>
plugin::CallMethod<0x450CF0, CRunningScript *>(this);
0AA6: call_method 0x450CF0 struct [CRunningScript] num_params 0 pop 0
</pre>

#### CRunningScript::ProcessOneCommand

<pre>
plugin::CallMethodAndReturn<char, 0x44FBE0, CRunningScript *>(this);
0AA8: call_method_return 0x44FBE0 struct [CRunningScript] num_params 0 pop 0 func_ret [char]
</pre>

#### CRunningScript::CollectParameters

<pre>
plugin::CallMethod<0x451010, CRunningScript *, int*, short>(this, arg0, count);
0AA6: call_method 0x451010 struct [CRunningScript] num_params 2 pop 0 [arg0] [count]
</pre>

#### CRunningScript::UpdateCompareFlag

<pre>
plugin::CallMethod<0x463F00, CRunningScript *, unsigned char>(this, flag);
0AA6: call_method 0x463F00 struct [CRunningScript] num_params 1 pop 0 [flag]
</pre>

### plugin_vc\game_vc\cSampleManager.cpp

#### cSampleManager::IsMP3RadioChannelAvailable

<pre>
plugin::CallAndReturn<bool, 0x5D80E0>();
0AA7: call_function_return 0x5D80E0 num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_vc\game_vc\CSceneEdit.cpp

#### CSceneEdit::SelectWeapon

<pre>
plugin::CallAndReturn<bool, 0x6032E0>();
0AA7: call_function_return 0x6032E0 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::SelectVehicle

<pre>
plugin::CallAndReturn<bool, 0x603520>();
0AA7: call_function_return 0x603520 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::SelectActor2

<pre>
plugin::CallAndReturn<bool, 0x603700>();
0AA7: call_function_return 0x603700 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::SelectActor

<pre>
plugin::CallAndReturn<bool, 0x603980>();
0AA7: call_function_return 0x603980 num_params 0 pop 0 func_ret [bool]
</pre>

#### CSceneEdit::PlayBack

<pre>
plugin::Call<0x603C10>();
0AA5: call_function 0x603C10 num_params 0 pop 0
</pre>

#### CSceneEdit::ProcessCommand

<pre>
plugin::Call<0x604500>();
0AA5: call_function 0x604500 num_params 0 pop 0
</pre>

#### CSceneEdit::Draw

<pre>
plugin::Call<0x605DB0>();
0AA5: call_function 0x605DB0 num_params 0 pop 0
</pre>

#### CSceneEdit::Update

<pre>
plugin::Call<0x606270>();
0AA5: call_function 0x606270 num_params 0 pop 0
</pre>

#### CSceneEdit::ReInitialise

<pre>
plugin::Call<0x6062F0>();
0AA5: call_function 0x6062F0 num_params 0 pop 0
</pre>

#### CSceneEdit::InitPlayBack

<pre>
plugin::Call<0x606470>();
0AA5: call_function 0x606470 num_params 0 pop 0
</pre>

#### CSceneEdit::Initialise

<pre>
plugin::Call<0x6065B0>();
0AA5: call_function 0x6065B0 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CShadowCamera.cpp

#### \*CShadowCamera::Create

<pre>
plugin::CallMethodAndReturnDynGlobal<RwCamera *, CShadowCamera *, int>(gaddrof(CShadowCamera::Create), this, rasterSize);
0AA8: call_method_return 0x626E70 struct [*CShadowCamera] num_params 1 pop 0 [rasterSize] func_ret [RwCamera *]
</pre>

#### CShadowCamera::Destroy

<pre>
plugin::CallMethodDynGlobal<CShadowCamera *>(gaddrof(CShadowCamera::Destroy), this);
0AA6: call_method 0x626DE0 struct [CShadowCamera] num_params 0 pop 0
</pre>

#### \*CShadowCamera::DrawOutlineBorder

<pre>
plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRGBA const &>(gaddrof(CShadowCamera::DrawOutlineBorder), this, color);
0AA8: call_method_return 0x6264D0 struct [*CShadowCamera] num_params 1 pop 0 [color] func_ret [RwRaster *]
</pre>

#### CShadowCamera::InvertRaster

<pre>
plugin::CallMethodDynGlobal<CShadowCamera *>(gaddrof(CShadowCamera::InvertRaster), this);
0AA6: call_method 0x626BD0 struct [CShadowCamera] num_params 0 pop 0
</pre>

#### \*CShadowCamera::MakeGradientRaster

<pre>
plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *>(gaddrof(CShadowCamera::MakeGradientRaster), this);
0AA8: call_method_return 0x6269F0 struct [*CShadowCamera] num_params 0 pop 0 func_ret [RwRaster *]
</pre>

#### \*CShadowCamera::RasterBlur

<pre>
plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *, int>(gaddrof(CShadowCamera::RasterBlur), this, raster, numPasses);
0AA8: call_method_return 0x626780 struct [*CShadowCamera] num_params 2 pop 0 [raster] [numPasses] func_ret [RwRaster *]
</pre>

#### \*CShadowCamera::RasterGradient

<pre>
plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *>(gaddrof(CShadowCamera::RasterGradient), this, raster);
0AA8: call_method_return 0x6266A0 struct [*CShadowCamera] num_params 1 pop 0 [raster] func_ret [RwRaster *]
</pre>

#### \*CShadowCamera::RasterResample

<pre>
plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *>(gaddrof(CShadowCamera::RasterResample), this, raster);
0AA8: call_method_return 0x626900 struct [*CShadowCamera] num_params 1 pop 0 [raster] func_ret [RwRaster *]
</pre>

#### \*CShadowCamera::Update

<pre>
plugin::CallMethodAndReturnDynGlobal<RwCamera *, CShadowCamera *, RpAtomic *>(gaddrof(CShadowCamera::Update), this, atomic);
0AA8: call_method_return 0x626D00 struct [*CShadowCamera] num_params 1 pop 0 [atomic] func_ret [RwCamera *]
</pre>

#### \*ShadowRenderCallBack

<pre>
plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(ShadowRenderCallBack), atomic, data);
</pre>

### plugin_vc\game_vc\CShinyTexts.cpp

#### CRegisteredShinyText::CRegisteredShinyText

<pre>
plugin::CallMethod<0x575130, CRegisteredShinyText *>(this);
0AA6: call_method 0x575130 struct [CRegisteredShinyText] num_params 0 pop 0
</pre>

#### CShinyTexts::Render

<pre>
plugin::Call<0x571240>();
0AA5: call_function 0x571240 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CShotInfo.cpp

#### CShotInfo::Initialise

<pre>
plugin::Call<0x5C83B0>();
0AA5: call_function 0x5C83B0 num_params 0 pop 0
</pre>

#### CShotInfo::Shutdown

<pre>
plugin::Call<0x5C8390>();
0AA5: call_function 0x5C8390 num_params 0 pop 0
</pre>

#### CShotInfo::AddShot

<pre>
plugin::CallAndReturn<bool, 0x5C8110, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, origin, target);
0AA7: call_function_return 0x5C8110 num_params 4 pop 4 [creator] [weaponType] [origin] [target] func_ret [bool]
</pre>

#### CShotInfo::Update

<pre>
plugin::Call<0x5C7E60>();
0AA5: call_function 0x5C7E60 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CSimpleModelInfo.cpp

#### CSimpleModelInfo::SetAtomic

<pre>
plugin::CallVirtualMethod<9, CSimpleModelInfo *, int, RpAtomic*>(this, atomicIndex, atomic);
</pre>

#### CSimpleModelInfo::GetAtomicFromDistance

<pre>
plugin::CallMethodAndReturn<RpAtomic*, 0x56F690, CSimpleModelInfo *, float>(this, distance);
0AA8: call_method_return 0x56F690 struct [CSimpleModelInfo] num_params 1 pop 0 [distance] func_ret [RpAtomic*]
</pre>

#### CSimpleModelInfo::GetLargestLodDistance

<pre>
plugin::CallMethodAndReturn<float, 0x56F660, CSimpleModelInfo *>(this);
0AA8: call_method_return 0x56F660 struct [CSimpleModelInfo] num_params 0 pop 0 func_ret [float]
</pre>

#### CSimpleModelInfo::GetLastAtomic

<pre>
plugin::CallMethodAndReturn<RpAtomic*, 0x56F620, CSimpleModelInfo *, float>(this, distance);
0AA8: call_method_return 0x56F620 struct [CSimpleModelInfo] num_params 1 pop 0 [distance] func_ret [RpAtomic*]
</pre>

#### CSimpleModelInfo::GetLodDistance

<pre>
plugin::CallMethodAndReturn<float, 0x56F6F0, CSimpleModelInfo *, int>(this, lodIndex);
0AA8: call_method_return 0x56F6F0 struct [CSimpleModelInfo] num_params 1 pop 0 [lodIndex] func_ret [float]
</pre>

#### CSimpleModelInfo::Init

<pre>
plugin::CallMethod<0x56F770, CSimpleModelInfo *>(this);
0AA6: call_method 0x56F770 struct [CSimpleModelInfo] num_params 0 pop 0
</pre>

#### CSimpleModelInfo::SetLodDistances

<pre>
plugin::CallMethod<0x56F600, CSimpleModelInfo *, float*>(this, distances);
0AA6: call_method 0x56F600 struct [CSimpleModelInfo] num_params 1 pop 0 [distances]
</pre>

#### CSimpleModelInfo::SetupBigBuilding

<pre>
plugin::CallMethod<0x56F420, CSimpleModelInfo *, int, int>(this, minLineIndex, maxLineIndex);
0AA6: call_method 0x56F420 struct [CSimpleModelInfo] num_params 2 pop 0 [minLineIndex] [maxLineIndex]
</pre>

#### SimpleModelStore::~SimpleModelStore

<pre>
plugin::CallMethod<0x5602A0, SimpleModelStore *>(this);
0AA6: call_method 0x5602A0 struct [SimpleModelStore] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CSprite.cpp

#### CSprite::CalcScreenCoors

<pre>
plugin::CallAndReturn<bool, 0x5778B0, RwV3d const&, RwV3d *, float *, float *, bool>(posn, out, w, h, checkMaxVisible);
0AA7: call_function_return 0x5778B0 num_params 5 pop 5 [posn] [out] [w] [h] [checkMaxVisible] func_ret [bool]
</pre>

### plugin_vc\game_vc\CStinger.cpp

#### CStinger::CStinger

<pre>
plugin::CallMethod<0x629B50, CStinger *>(this);
0AA6: call_method 0x629B50 struct [CStinger] num_params 0 pop 0
</pre>

#### CStinger::Deploy

<pre>
plugin::CallMethod<0x628EF0, CStinger *, CPed*>(this, pPed);
0AA6: call_method 0x628EF0 struct [CStinger] num_params 1 pop 0 [pPed]
</pre>

#### CStinger::CheckForBurstTyres

<pre>
plugin::CallMethod<0x628F70, CStinger *>(this);
0AA6: call_method 0x628F70 struct [CStinger] num_params 0 pop 0
</pre>

#### CStinger::Init

<pre>
plugin::CallMethod<0x6298D0, CStinger *, CPed*>(this, pPed);
0AA6: call_method 0x6298D0 struct [CStinger] num_params 1 pop 0 [pPed]
</pre>

#### CStinger::Process

<pre>
plugin::CallMethod<0x629380, CStinger *>(this);
0AA6: call_method 0x629380 struct [CStinger] num_params 0 pop 0
</pre>

#### CStinger::Remove

<pre>
plugin::CallMethod<0x629880, CStinger *>(this);
0AA6: call_method 0x629880 struct [CStinger] num_params 0 pop 0
</pre>

#### CStinger::~CStinger

<pre>
plugin::CallMethod<0x629B40, CStinger *>(this);
0AA6: call_method 0x629B40 struct [CStinger] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CStreaming.cpp

#### CStreaming::AddModelsToRequestList

<pre>
plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddModelsToRequestList), pos, streamingFlags);
</pre>

#### CStreaming::AddToLoadedVehiclesList

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AddToLoadedVehiclesList), modelIndex);
</pre>

#### CStreaming::AreAnimsUsedByRequestedModels

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreAnimsUsedByRequestedModels), animFileIndex);
</pre>

#### CStreaming::ConvertBufferToObject

<pre>
plugin::CallDynGlobal<char *, int>(gaddrof(CStreaming::ConvertBufferToObject), streamingBuffer, modelIndex);
</pre>

#### CStreaming::DeleteFarAwayRwObjects

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteFarAwayRwObjects), pos);
</pre>

#### CStreaming::DeleteRwObjectsAfterDeath

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteRwObjectsAfterDeath), pos);
</pre>

#### CStreaming::DeleteRwObjectsBehindCamera

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::DeleteRwObjectsBehindCamera), maxStreamingMemAllowed);
</pre>

#### CStreaming::DeleteRwObjectsBehindCameraInSectorList

<pre>
plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsBehindCameraInSectorList), ptrList, maxStreamingMemAllowed);
</pre>

#### CStreaming::DeleteRwObjectsInOverlapSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, int, int>(gaddrof(CStreaming::DeleteRwObjectsInOverlapSectorList), ptrlist, sectorX, sectorY);
</pre>

#### CStreaming::DeleteRwObjectsNotInFrustumInSectorList

<pre>
plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsNotInFrustumInSectorList), ptrList, maxStreamingMemAllowed);
</pre>

#### CStreaming::FinishLoadingLargeFile

<pre>
plugin::CallDynGlobal<char *, int>(gaddrof(CStreaming::FinishLoadingLargeFile), streamingBuffer, modelID);
</pre>

#### CStreaming::GetCdImageOffset

<pre>
plugin::CallAndReturnDynGlobal<unsigned int, int>(gaddrof(CStreaming::GetCdImageOffset), CdPosn);
</pre>

#### CStreaming::GetNextFileOnCd

<pre>
plugin::CallAndReturnDynGlobal<int, int, bool>(gaddrof(CStreaming::GetNextFileOnCd), CdOffset, bOnlyPriorityRequests);
</pre>

#### CStreaming::HasSpecialCharLoaded

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasSpecialCharLoaded), SpecialSlotID);
</pre>

#### CStreaming::InstanceLoadedModels

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::InstanceLoadedModels), pos);
</pre>

#### CStreaming::IsObjectInCdImage

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsObjectInCdImage), modelIndex);
</pre>

#### CStreaming::IsTxdUsedByRequestedModels

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsTxdUsedByRequestedModels), txdIndex);
</pre>

#### CStreaming::LoadAllRequestedModels

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CStreaming::LoadAllRequestedModels), bOnlyPriorityRequests);
</pre>

#### CStreaming::LoadCdDirectory

<pre>
plugin::CallDynGlobal<char const *, int>(gaddrof_o(CStreaming::LoadCdDirectory, void (*)(char const *, int)), fileName, id);
</pre>

#### CStreaming::LoadScene

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadScene), pos);
</pre>

#### CStreaming::LoadSceneCollision

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadSceneCollision), pos);
</pre>

#### CStreaming::MakeSpaceFor

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::MakeSpaceFor), memoryToCleanSize);
</pre>

#### CStreaming::MemoryCardLoad

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CStreaming::MemoryCardLoad), buffer, num);
</pre>

#### CStreaming::MemoryCardSave

<pre>
plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CStreaming::MemoryCardSave), text, num);
</pre>

#### CStreaming::ProcessEntitiesInSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, unsigned int)), a1, Streamingflags);
</pre>

#### CStreaming::ProcessEntitiesInSectorList

<pre>
plugin::CallDynGlobal<CPtrList *, float, float, float, float, float, float, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, float, float, float, float, float, float, unsigned int)), ptrList, X1, Y1, X2, Y2, X3, Y3, Streamingflags);
</pre>

#### CStreaming::ProcessLoadingChannel

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::ProcessLoadingChannel), channelIndex);
</pre>

#### CStreaming::RemoveBuildings

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveBuildings), levelID);
</pre>

#### CStreaming::RemoveBuildingsNotInArea

<pre>
plugin::CallAndReturnDynGlobal<char, int>(gaddrof(CStreaming::RemoveBuildingsNotInArea), LevelID);
</pre>

#### CStreaming::RemoveIslandsNotUsed

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveIslandsNotUsed), levelID);
</pre>

#### CStreaming::RemoveLeastUsedModel

<pre>
plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::RemoveLeastUsedModel), streamingFlags);
</pre>

#### CStreaming::RemoveLoadedVehicle

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedVehicle));
</pre>

#### CStreaming::RemoveLoadedZoneModel

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedZoneModel));
</pre>

#### CStreaming::RemoveModel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveModel), modelIndex);
</pre>

#### CStreaming::RemoveUnusedBigBuildings

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveUnusedBigBuildings), LevelID);
</pre>

#### CStreaming::RemoveUnusedBuildings

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveUnusedBuildings), levelID);
</pre>

#### CStreaming::RequestBigBuildings

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestBigBuildings), levelID);
</pre>

#### CStreaming::RequestModel

<pre>
plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestModel), modelIndex, Streamingflags);
</pre>

#### CStreaming::RequestModelStream

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestModelStream), ChannelID);
</pre>

#### CStreaming::RequestSpecialChar

<pre>
plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialChar), SpecialSlotID, Name, streamingFlags);
</pre>

#### CStreaming::RequestSpecialModel

<pre>
plugin::CallAndReturnDynGlobal<char, int, char *, int>(gaddrof(CStreaming::RequestSpecialModel), SpecialModelID, name, StreamingFlags);
</pre>

#### CStreaming::RetryLoadFile

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::RetryLoadFile), nChannel);
</pre>

#### CStreaming::SetMissionDoesntRequireModel

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireModel), modelIndex);
</pre>

#### CStreaming::SetMissionDoesntRequireSpecialChar

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireSpecialChar), SpecialSlotID);
</pre>

#### CStreaming::SetModelIsDeletable

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelIsDeletable), modelIndex);
</pre>

#### CStreaming::SetModelTxdIsDeletable

<pre>
plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelTxdIsDeletable), modelIndex);
</pre>

#### CStreaming::StreamZoneModels

<pre>
plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels), arg1);
</pre>

### plugin_vc\game_vc\CText.cpp

#### CText::Get

<pre>
plugin::CallMethodAndReturn<wchar_t*, 0x584F30, CText*, char const*>(this, key);
0AA8: call_method_return 0x584F30 struct [CText] num_params 1 pop 0 [key] func_ret [wchar_t*]
</pre>

### plugin_vc\game_vc\CTheScripts.cpp

#### CTheScripts::ClearSpaceForMissionEntity

<pre>
plugin::Call<0x45F180, CVector const&, CEntity*>(position, entity);
0AA5: call_function 0x45F180 num_params 2 pop 2 [position] [entity]
</pre>

#### CTheScripts::CleanUpThisObject

<pre>
plugin::CallDynGlobal<CObject *>(gaddrof(CTheScripts::CleanUpThisObject), pObject);
</pre>

#### CTheScripts::CleanUpThisPed

<pre>
plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::CleanUpThisPed), pPed);
</pre>

#### CTheScripts::CleanUpThisVehicle

<pre>
plugin::CallDynGlobal<CVehicle *>(gaddrof(CTheScripts::CleanUpThisVehicle), pVehicle);
</pre>

#### CTheScripts::IsPlayerOnAMission

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTheScripts::IsPlayerOnAMission));
</pre>

#### CTheScripts::IsPlayerStopped

<pre>
plugin::CallAndReturnDynGlobal<bool, CPlayerInfo *>(gaddrof(CTheScripts::IsPlayerStopped), pPlayerIfo);
</pre>

#### CTheScripts::IsVehicleStopped

<pre>
plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTheScripts::IsVehicleStopped), pPlayer);
</pre>

#### CTheScripts::RemoveThisPed

<pre>
plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::RemoveThisPed), pPed);
</pre>

#### \*CTheScripts::StartNewScript

<pre>
plugin::CallAndReturnDynGlobal<CRunningScript *, int>(gaddrof(CTheScripts::StartNewScript), addr);
</pre>

#### \*CTheScripts::StartTestScript

<pre>
plugin::CallAndReturnDynGlobal<CRunningScript *>(gaddrof(CTheScripts::StartTestScript));
</pre>

### plugin_vc\game_vc\CTheZones.cpp

#### CTheZones::CreateZone

<pre>
plugin::Call<0x4DDB80, char*, eZoneType, float, float, float, float, float, float, eLevelName>(name, type, posX1, posY1, posZ1, posX2, posY2, posZ2, island);
0AA5: call_function 0x4DDB80 num_params 9 pop 9 [name] [type] [posX1] [posY1] [posZ1] [posX2] [posY2] [posZ2] [island]
</pre>

#### CTheZones::FindAudioZone

<pre>
plugin::CallAndReturn<CZone*, 0x4DC370, CVector*>(point);
0AA7: call_function_return 0x4DC370 num_params 1 pop 1 [point] func_ret [CZone*]
</pre>

#### CTheZones::FindInformationZoneForPosition

<pre>
plugin::CallAndReturn<int, 0x4DD160, CVector const*>(pPoint);
0AA7: call_function_return 0x4DD160 num_params 1 pop 1 [pPoint] func_ret [int]
</pre>

#### CTheZones::FindNextZoneByLabelAndReturnIndex

<pre>
plugin::CallAndReturn<short, 0x4DD4A0, char*, eZoneType>(name, type);
0AA7: call_function_return 0x4DD4A0 num_params 2 pop 2 [name] [type] func_ret [short]
</pre>

#### CTheZones::FindSmallestNavigationZoneForPosition

<pre>
plugin::CallAndReturn<CZone*, 0x4DD060, CVector const*, bool, bool>(pPoint, findDef, findNavig);
0AA7: call_function_return 0x4DD060 num_params 3 pop 3 [pPoint] [findDef] [findNavig] func_ret [CZone*]
</pre>

#### CTheZones::FindZoneByLabelAndReturnIndex

<pre>
plugin::CallAndReturn<short, 0x4DD5F0, char*, eZoneType>(name, type);
0AA7: call_function_return 0x4DD5F0 num_params 2 pop 2 [name] [type] func_ret [short]
</pre>

#### CTheZones::GetNavigationZone

<pre>
plugin::CallAndReturn<int, 0x4DCC20, unsigned short>(arg0);
0AA7: call_function_return 0x4DCC20 num_params 1 pop 1 [arg0] func_ret [int]
</pre>

#### CTheZones::GetZoneInfo

<pre>
plugin::CallAndReturn<CZone*, 0x4DCEA0, CVector const*, unsigned char>(pPoint, arg1);
0AA7: call_function_return 0x4DCEA0 num_params 2 pop 2 [pPoint] [arg1] func_ret [CZone*]
</pre>

#### CTheZones::GetZoneInfoForTimeOfDay

<pre>
plugin::CallAndReturn<short, 0x4DC500, CVector const*, CZoneInfo*>(pPoint, zoneInfo);
0AA7: call_function_return 0x4DC500 num_params 2 pop 2 [pPoint] [zoneInfo] func_ret [short]
</pre>

#### CTheZones::Init

<pre>
plugin::Call<0x4DDFA0>();
0AA5: call_function 0x4DDFA0 num_params 0 pop 0
</pre>

#### CTheZones::InitialiseAudioZoneArray

<pre>
plugin::Call<0x4DC430>();
0AA5: call_function 0x4DC430 num_params 0 pop 0
</pre>

#### CTheZones::InsertZoneIntoZoneHierRecursive

<pre>
plugin::CallAndReturn<bool, 0x4DD9D0, CZone*, CZone*>(currentZona, otherZone);
0AA7: call_function_return 0x4DD9D0 num_params 2 pop 2 [currentZona] [otherZone] func_ret [bool]
</pre>

#### CTheZones::LoadAllZones

<pre>
plugin::Call<0x4DBCB0, unsigned char*, unsigned int>(arg0, arg1);
0AA5: call_function 0x4DBCB0 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CTheZones::LoadOneZone

<pre>
plugin::Call<0x4DBB80, CZone*, unsigned char**, unsigned int*, eZoneType>(pZone, arg1, arg2, type);
0AA5: call_function 0x4DBB80 num_params 4 pop 4 [pZone] [arg1] [arg2] [type]
</pre>

#### CTheZones::PointLiesWithinZone

<pre>
plugin::CallAndReturn<bool, 0x4DD750, CVector const*, CZone*>(pPoint, pZone);
0AA7: call_function_return 0x4DD750 num_params 2 pop 2 [pPoint] [pZone] func_ret [bool]
</pre>

#### CTheZones::PostZoneCreation

<pre>
plugin::CallAndReturn<char, 0x4DDA90>();
0AA7: call_function_return 0x4DDA90 num_params 0 pop 0 func_ret [char]
</pre>

#### CTheZones::SaveAllZones

<pre>
plugin::Call<0x4DC090, unsigned char*, unsigned int*>(arg0, arg1);
0AA5: call_function 0x4DC090 num_params 2 pop 2 [arg0] [arg1]
</pre>

#### CTheZones::SaveOneZone

<pre>
plugin::Call<0x4DBF30, CZone*, unsigned char**, unsigned int*, eZoneType>(pZone, arg1, arg2, type);
0AA5: call_function 0x4DBF30 num_params 4 pop 4 [pZone] [arg1] [arg2] [type]
</pre>

#### CTheZones::SetPedGroup

<pre>
plugin::Call<0x4DCC30, unsigned short, unsigned char, unsigned short>(arg0, arg1, arg2);
0AA5: call_function 0x4DCC30 num_params 3 pop 3 [arg0] [arg1] [arg2]
</pre>

#### CTheZones::SetZoneCarInfo

<pre>
plugin::Call<0x4DCDF0, int, unsigned char, short, short, short const*>(arg0, arg1, arg2, arg3, arg4);
0AA5: call_function 0x4DCDF0 num_params 5 pop 5 [arg0] [arg1] [arg2] [arg3] [arg4]
</pre>

#### CTheZones::SetZoneCivilianCarInfo

<pre>
plugin::Call<0x4DCD40, int, unsigned char, short const*, short const*>(arg0, arg1, arg2, arg3);
0AA5: call_function 0x4DCD40 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CTheZones::SetZonePedInfo

<pre>
plugin::Call<0x4DCC70, int, unsigned char, short, short, short, short, short, short, short, short, short, short, short>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
0AA5: call_function 0x4DCC70 num_params 13 pop 13 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12]
</pre>

#### CTheZones::Update

<pre>
plugin::Call<0x4DDDF0>();
0AA5: call_function 0x4DDDF0 num_params 0 pop 0
</pre>

#### CTheZones::ZoneIsEntirelyContainedWithinOtherZone

<pre>
plugin::CallAndReturn<bool, 0x4DD7D0, CZone*, CZone*>(currentZona, otherZone);
0AA7: call_function_return 0x4DD7D0 num_params 2 pop 2 [currentZona] [otherZone] func_ret [bool]
</pre>

### plugin_vc\game_vc\CTimeCycle.cpp

#### CTimeCycle::StopExtraColour

<pre>
plugin::CallDynGlobal<bool>(gaddrof(CTimeCycle::StopExtraColour), arg1);
</pre>

### plugin_vc\game_vc\CTimeModelInfo.cpp

#### CTimeModelInfo::FindOtherTimeModel

<pre>
plugin::CallMethod<0x56F330, CTimeModelInfo *>(this);
0AA6: call_method 0x56F330 struct [CTimeModelInfo] num_params 0 pop 0
</pre>

#### TimeModelStore::~TimeModelStore

<pre>
plugin::CallMethod<0x560240, TimeModelStore *>(this);
0AA6: call_method 0x560240 struct [TimeModelStore] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CTimer.cpp

#### CTimer::GetCurrentTimeInCycles

<pre>
plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CTimer::GetCurrentTimeInCycles));
</pre>

#### CTimer::GetCyclesPerMillisecond

<pre>
plugin::CallAndReturnDynGlobal<int>(gaddrof(CTimer::GetCyclesPerMillisecond));
</pre>

#### CTimer::GetIsSlowMotionActive

<pre>
plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTimer::GetIsSlowMotionActive));
</pre>

### plugin_vc\game_vc\CTrafficLights.cpp

#### CTrafficLights::DisplayActualLight

<pre>
plugin::CallDynGlobal<CEntity *>(gaddrof(CTrafficLights::DisplayActualLight), pEntity);
</pre>

#### CTrafficLights::ShouldCarStopForLight

<pre>
plugin::CallDynGlobal<CVehicle *, bool>(gaddrof(CTrafficLights::ShouldCarStopForLight), arg1, arg2);
</pre>

### plugin_vc\game_vc\CTrain.cpp

#### CTrain::AddPassenger

<pre>
plugin::CallMethod<0x5B2C60, CTrain *, CPed*>(this, ped);
0AA6: call_method 0x5B2C60 struct [CTrain] num_params 1 pop 0 [ped]
</pre>

#### CTrain::CTrain

<pre>
plugin::CallMethod<0x5B2D00, CTrain *, int, unsigned char>(this, modelIndex, createdBy);
0AA6: call_method 0x5B2D00 struct [CTrain] num_params 2 pop 0 [modelIndex] [createdBy]
</pre>

#### CTrain::InitTrains

<pre>
plugin::Call<0x5B2CA0>();
0AA5: call_function 0x5B2CA0 num_params 0 pop 0
</pre>

#### CTrain::Shutdown

<pre>
plugin::Call<0x5B2C90>();
0AA5: call_function 0x5B2C90 num_params 0 pop 0
</pre>

#### CTrain::UpdateTrains

<pre>
plugin::Call<0x5B2C80>();
0AA5: call_function 0x5B2C80 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\cTransmission.cpp

#### cTransmission::CalculateDriveAcceleration

<pre>
plugin::CallMethodAndReturn<float, 0x5B2E20, cTransmission *, float const&, unsigned char&, float&, float const&, bool>(this, gasPedal, currrentGear, arg2, arg3, arg4);
0AA8: call_method_return 0x5B2E20 struct [cTransmission] num_params 5 pop 0 [gasPedal] [currrentGear] [arg2] [arg3] [arg4] func_ret [float]
</pre>

#### cTransmission::CalculateGearForSimpleCar

<pre>
plugin::CallMethod<0x5B2DC0, cTransmission *, float, unsigned char&>(this, velocity, currrentGear);
0AA6: call_method 0x5B2DC0 struct [cTransmission] num_params 2 pop 0 [velocity] [currrentGear]
</pre>

#### cTransmission::InitGearRatios

<pre>
plugin::CallMethod<0x5B3120, cTransmission *>(this);
0AA6: call_method 0x5B3120 struct [cTransmission] num_params 0 pop 0
</pre>

#### cTransmission::cTransmission

<pre>
plugin::CallMethod<0x5B3240, cTransmission *>(this);
0AA6: call_method 0x5B3240 struct [cTransmission] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CTxdStore.cpp

#### CTxdStore::AddRef

<pre>
plugin::CallAndReturn<TxdDef*, 0x580A60, int>(index);
0AA7: call_function_return 0x580A60 num_params 1 pop 1 [index] func_ret [TxdDef*]
</pre>

#### CTxdStore::AddTxdSlot

<pre>
plugin::CallAndReturn<int, 0x580F00, char const*>(name);
0AA7: call_function_return 0x580F00 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CTxdStore::Create

<pre>
plugin::Call<0x580B60, int>(index);
0AA5: call_function 0x580B60 num_params 1 pop 1 [index]
</pre>

#### CTxdStore::FindTxdSlot

<pre>
plugin::CallAndReturn<int, 0x580D70, char const*>(name);
0AA7: call_function_return 0x580D70 num_params 1 pop 1 [name] func_ret [int]
</pre>

#### CTxdStore::FinishLoadTxd

<pre>
plugin::CallAndReturn<bool, 0x580BA0, int, RwStream*>(index, stream);
0AA7: call_function_return 0x580BA0 num_params 2 pop 2 [index] [stream] func_ret [bool]
</pre>

#### CTxdStore::GameShutdown

<pre>
plugin::Call<0x580F40>();
0AA5: call_function 0x580F40 num_params 0 pop 0
</pre>

#### CTxdStore::GetNumRefs

<pre>
plugin::CallAndReturn<int, 0x580990, int>(index);
0AA7: call_function_return 0x580990 num_params 1 pop 1 [index] func_ret [int]
</pre>

#### CTxdStore::GetTxdName

<pre>
plugin::CallAndReturn<int, 0x580E50, int>(index);
0AA7: call_function_return 0x580E50 num_params 1 pop 1 [index] func_ret [int]
</pre>

#### CTxdStore::LoadTxd

<pre>
plugin::CallAndReturn<bool, 0x580C60, int, RwStream*>(index, stream);
0AA7: call_function_return 0x580C60 num_params 2 pop 2 [index] [stream] func_ret [bool]
</pre>

#### CTxdStore::LoadTxd

<pre>
plugin::CallAndReturn<bool, 0x580CD0, int, char const*>(index, filename);
0AA7: call_function_return 0x580CD0 num_params 2 pop 2 [index] [filename] func_ret [bool]
</pre>

#### CTxdStore::PopCurrentTxd

<pre>
plugin::Call<0x580AA0>();
0AA5: call_function 0x580AA0 num_params 0 pop 0
</pre>

#### CTxdStore::PushCurrentTxd

<pre>
plugin::Call<0x580AC0>();
0AA5: call_function 0x580AC0 num_params 0 pop 0
</pre>

#### CTxdStore::RemoveRef

<pre>
plugin::Call<0x580A10, int>(index);
0AA5: call_function 0x580A10 num_params 1 pop 1 [index]
</pre>

#### CTxdStore::RemoveRefWithoutDelete

<pre>
plugin::CallAndReturn<TxdDef*, 0x5809D0, int>(index);
0AA7: call_function_return 0x5809D0 num_params 1 pop 1 [index] func_ret [TxdDef*]
</pre>

#### CTxdStore::RemoveTxd

<pre>
plugin::Call<0x580B10, int>(index);
0AA5: call_function 0x580B10 num_params 1 pop 1 [index]
</pre>

#### CTxdStore::RemoveTxdSlot

<pre>
plugin::Call<0x580E90, int>(index);
0AA5: call_function 0x580E90 num_params 1 pop 1 [index]
</pre>

#### CTxdStore::SetCurrentTxd

<pre>
plugin::Call<0x580AD0, int>(index);
0AA5: call_function 0x580AD0 num_params 1 pop 1 [index]
</pre>

#### CTxdStore::Shutdown

<pre>
plugin::Call<0x580FF0>();
0AA5: call_function 0x580FF0 num_params 0 pop 0
</pre>

#### CTxdStore::StartLoadTxd

<pre>
plugin::CallAndReturn<bool, 0x580BF0, int, RwStream*>(index, stream);
0AA7: call_function_return 0x580BF0 num_params 2 pop 2 [index] [stream] func_ret [bool]
</pre>

#### CTxdStore::Initialise

<pre>
plugin::Call<0x581010>();
0AA5: call_function 0x581010 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CUserDisplay.cpp

#### CUserDisplay::Init

<pre>
plugin::Call<0x4D1490>();
0AA5: call_function 0x4D1490 num_params 0 pop 0
</pre>

#### CUserDisplay::Process

<pre>
plugin::Call<0x4D1400>();
0AA5: call_function 0x4D1400 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CVehicle.cpp

#### CVehicle::ProcessControlInputs

<pre>
plugin::CallVirtualMethod<18, CVehicle *, unsigned char>(this, playerNum);
</pre>

#### CVehicle::GetComponentWorldPosition

<pre>
plugin::CallVirtualMethod<19, CVehicle *, int, CVector&>(this, componentId, posnOut);
</pre>

#### CVehicle::IsComponentPresent

<pre>
plugin::CallVirtualMethodAndReturn<bool, 20, CVehicle *, int>(this, componentId);
</pre>

#### CVehicle::SetComponentRotation

<pre>
plugin::CallVirtualMethod<21, CVehicle *, int, CVector>(this, componentId, arg1);
</pre>

#### CVehicle::OpenDoor

<pre>
plugin::CallVirtualMethod<22, CVehicle *, int, eDoors, float>(this, componentId, door, doorOpenRatio);
</pre>

#### CVehicle::ProcessOpenDoor

<pre>
plugin::CallVirtualMethod<23, CVehicle *, unsigned int, unsigned int, float>(this, arg0, arg1, arg2);
</pre>

#### CVehicle::IsDoorReady

<pre>
plugin::CallVirtualMethodAndReturn<bool, 24, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorFullyOpen

<pre>
plugin::CallVirtualMethodAndReturn<bool, 25, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorClosed

<pre>
plugin::CallVirtualMethodAndReturn<bool, 26, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorMissing

<pre>
plugin::CallVirtualMethodAndReturn<bool, 27, CVehicle *, eDoors>(this, door);
</pre>

#### CVehicle::IsDoorReady

<pre>
plugin::CallVirtualMethodAndReturn<bool, 28, CVehicle *, unsigned int>(this, door);
</pre>

#### CVehicle::IsDoorMissing

<pre>
plugin::CallVirtualMethodAndReturn<bool, 29, CVehicle *, unsigned int>(this, door);
</pre>

#### CVehicle::IsOpenTopCar

<pre>
plugin::CallVirtualMethodAndReturn<bool, 30, CVehicle *>(this);
</pre>

#### CVehicle::RemoveRefsToVehicle

<pre>
plugin::CallVirtualMethod<31, CVehicle *, CEntity*>(this, entity);
</pre>

#### CVehicle::BlowUpCar

<pre>
plugin::CallVirtualMethod<32, CVehicle *, CEntity*>(this, damager);
</pre>

#### CVehicle::SetUpWheelColModel

<pre>
plugin::CallVirtualMethodAndReturn<bool, 33, CVehicle *, CColModel*>(this, wheelCol);
</pre>

#### CVehicle::BurstTyre

<pre>
plugin::CallVirtualMethodAndReturn<bool, 34, CVehicle *, unsigned char, bool>(this, tyreComponentId, bPhysicalEffect);
</pre>

#### CVehicle::IsRoomForPedToLeaveCar

<pre>
plugin::CallVirtualMethodAndReturn<bool, 35, CVehicle *, unsigned int, CVector*>(this, arg0, arg1);
</pre>

#### CVehicle::IsClearToDriveAway

<pre>
plugin::CallVirtualMethodAndReturn<bool, 36, CVehicle *>(this);
</pre>

#### CVehicle::GetHeightAboveRoad

<pre>
plugin::CallVirtualMethodAndReturn<float, 37, CVehicle *>(this);
</pre>

#### CVehicle::PlayCarHorn

<pre>
plugin::CallVirtualMethod<38, CVehicle *>(this);
</pre>

#### CVehicle::ActivateBomb

<pre>
plugin::CallMethod<0x5B79E0, CVehicle *>(this);
0AA6: call_method 0x5B79E0 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ActivateBombWhenEntered

<pre>
plugin::CallMethod<0x5B7950, CVehicle *>(this);
0AA6: call_method 0x5B7950 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::AddPassenger

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8E60, CVehicle *, CPed*>(this, passenger);
0AA8: call_method_return 0x5B8E60 struct [CVehicle] num_params 1 pop 0 [passenger] func_ret [bool]
</pre>

#### CVehicle::AddPassenger

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8D50, CVehicle *, CPed*, unsigned char>(this, passenger, seatNumber);
0AA8: call_method_return 0x5B8D50 struct [CVehicle] num_params 2 pop 0 [passenger] [seatNumber] func_ret [bool]
</pre>

#### CVehicle::BladeColSectorList

<pre>
plugin::CallMethod<0x5B4610, CVehicle *, CPtrList&, CColModel&, CMatrix&, short, float>(this, ptrList, colModel, matrix, arg3, arg4);
0AA6: call_method 0x5B4610 struct [CVehicle] num_params 5 pop 0 [ptrList] [colModel] [matrix] [arg3] [arg4]
</pre>

#### CVehicle::CanBeDeleted

<pre>
plugin::CallMethodAndReturn<bool, 0x5BA960, CVehicle *>(this);
0AA8: call_method_return 0x5BA960 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanDoorsBeDamaged

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8440, CVehicle *>(this);
0AA8: call_method_return 0x5B8440 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedEnterCar

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8370, CVehicle *>(this);
0AA8: call_method_return 0x5B8370 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedExitCar

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8180, CVehicle *, bool>(this, arg0);
0AA8: call_method_return 0x5B8180 struct [CVehicle] num_params 1 pop 0 [arg0] func_ret [bool]
</pre>

#### CVehicle::CanPedJumpOffBike

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8130, CVehicle *>(this);
0AA8: call_method_return 0x5B8130 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedJumpOutCar

<pre>
plugin::CallMethodAndReturn<bool, 0x5B80C0, CVehicle *>(this);
0AA8: call_method_return 0x5B80C0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::CanPedOpenLocks

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8460, CVehicle *, CPed*>(this, ped);
0AA8: call_method_return 0x5B8460 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CVehicle::CarHasRoof

<pre>
plugin::CallMethodAndReturn<bool, 0x5B7910, CVehicle *>(this);
0AA8: call_method_return 0x5B7910 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::ChangeLawEnforcerState

<pre>
plugin::CallMethod<0x5B7D90, CVehicle *, unsigned char>(this, state);
0AA6: call_method 0x5B7D90 struct [CVehicle] num_params 1 pop 0 [state]
</pre>

#### CVehicle::DoBladeCollision

<pre>
plugin::CallMethod<0x5B5030, CVehicle *, CVector, CMatrix&, short, float, float>(this, arg0, matrix, arg2, arg3, arg4);
0AA6: call_method 0x5B5030 struct [CVehicle] num_params 5 pop 0 [arg0] [matrix] [arg2] [arg3] [arg4]
</pre>

#### CVehicle::DoFixedMachineGuns

<pre>
plugin::CallMethod<0x5C9170, CVehicle *>(this);
0AA6: call_method 0x5C9170 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::DoSunGlare

<pre>
plugin::CallMethod<0x5B3CD0, CVehicle *>(this);
0AA6: call_method 0x5B3CD0 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ExtinguishCarFire

<pre>
plugin::CallMethod<0x5B7A80, CVehicle *>(this);
0AA6: call_method 0x5B7A80 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::FindTyreNearestPoint

<pre>
plugin::CallMethodAndReturn<int, 0x5B96A0, CVehicle *, float, float>(this, x, y);
0AA8: call_method_return 0x5B96A0 struct [CVehicle] num_params 2 pop 0 [x] [y] func_ret [int]
</pre>

#### CVehicle::FireFixedMachineGuns

<pre>
plugin::CallMethod<0x5C8E40, CVehicle *>(this);
0AA6: call_method 0x5C8E40 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::FlyingControl

<pre>
plugin::CallMethod<0x5B54C0, CVehicle *, eFlightModel>(this, flightModel);
0AA6: call_method 0x5B54C0 struct [CVehicle] num_params 1 pop 0 [flightModel]
</pre>

#### CVehicle::GetVehicleAppearance

<pre>
plugin::CallMethodAndReturn<int, 0x5BAA80, CVehicle *>(this);
0AA8: call_method_return 0x5BAA80 struct [CVehicle] num_params 0 pop 0 func_ret [int]
</pre>

#### CVehicle::HeliDustGenerate

<pre>
plugin::Call<0x5B3250, CEntity*, float, float, int>(arg0, arg1, arg2, arg3);
0AA5: call_function 0x5B3250 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CVehicle::InflictDamage

<pre>
plugin::CallMethod<0x5B9020, CVehicle *, CEntity*, eWeaponType, float, CVector>(this, damager, weapon, intensity, coords);
0AA6: call_method 0x5B9020 struct [CVehicle] num_params 4 pop 0 [damager] [weapon] [intensity] [coords]
</pre>

#### CVehicle::IsDriver

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8670, CVehicle *, CPed*>(this, ped);
0AA8: call_method_return 0x5B8670 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CVehicle::IsDriver

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8640, CVehicle *, int>(this, modelIndex);
0AA8: call_method_return 0x5B8640 struct [CVehicle] num_params 1 pop 0 [modelIndex] func_ret [bool]
</pre>

#### CVehicle::IsLawEnforcementVehicle

<pre>
plugin::CallMethodAndReturn<bool, 0x5B7D60, CVehicle *>(this);
0AA8: call_method_return 0x5B7D60 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::IsOnItsSide

<pre>
plugin::CallMethodAndReturn<bool, 0x5B84B0, CVehicle *>(this);
0AA8: call_method_return 0x5B84B0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::IsPassenger

<pre>
plugin::CallMethodAndReturn<bool, 0x5B86D0, CVehicle *, CPed*>(this, ped);
0AA8: call_method_return 0x5B86D0 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]
</pre>

#### CVehicle::IsPassenger

<pre>
plugin::CallMethodAndReturn<bool, 0x5B86A0, CVehicle *, int>(this, modelIndex);
0AA8: call_method_return 0x5B86A0 struct [CVehicle] num_params 1 pop 0 [modelIndex] func_ret [bool]
</pre>

#### CVehicle::IsSphereTouchingVehicle

<pre>
plugin::CallMethodAndReturn<bool, 0x5B7F00, CVehicle *, float, float, float, float>(this, x, y, z, radius);
0AA8: call_method_return 0x5B7F00 struct [CVehicle] num_params 4 pop 0 [x] [y] [z] [radius] func_ret [bool]
</pre>

#### CVehicle::IsUpsideDown

<pre>
plugin::CallMethodAndReturn<bool, 0x5B84F0, CVehicle *>(this);
0AA8: call_method_return 0x5B84F0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::IsVehicleNormal

<pre>
plugin::CallMethodAndReturn<bool, 0x5B7DF0, CVehicle *>(this);
0AA8: call_method_return 0x5B7DF0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::KillPedsInVehicle

<pre>
plugin::CallMethod<0x5B8560, CVehicle *>(this);
0AA6: call_method 0x5B8560 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::MakeNonDraggedPedsLeaveVehicle

<pre>
plugin::CallMethod<0x5B3A30, CVehicle *, CPed*, CPed*, CPlayerPed*&, CCopPed*&>(this, arg0, arg1, arg2, arg3);
0AA6: call_method 0x5B3A30 struct [CVehicle] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3]
</pre>

#### CVehicle::ProcessBikeWheel

<pre>
plugin::CallMethod<0x5B9770, CVehicle *, CVector&, CVector&, CVector&, CVector&, int, float, float, float, float, char, float*, tWheelState*, eBikeWheelSpecial, unsigned short>(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
0AA6: call_method 0x5B9770 struct [CVehicle] num_params 14 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12] [arg13]
</pre>

#### CVehicle::ProcessCarAlarm

<pre>
plugin::CallMethod<0x5B8040, CVehicle *>(this);
0AA6: call_method 0x5B8040 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ProcessDelayedExplosion

<pre>
plugin::CallMethod<0x5B8F50, CVehicle *>(this);
0AA6: call_method 0x5B8F50 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::ProcessWheel

<pre>
plugin::CallMethod<0x5BA070, CVehicle *, CVector&, CVector&, CVector&, CVector&, int, float, float, float, char, float*, tWheelState*, unsigned short>(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
0AA6: call_method 0x5BA070 struct [CVehicle] num_params 12 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11]
</pre>

#### CVehicle::ProcessWheelRotation

<pre>
plugin::CallMethodAndReturn<float, 0x5BA900, CVehicle *, tWheelState, CVector const&, CVector const&, float>(this, wheelState, arg1, arg2, arg3);
0AA8: call_method_return 0x5BA900 struct [CVehicle] num_params 4 pop 0 [wheelState] [arg1] [arg2] [arg3] func_ret [float]
</pre>

#### CVehicle::RemoveDriver

<pre>
plugin::CallMethod<0x5B8920, CVehicle *, bool>(this, arg0);
0AA6: call_method 0x5B8920 struct [CVehicle] num_params 1 pop 0 [arg0]
</pre>

#### CVehicle::RemovePassenger

<pre>
plugin::CallMethod<0x5B8CE0, CVehicle *, CPed*>(this, passenger);
0AA6: call_method 0x5B8CE0 struct [CVehicle] num_params 1 pop 0 [passenger]
</pre>

#### CVehicle::SetComponentAtomicAlpha

<pre>
plugin::CallMethod<0x5B45D0, CVehicle *, RpAtomic*, int>(this, atomic, alpha);
0AA6: call_method 0x5B45D0 struct [CVehicle] num_params 2 pop 0 [atomic] [alpha]
</pre>

#### CVehicle::SetDriver

<pre>
plugin::CallMethod<0x5B89F0, CVehicle *, CPed*>(this, driver);
0AA6: call_method 0x5B89F0 struct [CVehicle] num_params 1 pop 0 [driver]
</pre>

#### CVehicle::SetUpDriver

<pre>
plugin::CallMethodAndReturn<CPed*, 0x5B8870, CVehicle *>(this);
0AA8: call_method_return 0x5B8870 struct [CVehicle] num_params 0 pop 0 func_ret [CPed*]
</pre>

#### CVehicle::SetupPassenger

<pre>
plugin::CallMethodAndReturn<CPed*, 0x5B8700, CVehicle *, int>(this, arg0);
0AA8: call_method_return 0x5B8700 struct [CVehicle] num_params 1 pop 0 [arg0] func_ret [CPed*]
</pre>

#### CVehicle::ShufflePassengersToMakeSpace

<pre>
plugin::CallMethodAndReturn<bool, 0x5B7B10, CVehicle *>(this);
0AA8: call_method_return 0x5B7B10 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

#### CVehicle::UpdateClumpAlpha

<pre>
plugin::CallMethod<0x5B4580, CVehicle *>(this);
0AA6: call_method 0x5B4580 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::UpdatePassengerList

<pre>
plugin::CallMethod<0x5B39F0, CVehicle *>(this);
0AA6: call_method 0x5B39F0 struct [CVehicle] num_params 0 pop 0
</pre>

#### CVehicle::UsesSiren

<pre>
plugin::CallMethodAndReturn<bool, 0x5B8520, CVehicle *>(this);
0AA8: call_method_return 0x5B8520 struct [CVehicle] num_params 0 pop 0 func_ret [bool]
</pre>

### plugin_vc\game_vc\CVehicleModelInfo.cpp

#### CVehicleModelInfo::AvoidSameVehicleColour

<pre>
plugin::CallMethod<0x579090, CVehicleModelInfo *, unsigned char*, unsigned char*>(this, prim, sec);
0AA6: call_method 0x579090 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]
</pre>

#### CVehicleModelInfo::ChooseComponent

<pre>
plugin::CallMethodAndReturn<int, 0x579670, CVehicleModelInfo *>(this);
0AA8: call_method_return 0x579670 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]
</pre>

#### CVehicleModelInfo::ChooseSecondComponent

<pre>
plugin::CallMethodAndReturn<int, 0x5794F0, CVehicleModelInfo *>(this);
0AA8: call_method_return 0x5794F0 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]
</pre>

#### CVehicleModelInfo::ChooseVehicleColour

<pre>
plugin::CallMethod<0x579190, CVehicleModelInfo *, unsigned char&, unsigned char&>(this, prim, sec);
0AA6: call_method 0x579190 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]
</pre>

#### CVehicleModelInfo::ClearAtomicFlagCB

<pre>
plugin::CallAndReturn<RwObject*, 0x579FD0, RwObject*, void*>(object, data);
0AA7: call_function_return 0x579FD0 num_params 2 pop 2 [object] [data] func_ret [RwObject*]
</pre>

#### CVehicleModelInfo::CollapseFramesCB

<pre>
plugin::CallAndReturn<RwFrame*, 0x57A660, RwFrame*, void*>(frame, data);
0AA7: call_function_return 0x57A660 num_params 2 pop 2 [frame] [data] func_ret [RwFrame*]
</pre>

#### CVehicleModelInfo::DeleteVehicleColourTextures

<pre>
plugin::Call<0x578C90>();
0AA5: call_function 0x578C90 num_params 0 pop 0
</pre>

#### CVehicleModelInfo::FindEditableMaterialList

<pre>
plugin::CallMethodAndReturn<int, 0x579390, CVehicleModelInfo *>(this);
0AA8: call_method_return 0x579390 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]
</pre>

#### CVehicleModelInfo::GetEditableMaterialListCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x579440, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x579440 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::GetEditableMaterialListCB

<pre>
plugin::CallAndReturn<RpMaterial*, 0x579460, RpMaterial*, void*>(material, data);
0AA7: call_function_return 0x579460 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]
</pre>

#### CVehicleModelInfo::GetMatFXEffectMaterialCB

<pre>
plugin::CallAndReturn<RpMaterial*, 0x578BA0, RpMaterial*, void*>(material, data);
0AA7: call_function_return 0x578BA0 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]
</pre>

#### CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors

<pre>
plugin::CallAndReturn<int, 0x578A70, int>(modelId);
0AA7: call_function_return 0x578A70 num_params 1 pop 1 [modelId] func_ret [int]
</pre>

#### CVehicleModelInfo::GetWheelPosn

<pre>
plugin::CallMethod<0x579AD0, CVehicleModelInfo *, int, CVector&>(this, wheel, outVec);
0AA6: call_method 0x579AD0 struct [CVehicleModelInfo] num_params 2 pop 0 [wheel] [outVec]
</pre>

#### CVehicleModelInfo::HasAlphaMaterialCB

<pre>
plugin::CallAndReturn<RpMaterial*, 0x57A600, RpMaterial*, void*>(material, data);
0AA7: call_function_return 0x57A600 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]
</pre>

#### CVehicleModelInfo::HideAllComponentsAtomicCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A620, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x57A620 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::LoadEnvironmentMaps

<pre>
plugin::Call<0x578C30>();
0AA5: call_function 0x578C30 num_params 0 pop 0
</pre>

#### CVehicleModelInfo::LoadVehicleColours

<pre>
plugin::Call<0x578CC0>();
0AA5: call_function 0x578CC0 num_params 0 pop 0
</pre>

#### CVehicleModelInfo::MoveObjectsCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A640, RwObject*, void*>(object, data);
0AA7: call_function_return 0x57A640 num_params 2 pop 2 [object] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::PreprocessHierarchy

<pre>
plugin::CallMethod<0x579B10, CVehicleModelInfo *>(this);
0AA6: call_method 0x579B10 struct [CVehicleModelInfo] num_params 0 pop 0
</pre>

#### CVehicleModelInfo::SetAtomicFlagCB

<pre>
plugin::CallAndReturn<RwObject*, 0x579FF0, RwObject*, void*>(object, data);
0AA7: call_function_return 0x579FF0 num_params 2 pop 2 [object] [data] func_ret [RwObject*]
</pre>

#### CVehicleModelInfo::SetAtomicRendererCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A4A0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x57A4A0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::SetAtomicRendererCB_BigVehicle

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A1E0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x57A1E0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::SetAtomicRendererCB_Boat

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A070, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x57A070 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::SetAtomicRendererCB_Heli

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A010, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x57A010 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::SetAtomicRendererCB_RealHeli

<pre>
plugin::CallAndReturn<RpAtomic*, 0x57A300, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x57A300 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::SetDefaultEnvironmentMapCB

<pre>
plugin::CallAndReturn<RpMaterial*, 0x578B40, RpMaterial*, void*>(material, data);
0AA7: call_function_return 0x578B40 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]
</pre>

#### CVehicleModelInfo::SetEnvironmentMapCB

<pre>
plugin::CallAndReturn<RpAtomic*, 0x578AF0, RpAtomic*, void*>(atomic, data);
0AA7: call_function_return 0x578AF0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]
</pre>

#### CVehicleModelInfo::SetVehicleColour

<pre>
plugin::CallMethod<0x579290, CVehicleModelInfo *, unsigned char, unsigned char>(this, prim, sec);
0AA6: call_method 0x579290 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]
</pre>

#### CVehicleModelInfo::SetVehicleComponentFlags

<pre>
plugin::CallMethod<0x579E80, CVehicleModelInfo *, RwFrame*, unsigned int>(this, component, flags);
0AA6: call_method 0x579E80 struct [CVehicleModelInfo] num_params 2 pop 0 [component] [flags]
</pre>

#### CVehicleModelInfo::ShutdownEnvironmentMaps

<pre>
plugin::Call<0x578BD0>();
0AA5: call_function 0x578BD0 num_params 0 pop 0
</pre>

#### VehicleModelStore::~VehicleModelStore

<pre>
plugin::CallMethod<0x560150, VehicleModelStore *>(this);
0AA6: call_method 0x560150 struct [VehicleModelStore] num_params 0 pop 0
</pre>

#### GetListOfComponentsNotUsedByRules

<pre>
plugin::CallAndReturn<int, 0x5799B0, unsigned int, int, int*>(compRulesBits, numExtras, variationsList);
0AA7: call_function_return 0x5799B0 num_params 3 pop 3 [compRulesBits] [numExtras] [variationsList] func_ret [int]
</pre>

#### ChooseComponent

<pre>
plugin::CallAndReturn<int, 0x5797C0, int, int>(rule, compRulesBits);
0AA7: call_function_return 0x5797C0 num_params 2 pop 2 [rule] [compRulesBits] func_ret [int]
</pre>

### plugin_vc\game_vc\CVisibilityPlugins.cpp

#### CVisibilityPlugins::SetAtomicRenderCallback

<pre>
plugin::Call<0x581940>(atomic, cb);
0AA5: call_function 0x581940 num_params 2 pop 2 [atomic] [cb]
</pre>

### plugin_vc\game_vc\CWanted.cpp

#### CWanted::AddCrimeToQ

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1990, CWanted *, eCrimeType, int, CVector const&, bool, bool>(this, crimeType, arg1, arg2, arg3, arg4);
0AA8: call_method_return 0x4D1990 struct [CWanted] num_params 5 pop 0 [crimeType] [arg1] [arg2] [arg3] [arg4] func_ret [bool]
</pre>

#### CWanted::AreArmyRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1E20, CWanted *>(this);
0AA8: call_method_return 0x4D1E20 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreFbiRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1E40, CWanted *>(this);
0AA8: call_method_return 0x4D1E40 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreMiamiViceRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1E80, CWanted *>(this);
0AA8: call_method_return 0x4D1E80 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::AreSwatRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1E60, CWanted *>(this);
0AA8: call_method_return 0x4D1E60 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::CheatWantedLevel

<pre>
plugin::CallMethod<0x4D1F80, CWanted *, int>(this, arg0);
0AA6: call_method 0x4D1F80 struct [CWanted] num_params 1 pop 0 [arg0]
</pre>

#### CWanted::ClearQdCrimes

<pre>
plugin::CallMethod<0x4D1A50, CWanted *>(this);
0AA6: call_method 0x4D1A50 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::Initialise

<pre>
plugin::CallMethod<0x4D2440, CWanted *>(this);
0AA6: call_method 0x4D2440 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::NumOfHelisRequired

<pre>
plugin::CallMethodAndReturn<bool, 0x4D1DE0, CWanted *>(this);
0AA8: call_method_return 0x4D1DE0 struct [CWanted] num_params 0 pop 0 func_ret [bool]
</pre>

#### CWanted::RegisterCrime

<pre>
plugin::CallMethod<0x4D20F0, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, arg1, arg2, arg3);
0AA6: call_method 0x4D20F0 struct [CWanted] num_params 4 pop 0 [crimeType] [arg1] [arg2] [arg3]
</pre>

#### CWanted::RegisterCrime_Immediately

<pre>
plugin::CallMethod<0x4D20B0, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, arg1, arg2, arg3);
0AA6: call_method 0x4D20B0 struct [CWanted] num_params 4 pop 0 [crimeType] [arg1] [arg2] [arg3]
</pre>

#### CWanted::ReportCrimeNow

<pre>
plugin::CallMethod<0x4D1610, CWanted *, eCrimeType, CVector const&, bool>(this, crimeType, arg1, arg2);
0AA6: call_method 0x4D1610 struct [CWanted] num_params 3 pop 0 [crimeType] [arg1] [arg2]
</pre>

#### CWanted::Reset

<pre>
plugin::CallMethod<0x4D2420, CWanted *>(this);
0AA6: call_method 0x4D2420 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::ResetPolicePursuit

<pre>
plugin::CallMethod<0x4D1D20, CWanted *>(this);
0AA6: call_method 0x4D1D20 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::SetMaximumWantedLevel

<pre>
plugin::Call<0x4D1E90, int>(level);
0AA5: call_function 0x4D1E90 num_params 1 pop 1 [level]
</pre>

#### CWanted::SetWantedLevel

<pre>
plugin::CallMethod<0x4D1FA0, CWanted *, int>(this, level);
0AA6: call_method 0x4D1FA0 struct [CWanted] num_params 1 pop 0 [level]
</pre>

#### CWanted::SetWantedLevelNoDrop

<pre>
plugin::CallMethod<0x4D1F50, CWanted *, int>(this, arg0);
0AA6: call_method 0x4D1F50 struct [CWanted] num_params 1 pop 0 [arg0]
</pre>

#### CWanted::Update

<pre>
plugin::CallMethod<0x4D2260, CWanted *>(this);
0AA6: call_method 0x4D2260 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::UpdateWantedLevel

<pre>
plugin::CallMethod<0x4D2110, CWanted *>(this);
0AA6: call_method 0x4D2110 struct [CWanted] num_params 0 pop 0
</pre>

#### CWanted::WorkOutPolicePresence

<pre>
plugin::Call<0x4D1B00, CVector, float>(arg0, arg1);
0AA5: call_function 0x4D1B00 num_params 2 pop 2 [arg0] [arg1]
</pre>

### plugin_vc\game_vc\CWaterCannons.cpp

#### CWaterCannon::CWaterCannon

<pre>
plugin::CallMethod<0x57BE40, CWaterCannon *>(this);
0AA6: call_method 0x57BE40 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::Init

<pre>
plugin::CallMethod<0x57BCD0, CWaterCannon *>(this);
0AA6: call_method 0x57BCD0 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::PushPeds

<pre>
plugin::CallMethod<0x57B2F0, CWaterCannon *>(this);
0AA6: call_method 0x57B2F0 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::Render

<pre>
plugin::CallMethod<0x57B810, CWaterCannon *>(this);
0AA6: call_method 0x57B810 struct [CWaterCannon] num_params 0 pop 0
</pre>

#### CWaterCannon::Update_OncePerFrame

<pre>
plugin::CallMethod<0x57BB90, CWaterCannon *, short>(this, index);
0AA6: call_method 0x57BB90 struct [CWaterCannon] num_params 1 pop 0 [index]
</pre>

#### CWaterCannons::Init

<pre>
plugin::Call<0x57B2C0>();
0AA5: call_function 0x57B2C0 num_params 0 pop 0
</pre>

#### CWaterCannons::Render

<pre>
plugin::Call<0x57B0E0>();
0AA5: call_function 0x57B0E0 num_params 0 pop 0
</pre>

#### CWaterCannons::Update

<pre>
plugin::Call<0x57B120>();
0AA5: call_function 0x57B120 num_params 0 pop 0
</pre>

#### CWaterCannons::UpdateOne

<pre>
plugin::Call<0x57B160, unsigned int, CVector*, CVector*>(pCar, posn, moveSpeed);
0AA5: call_function 0x57B160 num_params 3 pop 3 [pCar] [posn] [moveSpeed]
</pre>

### plugin_vc\game_vc\CWeaponEffects.cpp

#### CWeaponEffects::CWeaponEffects

<pre>
plugin::CallMethod<0x5D5140, CWeaponEffects *>(this);
0AA6: call_method 0x5D5140 struct [CWeaponEffects] num_params 0 pop 0
</pre>

#### CWeaponEffects::ClearCrossHair

<pre>
plugin::Call<0x5D5050>();
0AA5: call_function 0x5D5050 num_params 0 pop 0
</pre>

#### CWeaponEffects::Init

<pre>
plugin::Call<0x5D50B0>();
0AA5: call_function 0x5D50B0 num_params 0 pop 0
</pre>

#### CWeaponEffects::MarkTarget

<pre>
plugin::Call<0x5D5060, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float>(pos, red, green, blue, alpha, size);
0AA5: call_function 0x5D5060 num_params 6 pop 6 [pos] [red] [green] [blue] [alpha] [size]
</pre>

#### CWeaponEffects::Render

<pre>
plugin::Call<0x5D4E90>();
0AA5: call_function 0x5D4E90 num_params 0 pop 0
</pre>

#### CWeaponEffects::Shutdown

<pre>
plugin::Call<0x5D5090>();
0AA5: call_function 0x5D5090 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CWeaponInfo.cpp

#### CWeaponInfo::CWeaponInfo

<pre>
plugin::CallMethod<0x5D58D0, CWeaponInfo *>(this);
0AA6: call_method 0x5D58D0 struct [CWeaponInfo] num_params 0 pop 0
</pre>

#### CWeaponInfo::~CWeaponInfo

<pre>
plugin::CallMethod<0x5D58C0, CWeaponInfo *>(this);
0AA6: call_method 0x5D58C0 struct [CWeaponInfo] num_params 0 pop 0
</pre>

#### CWeaponInfo::FindWeaponFireType

<pre>
plugin::CallAndReturn<eWeaponFire, 0x5D5170, char*>(name);
0AA7: call_function_return 0x5D5170 num_params 1 pop 1 [name] func_ret [eWeaponFire]
</pre>

#### CWeaponInfo::GetWeaponInfo

<pre>
plugin::CallAndReturn<CWeaponInfo*, 0x5D5710, eWeaponType>(weaponType);
0AA7: call_function_return 0x5D5710 num_params 1 pop 1 [weaponType] func_ret [CWeaponInfo*]
</pre>

#### CWeaponInfo::Initialise

<pre>
plugin::Call<0x5D5750>();
0AA5: call_function 0x5D5750 num_params 0 pop 0
</pre>

#### CWeaponInfo::LoadWeaponData

<pre>
plugin::Call<0x5D5250>();
0AA5: call_function 0x5D5250 num_params 0 pop 0
</pre>

#### CWeaponInfo::Shutdown

<pre>
plugin::Call<0x5D5730>();
0AA5: call_function 0x5D5730 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CWeaponModelInfo.cpp

#### CWeaponModelInfo::GetWeaponInfo

<pre>
plugin::CallMethodAndReturn<int, 0x629C20, CWeaponModelInfo *>(this);
0AA8: call_method_return 0x629C20 struct [CWeaponModelInfo] num_params 0 pop 0 func_ret [int]
</pre>

#### CWeaponModelInfo::Init

<pre>
plugin::CallMethod<0x629C70, CWeaponModelInfo *>(this);
0AA6: call_method 0x629C70 struct [CWeaponModelInfo] num_params 0 pop 0
</pre>

#### CWeaponModelInfo::SetWeaponInfo

<pre>
plugin::CallMethodAndReturn<int, 0x629C30, CWeaponModelInfo *, int>(this, weaponType);
0AA8: call_method_return 0x629C30 struct [CWeaponModelInfo] num_params 1 pop 0 [weaponType] func_ret [int]
</pre>

#### WeaponModelStore::~WeaponModelStore

<pre>
plugin::CallMethod<0x5601E0, WeaponModelStore *>(this);
0AA6: call_method 0x5601E0 struct [WeaponModelStore] num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CWeather.cpp

#### CWeather::AddRain

<pre>
plugin::Call<0x57C900>();
0AA5: call_function 0x57C900 num_params 0 pop 0
</pre>

#### CWeather::AddSplashesDuringHurricane

<pre>
plugin::Call<0x57D160>();
0AA5: call_function 0x57D160 num_params 0 pop 0
</pre>

#### CWeather::AddStreamAfterRain

<pre>
plugin::Call<0x57D340>();
0AA5: call_function 0x57D340 num_params 0 pop 0
</pre>

#### CWeather::ForceWeather

<pre>
plugin::Call<0x57D570, short>(weather);
0AA5: call_function 0x57D570 num_params 1 pop 1 [weather]
</pre>

#### CWeather::ForceWeatherNow

<pre>
plugin::Call<0x57D550, short>(weather);
0AA5: call_function 0x57D550 num_params 1 pop 1 [weather]
</pre>

#### CWeather::Init

<pre>
plugin::Call<0x57E040>();
0AA5: call_function 0x57E040 num_params 0 pop 0
</pre>

#### CWeather::ReleaseWeather

<pre>
plugin::Call<0x57D540>();
0AA5: call_function 0x57D540 num_params 0 pop 0
</pre>

#### CWeather::RenderRainStreaks

<pre>
plugin::Call<0x57BF40>();
0AA5: call_function 0x57BF40 num_params 0 pop 0
</pre>

#### CWeather::Update

<pre>
plugin::Call<0x57D580>();
0AA5: call_function 0x57D580 num_params 0 pop 0
</pre>

### plugin_vc\game_vc\CWindModifiers.cpp

#### CWindModifiers::FindWindModifier

<pre>
plugin::CallAndReturnDynGlobal<bool, CVector, float *, float *>(gaddrof_o(CWindModifiers::FindWindModifier, bool (*)(CVector, float *, float *)), pos, x, y);
</pre>

#### CWindModifiers::RegisterOne

<pre>
plugin::CallDynGlobal<CVector, int>(gaddrof_o(CWindModifiers::RegisterOne, void (*)(CVector, int)), pos, type);
</pre>

### plugin_vc\game_vc\CWorld.cpp

#### CWorld::Add

<pre>
plugin::Call<0x4DB3F0, CEntity*>(entity);
0AA5: call_function 0x4DB3F0 num_params 1 pop 1 [entity]
</pre>

#### CWorld::AddParticles

<pre>
plugin::Call<0x4D4BB0>();
0AA5: call_function 0x4D4BB0 num_params 0 pop 0
</pre>

#### CWorld::CallOffChaseForArea

<pre>
plugin::Call<0x4D3200, float, float, float, float>(x1, y1, x2, y2);
0AA5: call_function 0x4D3200 num_params 4 pop 4 [x1] [y1] [x2] [y2]
</pre>

#### CWorld::CallOffChaseForAreaSectorListPeds

<pre>
plugin::Call<0x4D2DF0, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
0AA5: call_function 0x4D2DF0 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CWorld::CallOffChaseForAreaSectorListVehicles

<pre>
plugin::Call<0x4D2F50, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);
0AA5: call_function 0x4D2F50 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]
</pre>

#### CWorld::ClearCarsFromArea

<pre>
plugin::Call<0x4D3700, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x4D3700 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CWorld::ClearExcitingStuffFromArea

<pre>
plugin::Call<0x4D38F0, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);
0AA5: call_function 0x4D38F0 num_params 3 pop 3 [point] [radius] [bRemoveProjectilesAndShadows]
</pre>

#### CWorld::ClearForRestart

<pre>
plugin::Call<0x4DB4A0>();
0AA5: call_function 0x4DB4A0 num_params 0 pop 0
</pre>

#### CWorld::ClearPedsFromArea

<pre>
plugin::Call<0x4D35C0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);
0AA5: call_function 0x4D35C0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]
</pre>

#### CWorld::ClearScanCodes

<pre>
plugin::Call<0x4D7460>();
0AA5: call_function 0x4D7460 num_params 0 pop 0
</pre>

#### CWorld::ExtinguishAllCarFiresInArea

<pre>
plugin::Call<0x4D3480, CVector, float>(point, radius);
0AA5: call_function 0x4D3480 num_params 2 pop 2 [point] [radius]
</pre>

#### CWorld::FindGroundZFor3DCoord

<pre>
plugin::CallAndReturn<float, 0x4D53A0, float, float, float, bool*>(x, y, z, outResult);
0AA7: call_function_return 0x4D53A0 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]
</pre>

#### CWorld::FindGroundZForCoord

<pre>
plugin::CallAndReturn<float, 0x4D5540, float, float>(x, y);
0AA7: call_function_return 0x4D5540 num_params 2 pop 2 [x] [y] func_ret [float]
</pre>

#### CWorld::FindMissionEntitiesIntersectingCube

<pre>
plugin::Call<0x4D5800, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);
0AA5: call_function 0x4D5800 num_params 8 pop 8 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehicles] [peds] [objects]
</pre>

#### CWorld::FindMissionEntitiesIntersectingCubeSectorList

<pre>
plugin::Call<0x4D56B0, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool>(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);
0AA5: call_function 0x4D56B0 num_params 9 pop 9 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehiclesList] [pedsList] [objectsList]
</pre>

#### CWorld::FindObjectsInRange

<pre>
plugin::Call<0x4D6B90, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4D6B90 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsInRangeSectorList

<pre>
plugin::Call<0x4D6AD0, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x4D6AD0 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsIntersectingAngledCollisionBox

<pre>
plugin::Call<0x4D5B90, CBox const&, CMatrix const&, CVector const&, float, float, float, float, short*, short, CEntity**, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4D5B90 num_params 15 pop 15 [box] [transform] [point] [x1] [y1] [x2] [y2] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList

<pre>
plugin::Call<0x4D5A90, CPtrList&, CBox const&, CMatrix const&, CVector const&, short*, short, CEntity**>(list, box, transform, point, outCount, maxCount, outEntities);
0AA5: call_function 0x4D5A90 num_params 7 pop 7 [list] [box] [transform] [point] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsIntersectingCube

<pre>
plugin::Call<0x4D5FB0, CVector const&, CVector const&, short*, short, CEntity**, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4D5FB0 num_params 10 pop 10 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsIntersectingCubeSectorList

<pre>
plugin::Call<0x4D5EA0, CPtrList&, CVector const&, CVector const&, short*, short, CEntity**>(list, cornerA, cornerB, outCount, maxCount, outEntities);
0AA5: call_function 0x4D5EA0 num_params 6 pop 6 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsKindaColliding

<pre>
plugin::Call<0x4D6370, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4D6370 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsKindaCollidingSectorList

<pre>
plugin::Call<0x4D6280, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(list, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x4D6280 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindObjectsOfTypeInRange

<pre>
plugin::Call<0x4D6770, unsigned int, CVector const&, float, bool, short*, short, CEntity**, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);
0AA5: call_function 0x4D6770 num_params 12 pop 12 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]
</pre>

#### CWorld::FindObjectsOfTypeInRangeSectorList

<pre>
plugin::Call<0x4D66A0, unsigned int, CPtrList&, CVector const&, float, bool, short*, short, CEntity**>(modelId, list, point, radius, b2D, outCount, maxCount, outEntities);
0AA5: call_function 0x4D66A0 num_params 8 pop 8 [modelId] [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]
</pre>

#### CWorld::FindRoofZFor3DCoord

<pre>
plugin::CallAndReturn<float, 0x4D51D0, float, float, float, bool*>(x, y, z, outResult);
0AA7: call_function_return 0x4D51D0 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]
</pre>

#### CWorld::GetIsLineOfSightClear

<pre>
plugin::CallAndReturn<bool, 0x4DA560, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4DA560 num_params 9 pop 9 [origin] [target] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::GetIsLineOfSightSectorClear

<pre>
plugin::CallAndReturn<bool, 0x4D6EC0, CSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);
0AA7: call_function_return 0x4D6EC0 num_params 9 pop 9 [sector] [line] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]
</pre>

#### CWorld::Initialise

<pre>
plugin::Call<0x4DB9A0>();
0AA5: call_function 0x4DB9A0 num_params 0 pop 0
</pre>

#### CWorld::IsWanderPathClear

<pre>
plugin::CallAndReturn<bool, 0x4D2620, CVector const&, CVector const&, float, int>(origin, target, arg2, arg3);
0AA7: call_function_return 0x4D2620 num_params 4 pop 4 [origin] [target] [arg2] [arg3] func_ret [bool]
</pre>

#### CWorld::Process

<pre>
plugin::Call<0x4D7500>();
0AA5: call_function 0x4D7500 num_params 0 pop 0
</pre>

#### CWorld::ProcessLineOfSight

<pre>
plugin::CallAndReturn<bool, 0x4D92D0, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
0AA7: call_function_return 0x4D92D0 num_params 12 pop 12 [origin] [target] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CWorld::ProcessLineOfSightSector

<pre>
plugin::CallAndReturn<bool, 0x4D9060, CSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
0AA7: call_function_return 0x4D9060 num_params 13 pop 13 [sector] [line] [outColPoint] [maxTouchDistance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CWorld::ProcessLineOfSightSectorList

<pre>
plugin::CallAndReturn<bool, 0x4D8C60, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);
0AA7: call_function_return 0x4D8C60 num_params 8 pop 8 [list] [line] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLine

<pre>
plugin::CallAndReturn<bool, 0x4D8B00, CVector const&, float, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x4D8B00 num_params 11 pop 11 [origin] [distance] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::ProcessVerticalLineSector

<pre>
plugin::CallAndReturn<bool, 0x4D84D0, CSector&, CColLine const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, CStoredCollPoly*>(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);
0AA7: call_function_return 0x4D84D0 num_params 11 pop 11 [sector] [line] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]
</pre>

#### CWorld::Remove

<pre>
plugin::Call<0x4DB310, CEntity*>(entity);
0AA5: call_function 0x4DB310 num_params 1 pop 1 [entity]
</pre>

#### CWorld::RemoveFallenCars

<pre>
plugin::Call<0x4D48A0>();
0AA5: call_function 0x4D48A0 num_params 0 pop 0
</pre>

#### CWorld::RemoveFallenPeds

<pre>
plugin::Call<0x4D4A40>();
0AA5: call_function 0x4D4A40 num_params 0 pop 0
</pre>

#### CWorld::RemoveReferencesToDeletedObject

<pre>
plugin::Call<0x4D5090, CEntity*>(entity);
0AA5: call_function 0x4D5090 num_params 1 pop 1 [entity]
</pre>

#### CWorld::RepositionCertainDynamicObjects

<pre>
plugin::Call<0x4D4850>();
0AA5: call_function 0x4D4850 num_params 0 pop 0
</pre>

#### CWorld::RepositionOneObject

<pre>
plugin::Call<0x4D43A0, CEntity*>(entity);
0AA5: call_function 0x4D43A0 num_params 1 pop 1 [entity]
</pre>

#### CWorld::SetAllCarsCanBeDamaged

<pre>
plugin::Call<0x4D3550, bool>(enable);
0AA5: call_function 0x4D3550 num_params 1 pop 1 [enable]
</pre>

#### CWorld::SetCarsOnFire

<pre>
plugin::Call<0x4D4C30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
0AA5: call_function 0x4D4C30 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]
</pre>

#### CWorld::SetPedsChoking

<pre>
plugin::Call<0x4D4D90, float, float, float, float, CEntity*>(x, y, z, radius, gasCreator);
0AA5: call_function 0x4D4D90 num_params 5 pop 5 [x] [y] [z] [radius] [gasCreator]
</pre>

#### CWorld::SetPedsOnFire

<pre>
plugin::Call<0x4D4F30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);
0AA5: call_function 0x4D4F30 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]
</pre>

#### CWorld::ShutDown

<pre>
plugin::Call<0x4DB590>();
0AA5: call_function 0x4DB590 num_params 0 pop 0
</pre>

#### CWorld::StopAllLawEnforcersInTheirTracks

<pre>
plugin::Call<0x4D25B0>();
0AA5: call_function 0x4D25B0 num_params 0 pop 0
</pre>

#### CWorld::TestSphereAgainstSectorList

<pre>
plugin::CallAndReturn<CEntity*, 0x4D3C40, CPtrList&, CVector, float, CEntity*, bool>(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);
0AA7: call_function_return 0x4D3C40 num_params 5 pop 5 [list] [sphereCenter] [sphereRadius] [ignoreEntity] [doCameraIgnoreCheck] func_ret [CEntity*]
</pre>

#### CWorld::TestSphereAgainstWorld

<pre>
plugin::CallAndReturn<CEntity*, 0x4D3F40, CVector, float, CEntity*, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck);
0AA7: call_function_return 0x4D3F40 num_params 9 pop 9 [sphereCenter] [sphereRadius] [ignoreEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] func_ret [CEntity*]
</pre>

#### CWorld::TriggerExplosion

<pre>
plugin::Call<0x4D82D0, CVector const&, float, float, CEntity*, bool>(point, radius, visibleDistance, entity, processVehicleBombTimer);
0AA5: call_function 0x4D82D0 num_params 5 pop 5 [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]
</pre>

#### CWorld::TriggerExplosionSectorList

<pre>
plugin::Call<0x4D7B90, CPtrList&, CVector const&, float, float, CEntity*, bool>(list, point, radius, visibleDistance, entity, processVehicleBombTimer);
0AA5: call_function 0x4D7B90 num_params 6 pop 6 [list] [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]
</pre>

#### CWorld::UseDetonator

<pre>
plugin::Call<0x4D42F0, CEntity*>(creator);
0AA5: call_function 0x4D42F0 num_params 1 pop 1 [creator]
</pre>

### plugin_vc\game_vc\CZone.cpp

#### CZone::GetTranslatedName

<pre>
plugin::CallMethodAndReturn<wchar_t*, 0x4DE4B0, CZone*>(this);
0AA8: call_method_return 0x4DE4B0 struct [CZone] num_params 0 pop 0 func_ret [wchar_t*]
</pre>

### plugin_vc\game_vc\NodeName.cpp

#### \*GetFrameNodeName

<pre>
plugin::CallAndReturnDynGlobal<char *, RwFrame *>(gaddrof(GetFrameNodeName), frame);
</pre>

#### NodeNamePluginAttach

<pre>
plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(NodeNamePluginAttach));
</pre>

#### NodeNameStreamGetSize

<pre>
plugin::CallAndReturnDynGlobal<RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamGetSize), object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameStreamRead

<pre>
plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void *, RwInt32, RwInt32>(gaddrof(NodeNameStreamRead), stream, binaryLength, object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameStreamWrite

<pre>
plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamWrite), stream, binaryLength, object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameCopy

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(NodeNameCopy), dstObject, srcObject, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameDestructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameDestructor), object, offsetInObject, sizeInObject);
</pre>

#### \*NodeNameConstructor

<pre>
plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameConstructor), object, offsetInObject, sizeInObject);
</pre>

### plugin_vc\game_vc\meta\meta.cAudioScriptObject.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</pre>

#### \*operator_new<cAudioScriptObject>

<pre>
plugin::CallAndReturnDynGlobal<void *, unsigned int>(op_new_gaddr(cAudioScriptObject), sizeof(cAudioScriptObject));
</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), obj);</pre>

#### plugin::CallMethodDynGlobal<cAudioScriptObject \*>

<pre>
plugin::CallDynGlobal<void *>(op_delete_gaddr(cAudioScriptObject), obj);
</pre>

####

<pre>
plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CBulletTrace.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), reinterpret_cast<CBulletTrace *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CCutsceneShadow.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), reinterpret_cast<CCutsceneShadow *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), reinterpret_cast<CCutsceneShadow *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CDirectory.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), reinterpret_cast<CDirectory *>(objBuff), entriesNum);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), reinterpret_cast<CDirectory *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), obj, entriesNum);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CPad.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), reinterpret_cast<CPad *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), reinterpret_cast<CPad *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CParticle.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CPedAttractor.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPedAttractor *, C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float>(ctor_gaddr_o(CPedAttractor, void(C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float)), reinterpret_cast<CPedAttractor *>(objBuff), effect, matrix, maxPeds, qDist, waitTime, approachTime, distance, headingDiff, posDisp, headDisp);</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPedAttractor *>(dtor_gaddr(CPedAttractor), reinterpret_cast<CPedAttractor *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPedAttractor *, C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float>(ctor_gaddr_o(CPedAttractor, void(C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float)), obj, effect, matrix, maxPeds, qDist, waitTime, approachTime, distance, headingDiff, posDisp, headDisp);</pre>

####

<pre>
plugin::CallVirtualMethod<1, CPedAttractor *, unsigned char>(obj, 1);
</pre>

####

<pre>
plugin::CallVirtualMethod<1, CPedAttractor *, unsigned char>(&objArray[i], 1);
</pre>

### plugin_vc\game_vc\meta\meta.CPhone.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</pre>

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), &objArray[i]);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CPhoneInfo.h

#### ~stack_object

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CPointLight.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), reinterpret_cast<CPointLight *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CRouteNode.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), reinterpret_cast<CRouteNode *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), &objArray[i]);</pre>

### plugin_vc\game_vc\meta\meta.CWindModifiers.h

#### stack_object

<pre>
plugin::CallMethodDynGlobal<CWindModifier *>(ctor_gaddr(CWindModifier), reinterpret_cast<CWindModifier *>(objBuff));</pre>

#### \*>

<pre>
plugin::CallMethodDynGlobal<CWindModifier *>(ctor_gaddr(CWindModifier), obj);</pre>

####

<pre>
plugin::CallMethodDynGlobal<CWindModifier *>(ctor_gaddr(CWindModifier), &objArray[i]);
