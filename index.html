<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<style>p {font-family: monospace; }</style>
</head>
<body><ul>
<li>plugin_III<ul>
<li>game_III<ul>
<li><a href="#plugin_iiigame_iiic_pcsavecpp">C_PcSave.cpp</a></li>
<li><a href="#plugin_iiigame_iiic2deffectcpp">C2dEffect.cpp</a></li>
<li><a href="#plugin_iiigame_iiic3dmarkercpp">C3dMarker.cpp</a></li>
<li><a href="#plugin_iiigame_iiic3dmarkerscpp">C3dMarkers.cpp</a></li>
<li><a href="#plugin_iiigame_iiicaccidentmanagercpp">CAccidentManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimblendassocgroupcpp">CAnimBlendAssocGroup.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimblendassociationcpp">CAnimBlendAssociation.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimblendclumpdatacpp">CAnimBlendClumpData.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimblendhierarchycpp">CAnimBlendHierarchy.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimblendnodecpp">CAnimBlendNode.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimblendsequencecpp">CAnimBlendSequence.cpp</a></li>
<li><a href="#plugin_iiigame_iiicanimmanagercpp">CAnimManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicantennacpp">CAntenna.cpp</a></li>
<li><a href="#plugin_iiigame_iiicantennascpp">CAntennas.cpp</a></li>
<li><a href="#plugin_iiigame_iiicaudiocollisionmanagercpp">cAudioCollisionManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicaudiohydrantcpp">CAudioHydrant.cpp</a></li>
<li><a href="#plugin_iiigame_iiicaudiomanagercpp">cAudioManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicaudioscriptobjectcpp">cAudioScriptObject.cpp</a></li>
<li><a href="#plugin_iiigame_iiicautomobilecpp">CAutomobile.cpp</a></li>
<li><a href="#plugin_iiigame_iiicautopilotcpp">CAutoPilot.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbasemodelinfocpp">CBaseModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicboatcpp">CBoat.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbridgecpp">CBridge.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbrightlightscpp">CBrightLights.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbuildingcpp">CBuilding.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbulletinfocpp">CBulletInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbullettracecpp">CBulletTrace.cpp</a></li>
<li><a href="#plugin_iiigame_iiicbullettracescpp">CBulletTraces.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccameracpp">CCamera.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccaraicpp">CCarAI.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccarctrlcpp">CCarCtrl.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccargeneratorcpp">CCarGenerator.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccivilianpedcpp">CCivilianPed.cpp</a></li>
<li><a href="#plugin_iiigame_iiicclockcpp">CClock.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccloudscpp">CClouds.cpp</a></li>
<li><a href="#plugin_iiigame_iiicclumpmodelinfocpp">CClumpModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccolboxcpp">CColBox.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccollinecpp">CColLine.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccollisioncpp">CCollision.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccolmodelcpp">CColModel.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccolspherecpp">CColSphere.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccoltrianglecpp">CColTriangle.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccoltriangleplanecpp">CColTrianglePlane.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccontrollerstatecpp">CControllerState.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccoppedcpp">CCopPed.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccoronascpp">CCoronas.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccranecpp">CCrane.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccranescpp">CCranes.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccreditscpp">CCredits.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccurrentvehiclecpp">CCurrentVehicle.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccurvescpp">CCurves.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccutsceneheadcpp">CCutsceneHead.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccutscenemgrcpp">CCutsceneMgr.cpp</a></li>
<li><a href="#plugin_iiigame_iiiccutsceneobjectcpp">CCutsceneObject.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdamagemanagercpp">CDamageManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdarkelcpp">CDarkel.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdigitalclockcpp">CDigitalClock.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdirectorycpp">CDirectory.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdmaudiocpp">cDMAudio.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdoorcpp">CDoor.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdrawcpp">CDraw.cpp</a></li>
<li><a href="#plugin_iiigame_iiicdummycpp">CDummy.cpp</a></li>
<li><a href="#plugin_iiigame_iiicemergencypedcpp">CEmergencyPed.cpp</a></li>
<li><a href="#plugin_iiigame_iiicentitycpp">CEntity.cpp</a></li>
<li><a href="#plugin_iiigame_iiiceventlistcpp">CEventList.cpp</a></li>
<li><a href="#plugin_iiigame_iiicexplosioncpp">CExplosion.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfallingglasspanecpp">CFallingGlassPane.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfileloadercpp">CFileLoader.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfilemgrcpp">CFileMgr.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfirecpp">CFire.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfiremanagercpp">CFireManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfontcpp">CFont.cpp</a></li>
<li><a href="#plugin_iiigame_iiicfontdetailscpp">CFontDetails.cpp</a></li>
<li><a href="#plugin_iiigame_iiicgamecpp">CGame.cpp</a></li>
<li><a href="#plugin_iiigame_iiicgamelogiccpp">CGameLogic.cpp</a></li>
<li><a href="#plugin_iiigame_iiicgangscpp">CGangs.cpp</a></li>
<li><a href="#plugin_iiigame_iiicgaragecpp">CGarage.cpp</a></li>
<li><a href="#plugin_iiigame_iiicgaragescpp">CGarages.cpp</a></li>
<li><a href="#plugin_iiigame_iiicgeneralcpp">CGeneral.cpp</a></li>
<li><a href="#plugin_iiigame_iiicglasscpp">CGlass.cpp</a></li>
<li><a href="#plugin_iiigame_iiichelicpp">CHeli.cpp</a></li>
<li><a href="#plugin_iiigame_iiichudcpp">CHud.cpp</a></li>
<li><a href="#plugin_iiigame_iiicinstancecpp">CInstance.cpp</a></li>
<li><a href="#plugin_iiigame_iiickeyboardstatecpp">CKeyboardState.cpp</a></li>
<li><a href="#plugin_iiigame_iiiclinescpp">CLines.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmatrixcpp">CMatrix.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmblurcpp">CMBlur.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmenumanagercpp">CMenuManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmessagescpp">CMessages.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmissioncleanupcpp">CMissionCleanup.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmlomodelinfocpp">CMloModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmodelinfocpp">CModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmoneymessagecpp">CMoneyMessage.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmotionblurstreakscpp">CMotionBlurStreaks.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmousecontrollerstatecpp">CMouseControllerState.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmousepointerstatehelpercpp">CMousePointerStateHelper.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmovingthingcpp">CMovingThing.cpp</a></li>
<li><a href="#plugin_iiigame_iiicmusicmanagercpp">cMusicManager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicobjectcpp">CObject.cpp</a></li>
<li><a href="#plugin_iiigame_iiicobjectdatacpp">CObjectData.cpp</a></li>
<li><a href="#plugin_iiigame_iiicommoncpp">common.cpp</a></li>
<li><a href="#plugin_iiigame_iiiconesheetcpp">COneSheet.cpp</a></li>
<li><a href="#plugin_iiigame_iiiconscreentimercpp">COnscreenTimer.cpp</a></li>
<li><a href="#plugin_iiigame_iiiconscreentimerentrycpp">COnscreenTimerEntry.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpacmanpickupcpp">CPacManPickup.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpacmanpickupscpp">CPacManPickups.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpadcpp">CPad.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpagercpp">CPager.cpp</a></li>
<li><a href="#plugin_iiigame_iiicparticlecpp">CParticle.cpp</a></li>
<li><a href="#plugin_iiigame_iiicparticleobjectcpp">CParticleObject.cpp</a></li>
<li><a href="#plugin_iiigame_iiicparticlesystemmgrcpp">cParticleSystemMgr.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpathfindcpp">CPathFind.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedcpp">CPed.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedikcpp">CPedIK.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedmodelinfocpp">CPedModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedpathcpp">CPedPath.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedplacementcpp">CPedPlacement.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedstatscpp">CPedStats.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpedtypecpp">CPedType.cpp</a></li>
<li><a href="#plugin_iiigame_iiicphoneinfocpp">CPhoneInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicphysicalcpp">CPhysical.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpickupcpp">CPickup.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpickupscpp">CPickups.cpp</a></li>
<li><a href="#plugin_iiigame_iiicplaceablecpp">CPlaceable.cpp</a></li>
<li><a href="#plugin_iiigame_iiicplacenamecpp">CPlaceName.cpp</a></li>
<li><a href="#plugin_iiigame_iiicplanecpp">CPlane.cpp</a></li>
<li><a href="#plugin_iiigame_iiicplayerinfocpp">CPlayerInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicplayerpedcpp">CPlayerPed.cpp</a></li>
<li><a href="#plugin_iiigame_iiicplayerskincpp">CPlayerSkin.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpointlightscpp">CPointLights.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpoolscpp">CPools.cpp</a></li>
<li><a href="#plugin_iiigame_iiicpopulationcpp">CPopulation.cpp</a></li>
<li><a href="#plugin_iiigame_iiicprojectileinfocpp">CProjectileInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicquaternioncpp">CQuaternion.cpp</a></li>
<li><a href="#plugin_iiigame_iiicradarcpp">CRadar.cpp</a></li>
<li><a href="#plugin_iiigame_iiicrange2dcpp">CRange2D.cpp</a></li>
<li><a href="#plugin_iiigame_iiicrecorddataforchasecpp">CRecordDataForChase.cpp</a></li>
<li><a href="#plugin_iiigame_iiicrecorddataforgamecpp">CRecordDataForGame.cpp</a></li>
<li><a href="#plugin_iiigame_iiicregisteredcoronacpp">CRegisteredCorona.cpp</a></li>
<li><a href="#plugin_iiigame_iiicregisteredmotionblurstreakcpp">CRegisteredMotionBlurStreak.cpp</a></li>
<li><a href="#plugin_iiigame_iiicremotecpp">CRemote.cpp</a></li>
<li><a href="#plugin_iiigame_iiicrestartcpp">CRestart.cpp</a></li>
<li><a href="#plugin_iiigame_iiicroadblockscpp">CRoadBlocks.cpp</a></li>
<li><a href="#plugin_iiigame_iiicroutenodecpp">CRouteNode.cpp</a></li>
<li><a href="#plugin_iiigame_iiicrubbishcpp">CRubbish.cpp</a></li>
<li><a href="#plugin_iiigame_iiicrunningscriptcpp">CRunningScript.cpp</a></li>
<li><a href="#plugin_iiigame_iiicsceneeditcpp">CSceneEdit.cpp</a></li>
<li><a href="#plugin_iiigame_iiicscrollbarcpp">CScrollBar.cpp</a></li>
<li><a href="#plugin_iiigame_iiicshadowscpp">CShadows.cpp</a></li>
<li><a href="#plugin_iiigame_iiicshinytextscpp">CShinyTexts.cpp</a></li>
<li><a href="#plugin_iiigame_iiicshotinfocpp">CShotInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicsimplemodelinfocpp">CSimpleModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicskidmarkscpp">CSkidmarks.cpp</a></li>
<li><a href="#plugin_iiigame_iiicspecialfxcpp">CSpecialFX.cpp</a></li>
<li><a href="#plugin_iiigame_iiicspecialparticlestuffcpp">CSpecialParticleStuff.cpp</a></li>
<li><a href="#plugin_iiigame_iiicspritecpp">CSprite.cpp</a></li>
<li><a href="#plugin_iiigame_iiicsprite2dcpp">CSprite2d.cpp</a></li>
<li><a href="#plugin_iiigame_iiicstatscpp">CStats.cpp</a></li>
<li><a href="#plugin_iiigame_iiicstoredcarcpp">CStoredCar.cpp</a></li>
<li><a href="#plugin_iiigame_iiicstreamingcpp">CStreaming.cpp</a></li>
<li><a href="#plugin_iiigame_iiicstreaminginfocpp">CStreamingInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicstuckcarcheckcpp">CStuckCarCheck.cpp</a></li>
<li><a href="#plugin_iiigame_iiicsurfacetablecpp">CSurfaceTable.cpp</a></li>
<li><a href="#plugin_iiigame_iiictextcpp">CText.cpp</a></li>
<li><a href="#plugin_iiigame_iiicthecargeneratorscpp">CTheCarGenerators.cpp</a></li>
<li><a href="#plugin_iiigame_iiicthescriptscpp">CTheScripts.cpp</a></li>
<li><a href="#plugin_iiigame_iiicthezonescpp">CTheZones.cpp</a></li>
<li><a href="#plugin_iiigame_iiictimemodelinfocpp">CTimeModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiictimercpp">CTimer.cpp</a></li>
<li><a href="#plugin_iiigame_iiictowerclockcpp">CTowerClock.cpp</a></li>
<li><a href="#plugin_iiigame_iiictrafficlightscpp">CTrafficLights.cpp</a></li>
<li><a href="#plugin_iiigame_iiictraincpp">CTrain.cpp</a></li>
<li><a href="#plugin_iiigame_iiictraindoorcpp">CTrainDoor.cpp</a></li>
<li><a href="#plugin_iiigame_iiictransmissioncpp">cTransmission.cpp</a></li>
<li><a href="#plugin_iiigame_iiictreadablecpp">CTreadable.cpp</a></li>
<li><a href="#plugin_iiigame_iiictxdstorecpp">CTxdStore.cpp</a></li>
<li><a href="#plugin_iiigame_iiicupsidedowncarcheckcpp">CUpsideDownCarCheck.cpp</a></li>
<li><a href="#plugin_iiigame_iiicvehiclecpp">CVehicle.cpp</a></li>
<li><a href="#plugin_iiigame_iiicvehiclemodelinfocpp">CVehicleModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicvisibilitypluginscpp">CVisibilityPlugins.cpp</a></li>
<li><a href="#plugin_iiigame_iiicwantedcpp">CWanted.cpp</a></li>
<li><a href="#plugin_iiigame_iiicwatercannoncpp">CWaterCannon.cpp</a></li>
<li><a href="#plugin_iiigame_iiicwatercannonscpp">CWaterCannons.cpp</a></li>
<li><a href="#plugin_iiigame_iiicweaponcpp">CWeapon.cpp</a></li>
<li><a href="#plugin_iiigame_iiicweaponeffectscpp">CWeaponEffects.cpp</a></li>
<li><a href="#plugin_iiigame_iiicweaponinfocpp">CWeaponInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiicweathercpp">CWeather.cpp</a></li>
<li><a href="#plugin_iiigame_iiicworldcpp">CWorld.cpp</a></li>
<li><a href="#plugin_iiigame_iiicxtracompsmodelinfocpp">CXtraCompsModelInfo.cpp</a></li>
<li><a href="#plugin_iiigame_iiiczonecpp">CZone.cpp</a></li>
<li><a href="#plugin_iiigame_iiigenericgamestoragecpp">GenericGameStorage.cpp</a></li>
<li><a href="#plugin_iiigame_iiinodenamecpp">NodeName.cpp</a></li>
<li><a href="#plugin_iiigame_iiirenderbuffercpp">RenderBuffer.cpp</a></li>
<li><a href="#plugin_iiigame_iiirpanimblendcpp">RpAnimBlend.cpp</a></li>
<li><a href="#plugin_iiigame_iiimetac2deffectsmodelinfoh">meta.C2deffectsModelInfo.h</a></li>
<li><a href="#plugin_iiigame_iiimetac3dmarkerh">meta.C3dMarker.h</a></li>
<li><a href="#plugin_iiigame_iiimetacaccidenth">meta.CAccident.h</a></li>
<li><a href="#plugin_iiigame_iiimetacaccidentmanagerh">meta.CAccidentManager.h</a></li>
<li><a href="#plugin_iiigame_iiimetacanimblendassocgrouph">meta.CAnimBlendAssocGroup.h</a></li>
<li><a href="#plugin_iiigame_iiimetacanimblendassociationh">meta.CAnimBlendAssociation.h</a></li>
<li><a href="#plugin_iiigame_iiimetacanimblendclumpdatah">meta.CAnimBlendClumpData.h</a></li>
<li><a href="#plugin_iiigame_iiimetacanimblendhierarchyh">meta.CAnimBlendHierarchy.h</a></li>
<li><a href="#plugin_iiigame_iiimetacanimblendsequenceh">meta.CAnimBlendSequence.h</a></li>
<li><a href="#plugin_iiigame_iiimetacantennah">meta.CAntenna.h</a></li>
<li><a href="#plugin_iiigame_iiimetacaudiocollisionh">meta.cAudioCollision.h</a></li>
<li><a href="#plugin_iiigame_iiimetacaudiohydranth">meta.CAudioHydrant.h</a></li>
<li><a href="#plugin_iiigame_iiimetacaudioscriptobjecth">meta.cAudioScriptObject.h</a></li>
<li><a href="#plugin_iiigame_iiimetacbasemodelinfoh">meta.CBaseModelInfo.h</a></li>
<li><a href="#plugin_iiigame_iiimetacbrightlighth">meta.CBrightLight.h</a></li>
<li><a href="#plugin_iiigame_iiimetacbulletinfoh">meta.CBulletInfo.h</a></li>
<li><a href="#plugin_iiigame_iiimetacbullettraceh">meta.CBulletTrace.h</a></li>
<li><a href="#plugin_iiigame_iiimetaccamerah">meta.CCamera.h</a></li>
<li><a href="#plugin_iiigame_iiimetaccargeneratorh">meta.CCarGenerator.h</a></li>
<li><a href="#plugin_iiigame_iiimetaccollineh">meta.CColLine.h</a></li>
<li><a href="#plugin_iiigame_iiimetaccolpointh">meta.CColPoint.h</a></li>
<li><a href="#plugin_iiigame_iiimetaccurrentvehicleh">meta.CCurrentVehicle.h</a></li>
<li><a href="#plugin_iiigame_iiimetacdateh">meta.CDate.h</a></li>
<li><a href="#plugin_iiigame_iiimetacdigitalclockh">meta.CDigitalClock.h</a></li>
<li><a href="#plugin_iiigame_iiimetacdirectoryh">meta.CDirectory.h</a></li>
<li><a href="#plugin_iiigame_iiimetacdmaudioh">meta.cDMAudio.h</a></li>
<li><a href="#plugin_iiigame_iiimetacentityh">meta.CEntity.h</a></li>
<li><a href="#plugin_iiigame_iiimetaceventlisth">meta.CEventList.h</a></li>
<li><a href="#plugin_iiigame_iiimetacfallingglasspaneh">meta.CFallingGlassPane.h</a></li>
<li><a href="#plugin_iiigame_iiimetacfireh">meta.CFire.h</a></li>
<li><a href="#plugin_iiigame_iiimetacfiremanagerh">meta.CFireManager.h</a></li>
<li><a href="#plugin_iiigame_iiimetacganginfoh">meta.CGangInfo.h</a></li>
<li><a href="#plugin_iiigame_iiimetacinstanceh">meta.CInstance.h</a></li>
<li><a href="#plugin_iiigame_iiimetacmissioncleanuph">meta.CMissionCleanup.h</a></li>
<li><a href="#plugin_iiigame_iiimetacmoneymessageh">meta.CMoneyMessage.h</a></li>
<li><a href="#plugin_iiigame_iiimetacmovieh">meta.CMovie.h</a></li>
<li><a href="#plugin_iiigame_iiimetacmovingthingh">meta.CMovingThing.h</a></li>
<li><a href="#plugin_iiigame_iiimetacmusicmanagerh">meta.cMusicManager.h</a></li>
<li><a href="#plugin_iiigame_iiimetacpacmanpickuph">meta.CPacManPickup.h</a></li>
<li><a href="#plugin_iiigame_iiimetacparticleh">meta.CParticle.h</a></li>
<li><a href="#plugin_iiigame_iiimetacparticleobjecth">meta.CParticleObject.h</a></li>
<li><a href="#plugin_iiigame_iiimetacpathnodeh">meta.CPathNode.h</a></li>
<li><a href="#plugin_iiigame_iiimetacphoneh">meta.CPhone.h</a></li>
<li><a href="#plugin_iiigame_iiimetacphoneinfoh">meta.CPhoneInfo.h</a></li>
<li><a href="#plugin_iiigame_iiimetacpickuph">meta.CPickup.h</a></li>
<li><a href="#plugin_iiigame_iiimetacplaceableh">meta.CPlaceable.h</a></li>
<li><a href="#plugin_iiigame_iiimetacplacenameh">meta.CPlaceName.h</a></li>
<li><a href="#plugin_iiigame_iiimetacradarh">meta.CRadar.h</a></li>
<li><a href="#plugin_iiigame_iiimetacregisteredcoronah">meta.CRegisteredCorona.h</a></li>
<li><a href="#plugin_iiigame_iiimetacregisteredmotionblurstreakh">meta.CRegisteredMotionBlurStreak.h</a></li>
<li><a href="#plugin_iiigame_iiimetacregisteredshinytexth">meta.CRegisteredShinyText.h</a></li>
<li><a href="#plugin_iiigame_iiimetacroutenodeh">meta.CRouteNode.h</a></li>
<li><a href="#plugin_iiigame_iiimetacscrollbarh">meta.CScrollBar.h</a></li>
<li><a href="#plugin_iiigame_iiimetacshotinfoh">meta.CShotInfo.h</a></li>
<li><a href="#plugin_iiigame_iiimetacskidmarkh">meta.CSkidmark.h</a></li>
<li><a href="#plugin_iiigame_iiimetacsprite2dh">meta.CSprite2d.h</a></li>
<li><a href="#plugin_iiigame_iiimetacstoredcollpolyh">meta.CStoredCollPoly.h</a></li>
<li><a href="#plugin_iiigame_iiimetacstuckcarcheckh">meta.CStuckCarCheck.h</a></li>
<li><a href="#plugin_iiigame_iiimetactempnodeh">meta.CTempNode.h</a></li>
<li><a href="#plugin_iiigame_iiimetactexth">meta.CText.h</a></li>
<li><a href="#plugin_iiigame_iiimetactowerclockh">meta.CTowerClock.h</a></li>
<li><a href="#plugin_iiigame_iiimetactraincamnodeh">meta.CTrainCamNode.h</a></li>
<li><a href="#plugin_iiigame_iiimetactraindoorh">meta.CTrainDoor.h</a></li>
<li><a href="#plugin_iiigame_iiimetacwantedh">meta.CWanted.h</a></li>
<li><a href="#plugin_iiigame_iiimetacwatercannonh">meta.CWaterCannon.h</a></li>
<li><a href="#plugin_iiigame_iiimetacweaponh">meta.CWeapon.h</a></li></ul></li></ul></li>
<li>plugin_sa<ul>
<li>game_sa<ul>
<li><a href="#plugin_sagame_sac_pcsavecpp">C_PcSave.cpp</a></li>
<li><a href="#plugin_sagame_sac3dmarkercpp">C3dMarker.cpp</a></li>
<li><a href="#plugin_sagame_sac3dmarkerscpp">C3dMarkers.cpp</a></li>
<li><a href="#plugin_sagame_sacaeaudiohardwarecpp">CAEAudioHardware.cpp</a></li>
<li><a href="#plugin_sagame_sacaecutscenetrackmanagercpp">CAECutsceneTrackManager.cpp</a></li>
<li><a href="#plugin_sagame_sacaeradiotrackmanagercpp">CAERadioTrackManager.cpp</a></li>
<li><a href="#plugin_sagame_sacaestreamthreadcpp">CAEStreamThread.cpp</a></li>
<li><a href="#plugin_sagame_sacaeweaponaudioentitycpp">CAEWeaponAudioEntity.cpp</a></li>
<li><a href="#plugin_sagame_sacanimatedbuildingcpp">CAnimatedBuilding.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendassocgroupcpp">CAnimBlendAssocGroup.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendassociationcpp">CAnimBlendAssociation.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendclumpdatacpp">CAnimBlendClumpData.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendhierarchycpp">CAnimBlendHierarchy.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendnodecpp">CAnimBlendNode.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendsequencecpp">CAnimBlendSequence.cpp</a></li>
<li><a href="#plugin_sagame_sacanimblendstaticassociationcpp">CAnimBlendStaticAssociation.cpp</a></li>
<li><a href="#plugin_sagame_sacanimmanagercpp">CAnimManager.cpp</a></li>
<li><a href="#plugin_sagame_sacaudioenginecpp">CAudioEngine.cpp</a></li>
<li><a href="#plugin_sagame_sacbasemodelinfocpp">CBaseModelInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacbirdscpp">CBirds.cpp</a></li>
<li><a href="#plugin_sagame_sacbouncingpanelcpp">CBouncingPanel.cpp</a></li>
<li><a href="#plugin_sagame_sacboundingboxcpp">CBoundingBox.cpp</a></li>
<li><a href="#plugin_sagame_sacbrightlightscpp">CBrightLights.cpp</a></li>
<li><a href="#plugin_sagame_sacbuildingcpp">CBuilding.cpp</a></li>
<li><a href="#plugin_sagame_sacbulletinfocpp">CBulletInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacbullettracecpp">CBulletTrace.cpp</a></li>
<li><a href="#plugin_sagame_sacbullettracescpp">CBulletTraces.cpp</a></li>
<li><a href="#plugin_sagame_saccameracpp">CCamera.cpp</a></li>
<li><a href="#plugin_sagame_saccaraicpp">CCarAI.cpp</a></li>
<li><a href="#plugin_sagame_saccarctrlcpp">CCarCtrl.cpp</a></li>
<li><a href="#plugin_sagame_saccarenterexitcpp">CCarEnterExit.cpp</a></li>
<li><a href="#plugin_sagame_saccargeneratorcpp">CCarGenerator.cpp</a></li>
<li><a href="#plugin_sagame_saccarpathlinkcpp">CCarPathLink.cpp</a></li>
<li><a href="#plugin_sagame_saccheatcpp">CCheat.cpp</a></li>
<li><a href="#plugin_sagame_saccheckpointcpp">CCheckpoint.cpp</a></li>
<li><a href="#plugin_sagame_saccheckpointscpp">CCheckpoints.cpp</a></li>
<li><a href="#plugin_sagame_sacclockcpp">CClock.cpp</a></li>
<li><a href="#plugin_sagame_sacclothescpp">CClothes.cpp</a></li>
<li><a href="#plugin_sagame_sacclothesbuildercpp">CClothesBuilder.cpp</a></li>
<li><a href="#plugin_sagame_saccloudscpp">CClouds.cpp</a></li>
<li><a href="#plugin_sagame_sacclumpmodelinfocpp">CClumpModelInfo.cpp</a></li>
<li><a href="#plugin_sagame_saccolaccelcpp">CColAccel.cpp</a></li>
<li><a href="#plugin_sagame_saccoldiskcpp">CColDisk.cpp</a></li>
<li><a href="#plugin_sagame_saccollisioncpp">CCollision.cpp</a></li>
<li><a href="#plugin_sagame_saccollisiondatacpp">CCollisionData.cpp</a></li>
<li><a href="#plugin_sagame_saccolmodelcpp">CColModel.cpp</a></li>
<li><a href="#plugin_sagame_saccoloursetcpp">CColourSet.cpp</a></li>
<li><a href="#plugin_sagame_saccontrollerconfigmanagercpp">CControllerConfigManager.cpp</a></li>
<li><a href="#plugin_sagame_saccovercpp">CCover.cpp</a></li>
<li><a href="#plugin_sagame_saccoverpointcpp">CCoverPoint.cpp</a></li>
<li><a href="#plugin_sagame_saccreditscpp">CCredits.cpp</a></li>
<li><a href="#plugin_sagame_saccullzonescpp">CCullZones.cpp</a></li>
<li><a href="#plugin_sagame_saccustomcarenvmappipelinecpp">CCustomCarEnvMapPipeline.cpp</a></li>
<li><a href="#plugin_sagame_saccustomcarplatemgrcpp">CCustomCarPlateMgr.cpp</a></li>
<li><a href="#plugin_sagame_saccutscenemgrcpp">CCutsceneMgr.cpp</a></li>
<li><a href="#plugin_sagame_sacdarkelcpp">CDarkel.cpp</a></li>
<li><a href="#plugin_sagame_sacdatecpp">CDate.cpp</a></li>
<li><a href="#plugin_sagame_sacdecisionsimplecpp">CDecisionSimple.cpp</a></li>
<li><a href="#plugin_sagame_sacdirectorycpp">CDirectory.cpp</a></li>
<li><a href="#plugin_sagame_sacdoorcpp">CDoor.cpp</a></li>
<li><a href="#plugin_sagame_sacdrawcpp">CDraw.cpp</a></li>
<li><a href="#plugin_sagame_sacentryexitcpp">CEntryExit.cpp</a></li>
<li><a href="#plugin_sagame_sacentryexitmanagercpp">CEntryExitManager.cpp</a></li>
<li><a href="#plugin_sagame_sacexplosioncpp">CExplosion.cpp</a></li>
<li><a href="#plugin_sagame_sacfileloadercpp">CFileLoader.cpp</a></li>
<li><a href="#plugin_sagame_sacformationcpp">CFormation.cpp</a></li>
<li><a href="#plugin_sagame_sacgamecpp">CGame.cpp</a></li>
<li><a href="#plugin_sagame_sacgamelogiccpp">CGameLogic.cpp</a></li>
<li><a href="#plugin_sagame_sacgangscpp">CGangs.cpp</a></li>
<li><a href="#plugin_sagame_sacgangwarscpp">CGangWars.cpp</a></li>
<li><a href="#plugin_sagame_sacgangwarssavestructurecpp">CGangWarsSaveStructure.cpp</a></li>
<li><a href="#plugin_sagame_sacgenericgamestoragecpp">CGenericGameStorage.cpp</a></li>
<li><a href="#plugin_sagame_sacgridrefcpp">CGridRef.cpp</a></li>
<li><a href="#plugin_sagame_sachudcpp">CHud.cpp</a></li>
<li><a href="#plugin_sagame_saciplstorecpp">CIplStore.cpp</a></li>
<li><a href="#plugin_sagame_sacloadedcargroupcpp">CLoadedCarGroup.cpp</a></li>
<li><a href="#plugin_sagame_sacloadingscreencpp">CLoadingScreen.cpp</a></li>
<li><a href="#plugin_sagame_sacmatrixcpp">CMatrix.cpp</a></li>
<li><a href="#plugin_sagame_sacmatrixlinkcpp">CMatrixLink.cpp</a></li>
<li><a href="#plugin_sagame_sacmenumanagercpp">CMenuManager.cpp</a></li>
<li><a href="#plugin_sagame_sacmirrorscpp">CMirrors.cpp</a></li>
<li><a href="#plugin_sagame_sacmodelinfocpp">CModelInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacmodelinfoacceleratorcpp">CModelInfoAccelerator.cpp</a></li>
<li><a href="#plugin_sagame_sacmotionblurstreakscpp">CMotionBlurStreaks.cpp</a></li>
<li><a href="#plugin_sagame_sacocttreecpp">COctTree.cpp</a></li>
<li><a href="#plugin_sagame_sacocttreebasecpp">COctTreeBase.cpp</a></li>
<li><a href="#plugin_sagame_sacommoncpp">common.cpp</a></li>
<li><a href="#plugin_sagame_saconscreencounterentrycpp">COnscreenCounterEntry.cpp</a></li>
<li><a href="#plugin_sagame_saconscreentimercpp">COnscreenTimer.cpp</a></li>
<li><a href="#plugin_sagame_saconscreentimerentrycpp">COnscreenTimerEntry.cpp</a></li>
<li><a href="#plugin_sagame_sacpadcpp">CPad.cpp</a></li>
<li><a href="#plugin_sagame_sacpathnodecpp">CPathNode.cpp</a></li>
<li><a href="#plugin_sagame_sacpedclothesdesccpp">CPedClothesDesc.cpp</a></li>
<li><a href="#plugin_sagame_sacpedgroupcpp">CPedGroup.cpp</a></li>
<li><a href="#plugin_sagame_sacpedgroupintelligencecpp">CPedGroupIntelligence.cpp</a></li>
<li><a href="#plugin_sagame_sacpedgroupmembershipcpp">CPedGroupMembership.cpp</a></li>
<li><a href="#plugin_sagame_sacpedgroupplacercpp">CPedGroupPlacer.cpp</a></li>
<li><a href="#plugin_sagame_sacpedgroupscpp">CPedGroups.cpp</a></li>
<li><a href="#plugin_sagame_sacpedikcpp">CPedIK.cpp</a></li>
<li><a href="#plugin_sagame_sacpedintelligencecpp">CPedIntelligence.cpp</a></li>
<li><a href="#plugin_sagame_sacpedlistcpp">CPedList.cpp</a></li>
<li><a href="#plugin_sagame_sacpedplacementcpp">CPedPlacement.cpp</a></li>
<li><a href="#plugin_sagame_sacpedtaskpaircpp">CPedTaskPair.cpp</a></li>
<li><a href="#plugin_sagame_sacpickupcpp">CPickup.cpp</a></li>
<li><a href="#plugin_sagame_sacpickupscpp">CPickups.cpp</a></li>
<li><a href="#plugin_sagame_sacplayerinfocpp">CPlayerInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacplayerpedcpp">CPlayerPed.cpp</a></li>
<li><a href="#plugin_sagame_sacpointlightscpp">CPointLights.cpp</a></li>
<li><a href="#plugin_sagame_sacpointlistcpp">CPointList.cpp</a></li>
<li><a href="#plugin_sagame_sacpoolscpp">CPools.cpp</a></li>
<li><a href="#plugin_sagame_sacpopcyclecpp">CPopCycle.cpp</a></li>
<li><a href="#plugin_sagame_sacprojectileinfocpp">CProjectileInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacptrlistcpp">CPtrList.cpp</a></li>
<li><a href="#plugin_sagame_sacptrlistdoublelinkcpp">CPtrListDoubleLink.cpp</a></li>
<li><a href="#plugin_sagame_sacptrlistsinglelinkcpp">CPtrListSingleLink.cpp</a></li>
<li><a href="#plugin_sagame_sacptrnodedoublelinkcpp">CPtrNodeDoubleLink.cpp</a></li>
<li><a href="#plugin_sagame_sacptrnodesinglelinkcpp">CPtrNodeSingleLink.cpp</a></li>
<li><a href="#plugin_sagame_sacquadtreenodecpp">CQuadTreeNode.cpp</a></li>
<li><a href="#plugin_sagame_sacregisteredmotionblurstreakcpp">CRegisteredMotionBlurStreak.cpp</a></li>
<li><a href="#plugin_sagame_sacrenderercpp">CRenderer.cpp</a></li>
<li><a href="#plugin_sagame_sacroadblockscpp">CRoadBlocks.cpp</a></li>
<li><a href="#plugin_sagame_sacrunningscriptcpp">CRunningScript.cpp</a></li>
<li><a href="#plugin_sagame_sacscriptresourcemanagercpp">CScriptResourceManager.cpp</a></li>
<li><a href="#plugin_sagame_sacscriptsforbrainscpp">CScriptsForBrains.cpp</a></li>
<li><a href="#plugin_sagame_sacsetpiececpp">CSetPiece.cpp</a></li>
<li><a href="#plugin_sagame_sacsetpiecescpp">CSetPieces.cpp</a></li>
<li><a href="#plugin_sagame_sacshinytextscpp">CShinyTexts.cpp</a></li>
<li><a href="#plugin_sagame_sacshotinfocpp">CShotInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacspecialfxcpp">CSpecialFX.cpp</a></li>
<li><a href="#plugin_sagame_sacspecialplatehandlercpp">CSpecialPlateHandler.cpp</a></li>
<li><a href="#plugin_sagame_sacstatscpp">CStats.cpp</a></li>
<li><a href="#plugin_sagame_sacstreamedscriptscpp">CStreamedScripts.cpp</a></li>
<li><a href="#plugin_sagame_sacstreamingcpp">CStreaming.cpp</a></li>
<li><a href="#plugin_sagame_sacstreaminginfocpp">CStreamingInfo.cpp</a></li>
<li><a href="#plugin_sagame_sacstuckcarcheckcpp">CStuckCarCheck.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexcpp">CTaskComplex.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexclimbcpp">CTaskComplexClimb.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexdiecpp">CTaskComplexDie.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexenterboatasdrivercpp">CTaskComplexEnterBoatAsDriver.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexentercarcpp">CTaskComplexEnterCar.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexentercarasdrivercpp">CTaskComplexEnterCarAsDriver.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexentercaraspassengercpp">CTaskComplexEnterCarAsPassenger.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexfacialcpp">CTaskComplexFacial.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexjumpcpp">CTaskComplexJump.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexleavecarcpp">CTaskComplexLeaveCar.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexprostitutesolicitcpp">CTaskComplexProstituteSolicit.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexsequencecpp">CTaskComplexSequence.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexstuckinaircpp">CTaskComplexStuckInAir.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexsunbathecpp">CTaskComplexSunbathe.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexusemobilephonecpp">CTaskComplexUseMobilePhone.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexwandercpp">CTaskComplexWander.cpp</a></li>
<li><a href="#plugin_sagame_sactaskcomplexwanderstandardcpp">CTaskComplexWanderStandard.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleanimcpp">CTaskSimpleAnim.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplecarsetpedinaspassengercpp">CTaskSimpleCarSetPedInAsPassenger.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplecarsetpedoutcpp">CTaskSimpleCarSetPedOut.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplechokingcpp">CTaskSimpleChoking.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleclimbcpp">CTaskSimpleClimb.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleduckcpp">CTaskSimpleDuck.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleducktogglecpp">CTaskSimpleDuckToggle.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplefacialcpp">CTaskSimpleFacial.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplefightcpp">CTaskSimpleFight.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplegangdrivebycpp">CTaskSimpleGangDriveBy.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleikchaincpp">CTaskSimpleIKChain.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleiklookatcpp">CTaskSimpleIKLookAt.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleikmanagercpp">CTaskSimpleIKManager.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleinaircpp">CTaskSimpleInAir.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplejetpackcpp">CTaskSimpleJetPack.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplejumpcpp">CTaskSimpleJump.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleplayeronfootcpp">CTaskSimplePlayerOnFoot.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplerunanimcpp">CTaskSimpleRunAnim.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplerunnamedanimcpp">CTaskSimpleRunNamedAnim.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplestandstillcpp">CTaskSimpleStandStill.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplestealthkillcpp">CTaskSimpleStealthKill.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleswimcpp">CTaskSimpleSwim.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimplethrowprojectilecpp">CTaskSimpleThrowProjectile.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpletriggerlookatcpp">CTaskSimpleTriggerLookAt.cpp</a></li>
<li><a href="#plugin_sagame_sactasksimpleuseguncpp">CTaskSimpleUseGun.cpp</a></li>
<li><a href="#plugin_sagame_sactaskutilitylineuppedwithcarcpp">CTaskUtilityLineUpPedWithCar.cpp</a></li>
<li><a href="#plugin_sagame_sacthecargeneratorscpp">CTheCarGenerators.cpp</a></li>
<li><a href="#plugin_sagame_sacthescriptscpp">CTheScripts.cpp</a></li>
<li><a href="#plugin_sagame_sactimecyclecpp">CTimeCycle.cpp</a></li>
<li><a href="#plugin_sagame_sacupsidedowncarcheckcpp">CUpsideDownCarCheck.cpp</a></li>
<li><a href="#plugin_sagame_sacvisibilitypluginscpp">CVisibilityPlugins.cpp</a></li>
<li><a href="#plugin_sagame_sacwantedcpp">CWanted.cpp</a></li>
<li><a href="#plugin_sagame_sacweaponcpp">CWeapon.cpp</a></li>
<li><a href="#plugin_sagame_sacweaponeffectscpp">CWeaponEffects.cpp</a></li>
<li><a href="#plugin_sagame_sacweathercpp">CWeather.cpp</a></li>
<li><a href="#plugin_sagame_sacworldcpp">CWorld.cpp</a></li>
<li><a href="#plugin_sagame_sad3dindexdatabuffercpp">D3DIndexDataBuffer.cpp</a></li>
<li><a href="#plugin_sagame_sad3dresourcesystemcpp">D3DResourceSystem.cpp</a></li>
<li><a href="#plugin_sagame_sad3dtexturebuffercpp">D3DTextureBuffer.cpp</a></li>
<li><a href="#plugin_sagame_sajpegcompresscpp">JPegCompress.cpp</a></li>
<li><a href="#plugin_sagame_salist_ccpp">List_c.cpp</a></li>
<li><a href="#plugin_sagame_salistitem_ccpp">ListItem_c.cpp</a></li>
<li><a href="#plugin_sagame_sapipelineplugincpp">PipelinePlugin.cpp</a></li>
<li><a href="#plugin_sagame_sarenderwarecpp">RenderWare.cpp</a></li>
<li><a href="#plugin_sagame_sametacanimblendassociationh">meta.CAnimBlendAssociation.h</a></li>
<li><a href="#plugin_sagame_sametacanimblendstaticassociationh">meta.CAnimBlendStaticAssociation.h</a></li>
<li><a href="#plugin_sagame_sametaccamerah">meta.CCamera.h</a></li>
<li><a href="#plugin_sagame_sametacentryexith">meta.CEntryExit.h</a></li>
<li><a href="#plugin_sagame_sametacganginfoh">meta.CGangInfo.h</a></li>
<li><a href="#plugin_sagame_sametacmatrixlinkh">meta.CMatrixLink.h</a></li>
<li><a href="#plugin_sagame_sametacpedgrouph">meta.CPedGroup.h</a></li>
<li><a href="#plugin_sagame_sametacpedgroupintelligenceh">meta.CPedGroupIntelligence.h</a></li>
<li><a href="#plugin_sagame_sametacpedgroupmembershiph">meta.CPedGroupMembership.h</a></li></ul></li></ul></li>
<li>plugin_vc<ul>
<li>game_vc<ul>
<li><a href="#plugin_vcgame_vcc_pcsavecpp">C_PcSave.cpp</a></li>
<li><a href="#plugin_vcgame_vcc3dmarkercpp">C3dMarker.cpp</a></li>
<li><a href="#plugin_vcgame_vcc3dmarkerscpp">C3dMarkers.cpp</a></li>
<li><a href="#plugin_vcgame_vccanimblendassociationcpp">CAnimBlendAssociation.cpp</a></li>
<li><a href="#plugin_vcgame_vccanimmanagercpp">CAnimManager.cpp</a></li>
<li><a href="#plugin_vcgame_vccaudiomanagercpp">cAudioManager.cpp</a></li>
<li><a href="#plugin_vcgame_vccaudioscriptobjectcpp">cAudioScriptObject.cpp</a></li>
<li><a href="#plugin_vcgame_vccautomobilecpp">CAutomobile.cpp</a></li>
<li><a href="#plugin_vcgame_vccbasemodelinfocpp">CBaseModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccbikecpp">CBike.cpp</a></li>
<li><a href="#plugin_vcgame_vccboatcpp">CBoat.cpp</a></li>
<li><a href="#plugin_vcgame_vccboxcpp">CBox.cpp</a></li>
<li><a href="#plugin_vcgame_vccbrightlightscpp">CBrightLights.cpp</a></li>
<li><a href="#plugin_vcgame_vccbulletinfocpp">CBulletInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccbullettracescpp">CBulletTraces.cpp</a></li>
<li><a href="#plugin_vcgame_vccbuoyancycpp">cBuoyancy.cpp</a></li>
<li><a href="#plugin_vcgame_vcccameracpp">CCamera.cpp</a></li>
<li><a href="#plugin_vcgame_vcccaraicpp">CCarAI.cpp</a></li>
<li><a href="#plugin_vcgame_vcccarctrlcpp">CCarCtrl.cpp</a></li>
<li><a href="#plugin_vcgame_vcccargeneratorcpp">CCarGenerator.cpp</a></li>
<li><a href="#plugin_vcgame_vcccivilianpedcpp">CCivilianPed.cpp</a></li>
<li><a href="#plugin_vcgame_vccclockcpp">CClock.cpp</a></li>
<li><a href="#plugin_vcgame_vcccloudscpp">CClouds.cpp</a></li>
<li><a href="#plugin_vcgame_vccclumpmodelinfocpp">CClumpModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vcccolboxcpp">CColBox.cpp</a></li>
<li><a href="#plugin_vcgame_vcccollinecpp">CColLine.cpp</a></li>
<li><a href="#plugin_vcgame_vcccolmodelcpp">CColModel.cpp</a></li>
<li><a href="#plugin_vcgame_vcccolspherecpp">CColSphere.cpp</a></li>
<li><a href="#plugin_vcgame_vcccontrollerstatecpp">CControllerState.cpp</a></li>
<li><a href="#plugin_vcgame_vcccoppedcpp">CCopPed.cpp</a></li>
<li><a href="#plugin_vcgame_vcccoronascpp">CCoronas.cpp</a></li>
<li><a href="#plugin_vcgame_vcccranescpp">CCranes.cpp</a></li>
<li><a href="#plugin_vcgame_vcccutsceneobjectcpp">CCutsceneObject.cpp</a></li>
<li><a href="#plugin_vcgame_vcccutsceneshadowcpp">CCutsceneShadow.cpp</a></li>
<li><a href="#plugin_vcgame_vccdamagemanagercpp">CDamageManager.cpp</a></li>
<li><a href="#plugin_vcgame_vccdarkelcpp">CDarkel.cpp</a></li>
<li><a href="#plugin_vcgame_vccdirectorycpp">CDirectory.cpp</a></li>
<li><a href="#plugin_vcgame_vccdmaudiocpp">cDMAudio.cpp</a></li>
<li><a href="#plugin_vcgame_vccdrawcpp">CDraw.cpp</a></li>
<li><a href="#plugin_vcgame_vccemergencypedcpp">CEmergencyPed.cpp</a></li>
<li><a href="#plugin_vcgame_vccescalatorscpp">CEscalators.cpp</a></li>
<li><a href="#plugin_vcgame_vccfileloadercpp">CFileLoader.cpp</a></li>
<li><a href="#plugin_vcgame_vccfilemgrcpp">CFileMgr.cpp</a></li>
<li><a href="#plugin_vcgame_vccfontcpp">CFont.cpp</a></li>
<li><a href="#plugin_vcgame_vccgamecpp">CGame.cpp</a></li>
<li><a href="#plugin_vcgame_vccgamelogiccpp">CGameLogic.cpp</a></li>
<li><a href="#plugin_vcgame_vccgangscpp">CGangs.cpp</a></li>
<li><a href="#plugin_vcgame_vccgeneralcpp">CGeneral.cpp</a></li>
<li><a href="#plugin_vcgame_vcchandlingdatamgrcpp">cHandlingDataMgr.cpp</a></li>
<li><a href="#plugin_vcgame_vcchelicpp">CHeli.cpp</a></li>
<li><a href="#plugin_vcgame_vcchudcpp">CHud.cpp</a></li>
<li><a href="#plugin_vcgame_vcckeyboardstatecpp">CKeyboardState.cpp</a></li>
<li><a href="#plugin_vcgame_vccmenumanagercpp">CMenuManager.cpp</a></li>
<li><a href="#plugin_vcgame_vccmessagescpp">CMessages.cpp</a></li>
<li><a href="#plugin_vcgame_vccmodelinfocpp">CModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccmotionblurstreakscpp">CMotionBlurStreaks.cpp</a></li>
<li><a href="#plugin_vcgame_vccmousepointerstatehelpercpp">CMousePointerStateHelper.cpp</a></li>
<li><a href="#plugin_vcgame_vccmoviecpp">CMovie.cpp</a></li>
<li><a href="#plugin_vcgame_vccobjectcpp">CObject.cpp</a></li>
<li><a href="#plugin_vcgame_vccocclusioncpp">COcclusion.cpp</a></li>
<li><a href="#plugin_vcgame_vccommoncpp">common.cpp</a></li>
<li><a href="#plugin_vcgame_vcconscreentimercpp">COnscreenTimer.cpp</a></li>
<li><a href="#plugin_vcgame_vccpadcpp">CPad.cpp</a></li>
<li><a href="#plugin_vcgame_vccparticlecpp">CParticle.cpp</a></li>
<li><a href="#plugin_vcgame_vccparticlesystemmgrcpp">cParticleSystemMgr.cpp</a></li>
<li><a href="#plugin_vcgame_vccpathfindcpp">CPathFind.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedcpp">CPed.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedatmattractorcpp">CPedAtmAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedattractorcpp">CPedAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedattractormanagercpp">CPedAttractorManager.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedicecreamvanattractorcpp">CPedIceCreamVanAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedikcpp">CPedIK.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedmodelinfocpp">CPedModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedpizzaattractorcpp">CPedPizzaAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedplacementcpp">CPedPlacement.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedseatattractorcpp">CPedSeatAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedshelterattractorcpp">CPedShelterAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedstatscpp">CPedStats.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedstopattractorcpp">CPedStopAttractor.cpp</a></li>
<li><a href="#plugin_vcgame_vccpedtypecpp">CPedType.cpp</a></li>
<li><a href="#plugin_vcgame_vccphoneinfocpp">CPhoneInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccpickupscpp">CPickups.cpp</a></li>
<li><a href="#plugin_vcgame_vccplanecpp">CPlane.cpp</a></li>
<li><a href="#plugin_vcgame_vccplayerpedcpp">CPlayerPed.cpp</a></li>
<li><a href="#plugin_vcgame_vccplayerskincpp">CPlayerSkin.cpp</a></li>
<li><a href="#plugin_vcgame_vccpointlightscpp">CPointLights.cpp</a></li>
<li><a href="#plugin_vcgame_vccpoolscpp">CPools.cpp</a></li>
<li><a href="#plugin_vcgame_vccpopulationcpp">CPopulation.cpp</a></li>
<li><a href="#plugin_vcgame_vccprojectilecpp">CProjectile.cpp</a></li>
<li><a href="#plugin_vcgame_vccprojectileinfocpp">CProjectileInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccquaternioncpp">CQuaternion.cpp</a></li>
<li><a href="#plugin_vcgame_vccradarcpp">CRadar.cpp</a></li>
<li><a href="#plugin_vcgame_vccregisteredmotionblurstreakcpp">CRegisteredMotionBlurStreak.cpp</a></li>
<li><a href="#plugin_vcgame_vccrestartcpp">CRestart.cpp</a></li>
<li><a href="#plugin_vcgame_vccroutenodecpp">CRouteNode.cpp</a></li>
<li><a href="#plugin_vcgame_vccrubbishcpp">CRubbish.cpp</a></li>
<li><a href="#plugin_vcgame_vccrunningscriptcpp">CRunningScript.cpp</a></li>
<li><a href="#plugin_vcgame_vccsamplemanagercpp">cSampleManager.cpp</a></li>
<li><a href="#plugin_vcgame_vccsceneeditcpp">CSceneEdit.cpp</a></li>
<li><a href="#plugin_vcgame_vccshadowcameracpp">CShadowCamera.cpp</a></li>
<li><a href="#plugin_vcgame_vccshinytextscpp">CShinyTexts.cpp</a></li>
<li><a href="#plugin_vcgame_vccshotinfocpp">CShotInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccsimplemodelinfocpp">CSimpleModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccspritecpp">CSprite.cpp</a></li>
<li><a href="#plugin_vcgame_vccstingercpp">CStinger.cpp</a></li>
<li><a href="#plugin_vcgame_vccstreamingcpp">CStreaming.cpp</a></li>
<li><a href="#plugin_vcgame_vcctextcpp">CText.cpp</a></li>
<li><a href="#plugin_vcgame_vccthescriptscpp">CTheScripts.cpp</a></li>
<li><a href="#plugin_vcgame_vccthezonescpp">CTheZones.cpp</a></li>
<li><a href="#plugin_vcgame_vcctimecyclecpp">CTimeCycle.cpp</a></li>
<li><a href="#plugin_vcgame_vcctimemodelinfocpp">CTimeModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vcctimercpp">CTimer.cpp</a></li>
<li><a href="#plugin_vcgame_vcctrafficlightscpp">CTrafficLights.cpp</a></li>
<li><a href="#plugin_vcgame_vcctraincpp">CTrain.cpp</a></li>
<li><a href="#plugin_vcgame_vcctransmissioncpp">cTransmission.cpp</a></li>
<li><a href="#plugin_vcgame_vcctxdstorecpp">CTxdStore.cpp</a></li>
<li><a href="#plugin_vcgame_vccuserdisplaycpp">CUserDisplay.cpp</a></li>
<li><a href="#plugin_vcgame_vccvehiclecpp">CVehicle.cpp</a></li>
<li><a href="#plugin_vcgame_vccvehiclemodelinfocpp">CVehicleModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccvisibilitypluginscpp">CVisibilityPlugins.cpp</a></li>
<li><a href="#plugin_vcgame_vccwantedcpp">CWanted.cpp</a></li>
<li><a href="#plugin_vcgame_vccwatercannonscpp">CWaterCannons.cpp</a></li>
<li><a href="#plugin_vcgame_vccweaponeffectscpp">CWeaponEffects.cpp</a></li>
<li><a href="#plugin_vcgame_vccweaponinfocpp">CWeaponInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccweaponmodelinfocpp">CWeaponModelInfo.cpp</a></li>
<li><a href="#plugin_vcgame_vccweathercpp">CWeather.cpp</a></li>
<li><a href="#plugin_vcgame_vccwindmodifierscpp">CWindModifiers.cpp</a></li>
<li><a href="#plugin_vcgame_vccworldcpp">CWorld.cpp</a></li>
<li><a href="#plugin_vcgame_vcczonecpp">CZone.cpp</a></li>
<li><a href="#plugin_vcgame_vcnodenamecpp">NodeName.cpp</a></li>
<li><a href="#plugin_vcgame_vcmetacaudioscriptobjecth">meta.cAudioScriptObject.h</a></li>
<li><a href="#plugin_vcgame_vcmetacbullettraceh">meta.CBulletTrace.h</a></li>
<li><a href="#plugin_vcgame_vcmetaccutsceneshadowh">meta.CCutsceneShadow.h</a></li>
<li><a href="#plugin_vcgame_vcmetacdirectoryh">meta.CDirectory.h</a></li>
<li><a href="#plugin_vcgame_vcmetacpadh">meta.CPad.h</a></li>
<li><a href="#plugin_vcgame_vcmetacparticleh">meta.CParticle.h</a></li>
<li><a href="#plugin_vcgame_vcmetacpedattractorh">meta.CPedAttractor.h</a></li>
<li><a href="#plugin_vcgame_vcmetacphoneh">meta.CPhone.h</a></li>
<li><a href="#plugin_vcgame_vcmetacphoneinfoh">meta.CPhoneInfo.h</a></li>
<li><a href="#plugin_vcgame_vcmetacpointlighth">meta.CPointLight.h</a></li>
<li><a href="#plugin_vcgame_vcmetacroutenodeh">meta.CRouteNode.h</a></li>
<li><a href="#plugin_vcgame_vcmetacwindmodifiersh">meta.CWindModifiers.h</a></li></ul></li></ul></li>
</ul><h3 id="plugin_iiigame_iiic_pcsavecpp">plugin_III\game_III\C_PcSave.cpp</h3><h4>C_PcSave::DeleteSlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::DeleteSlot), this, slot);</p>
<p>0AA8: call_method_return 0x5922F0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]</p>
<h4>C_PcSave::PcClassSaveRoutine</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int, unsigned char *, unsigned int>(gaddrof(C_PcSave::PcClassSaveRoutine), this, file, data, size);</p>
<p>0AA8: call_method_return 0x591F80 struct [C_PcSave] num_params 3 pop 0 [file] [data] [size] func_ret [bool]</p>
<h4>C_PcSave::PopulateSlotInfo</h4>
<p>plugin::CallMethodDynGlobal<C_PcSave *>(gaddrof(C_PcSave::PopulateSlotInfo), this);</p>
<p>0AA6: call_method 0x592090 struct [C_PcSave] num_params 0 pop 0</p>
<p>define function C_PcSave__PopulateSlotInfo&lt;thiscall, 0x592090&gt;()</p>
<h4>C_PcSave::SaveSlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::SaveSlot), this, slot);</p>
<p>0AA8: call_method_return 0x591EC0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]</p>
<h4>C_PcSave::SetSaveDirectory</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(C_PcSave::SetSaveDirectory), path);</p><h3 id="plugin_iiigame_iiic2deffectcpp">plugin_III\game_III\C2dEffect.cpp</h3><h4>C2dEffect::Shutdown</h4>
<p>plugin::CallMethodDynGlobal<C2dEffect *>(gaddrof(C2dEffect::Shutdown), this);</p>
<p>0AA6: call_method 0x50B820 struct [C2dEffect] num_params 0 pop 0</p>
<p>define function C2dEffect__Shutdown&lt;thiscall, 0x50B820&gt;()</p><h3 id="plugin_iiigame_iiic3dmarkercpp">plugin_III\game_III\C3dMarker.cpp</h3><h4>C3dMarker::AddMarker</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarker::AddMarker), this, nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);</p>
<p>0AA6: call_method 0x51B070 struct [C3dMarker] num_params 10 pop 0 [nId] [nType] [fSize] [bRed] [bGreen] [bBlue] [bAlpha] [nPulsePeriod] [fPulseFraction] [nRotateRate]</p>
<p>define function C3dMarker__AddMarker&lt;thiscall, 0x51B070&gt;(nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate)</p>
<h4>C3dMarker::DeleteMarkerObject</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::DeleteMarkerObject), this);</p>
<p>0AA6: call_method 0x51B170 struct [C3dMarker] num_params 0 pop 0</p>
<p>define function C3dMarker__DeleteMarkerObject&lt;thiscall, 0x51B170&gt;()</p>
<h4>C3dMarker::Render</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::Render), this);</p>
<p>0AA6: call_method 0x51B1B0 struct [C3dMarker] num_params 0 pop 0</p>
<p>define function C3dMarker__Render&lt;thiscall, 0x51B1B0&gt;()</p>
<h4>*MarkerAtomicCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(MarkerAtomicCB), atomic, data);</p>
<p>0AA7: call_function_return 0x51B060 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function MarkerAtomicCB&lt;cdecl, 0x51B060&gt;(atomic, data): int</p><h3 id="plugin_iiigame_iiic3dmarkerscpp">plugin_III\game_III\C3dMarkers.cpp</h3><h4>C3dMarkers::PlaceMarker</h4>
<p>plugin::CallDynGlobal<unsigned int, unsigned short, CVector &, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarkers::PlaceMarker), nId, nType, point, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);</p>
<h4>C3dMarkers::PlaceMarkerSet</h4>
<p>plugin::CallDynGlobal<unsigned int, unsigned short, CVector &, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(gaddrof(C3dMarkers::PlaceMarkerSet), nId, nType, point, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);</p><h3 id="plugin_iiigame_iiicaccidentmanagercpp">plugin_III\game_III\CAccidentManager.cpp</h3><h4>CAccidentManager::CountActiveAccidents</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned short, CAccidentManager *>(gaddrof(CAccidentManager::CountActiveAccidents), this);</p>
<p>0AA8: call_method_return 0x456880 struct [CAccidentManager] num_params 0 pop 0 func_ret [unsigned short]</p>
<h4>*CAccidentManager::FindNearestAccident</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAccident *, CAccidentManager *, CVector, float *>(gaddrof(CAccidentManager::FindNearestAccident), this, pos, distance);</p>
<p>0AA8: call_method_return 0x456760 struct [*CAccidentManager] num_params 2 pop 0 [pos] [distance] func_ret [CAccident *]</p>
<h4>*CAccidentManager::GetNextFreeAccident</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAccident *, CAccidentManager *>(gaddrof(CAccidentManager::GetNextFreeAccident), this);</p>
<p>0AA8: call_method_return 0x4565A0 struct [*CAccidentManager] num_params 0 pop 0 func_ret [CAccident *]</p>
<h4>CAccidentManager::ReportAccident</h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *, CPed *>(gaddrof(CAccidentManager::ReportAccident), this, ped);</p>
<p>0AA6: call_method 0x4565D0 struct [CAccidentManager] num_params 1 pop 0 [ped]</p>
<p>define function CAccidentManager__ReportAccident&lt;thiscall, 0x4565D0&gt;(ped)</p>
<h4>CAccidentManager::UnattendedAccidents</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAccidentManager *>(gaddrof(CAccidentManager::UnattendedAccidents), this);</p>
<p>0AA8: call_method_return 0x4568D0 struct [CAccidentManager] num_params 0 pop 0 func_ret [bool]</p>
<h4>CAccidentManager::Update</h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *>(gaddrof(CAccidentManager::Update), this);</p>
<p>0AA6: call_method 0x456710 struct [CAccidentManager] num_params 0 pop 0</p>
<p>define function CAccidentManager__Update&lt;thiscall, 0x456710&gt;()</p>
<h4>CAccidentManager::WorkToDoForMedics</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAccidentManager *>(gaddrof(CAccidentManager::WorkToDoForMedics), this);</p>
<p>0AA8: call_method_return 0x4568A0 struct [CAccidentManager] num_params 0 pop 0 func_ret [bool]</p><h3 id="plugin_iiigame_iiicanimblendassocgroupcpp">plugin_III\game_III\CAnimBlendAssocGroup.cpp</h3><h4>*CAnimBlendAssocGroup::CopyAnimation</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::CopyAnimation, CAnimBlendAssociation <em>(CAnimBlendAssocGroup::</em>)(char const *)), this, name);</p>
<p>0AA8: call_method_return 0x401420 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [name] func_ret [CAnimBlendAssociation *]</p>
<h4>*CAnimBlendAssocGroup::CopyAnimation</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, unsigned int>(gaddrof_o(CAnimBlendAssocGroup::CopyAnimation, CAnimBlendAssociation <em>(CAnimBlendAssocGroup::</em>)(unsigned int)), this, id);</p>
<p>0AA8: call_method_return 0x401420 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [id] func_ret [CAnimBlendAssociation *]</p>
<h4>CAnimBlendAssocGroup::CreateAssociations</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::CreateAssociations, void (CAnimBlendAssocGroup::*)(char const *)), this, name);</p>
<p>0AA6: call_method 0x401220 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [name]</p>
<p>define function CAnimBlendAssocGroup__CreateAssociations&lt;thiscall, 0x401220&gt;(name)</p>
<h4>CAnimBlendAssocGroup::CreateAssociations</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *, char const *, RpClump *, char **, int>(gaddrof_o(CAnimBlendAssocGroup::CreateAssociations, void (CAnimBlendAssocGroup::*)(char const *, RpClump *, char **, int)), this, blockName, clump, animNames, numAssocs);</p>
<p>0AA6: call_method 0x401220 struct [CAnimBlendAssocGroup] num_params 4 pop 0 [blockName] [clump] [animNames] [numAssocs]</p>
<p>define function CAnimBlendAssocGroup__CreateAssociations&lt;thiscall, 0x401220&gt;(blockName, clump, animNames, numAssocs)</p>
<h4>CAnimBlendAssocGroup::DestroyAssociations</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(gaddrof(CAnimBlendAssocGroup::DestroyAssociations), this);</p>
<p>0AA6: call_method 0x4012D0 struct [CAnimBlendAssocGroup] num_params 0 pop 0</p>
<p>define function CAnimBlendAssocGroup__DestroyAssociations&lt;thiscall, 0x4012D0&gt;()</p>
<h4>*CAnimBlendAssocGroup::GetAnimation</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, char const *>(gaddrof_o(CAnimBlendAssocGroup::GetAnimation, CAnimBlendAssociation <em>(CAnimBlendAssocGroup::</em>)(char const *)), this, name);</p>
<p>0AA8: call_method_return 0x4013D0 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [name] func_ret [CAnimBlendAssociation *]</p>
<h4>*CAnimBlendAssocGroup::GetAnimation</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssocGroup *, unsigned int>(gaddrof_o(CAnimBlendAssocGroup::GetAnimation, CAnimBlendAssociation <em>(CAnimBlendAssocGroup::</em>)(unsigned int)), this, id);</p>
<p>0AA8: call_method_return 0x4013D0 struct [*CAnimBlendAssocGroup] num_params 1 pop 0 [id] func_ret [CAnimBlendAssociation *]</p>
<h4>strcmpIgnoringDigits</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *, char const *>(gaddrof(strcmpIgnoringDigits), s1, s2);</p>
<p>0AA7: call_function_return 0x401020 num_params 2 pop 2 [s1] [s2] func_ret [bool]</p>
<p>define function strcmpIgnoringDigits&lt;cdecl, 0x401020&gt;(s1, s2): int</p>
<h4>*GetModelFromName</h4>
<p>plugin::CallAndReturnDynGlobal<CBaseModelInfo *, char const *>(gaddrof(GetModelFromName), name);</p>
<p>0AA7: call_function_return 0x4010D0 num_params 1 pop 1 [name] func_ret [CBaseModelInfo *]</p>
<p>define function GetModelFromName&lt;cdecl, 0x4010D0&gt;(name): int</p><h3 id="plugin_iiigame_iiicanimblendassociationcpp">plugin_III\game_III\CAnimBlendAssociation.cpp</h3><h4>CAnimBlendAssociation::AllocateAnimBlendNodeArray</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::AllocateAnimBlendNodeArray), this, n);</p>
<p>0AA6: call_method 0x4016A0 struct [CAnimBlendAssociation] num_params 1 pop 0 [n]</p>
<p>define function CAnimBlendAssociation__AllocateAnimBlendNodeArray&lt;thiscall, 0x4016A0&gt;(n)</p>
<h4>CAnimBlendAssociation::FreeAnimBlendNodeArray</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::FreeAnimBlendNodeArray), this);</p>
<p>0AA6: call_method 0x4016F0 struct [CAnimBlendAssociation] num_params 0 pop 0</p>
<p>define function CAnimBlendAssociation__FreeAnimBlendNodeArray&lt;thiscall, 0x4016F0&gt;()</p>
<h4>*CAnimBlendAssociation::GetNode</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAnimBlendNode *, CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::GetNode), this, index);</p>
<p>0AA8: call_method_return 0x4017B0 struct [*CAnimBlendAssociation] num_params 1 pop 0 [index] func_ret [CAnimBlendNode *]</p>
<h4>CAnimBlendAssociation::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(RpClump *, CAnimBlendHierarchy *)), this, clump, hier);</p>
<p>0AA6: call_method 0x401620 struct [CAnimBlendAssociation] num_params 2 pop 0 [clump] [hier]</p>
<p>define function CAnimBlendAssociation__Init&lt;thiscall, 0x401620&gt;(clump, hier)</p>
<h4>CAnimBlendAssociation::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendAssociation &amp;)), this, assoc);</p>
<p>0AA6: call_method 0x401620 struct [CAnimBlendAssociation] num_params 1 pop 0 [assoc]</p>
<p>define function CAnimBlendAssociation__Init&lt;thiscall, 0x401620&gt;(assoc)</p>
<h4>CAnimBlendAssociation::SetBlend</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlend), this, amount, delta);</p>
<p>0AA6: call_method 0x4017E0 struct [CAnimBlendAssociation] num_params 2 pop 0 [amount] [delta]</p>
<p>define function CAnimBlendAssociation__SetBlend&lt;thiscall, 0x4017E0&gt;(amount, delta)</p>
<h4>CAnimBlendAssociation::SetCurrentTime</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::SetCurrentTime), this, time);</p>
<p>0AA6: call_method 0x401700 struct [CAnimBlendAssociation] num_params 1 pop 0 [time]</p>
<p>define function CAnimBlendAssociation__SetCurrentTime&lt;thiscall, 0x401700&gt;(time)</p>
<h4>CAnimBlendAssociation::SetDeleteCallback</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetDeleteCallback), this, func, data);</p>
<p>0AA6: call_method 0x401800 struct [CAnimBlendAssociation] num_params 2 pop 0 [func] [data]</p>
<p>define function CAnimBlendAssociation__SetDeleteCallback&lt;thiscall, 0x401800&gt;(func, data)</p>
<h4>CAnimBlendAssociation::SetFinishCallback</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetFinishCallback), this, func, data);</p>
<p>0AA6: call_method 0x401820 struct [CAnimBlendAssociation] num_params 2 pop 0 [func] [data]</p>
<p>define function CAnimBlendAssociation__SetFinishCallback&lt;thiscall, 0x401820&gt;(func, data)</p>
<h4>CAnimBlendAssociation::Start</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::Start), this, time);</p>
<p>0AA6: call_method 0x4017D0 struct [CAnimBlendAssociation] num_params 1 pop 0 [time]</p>
<p>define function CAnimBlendAssociation__Start&lt;thiscall, 0x4017D0&gt;(time)</p>
<h4>CAnimBlendAssociation::SyncAnimation</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::SyncAnimation), this, other);</p>
<p>0AA6: call_method 0x401780 struct [CAnimBlendAssociation] num_params 1 pop 0 [other]</p>
<p>define function CAnimBlendAssociation__SyncAnimation&lt;thiscall, 0x401780&gt;(other)</p>
<h4>CAnimBlendAssociation::UpdateBlend</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::UpdateBlend), this, timeDelta);</p>
<p>0AA8: call_method_return 0x4032B0 struct [CAnimBlendAssociation] num_params 1 pop 0 [timeDelta] func_ret [bool]</p>
<h4>CAnimBlendAssociation::UpdateTime</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTime), this, timeDelta, relSpeed);</p>
<p>0AA6: call_method 0x4031F0 struct [CAnimBlendAssociation] num_params 2 pop 0 [timeDelta] [relSpeed]</p>
<p>define function CAnimBlendAssociation__UpdateTime&lt;thiscall, 0x4031F0&gt;(timeDelta, relSpeed)</p><h3 id="plugin_iiigame_iiicanimblendclumpdatacpp">plugin_III\game_III\CAnimBlendClumpData.cpp</h3><h4>CAnimBlendClumpData::ForAllFrames</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *>(gaddrof(CAnimBlendClumpData::ForAllFrames), this, func, data);</p>
<p>0AA6: call_method 0x401930 struct [CAnimBlendClumpData] num_params 2 pop 0 [func] [data]</p>
<p>define function CAnimBlendClumpData__ForAllFrames&lt;thiscall, 0x401930&gt;(func, data)</p>
<h4>CAnimBlendClumpData::SetNumberOfBones</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *, int>(gaddrof(CAnimBlendClumpData::SetNumberOfBones), this, n);</p>
<p>0AA6: call_method 0x4018F0 struct [CAnimBlendClumpData] num_params 1 pop 0 [n]</p>
<p>define function CAnimBlendClumpData__SetNumberOfBones&lt;thiscall, 0x4018F0&gt;(n)</p><h3 id="plugin_iiigame_iiicanimblendhierarchycpp">plugin_III\game_III\CAnimBlendHierarchy.cpp</h3><h4>CAnimBlendHierarchy::CalcTotalTime</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::CalcTotalTime), this);</p>
<p>0AA6: call_method 0x4019E0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__CalcTotalTime&lt;thiscall, 0x4019E0&gt;()</p>
<h4>CAnimBlendHierarchy::RemoveAnimSequences</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveAnimSequences), this);</p>
<p>0AA6: call_method 0x401AB0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__RemoveAnimSequences&lt;thiscall, 0x401AB0&gt;()</p>
<h4>CAnimBlendHierarchy::RemoveQuaternionFlips</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveQuaternionFlips), this);</p>
<p>0AA6: call_method 0x401A80 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__RemoveQuaternionFlips&lt;thiscall, 0x401A80&gt;()</p>
<h4>CAnimBlendHierarchy::RemoveUncompressedData</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::RemoveUncompressedData), this);</p>
<p>0AA6: call_method 0x401B00 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__RemoveUncompressedData&lt;thiscall, 0x401B00&gt;()</p>
<h4>CAnimBlendHierarchy::SetName</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *, char const *>(gaddrof(CAnimBlendHierarchy::SetName), this, name);</p>
<p>0AA6: call_method 0x4019C0 struct [CAnimBlendHierarchy] num_params 1 pop 0 [name]</p>
<p>define function CAnimBlendHierarchy__SetName&lt;thiscall, 0x4019C0&gt;(name)</p>
<h4>CAnimBlendHierarchy::Shutdown</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::Shutdown), this);</p>
<p>0AA6: call_method 0x4019A0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__Shutdown&lt;thiscall, 0x4019A0&gt;()</p>
<h4>CAnimBlendHierarchy::Uncompress</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimBlendHierarchy::Uncompress), this);</p>
<p>0AA6: call_method 0x401AD0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__Uncompress&lt;thiscall, 0x401AD0&gt;()</p><h3 id="plugin_iiigame_iiicanimblendnodecpp">plugin_III\game_III\CAnimBlendNode.cpp</h3><h4>CAnimBlendNode::CalcDeltas</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendNode *>(gaddrof(CAnimBlendNode::CalcDeltas), this);</p>
<p>0AA6: call_method 0x401E70 struct [CAnimBlendNode] num_params 0 pop 0</p>
<p>define function CAnimBlendNode__CalcDeltas&lt;thiscall, 0x401E70&gt;()</p>
<h4>CAnimBlendNode::FindKeyFrame</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *, float>(gaddrof(CAnimBlendNode::FindKeyFrame), this, t);</p>
<p>0AA8: call_method_return 0x4021B0 struct [CAnimBlendNode] num_params 1 pop 0 [t] func_ret [bool]</p>
<h4>CAnimBlendNode::GetCurrentTranslation</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendNode *, CVector &, float>(gaddrof(CAnimBlendNode::GetCurrentTranslation), this, trans, weight);</p>
<p>0AA6: call_method 0x401FE0 struct [CAnimBlendNode] num_params 2 pop 0 [trans] [weight]</p>
<p>define function CAnimBlendNode__GetCurrentTranslation&lt;thiscall, 0x401FE0&gt;(trans, weight)</p>
<h4>CAnimBlendNode::GetEndTranslation</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendNode *, CVector &, float>(gaddrof(CAnimBlendNode::GetEndTranslation), this, trans, weight);</p>
<p>0AA6: call_method 0x402110 struct [CAnimBlendNode] num_params 2 pop 0 [trans] [weight]</p>
<p>define function CAnimBlendNode__GetEndTranslation&lt;thiscall, 0x402110&gt;(trans, weight)</p>
<h4>CAnimBlendNode::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendNode *>(gaddrof(CAnimBlendNode::Init), this);</p>
<p>0AA6: call_method 0x401B10 struct [CAnimBlendNode] num_params 0 pop 0</p>
<p>define function CAnimBlendNode__Init&lt;thiscall, 0x401B10&gt;()</p>
<h4>CAnimBlendNode::NextKeyFrame</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *>(gaddrof(CAnimBlendNode::NextKeyFrame), this);</p>
<p>0AA8: call_method_return 0x401DC0 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]</p>
<h4>CAnimBlendNode::Update</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendNode *, CVector &, CQuaternion &, float>(gaddrof(CAnimBlendNode::Update), this, trans, rot, weight);</p>
<p>0AA8: call_method_return 0x401B30 struct [CAnimBlendNode] num_params 3 pop 0 [trans] [rot] [weight] func_ret [bool]</p><h3 id="plugin_iiigame_iiicanimblendsequencecpp">plugin_III\game_III\CAnimBlendSequence.cpp</h3><h4>CAnimBlendSequence::RemoveQuaternionFlips</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *>(gaddrof(CAnimBlendSequence::RemoveQuaternionFlips), this);</p>
<p>0AA6: call_method 0x4023A0 struct [CAnimBlendSequence] num_params 0 pop 0</p>
<p>define function CAnimBlendSequence__RemoveQuaternionFlips&lt;thiscall, 0x4023A0&gt;()</p>
<h4>CAnimBlendSequence::SetName</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *, char const *>(gaddrof(CAnimBlendSequence::SetName), this, name);</p>
<p>0AA6: call_method 0x402330 struct [CAnimBlendSequence] num_params 1 pop 0 [name]</p>
<p>define function CAnimBlendSequence__SetName&lt;thiscall, 0x402330&gt;(name)</p>
<h4>CAnimBlendSequence::SetNumFrames</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *, int, bool>(gaddrof(CAnimBlendSequence::SetNumFrames), this, numFrames, translation);</p>
<p>0AA6: call_method 0x402350 struct [CAnimBlendSequence] num_params 2 pop 0 [numFrames] [translation]</p>
<p>define function CAnimBlendSequence__SetNumFrames&lt;thiscall, 0x402350&gt;(numFrames, translation)</p><h3 id="plugin_iiigame_iiicanimmanagercpp">plugin_III\game_III\CAnimManager.cpp</h3><h4>*CAnimManager::AddAnimation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int, int>(gaddrof(CAnimManager::AddAnimation), clump, groupId, animId);</p>
<p>0AA7: call_function_return 0x403620 num_params 3 pop 3 [clump] [groupId] [animId] func_ret [CAnimBlendAssociation *]</p>
<p>define function CAnimManager__AddAnimation&lt;cdecl, 0x403620&gt;(clump, groupId, animId): int</p>
<h4>*CAnimManager::AddAnimationAndSync</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendAssociation *, int, int>(gaddrof(CAnimManager::AddAnimationAndSync), clump, association, groupId, animId);</p>
<p>0AA7: call_function_return 0x4036A0 num_params 4 pop 4 [clump] [association] [groupId] [animId] func_ret [CAnimBlendAssociation *]</p>
<p>define function CAnimManager__AddAnimationAndSync&lt;cdecl, 0x4036A0&gt;(clump, association, groupId, animId): int</p>
<h4>*CAnimManager::BlendAnimation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int, int, float>(gaddrof(CAnimManager::BlendAnimation), clump, groupId, animId, delta);</p>
<p>0AA7: call_function_return 0x403710 num_params 4 pop 4 [clump] [groupId] [animId] [delta] func_ret [CAnimBlendAssociation *]</p>
<p>define function CAnimManager__BlendAnimation&lt;cdecl, 0x403710&gt;(clump, groupId, animId, delta): int</p>
<h4>*CAnimManager::CreateAnimAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, int>(gaddrof(CAnimManager::CreateAnimAssociation), groupId, animId);</p>
<p>0AA7: call_function_return 0x4035C0 num_params 2 pop 2 [groupId] [animId] func_ret [CAnimBlendAssociation *]</p>
<p>define function CAnimManager__CreateAnimAssociation&lt;cdecl, 0x4035C0&gt;(groupId, animId): int</p>
<h4>*CAnimManager::GetAnimAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, int>(gaddrof_o(CAnimManager::GetAnimAssociation, CAnimBlendAssociation <em>(</em>)(int, int)), groupId, animId);</p>
<p>0AA7: call_function_return 0x403600 num_params 2 pop 2 [groupId] [animId] func_ret [CAnimBlendAssociation *]</p>
<p>define function CAnimManager__GetAnimAssociation&lt;cdecl, 0x403600&gt;(groupId, animId): int</p>
<h4>*CAnimManager::GetAnimAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, int, char const *>(gaddrof_o(CAnimManager::GetAnimAssociation, CAnimBlendAssociation <em>(</em>)(int, char const *)), groupId, name);</p>
<p>0AA7: call_function_return 0x403600 num_params 2 pop 2 [groupId] [name] func_ret [CAnimBlendAssociation *]</p>
<p>define function CAnimManager__GetAnimAssociation&lt;cdecl, 0x403600&gt;(groupId, name): int</p>
<h4>*CAnimManager::GetAnimGroupName</h4>
<p>plugin::CallAndReturnDynGlobal<char const *, int>(gaddrof(CAnimManager::GetAnimGroupName), groupId);</p>
<p>0AA7: call_function_return 0x4035B0 num_params 1 pop 1 [groupId] func_ret [char const *]</p>
<p>define function CAnimManager__GetAnimGroupName&lt;cdecl, 0x4035B0&gt;(groupId): int</p>
<h4>*CAnimManager::GetAnimation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendHierarchy *, char const *, CAnimBlock *>(gaddrof(CAnimManager::GetAnimation), name, animBlock);</p>
<p>0AA7: call_function_return 0x4034F0 num_params 2 pop 2 [name] [animBlock] func_ret [CAnimBlendHierarchy *]</p>
<p>define function CAnimManager__GetAnimation&lt;cdecl, 0x4034F0&gt;(name, animBlock): int</p>
<h4>*CAnimManager::GetAnimationBlock</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlock *, char const *>(gaddrof(CAnimManager::GetAnimationBlock), name);</p>
<p>0AA7: call_function_return 0x4034A0 num_params 1 pop 1 [name] func_ret [CAnimBlock *]</p>
<p>define function CAnimManager__GetAnimationBlock&lt;cdecl, 0x4034A0&gt;(name): int</p>
<h4>CAnimManager::LoadAnimFile</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof_o(CAnimManager::LoadAnimFile, void (*)(char const *)), name);</p>
<h4>CAnimManager::LoadAnimFile</h4>
<p>plugin::CallDynGlobal<int, bool>(gaddrof_o(CAnimManager::LoadAnimFile, void (*)(int, bool)), fileHandle, compress);</p>
<h4>CAnimManager::UncompressAnimation</h4>
<p>plugin::CallDynGlobal<CAnimBlendHierarchy *>(gaddrof(CAnimManager::UncompressAnimation), hier);</p><h3 id="plugin_iiigame_iiicantennacpp">plugin_III\game_III\CAntenna.cpp</h3><h4>CAntenna::Update</h4>
<p>plugin::CallMethodDynGlobal<CAntenna *, CVector, CVector>(gaddrof(CAntenna::Update), this, dir, pos);</p>
<p>0AA6: call_method 0x4F6830 struct [CAntenna] num_params 2 pop 0 [dir] [pos]</p>
<p>define function CAntenna__Update&lt;thiscall, 0x4F6830&gt;(dir, pos)</p><h3 id="plugin_iiigame_iiicantennascpp">plugin_III\game_III\CAntennas.cpp</h3><h4>CAntennas::RegisterOne</h4>
<p>plugin::CallDynGlobal<unsigned int, CVector, CVector, float>(gaddrof(CAntennas::RegisterOne), id, dir, pos, length);</p><h3 id="plugin_iiigame_iiicaudiocollisionmanagercpp">plugin_III\game_III\cAudioCollisionManager.cpp</h3><h4>cAudioCollisionManager::AddCollisionToRequestedQueue</h4>
<p>plugin::CallMethodDynGlobal<cAudioCollisionManager *>(gaddrof(cAudioCollisionManager::AddCollisionToRequestedQueue), this);</p>
<p>0AA6: call_method 0x5685E0 struct [cAudioCollisionManager] num_params 0 pop 0</p>
<p>define function cAudioCollisionManager__AddCollisionToRequestedQueue&lt;thiscall, 0x5685E0&gt;()</p><h3 id="plugin_iiigame_iiicaudiohydrantcpp">plugin_III\game_III\CAudioHydrant.cpp</h3><h4>CAudioHydrant::Add</h4>
<p>plugin::CallDynGlobal<CParticleObject *>(gaddrof(CAudioHydrant::Add), object);</p>
<h4>CAudioHydrant::Remove</h4>
<p>plugin::CallDynGlobal<CParticleObject *>(gaddrof(CAudioHydrant::Remove), object);</p><h3 id="plugin_iiigame_iiicaudiomanagercpp">plugin_III\game_III\cAudioManager.cpp</h3><h4>cAudioManager::cAudioManager</h4>
<p>plugin::CallMethod<0x579AB0, cAudioManager *>(this);</p>
<p>0AA6: call_method 0x579AB0 struct [cAudioManager] num_params 0 pop 0</p>
<p>define function cAudioManager__cAudioManager&lt;thiscall, 0x579AB0&gt;()</p>
<h4>cAudioManager::~cAudioManager</h4>
<p>plugin::CallMethod<0x57A0A0, cAudioManager *>(this);</p>
<p>0AA6: call_method 0x57A0A0 struct [cAudioManager] num_params 0 pop 0</p>
<p>define function cAudioManager__~cAudioManager&lt;thiscall, 0x57A0A0&gt;()</p>
<h4>cAudioManager::UsesSiren</h4>
<p>plugin::CallMethodAndReturn<bool, 0x56C3C0, cAudioManager *, unsigned int>(this, index);</p>
<p>0AA8: call_method_return 0x56C3C0 struct [cAudioManager] num_params 1 pop 0 [index] func_ret [bool]</p>
<p>define function cAudioManager__UsesSiren&lt;thiscall, 0x56C3C0&gt;(index): int</p>
<h4>cAudioManager::UsesSirenSwitching</h4>
<p>plugin::CallMethodAndReturn<bool, 0x56C3F0, cAudioManager *, unsigned int>(this, index);</p>
<p>0AA8: call_method_return 0x56C3F0 struct [cAudioManager] num_params 1 pop 0 [index] func_ret [bool]</p>
<p>define function cAudioManager__UsesSirenSwitching&lt;thiscall, 0x56C3F0&gt;(index): int</p><h3 id="plugin_iiigame_iiicaudioscriptobjectcpp">plugin_III\game_III\cAudioScriptObject.cpp</h3><h4>cAudioScriptObject::Reset</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(gaddrof(cAudioScriptObject::Reset), this);</p>
<p>0AA6: call_method 0x57C430 struct [cAudioScriptObject] num_params 0 pop 0</p>
<p>define function cAudioScriptObject__Reset&lt;thiscall, 0x57C430&gt;()</p>
<h4>cAudioScriptObject::LoadAllAudioScriptObjects</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(cAudioScriptObject::LoadAllAudioScriptObjects), buf, size);</p>
<h4>cAudioScriptObject::SaveAllAudioScriptObjects</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(cAudioScriptObject::SaveAllAudioScriptObjects), buf, size);</p>
<h4>PlayOneShotScriptObject</h4>
<p>plugin::CallDynGlobal<unsigned char, CVector const &>(gaddrof(PlayOneShotScriptObject), id, pos);</p><h3 id="plugin_iiigame_iiicautomobilecpp">plugin_III\game_III\CAutomobile.cpp</h3><h4>CAutomobile::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CAutomobile *, unsigned int>(this, modelIndex);</p>
<h4>CAutomobile::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CAutomobile *>(this);</p>
<h4>CAutomobile::Teleport</h4>
<p>plugin::CallVirtualMethod<11, CAutomobile *, CVector>(this, pos);</p>
<h4>CAutomobile::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CAutomobile *>(this);</p>
<h4>CAutomobile::Render</h4>
<p>plugin::CallVirtualMethod<13, CAutomobile *>(this);</p>
<h4>CAutomobile::ProcessEntityCollision</h4>
<p>plugin::CallVirtualMethod<17, CAutomobile *, CEntity *, CColPoint *>(this, entity, colPoint);</p>
<h4>CAutomobile::ProcessControlInputs</h4>
<p>plugin::CallVirtualMethod<18, CAutomobile *, unsigned char>(this, pad);</p>
<h4>CAutomobile::GetComponentWorldPosition</h4>
<p>plugin::CallVirtualMethod<19, CAutomobile *, int, CVector &>(this, component, pos);</p>
<h4>CAutomobile::IsComponentPresent</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 20, CAutomobile *, int>(this, component);</p>
<h4>CAutomobile::SetComponentRotation</h4>
<p>plugin::CallVirtualMethod<21, CAutomobile *, int, CVector>(this, component, rotation);</p>
<h4>CAutomobile::OpenDoor</h4>
<p>plugin::CallVirtualMethod<22, CAutomobile *, int, eDoors, float>(this, component, door, angle);</p>
<h4>CAutomobile::ProcessOpenDoor</h4>
<p>plugin::CallVirtualMethod<23, CAutomobile *, unsigned int, unsigned int, float>(this, component, anim, angle);</p>
<h4>CAutomobile::IsDoorReady</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 24, CAutomobile *, eDoors>(this, door);</p>
<h4>CAutomobile::IsDoorFullyOpen</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 25, CAutomobile *, eDoors>(this, door);</p>
<h4>CAutomobile::IsDoorClosed</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 26, CAutomobile *, eDoors>(this, door);</p>
<h4>CAutomobile::IsDoorMissing</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 27, CAutomobile *, eDoors>(this, door);</p>
<h4>CAutomobile::RemoveRefsToVehicle</h4>
<p>plugin::CallVirtualMethod<28, CAutomobile *, CEntity *>(this, entity);</p>
<h4>CAutomobile::BlowUpCar</h4>
<p>plugin::CallVirtualMethod<29, CAutomobile *, CEntity *>(this, culprit);</p>
<h4>CAutomobile::SetUpWheelColModel</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 30, CAutomobile *, CColModel *>(this, wheelCol);</p>
<h4>CAutomobile::BurstTyre</h4>
<p>plugin::CallVirtualMethod<31, CAutomobile *, unsigned char>(this, wheel);</p>
<h4>CAutomobile::IsRoomForPedToLeaveCar</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 32, CAutomobile *, unsigned int, CVector *>(this, component, doorOffset);</p>
<h4>CAutomobile::GetHeightAboveRoad</h4>
<p>plugin::CallVirtualMethodAndReturn<float, 33, CAutomobile *>(this);</p>
<h4>CAutomobile::PlayCarHorn</h4>
<p>plugin::CallVirtualMethod<34, CAutomobile *>(this);</p>
<h4>CAutomobile::AddDamagedVehicleParticles</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::AddDamagedVehicleParticles), this);</p>
<p>0AA6: call_method 0x535450 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__AddDamagedVehicleParticles&lt;thiscall, 0x535450&gt;()</p>
<h4>CAutomobile::AddWheelDirtAndWater</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *, CColPoint &, unsigned int>(gaddrof(CAutomobile::AddWheelDirtAndWater), this, point, belowEffectSpeed);</p>
<p>0AA8: call_method_return 0x5357D0 struct [CAutomobile] num_params 2 pop 0 [point] [belowEffectSpeed] func_ret [bool]</p>
<h4>CAutomobile::BlowUpCarsInPath</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::BlowUpCarsInPath), this);</p>
<p>0AA6: call_method 0x53E000 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__BlowUpCarsInPath&lt;thiscall, 0x53E000&gt;()</p>
<h4>CAutomobile::DoDriveByShootings</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::DoDriveByShootings), this);</p>
<p>0AA6: call_method 0x564000 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__DoDriveByShootings&lt;thiscall, 0x564000&gt;()</p>
<h4>CAutomobile::FireTruckControl</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::FireTruckControl), this);</p>
<p>0AA6: call_method 0x522590 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__FireTruckControl&lt;thiscall, 0x522590&gt;()</p>
<h4>CAutomobile::Fix</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::Fix), this);</p>
<p>0AA6: call_method 0x53C240 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__Fix&lt;thiscall, 0x53C240&gt;()</p>
<h4>CAutomobile::GetAllWheelsOffGround</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::GetAllWheelsOffGround), this);</p>
<p>0AA8: call_method_return 0x53BC40 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]</p>
<h4>CAutomobile::HasCarStoppedBecauseOfLight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::HasCarStoppedBecauseOfLight), this);</p>
<p>0AA8: call_method_return 0x42E220 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]</p>
<h4>CAutomobile::HideAllComps</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::HideAllComps), this);</p>
<p>0AA6: call_method 0x5300C0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__HideAllComps&lt;thiscall, 0x5300C0&gt;()</p>
<h4>CAutomobile::HydraulicControl</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::HydraulicControl), this);</p>
<p>0AA6: call_method 0x52D4E0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__HydraulicControl&lt;thiscall, 0x52D4E0&gt;()</p>
<h4>CAutomobile::PlaceOnRoadProperly</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::PlaceOnRoadProperly), this);</p>
<p>0AA6: call_method 0x53E090 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__PlaceOnRoadProperly&lt;thiscall, 0x53E090&gt;()</p>
<h4>CAutomobile::PlayHornIfNecessary</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::PlayHornIfNecessary), this);</p>
<p>0AA6: call_method 0x53C4B0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__PlayHornIfNecessary&lt;thiscall, 0x53C4B0&gt;()</p>
<h4>CAutomobile::ProcessAutoBusDoors</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ProcessAutoBusDoors), this);</p>
<p>0AA6: call_method 0x53D370 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ProcessAutoBusDoors&lt;thiscall, 0x53D370&gt;()</p>
<h4>CAutomobile::ProcessBuoyancy</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ProcessBuoyancy), this);</p>
<p>0AA6: call_method 0x5308D0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ProcessBuoyancy&lt;thiscall, 0x5308D0&gt;()</p>
<h4>CAutomobile::ProcessSwingingDoor</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, int, eDoors>(gaddrof(CAutomobile::ProcessSwingingDoor), this, component, door);</p>
<p>0AA6: call_method 0x535250 struct [CAutomobile] num_params 2 pop 0 [component] [door]</p>
<p>define function CAutomobile__ProcessSwingingDoor&lt;thiscall, 0x535250&gt;(component, door)</p>
<h4>CAutomobile::RcbanditCheck1CarWheels</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *, CPtrList &>(gaddrof(CAutomobile::RcbanditCheck1CarWheels), this, list);</p>
<p>0AA8: call_method_return 0x53CBA0 struct [CAutomobile] num_params 1 pop 0 [list] func_ret [bool]</p>
<h4>CAutomobile::RcbanditCheckHitWheels</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAutomobile *>(gaddrof(CAutomobile::RcbanditCheckHitWheels), this);</p>
<p>0AA8: call_method_return 0x53C990 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]</p>
<h4>CAutomobile::ReduceHornCounter</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ReduceHornCounter), this);</p>
<p>0AA6: call_method 0x5308C0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ReduceHornCounter&lt;thiscall, 0x5308C0&gt;()</p>
<h4>*CAutomobile::RemoveBonnetInPedCollision</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CObject *, CAutomobile *>(gaddrof(CAutomobile::RemoveBonnetInPedCollision), this);</p>
<p>0AA8: call_method_return 0x535320 struct [*CAutomobile] num_params 0 pop 0 func_ret [CObject *]</p>
<h4>CAutomobile::ResetSuspension</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ResetSuspension), this);</p>
<p>0AA6: call_method 0x5353A0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ResetSuspension&lt;thiscall, 0x5353A0&gt;()</p>
<h4>CAutomobile::ScanForCrimes</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ScanForCrimes), this);</p>
<p>0AA6: call_method 0x53C4F0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ScanForCrimes&lt;thiscall, 0x53C4F0&gt;()</p>
<h4>CAutomobile::SetBumperDamage</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, int, ePanels, bool>(gaddrof(CAutomobile::SetBumperDamage), this, component, panel, noFlyingComponents);</p>
<p>0AA6: call_method 0x530120 struct [CAutomobile] num_params 3 pop 0 [component] [panel] [noFlyingComponents]</p>
<p>define function CAutomobile__SetBumperDamage&lt;thiscall, 0x530120&gt;(component, panel, noFlyingComponents)</p>
<h4>CAutomobile::SetBusDoorTimer</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, unsigned int, unsigned char>(gaddrof(CAutomobile::SetBusDoorTimer), this, timer, type);</p>
<p>0AA6: call_method 0x53D320 struct [CAutomobile] num_params 2 pop 0 [timer] [type]</p>
<p>define function CAutomobile__SetBusDoorTimer&lt;thiscall, 0x53D320&gt;(timer, type)</p>
<h4>CAutomobile::SetComponentVisibility</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, RwFrame *, unsigned int>(gaddrof(CAutomobile::SetComponentVisibility), this, frame, flag);</p>
<p>0AA6: call_method 0x5300E0 struct [CAutomobile] num_params 2 pop 0 [frame] [flag]</p>
<p>define function CAutomobile__SetComponentVisibility&lt;thiscall, 0x5300E0&gt;(frame, flag)</p>
<h4>CAutomobile::SetDoorDamage</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, int, eDoors, bool>(gaddrof(CAutomobile::SetDoorDamage), this, component, door, noFlyingComponents);</p>
<p>0AA6: call_method 0x530200 struct [CAutomobile] num_params 3 pop 0 [component] [door] [noFlyingComponents]</p>
<p>define function CAutomobile__SetDoorDamage&lt;thiscall, 0x530200&gt;(component, door, noFlyingComponents)</p>
<h4>CAutomobile::SetPanelDamage</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, int, ePanels, bool>(gaddrof(CAutomobile::SetPanelDamage), this, component, panel, noFlyingComponents);</p>
<p>0AA6: call_method 0x5301A0 struct [CAutomobile] num_params 3 pop 0 [component] [panel] [noFlyingComponents]</p>
<p>define function CAutomobile__SetPanelDamage&lt;thiscall, 0x5301A0&gt;(component, panel, noFlyingComponents)</p>
<h4>CAutomobile::SetTaxiLight</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, bool>(gaddrof(CAutomobile::SetTaxiLight), this, enable);</p>
<p>0AA6: call_method 0x53C420 struct [CAutomobile] num_params 1 pop 0 [enable]</p>
<p>define function CAutomobile__SetTaxiLight&lt;thiscall, 0x53C420&gt;(enable)</p>
<h4>CAutomobile::SetupDamageAfterLoad</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupDamageAfterLoad), this);</p>
<p>0AA6: call_method 0x53C310 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__SetupDamageAfterLoad&lt;thiscall, 0x53C310&gt;()</p>
<h4>CAutomobile::SetupModelNodes</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupModelNodes), this);</p>
<p>0AA6: call_method 0x52D1B0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__SetupModelNodes&lt;thiscall, 0x52D1B0&gt;()</p>
<h4>CAutomobile::SetupSuspensionLines</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::SetupSuspensionLines), this);</p>
<p>0AA6: call_method 0x52D210 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__SetupSuspensionLines&lt;thiscall, 0x52D210&gt;()</p>
<h4>CAutomobile::ShowAllComps</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::ShowAllComps), this);</p>
<p>0AA6: call_method 0x5300D0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ShowAllComps&lt;thiscall, 0x5300D0&gt;()</p>
<h4>*CAutomobile::SpawnFlyingComponent</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CObject *, CAutomobile *, int, unsigned int>(gaddrof(CAutomobile::SpawnFlyingComponent), this, component, type);</p>
<p>0AA8: call_method_return 0x530300 struct [*CAutomobile] num_params 2 pop 0 [component] [type] func_ret [CObject *]</p>
<h4>CAutomobile::TankControl</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *>(gaddrof(CAutomobile::TankControl), this);</p>
<p>0AA6: call_method 0x53D530 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__TankControl&lt;thiscall, 0x53D530&gt;()</p>
<h4>CAutomobile::VehicleDamage</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, float, unsigned short>(gaddrof(CAutomobile::VehicleDamage), this, impulse, damagedPiece);</p>
<p>0AA6: call_method 0x52F390 struct [CAutomobile] num_params 2 pop 0 [impulse] [damagedPiece]</p>
<p>define function CAutomobile__VehicleDamage&lt;thiscall, 0x52F390&gt;(impulse, damagedPiece)</p>
<h4>CAutomobile::dmgDrawCarCollidingParticles</h4>
<p>plugin::CallMethodDynGlobal<CAutomobile *, CVector const &, float>(gaddrof(CAutomobile::dmgDrawCarCollidingParticles), this, pos, amount);</p>
<p>0AA6: call_method 0x52F030 struct [CAutomobile] num_params 2 pop 0 [pos] [amount]</p>
<p>define function CAutomobile__dmgDrawCarCollidingParticles&lt;thiscall, 0x52F030&gt;(pos, amount)</p>
<h4>CAutomobile::SetAllTaxiLights</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CAutomobile::SetAllTaxiLights), enable);</p>
<h4>*SetVehicleAtomicVisibilityCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(SetVehicleAtomicVisibilityCB), object, data);</p>
<p>0AA7: call_function_return 0x52C660 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function SetVehicleAtomicVisibilityCB&lt;cdecl, 0x52C660&gt;(object, data): int</p>
<h4>*GetCurrentAtomicObjectCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetCurrentAtomicObjectCB), object, data);</p>
<p>0AA7: call_function_return 0x52C690 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function GetCurrentAtomicObjectCB&lt;cdecl, 0x52C690&gt;(object, data): int</p><h3 id="plugin_iiigame_iiicautopilotcpp">plugin_III\game_III\CAutoPilot.cpp</h3><h4>CAutoPilot::ModifySpeed</h4>
<p>plugin::CallMethod<0x4137B0, CAutoPilot *, float>(this, speed);</p>
<p>0AA6: call_method 0x4137B0 struct [CAutoPilot] num_params 1 pop 0 [speed]</p>
<p>define function CAutoPilot__ModifySpeed&lt;thiscall, 0x4137B0&gt;(speed)</p>
<h4>CAutoPilot::RemoveOnePathNode</h4>
<p>plugin::CallMethod<0x413A00, CAutoPilot *>(this);</p>
<p>0AA6: call_method 0x413A00 struct [CAutoPilot] num_params 0 pop 0</p>
<p>define function CAutoPilot__RemoveOnePathNode&lt;thiscall, 0x413A00&gt;()</p><h3 id="plugin_iiigame_iiicbasemodelinfocpp">plugin_III\game_III\CBaseModelInfo.cpp</h3><h4>CBaseModelInfo::Shutdown</h4>
<p>plugin::CallVirtualMethod<1, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::Add2dEffect</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *, C2dEffect *>(gaddrof(CBaseModelInfo::Add2dEffect), this, effect);</p>
<p>0AA6: call_method 0x4F6B20 struct [CBaseModelInfo] num_params 1 pop 0 [effect]</p>
<p>define function CBaseModelInfo__Add2dEffect&lt;thiscall, 0x4F6B20&gt;(effect)</p>
<h4>CBaseModelInfo::AddRef</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::AddRef), this);</p>
<p>0AA6: call_method 0x4F6BA0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__AddRef&lt;thiscall, 0x4F6BA0&gt;()</p>
<h4>CBaseModelInfo::AddTexDictionaryRef</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::AddTexDictionaryRef), this);</p>
<p>0AA6: call_method 0x4F6B80 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__AddTexDictionaryRef&lt;thiscall, 0x4F6B80&gt;()</p>
<h4>CBaseModelInfo::ClearTexDictionary</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::ClearTexDictionary), this);</p>
<p>0AA6: call_method 0x4F6B70 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__ClearTexDictionary&lt;thiscall, 0x4F6B70&gt;()</p>
<h4>CBaseModelInfo::DeleteCollisionModel</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::DeleteCollisionModel), this);</p>
<p>0AA6: call_method 0x4F6AC0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__DeleteCollisionModel&lt;thiscall, 0x4F6AC0&gt;()</p>
<h4>*CBaseModelInfo::Get2dEffect</h4>
<p>plugin::CallMethodAndReturnDynGlobal<C2dEffect *, CBaseModelInfo *, int>(gaddrof(CBaseModelInfo::Get2dEffect), this, effectNumber);</p>
<p>0AA8: call_method_return 0x4F6B00 struct [*CBaseModelInfo] num_params 1 pop 0 [effectNumber] func_ret [C2dEffect *]</p>
<h4>CBaseModelInfo::Init2dEffects</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::Init2dEffects), this);</p>
<p>0AA6: call_method 0x4F6AF0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__Init2dEffects&lt;thiscall, 0x4F6AF0&gt;()</p>
<h4>CBaseModelInfo::RemoveRef</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::RemoveRef), this);</p>
<p>0AA6: call_method 0x4F6BB0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__RemoveRef&lt;thiscall, 0x4F6BB0&gt;()</p>
<h4>CBaseModelInfo::RemoveTexDictionaryRef</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(gaddrof(CBaseModelInfo::RemoveTexDictionaryRef), this);</p>
<p>0AA6: call_method 0x4F6B90 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__RemoveTexDictionaryRef&lt;thiscall, 0x4F6B90&gt;()</p>
<h4>CBaseModelInfo::SetTexDictionary</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *, char const *>(gaddrof(CBaseModelInfo::SetTexDictionary), this, txdName);</p>
<p>0AA6: call_method 0x4F6B40 struct [CBaseModelInfo] num_params 1 pop 0 [txdName]</p>
<p>define function CBaseModelInfo__SetTexDictionary&lt;thiscall, 0x4F6B40&gt;(txdName)</p><h3 id="plugin_iiigame_iiicboatcpp">plugin_III\game_III\CBoat.cpp</h3><h4>CBoat::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CBoat *, unsigned int>(this, modelIndex);</p>
<h4>CBoat::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CBoat *>(this);</p>
<h4>CBoat::Teleport</h4>
<p>plugin::CallVirtualMethod<11, CBoat *, CVector>(this, point);</p>
<h4>CBoat::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CBoat *>(this);</p>
<h4>CBoat::Render</h4>
<p>plugin::CallVirtualMethod<13, CBoat *>(this);</p>
<h4>CBoat::ProcessControlInputs</h4>
<p>plugin::CallVirtualMethod<18, CBoat *, unsigned char>(this, padNumber);</p>
<h4>CBoat::GetComponentWorldPosition</h4>
<p>plugin::CallVirtualMethod<19, CBoat *, int, CVector &>(this, component, pos);</p>
<h4>CBoat::IsComponentPresent</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 20, CBoat *, int>(this, component);</p>
<h4>CBoat::BlowUpCar</h4>
<p>plugin::CallVirtualMethod<29, CBoat *, CEntity *>(this, entity);</p>
<h4>CBoat::AddWakePoint</h4>
<p>plugin::CallMethodDynGlobal<CBoat *, CVector>(gaddrof(CBoat::AddWakePoint), this, point);</p>
<p>0AA6: call_method 0x542140 struct [CBoat] num_params 1 pop 0 [point]</p>
<p>define function CBoat__AddWakePoint&lt;thiscall, 0x542140&gt;(point)</p>
<h4>CBoat::ApplyWaterResistance</h4>
<p>plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::ApplyWaterResistance), this);</p>
<p>0AA6: call_method 0x541A30 struct [CBoat] num_params 0 pop 0</p>
<p>define function CBoat__ApplyWaterResistance&lt;thiscall, 0x541A30&gt;()</p>
<h4>CBoat::PruneWakeTrail</h4>
<p>plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::PruneWakeTrail), this);</p>
<p>0AA6: call_method 0x5420D0 struct [CBoat] num_params 0 pop 0</p>
<p>define function CBoat__PruneWakeTrail&lt;thiscall, 0x5420D0&gt;()</p>
<h4>CBoat::SetupModelNodes</h4>
<p>plugin::CallMethodDynGlobal<CBoat *>(gaddrof(CBoat::SetupModelNodes), this);</p>
<p>0AA6: call_method 0x53E7D0 struct [CBoat] num_params 0 pop 0</p>
<p>define function CBoat__SetupModelNodes&lt;thiscall, 0x53E7D0&gt;()</p>
<h4>CBoat::IsSectorAffectedByWake</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector2D, float, CBoat **>(gaddrof(CBoat::IsSectorAffectedByWake), sector, size, apBoats);</p>
<p>0AA7: call_function_return 0x542370 num_params 3 pop 3 [sector] [size] [apBoats] func_ret [bool]</p>
<p>define function CBoat__IsSectorAffectedByWake&lt;cdecl, 0x542370&gt;(sector, size, apBoats): int</p>
<h4>CBoat::IsVertexAffectedByWake</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVector, CBoat *>(gaddrof(CBoat::IsVertexAffectedByWake), vecVertex, boat);</p>
<p>0AA7: call_function_return 0x5424A0 num_params 2 pop 2 [vecVertex] [boat] func_ret [float]</p>
<p>define function CBoat__IsVertexAffectedByWake&lt;cdecl, 0x5424A0&gt;(vecVertex, boat): float</p>
<h4>*GetBoatAtomicObjectCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetBoatAtomicObjectCB), object, data);</p>
<p>0AA7: call_function_return 0x53E3C0 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function GetBoatAtomicObjectCB&lt;cdecl, 0x53E3C0&gt;(object, data): int</p><h3 id="plugin_iiigame_iiicbridgecpp">plugin_III\game_III\CBridge.cpp</h3><h4>CBridge::ShouldLightsBeFlashing</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CBridge::ShouldLightsBeFlashing));</p>
<p>0AA7: call_function_return 0x413D10 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBridge__ShouldLightsBeFlashing&lt;cdecl, 0x413D10&gt;(): int</p>
<h4>CBridge::ThisIsABridgeObjectMovingUp</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CBridge::ThisIsABridgeObjectMovingUp), modelIndex);</p>
<p>0AA7: call_function_return 0x413DE0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CBridge__ThisIsABridgeObjectMovingUp&lt;cdecl, 0x413DE0&gt;(modelIndex): int</p><h3 id="plugin_iiigame_iiicbrightlightscpp">plugin_III\game_III\CBrightLights.cpp</h3><h4>CBrightLights::RegisterOne</h4>
<p>plugin::CallDynGlobal<CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(gaddrof(CBrightLights::RegisterOne), posn, right, up, at, red, green, blue, alpha);</p><h3 id="plugin_iiigame_iiicbuildingcpp">plugin_III\game_III\CBuilding.cpp</h3><h4>CBuilding::GetIsATreadable</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 17, CBuilding *>(this);</p>
<h4>CBuilding::ReplaceWithNewModel</h4>
<p>plugin::CallMethodDynGlobal<CBuilding *, int>(gaddrof(CBuilding::ReplaceWithNewModel), this, modelIndex);</p>
<p>0AA6: call_method 0x405850 struct [CBuilding] num_params 1 pop 0 [modelIndex]</p>
<p>define function CBuilding__ReplaceWithNewModel&lt;thiscall, 0x405850&gt;(modelIndex)</p><h3 id="plugin_iiigame_iiicbulletinfocpp">plugin_III\game_III\CBulletInfo.cpp</h3><h4>CBulletInfo::AddBullet</h4>
<p>plugin::CallDynGlobal<CEntity *, eWeaponType, CVector, CVector>(gaddrof(CBulletInfo::AddBullet), pSource, type, pos, speed);</p>
<h4>CBulletInfo::TestForSniperBullet</h4>
<p>plugin::CallAndReturnDynGlobal<bool, float, float, float, float, float, float>(gaddrof(CBulletInfo::TestForSniperBullet), x1, x2, y1, y2, z1, z2);</p>
<p>0AA7: call_function_return 0x558D40 num_params 6 pop 6 [x1] [x2] [y1] [y2] [z1] [z2] func_ret [bool]</p>
<p>define function CBulletInfo__TestForSniperBullet&lt;cdecl, 0x558D40&gt;(x1, x2, y1, y2, z1, z2): int</p><h3 id="plugin_iiigame_iiicbullettracecpp">plugin_III\game_III\CBulletTrace.cpp</h3><h4>CBulletTrace::Update</h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(gaddrof(CBulletTrace::Update), this);</p>
<p>0AA6: call_method 0x519270 struct [CBulletTrace] num_params 0 pop 0</p>
<p>define function CBulletTrace__Update&lt;thiscall, 0x519270&gt;()</p><h3 id="plugin_iiigame_iiicbullettracescpp">plugin_III\game_III\CBulletTraces.cpp</h3><h4>CBulletTraces::AddTrace</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *>(gaddrof(CBulletTraces::AddTrace), origin, target);</p><h3 id="plugin_iiigame_iiiccameracpp">plugin_III\game_III\CCamera.cpp</h3><h4>CCamera::CalculateDerivedValues</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CalculateDerivedValues), this);</p>
<p>0AA6: call_method 0x46EEA0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__CalculateDerivedValues&lt;thiscall, 0x46EEA0&gt;()</p>
<h4>CCamera::CamControl</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CamControl), this);</p>
<p>0AA6: call_method 0x468250 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__CamControl&lt;thiscall, 0x468250&gt;()</p>
<h4>CCamera::CamShake</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, float, float, float>(gaddrof(CCamera::CamShake), this, strength, x, y, z);</p>
<p>0AA6: call_method 0x46B200 struct [CCamera] num_params 4 pop 0 [strength] [x] [y] [z]</p>
<p>define function CCamera__CamShake&lt;thiscall, 0x46B200&gt;(strength, x, y, z)</p>
<h4>CCamera::ClearPlayerWeaponMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ClearPlayerWeaponMode), this);</p>
<p>0AA6: call_method 0x46B350 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ClearPlayerWeaponMode&lt;thiscall, 0x46B350&gt;()</p>
<h4>CCamera::DontProcessObbeCinemaCamera</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DontProcessObbeCinemaCamera), this);</p>
<p>0AA6: call_method 0x46B380 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__DontProcessObbeCinemaCamera&lt;thiscall, 0x46B380&gt;()</p>
<h4>CCamera::DrawBordersForWideScreen</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DrawBordersForWideScreen), this);</p>
<p>0AA6: call_method 0x46B430 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__DrawBordersForWideScreen&lt;thiscall, 0x46B430&gt;()</p>
<h4>CCamera::Fade</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, short>(gaddrof(CCamera::Fade), this, timeOut, direction);</p>
<p>0AA6: call_method 0x46B3A0 struct [CCamera] num_params 2 pop 0 [timeOut] [direction]</p>
<p>define function CCamera__Fade&lt;thiscall, 0x46B3A0&gt;(timeOut, direction)</p>
<h4>CCamera::Find3rdPersonCamTargetVector</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, CVector, CVector &, CVector &>(gaddrof(CCamera::Find3rdPersonCamTargetVector), this, dist, pos, source, target);</p>
<p>0AA6: call_method 0x46B580 struct [CCamera] num_params 4 pop 0 [dist] [pos] [source] [target]</p>
<p>define function CCamera__Find3rdPersonCamTargetVector&lt;thiscall, 0x46B580&gt;(dist, pos, source, target)</p>
<h4>CCamera::Find3rdPersonQuickAimPitch</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::Find3rdPersonQuickAimPitch), this);</p>
<p>0AA8: call_method_return 0x46B850 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<h4>CCamera::FinishCutscene</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::FinishCutscene), this);</p>
<p>0AA6: call_method 0x46B560 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__FinishCutscene&lt;thiscall, 0x46B560&gt;()</p>
<h4>*CCamera::GetCameraMatrix</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CMatrix *, CCamera *>(gaddrof(CCamera::GetCameraMatrix), this);</p>
<p>0AA8: call_method_return 0x42C8B0 struct [*CCamera] num_params 0 pop 0 func_ret [CMatrix *]</p>
<h4>CCamera::GetCutSceneFinishTime</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::GetCutSceneFinishTime), this);</p>
<p>0AA8: call_method_return 0x46B920 struct [CCamera] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>CCamera::GetFading</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetFading), this);</p>
<p>0AA8: call_method_return 0x46B970 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::GetFadingDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetFadingDirection), this);</p>
<p>0AA8: call_method_return 0x46B980 struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<h4>*CCamera::GetGameCamPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVector *, CCamera *>(gaddrof(CCamera::GetGameCamPosition), this);</p>
<p>0AA8: call_method_return 0x46BA10 struct [*CCamera] num_params 0 pop 0 func_ret [CVector *]</p>
<h4>CCamera::GetLookDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetLookDirection), this);</p>
<p>0AA8: call_method_return 0x46BA50 struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<h4>CCamera::GetLookingForwardFirstPerson</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingForwardFirstPerson), this);</p>
<p>0AA8: call_method_return 0x46BA90 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::GetLookingLRBFirstPerson</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingLRBFirstPerson), this);</p>
<p>0AA8: call_method_return 0x46BA20 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::GetPositionAlongSpline</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetPositionAlongSpline), this);</p>
<p>0AA8: call_method_return 0x46BAC0 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<h4>CCamera::GetScreenFadeStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetScreenFadeStatus), this);</p>
<p>0AA8: call_method_return 0x46B9C0 struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<h4>CCamera::Get_Just_Switched_Status</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Get_Just_Switched_Status), this);</p>
<p>0AA8: call_method_return 0x46B9B0 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::Init</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Init), this);</p>
<p>0AA6: call_method 0x46BAD0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Init&lt;thiscall, 0x46BAD0&gt;()</p>
<h4>CCamera::InitialiseCameraForDebugMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::InitialiseCameraForDebugMode), this);</p>
<p>0AA6: call_method 0x46BEB0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__InitialiseCameraForDebugMode&lt;thiscall, 0x46BEB0&gt;()</p>
<h4>CCamera::IsItTimeForNewcam</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int, int>(gaddrof(CCamera::IsItTimeForNewcam), this, obbeMode, time);</p>
<p>0AA8: call_method_return 0x46BF10 struct [CCamera] num_params 2 pop 0 [obbeMode] [time] func_ret [bool]</p>
<h4>CCamera::IsSphereVisible</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float, CMatrix const *>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &amp;, float, CMatrix const *)), this, center, radius, matrix);</p>
<p>0AA8: call_method_return 0x43D3B0 struct [CCamera] num_params 3 pop 0 [center] [radius] [matrix] func_ret [bool]</p>
<h4>CCamera::IsSphereVisible</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CCamera <em>, CVector const &, float>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::</em>)(CVector const &amp;, float)), this, center, radius);</p>
<p>0AA8: call_method_return 0x43D3B0 struct [CCamera] num_params 2 pop 0 [center] [radius] func_ret [bool]</p>
<h4>CCamera::LoadPathSplines</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::LoadPathSplines), this, file);</p>
<p>0AA6: call_method 0x46D1D0 struct [CCamera] num_params 1 pop 0 [file]</p>
<p>define function CCamera__LoadPathSplines&lt;thiscall, 0x46D1D0&gt;(file)</p>
<h4>CCamera::LoadTrainCamNodes</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, char const *>(gaddrof(CCamera::LoadTrainCamNodes), this, name);</p>
<p>0AA6: call_method 0x46C9E0 struct [CCamera] num_params 1 pop 0 [name]</p>
<p>define function CCamera__LoadTrainCamNodes&lt;thiscall, 0x46C9E0&gt;(name)</p>
<h4>CCamera::Process</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process), this);</p>
<p>0AA6: call_method 0x46D3F0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Process&lt;thiscall, 0x46D3F0&gt;()</p>
<h4>CCamera::ProcessFade</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessFade), this);</p>
<p>0AA6: call_method 0x46F080 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessFade&lt;thiscall, 0x46F080&gt;()</p>
<h4>CCamera::ProcessMusicFade</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessMusicFade), this);</p>
<p>0AA6: call_method 0x46F1E0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessMusicFade&lt;thiscall, 0x46F1E0&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraCar</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraCar), this);</p>
<p>0AA6: call_method 0x46F3E0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraCar&lt;thiscall, 0x46F3E0&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraPed</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPed), this);</p>
<p>0AA6: call_method 0x46F520 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraPed&lt;thiscall, 0x46F520&gt;()</p>
<h4>CCamera::ProcessWideScreenOn</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessWideScreenOn), this);</p>
<p>0AA6: call_method 0x46F8E0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessWideScreenOn&lt;thiscall, 0x46F8E0&gt;()</p>
<h4>CCamera::Process_Train_Camera_Control</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process_Train_Camera_Control), this);</p>
<p>0AA6: call_method 0x46F600 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Process_Train_Camera_Control&lt;thiscall, 0x46F600&gt;()</p>
<h4>CCamera::RenderMotionBlur</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RenderMotionBlur), this);</p>
<p>0AA6: call_method 0x46F940 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RenderMotionBlur&lt;thiscall, 0x46F940&gt;()</p>
<h4>CCamera::Restore</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Restore), this);</p>
<p>0AA6: call_method 0x46F990 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Restore&lt;thiscall, 0x46F990&gt;()</p>
<h4>CCamera::RestoreWithJumpCut</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreWithJumpCut), this);</p>
<p>0AA6: call_method 0x46FAE0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RestoreWithJumpCut&lt;thiscall, 0x46FAE0&gt;()</p>
<h4>CCamera::SetCamCutSceneOffSet</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const &>(gaddrof(CCamera::SetCamCutSceneOffSet), this, pos);</p>
<p>0AA6: call_method 0x46FC30 struct [CCamera] num_params 1 pop 0 [pos]</p>
<p>define function CCamera__SetCamCutSceneOffSet&lt;thiscall, 0x46FC30&gt;(pos)</p>
<h4>CCamera::SetCamPositionForFixedMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const &, CVector const &>(gaddrof(CCamera::SetCamPositionForFixedMode), this, source, offset);</p>
<p>0AA6: call_method 0x46FCC0 struct [CCamera] num_params 2 pop 0 [source] [offset]</p>
<p>define function CCamera__SetCamPositionForFixedMode&lt;thiscall, 0x46FCC0&gt;(source, offset)</p>
<h4>CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString), this);</p>
<p>0AA6: call_method 0x46FC60 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetCameraDirectlyBehindForFollowPed_CamOnAString&lt;thiscall, 0x46FC60&gt;()</p>
<h4>CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString), this);</p>
<p>0AA6: call_method 0x46FC90 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetCameraDirectlyInFrontForFollowPed_CamOnAString&lt;thiscall, 0x46FC90&gt;()</p>
<h4>CCamera::SetFadeColour</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, unsigned char, unsigned char, unsigned char>(gaddrof(CCamera::SetFadeColour), this, red, green, blue);</p>
<p>0AA6: call_method 0x46FD00 struct [CCamera] num_params 3 pop 0 [red] [green] [blue]</p>
<p>define function CCamera__SetFadeColour&lt;thiscall, 0x46FD00&gt;(red, green, blue)</p>
<h4>CCamera::SetMotionBlur</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int, int, int, int, int>(gaddrof(CCamera::SetMotionBlur), this, red, green, blue, value, type);</p>
<p>0AA6: call_method 0x46FD40 struct [CCamera] num_params 5 pop 0 [red] [green] [blue] [value] [type]</p>
<p>define function CCamera__SetMotionBlur&lt;thiscall, 0x46FD40&gt;(red, green, blue, value, type)</p>
<h4>CCamera::SetMotionBlurAlpha</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::SetMotionBlurAlpha), this, alpha);</p>
<p>0AA6: call_method 0x46FD80 struct [CCamera] num_params 1 pop 0 [alpha]</p>
<p>define function CCamera__SetMotionBlurAlpha&lt;thiscall, 0x46FD80&gt;(alpha)</p>
<h4>CCamera::SetNearClipScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipScript), this, clip);</p>
<p>0AA6: call_method 0x46FD90 struct [CCamera] num_params 1 pop 0 [clip]</p>
<p>define function CCamera__SetNearClipScript&lt;thiscall, 0x46FD90&gt;(clip)</p>
<h4>CCamera::SetNewPlayerWeaponMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short, short, short>(gaddrof(CCamera::SetNewPlayerWeaponMode), this, mode, minZoom, maxZoom);</p>
<p>0AA6: call_method 0x46FDB0 struct [CCamera] num_params 3 pop 0 [mode] [minZoom] [maxZoom]</p>
<p>define function CCamera__SetNewPlayerWeaponMode&lt;thiscall, 0x46FDB0&gt;(mode, minZoom, maxZoom)</p>
<h4>CCamera::SetParametersForScriptInterpolation</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, float, unsigned int>(gaddrof(CCamera::SetParametersForScriptInterpolation), this, stopMoving, catchUp, time);</p>
<p>0AA6: call_method 0x46FDE0 struct [CCamera] num_params 3 pop 0 [stopMoving] [catchUp] [time]</p>
<p>define function CCamera__SetParametersForScriptInterpolation&lt;thiscall, 0x46FDE0&gt;(stopMoving, catchUp, time)</p>
<h4>CCamera::SetPercentAlongCutScene</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetPercentAlongCutScene), this, percent);</p>
<p>0AA6: call_method 0x46FE20 struct [CCamera] num_params 1 pop 0 [percent]</p>
<p>define function CCamera__SetPercentAlongCutScene&lt;thiscall, 0x46FE20&gt;(percent)</p>
<h4>CCamera::SetRwCamera</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, RwCamera *>(gaddrof(CCamera::SetRwCamera), this, rwCamera);</p>
<p>0AA6: call_method 0x46FEC0 struct [CCamera] num_params 1 pop 0 [rwCamera]</p>
<p>define function CCamera__SetRwCamera&lt;thiscall, 0x46FEC0&gt;(rwCamera)</p>
<h4>CCamera::SetWideScreenOff</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOff), this);</p>
<p>0AA6: call_method 0x46FF10 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetWideScreenOff&lt;thiscall, 0x46FF10&gt;()</p>
<h4>CCamera::SetWideScreenOn</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOn), this);</p>
<p>0AA6: call_method 0x46FF00 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetWideScreenOn&lt;thiscall, 0x46FF00&gt;()</p>
<h4>CCamera::SetZoomValueCamStringScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueCamStringScript), this, dist);</p>
<p>0AA6: call_method 0x46FF90 struct [CCamera] num_params 1 pop 0 [dist]</p>
<p>define function CCamera__SetZoomValueCamStringScript&lt;thiscall, 0x46FF90&gt;(dist)</p>
<h4>CCamera::SetZoomValueFollowPedScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueFollowPedScript), this, dist);</p>
<p>0AA6: call_method 0x46FF30 struct [CCamera] num_params 1 pop 0 [dist]</p>
<p>define function CCamera__SetZoomValueFollowPedScript&lt;thiscall, 0x46FF30&gt;(dist)</p>
<h4>CCamera::StartTransition</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransition), this, newMode);</p>
<p>0AA6: call_method 0x46FFF0 struct [CCamera] num_params 1 pop 0 [newMode]</p>
<p>define function CCamera__StartTransition&lt;thiscall, 0x46FFF0&gt;(newMode)</p>
<h4>CCamera::StartTransitionWhenNotFinishedInter</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransitionWhenNotFinishedInter), this, mode);</p>
<p>0AA6: call_method 0x470D80 struct [CCamera] num_params 1 pop 0 [mode]</p>
<p>define function CCamera__StartTransitionWhenNotFinishedInter&lt;thiscall, 0x470D80&gt;(mode)</p>
<h4>CCamera::StoreValuesDuringInterPol</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector &, CVector &, CVector &, float *>(gaddrof(CCamera::StoreValuesDuringInterPol), this, source, target, up, fov);</p>
<p>0AA6: call_method 0x470DA0 struct [CCamera] num_params 4 pop 0 [source] [target] [up] [fov]</p>
<p>define function CCamera__StoreValuesDuringInterPol&lt;thiscall, 0x470DA0&gt;(source, target, up, fov)</p>
<h4>CCamera::TakeControl</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CEntity *, short, short, int>(gaddrof(CCamera::TakeControl), this, target, mode, typeOfSwitch, controller);</p>
<p>0AA6: call_method 0x471500 struct [CCamera] num_params 4 pop 0 [target] [mode] [typeOfSwitch] [controller]</p>
<p>define function CCamera__TakeControl&lt;thiscall, 0x471500&gt;(target, mode, typeOfSwitch, controller)</p>
<h4>CCamera::TakeControlNoEntity</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const &, short, int>(gaddrof(CCamera::TakeControlNoEntity), this, pos, typeOfSwitch, controller);</p>
<p>0AA6: call_method 0x4715B0 struct [CCamera] num_params 3 pop 0 [pos] [typeOfSwitch] [controller]</p>
<p>define function CCamera__TakeControlNoEntity&lt;thiscall, 0x4715B0&gt;(pos, typeOfSwitch, controller)</p>
<h4>CCamera::TakeControlWithSpline</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::TakeControlWithSpline), this, typeOfSwitch);</p>
<p>0AA6: call_method 0x471620 struct [CCamera] num_params 1 pop 0 [typeOfSwitch]</p>
<p>define function CCamera__TakeControlWithSpline&lt;thiscall, 0x471620&gt;(typeOfSwitch)</p>
<h4>CCamera::TryToStartNewCamMode</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int>(gaddrof(CCamera::TryToStartNewCamMode), this, obbeMode);</p>
<p>0AA8: call_method_return 0x471650 struct [CCamera] num_params 1 pop 0 [obbeMode] func_ret [bool]</p>
<h4>CCamera::UpdateAimingCoors</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const &>(gaddrof(CCamera::UpdateAimingCoors), this, coors);</p>
<p>0AA6: call_method 0x472F10 struct [CCamera] num_params 1 pop 0 [coors]</p>
<p>define function CCamera__UpdateAimingCoors&lt;thiscall, 0x472F10&gt;(coors)</p>
<h4>CCamera::UpdateSoundDistances</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateSoundDistances), this);</p>
<p>0AA6: call_method 0x470EA0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__UpdateSoundDistances&lt;thiscall, 0x470EA0&gt;()</p>
<h4>CCamera::UpdateTargetEntity</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateTargetEntity), this);</p>
<p>0AA6: call_method 0x4712A0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__UpdateTargetEntity&lt;thiscall, 0x4712A0&gt;()</p>
<h4>CamShakeNoPos</h4>
<p>plugin::CallDynGlobal<CCamera *, float>(gaddrof(CamShakeNoPos), camera, strength);</p><h3 id="plugin_iiigame_iiiccaraicpp">plugin_III\game_III\CCarAI.cpp</h3><h4>CCarAI::AddAmbulanceOccupants</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddAmbulanceOccupants), vehicle);</p>
<h4>CCarAI::AddFiretruckOccupants</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddFiretruckOccupants), vehicle);</p>
<h4>CCarAI::AddPoliceCarOccupants</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddPoliceCarOccupants), vehicle);</p>
<h4>CCarAI::CarHasReasonToStop</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::CarHasReasonToStop), vehicle);</p>
<h4>CCarAI::FindPoliceCarMissionForWantedLevel</h4>
<p>plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceCarMissionForWantedLevel));</p>
<p>0AA7: call_function_return 0x415E30 num_params 0 pop 0 func_ret [eCarMission]</p>
<p>define function CCarAI__FindPoliceCarMissionForWantedLevel&lt;cdecl, 0x415E30&gt;(): int</p>
<h4>CCarAI::FindPoliceCarSpeedForWantedLevel</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CCarAI::FindPoliceCarSpeedForWantedLevel), vehicle);</p>
<p>0AA7: call_function_return 0x415EB0 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CCarAI__FindPoliceCarSpeedForWantedLevel&lt;cdecl, 0x415EB0&gt;(vehicle): int</p>
<h4>CCarAI::FindSwitchDistanceClose</h4>
<p>plugin::CallAndReturnDynGlobal<float>(gaddrof(CCarAI::FindSwitchDistanceClose));</p>
<p>0AA7: call_function_return 0x413E20 num_params 0 pop 0 func_ret [float]</p>
<p>define function CCarAI__FindSwitchDistanceClose&lt;cdecl, 0x413E20&gt;(): float</p>
<h4>CCarAI::FindSwitchDistanceFar</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarAI::FindSwitchDistanceFar), vehicle);</p>
<p>0AA7: call_function_return 0x413E30 num_params 1 pop 1 [vehicle] func_ret [float]</p>
<p>define function CCarAI__FindSwitchDistanceFar&lt;cdecl, 0x413E30&gt;(vehicle): float</p>
<h4>CCarAI::GetCarToGoToCoors</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToGoToCoors), vehicle, coors);</p>
<p>0AA7: call_function_return 0x415B10 num_params 2 pop 2 [vehicle] [coors] func_ret [float]</p>
<p>define function CCarAI__GetCarToGoToCoors&lt;cdecl, 0x415B10&gt;(vehicle, coors): float</p>
<h4>CCarAI::MakeWayForCarWithSiren</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MakeWayForCarWithSiren), vehicle);</p>
<h4>CCarAI::MellowOutChaseSpeed</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeed), vehicle);</p>
<h4>CCarAI::TellCarToBlockOtherCar</h4>
<p>plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToBlockOtherCar), vehicle, blockVehicle);</p>
<h4>CCarAI::TellCarToRamOtherCar</h4>
<p>plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToRamOtherCar), vehicle, ramVehicle);</p>
<h4>CCarAI::TellOccupantsToLeaveCar</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToLeaveCar), vehicle);</p>
<h4>CCarAI::UpdateCarAI</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::UpdateCarAI), vehicle);</p><h3 id="plugin_iiigame_iiiccarctrlcpp">plugin_III\game_III\CCarCtrl.cpp</h3><h4>CCarCtrl::AddToCarArray</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CCarCtrl::AddToCarArray), id, vehicleClass);</p>
<h4>CCarCtrl::ChooseCarModel</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::ChooseCarModel), vehicleClass);</p>
<p>0AA7: call_function_return 0x418110 num_params 1 pop 1 [vehicleClass] func_ret [int]</p>
<p>define function CCarCtrl__ChooseCarModel&lt;cdecl, 0x418110&gt;(vehicleClass): int</p>
<h4>CCarCtrl::ChooseGangCarModel</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::ChooseGangCarModel), gang);</p>
<p>0AA7: call_function_return 0x4182C0 num_params 1 pop 1 [gang] func_ret [int]</p>
<p>define function CCarCtrl__ChooseGangCarModel&lt;cdecl, 0x4182C0&gt;(gang): int</p>
<h4>CCarCtrl::ChooseModel</h4>
<p>plugin::CallAndReturnDynGlobal<int, CZoneInfo *, CVector *, int *>(gaddrof(CCarCtrl::ChooseModel), info, pos, outVehicleClass);</p>
<p>0AA7: call_function_return 0x417EC0 num_params 3 pop 3 [info] [pos] [outVehicleClass] func_ret [int]</p>
<p>define function CCarCtrl__ChooseModel&lt;cdecl, 0x417EC0&gt;(info, pos, outVehicleClass): int</p>
<h4>CCarCtrl::ChoosePoliceCarModel</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CCarCtrl::ChoosePoliceCarModel));</p>
<p>0AA7: call_function_return 0x4181F0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CCarCtrl__ChoosePoliceCarModel&lt;cdecl, 0x4181F0&gt;(): int</p>
<h4>CCarCtrl::CountCarsOfType</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CCarCtrl::CountCarsOfType), modelIndex);</p>
<p>0AA7: call_function_return 0x418820 num_params 1 pop 1 [modelIndex] func_ret [int]</p>
<p>define function CCarCtrl__CountCarsOfType&lt;cdecl, 0x418820&gt;(modelIndex): int</p>
<h4>CCarCtrl::DragCarToPoint</h4>
<p>plugin::CallDynGlobal<CVehicle *, CVector *>(gaddrof(CCarCtrl::DragCarToPoint), vehicle, point);</p>
<h4>CCarCtrl::FindAngleToWeaveThroughTraffic</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *, CPhysical *, float, float>(gaddrof(CCarCtrl::FindAngleToWeaveThroughTraffic), vehicle, target, angleToTarget, angleForward);</p>
<p>0AA7: call_function_return 0x41A590 num_params 4 pop 4 [vehicle] [target] [angleToTarget] [angleForward] func_ret [float]</p>
<p>define function CCarCtrl__FindAngleToWeaveThroughTraffic&lt;cdecl, 0x41A590&gt;(vehicle, target, angleToTarget, angleForward): float</p>
<h4>CCarCtrl::FindLinksToGoWithTheseNodes</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::FindLinksToGoWithTheseNodes), vehicle);</p>
<h4>CCarCtrl::FindMaxSteerAngle</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarCtrl::FindMaxSteerAngle), vehicle);</p>
<p>0AA7: call_function_return 0x41E2F0 num_params 1 pop 1 [vehicle] func_ret [float]</p>
<p>define function CCarCtrl__FindMaxSteerAngle&lt;cdecl, 0x41E2F0&gt;(vehicle): float</p>
<h4>CCarCtrl::FindMaximumSpeedForThisCarInTraffic</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *>(gaddrof(CCarCtrl::FindMaximumSpeedForThisCarInTraffic), vehicle);</p>
<p>0AA7: call_function_return 0x418C10 num_params 1 pop 1 [vehicle] func_ret [float]</p>
<p>define function CCarCtrl__FindMaximumSpeedForThisCarInTraffic&lt;cdecl, 0x418C10&gt;(vehicle): float</p>
<h4>CCarCtrl::FindPathDirection</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char, int, int, int>(gaddrof(CCarCtrl::FindPathDirection), prevNode, curNode, nextNode);</p>
<p>0AA7: call_function_return 0x41C360 num_params 3 pop 3 [prevNode] [curNode] [nextNode] func_ret [unsigned char]</p>
<p>define function CCarCtrl__FindPathDirection&lt;cdecl, 0x41C360&gt;(prevNode, curNode, nextNode): int</p>
<h4>CCarCtrl::FindSpeedMultiplier</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CCarCtrl::FindSpeedMultiplier), angleChange, minAngle, maxAngle, coef);</p>
<p>0AA7: call_function_return 0x41D980 num_params 4 pop 4 [angleChange] [minAngle] [maxAngle] [coef] func_ret [float]</p>
<p>define function CCarCtrl__FindSpeedMultiplier&lt;cdecl, 0x41D980&gt;(angleChange, minAngle, maxAngle, coef): float</p>
<h4>CCarCtrl::GenerateOneEmergencyServicesCar</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned int, CVector>(gaddrof(CCarCtrl::GenerateOneEmergencyServicesCar), modelIndex, point);</p>
<p>0AA7: call_function_return 0x41FE50 num_params 2 pop 2 [modelIndex] [point] func_ret [bool]</p>
<p>define function CCarCtrl__GenerateOneEmergencyServicesCar&lt;cdecl, 0x41FE50&gt;(modelIndex, point): int</p>
<h4>CCarCtrl::IsThisVehicleInteresting</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::IsThisVehicleInteresting), vehicle);</p>
<p>0AA7: call_function_return 0x41F780 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarCtrl__IsThisVehicleInteresting&lt;cdecl, 0x41F780&gt;(vehicle): int</p>
<h4>CCarCtrl::JoinCarWithRoadSystem</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::JoinCarWithRoadSystem), vehicle);</p>
<h4>CCarCtrl::JoinCarWithRoadSystemGotoCoors</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *, CVector, bool>(gaddrof(CCarCtrl::JoinCarWithRoadSystemGotoCoors), vehicle, point, isProperNow);</p>
<p>0AA7: call_function_return 0x41FA00 num_params 3 pop 3 [vehicle] [point] [isProperNow] func_ret [bool]</p>
<p>define function CCarCtrl__JoinCarWithRoadSystemGotoCoors&lt;cdecl, 0x41FA00&gt;(vehicle, point, isProperNow): int</p>
<h4>CCarCtrl::MapCouldMoveInThisArea</h4>
<p>plugin::CallAndReturnDynGlobal<bool, float, float>(gaddrof(CCarCtrl::MapCouldMoveInThisArea), x, y);</p>
<p>0AA7: call_function_return 0x4203B0 num_params 2 pop 2 [x] [y] func_ret [bool]</p>
<p>define function CCarCtrl__MapCouldMoveInThisArea&lt;cdecl, 0x4203B0&gt;(x, y): int</p>
<h4>CCarCtrl::PickNextNodeAccordingStrategy</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeAccordingStrategy), vehicle);</p>
<p>0AA7: call_function_return 0x41BA50 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarCtrl__PickNextNodeAccordingStrategy&lt;cdecl, 0x41BA50&gt;(vehicle): int</p>
<h4>CCarCtrl::PickNextNodeRandomly</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::PickNextNodeRandomly), vehicle);</p>
<h4>CCarCtrl::PickNextNodeToChaseCar</h4>
<p>plugin::CallDynGlobal<CVehicle *, float, float, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeToChaseCar), vehicle, targetX, targetY, target);</p>
<h4>CCarCtrl::PickNextNodeToFollowPath</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCarCtrl::PickNextNodeToFollowPath), vehicle);</p>
<p>0AA7: call_function_return 0x41CD50 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarCtrl__PickNextNodeToFollowPath&lt;cdecl, 0x41CD50&gt;(vehicle): int</p>
<h4>CCarCtrl::PossiblyRemoveVehicle</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::PossiblyRemoveVehicle), vehicle);</p>
<h4>CCarCtrl::RegisterVehicleOfInterest</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::RegisterVehicleOfInterest), vehicle);</p>
<h4>CCarCtrl::RemoveFromInterestingVehicleList</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::RemoveFromInterestingVehicleList), vehicle);</p>
<h4>CCarCtrl::ScanForPedDanger</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::ScanForPedDanger), vehicle);</p>
<h4>CCarCtrl::SlowCarDownForCarsSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float>(gaddrof(CCarCtrl::SlowCarDownForCarsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pSpeed, curSpeed);</p>
<h4>CCarCtrl::SlowCarDownForOtherCar</h4>
<p>plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float>(gaddrof(CCarCtrl::SlowCarDownForOtherCar), entity, vehicle, pSpeed, curSpeed);</p>
<h4>CCarCtrl::SlowCarDownForPedsSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float>(gaddrof(CCarCtrl::SlowCarDownForPedsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pSpeed, curSpeed);</p>
<h4>CCarCtrl::SlowCarOnRailsDownForTrafficAndLights</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SlowCarOnRailsDownForTrafficAndLights), vehicle);</p>
<h4>CCarCtrl::SteerAIBoatWithPhysics</h4>
<p>plugin::CallDynGlobal<CBoat *>(gaddrof(CCarCtrl::SteerAIBoatWithPhysics), boat);</p>
<h4>CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget</h4>
<p>plugin::CallDynGlobal<CBoat *, float, float, float *, float *, float *>(gaddrof(CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget), boat, targetX, targetY, steerAngle, gasPedal, breakPedal);</p>
<h4>CCarCtrl::SteerAICarWithPhysics</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SteerAICarWithPhysics), vehicle);</p>
<h4>CCarCtrl::SteerAICarWithPhysicsFollowPath</h4>
<p>plugin::CallDynGlobal<CVehicle *, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsFollowPath), vehicle, steerAngle, gasPedal, breakPedal, bHandBrake);</p>
<h4>CCarCtrl::SteerAICarWithPhysicsHeadingForTarget</h4>
<p>plugin::CallDynGlobal<CVehicle *, CPhysical *, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsHeadingForTarget), vehicle, target, targetX, targetY, steerAngle, gasPedal, breakPedal, bHandBrake);</p>
<h4>CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget</h4>
<p>plugin::CallDynGlobal<CVehicle *, float, float, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget), vehicle, targetX, targetY, targetSpeedX, targetSpeedY, steerAngle, gasPedal, breakPedal, bHandBrake);</p>
<h4>CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop</h4>
<p>plugin::CallDynGlobal<CVehicle *, float, float, float, float, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop), vehicle, targetX, targetY, targetSpeedX, targetSpeedY, steerAngle, gasPedal, breakPedal, bHandBrake);</p>
<h4>CCarCtrl::SteerAICarWithPhysics_OnlyMission</h4>
<p>plugin::CallDynGlobal<CVehicle *, float *, float *, float *, bool *>(gaddrof(CCarCtrl::SteerAICarWithPhysics_OnlyMission), vehicle, steerAngle, gasPedal, breakPedal, bHandBrake);</p>
<h4>CCarCtrl::SwitchVehicleToRealPhysics</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::SwitchVehicleToRealPhysics), vehicle);</p>
<h4>CCarCtrl::TestCollisionBetween2MovingRects</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *, CVehicle *, float, float, CVector *, CVector *, unsigned char>(gaddrof(CCarCtrl::TestCollisionBetween2MovingRects), vehicleA, vehicleB, projectionX, projectionY, pForwardA, pForwardB, id);</p>
<p>0AA7: call_function_return 0x41A020 num_params 7 pop 7 [vehicleA] [vehicleB] [projectionX] [projectionY] [pForwardA] [pForwardB] [id] func_ret [float]</p>
<p>define function CCarCtrl__TestCollisionBetween2MovingRects&lt;cdecl, 0x41A020&gt;(vehicleA, vehicleB, projectionX, projectionY, pForwardA, pForwardB, id): float</p>
<h4>CCarCtrl::ThisRoadObjectCouldMove</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CCarCtrl::ThisRoadObjectCouldMove), objectModelIndex);</p>
<p>0AA7: call_function_return 0x420380 num_params 1 pop 1 [objectModelIndex] func_ret [bool]</p>
<p>define function CCarCtrl__ThisRoadObjectCouldMove&lt;cdecl, 0x420380&gt;(objectModelIndex): int</p>
<h4>CCarCtrl::UpdateCarCount</h4>
<p>plugin::CallDynGlobal<CVehicle *, bool>(gaddrof(CCarCtrl::UpdateCarCount), vehicle, remove);</p>
<h4>CCarCtrl::UpdateCarOnRails</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarCtrl::UpdateCarOnRails), vehicle);</p>
<h4>CCarCtrl::WeaveForObject</h4>
<p>plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForObject), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);</p>
<h4>CCarCtrl::WeaveForOtherCar</h4>
<p>plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForOtherCar), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);</p>
<h4>CCarCtrl::WeaveForPed</h4>
<p>plugin::CallDynGlobal<CEntity *, CVehicle *, float *, float *>(gaddrof(CCarCtrl::WeaveForPed), entity, vehicle, pAngleToWeaveLeft, pAngleToWeaveRight);</p>
<h4>CCarCtrl::WeaveThroughCarsSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList &, CVehicle *, CPhysical *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughCarsSectorList), list, vehicle, target, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);</p>
<h4>CCarCtrl::WeaveThroughObjectsSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList &, CVehicle *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughObjectsSectorList), list, vehicle, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);</p>
<h4>CCarCtrl::WeaveThroughPedsSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList &, CVehicle *, CPhysical *, float, float, float, float, float *, float *>(gaddrof(CCarCtrl::WeaveThroughPedsSectorList), list, vehicle, target, x_inf, y_inf, x_sup, y_sup, pAngleToWeaveLeft, pAngleToWeaveRight);</p><h3 id="plugin_iiigame_iiiccargeneratorcpp">plugin_III\game_III\CCarGenerator.cpp</h3><h4>CCarGenerator::CalcNextGen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CCarGenerator *>(gaddrof(CCarGenerator::CalcNextGen), this);</p>
<p>0AA8: call_method_return 0x5426C0 struct [CCarGenerator] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>CCarGenerator::CheckForBlockage</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckForBlockage), this);</p>
<p>0AA8: call_method_return 0x542DF0 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCarGenerator::CheckIfWithinRangeOfAnyPlayers</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckIfWithinRangeOfAnyPlayers), this);</p>
<p>0AA8: call_method_return 0x542E50 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCarGenerator::DoInternalProcessing</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::DoInternalProcessing), this);</p>
<p>0AA6: call_method 0x5426E0 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__DoInternalProcessing&lt;thiscall, 0x5426E0&gt;()</p>
<h4>CCarGenerator::Process</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::Process), this);</p>
<p>0AA6: call_method 0x542BB0 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__Process&lt;thiscall, 0x542BB0&gt;()</p>
<h4>CCarGenerator::Setup</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(gaddrof(CCarGenerator::Setup), this, x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay);</p>
<p>0AA6: call_method 0x542C40 struct [CCarGenerator] num_params 12 pop 0 [x] [y] [z] [angle] [modelId] [primaryColor] [secondaryColor] [forceSpawn] [alarm] [doorLock] [minDelay] [maxDelay]</p>
<p>define function CCarGenerator__Setup&lt;thiscall, 0x542C40&gt;(x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay)</p>
<h4>CCarGenerator::SwitchOff</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOff), this);</p>
<p>0AA6: call_method 0x542690 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__SwitchOff&lt;thiscall, 0x542690&gt;()</p>
<h4>CCarGenerator::SwitchOn</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOn), this);</p>
<p>0AA6: call_method 0x5426A0 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__SwitchOn&lt;thiscall, 0x5426A0&gt;()</p><h3 id="plugin_iiigame_iiiccivilianpedcpp">plugin_III\game_III\CCivilianPed.cpp</h3><h4>CCivilianPed::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CCivilianPed *>(this);</p>
<h4>CCivilianPed::CivilianAI</h4>
<p>plugin::CallMethodDynGlobal<CCivilianPed *>(gaddrof(CCivilianPed::CivilianAI), this);</p>
<p>0AA6: call_method 0x4C07A0 struct [CCivilianPed] num_params 0 pop 0</p>
<p>define function CCivilianPed__CivilianAI&lt;thiscall, 0x4C07A0&gt;()</p><h3 id="plugin_iiigame_iiicclockcpp">plugin_III\game_III\CClock.cpp</h3><h4>CClock::GetGameClockMinutesUntil</h4>
<p>plugin::CallAndReturnDynGlobal<int, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);</p>
<p>0AA7: call_function_return 0x4733F0 num_params 2 pop 2 [hours] [minutes] func_ret [int]</p>
<p>define function CClock__GetGameClockMinutesUntil&lt;cdecl, 0x4733F0&gt;(hours, minutes): int</p>
<h4>CClock::GetIsTimeInRange</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);</p>
<p>0AA7: call_function_return 0x473420 num_params 2 pop 2 [hourA] [hourB] func_ret [bool]</p>
<p>define function CClock__GetIsTimeInRange&lt;cdecl, 0x473420&gt;(hourA, hourB): int</p>
<h4>CClock::Initialise</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);</p>
<h4>CClock::SetGameClock</h4>
<p>plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes);</p><h3 id="plugin_iiigame_iiiccloudscpp">plugin_III\game_III\CClouds.cpp</h3><h4>CClouds::RenderBackground</h4>
<p>plugin::CallDynGlobal<short, short, short, short, short, short, short>(gaddrof(CClouds::RenderBackground), redTop, greenTop, blueTop, redBottom, greenBottom, blueBottom, alpha);</p>
<h4>UseDarkBackground</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(UseDarkBackground));</p>
<p>0AA7: call_function_return 0x4F7ED0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function UseDarkBackground&lt;cdecl, 0x4F7ED0&gt;(): int</p><h3 id="plugin_iiigame_iiicclumpmodelinfocpp">plugin_III\game_III\CClumpModelInfo.cpp</h3><h4>CClumpModelInfo::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<2, CClumpModelInfo *>(this);</p>
<h4>*CClumpModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 3, CClumpModelInfo *>(this);</p>
<h4>*CClumpModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 4, CClumpModelInfo *, RwMatrix *>(this, matrix);</p>
<h4>*CClumpModelInfo::GetRwObject</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 5, CClumpModelInfo *>(this);</p>
<h4>CClumpModelInfo::SetClump</h4>
<p>plugin::CallVirtualMethod<6, CClumpModelInfo *, RpClump *>(this, clump);</p>
<h4>CClumpModelInfo::SetFrameIds</h4>
<p>plugin::CallMethodDynGlobal<CClumpModelInfo *, RwObjectNameIdAssocation *>(gaddrof(CClumpModelInfo::SetFrameIds), this, id);</p>
<p>0AA6: call_method 0x4F8BB0 struct [CClumpModelInfo] num_params 1 pop 0 [id]</p>
<p>define function CClumpModelInfo__SetFrameIds&lt;thiscall, 0x4F8BB0&gt;(id)</p>
<h4>CClumpModelInfo::FillFrameArray</h4>
<p>plugin::CallDynGlobal<RpClump *, RwFrame **>(gaddrof(CClumpModelInfo::FillFrameArray), clump, frames);</p>
<h4>*CClumpModelInfo::FillFrameArrayCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FillFrameArrayCB), frame, data);</p>
<p>0AA7: call_function_return 0x4F8B20 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function CClumpModelInfo__FillFrameArrayCB&lt;cdecl, 0x4F8B20&gt;(frame, data): int</p>
<h4>*CClumpModelInfo::FindFrameFromIdCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromIdCB), frame, data);</p>
<p>0AA7: call_function_return 0x4F8AD0 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function CClumpModelInfo__FindFrameFromIdCB&lt;cdecl, 0x4F8AD0&gt;(frame, data): int</p>
<h4>*CClumpModelInfo::FindFrameFromNameCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromNameCB), frame, data);</p>
<p>0AA7: call_function_return 0x4F8960 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function CClumpModelInfo__FindFrameFromNameCB&lt;cdecl, 0x4F8960&gt;(frame, data): int</p>
<h4>*CClumpModelInfo::FindFrameFromNameWithoutIdCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CClumpModelInfo::FindFrameFromNameWithoutIdCB), frame, data);</p>
<p>0AA7: call_function_return 0x4F8A10 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function CClumpModelInfo__FindFrameFromNameWithoutIdCB&lt;cdecl, 0x4F8A10&gt;(frame, data): int</p>
<h4>*CClumpModelInfo::GetFrameFromId</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RpClump *, int>(gaddrof(CClumpModelInfo::GetFrameFromId), clump, id);</p>
<p>0AA7: call_function_return 0x4F8B50 num_params 2 pop 2 [clump] [id] func_ret [RwFrame *]</p>
<p>define function CClumpModelInfo__GetFrameFromId&lt;cdecl, 0x4F8B50&gt;(clump, id): int</p>
<h4>*CClumpModelInfo::SetAtomicRendererCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CClumpModelInfo::SetAtomicRendererCB), atomic, data);</p>
<p>0AA7: call_function_return 0x4F8940 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CClumpModelInfo__SetAtomicRendererCB&lt;cdecl, 0x4F8940&gt;(atomic, data): int</p><h3 id="plugin_iiigame_iiiccolboxcpp">plugin_III\game_III\CColBox.cpp</h3><h4>CColBox::operator=</h4>
<p>plugin::CallMethodDynGlobal<CColBox *, CColBox const &>(gaddrof(CColBox::operator=), this, right);</p>
<p>0AA6: call_method 0x40B2E0 struct [CColBox] num_params 1 pop 0 [right]</p>
<p>define function CColBox__operator=&lt;thiscall, 0x40B2E0&gt;(right)</p>
<h4>CColBox::Set</h4>
<p>plugin::CallMethodDynGlobal<CColBox *, CVector &, CVector &, unsigned char, unsigned char>(gaddrof(CColBox::Set), this, min, max, material, flag);</p>
<p>0AA6: call_method 0x40B2A0 struct [CColBox] num_params 4 pop 0 [min] [max] [material] [flag]</p>
<p>define function CColBox__Set&lt;thiscall, 0x40B2A0&gt;(min, max, material, flag)</p><h3 id="plugin_iiigame_iiiccollinecpp">plugin_III\game_III\CColLine.cpp</h3><h4>CColLine::Set</h4>
<p>plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(gaddrof(CColLine::Set), this, start, end);</p>
<p>0AA6: call_method 0x40B350 struct [CColLine] num_params 2 pop 0 [start] [end]</p>
<p>define function CColLine__Set&lt;thiscall, 0x40B350&gt;(start, end)</p><h3 id="plugin_iiigame_iiiccollisioncpp">plugin_III\game_III\CCollision.cpp</h3><h4>CCollision::Init</h4>
<p>plugin::Call<0x40B380>();</p>
<p>0AA5: call_function 0x40B380 num_params 0 pop 0</p>
<p>define function CCollision__Init&lt;cdecl, 0x40B380&gt;()</p>
<h4>CCollision::Shutdown</h4>
<p>plugin::Call<0x40B3A0>();</p>
<p>0AA5: call_function 0x40B3A0 num_params 0 pop 0</p>
<p>define function CCollision__Shutdown&lt;cdecl, 0x40B3A0&gt;()</p>
<h4>CCollision::Update</h4>
<p>plugin::Call<0x40B3B0>();</p>
<p>0AA5: call_function 0x40B3B0 num_params 0 pop 0</p>
<p>define function CCollision__Update&lt;cdecl, 0x40B3B0&gt;()</p>
<h4>CCollision::LoadCollisionScreen</h4>
<p>plugin::Call<0x40B580, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x40B580 num_params 1 pop 1 [levelName]</p>
<p>define function CCollision__LoadCollisionScreen&lt;cdecl, 0x40B580&gt;(levelName)</p>
<h4>CCollision::LoadCollisionWhenINeedIt</h4>
<p>plugin::Call<0x40B5B0, bool>(arg0);</p>
<p>0AA5: call_function 0x40B5B0 num_params 1 pop 1 [arg0]</p>
<p>define function CCollision__LoadCollisionWhenINeedIt&lt;cdecl, 0x40B5B0&gt;(arg0)</p>
<h4>CCollision::SortOutCollisionAfterLoad</h4>
<p>plugin::Call<0x40B900>();</p>
<p>0AA5: call_function 0x40B900 num_params 0 pop 0</p>
<p>define function CCollision__SortOutCollisionAfterLoad&lt;cdecl, 0x40B900&gt;()</p>
<h4>CCollision::CalculateTrianglePlanes</h4>
<p>plugin::Call<0x40B960, CColModel*>(colModel);</p>
<p>0AA5: call_function 0x40B960 num_params 1 pop 1 [colModel]</p>
<p>define function CCollision__CalculateTrianglePlanes&lt;cdecl, 0x40B960&gt;(colModel)</p>
<h4>CCollision::ProcessSphereSphere</h4>
<p>plugin::CallAndReturn<bool, 0x40B9F0, CColSphere const&, CColSphere const&, CColPoint&, float&>(sphere1, sphere2, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x40B9F0 num_params 4 pop 4 [sphere1] [sphere2] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessSphereSphere&lt;cdecl, 0x40B9F0&gt;(sphere1, sphere2, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestSphereBox</h4>
<p>plugin::CallAndReturn<bool, 0x40BB70, CColSphere const&, CColBox const&>(sphere, box);</p>
<p>0AA7: call_function_return 0x40BB70 num_params 2 pop 2 [sphere] [box] func_ret [bool]</p>
<p>define function CCollision__TestSphereBox&lt;cdecl, 0x40BB70&gt;(sphere, box): int</p>
<h4>CCollision::ProcessSphereBox</h4>
<p>plugin::CallAndReturn<bool, 0x40BC00, CColSphere const&, CColBox const&, CColPoint&, float&>(sphere, box, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x40BC00 num_params 4 pop 4 [sphere] [box] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessSphereBox&lt;cdecl, 0x40BC00&gt;(sphere, box, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestSphereTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x40C580, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(sphere, verts, tri, triPlane);</p>
<p>0AA7: call_function_return 0x40C580 num_params 4 pop 4 [sphere] [verts] [tri] [triPlane] func_ret [bool]</p>
<p>define function CCollision__TestSphereTriangle&lt;cdecl, 0x40C580&gt;(sphere, verts, tri, triPlane): int</p>
<h4>CCollision::ProcessSphereTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x40CE30, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(sphere, verts, tri, triPlane, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x40CE30 num_params 6 pop 6 [sphere] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessSphereTriangle&lt;cdecl, 0x40CE30&gt;(sphere, verts, tri, triPlane, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestLineSphere</h4>
<p>plugin::CallAndReturn<bool, 0x40DAA0, CColLine const&, CColSphere const&>(colLine, sphere);</p>
<p>0AA7: call_function_return 0x40DAA0 num_params 2 pop 2 [colLine] [sphere] func_ret [bool]</p>
<p>define function CCollision__TestLineSphere&lt;cdecl, 0x40DAA0&gt;(colLine, sphere): int</p>
<h4>CCollision::DistToLine</h4>
<p>plugin::CallAndReturn<float, 0x40DC70, CVector const<em>, CVector const</em>, CVector const*>(lineStart, lineEnd, point);</p>
<p>0AA7: call_function_return 0x40DC70 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]</p>
<p>define function CCollision__DistToLine&lt;cdecl, 0x40DC70&gt;(lineStart, lineEnd, point): float</p>
<h4>CCollision::ProcessLineSphere</h4>
<p>plugin::CallAndReturn<bool, 0x40DE80, CColLine const&, CColSphere const&, CColPoint&, float&>(colLine, sphere, colPoint, depth);</p>
<p>0AA7: call_function_return 0x40DE80 num_params 4 pop 4 [colLine] [sphere] [colPoint] [depth] func_ret [bool]</p>
<p>define function CCollision__ProcessLineSphere&lt;cdecl, 0x40DE80&gt;(colLine, sphere, colPoint, depth): int</p>
<h4>CCollision::TestLineBox</h4>
<p>plugin::CallAndReturn<bool, 0x40E130, CColLine const&, CColBox const&>(colLine, colBox);</p>
<p>0AA7: call_function_return 0x40E130 num_params 2 pop 2 [colLine] [colBox] func_ret [bool]</p>
<p>define function CCollision__TestLineBox&lt;cdecl, 0x40E130&gt;(colLine, colBox): int</p>
<h4>CCollision::TestVerticalLineBox</h4>
<p>plugin::CallAndReturn<bool, 0x40E5C0, CColLine const&, CColBox const&>(colLine, colBox);</p>
<p>0AA7: call_function_return 0x40E5C0 num_params 2 pop 2 [colLine] [colBox] func_ret [bool]</p>
<p>define function CCollision__TestVerticalLineBox&lt;cdecl, 0x40E5C0&gt;(colLine, colBox): int</p>
<h4>CCollision::ProcessLineBox</h4>
<p>plugin::CallAndReturn<bool, 0x40E670, CColLine const&, CColBox const&, CColPoint&, float&>(colLine, colBox, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x40E670 num_params 4 pop 4 [colLine] [colBox] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessLineBox&lt;cdecl, 0x40E670&gt;(colLine, colBox, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestLineTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x40EC10, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(colLine, verts, tri, triPlane);</p>
<p>0AA7: call_function_return 0x40EC10 num_params 4 pop 4 [colLine] [verts] [tri] [triPlane] func_ret [bool]</p>
<p>define function CCollision__TestLineTriangle&lt;cdecl, 0x40EC10&gt;(colLine, verts, tri, triPlane): int</p>
<h4>CCollision::ProcessLineTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x40F140, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(colLine, verts, tri, triPlane, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x40F140 num_params 6 pop 6 [colLine] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessLineTriangle&lt;cdecl, 0x40F140&gt;(colLine, verts, tri, triPlane, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x40F720, CColLine const&, CMatrix const&, CColModel&, bool>(colLine, transform, colModel, doSeeThroughCheck);</p>
<p>0AA7: call_function_return 0x40F720 num_params 4 pop 4 [colLine] [transform] [colModel] [doSeeThroughCheck] func_ret [bool]</p>
<p>define function CCollision__TestLineOfSight&lt;cdecl, 0x40F720&gt;(colLine, transform, colModel, doSeeThroughCheck): int</p>
<h4>CCollision::ProcessLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x40F910, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool>(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck);</p>
<p>0AA7: call_function_return 0x40F910 num_params 6 pop 6 [colLine] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] func_ret [bool]</p>
<p>define function CCollision__ProcessLineOfSight&lt;cdecl, 0x40F910&gt;(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck): int</p>
<h4>CCollision::ProcessVerticalLineTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x40FB50, CColLine const&, CompressedVector const<em>, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly</em>>(colLine, verts, tri, triPlane, colPoint, maxTouchDistance, colPoly);</p>
<p>0AA7: call_function_return 0x40FB50 num_params 7 pop 7 [colLine] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] [colPoly] func_ret [bool]</p>
<p>define function CCollision__ProcessVerticalLineTriangle&lt;cdecl, 0x40FB50&gt;(colLine, verts, tri, triPlane, colPoint, maxTouchDistance, colPoly): int</p>
<h4>CCollision::ProcessVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x410120, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, CStoredCollPoly*>(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, colPoly);</p>
<p>0AA7: call_function_return 0x410120 num_params 7 pop 7 [colLine] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] [colPoly] func_ret [bool]</p>
<p>define function CCollision__ProcessVerticalLine&lt;cdecl, 0x410120&gt;(colLine, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, colPoly): int</p>
<h4>CCollision::IsStoredPolyStillValidVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x4105A0, CVector const&, float, CColPoint&, CStoredCollPoly*>(lineOrigin, lineDist, colPoint, colPoly);</p>
<p>0AA7: call_function_return 0x4105A0 num_params 4 pop 4 [lineOrigin] [lineDist] [colPoint] [colPoly] func_ret [bool]</p>
<p>define function CCollision__IsStoredPolyStillValidVerticalLine&lt;cdecl, 0x4105A0&gt;(lineOrigin, lineDist, colPoint, colPoly): int</p>
<h4>CCollision::ProcessColModels</h4>
<p>plugin::CallAndReturn<int, 0x410BE0, CMatrix const&, CColModel&, CMatrix const&, CColModel&, CColPoint<em>, CColPoint</em>, float*>(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x410BE0 num_params 7 pop 7 [transform1] [colModel1] [transform2] [colModel2] [colPoint1] [colPoint2] [maxTouchDistance] func_ret [int]</p>
<p>define function CCollision__ProcessColModels&lt;cdecl, 0x410BE0&gt;(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance): int</p><h3 id="plugin_iiigame_iiiccolmodelcpp">plugin_III\game_III\CColModel.cpp</h3><h4>CColModel::CColModel</h4>
<p>plugin::CallMethodDynGlobal<CColModel *>(ctor_gaddr(CColModel), this);</p>
<h4>CColModel::~CColModel</h4>
<p>plugin::CallMethodDynGlobal<CColModel *>(dtor_gaddr(CColModel), this);</p>
<h4>CColModel::operator=</h4>
<p>plugin::CallMethodDynGlobal<CColModel *, CColModel const &>(gaddrof_o(CColModel::operator=, void (CColModel::*)(CColModel const &amp;)), this, right);</p>
<p>0AA6: call_method 0x411710 struct [CColModel] num_params 1 pop 0 [right]</p>
<p>define function CColModel__operator=&lt;thiscall, 0x411710&gt;(right)</p>
<h4>CColModel::CalculateTrianglePlanes</h4>
<p>plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::CalculateTrianglePlanes), this);</p>
<p>0AA6: call_method 0x411CB0 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__CalculateTrianglePlanes&lt;thiscall, 0x411CB0&gt;()</p>
<h4>*CColModel::GetLinkPtr</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CLink<CColModel *> *, CColModel *&gt;(gaddrof(CColModel::GetLinkPtr), this);</p>
<p>0AA8: call_method_return 0x411D60 struct [*CColModel] num_params 0 pop 0 func_ret [CLink<CColModel *> *]</p>
<h4>CColModel::GetTrianglePoint</h4>
<p>plugin::CallMethodDynGlobal<CColModel *, CVector &, int>(gaddrof(CColModel::GetTrianglePoint), this, outVec, vertId);</p>
<p>0AA6: call_method 0x411C70 struct [CColModel] num_params 2 pop 0 [outVec] [vertId]</p>
<p>define function CColModel__GetTrianglePoint&lt;thiscall, 0x411C70&gt;(outVec, vertId)</p>
<h4>CColModel::RemoveCollisionVolumes</h4>
<p>plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::RemoveCollisionVolumes), this);</p>
<p>0AA6: call_method 0x411D80 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__RemoveCollisionVolumes&lt;thiscall, 0x411D80&gt;()</p>
<h4>CColModel::RemoveTrianglePlanes</h4>
<p>plugin::CallMethodDynGlobal<CColModel *>(gaddrof(CColModel::RemoveTrianglePlanes), this);</p>
<p>0AA6: call_method 0x411D10 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__RemoveTrianglePlanes&lt;thiscall, 0x411D10&gt;()</p>
<h4>CColModel::SetLinkPtr</h4>
<p>plugin::CallMethodDynGlobal<CColModel *, CLink<CColModel *> *&gt;(gaddrof(CColModel::SetLinkPtr), this, link);</p>
<p>0AA6: call_method 0x411D40 struct [CColModel] num_params 1 pop 0 [link]</p>
<p>define function CColModel__SetLinkPtr&lt;thiscall, 0x411D40&gt;(link)</p><h3 id="plugin_iiigame_iiiccolspherecpp">plugin_III\game_III\CColSphere.cpp</h3><h4>CColSphere::CColSphere</h4>
<p>plugin::CallMethodDynGlobal<CColSphere *>(ctor_gaddr(CColSphere), this);</p>
<h4>CColSphere::Set</h4>
<p>plugin::CallMethodDynGlobal<CColSphere *, float, CVector &, unsigned char, unsigned char>(gaddrof(CColSphere::Set), this, radius, center, material, flag);</p>
<p>0AA6: call_method 0x411E40 struct [CColSphere] num_params 4 pop 0 [radius] [center] [material] [flag]</p>
<p>define function CColSphere__Set&lt;thiscall, 0x411E40&gt;(radius, center, material, flag)</p><h3 id="plugin_iiigame_iiiccoltrianglecpp">plugin_III\game_III\CColTriangle.cpp</h3><h4>CColTriangle::Set</h4>
<p>plugin::CallMethodDynGlobal<CColTriangle *, CompressedVector const *, int, int, int, unsigned char, unsigned char>(gaddrof(CColTriangle::Set), this, verts, vertA, vertB, vertC, material, flag);</p>
<p>0AA6: call_method 0x411E70 struct [CColTriangle] num_params 6 pop 0 [verts] [vertA] [vertB] [vertC] [material] [flag]</p>
<p>define function CColTriangle__Set&lt;thiscall, 0x411E70&gt;(verts, vertA, vertB, vertC, material, flag)</p><h3 id="plugin_iiigame_iiiccoltriangleplanecpp">plugin_III\game_III\CColTrianglePlane.cpp</h3><h4>CColTrianglePlane::GetNormal</h4>
<p>plugin::CallMethodDynGlobal<CColTrianglePlane *, CVector &>(gaddrof(CColTrianglePlane::GetNormal), this, point);</p>
<p>0AA6: call_method 0x412140 struct [CColTrianglePlane] num_params 1 pop 0 [point]</p>
<p>define function CColTrianglePlane__GetNormal&lt;thiscall, 0x412140&gt;(point)</p>
<h4>CColTrianglePlane::Set</h4>
<p>plugin::CallMethodDynGlobal<CColTrianglePlane *, CompressedVector const *, CColTriangle &>(gaddrof(CColTrianglePlane::Set), this, verts, tri);</p>
<p>0AA6: call_method 0x411EA0 struct [CColTrianglePlane] num_params 2 pop 0 [verts] [tri]</p>
<p>define function CColTrianglePlane__Set&lt;thiscall, 0x411EA0&gt;(verts, tri)</p><h3 id="plugin_iiigame_iiiccontrollerstatecpp">plugin_III\game_III\CControllerState.cpp</h3><h4>CControllerState::Clear</h4>
<p>plugin::CallMethod<0x4916C0, CControllerState *>(this);</p>
<p>0AA6: call_method 0x4916C0 struct [CControllerState] num_params 0 pop 0</p>
<p>define function CControllerState__Clear&lt;thiscall, 0x4916C0&gt;()</p><h3 id="plugin_iiigame_iiiccoppedcpp">plugin_III\game_III\CCopPed.cpp</h3><h4>CCopPed::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CCopPed *>(this);</p>
<h4>CCopPed::ArrestPlayer</h4>
<p>plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ArrestPlayer), this);</p>
<p>0AA6: call_method 0x4C2C90 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ArrestPlayer&lt;thiscall, 0x4C2C90&gt;()</p>
<h4>CCopPed::ClearPursuit</h4>
<p>plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ClearPursuit), this);</p>
<p>0AA6: call_method 0x4C28C0 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ClearPursuit&lt;thiscall, 0x4C28C0&gt;()</p>
<h4>CCopPed::CopAI</h4>
<p>plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::CopAI), this);</p>
<p>0AA6: call_method 0x4C1B50 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__CopAI&lt;thiscall, 0x4C1B50&gt;()</p>
<h4>CCopPed::ScanForCrimes</h4>
<p>plugin::CallMethodDynGlobal<CCopPed *>(gaddrof(CCopPed::ScanForCrimes), this);</p>
<p>0AA6: call_method 0x4C26A0 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ScanForCrimes&lt;thiscall, 0x4C26A0&gt;()</p>
<h4>CCopPed::SetArrestPlayer</h4>
<p>plugin::CallMethodDynGlobal<CCopPed *, CPed *>(gaddrof(CCopPed::SetArrestPlayer), this, player);</p>
<p>0AA6: call_method 0x4C2B00 struct [CCopPed] num_params 1 pop 0 [player]</p>
<p>define function CCopPed__SetArrestPlayer&lt;thiscall, 0x4C2B00&gt;(player)</p>
<h4>CCopPed::SetPursuit</h4>
<p>plugin::CallMethodDynGlobal<CCopPed *, bool>(gaddrof(CCopPed::SetPursuit), this, ignoreCopLimit);</p>
<p>0AA6: call_method 0x4C27D0 struct [CCopPed] num_params 1 pop 0 [ignoreCopLimit]</p>
<p>define function CCopPed__SetPursuit&lt;thiscall, 0x4C27D0&gt;(ignoreCopLimit)</p><h3 id="plugin_iiigame_iiiccoronascpp">plugin_III\game_III\CCoronas.cpp</h3><h4>CCoronas::RegisterCorona</h4>
<p>plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof_o(CCoronas::RegisterCorona, void (*)(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &amp;, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float)), id, red, green, blue, alpha, coors, size, drawDist, coronaType, flareType, reflection, LOScheck, drawStreak, someAngle);</p>
<h4>CCoronas::RegisterCorona</h4>
<p>plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &, float, float, RwTexture *, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof_o(CCoronas::RegisterCorona, void (*)(unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const &amp;, float, float, RwTexture *, unsigned char, unsigned char, unsigned char, unsigned char, float)), id, red, green, blue, alpha, coors, size, drawDist, texture, flareType, reflection, LOScheck, drawStreak, someAngle);</p>
<h4>CCoronas::UpdateCoronaCoors</h4>
<p>plugin::CallDynGlobal<unsigned int, CVector const &, float, float>(gaddrof(CCoronas::UpdateCoronaCoors), id, coors, drawDist, someAngle);</p><h3 id="plugin_iiigame_iiiccranecpp">plugin_III\game_III\CCrane.cpp</h3><h4>CCrane::CalcHookCoordinates</h4>
<p>plugin::CallMethodDynGlobal<CCrane *, float *, float *, float *>(gaddrof(CCrane::CalcHookCoordinates), this, pX, pY, pZ);</p>
<p>0AA6: call_method 0x544F80 struct [CCrane] num_params 3 pop 0 [pX] [pY] [pZ]</p>
<p>define function CCrane__CalcHookCoordinates&lt;thiscall, 0x544F80&gt;(pX, pY, pZ)</p>
<h4>CCrane::DoesCranePickUpThisCarType</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, unsigned int>(gaddrof(CCrane::DoesCranePickUpThisCarType), this, vehicleModelIndex);</p>
<p>0AA8: call_method_return 0x544A90 struct [CCrane] num_params 1 pop 0 [vehicleModelIndex] func_ret [bool]</p>
<h4>CCrane::FindCarInSectorList</h4>
<p>plugin::CallMethodDynGlobal<CCrane *, CPtrList *>(gaddrof(CCrane::FindCarInSectorList), this, list);</p>
<p>0AA6: call_method 0x544850 struct [CCrane] num_params 1 pop 0 [list]</p>
<p>define function CCrane__FindCarInSectorList&lt;thiscall, 0x544850&gt;(list)</p>
<h4>CCrane::FindParametersForTarget</h4>
<p>plugin::CallMethodDynGlobal<CCrane *, float, float, float, float *, float *, float *>(gaddrof(CCrane::FindParametersForTarget), this, x, y, z, pAngle, pDistance, pHeight);</p>
<p>0AA6: call_method 0x544EF0 struct [CCrane] num_params 6 pop 0 [x] [y] [z] [pAngle] [pDistance] [pHeight]</p>
<p>define function CCrane__FindParametersForTarget&lt;thiscall, 0x544EF0&gt;(x, y, z, pAngle, pDistance, pHeight)</p>
<h4>CCrane::GoTowardsHeightTarget</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, float, float>(gaddrof(CCrane::GoTowardsHeightTarget), this, targetHeight, speedMultiplier);</p>
<p>0AA8: call_method_return 0x544E50 struct [CCrane] num_params 2 pop 0 [targetHeight] [speedMultiplier] func_ret [bool]</p>
<h4>CCrane::GoTowardsTarget</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCrane *, float, float, float, float>(gaddrof(CCrane::GoTowardsTarget), this, angleToTarget, distanceToTarget, targetHeight, speedMultiplier);</p>
<p>0AA8: call_method_return 0x544C00 struct [CCrane] num_params 4 pop 0 [angleToTarget] [distanceToTarget] [targetHeight] [speedMultiplier] func_ret [bool]</p>
<h4>CCrane::RotateCarriedCarProperly</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCrane *>(gaddrof(CCrane::RotateCarriedCarProperly), this);</p>
<p>0AA8: call_method_return 0x544700 struct [CCrane] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCrane::SetHookMatrix</h4>
<p>plugin::CallMethodDynGlobal<CCrane *>(gaddrof(CCrane::SetHookMatrix), this);</p>
<p>0AA6: call_method 0x545000 struct [CCrane] num_params 0 pop 0</p>
<p>define function CCrane__SetHookMatrix&lt;thiscall, 0x545000&gt;()</p>
<h4>CCrane::Update</h4>
<p>plugin::CallMethodDynGlobal<CCrane *>(gaddrof(CCrane::Update), this);</p>
<p>0AA6: call_method 0x543AC0 struct [CCrane] num_params 0 pop 0</p>
<p>define function CCrane__Update&lt;thiscall, 0x543AC0&gt;()</p><h3 id="plugin_iiigame_iiiccranescpp">plugin_III\game_III\CCranes.cpp</h3><h4>CCranes::ActivateCrane</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, float, float, float, bool, bool, float, float>(gaddrof(CCranes::ActivateCrane), infX, supX, infY, supY, dropOffX, dropOffY, dropOffZ, heading, isCrusher, isMilitary, posX, posY);</p>
<h4>CCranes::AddThisOneCrane</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CCranes::AddThisOneCrane), entity);</p>
<h4>CCranes::DeActivateCrane</h4>
<p>plugin::CallDynGlobal<float, float>(gaddrof(CCranes::DeActivateCrane), x, y);</p>
<h4>CCranes::DoesMilitaryCraneHaveThisOneAlready</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CCranes::DoesMilitaryCraneHaveThisOneAlready), vehicleModelIndex);</p>
<p>0AA7: call_function_return 0x544B00 num_params 1 pop 1 [vehicleModelIndex] func_ret [bool]</p>
<p>define function CCranes__DoesMilitaryCraneHaveThisOneAlready&lt;cdecl, 0x544B00&gt;(vehicleModelIndex): int</p>
<h4>CCranes::HaveAllCarsBeenCollectedByMilitaryCrane</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CCranes::HaveAllCarsBeenCollectedByMilitaryCrane));</p>
<p>0AA7: call_function_return 0x544BE0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCranes__HaveAllCarsBeenCollectedByMilitaryCrane&lt;cdecl, 0x544BE0&gt;(): int</p>
<h4>CCranes::IsThisCarBeingCarriedByAnyCrane</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingCarriedByAnyCrane), vehicle);</p>
<p>0AA7: call_function_return 0x545190 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCranes__IsThisCarBeingCarriedByAnyCrane&lt;cdecl, 0x545190&gt;(vehicle): int</p>
<h4>CCranes::IsThisCarBeingTargettedByAnyCrane</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingTargettedByAnyCrane), vehicle);</p>
<p>0AA7: call_function_return 0x5451E0 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCranes__IsThisCarBeingTargettedByAnyCrane&lt;cdecl, 0x5451E0&gt;(vehicle): int</p>
<h4>CCranes::IsThisCarPickedUp</h4>
<p>plugin::CallAndReturnDynGlobal<bool, float, float, CVehicle *>(gaddrof(CCranes::IsThisCarPickedUp), x, y, vehicle);</p>
<p>0AA7: call_function_return 0x543940 num_params 3 pop 3 [x] [y] [vehicle] func_ret [bool]</p>
<p>define function CCranes__IsThisCarPickedUp&lt;cdecl, 0x543940&gt;(x, y, vehicle): int</p>
<h4>CCranes::RegisterCarForMilitaryCrane</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CCranes::RegisterCarForMilitaryCrane), vehicleModelIndex);</p>
<h4>CCranes::Save</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CCranes::Save), buf, size);</p>
<h4>CranesLoad</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CranesLoad), buf, size);</p><h3 id="plugin_iiigame_iiiccreditscpp">plugin_III\game_III\CCredits.cpp</h3><h4>CCredits::AreCreditsDone</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CCredits::AreCreditsDone));</p>
<p>0AA7: call_function_return 0x4FE790 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCredits__AreCreditsDone&lt;cdecl, 0x4FE790&gt;(): int</p>
<h4>CCredits::PrintCreditSpace</h4>
<p>plugin::CallDynGlobal<float, unsigned int *>(gaddrof(CCredits::PrintCreditSpace), space, line);</p>
<h4>CCredits::PrintCreditText</h4>
<p>plugin::CallDynGlobal<float, float, wchar_t *, unsigned int *, float>(gaddrof(CCredits::PrintCreditText), scaleX, scaleY, text, lineOffset, scrollOffset);</p><h3 id="plugin_iiigame_iiiccurrentvehiclecpp">plugin_III\game_III\CCurrentVehicle.cpp</h3><h4>CCurrentVehicle::Display</h4>
<p>plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Display), this);</p>
<p>0AA6: call_method 0x4AD630 struct [CCurrentVehicle] num_params 0 pop 0</p>
<p>define function CCurrentVehicle__Display&lt;thiscall, 0x4AD630&gt;()</p>
<h4>CCurrentVehicle::Init</h4>
<p>plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Init), this);</p>
<p>0AA6: call_method 0x4AD5F0 struct [CCurrentVehicle] num_params 0 pop 0</p>
<p>define function CCurrentVehicle__Init&lt;thiscall, 0x4AD5F0&gt;()</p>
<h4>CCurrentVehicle::Process</h4>
<p>plugin::CallMethodDynGlobal<CCurrentVehicle *>(gaddrof(CCurrentVehicle::Process), this);</p>
<p>0AA6: call_method 0x4AD600 struct [CCurrentVehicle] num_params 0 pop 0</p>
<p>define function CCurrentVehicle__Process&lt;thiscall, 0x4AD600&gt;()</p><h3 id="plugin_iiigame_iiiccurvescpp">plugin_III\game_III\CCurves.cpp</h3><h4>CCurves::CalcCurvePoint</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *, CVector *, CVector *, float, int, CVector *, CVector *>(gaddrof(CCurves::CalcCurvePoint), pPos1, pPos2, pDir1, pDir2, between, timeOnCurve, pOutPos, pOutDir);</p>
<h4>CCurves::CalcSpeedScaleFactor</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVector *, CVector *, float, float, float, float>(gaddrof(CCurves::CalcSpeedScaleFactor), pPoint1, pPoint2, dir1X, dir1Y, dir2X, dir2Y);</p>
<p>0AA7: call_function_return 0x420410 num_params 6 pop 6 [pPoint1] [pPoint2] [dir1X] [dir1Y] [dir2X] [dir2Y] func_ret [float]</p>
<p>define function CCurves__CalcSpeedScaleFactor&lt;cdecl, 0x420410&gt;(pPoint1, pPoint2, dir1X, dir1Y, dir2X, dir2Y): float</p><h3 id="plugin_iiigame_iiiccutsceneheadcpp">plugin_III\game_III\CCutsceneHead.cpp</h3><h4>CCutsceneHead::CreateRwObject</h4>
<p>plugin::CallVirtualMethod<5, CCutsceneHead *>(this);</p>
<h4>CCutsceneHead::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<6, CCutsceneHead *>(this);</p>
<h4>CCutsceneHead::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CCutsceneHead *>(this);</p>
<h4>CCutsceneHead::Render</h4>
<p>plugin::CallVirtualMethod<13, CCutsceneHead *>(this);</p>
<h4>CCutsceneHead::PlayAnimation</h4>
<p>plugin::CallMethodDynGlobal<CCutsceneHead *, char const *>(gaddrof(CCutsceneHead::PlayAnimation), this, name);</p>
<p>0AA6: call_method 0x4BA6A0 struct [CCutsceneHead] num_params 1 pop 0 [name]</p>
<p>define function CCutsceneHead__PlayAnimation&lt;thiscall, 0x4BA6A0&gt;(name)</p><h3 id="plugin_iiigame_iiiccutscenemgrcpp">plugin_III\game_III\CCutsceneMgr.cpp</h3><h4>CCutsceneMgr::AddCutsceneHead</h4>
<p>plugin::CallAndReturn<CCutsceneHead<em>, 0x404CD0, CObject</em>, int>(object, modelIndex);</p>
<p>0AA7: call_function_return 0x404CD0 num_params 2 pop 2 [object] [modelIndex] func_ret [CCutsceneHead*]</p>
<p>define function CCutsceneMgr__AddCutsceneHead&lt;cdecl, 0x404CD0&gt;(object, modelIndex): int</p>
<h4>CCutsceneMgr::CreateCutsceneObject</h4>
<p>plugin::CallAndReturn<CCutsceneObject*, 0x404BE0, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x404BE0 num_params 1 pop 1 [modelIndex] func_ret [CCutsceneObject*]</p>
<p>define function CCutsceneMgr__CreateCutsceneObject&lt;cdecl, 0x404BE0&gt;(modelIndex): int</p>
<h4>CCutsceneMgr::DeleteCutsceneData</h4>
<p>plugin::Call<0x4048E0>();</p>
<p>0AA5: call_function 0x4048E0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__DeleteCutsceneData&lt;cdecl, 0x4048E0&gt;()</p>
<h4>CCutsceneMgr::FinishCutscene</h4>
<p>plugin::Call<0x405140>();</p>
<p>0AA5: call_function 0x405140 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__FinishCutscene&lt;cdecl, 0x405140&gt;()</p>
<h4>CCutsceneMgr::GetCutsceneTimeInMilleseconds</h4>
<p>plugin::CallAndReturn<int, 0x4051B0>();</p>
<p>0AA7: call_function_return 0x4051B0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CCutsceneMgr__GetCutsceneTimeInMilleseconds&lt;cdecl, 0x4051B0&gt;(): int</p>
<h4>CCutsceneMgr::HasCutsceneFinished</h4>
<p>plugin::CallAndReturn<bool, 0x4051F0>();</p>
<p>0AA7: call_function_return 0x4051F0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCutsceneMgr__HasCutsceneFinished&lt;cdecl, 0x4051F0&gt;(): int</p>
<h4>CCutsceneMgr::Initialise</h4>
<p>plugin::Call<0x4045D0>();</p>
<p>0AA5: call_function 0x4045D0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Initialise&lt;cdecl, 0x4045D0&gt;()</p>
<h4>CCutsceneMgr::LoadCutsceneData</h4>
<p>plugin::Call<0x404650, char const*>(cutsceneName);</p>
<p>0AA5: call_function 0x404650 num_params 1 pop 1 [cutsceneName]</p>
<p>define function CCutsceneMgr__LoadCutsceneData&lt;cdecl, 0x404650&gt;(cutsceneName)</p>
<h4>CCutsceneMgr::SetCutsceneAnim</h4>
<p>plugin::Call<0x404D20, char const<em>, CObject</em>>(animName, object);</p>
<p>0AA5: call_function 0x404D20 num_params 2 pop 2 [animName] [object]</p>
<p>define function CCutsceneMgr__SetCutsceneAnim&lt;cdecl, 0x404D20&gt;(animName, object)</p>
<h4>CCutsceneMgr::SetHeadAnim</h4>
<p>plugin::Call<0x404D80, char const<em>, CObject</em>>(animName, object);</p>
<p>0AA5: call_function 0x404D80 num_params 2 pop 2 [animName] [object]</p>
<p>define function CCutsceneMgr__SetHeadAnim&lt;cdecl, 0x404D80&gt;(animName, object)</p>
<h4>CCutsceneMgr::SetupCutsceneToStart</h4>
<p>plugin::Call<0x404DC0>();</p>
<p>0AA5: call_function 0x404DC0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__SetupCutsceneToStart&lt;cdecl, 0x404DC0&gt;()</p>
<h4>CCutsceneMgr::Shutdown</h4>
<p>plugin::Call<0x404630>();</p>
<p>0AA5: call_function 0x404630 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Shutdown&lt;cdecl, 0x404630&gt;()</p>
<h4>CCutsceneMgr::Update</h4>
<p>plugin::Call<0x404EE0>();</p>
<p>0AA5: call_function 0x404EE0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Update&lt;cdecl, 0x404EE0&gt;()</p>
<h4>FindCutsceneAudioTrackId</h4>
<p>plugin::CallAndReturn<int, 0x404530, char const*>(cutsceneName);</p>
<p>0AA7: call_function_return 0x404530 num_params 1 pop 1 [cutsceneName] func_ret [int]</p>
<p>define function FindCutsceneAudioTrackId&lt;cdecl, 0x404530&gt;(cutsceneName): int</p><h3 id="plugin_iiigame_iiiccutsceneobjectcpp">plugin_III\game_III\CCutsceneObject.cpp</h3><h4>CCutsceneObject::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CCutsceneObject *, unsigned int>(this, modelIndex);</p>
<h4>CCutsceneObject::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CCutsceneObject *>(this);</p>
<h4>CCutsceneObject::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CCutsceneObject *>(this);</p>
<h4>CCutsceneObject::Render</h4>
<p>plugin::CallVirtualMethod<13, CCutsceneObject *>(this);</p>
<h4>CCutsceneObject::SetupLighting</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 14, CCutsceneObject *>(this);</p>
<h4>CCutsceneObject::RemoveLighting</h4>
<p>plugin::CallVirtualMethod<15, CCutsceneObject *, bool>(this, resetWorldColors);</p><h3 id="plugin_iiigame_iiicdamagemanagercpp">plugin_III\game_III\CDamageManager.cpp</h3><h4>CDamageManager::ApplyDamage</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDamageManager *, tComponent, float, float>(gaddrof(CDamageManager::ApplyDamage), this, component, damage, unused);</p>
<p>0AA8: call_method_return 0x545A80 struct [CDamageManager] num_params 3 pop 0 [component] [damage] [unused] func_ret [bool]</p>
<h4>CDamageManager::FuckCarCompletely</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::FuckCarCompletely), this);</p>
<p>0AA6: call_method 0x545B70 struct [CDamageManager] num_params 0 pop 0</p>
<p>define function CDamageManager__FuckCarCompletely&lt;thiscall, 0x545B70&gt;()</p>
<h4>CDamageManager::GetComponentGroup</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDamageManager *, tComponent, tComponentGroup *, unsigned char *>(gaddrof(CDamageManager::GetComponentGroup), this, component, group, subComp);</p>
<p>0AA8: call_method_return 0x545790 struct [CDamageManager] num_params 3 pop 0 [component] [group] [subComp] func_ret [bool]</p>
<h4>CDamageManager::GetDoorStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetDoorStatus), this, door);</p>
<p>0AA8: call_method_return 0x545930 struct [CDamageManager] num_params 1 pop 0 [door] func_ret [int]</p>
<h4>CDamageManager::GetEngineStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *>(gaddrof(CDamageManager::GetEngineStatus), this);</p>
<p>0AA8: call_method_return 0x545960 struct [CDamageManager] num_params 0 pop 0 func_ret [int]</p>
<h4>CDamageManager::GetLightStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, eLights>(gaddrof(CDamageManager::GetLightStatus), this, light);</p>
<p>0AA8: call_method_return 0x545890 struct [CDamageManager] num_params 1 pop 0 [light] func_ret [int]</p>
<h4>CDamageManager::GetPanelStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetPanelStatus), this, panel);</p>
<p>0AA8: call_method_return 0x5458E0 struct [CDamageManager] num_params 1 pop 0 [panel] func_ret [int]</p>
<h4>CDamageManager::GetWheelStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CDamageManager *, int>(gaddrof(CDamageManager::GetWheelStatus), this, wheel);</p>
<p>0AA8: call_method_return 0x545910 struct [CDamageManager] num_params 1 pop 0 [wheel] func_ret [int]</p>
<h4>CDamageManager::ProgressDoorDamage</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressDoorDamage), this, door);</p>
<p>0AA6: call_method 0x545970 struct [CDamageManager] num_params 1 pop 0 [door]</p>
<p>define function CDamageManager__ProgressDoorDamage&lt;thiscall, 0x545970&gt;(door)</p>
<h4>CDamageManager::ProgressEngineDamage</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::ProgressEngineDamage), this);</p>
<p>0AA6: call_method 0x5459B0 struct [CDamageManager] num_params 0 pop 0</p>
<p>define function CDamageManager__ProgressEngineDamage&lt;thiscall, 0x5459B0&gt;()</p>
<h4>CDamageManager::ProgressPanelDamage</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressPanelDamage), this, panel);</p>
<p>0AA6: call_method 0x545A00 struct [CDamageManager] num_params 1 pop 0 [panel]</p>
<p>define function CDamageManager__ProgressPanelDamage&lt;thiscall, 0x545A00&gt;(panel)</p>
<h4>CDamageManager::ProgressWheelDamage</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, unsigned char>(gaddrof(CDamageManager::ProgressWheelDamage), this, wheel);</p>
<p>0AA6: call_method 0x545A40 struct [CDamageManager] num_params 1 pop 0 [wheel]</p>
<p>define function CDamageManager__ProgressWheelDamage&lt;thiscall, 0x545A40&gt;(wheel)</p>
<h4>CDamageManager::ResetDamageStatus</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *>(gaddrof(CDamageManager::ResetDamageStatus), this);</p>
<p>0AA6: call_method 0x545850 struct [CDamageManager] num_params 0 pop 0</p>
<p>define function CDamageManager__ResetDamageStatus&lt;thiscall, 0x545850&gt;()</p>
<h4>CDamageManager::SetDoorStatus</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetDoorStatus), this, door, status);</p>
<p>0AA6: call_method 0x545920 struct [CDamageManager] num_params 2 pop 0 [door] [status]</p>
<p>define function CDamageManager__SetDoorStatus&lt;thiscall, 0x545920&gt;(door, status)</p>
<h4>CDamageManager::SetEngineStatus</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, unsigned int>(gaddrof(CDamageManager::SetEngineStatus), this, status);</p>
<p>0AA6: call_method 0x545940 struct [CDamageManager] num_params 1 pop 0 [status]</p>
<p>define function CDamageManager__SetEngineStatus&lt;thiscall, 0x545940&gt;(status)</p>
<h4>CDamageManager::SetLightStatus</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, eLights, unsigned int>(gaddrof(CDamageManager::SetLightStatus), this, light, status);</p>
<p>0AA6: call_method 0x545860 struct [CDamageManager] num_params 2 pop 0 [light] [status]</p>
<p>define function CDamageManager__SetLightStatus&lt;thiscall, 0x545860&gt;(light, status)</p>
<h4>CDamageManager::SetPanelStatus</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetPanelStatus), this, panel, status);</p>
<p>0AA6: call_method 0x5458B0 struct [CDamageManager] num_params 2 pop 0 [panel] [status]</p>
<p>define function CDamageManager__SetPanelStatus&lt;thiscall, 0x5458B0&gt;(panel, status)</p>
<h4>CDamageManager::SetWheelStatus</h4>
<p>plugin::CallMethodDynGlobal<CDamageManager *, int, unsigned int>(gaddrof(CDamageManager::SetWheelStatus), this, wheel, status);</p>
<p>0AA6: call_method 0x545900 struct [CDamageManager] num_params 2 pop 0 [wheel] [status]</p>
<p>define function CDamageManager__SetWheelStatus&lt;thiscall, 0x545900&gt;(wheel, status)</p><h3 id="plugin_iiigame_iiicdarkelcpp">plugin_III\game_III\CDarkel.cpp</h3><h4>CDarkel::CalcFade</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char, unsigned int, unsigned int, unsigned int>(gaddrof(CDarkel::CalcFade), time, min, max);</p>
<p>0AA7: call_function_return 0x421380 num_params 3 pop 3 [time] [min] [max] func_ret [unsigned char]</p>
<p>define function CDarkel__CalcFade&lt;cdecl, 0x421380&gt;(time, min, max): int</p>
<h4>CDarkel::FrenzyOnGoing</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CDarkel::FrenzyOnGoing));</p>
<p>0AA7: call_function_return 0x420E60 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CDarkel__FrenzyOnGoing&lt;cdecl, 0x420E60&gt;(): int</p>
<h4>CDarkel::QueryModelsKilledByPlayer</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned short, int>(gaddrof(CDarkel::QueryModelsKilledByPlayer), modelId);</p>
<p>0AA7: call_function_return 0x421370 num_params 1 pop 1 [modelId] func_ret [unsigned short]</p>
<p>define function CDarkel__QueryModelsKilledByPlayer&lt;cdecl, 0x421370&gt;(modelId): int</p>
<h4>CDarkel::ReadStatus</h4>
<p>plugin::CallAndReturnDynGlobal<eDarkelStatus>(gaddrof(CDarkel::ReadStatus));</p>
<p>0AA7: call_function_return 0x420E50 num_params 0 pop 0 func_ret [eDarkelStatus]</p>
<p>define function CDarkel__ReadStatus&lt;cdecl, 0x420E50&gt;(): int</p>
<h4>CDarkel::RegisterCarBlownUpByPlayer</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CDarkel::RegisterCarBlownUpByPlayer), vehicle);</p>
<h4>CDarkel::RegisterKillByPlayer</h4>
<p>plugin::CallDynGlobal<CPed *, eWeaponType, bool>(gaddrof(CDarkel::RegisterKillByPlayer), ped, weaponType, headShot);</p>
<h4>CDarkel::RegisterKillNotByPlayer</h4>
<p>plugin::CallDynGlobal<CPed *, eWeaponType>(gaddrof(CDarkel::RegisterKillNotByPlayer), ped, weaponType);</p>
<h4>CDarkel::StartFrenzy</h4>
<p>plugin::CallDynGlobal<eWeaponType, int, unsigned short, int, wchar_t *, int, int, int, bool, bool>(gaddrof(CDarkel::StartFrenzy), weaponType, time, kill, model, text, model2, model3, model4, standardSound, headShot);</p><h3 id="plugin_iiigame_iiicdigitalclockcpp">plugin_III\game_III\CDigitalClock.cpp</h3><h4>CDigitalClock::Init</h4>
<p>plugin::CallMethodDynGlobal<CDigitalClock *, CVector, float, float, unsigned char, unsigned char, unsigned char, float, float>(gaddrof(CDigitalClock::Init), this, pos, sizeX, sizeY, red, green, blue, drawDistance, scale);</p>
<p>0AA6: call_method 0x5004F0 struct [CDigitalClock] num_params 8 pop 0 [pos] [sizeX] [sizeY] [red] [green] [blue] [drawDistance] [scale]</p>
<p>define function CDigitalClock__Init&lt;thiscall, 0x5004F0&gt;(pos, sizeX, sizeY, red, green, blue, drawDistance, scale)</p>
<h4>CDigitalClock::Render</h4>
<p>plugin::CallMethodDynGlobal<CDigitalClock *>(gaddrof(CDigitalClock::Render), this);</p>
<p>0AA6: call_method 0x5005F0 struct [CDigitalClock] num_params 0 pop 0</p>
<p>define function CDigitalClock__Render&lt;thiscall, 0x5005F0&gt;()</p>
<h4>CDigitalClock::Update</h4>
<p>plugin::CallMethodDynGlobal<CDigitalClock *>(gaddrof(CDigitalClock::Update), this);</p>
<p>0AA6: call_method 0x500550 struct [CDigitalClock] num_params 0 pop 0</p>
<p>define function CDigitalClock__Update&lt;thiscall, 0x500550&gt;()</p>
<h4>*CDigitalClock::GetString</h4>
<p>plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CDigitalClock::GetString));</p>
<p>0AA7: call_function_return 0x4FF450 num_params 0 pop 0 func_ret [char const *]</p>
<p>define function CDigitalClock__GetString&lt;cdecl, 0x4FF450&gt;(): int</p><h3 id="plugin_iiigame_iiicdirectorycpp">plugin_III\game_III\CDirectory.cpp</h3><h4>CDirectory::AddItem</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, CDirectory::DirectoryInfo const &>(gaddrof(CDirectory::AddItem), this, entry);</p>
<p>0AA6: call_method 0x473600 struct [CDirectory] num_params 1 pop 0 [entry]</p>
<p>define function CDirectory__AddItem&lt;thiscall, 0x473600&gt;(entry)</p>
<h4>CDirectory::FindItem</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *, unsigned int &, unsigned int &>(gaddrof(CDirectory::FindItem), this, name, outOffset, outSize);</p>
<p>0AA8: call_method_return 0x4736E0 struct [CDirectory] num_params 3 pop 0 [name] [outOffset] [outSize] func_ret [bool]</p>
<h4>CDirectory::ReadDirFile</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, char const *>(gaddrof(CDirectory::ReadDirFile), this, fileName);</p>
<p>0AA6: call_method 0x473630 struct [CDirectory] num_params 1 pop 0 [fileName]</p>
<p>define function CDirectory__ReadDirFile&lt;thiscall, 0x473630&gt;(fileName)</p>
<h4>CDirectory::WriteDirFile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *>(gaddrof(CDirectory::WriteDirFile), this, fileName);</p>
<p>0AA8: call_method_return 0x473690 struct [CDirectory] num_params 1 pop 0 [fileName] func_ret [bool]</p><h3 id="plugin_iiigame_iiicdmaudiocpp">plugin_III\game_III\cDMAudio.cpp</h3><h4>cDMAudio::ChangeMusicMode</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::ChangeMusicMode), this, mode);</p>
<p>0AA6: call_method 0x57CCF0 struct [cDMAudio] num_params 1 pop 0 [mode]</p>
<p>define function cDMAudio__ChangeMusicMode&lt;thiscall, 0x57CCF0&gt;(mode)</p>
<h4>cDMAudio::CheckForAnAudioFileOnCD</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::CheckForAnAudioFileOnCD), this);</p>
<p>0AA8: call_method_return 0x57CA70 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]</p>
<h4>cDMAudio::ClearMissionAudio</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ClearMissionAudio), this);</p>
<p>0AA6: call_method 0x57CE20 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__ClearMissionAudio&lt;thiscall, 0x57CE20&gt;()</p>
<h4>cDMAudio::CreateEntity</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, cDMAudio *, eAudioType, void *>(gaddrof(cDMAudio::CreateEntity), this, type, data);</p>
<p>0AA8: call_method_return 0x57C7C0 struct [cDMAudio] num_params 2 pop 0 [type] [data] func_ret [int]</p>
<h4>cDMAudio::CreateLoopingScriptObject</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, cDMAudio *, cAudioScriptObject *>(gaddrof(cDMAudio::CreateLoopingScriptObject), this, object);</p>
<p>0AA8: call_method_return 0x57CB00 struct [cDMAudio] num_params 1 pop 0 [object] func_ret [int]</p>
<h4>cDMAudio::CreateOneShotScriptObject</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, cAudioScriptObject *>(gaddrof(cDMAudio::CreateOneShotScriptObject), this, object);</p>
<p>0AA6: call_method 0x57CB60 struct [cDMAudio] num_params 1 pop 0 [object]</p>
<p>define function cDMAudio__CreateOneShotScriptObject&lt;thiscall, 0x57CB60&gt;(object)</p>
<h4>cDMAudio::DestroyAllGameCreatedEntities</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::DestroyAllGameCreatedEntities), this);</p>
<p>0AA6: call_method 0x57C870 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__DestroyAllGameCreatedEntities&lt;thiscall, 0x57C870&gt;()</p>
<h4>cDMAudio::DestroyEntity</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::DestroyEntity), this, audioEntity);</p>
<p>0AA6: call_method 0x57C7F0 struct [cDMAudio] num_params 1 pop 0 [audioEntity]</p>
<p>define function cDMAudio__DestroyEntity&lt;thiscall, 0x57C7F0&gt;(audioEntity)</p>
<h4>cDMAudio::DestroyLoopingScriptObject</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::DestroyLoopingScriptObject), this, audioEntity);</p>
<p>0AA6: call_method 0x57CB40 struct [cDMAudio] num_params 1 pop 0 [audioEntity]</p>
<p>define function cDMAudio__DestroyLoopingScriptObject&lt;thiscall, 0x57CB40&gt;(audioEntity)</p>
<h4>*cDMAudio::Get3DProviderName</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char *, cDMAudio *, unsigned char>(gaddrof(cDMAudio::Get3DProviderName), this, id);</p>
<p>0AA8: call_method_return 0x57C970 struct [*cDMAudio] num_params 1 pop 0 [id] func_ret [char *]</p>
<h4>cDMAudio::GetCDAudioDriveLetter</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *>(gaddrof(cDMAudio::GetCDAudioDriveLetter), this);</p>
<p>0AA8: call_method_return 0x57CA90 struct [cDMAudio] num_params 0 pop 0 func_ret [char]</p>
<h4>cDMAudio::GetCurrent3DProviderIndex</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *>(gaddrof(cDMAudio::GetCurrent3DProviderIndex), this);</p>
<p>0AA8: call_method_return 0x57C990 struct [cDMAudio] num_params 0 pop 0 func_ret [char]</p>
<h4>cDMAudio::GetMissionAudioLoadingStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetMissionAudioLoadingStatus), this);</p>
<p>0AA8: call_method_return 0x57CD90 struct [cDMAudio] num_params 0 pop 0 func_ret [unsigned char]</p>
<h4>cDMAudio::GetNum3DProvidersAvailable</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetNum3DProvidersAvailable), this);</p>
<p>0AA8: call_method_return 0x57C950 struct [cDMAudio] num_params 0 pop 0 func_ret [unsigned char]</p>
<h4>cDMAudio::GetRadioInCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, cDMAudio *>(gaddrof(cDMAudio::GetRadioInCar), this);</p>
<p>0AA8: call_method_return 0x57CE40 struct [cDMAudio] num_params 0 pop 0 func_ret [unsigned char]</p>
<h4>cDMAudio::Initialise</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Initialise), this);</p>
<p>0AA6: call_method 0x57C760 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__Initialise&lt;thiscall, 0x57C760&gt;()</p>
<h4>cDMAudio::IsAudioInitialised</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsAudioInitialised), this);</p>
<p>0AA8: call_method_return 0x57CAB0 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]</p>
<h4>cDMAudio::IsMP3RadioChannelAvailable</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsMP3RadioChannelAvailable), this);</p>
<p>0AA8: call_method_return 0x57C9F0 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]</p>
<h4>cDMAudio::IsMissionAudioSampleFinished</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cDMAudio *>(gaddrof(cDMAudio::IsMissionAudioSampleFinished), this);</p>
<p>0AA8: call_method_return 0x57CE00 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]</p>
<h4>cDMAudio::PlayFrontEndSound</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned short, unsigned int>(gaddrof(cDMAudio::PlayFrontEndSound), this, frontend, volume);</p>
<p>0AA6: call_method 0x57CC20 struct [cDMAudio] num_params 2 pop 0 [frontend] [volume]</p>
<p>define function cDMAudio__PlayFrontEndSound&lt;thiscall, 0x57CC20&gt;(frontend, volume)</p>
<h4>cDMAudio::PlayFrontEndTrack</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char, unsigned char>(gaddrof(cDMAudio::PlayFrontEndTrack), this, track, frontendFlag);</p>
<p>0AA6: call_method 0x57CC80 struct [cDMAudio] num_params 2 pop 0 [track] [frontendFlag]</p>
<p>define function cDMAudio__PlayFrontEndTrack&lt;thiscall, 0x57CC80&gt;(track, frontendFlag)</p>
<h4>cDMAudio::PlayLoadedMissionAudio</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::PlayLoadedMissionAudio), this);</p>
<p>0AA6: call_method 0x57CDE0 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__PlayLoadedMissionAudio&lt;thiscall, 0x57CDE0&gt;()</p>
<h4>cDMAudio::PlayOneShot</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, int, unsigned short, float>(gaddrof(cDMAudio::PlayOneShot), this, audioEntity, oneShot, volume);</p>
<p>0AA6: call_method 0x57C840 struct [cDMAudio] num_params 3 pop 0 [audioEntity] [oneShot] [volume]</p>
<p>define function cDMAudio__PlayOneShot&lt;thiscall, 0x57C840&gt;(audioEntity, oneShot, volume)</p>
<h4>cDMAudio::PlayPreloadedCutSceneMusic</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::PlayPreloadedCutSceneMusic), this);</p>
<p>0AA6: call_method 0x57CD30 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__PlayPreloadedCutSceneMusic&lt;thiscall, 0x57CD30&gt;()</p>
<h4>cDMAudio::PlayRadioAnnouncement</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::PlayRadioAnnouncement), this, announcement);</p>
<p>0AA6: call_method 0x57CC60 struct [cDMAudio] num_params 1 pop 0 [announcement]</p>
<p>define function cDMAudio__PlayRadioAnnouncement&lt;thiscall, 0x57CC60&gt;(announcement)</p>
<h4>cDMAudio::PlaySuspectLastSeen</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, float, float, float>(gaddrof(cDMAudio::PlaySuspectLastSeen), this, x, y, z);</p>
<p>0AA6: call_method 0x57CBB0 struct [cDMAudio] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function cDMAudio__PlaySuspectLastSeen&lt;thiscall, 0x57CBB0&gt;(x, y, z)</p>
<h4>cDMAudio::PreloadCutSceneMusic</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::PreloadCutSceneMusic), this, track);</p>
<p>0AA6: call_method 0x57CD10 struct [cDMAudio] num_params 1 pop 0 [track]</p>
<p>define function cDMAudio__PreloadCutSceneMusic&lt;thiscall, 0x57CD10&gt;(track)</p>
<h4>cDMAudio::PreloadMissionAudio</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, char *>(gaddrof(cDMAudio::PreloadMissionAudio), this, name);</p>
<p>0AA6: call_method 0x57CD70 struct [cDMAudio] num_params 1 pop 0 [name]</p>
<p>define function cDMAudio__PreloadMissionAudio&lt;thiscall, 0x57CD70&gt;(name)</p>
<h4>cDMAudio::ReacquireDigitalHandle</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ReacquireDigitalHandle), this);</p>
<p>0AA6: call_method 0x57CA30 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__ReacquireDigitalHandle&lt;thiscall, 0x57CA30&gt;()</p>
<h4>cDMAudio::ReleaseDigitalHandle</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::ReleaseDigitalHandle), this);</p>
<p>0AA6: call_method 0x57CA10 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__ReleaseDigitalHandle&lt;thiscall, 0x57CA10&gt;()</p>
<h4>cDMAudio::ReportCollision</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, CEntity *, CEntity *, unsigned char, unsigned char, float, float>(gaddrof(cDMAudio::ReportCollision), this, entityA, entityB, surfaceTypeA, surfaceTypeB, collisionPower, velocity);</p>
<p>0AA6: call_method 0x57CBE0 struct [cDMAudio] num_params 6 pop 0 [entityA] [entityB] [surfaceTypeA] [surfaceTypeB] [collisionPower] [velocity]</p>
<p>define function cDMAudio__ReportCollision&lt;thiscall, 0x57CBE0&gt;(entityA, entityB, surfaceTypeA, surfaceTypeB, collisionPower, velocity)</p>
<h4>cDMAudio::ReportCrime</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, eCrimeType, CVector const &>(gaddrof(cDMAudio::ReportCrime), this, crime, pos);</p>
<p>0AA6: call_method 0x57CAD0 struct [cDMAudio] num_params 2 pop 0 [crime] [pos]</p>
<p>define function cDMAudio__ReportCrime&lt;thiscall, 0x57CAD0&gt;(crime, pos)</p>
<h4>cDMAudio::ResetTimers</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned int>(gaddrof(cDMAudio::ResetTimers), this, time);</p>
<p>0AA6: call_method 0x57CCD0 struct [cDMAudio] num_params 1 pop 0 [time]</p>
<p>define function cDMAudio__ResetTimers&lt;thiscall, 0x57CCD0&gt;(time)</p>
<h4>cDMAudio::Service</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Service), this);</p>
<p>0AA6: call_method 0x57C7A0 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__Service&lt;thiscall, 0x57C7A0&gt;()</p>
<h4>cDMAudio::SetCurrent3DProvider</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetCurrent3DProvider), this, which);</p>
<p>0AA8: call_method_return 0x57C9B0 struct [cDMAudio] num_params 1 pop 0 [which] func_ret [char]</p>
<h4>cDMAudio::SetDynamicAcousticModelingStatus</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetDynamicAcousticModelingStatus), this, status);</p>
<p>0AA6: call_method 0x57CA50 struct [cDMAudio] num_params 1 pop 0 [status]</p>
<p>define function cDMAudio__SetDynamicAcousticModelingStatus&lt;thiscall, 0x57CA50&gt;(status)</p>
<h4>cDMAudio::SetEffectsFadeVol</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetEffectsFadeVol), this, volume);</p>
<p>0AA6: call_method 0x57C8F0 struct [cDMAudio] num_params 1 pop 0 [volume]</p>
<p>define function cDMAudio__SetEffectsFadeVol&lt;thiscall, 0x57C8F0&gt;(volume)</p>
<h4>cDMAudio::SetEffectsMasterVolume</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetEffectsMasterVolume), this, volume);</p>
<p>0AA6: call_method 0x57C890 struct [cDMAudio] num_params 1 pop 0 [volume]</p>
<p>define function cDMAudio__SetEffectsMasterVolume&lt;thiscall, 0x57C890&gt;(volume)</p>
<h4>cDMAudio::SetEntityStatus</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, int, unsigned char>(gaddrof(cDMAudio::SetEntityStatus), this, audioEntity, status);</p>
<p>0AA6: call_method 0x57C810 struct [cDMAudio] num_params 2 pop 0 [audioEntity] [status]</p>
<p>define function cDMAudio__SetEntityStatus&lt;thiscall, 0x57C810&gt;(audioEntity, status)</p>
<h4>cDMAudio::SetMissionAudioLocation</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, float, float, float>(gaddrof(cDMAudio::SetMissionAudioLocation), this, x, y, z);</p>
<p>0AA6: call_method 0x57CDB0 struct [cDMAudio] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function cDMAudio__SetMissionAudioLocation&lt;thiscall, 0x57CDB0&gt;(x, y, z)</p>
<h4>cDMAudio::SetMusicFadeVol</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetMusicFadeVol), this, volume);</p>
<p>0AA6: call_method 0x57C920 struct [cDMAudio] num_params 1 pop 0 [volume]</p>
<p>define function cDMAudio__SetMusicFadeVol&lt;thiscall, 0x57C920&gt;(volume)</p>
<h4>cDMAudio::SetMusicMasterVolume</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char>(gaddrof(cDMAudio::SetMusicMasterVolume), this, volume);</p>
<p>0AA6: call_method 0x57C8C0 struct [cDMAudio] num_params 1 pop 0 [volume]</p>
<p>define function cDMAudio__SetMusicMasterVolume&lt;thiscall, 0x57C8C0&gt;(volume)</p>
<h4>cDMAudio::SetRadioChannel</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned char, int>(gaddrof(cDMAudio::SetRadioChannel), this, radio, pos);</p>
<p>0AA6: call_method 0x57CE80 struct [cDMAudio] num_params 2 pop 0 [radio] [pos]</p>
<p>define function cDMAudio__SetRadioChannel&lt;thiscall, 0x57CE80&gt;(radio, pos)</p>
<h4>cDMAudio::SetRadioInCar</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, unsigned int>(gaddrof(cDMAudio::SetRadioInCar), this, radio);</p>
<p>0AA6: call_method 0x57CE60 struct [cDMAudio] num_params 1 pop 0 [radio]</p>
<p>define function cDMAudio__SetRadioInCar&lt;thiscall, 0x57CE60&gt;(radio)</p>
<h4>cDMAudio::SetSpeakerConfig</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *, int>(gaddrof(cDMAudio::SetSpeakerConfig), this, config);</p>
<p>0AA6: call_method 0x57C9D0 struct [cDMAudio] num_params 1 pop 0 [config]</p>
<p>define function cDMAudio__SetSpeakerConfig&lt;thiscall, 0x57C9D0&gt;(config)</p>
<h4>cDMAudio::StopCutSceneMusic</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::StopCutSceneMusic), this);</p>
<p>0AA6: call_method 0x57CD50 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__StopCutSceneMusic&lt;thiscall, 0x57CD50&gt;()</p>
<h4>cDMAudio::StopFrontEndTrack</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::StopFrontEndTrack), this);</p>
<p>0AA6: call_method 0x57CCB0 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__StopFrontEndTrack&lt;thiscall, 0x57CCB0&gt;()</p>
<h4>cDMAudio::Terminate</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(gaddrof(cDMAudio::Terminate), this);</p>
<p>0AA6: call_method 0x57C780 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__Terminate&lt;thiscall, 0x57C780&gt;()</p><h3 id="plugin_iiigame_iiicdoorcpp">plugin_III\game_III\CDoor.cpp</h3><h4>CDoor::CDoor</h4>
<p>plugin::CallMethod<0x52D150, CDoor *>(this);</p>
<p>0AA6: call_method 0x52D150 struct [CDoor] num_params 0 pop 0</p>
<p>define function CDoor__CDoor&lt;thiscall, 0x52D150&gt;()</p>
<h4>CDoor::GetAngleOpenRatio</h4>
<p>plugin::CallMethodAndReturn<float, 0x545F80, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x545F80 struct [CDoor] num_params 0 pop 0 func_ret [float]</p>
<p>define function CDoor__GetAngleOpenRatio&lt;thiscall, 0x545F80&gt;(): float</p>
<h4>CDoor::IsClosed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x546060, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x546060 struct [CDoor] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CDoor__IsClosed&lt;thiscall, 0x546060&gt;(): int</p>
<h4>CDoor::IsFullyOpen</h4>
<p>plugin::CallMethodAndReturn<bool, 0x546090, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x546090 struct [CDoor] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CDoor__IsFullyOpen&lt;thiscall, 0x546090&gt;(): int</p>
<h4>CDoor::Open</h4>
<p>plugin::CallMethod<0x545EF0, CDoor *, float>(this, angle);</p>
<p>0AA6: call_method 0x545EF0 struct [CDoor] num_params 1 pop 0 [angle]</p>
<p>define function CDoor__Open&lt;thiscall, 0x545EF0&gt;(angle)</p>
<h4>CDoor::Process</h4>
<p>plugin::CallMethod<0x545BD0, CDoor <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA6: call_method 0x545BD0 struct [CDoor] num_params 1 pop 0 [vehicle]</p>
<p>define function CDoor__Process&lt;thiscall, 0x545BD0&gt;(vehicle)</p>
<h4>CDoor::RetAngleWhenClosed</h4>
<p>plugin::CallMethodAndReturn<float, 0x545FE0, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x545FE0 struct [CDoor] num_params 0 pop 0 func_ret [float]</p>
<p>define function CDoor__RetAngleWhenClosed&lt;thiscall, 0x545FE0&gt;(): float</p>
<h4>CDoor::RetAngleWhenOpen</h4>
<p>plugin::CallMethodAndReturn<float, 0x546020, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x546020 struct [CDoor] num_params 0 pop 0 func_ret [float]</p>
<p>define function CDoor__RetAngleWhenOpen&lt;thiscall, 0x546020&gt;(): float</p><h3 id="plugin_iiigame_iiicdrawcpp">plugin_III\game_III\CDraw.cpp</h3><h4>CDraw::SetFOV</h4>
<p>plugin::CallDynGlobal<float>(gaddrof(CDraw::SetFOV), fovValue);</p><h3 id="plugin_iiigame_iiicdummycpp">plugin_III\game_III\CDummy.cpp</h3><h4>CDummy::Add</h4>
<p>plugin::CallVirtualMethod<1, CDummy *>(this);</p>
<h4>CDummy::Remove</h4>
<p>plugin::CallVirtualMethod<2, CDummy *>(this);</p><h3 id="plugin_iiigame_iiicemergencypedcpp">plugin_III\game_III\CEmergencyPed.cpp</h3><h4>CEmergencyPed::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CEmergencyPed *>(this);</p>
<h4>CEmergencyPed::FiremanAI</h4>
<p>plugin::CallMethodDynGlobal<CEmergencyPed *>(gaddrof(CEmergencyPed::FiremanAI), this);</p>
<p>0AA6: call_method 0x4C3CE0 struct [CEmergencyPed] num_params 0 pop 0</p>
<p>define function CEmergencyPed__FiremanAI&lt;thiscall, 0x4C3CE0&gt;()</p>
<h4>CEmergencyPed::InRange</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEmergencyPed *, CPed *>(gaddrof(CEmergencyPed::InRange), this, victim);</p>
<p>0AA8: call_method_return 0x4C3EC0 struct [CEmergencyPed] num_params 1 pop 0 [victim] func_ret [bool]</p>
<h4>CEmergencyPed::MedicAI</h4>
<p>plugin::CallMethodDynGlobal<CEmergencyPed *>(gaddrof(CEmergencyPed::MedicAI), this);</p>
<p>0AA6: call_method 0x4C30A0 struct [CEmergencyPed] num_params 0 pop 0</p>
<p>define function CEmergencyPed__MedicAI&lt;thiscall, 0x4C30A0&gt;()</p><h3 id="plugin_iiigame_iiicentitycpp">plugin_III\game_III\CEntity.cpp</h3><h4>CEntity::Add</h4>
<p>plugin::CallVirtualMethod<1, CEntity *>(this);</p>
<h4>CEntity::Remove</h4>
<p>plugin::CallVirtualMethod<2, CEntity *>(this);</p>
<h4>CEntity::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CEntity *, unsigned int>(this, modelIndex);</p>
<h4>CEntity::SetModelIndexNoCreate</h4>
<p>plugin::CallVirtualMethod<4, CEntity *, unsigned int>(this, modelIndex);</p>
<h4>CEntity::CreateRwObject</h4>
<p>plugin::CallVirtualMethod<5, CEntity *>(this);</p>
<h4>CEntity::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<6, CEntity *>(this);</p>
<h4>*CEntity::GetBoundRect</h4>
<p>plugin::CallVirtualMethodAndReturn<CRect *, 7, CEntity *>(this);</p>
<h4>CEntity::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CEntity *>(this);</p>
<h4>CEntity::ProcessCollision</h4>
<p>plugin::CallVirtualMethod<9, CEntity *>(this);</p>
<h4>CEntity::ProcessShift</h4>
<p>plugin::CallVirtualMethod<10, CEntity *>(this);</p>
<h4>CEntity::Teleport</h4>
<p>plugin::CallVirtualMethod<11, CEntity *, CVector>(this, point);</p>
<h4>CEntity::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CEntity *>(this);</p>
<h4>CEntity::Render</h4>
<p>plugin::CallVirtualMethod<13, CEntity *>(this);</p>
<h4>CEntity::SetupLighting</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 14, CEntity *>(this);</p>
<h4>CEntity::RemoveLighting</h4>
<p>plugin::CallVirtualMethod<15, CEntity *, bool>(this, resetWorldColors);</p>
<h4>CEntity::FlagToDestroyWhenNextProcessed</h4>
<p>plugin::CallVirtualMethod<16, CEntity *>(this);</p>
<h4>CEntity::AddSteamsFromGround</h4>
<p>plugin::CallMethodDynGlobal<CEntity *, CVector *>(gaddrof(CEntity::AddSteamsFromGround), this, unused);</p>
<p>0AA6: call_method 0x50CE40 struct [CEntity] num_params 1 pop 0 [unused]</p>
<p>define function CEntity__AddSteamsFromGround&lt;thiscall, 0x50CE40&gt;(unused)</p>
<h4>CEntity::AttachToRwObject</h4>
<p>plugin::CallMethodDynGlobal<CEntity *, RwObject *>(gaddrof(CEntity::AttachToRwObject), this, rwObject);</p>
<p>0AA6: call_method 0x473F10 struct [CEntity] num_params 1 pop 0 [rwObject]</p>
<p>define function CEntity__AttachToRwObject&lt;thiscall, 0x473F10&gt;(rwObject)</p>
<h4>CEntity::DetachFromRwObject</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::DetachFromRwObject), this);</p>
<p>0AA6: call_method 0x473F60 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__DetachFromRwObject&lt;thiscall, 0x473F60&gt;()</p>
<h4>*CEntity::GetBoundCentre</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVector *, CEntity *>(gaddrof_o(CEntity::GetBoundCentre, CVector <em>(CEntity::</em>)()), this);</p>
<p>0AA8: call_method_return 0x4742C0 struct [*CEntity] num_params 0 pop 0 func_ret [CVector *]</p>
<h4>CEntity::GetBoundCentre</h4>
<p>plugin::CallMethodDynGlobal<CEntity *, CVector &>(gaddrof_o(CEntity::GetBoundCentre, void (CEntity::*)(CVector &amp;)), this, out);</p>
<p>0AA6: call_method 0x4742C0 struct [CEntity] num_params 1 pop 0 [out]</p>
<p>define function CEntity__GetBoundCentre&lt;thiscall, 0x4742C0&gt;(out)</p>
<h4>CEntity::GetBoundRadius</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CEntity *>(gaddrof(CEntity::GetBoundRadius), this);</p>
<p>0AA8: call_method_return 0x474310 struct [CEntity] num_params 0 pop 0 func_ret [float]</p>
<h4>CEntity::GetDistanceFromCentreOfMassToBaseOfModel</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CEntity *>(gaddrof(CEntity::GetDistanceFromCentreOfMassToBaseOfModel), this);</p>
<p>0AA8: call_method_return 0x4755C0 struct [CEntity] num_params 0 pop 0 func_ret [float]</p>
<h4>CEntity::GetIsOnScreen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::GetIsOnScreen), this);</p>
<p>0AA8: call_method_return 0x474CC0 struct [CEntity] num_params 0 pop 0 func_ret [bool]</p>
<h4>CEntity::GetIsOnScreenComplex</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::GetIsOnScreenComplex), this);</p>
<p>0AA8: call_method_return 0x474D20 struct [CEntity] num_params 0 pop 0 func_ret [bool]</p>
<h4>CEntity::GetIsTouching</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntity *, CVector const &, float>(gaddrof(CEntity::GetIsTouching), this, posn, radius);</p>
<p>0AA8: call_method_return 0x474C10 struct [CEntity] num_params 2 pop 0 [posn] [radius] func_ret [bool]</p>
<h4>CEntity::IsVisible</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntity *>(gaddrof(CEntity::IsVisible), this);</p>
<p>0AA8: call_method_return 0x474CA0 struct [CEntity] num_params 0 pop 0 func_ret [bool]</p>
<h4>CEntity::ModifyMatrixForBannerInWind</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ModifyMatrixForBannerInWind), this);</p>
<p>0AA6: call_method 0x475830 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__ModifyMatrixForBannerInWind&lt;thiscall, 0x475830&gt;()</p>
<h4>CEntity::ModifyMatrixForTreeInWind</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ModifyMatrixForTreeInWind), this);</p>
<p>0AA6: call_method 0x475670 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__ModifyMatrixForTreeInWind&lt;thiscall, 0x475670&gt;()</p>
<h4>CEntity::PreRenderForGlassWindow</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::PreRenderForGlassWindow), this);</p>
<p>0AA6: call_method 0x475A20 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__PreRenderForGlassWindow&lt;thiscall, 0x475A20&gt;()</p>
<h4>CEntity::ProcessLightsForEntity</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ProcessLightsForEntity), this);</p>
<p>0AA6: call_method 0x4FA530 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__ProcessLightsForEntity&lt;thiscall, 0x4FA530&gt;()</p>
<h4>CEntity::PruneReferences</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::PruneReferences), this);</p>
<p>0AA6: call_method 0x4A7530 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__PruneReferences&lt;thiscall, 0x4A7530&gt;()</p>
<h4>CEntity::RegisterReference</h4>
<p>plugin::CallMethodDynGlobal<CEntity *, CEntity **>(gaddrof(CEntity::RegisterReference), this, entity);</p>
<p>0AA6: call_method 0x4A7480 struct [CEntity] num_params 1 pop 0 [entity]</p>
<p>define function CEntity__RegisterReference&lt;thiscall, 0x4A7480&gt;(entity)</p>
<h4>CEntity::ResolveReferences</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::ResolveReferences), this);</p>
<p>0AA6: call_method 0x4A74E0 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__ResolveReferences&lt;thiscall, 0x4A74E0&gt;()</p>
<h4>CEntity::SetState</h4>
<p>plugin::CallMethodDynGlobal<CEntity *, unsigned char>(gaddrof(CEntity::SetState), this, state);</p>
<p>0AA6: call_method 0x54A8A0 struct [CEntity] num_params 1 pop 0 [state]</p>
<p>define function CEntity__SetState&lt;thiscall, 0x54A8A0&gt;(state)</p>
<h4>CEntity::SetupBigBuilding</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::SetupBigBuilding), this);</p>
<p>0AA6: call_method 0x4755E0 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__SetupBigBuilding&lt;thiscall, 0x4755E0&gt;()</p>
<h4>CEntity::UpdateRwFrame</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(gaddrof(CEntity::UpdateRwFrame), this);</p>
<p>0AA6: call_method 0x474330 struct [CEntity] num_params 0 pop 0</p>
<p>define function CEntity__UpdateRwFrame&lt;thiscall, 0x474330&gt;()</p><h3 id="plugin_iiigame_iiiceventlistcpp">plugin_III\game_III\CEventList.cpp</h3><h4>CEventList::ClearEvent</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CEventList::ClearEvent), event);</p>
<h4>CEventList::FindClosestEvent</h4>
<p>plugin::CallAndReturnDynGlobal<bool, eEventType, CVector, int *>(gaddrof(CEventList::FindClosestEvent), type, pos, event);</p>
<p>0AA7: call_function_return 0x475F90 num_params 3 pop 3 [type] [pos] [event] func_ret [bool]</p>
<p>define function CEventList__FindClosestEvent&lt;cdecl, 0x475F90&gt;(type, pos, event): int</p>
<h4>CEventList::GetEvent</h4>
<p>plugin::CallAndReturnDynGlobal<bool, eEventType, int *>(gaddrof(CEventList::GetEvent), type, event);</p>
<p>0AA7: call_function_return 0x475F40 num_params 2 pop 2 [type] [event] func_ret [bool]</p>
<p>define function CEventList__GetEvent&lt;cdecl, 0x475F40&gt;(type, event): int</p>
<h4>CEventList::RegisterEvent</h4>
<p>plugin::CallDynGlobal<eEventType, eEventEntity, CEntity *, CPed *, int>(gaddrof_o(CEventList::RegisterEvent, void (*)(eEventType, eEventEntity, CEntity *, CPed *, int)), type, entityType, entity, criminal, time);</p>
<h4>CEventList::RegisterEvent</h4>
<p>plugin::CallDynGlobal<eEventType, CVector, int>(gaddrof_o(CEventList::RegisterEvent, void (*)(eEventType, CVector, int)), type, pos, time);</p>
<h4>CEventList::ReportCrimeForEvent</h4>
<p>plugin::CallDynGlobal<eEventType, int, bool>(gaddrof(CEventList::ReportCrimeForEvent), type, crimeId, bPoliceDontReallyCare);</p><h3 id="plugin_iiigame_iiicexplosioncpp">plugin_III\game_III\CExplosion.cpp</h3><h4>CExplosion::AddExplosion</h4>
<p>plugin::CallAndReturn<bool, 0x5591C0, CEntity<em>, CEntity</em>, eExplosionType, CVector const&, unsigned int>(victim, creator, explosionType, posn, time);</p>
<p>0AA7: call_function_return 0x5591C0 num_params 5 pop 5 [victim] [creator] [explosionType] [posn] [time] func_ret [bool]</p>
<p>define function CExplosion__AddExplosion&lt;cdecl, 0x5591C0&gt;(victim, creator, explosionType, posn, time): int</p>
<h4>CExplosion::CExplosion</h4>
<p>plugin::CallMethod<0x55ADE0, CExplosion *>(this);</p>
<p>0AA6: call_method 0x55ADE0 struct [CExplosion] num_params 0 pop 0</p>
<p>define function CExplosion__CExplosion&lt;thiscall, 0x55ADE0&gt;()</p>
<h4>CExplosion::GetExplosionActiveCounter</h4>
<p>plugin::CallAndReturn<unsigned char, 0x559140, unsigned char>(index);</p>
<p>0AA7: call_function_return 0x559140 num_params 1 pop 1 [index] func_ret [unsigned char]</p>
<p>define function CExplosion__GetExplosionActiveCounter&lt;cdecl, 0x559140&gt;(index): int</p>
<h4>CExplosion::GetExplosionPosition</h4>
<p>plugin::CallAndReturn<CVector*, 0x5591A0, unsigned char>(index);</p>
<p>0AA7: call_function_return 0x5591A0 num_params 1 pop 1 [index] func_ret [CVector*]</p>
<p>define function CExplosion__GetExplosionPosition&lt;cdecl, 0x5591A0&gt;(index): int</p>
<h4>CExplosion::Initialise</h4>
<p>plugin::Call<0x559030>();</p>
<p>0AA5: call_function 0x559030 num_params 0 pop 0</p>
<p>define function CExplosion__Initialise&lt;cdecl, 0x559030&gt;()</p>
<h4>CExplosion::RemoveAllExplosionsInArea</h4>
<p>plugin::Call<0x55AD40, CVector, float>(posn, radius);</p>
<p>0AA5: call_function 0x55AD40 num_params 2 pop 2 [posn] [radius]</p>
<p>define function CExplosion__RemoveAllExplosionsInArea&lt;cdecl, 0x55AD40&gt;(posn, radius)</p>
<h4>CExplosion::ResetExplosionActiveCounter</h4>
<p>plugin::Call<0x559160, unsigned char>(index);</p>
<p>0AA5: call_function 0x559160 num_params 1 pop 1 [index]</p>
<p>define function CExplosion__ResetExplosionActiveCounter&lt;cdecl, 0x559160&gt;(index)</p>
<h4>CExplosion::Shutdown</h4>
<p>plugin::Call<0x559100>();</p>
<p>0AA5: call_function 0x559100 num_params 0 pop 0</p>
<p>define function CExplosion__Shutdown&lt;cdecl, 0x559100&gt;()</p>
<h4>CExplosion::TestForExplosionInArea</h4>
<p>plugin::CallAndReturn<bool, 0x55AC80, eExplosionType, float, float, float, float, float, float>(explosionType, x1, y1, z1, x2, y2, z2);</p>
<p>0AA7: call_function_return 0x55AC80 num_params 7 pop 7 [explosionType] [x1] [y1] [z1] [x2] [y2] [z2] func_ret [bool]</p>
<p>define function CExplosion__TestForExplosionInArea&lt;cdecl, 0x55AC80&gt;(explosionType, x1, y1, z1, x2, y2, z2): int</p>
<h4>CExplosion::Update</h4>
<p>plugin::Call<0x55A0C0>();</p>
<p>0AA5: call_function 0x55A0C0 num_params 0 pop 0</p>
<p>define function CExplosion__Update&lt;cdecl, 0x55A0C0&gt;()</p><h3 id="plugin_iiigame_iiicfallingglasspanecpp">plugin_III\game_III\CFallingGlassPane.cpp</h3><h4>CFallingGlassPane::Render</h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(gaddrof(CFallingGlassPane::Render), this);</p>
<p>0AA6: call_method 0x5024C0 struct [CFallingGlassPane] num_params 0 pop 0</p>
<p>define function CFallingGlassPane__Render&lt;thiscall, 0x5024C0&gt;()</p>
<h4>CFallingGlassPane::Update</h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(gaddrof(CFallingGlassPane::Update), this);</p>
<p>0AA6: call_method 0x502080 struct [CFallingGlassPane] num_params 0 pop 0</p>
<p>define function CFallingGlassPane__Update&lt;thiscall, 0x502080&gt;()</p><h3 id="plugin_iiigame_iiicfileloadercpp">plugin_III\game_III\CFileLoader.cpp</h3><h4>CFileLoader::LoadLine</h4>
<p>plugin::CallAndReturn<char*, 0x4761D0, int>(fileHandle);</p>
<p>0AA7: call_function_return 0x4761D0 num_params 1 pop 1 [fileHandle] func_ret [char*]</p>
<p>define function CFileLoader__LoadLine&lt;cdecl, 0x4761D0&gt;(fileHandle): int</p>
<h4>GetFilename</h4>
<p>plugin::CallAndReturn<char<em>, 0x476230, char const</em>>(filepath);</p>
<p>0AA7: call_function_return 0x476230 num_params 1 pop 1 [filepath] func_ret [char*]</p>
<p>define function GetFilename&lt;cdecl, 0x476230&gt;(filepath): int</p>
<h4>LoadingScreenLoadingFile</h4>
<p>plugin::Call<0x476250, char const*>(filepath);</p>
<p>0AA5: call_function 0x476250 num_params 1 pop 1 [filepath]</p>
<p>define function LoadingScreenLoadingFile&lt;cdecl, 0x476250&gt;(filepath)</p>
<h4>CFileLoader::LoadLevel</h4>
<p>plugin::Call<0x476290, char const*>(datFilePath);</p>
<p>0AA5: call_function 0x476290 num_params 1 pop 1 [datFilePath]</p>
<p>define function CFileLoader__LoadLevel&lt;cdecl, 0x476290&gt;(datFilePath)</p>
<h4>CFileLoader::LoadCollisionFromDatFile</h4>
<p>plugin::Call<0x476520, unsigned int>(gameLevel);</p>
<p>0AA5: call_function 0x476520 num_params 1 pop 1 [gameLevel]</p>
<p>define function CFileLoader__LoadCollisionFromDatFile&lt;cdecl, 0x476520&gt;(gameLevel)</p>
<h4>CFileLoader::LoadTexDictionary</h4>
<p>plugin::CallAndReturn<RwTexDictionary *, 0x4765B0, char const*>(filepath);</p>
<p>0AA7: call_function_return 0x4765B0 num_params 1 pop 1 [filepath] func_ret [RwTexDictionary *]</p>
<p>define function CFileLoader__LoadTexDictionary&lt;cdecl, 0x4765B0&gt;(filepath): int</p>
<h4>MoveTexturesCB</h4>
<p>plugin::CallAndReturn<RwTexture<em>, 0x476610, RwTexture</em>, void*>(texture, data);</p>
<p>0AA7: call_function_return 0x476610 num_params 2 pop 2 [texture] [data] func_ret [RwTexture*]</p>
<p>define function MoveTexturesCB&lt;cdecl, 0x476610&gt;(texture, data): int</p>
<h4>CFileLoader::AddTexDictionaries</h4>
<p>plugin::Call<0x476630, RwTexDictionary<em>, RwTexDictionary</em>>(dst, src);</p>
<p>0AA5: call_function 0x476630 num_params 2 pop 2 [dst] [src]</p>
<p>define function CFileLoader__AddTexDictionaries&lt;cdecl, 0x476630&gt;(dst, src)</p>
<h4>GetNameAndLOD</h4>
<p>plugin::Call<0x476650, char<em>, char</em>, unsigned int *>(nodeName, outName, outLodIndex);</p>
<p>0AA5: call_function 0x476650 num_params 3 pop 3 [nodeName] [outName] [outLodIndex]</p>
<p>define function GetNameAndLOD&lt;cdecl, 0x476650&gt;(nodeName, outName, outLodIndex)</p>
<h4>CFileLoader::FindRelatedModelInfoCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x4766C0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x4766C0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CFileLoader__FindRelatedModelInfoCB&lt;cdecl, 0x4766C0&gt;(atomic, data): int</p>
<h4>CFileLoader::LoadAtomicFile</h4>
<p>plugin::Call<0x476750, char const*>(filepath);</p>
<p>0AA5: call_function 0x476750 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__LoadAtomicFile&lt;cdecl, 0x476750&gt;(filepath)</p>
<h4>CFileLoader::LoadAtomicFile2Return</h4>
<p>plugin::CallAndReturn<RpClump<em>, 0x4767C0, char const</em>>(filepath);</p>
<p>0AA7: call_function_return 0x4767C0 num_params 1 pop 1 [filepath] func_ret [RpClump*]</p>
<p>define function CFileLoader__LoadAtomicFile2Return&lt;cdecl, 0x4767C0&gt;(filepath): int</p>
<h4>CFileLoader::LoadClumpFile</h4>
<p>plugin::Call<0x476810, char const*>(filepath);</p>
<p>0AA5: call_function 0x476810 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__LoadClumpFile&lt;cdecl, 0x476810&gt;(filepath)</p>
<h4>CFileLoader::SetRelatedModelInfoCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x4768C0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x4768C0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CFileLoader__SetRelatedModelInfoCB&lt;cdecl, 0x4768C0&gt;(atomic, data): int</p>
<h4>CFileLoader::LoadAtomicFile</h4>
<p>plugin::CallAndReturn<bool, 0x476930, RwStream*, unsigned int>(stream, modelIndex);</p>
<p>0AA7: call_function_return 0x476930 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__LoadAtomicFile&lt;cdecl, 0x476930&gt;(stream, modelIndex): int</p>
<h4>CFileLoader::LoadClumpFile</h4>
<p>plugin::CallAndReturn<bool, 0x476990, RwStream*, unsigned int>(stream, modelIndex);</p>
<p>0AA7: call_function_return 0x476990 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__LoadClumpFile&lt;cdecl, 0x476990&gt;(stream, modelIndex): int</p>
<h4>CFileLoader::StartLoadClumpFile</h4>
<p>plugin::CallAndReturn<bool, 0x476A20, RwStream*, unsigned int>(stream, modelIndex);</p>
<p>0AA7: call_function_return 0x476A20 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__StartLoadClumpFile&lt;cdecl, 0x476A20&gt;(stream, modelIndex): int</p>
<h4>CFileLoader::FinishLoadClumpFile</h4>
<p>plugin::CallAndReturn<bool, 0x476A70, RwStream*, unsigned int>(stream, modelIndex);</p>
<p>0AA7: call_function_return 0x476A70 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__FinishLoadClumpFile&lt;cdecl, 0x476A70&gt;(stream, modelIndex): int</p>
<h4>CFileLoader::LoadObjectTypes</h4>
<p>plugin::Call<0x476AC0, char const*>(filepath);</p>
<p>0AA5: call_function 0x476AC0 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__LoadObjectTypes&lt;cdecl, 0x476AC0&gt;(filepath)</p>
<h4>CFileLoader::ReloadPaths</h4>
<p>plugin::Call<0x476DB0, char const*>(filepath);</p>
<p>0AA5: call_function 0x476DB0 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__ReloadPaths&lt;cdecl, 0x476DB0&gt;(filepath)</p>
<h4>CFileLoader::ReloadObjectTypes</h4>
<p>plugin::Call<0x476F30, char const*>(filepath);</p>
<p>0AA5: call_function 0x476F30 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__ReloadObjectTypes&lt;cdecl, 0x476F30&gt;(filepath)</p>
<h4>CFileLoader::LoadObject</h4>
<p>plugin::Call<0x477040, char const*>(line);</p>
<p>0AA5: call_function 0x477040 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadObject&lt;cdecl, 0x477040&gt;(line)</p>
<h4>CFileLoader::ReloadObject</h4>
<p>plugin::Call<0x4772B0, char const*>(line);</p>
<p>0AA5: call_function 0x4772B0 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__ReloadObject&lt;cdecl, 0x4772B0&gt;(line)</p>
<h4>CFileLoader::LoadTimeObject</h4>
<p>plugin::Call<0x4774B0, char const*>(line);</p>
<p>0AA5: call_function 0x4774B0 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadTimeObject&lt;cdecl, 0x4774B0&gt;(line)</p>
<h4>CFileLoader::LoadMLO</h4>
<p>plugin::Call<0x477750, char const*>(line);</p>
<p>0AA5: call_function 0x477750 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadMLO&lt;cdecl, 0x477750&gt;(line)</p>
<h4>CFileLoader::LoadMLOInstance</h4>
<p>plugin::Call<0x4777C0, int, char const*>(modelIndex, line);</p>
<p>0AA5: call_function 0x4777C0 num_params 2 pop 2 [modelIndex] [line]</p>
<p>define function CFileLoader__LoadMLOInstance&lt;cdecl, 0x4777C0&gt;(modelIndex, line)</p>
<h4>CFileLoader::LoadClumpObject</h4>
<p>plugin::Call<0x477920, char const*>(line);</p>
<p>0AA5: call_function 0x477920 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadClumpObject&lt;cdecl, 0x477920&gt;(line)</p>
<h4>CFileLoader::LoadVehicleObject</h4>
<p>plugin::Call<0x477990, char const*>(line);</p>
<p>0AA5: call_function 0x477990 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadVehicleObject&lt;cdecl, 0x477990&gt;(line)</p>
<h4>CFileLoader::LoadPedObject</h4>
<p>plugin::Call<0x477DE0, char const*>(line);</p>
<p>0AA5: call_function 0x477DE0 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadPedObject&lt;cdecl, 0x477DE0&gt;(line)</p>
<h4>CFileLoader::LoadPathHeader</h4>
<p>plugin::CallAndReturn<int, 0x477ED0, char const<em>, char</em>>(line, outPathType);</p>
<p>0AA7: call_function_return 0x477ED0 num_params 2 pop 2 [line] [outPathType] func_ret [int]</p>
<p>define function CFileLoader__LoadPathHeader&lt;cdecl, 0x477ED0&gt;(line, outPathType): int</p>
<h4>CFileLoader::LoadPedPathNode</h4>
<p>plugin::Call<0x477F00, char const*, int, int>(line, id, index);</p>
<p>0AA5: call_function 0x477F00 num_params 3 pop 3 [line] [id] [index]</p>
<p>define function CFileLoader__LoadPedPathNode&lt;cdecl, 0x477F00&gt;(line, id, index)</p>
<h4>CFileLoader::LoadCarPathNode</h4>
<p>plugin::Call<0x477FF0, char const*, int, int>(line, id, index);</p>
<p>0AA5: call_function 0x477FF0 num_params 3 pop 3 [line] [id] [index]</p>
<p>define function CFileLoader__LoadCarPathNode&lt;cdecl, 0x477FF0&gt;(line, id, index)</p>
<h4>CFileLoader::Load2dEffect</h4>
<p>plugin::Call<0x4780E0, char const*>(line);</p>
<p>0AA5: call_function 0x4780E0 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__Load2dEffect&lt;cdecl, 0x4780E0&gt;(line)</p>
<h4>CFileLoader::LoadScene</h4>
<p>plugin::Call<0x478370, char const*>(filepath);</p>
<p>0AA5: call_function 0x478370 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__LoadScene&lt;cdecl, 0x478370&gt;(filepath)</p>
<h4>CFileLoader::LoadMapZones</h4>
<p>plugin::Call<0x478550, char const*>(filepath);</p>
<p>0AA5: call_function 0x478550 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__LoadMapZones&lt;cdecl, 0x478550&gt;(filepath)</p>
<h4>CFileLoader::LoadObjectInstance</h4>
<p>plugin::Call<0x4786B0, char const*>(line);</p>
<p>0AA5: call_function 0x4786B0 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadObjectInstance&lt;cdecl, 0x4786B0&gt;(line)</p>
<h4>CFileLoader::LoadPickup</h4>
<p>plugin::Call<0x4789C0, char const*>(line);</p>
<p>0AA5: call_function 0x4789C0 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadPickup&lt;cdecl, 0x4789C0&gt;(line)</p>
<h4>CFileLoader::LoadZone</h4>
<p>plugin::Call<0x478A00, char const*>(line);</p>
<p>0AA5: call_function 0x478A00 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadZone&lt;cdecl, 0x478A00&gt;(line)</p>
<h4>CFileLoader::LoadCullZone</h4>
<p>plugin::Call<0x478A90, char const*>(line);</p>
<p>0AA5: call_function 0x478A90 num_params 1 pop 1 [line]</p>
<p>define function CFileLoader__LoadCullZone&lt;cdecl, 0x478A90&gt;(line)</p>
<h4>CFileLoader::LoadCollisionFile</h4>
<p>plugin::Call<0x478B20, char*>(filepath);</p>
<p>0AA5: call_function 0x478B20 num_params 1 pop 1 [filepath]</p>
<p>define function CFileLoader__LoadCollisionFile&lt;cdecl, 0x478B20&gt;(filepath)</p>
<h4>CFileLoader::LoadCollisionModel</h4>
<p>plugin::Call<0x478C20, unsigned char<em>, CColModel&, char</em>>(buffer, outColModel, name);</p>
<p>0AA5: call_function 0x478C20 num_params 3 pop 3 [buffer] [outColModel] [name]</p>
<p>define function CFileLoader__LoadCollisionModel&lt;cdecl, 0x478C20&gt;(buffer, outColModel, name)</p><h3 id="plugin_iiigame_iiicfilemgrcpp">plugin_III\game_III\CFileMgr.cpp</h3><h4>CFileMgr::ChangeDir</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileMgr::ChangeDir), dir);</p>
<h4>CFileMgr::CloseFile</h4>
<p>plugin::CallAndReturnDynGlobal<int, FILESTREAM>(gaddrof(CFileMgr::CloseFile), fileHandle);</p>
<p>0AA7: call_function_return 0x479200 num_params 1 pop 1 [fileHandle] func_ret [int]</p>
<p>define function CFileMgr__CloseFile&lt;cdecl, 0x479200&gt;(fileHandle): int</p>
<h4>CFileMgr::GetErrorReadWrite</h4>
<p>plugin::CallAndReturnDynGlobal<int, FILESTREAM>(gaddrof(CFileMgr::GetErrorReadWrite), fileHandle);</p>
<p>0AA7: call_function_return 0x479210 num_params 1 pop 1 [fileHandle] func_ret [int]</p>
<p>define function CFileMgr__GetErrorReadWrite&lt;cdecl, 0x479210&gt;(fileHandle): int</p>
<h4>CFileMgr::LoadTextFile</h4>
<p>plugin::CallAndReturnDynGlobal<FILESTREAM, char const *, unsigned char *, int, char const *>(gaddrof(CFileMgr::LoadTextFile), filePath, buf, size, mode);</p>
<p>0AA7: call_function_return 0x479090 num_params 4 pop 4 [filePath] [buf] [size] [mode] func_ret [FILESTREAM]</p>
<p>define function CFileMgr__LoadTextFile&lt;cdecl, 0x479090&gt;(filePath, buf, size, mode): int</p>
<h4>CFileMgr::OpenFile</h4>
<p>plugin::CallAndReturnDynGlobal<FILESTREAM, char const *, char const *>(gaddrof(CFileMgr::OpenFile), filePath, mode);</p>
<p>0AA7: call_function_return 0x479100 num_params 2 pop 2 [filePath] [mode] func_ret [FILESTREAM]</p>
<p>define function CFileMgr__OpenFile&lt;cdecl, 0x479100&gt;(filePath, mode): int</p>
<h4>CFileMgr::OpenFileForWriting</h4>
<p>plugin::CallAndReturnDynGlobal<FILESTREAM, char const *>(gaddrof(CFileMgr::OpenFileForWriting), filePath);</p>
<p>0AA7: call_function_return 0x479120 num_params 1 pop 1 [filePath] func_ret [FILESTREAM]</p>
<p>define function CFileMgr__OpenFileForWriting&lt;cdecl, 0x479120&gt;(filePath): int</p>
<h4>CFileMgr::Read</h4>
<p>plugin::CallAndReturnDynGlobal<int, FILESTREAM, char *, int>(gaddrof(CFileMgr::Read), fileHandle, buf, size);</p>
<p>0AA7: call_function_return 0x479140 num_params 3 pop 3 [fileHandle] [buf] [size] func_ret [int]</p>
<p>define function CFileMgr__Read&lt;cdecl, 0x479140&gt;(fileHandle, buf, size): int</p>
<h4>CFileMgr::ReadLine</h4>
<p>plugin::CallAndReturnDynGlobal<bool, FILESTREAM, char *, int>(gaddrof(CFileMgr::ReadLine), fileHandle, buf, len);</p>
<p>0AA7: call_function_return 0x4791D0 num_params 3 pop 3 [fileHandle] [buf] [len] func_ret [bool]</p>
<p>define function CFileMgr__ReadLine&lt;cdecl, 0x4791D0&gt;(fileHandle, buf, len): int</p>
<h4>CFileMgr::Seek</h4>
<p>plugin::CallAndReturnDynGlobal<bool, FILESTREAM, int, int>(gaddrof(CFileMgr::Seek), fileHandle, offset, origin);</p>
<p>0AA7: call_function_return 0x479180 num_params 3 pop 3 [fileHandle] [offset] [origin] func_ret [bool]</p>
<p>define function CFileMgr__Seek&lt;cdecl, 0x479180&gt;(fileHandle, offset, origin): int</p>
<h4>CFileMgr::SetDir</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileMgr::SetDir), dir);</p>
<h4>CFileMgr::Write</h4>
<p>plugin::CallAndReturnDynGlobal<int, FILESTREAM, char *, int>(gaddrof(CFileMgr::Write), fileHandle, buf, size);</p>
<p>0AA7: call_function_return 0x479160 num_params 3 pop 3 [fileHandle] [buf] [size] func_ret [int]</p>
<p>define function CFileMgr__Write&lt;cdecl, 0x479160&gt;(fileHandle, buf, size): int</p><h3 id="plugin_iiigame_iiicfirecpp">plugin_III\game_III\CFire.cpp</h3><h4>CFire::Extinguish</h4>
<p>plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::Extinguish), this);</p>
<p>0AA6: call_method 0x479D40 struct [CFire] num_params 0 pop 0</p>
<p>define function CFire__Extinguish&lt;thiscall, 0x479D40&gt;()</p>
<h4>CFire::ProcessFire</h4>
<p>plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::ProcessFire), this);</p>
<p>0AA6: call_method 0x4798D0 struct [CFire] num_params 0 pop 0</p>
<p>define function CFire__ProcessFire&lt;thiscall, 0x4798D0&gt;()</p>
<h4>CFire::ReportThisFire</h4>
<p>plugin::CallMethodDynGlobal<CFire *>(gaddrof(CFire::ReportThisFire), this);</p>
<p>0AA6: call_method 0x4798B0 struct [CFire] num_params 0 pop 0</p>
<p>define function CFire__ReportThisFire&lt;thiscall, 0x4798B0&gt;()</p><h3 id="plugin_iiigame_iiicfiremanagercpp">plugin_III\game_III\CFireManager.cpp</h3><h4>CFireManager::ExtinguishPoint</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *, CVector, float>(gaddrof(CFireManager::ExtinguishPoint), this, point, range);</p>
<p>0AA6: call_method 0x479DB0 struct [CFireManager] num_params 2 pop 0 [point] [range]</p>
<p>define function CFireManager__ExtinguishPoint&lt;thiscall, 0x479DB0&gt;(point, range)</p>
<h4>*CFireManager::FindFurthestFire_NeverMindFireMen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *, CVector, float, float>(gaddrof(CFireManager::FindFurthestFire_NeverMindFireMen), this, pos, minRange, maxRange);</p>
<p>0AA8: call_method_return 0x479430 struct [*CFireManager] num_params 3 pop 0 [pos] [minRange] [maxRange] func_ret [CFire *]</p>
<h4>*CFireManager::FindNearestFire</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *, CVector, float *>(gaddrof(CFireManager::FindNearestFire), this, pos, pDistance);</p>
<p>0AA8: call_method_return 0x479340 struct [*CFireManager] num_params 2 pop 0 [pos] [pDistance] func_ret [CFire *]</p>
<h4>*CFireManager::GetNextFreeFire</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CFire *, CFireManager *>(gaddrof(CFireManager::GetNextFreeFire), this);</p>
<p>0AA8: call_method_return 0x4792E0 struct [*CFireManager] num_params 0 pop 0 func_ret [CFire *]</p>
<h4>CFireManager::IsScriptFireExtinguished</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CFireManager *, short>(gaddrof(CFireManager::IsScriptFireExtinguished), this, fireIndex);</p>
<p>0AA8: call_method_return 0x479FC0 struct [CFireManager] num_params 1 pop 0 [fireIndex] func_ret [bool]</p>
<h4>CFireManager::RemoveAllScriptFires</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(gaddrof(CFireManager::RemoveAllScriptFires), this);</p>
<p>0AA6: call_method 0x47A000 struct [CFireManager] num_params 0 pop 0</p>
<p>define function CFireManager__RemoveAllScriptFires&lt;thiscall, 0x47A000&gt;()</p>
<h4>CFireManager::RemoveScriptFire</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *, short>(gaddrof(CFireManager::RemoveScriptFire), this, fireIndex);</p>
<p>0AA6: call_method 0x479FE0 struct [CFireManager] num_params 1 pop 0 [fireIndex]</p>
<p>define function CFireManager__RemoveScriptFire&lt;thiscall, 0x479FE0&gt;(fireIndex)</p>
<h4>CFireManager::SetScriptFireAudio</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *, short, bool>(gaddrof(CFireManager::SetScriptFireAudio), this, fireIndex, state);</p>
<p>0AA6: call_method 0x47A040 struct [CFireManager] num_params 2 pop 0 [fireIndex] [state]</p>
<p>define function CFireManager__SetScriptFireAudio&lt;thiscall, 0x47A040&gt;(fireIndex, state)</p>
<h4>CFireManager::StartFire</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *, CVector, float, unsigned char>(gaddrof_o(CFireManager::StartFire, void (CFireManager::*)(CVector, float, unsigned char)), this, pos, strength, propagation);</p>
<p>0AA6: call_method 0x479590 struct [CFireManager] num_params 3 pop 0 [pos] [strength] [propagation]</p>
<p>define function CFireManager__StartFire&lt;thiscall, 0x479590&gt;(pos, strength, propagation)</p>
<h4>CFireManager::StartFire</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *, CEntity *, CEntity *, float, unsigned char>(gaddrof_o(CFireManager::StartFire, void (CFireManager::*)(CEntity *, CEntity *, float, unsigned char)), this, entityOnFire, fleeFrom, strength, propagation);</p>
<p>0AA6: call_method 0x479590 struct [CFireManager] num_params 4 pop 0 [entityOnFire] [fleeFrom] [strength] [propagation]</p>
<p>define function CFireManager__StartFire&lt;thiscall, 0x479590&gt;(entityOnFire, fleeFrom, strength, propagation)</p>
<h4>CFireManager::StartScriptFire</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CFireManager *, CVector const &, CEntity *, float, unsigned char>(gaddrof(CFireManager::StartScriptFire), this, pos, target, strength, propagation);</p>
<p>0AA8: call_method_return 0x479E60 struct [CFireManager] num_params 4 pop 0 [pos] [target] [strength] [propagation] func_ret [int]</p>
<h4>CFireManager::Update</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(gaddrof(CFireManager::Update), this);</p>
<p>0AA6: call_method 0x479310 struct [CFireManager] num_params 0 pop 0</p>
<p>define function CFireManager__Update&lt;thiscall, 0x479310&gt;()</p><h3 id="plugin_iiigame_iiicfontcpp">plugin_III\game_III\CFont.cpp</h3><h4>CFont::DrawFonts</h4>
<p>plugin::Call<0x501B50>();</p>
<p>0AA5: call_function 0x501B50 num_params 0 pop 0</p>
<p>define function CFont__DrawFonts&lt;cdecl, 0x501B50&gt;()</p>
<h4>CFont::GetNextSpace</h4>
<p>plugin::CallAndReturn<wchar_t<em>, 0x501960, const wchar_t</em>>(str);</p>
<p>0AA7: call_function_return 0x501960 num_params 1 pop 1 [str] func_ret [wchar_t*]</p>
<p>define function CFont__GetNextSpace&lt;cdecl, 0x501960&gt;(str): int</p>
<h4>CFont::GetNumberLines</h4>
<p>plugin::CallAndReturn<int, 0x501260, float, float, const wchar_t*>(x, y, text);</p>
<p>0AA7: call_function_return 0x501260 num_params 3 pop 3 [x] [y] [text] func_ret [int]</p>
<p>define function CFont__GetNumberLines&lt;cdecl, 0x501260&gt;(x, y, text): int</p>
<h4>CFont::GetStringWidth</h4>
<p>plugin::CallAndReturn<float, 0x5018A0, const wchar_t*, bool>(str, sentence);</p>
<p>0AA7: call_function_return 0x5018A0 num_params 2 pop 2 [str] [sentence] func_ret [float]</p>
<p>define function CFont__GetStringWidth&lt;cdecl, 0x5018A0&gt;(str, sentence): float</p>
<h4>CFont::GetTextRect</h4>
<p>plugin::CallAndReturn<CRect<em>, 0x5013B0, CRect</em>, float, float, const wchar_t*>(rect_out, x, y, text);</p>
<p>0AA7: call_function_return 0x5013B0 num_params 4 pop 4 [rect_out] [x] [y] [text] func_ret [CRect*]</p>
<p>define function CFont__GetTextRect&lt;cdecl, 0x5013B0&gt;(rect_out, x, y, text): int</p>
<h4>CFont::InitPerFrame</h4>
<p>plugin::Call<0x500BE0>();</p>
<p>0AA5: call_function 0x500BE0 num_params 0 pop 0</p>
<p>define function CFont__InitPerFrame&lt;cdecl, 0x500BE0&gt;()</p>
<h4>CFont::Initialise</h4>
<p>plugin::Call<0x500A40>();</p>
<p>0AA5: call_function 0x500A40 num_params 0 pop 0</p>
<p>define function CFont__Initialise&lt;cdecl, 0x500A40&gt;()</p>
<h4>CFont::ParseToken</h4>
<p>plugin::CallAndReturn<wchar_t<em>, 0x5019A0, wchar_t</em>>(str);</p>
<p>0AA7: call_function_return 0x5019A0 num_params 1 pop 1 [str] func_ret [wchar_t*]</p>
<p>define function CFont__ParseToken&lt;cdecl, 0x5019A0&gt;(str): int</p>
<h4>CFont::PrintChar</h4>
<p>plugin::Call<0x500C30, float, float, short>(x, y, character);</p>
<p>0AA5: call_function 0x500C30 num_params 3 pop 3 [x] [y] [character]</p>
<p>define function CFont__PrintChar&lt;cdecl, 0x500C30&gt;(x, y, character)</p>
<h4>CFont::PrintString</h4>
<p>plugin::Call<0x500F50, float, float, const wchar_t*>(x, y, text);</p>
<p>0AA5: call_function 0x500F50 num_params 3 pop 3 [x] [y] [text]</p>
<p>define function CFont__PrintString&lt;cdecl, 0x500F50&gt;(x, y, text)</p>
<h4>CFont::PrintString</h4>
<p>plugin::Call<0x501730, float, float, const wchar_t<em>, const wchar_t</em>, float>(x, y, start, end, arg4);</p>
<p>0AA5: call_function 0x501730 num_params 5 pop 5 [x] [y] [start] [end] [arg4]</p>
<p>define function CFont__PrintString&lt;cdecl, 0x501730&gt;(x, y, start, end, arg4)</p>
<h4>CFont::SetAlphaFade</h4>
<p>plugin::Call<0x501DD0, float>(alpha);</p>
<p>0AA5: call_function 0x501DD0 num_params 1 pop 1 [alpha]</p>
<p>define function CFont__SetAlphaFade&lt;cdecl, 0x501DD0&gt;(alpha)</p>
<h4>CFont::SetBackGroundOnlyTextOff</h4>
<p>plugin::Call<0x501D40>();</p>
<p>0AA5: call_function 0x501D40 num_params 0 pop 0</p>
<p>define function CFont__SetBackGroundOnlyTextOff&lt;cdecl, 0x501D40&gt;()</p>
<h4>CFont::SetBackGroundOnlyTextOn</h4>
<p>plugin::Call<0x501D30>();</p>
<p>0AA5: call_function 0x501D30 num_params 0 pop 0</p>
<p>define function CFont__SetBackGroundOnlyTextOn&lt;cdecl, 0x501D30&gt;()</p>
<h4>CFont::SetBackgroundColor</h4>
<p>plugin::Call<0x501D00, CRGBA*>(&amp;color);</p>
<p>0AA5: call_function 0x501D00 num_params 1 pop 1 [&amp;color]</p>
<p>define function CFont__SetBackgroundColor&lt;cdecl, 0x501D00&gt;(&amp;color)</p>
<h4>CFont::SetBackgroundOff</h4>
<p>plugin::Call<0x501CF0>();</p>
<p>0AA5: call_function 0x501CF0 num_params 0 pop 0</p>
<p>define function CFont__SetBackgroundOff&lt;cdecl, 0x501CF0&gt;()</p>
<h4>CFont::SetBackgroundOn</h4>
<p>plugin::Call<0x501CE0>();</p>
<p>0AA5: call_function 0x501CE0 num_params 0 pop 0</p>
<p>define function CFont__SetBackgroundOn&lt;cdecl, 0x501CE0&gt;()</p>
<h4>CFont::SetCentreOff</h4>
<p>plugin::Call<0x501CB0>();</p>
<p>0AA5: call_function 0x501CB0 num_params 0 pop 0</p>
<p>define function CFont__SetCentreOff&lt;cdecl, 0x501CB0&gt;()</p>
<h4>CFont::SetCentreOn</h4>
<p>plugin::Call<0x501C90>();</p>
<p>0AA5: call_function 0x501C90 num_params 0 pop 0</p>
<p>define function CFont__SetCentreOn&lt;cdecl, 0x501C90&gt;()</p>
<h4>CFont::SetCentreSize</h4>
<p>plugin::Call<0x501CD0, float>(size);</p>
<p>0AA5: call_function 0x501CD0 num_params 1 pop 1 [size]</p>
<p>define function CFont__SetCentreSize&lt;cdecl, 0x501CD0&gt;(size)</p>
<h4>CFont::SetColor</h4>
<p>plugin::Call<0x501BD0, CRGBA*>(&amp;color);</p>
<p>0AA5: call_function 0x501BD0 num_params 1 pop 1 [&amp;color]</p>
<p>define function CFont__SetColor&lt;cdecl, 0x501BD0&gt;(&amp;color)</p>
<h4>CFont::SetDropColor</h4>
<p>plugin::Call<0x501DE0, CRGBA*>(&amp;color);</p>
<p>0AA5: call_function 0x501DE0 num_params 1 pop 1 [&amp;color]</p>
<p>define function CFont__SetDropColor&lt;cdecl, 0x501DE0&gt;(&amp;color)</p>
<h4>CFont::SetDropShadowPosition</h4>
<p>plugin::Call<0x501E70, short>(value);</p>
<p>0AA5: call_function 0x501E70 num_params 1 pop 1 [value]</p>
<p>define function CFont__SetDropShadowPosition&lt;cdecl, 0x501E70&gt;(value)</p>
<h4>CFont::SetFontStyle</h4>
<p>plugin::Call<0x501DB0, short>(style);</p>
<p>0AA5: call_function 0x501DB0 num_params 1 pop 1 [style]</p>
<p>define function CFont__SetFontStyle&lt;cdecl, 0x501DB0&gt;(style)</p>
<h4>CFont::SetJustifyOff</h4>
<p>plugin::Call<0x501C80>();</p>
<p>0AA5: call_function 0x501C80 num_params 0 pop 0</p>
<p>define function CFont__SetJustifyOff&lt;cdecl, 0x501C80&gt;()</p>
<h4>CFont::SetJustifyOn</h4>
<p>plugin::Call<0x501C60>();</p>
<p>0AA5: call_function 0x501C60 num_params 0 pop 0</p>
<p>define function CFont__SetJustifyOn&lt;cdecl, 0x501C60&gt;()</p>
<h4>CFont::SetPropOff</h4>
<p>plugin::Call<0x501D90>();</p>
<p>0AA5: call_function 0x501D90 num_params 0 pop 0</p>
<p>define function CFont__SetPropOff&lt;cdecl, 0x501D90&gt;()</p>
<h4>CFont::SetPropOn</h4>
<p>plugin::Call<0x501DA0>();</p>
<p>0AA5: call_function 0x501DA0 num_params 0 pop 0</p>
<p>define function CFont__SetPropOn&lt;cdecl, 0x501DA0&gt;()</p>
<h4>CFont::SetRightJustifyOff</h4>
<p>plugin::Call<0x501D70>();</p>
<p>0AA5: call_function 0x501D70 num_params 0 pop 0</p>
<p>define function CFont__SetRightJustifyOff&lt;cdecl, 0x501D70&gt;()</p>
<h4>CFont::SetRightJustifyOn</h4>
<p>plugin::Call<0x501D50>();</p>
<p>0AA5: call_function 0x501D50 num_params 0 pop 0</p>
<p>define function CFont__SetRightJustifyOn&lt;cdecl, 0x501D50&gt;()</p>
<h4>CFont::SetRightJustifyWrap</h4>
<p>plugin::Call<0x501DC0, float>(value);</p>
<p>0AA5: call_function 0x501DC0 num_params 1 pop 1 [value]</p>
<p>define function CFont__SetRightJustifyWrap&lt;cdecl, 0x501DC0&gt;(value)</p>
<h4>CFont::SetScale</h4>
<p>plugin::Call<0x501B80, float, float>(width, height);</p>
<p>0AA5: call_function 0x501B80 num_params 2 pop 2 [width] [height]</p>
<p>define function CFont__SetScale&lt;cdecl, 0x501B80&gt;(width, height)</p>
<h4>CFont::SetSlant</h4>
<p>plugin::Call<0x501BC0, float>(value);</p>
<p>0AA5: call_function 0x501BC0 num_params 1 pop 1 [value]</p>
<p>define function CFont__SetSlant&lt;cdecl, 0x501BC0&gt;(value)</p>
<h4>CFont::SetSlantRefPoint</h4>
<p>plugin::Call<0x501BA0, float, float>(x, y);</p>
<p>0AA5: call_function 0x501BA0 num_params 2 pop 2 [x] [y]</p>
<p>define function CFont__SetSlantRefPoint&lt;cdecl, 0x501BA0&gt;(x, y)</p>
<h4>CFont::SetWrapx</h4>
<p>plugin::Call<0x501CC0, float>(value);</p>
<p>0AA5: call_function 0x501CC0 num_params 1 pop 1 [value]</p>
<p>define function CFont__SetWrapx&lt;cdecl, 0x501CC0&gt;(value)</p>
<h4>CFont::Shutdown</h4>
<p>plugin::Call<0x500BA0>();</p>
<p>0AA5: call_function 0x500BA0 num_params 0 pop 0</p>
<p>define function CFont__Shutdown&lt;cdecl, 0x500BA0&gt;()</p>
<h4>CFont::character_code</h4>
<p>plugin::CallAndReturn<short, 0x501E80, unsigned char>(character);</p>
<p>0AA7: call_function_return 0x501E80 num_params 1 pop 1 [character] func_ret [short]</p>
<p>define function CFont__character_code&lt;cdecl, 0x501E80&gt;(character): int</p>
<h4>AsciiToUnicode</h4>
<p>plugin::Call<0x5009C0, char const<em>, wchar_t</em>>(str_ascii, str_unicode);</p>
<p>0AA5: call_function 0x5009C0 num_params 2 pop 2 [str_ascii] [str_unicode]</p>
<p>define function AsciiToUnicode&lt;cdecl, 0x5009C0&gt;(str_ascii, str_unicode)</p>
<h4>UnicodeStrlen</h4>
<p>plugin::CallAndReturn<int, 0x500A20, wchar_t const*>(str);</p>
<p>0AA7: call_function_return 0x500A20 num_params 1 pop 1 [str] func_ret [int]</p>
<p>define function UnicodeStrlen&lt;cdecl, 0x500A20&gt;(str): int</p><h3 id="plugin_iiigame_iiicfontdetailscpp">plugin_III\game_III\CFontDetails.cpp</h3><h4>CFontDetails::~CFontDetails</h4>
<p>plugin::CallMethod<0x501F10, CFontDetails *>(this);</p>
<p>0AA6: call_method 0x501F10 struct [CFontDetails] num_params 0 pop 0</p>
<p>define function CFontDetails__~CFontDetails&lt;thiscall, 0x501F10&gt;()</p><h3 id="plugin_iiigame_iiicgamecpp">plugin_III\game_III\CGame.cpp</h3><h4>CGame::DrasticTidyUpMemory</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CGame::DrasticTidyUpMemory), flushDraw);</p>
<h4>CGame::Initialise</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);</p>
<p>0AA7: call_function_return 0x48BED0 num_params 1 pop 1 [datFile] func_ret [bool]</p>
<p>define function CGame__Initialise&lt;cdecl, 0x48BED0&gt;(datFile): int</p>
<h4>CGame::InitialiseOnceAfterRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceAfterRW));</p>
<p>0AA7: call_function_return 0x48BD50 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseOnceAfterRW&lt;cdecl, 0x48BD50&gt;(): int</p>
<h4>CGame::InitialiseOnceBeforeRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));</p>
<p>0AA7: call_function_return 0x48BB80 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseOnceBeforeRW&lt;cdecl, 0x48BB80&gt;(): int</p>
<h4>CGame::InitialiseRenderWare</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));</p>
<p>0AA7: call_function_return 0x48BBA0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseRenderWare&lt;cdecl, 0x48BBA0&gt;(): int</p>
<h4>CGame::Shutdown</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));</p>
<p>0AA7: call_function_return 0x48C3A0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__Shutdown&lt;cdecl, 0x48C3A0&gt;(): int</p>
<h4>CGame::TidyUpMemory</h4>
<p>plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), moveTextures, flushDraw);</p><h3 id="plugin_iiigame_iiicgamelogiccpp">plugin_III\game_III\CGameLogic.cpp</h3><h4>CGameLogic::PassTime</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CGameLogic::PassTime), time);</p>
<h4>CGameLogic::RestorePlayerStuffDuringResurrection</h4>
<p>plugin::CallDynGlobal<CPlayerPed *, CVector, float>(gaddrof(CGameLogic::RestorePlayerStuffDuringResurrection), player, pos, angle);</p>
<h4>CGameLogic::SortOutStreamingAndMemory</h4>
<p>plugin::CallDynGlobal<CVector const &>(gaddrof(CGameLogic::SortOutStreamingAndMemory), pos);</p><h3 id="plugin_iiigame_iiicgangscpp">plugin_III\game_III\CGangs.cpp</h3><h4>CGangs::GetGangPedModelOverride</h4>
<p>plugin::CallAndReturnDynGlobal<char, short>(gaddrof(CGangs::GetGangPedModelOverride), gang);</p>
<p>0AA7: call_function_return 0x4C4070 num_params 1 pop 1 [gang] func_ret [char]</p>
<p>define function CGangs__GetGangPedModelOverride&lt;cdecl, 0x4C4070&gt;(gang): int</p>
<h4>CGangs::LoadAllGangData</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CGangs::LoadAllGangData), buf, size);</p>
<h4>CGangs::SaveAllGangData</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CGangs::SaveAllGangData), buf, size);</p>
<h4>CGangs::SetGangPedModelOverride</h4>
<p>plugin::CallDynGlobal<short, char>(gaddrof(CGangs::SetGangPedModelOverride), gang, ovrd);</p>
<h4>CGangs::SetGangVehicleModel</h4>
<p>plugin::CallDynGlobal<short, int>(gaddrof(CGangs::SetGangVehicleModel), gang, model);</p>
<h4>CGangs::SetGangWeapons</h4>
<p>plugin::CallDynGlobal<short, int, int>(gaddrof(CGangs::SetGangWeapons), gang, weaponOne, weaponTwo);</p><h3 id="plugin_iiigame_iiicgaragecpp">plugin_III\game_III\CGarage.cpp</h3><h4>CGarage::BuildRotatedDoorMatrix</h4>
<p>plugin::CallMethod<0x4267C0, CGarage <em>, CEntity</em>, float>(this, door, angle);</p>
<p>0AA6: call_method 0x4267C0 struct [CGarage] num_params 2 pop 0 [door] [angle]</p>
<p>define function CGarage__BuildRotatedDoorMatrix&lt;thiscall, 0x4267C0&gt;(door, angle)</p>
<h4>CGarage::CalcDistToGarageRectangleSquared</h4>
<p>plugin::CallMethodAndReturn<float, 0x426F50, CGarage *, float, float>(this, x, y);</p>
<p>0AA8: call_method_return 0x426F50 struct [CGarage] num_params 2 pop 0 [x] [y] func_ret [float]</p>
<p>define function CGarage__CalcDistToGarageRectangleSquared&lt;thiscall, 0x426F50&gt;(x, y): float</p>
<h4>CGarage::CalcSmallestDistToGarageDoorSquared</h4>
<p>plugin::CallMethodAndReturn<float, 0x426FE0, CGarage *, float, float>(this, x, y);</p>
<p>0AA8: call_method_return 0x426FE0 struct [CGarage] num_params 2 pop 0 [x] [y] func_ret [float]</p>
<p>define function CGarage__CalcSmallestDistToGarageDoorSquared&lt;thiscall, 0x426FE0&gt;(x, y): float</p>
<h4>CGarage::CenterCarInGarage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x428000, CGarage <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA8: call_method_return 0x428000 struct [CGarage] num_params 1 pop 0 [vehicle] func_ret [bool]</p>
<p>define function CGarage__CenterCarInGarage&lt;thiscall, 0x428000&gt;(vehicle): int</p>
<h4>CGarage::CountCarsWithCenterPointWithinGarage</h4>
<p>plugin::CallMethodAndReturn<int, 0x426130, CGarage <em>, CEntity</em>>(this, vehicle);</p>
<p>0AA8: call_method_return 0x426130 struct [CGarage] num_params 1 pop 0 [vehicle] func_ret [int]</p>
<p>define function CGarage__CountCarsWithCenterPointWithinGarage&lt;thiscall, 0x426130&gt;(vehicle): int</p>
<h4>CGarage::DoesCraigNeedThisCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x426D90, CGarage *, int>(this, modelIndex);</p>
<p>0AA8: call_method_return 0x426D90 struct [CGarage] num_params 1 pop 0 [modelIndex] func_ret [bool]</p>
<p>define function CGarage__DoesCraigNeedThisCar&lt;thiscall, 0x426D90&gt;(modelIndex): int</p>
<h4>CGarage::EntityHasASphereWayOutsideGarage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425B30, CGarage <em>, CEntity</em>, float>(this, entity, radius);</p>
<p>0AA8: call_method_return 0x425B30 struct [CGarage] num_params 2 pop 0 [entity] [radius] func_ret [bool]</p>
<p>define function CGarage__EntityHasASphereWayOutsideGarage&lt;thiscall, 0x425B30&gt;(entity, radius): int</p>
<h4>CGarage::FindDoorsEntities</h4>
<p>plugin::CallMethod<0x427060, CGarage *>(this);</p>
<p>0AA6: call_method 0x427060 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__FindDoorsEntities&lt;thiscall, 0x427060&gt;()</p>
<h4>CGarage::FindDoorsEntitiesSectorList</h4>
<p>plugin::CallMethodAndReturn<char, 0x427300, CGarage *, CPtrList&, bool>(this, list, arg1);</p>
<p>0AA8: call_method_return 0x427300 struct [CGarage] num_params 2 pop 0 [list] [arg1] func_ret [char]</p>
<p>define function CGarage__FindDoorsEntitiesSectorList&lt;thiscall, 0x427300&gt;(list, arg1): int</p>
<h4>CGarage::HasCraigCollectedThisCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x426DF0, CGarage *, int>(this, modelIndex);</p>
<p>0AA8: call_method_return 0x426DF0 struct [CGarage] num_params 1 pop 0 [modelIndex] func_ret [bool]</p>
<p>define function CGarage__HasCraigCollectedThisCar&lt;thiscall, 0x426DF0&gt;(modelIndex): int</p>
<h4>CGarage::IsAnyCarBlockingDoor</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425FB0, CGarage *>(this);</p>
<p>0AA8: call_method_return 0x425FB0 struct [CGarage] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGarage__IsAnyCarBlockingDoor&lt;thiscall, 0x425FB0&gt;(): int</p>
<h4>CGarage::IsAnyOtherCarTouchingGarage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425C90, CGarage <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA8: call_method_return 0x425C90 struct [CGarage] num_params 1 pop 0 [vehicle] func_ret [bool]</p>
<p>define function CGarage__IsAnyOtherCarTouchingGarage&lt;thiscall, 0x425C90&gt;(vehicle): int</p>
<h4>CGarage::IsAnyOtherPedTouchingGarage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425E20, CGarage <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x425E20 struct [CGarage] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CGarage__IsAnyOtherPedTouchingGarage&lt;thiscall, 0x425E20&gt;(ped): int</p>
<h4>CGarage::IsEntityEntirelyInside</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425370, CGarage <em>, CEntity</em>>(this, entity);</p>
<p>0AA8: call_method_return 0x425370 struct [CGarage] num_params 1 pop 0 [entity] func_ret [bool]</p>
<p>define function CGarage__IsEntityEntirelyInside&lt;thiscall, 0x425370&gt;(entity): int</p>
<h4>CGarage::IsEntityEntirelyInside3D</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4254F0, CGarage <em>, CEntity</em>, float>(this, entity, radius);</p>
<p>0AA8: call_method_return 0x4254F0 struct [CGarage] num_params 2 pop 0 [entity] [radius] func_ret [bool]</p>
<p>define function CGarage__IsEntityEntirelyInside3D&lt;thiscall, 0x4254F0&gt;(entity, radius): int</p>
<h4>CGarage::IsEntityEntirelyOutside</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425740, CGarage <em>, CEntity</em>, float>(this, entity, radius);</p>
<p>0AA8: call_method_return 0x425740 struct [CGarage] num_params 2 pop 0 [entity] [radius] func_ret [bool]</p>
<p>define function CGarage__IsEntityEntirelyOutside&lt;thiscall, 0x425740&gt;(entity, radius): int</p>
<h4>CGarage::IsEntityTouching3D</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425950, CGarage <em>, CEntity</em>>(this, entity);</p>
<p>0AA8: call_method_return 0x425950 struct [CGarage] num_params 1 pop 0 [entity] func_ret [bool]</p>
<p>define function CGarage__IsEntityTouching3D&lt;thiscall, 0x425950&gt;(entity): int</p>
<h4>CGarage::IsGarageEmpty</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425890, CGarage *>(this);</p>
<p>0AA8: call_method_return 0x425890 struct [CGarage] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGarage__IsGarageEmpty&lt;thiscall, 0x425890&gt;(): int</p>
<h4>CGarage::IsPlayerOutsideGarage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x425910, CGarage *>(this);</p>
<p>0AA8: call_method_return 0x425910 struct [CGarage] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGarage__IsPlayerOutsideGarage&lt;thiscall, 0x425910&gt;(): int</p>
<h4>CGarage::IsStaticPlayerCarEntirelyInside</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4251C0, CGarage *>(this);</p>
<p>0AA8: call_method_return 0x4251C0 struct [CGarage] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGarage__IsStaticPlayerCarEntirelyInside&lt;thiscall, 0x4251C0&gt;(): int</p>
<h4>CGarage::Load</h4>
<p>plugin::CallMethod<0x4288E0, CGarage <em>, unsigned char</em>, unsigned int>(this, bufferPointer, structSize);</p>
<p>0AA6: call_method 0x4288E0 struct [CGarage] num_params 2 pop 0 [bufferPointer] [structSize]</p>
<p>define function CGarage__Load&lt;thiscall, 0x4288E0&gt;(bufferPointer, structSize)</p>
<h4>CGarage::MarkThisCarAsCollectedForCraig</h4>
<p>plugin::CallMethodAndReturn<bool, 0x426E50, CGarage *, int>(this, modelIndex);</p>
<p>0AA8: call_method_return 0x426E50 struct [CGarage] num_params 1 pop 0 [modelIndex] func_ret [bool]</p>
<p>define function CGarage__MarkThisCarAsCollectedForCraig&lt;thiscall, 0x426E50&gt;(modelIndex): int</p>
<h4>CGarage::PlayerArrestedOrDied</h4>
<p>plugin::CallMethod<0x427FC0, CGarage *>(this);</p>
<p>0AA6: call_method 0x427FC0 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__PlayerArrestedOrDied&lt;thiscall, 0x427FC0&gt;()</p>
<h4>CGarage::RefreshDoorPointers</h4>
<p>plugin::CallMethod<0x426980, CGarage *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x426980 struct [CGarage] num_params 1 pop 0 [arg0]</p>
<p>define function CGarage__RefreshDoorPointers&lt;thiscall, 0x426980&gt;(arg0)</p>
<h4>CGarage::RemoveCarsBlockingDoorNotInside</h4>
<p>plugin::CallMethod<0x4261F0, CGarage *>(this);</p>
<p>0AA6: call_method 0x4261F0 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__RemoveCarsBlockingDoorNotInside&lt;thiscall, 0x4261F0&gt;()</p>
<h4>CGarage::RestoreCarsForThisHideOut</h4>
<p>plugin::CallMethodAndReturn<bool, 0x427A40, CGarage <em>, CStoredCar</em>>(this, car);</p>
<p>0AA8: call_method_return 0x427A40 struct [CGarage] num_params 1 pop 0 [car] func_ret [bool]</p>
<p>define function CGarage__RestoreCarsForThisHideOut&lt;thiscall, 0x427A40&gt;(car): int</p>
<h4>CGarage::StoreAndRemoveCarsForThisHideOut</h4>
<p>plugin::CallMethod<0x427840, CGarage <em>, CStoredCar</em>, int>(this, car, count);</p>
<p>0AA6: call_method 0x427840 struct [CGarage] num_params 2 pop 0 [car] [count]</p>
<p>define function CGarage__StoreAndRemoveCarsForThisHideOut&lt;thiscall, 0x427840&gt;(car, count)</p>
<h4>CGarage::TidyUpGarage</h4>
<p>plugin::CallMethod<0x427C30, CGarage *>(this);</p>
<p>0AA6: call_method 0x427C30 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__TidyUpGarage&lt;thiscall, 0x427C30&gt;()</p>
<h4>CGarage::TidyUpGarageClose</h4>
<p>plugin::CallMethod<0x427D90, CGarage *>(this);</p>
<p>0AA6: call_method 0x427D90 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__TidyUpGarageClose&lt;thiscall, 0x427D90&gt;()</p>
<h4>CGarage::Update</h4>
<p>plugin::CallMethod<0x4222D0, CGarage *>(this);</p>
<p>0AA6: call_method 0x4222D0 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__Update&lt;thiscall, 0x4222D0&gt;()</p>
<h4>CGarage::UpdateCrusherAngle</h4>
<p>plugin::CallMethod<0x4268A0, CGarage *>(this);</p>
<p>0AA6: call_method 0x4268A0 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__UpdateCrusherAngle&lt;thiscall, 0x4268A0&gt;()</p>
<h4>CGarage::UpdateCrusherShake</h4>
<p>plugin::CallMethod<0x4268E0, CGarage *, float, float>(this, x, y);</p>
<p>0AA6: call_method 0x4268E0 struct [CGarage] num_params 2 pop 0 [x] [y]</p>
<p>define function CGarage__UpdateCrusherShake&lt;thiscall, 0x4268E0&gt;(x, y)</p>
<h4>CGarage::UpdateDoorsHeight</h4>
<p>plugin::CallMethod<0x426730, CGarage *>(this);</p>
<p>0AA6: call_method 0x426730 struct [CGarage] num_params 0 pop 0</p>
<p>define function CGarage__UpdateDoorsHeight&lt;thiscall, 0x426730&gt;()</p><h3 id="plugin_iiigame_iiicgaragescpp">plugin_III\game_III\CGarages.cpp</h3><h4>CGarages::ActivateGarage</h4>
<p>plugin::Call<0x426C60, short>(index);</p>
<p>0AA5: call_function 0x426C60 num_params 1 pop 1 [index]</p>
<p>define function CGarages__ActivateGarage&lt;cdecl, 0x426C60&gt;(index)</p>
<h4>CGarages::AddOne</h4>
<p>plugin::CallAndReturn<int, 0x421FA0, CVector, CVector, unsigned char, unsigned int>(pointFront, pointBack, type, vehicleModelIndex);</p>
<p>0AA7: call_function_return 0x421FA0 num_params 4 pop 4 [pointFront] [pointBack] [type] [vehicleModelIndex] func_ret [int]</p>
<p>define function CGarages__AddOne&lt;cdecl, 0x421FA0&gt;(pointFront, pointBack, type, vehicleModelIndex): int</p>
<h4>CGarages::CameraShouldBeOutside</h4>
<p>plugin::CallAndReturn<bool, 0x427BC0>();</p>
<p>0AA7: call_function_return 0x427BC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGarages__CameraShouldBeOutside&lt;cdecl, 0x427BC0&gt;(): int</p>
<h4>CGarages::ChangeGarageType</h4>
<p>plugin::Call<0x4222A0, short, unsigned char, unsigned int>(index, type, vehicleModelIndex);</p>
<p>0AA5: call_function 0x4222A0 num_params 3 pop 3 [index] [type] [vehicleModelIndex]</p>
<p>define function CGarages__ChangeGarageType&lt;cdecl, 0x4222A0&gt;(index, type, vehicleModelIndex)</p>
<h4>CGarages::CloseHideOutGaragesBeforeSave</h4>
<p>plugin::Call<0x428130>();</p>
<p>0AA5: call_function 0x428130 num_params 0 pop 0</p>
<p>define function CGarages__CloseHideOutGaragesBeforeSave&lt;cdecl, 0x428130&gt;()</p>
<h4>CGarages::CountCarsInHideoutGarage</h4>
<p>plugin::CallAndReturn<int, 0x4281E0, unsigned char>(type);</p>
<p>0AA7: call_function_return 0x4281E0 num_params 1 pop 1 [type] func_ret [int]</p>
<p>define function CGarages__CountCarsInHideoutGarage&lt;cdecl, 0x4281E0&gt;(type): int</p>
<h4>CGarages::DeActivateGarage</h4>
<p>plugin::Call<0x426C40, short>(index);</p>
<p>0AA5: call_function 0x426C40 num_params 1 pop 1 [index]</p>
<p>define function CGarages__DeActivateGarage&lt;cdecl, 0x426C40&gt;(index)</p>
<h4>CGarages::FindDoorHeightForMI</h4>
<p>plugin::CallAndReturn<float, 0x427C10, unsigned int>(vehicleModelIndex);</p>
<p>0AA7: call_function_return 0x427C10 num_params 1 pop 1 [vehicleModelIndex] func_ret [float]</p>
<p>define function CGarages__FindDoorHeightForMI&lt;cdecl, 0x427C10&gt;(vehicleModelIndex): float</p>
<h4>CGarages::FindMaxNumStoredCarsForGarage</h4>
<p>plugin::CallAndReturn<int, 0x428230, unsigned char>(type);</p>
<p>0AA7: call_function_return 0x428230 num_params 1 pop 1 [type] func_ret [int]</p>
<p>define function CGarages__FindMaxNumStoredCarsForGarage&lt;cdecl, 0x428230&gt;(type): int</p>
<h4>CGarages::GivePlayerDetonator</h4>
<p>plugin::Call<0x427BD0>();</p>
<p>0AA5: call_function 0x427BD0 num_params 0 pop 0</p>
<p>define function CGarages__GivePlayerDetonator&lt;cdecl, 0x427BD0&gt;()</p>
<h4>CGarages::HasCarBeenCrushed</h4>
<p>plugin::CallAndReturn<bool, 0x4275A0, int>(vehicleModelIndex);</p>
<p>0AA7: call_function_return 0x4275A0 num_params 1 pop 1 [vehicleModelIndex] func_ret [bool]</p>
<p>define function CGarages__HasCarBeenCrushed&lt;cdecl, 0x4275A0&gt;(vehicleModelIndex): int</p>
<h4>CGarages::HasCarBeenDroppedOffYet</h4>
<p>plugin::CallAndReturn<bool, 0x426C20, short>(index);</p>
<p>0AA7: call_function_return 0x426C20 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CGarages__HasCarBeenDroppedOffYet&lt;cdecl, 0x426C20&gt;(index): int</p>
<h4>CGarages::HasImportExportGarageCollectedThisCar</h4>
<p>plugin::CallAndReturn<bool, 0x426CB0, short, int>(index, vehicleModelIndex);</p>
<p>0AA7: call_function_return 0x426CB0 num_params 2 pop 2 [index] [vehicleModelIndex] func_ret [bool]</p>
<p>define function CGarages__HasImportExportGarageCollectedThisCar&lt;cdecl, 0x426CB0&gt;(index, vehicleModelIndex): int</p>
<h4>CGarages::HasResprayHappened</h4>
<p>plugin::CallAndReturn<bool, 0x4274F0, short>(index);</p>
<p>0AA7: call_function_return 0x4274F0 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CGarages__HasResprayHappened&lt;cdecl, 0x4274F0&gt;(index): int</p>
<h4>CGarages::HasThisCarBeenCollected</h4>
<p>plugin::CallAndReturn<bool, 0x426D50, short, int>(index, vehicleModelIndex);</p>
<p>0AA7: call_function_return 0x426D50 num_params 2 pop 2 [index] [vehicleModelIndex] func_ret [bool]</p>
<p>define function CGarages__HasThisCarBeenCollected&lt;cdecl, 0x426D50&gt;(index, vehicleModelIndex): int</p>
<h4>CGarages::Init</h4>
<p>plugin::Call<0x421C60>();</p>
<p>0AA5: call_function 0x421C60 num_params 0 pop 0</p>
<p>define function CGarages__Init&lt;cdecl, 0x421C60&gt;()</p>
<h4>CGarages::IsCarSprayable</h4>
<p>plugin::CallAndReturn<bool, 0x426700, CAutomobile*>(car);</p>
<p>0AA7: call_function_return 0x426700 num_params 1 pop 1 [car] func_ret [bool]</p>
<p>define function CGarages__IsCarSprayable&lt;cdecl, 0x426700&gt;(car): int</p>
<h4>CGarages::IsGarageClosed</h4>
<p>plugin::CallAndReturn<bool, 0x426D20, short>(index);</p>
<p>0AA7: call_function_return 0x426D20 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CGarages__IsGarageClosed&lt;cdecl, 0x426D20&gt;(index): int</p>
<h4>CGarages::IsGarageOpen</h4>
<p>plugin::CallAndReturn<bool, 0x426CF0, short>(index);</p>
<p>0AA7: call_function_return 0x426CF0 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CGarages__IsGarageOpen&lt;cdecl, 0x426CF0&gt;(index): int</p>
<h4>CGarages::IsModelIndexADoor</h4>
<p>plugin::CallAndReturn<bool, 0x428D90, unsigned int>(modelIndexDoor);</p>
<p>0AA7: call_function_return 0x428D90 num_params 1 pop 1 [modelIndexDoor] func_ret [bool]</p>
<p>define function CGarages__IsModelIndexADoor&lt;cdecl, 0x428D90&gt;(modelIndexDoor): int</p>
<h4>CGarages::IsPointInAGarageCameraZone</h4>
<p>plugin::CallAndReturn<bool, 0x427AB0, CVector>(point);</p>
<p>0AA7: call_function_return 0x427AB0 num_params 1 pop 1 [point] func_ret [bool]</p>
<p>define function CGarages__IsPointInAGarageCameraZone&lt;cdecl, 0x427AB0&gt;(point): int</p>
<h4>CGarages::IsPointWithinAnyGarage</h4>
<p>plugin::CallAndReturn<bool, 0x428320, CVector&>(point);</p>
<p>0AA7: call_function_return 0x428320 num_params 1 pop 1 [point] func_ret [bool]</p>
<p>define function CGarages__IsPointWithinAnyGarage&lt;cdecl, 0x428320&gt;(point): int</p>
<h4>CGarages::IsPointWithinHideOutGarage</h4>
<p>plugin::CallAndReturn<bool, 0x428260, CVector&>(point);</p>
<p>0AA7: call_function_return 0x428260 num_params 1 pop 1 [point] func_ret [bool]</p>
<p>define function CGarages__IsPointWithinHideOutGarage&lt;cdecl, 0x428260&gt;(point): int</p>
<h4>CGarages::IsThisCarWithinGarageArea</h4>
<p>plugin::CallAndReturn<bool, 0x427570, short, CEntity*>(index, entity);</p>
<p>0AA7: call_function_return 0x427570 num_params 2 pop 2 [index] [entity] func_ret [bool]</p>
<p>define function CGarages__IsThisCarWithinGarageArea&lt;cdecl, 0x427570&gt;(index, entity): int</p>
<h4>CGarages::Load</h4>
<p>plugin::Call<0x428940, unsigned char*, unsigned int>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x428940 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CGarages__Load&lt;cdecl, 0x428940&gt;(bufferPointer, structSize)</p>
<h4>CGarages::PlayerArrestedOrDied</h4>
<p>plugin::Call<0x427F60>();</p>
<p>0AA5: call_function 0x427F60 num_params 0 pop 0</p>
<p>define function CGarages__PlayerArrestedOrDied&lt;cdecl, 0x427F60&gt;()</p>
<h4>CGarages::PrintMessages</h4>
<p>plugin::Call<0x426310>();</p>
<p>0AA5: call_function 0x426310 num_params 0 pop 0</p>
<p>define function CGarages__PrintMessages&lt;cdecl, 0x426310&gt;()</p>
<h4>CGarages::QueryCarsCollected</h4>
<p>plugin::CallAndReturn<int, 0x426CA0, short>(index);</p>
<p>0AA7: call_function_return 0x426CA0 num_params 1 pop 1 [index] func_ret [int]</p>
<p>define function CGarages__QueryCarsCollected&lt;cdecl, 0x426CA0&gt;(index): int</p>
<h4>CGarages::Save</h4>
<p>plugin::Call<0x4284E0, unsigned char<em>, unsigned int</em>>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4284E0 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CGarages__Save&lt;cdecl, 0x4284E0&gt;(bufferPointer, structSize)</p>
<h4>CGarages::SetAllDoorsBackToOriginalHeight</h4>
<p>plugin::Call<0x4283D0>();</p>
<p>0AA5: call_function 0x4283D0 num_params 0 pop 0</p>
<p>define function CGarages__SetAllDoorsBackToOriginalHeight&lt;cdecl, 0x4283D0&gt;()</p>
<h4>CGarages::SetGarageDoorToRotate</h4>
<p>plugin::Call<0x427510, short>(index);</p>
<p>0AA5: call_function 0x427510 num_params 1 pop 1 [index]</p>
<p>define function CGarages__SetGarageDoorToRotate&lt;cdecl, 0x427510&gt;(index)</p>
<h4>CGarages::SetLeaveCameraForThisGarage</h4>
<p>plugin::Call<0x427550, short>(index);</p>
<p>0AA5: call_function 0x427550 num_params 1 pop 1 [index]</p>
<p>define function CGarages__SetLeaveCameraForThisGarage&lt;cdecl, 0x427550&gt;(index)</p>
<h4>CGarages::SetTargetCarForMissionGarage</h4>
<p>plugin::Call<0x426BD0, short, CAutomobile*>(index, car);</p>
<p>0AA5: call_function 0x426BD0 num_params 2 pop 2 [index] [car]</p>
<p>define function CGarages__SetTargetCarForMissionGarage&lt;cdecl, 0x426BD0&gt;(index, car)</p>
<h4>CGarages::Shutdown</h4>
<p>plugin::Call<0x421E10>();</p>
<p>0AA5: call_function 0x421E10 num_params 0 pop 0</p>
<p>define function CGarages__Shutdown&lt;cdecl, 0x421E10&gt;()</p>
<h4>CGarages::TriggerMessage</h4>
<p>plugin::Call<0x426B20, char*, short, unsigned short, short>(text, numberInString, time, numberInString2);</p>
<p>0AA5: call_function 0x426B20 num_params 4 pop 4 [text] [numberInString] [time] [numberInString2]</p>
<p>define function CGarages__TriggerMessage&lt;cdecl, 0x426B20&gt;(text, numberInString, time, numberInString2)</p>
<h4>CGarages::Update</h4>
<p>plugin::Call<0x421E40>();</p>
<p>0AA5: call_function 0x421E40 num_params 0 pop 0</p>
<p>define function CGarages__Update&lt;cdecl, 0x421E40&gt;()</p><h3 id="plugin_iiigame_iiicgeneralcpp">plugin_III\game_III\CGeneral.cpp</h3><h4>CGeneral::GetATanOfXY</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float>(gaddrof(CGeneral::GetATanOfXY), x, y);</p>
<p>0AA7: call_function_return 0x48CC30 num_params 2 pop 2 [x] [y] func_ret [float]</p>
<p>define function CGeneral__GetATanOfXY&lt;cdecl, 0x48CC30&gt;(x, y): float</p>
<h4>CGeneral::GetAngleBetweenPoints</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetAngleBetweenPoints), x1, y1, x2, y2);</p>
<p>0AA7: call_function_return 0x48CA30 num_params 4 pop 4 [x1] [y1] [x2] [y2] func_ret [float]</p>
<p>define function CGeneral__GetAngleBetweenPoints&lt;cdecl, 0x48CA30&gt;(x1, y1, x2, y2): float</p>
<h4>CGeneral::GetNodeHeadingFromVector</h4>
<p>plugin::CallAndReturnDynGlobal<int, float, float>(gaddrof(CGeneral::GetNodeHeadingFromVector), x, y);</p>
<p>0AA7: call_function_return 0x48CE40 num_params 2 pop 2 [x] [y] func_ret [int]</p>
<p>define function CGeneral__GetNodeHeadingFromVector&lt;cdecl, 0x48CE40&gt;(x, y): int</p>
<h4>CGeneral::GetRadianAngleBetweenPoints</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetRadianAngleBetweenPoints), x1, y1, x2, y2);</p>
<p>0AA7: call_function_return 0x48CA50 num_params 4 pop 4 [x1] [y1] [x2] [y2] func_ret [float]</p>
<p>define function CGeneral__GetRadianAngleBetweenPoints&lt;cdecl, 0x48CA50&gt;(x1, y1, x2, y2): float</p>
<h4>CGeneral::LimitAngle</h4>
<p>plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitAngle), angle);</p>
<p>0AA7: call_function_return 0x48CB40 num_params 1 pop 1 [angle] func_ret [float]</p>
<p>define function CGeneral__LimitAngle&lt;cdecl, 0x48CB40&gt;(angle): float</p>
<h4>CGeneral::LimitRadianAngle</h4>
<p>plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitRadianAngle), angle);</p>
<p>0AA7: call_function_return 0x48CB90 num_params 1 pop 1 [angle] func_ret [float]</p>
<p>define function CGeneral__LimitRadianAngle&lt;cdecl, 0x48CB90&gt;(angle): float</p><h3 id="plugin_iiigame_iiicglasscpp">plugin_III\game_III\CGlass.cpp</h3><h4>CGlass::AskForObjectToBeRenderedInGlass</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CGlass::AskForObjectToBeRenderedInGlass), entity);</p>
<h4>CGlass::CalcAlphaWithNormal</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector *>(gaddrof(CGlass::CalcAlphaWithNormal), normal);</p>
<p>0AA7: call_function_return 0x503C90 num_params 1 pop 1 [normal] func_ret [int]</p>
<p>define function CGlass__CalcAlphaWithNormal&lt;cdecl, 0x503C90&gt;(normal): int</p>
<h4>*CGlass::FindFreePane</h4>
<p>plugin::CallAndReturnDynGlobal<CFallingGlassPane *>(gaddrof(CGlass::FindFreePane));</p>
<p>0AA7: call_function_return 0x502490 num_params 0 pop 0 func_ret [CFallingGlassPane *]</p>
<p>define function CGlass__FindFreePane&lt;cdecl, 0x502490&gt;(): int</p>
<h4>CGlass::GeneratePanesForWindow</h4>
<p>plugin::CallDynGlobal<unsigned int, CVector, CVector, CVector, CVector, CVector, float, bool, bool>(gaddrof(CGlass::GeneratePanesForWindow), type, pos, at, right, speed, point, moveSpeed, cracked, explosion);</p>
<h4>CGlass::RenderEntityInGlass</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CGlass::RenderEntityInGlass), entity);</p>
<h4>CGlass::WasGlassHitByBullet</h4>
<p>plugin::CallDynGlobal<CEntity *, CVector>(gaddrof(CGlass::WasGlassHitByBullet), entity, point);</p>
<h4>CGlass::WindowRespondsToCollision</h4>
<p>plugin::CallDynGlobal<CEntity *, float, CVector, CVector, bool>(gaddrof(CGlass::WindowRespondsToCollision), entity, amount, speed, point, explosion);</p>
<h4>CGlass::WindowRespondsToExplosion</h4>
<p>plugin::CallDynGlobal<CEntity *, CVector>(gaddrof(CGlass::WindowRespondsToExplosion), entity, point);</p>
<h4>CGlass::WindowRespondsToSoftCollision</h4>
<p>plugin::CallDynGlobal<CEntity *, float>(gaddrof(CGlass::WindowRespondsToSoftCollision), entity, amount);</p><h3 id="plugin_iiigame_iiichelicpp">plugin_III\game_III\CHeli.cpp</h3><h4>CHeli::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CHeli *, unsigned int>(this, modelIndex);</p>
<h4>CHeli::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CHeli *>(this);</p>
<h4>CHeli::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CHeli *>(this);</p>
<h4>CHeli::Render</h4>
<p>plugin::CallVirtualMethod<13, CHeli *>(this);</p>
<h4>CHeli::PreRenderAlways</h4>
<p>plugin::CallMethodDynGlobal<CHeli *>(gaddrof(CHeli::PreRenderAlways), this);</p>
<p>0AA6: call_method 0x5477F0 struct [CHeli] num_params 0 pop 0</p>
<p>define function CHeli__PreRenderAlways&lt;thiscall, 0x5477F0&gt;()</p>
<h4>*CHeli::SpawnFlyingComponent</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CObject *, CHeli *, int>(gaddrof(CHeli::SpawnFlyingComponent), this, component);</p>
<p>0AA8: call_method_return 0x54AE50 struct [*CHeli] num_params 1 pop 0 [component] func_ret [CObject *]</p>
<h4>CHeli::ActivateHeli</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CHeli::ActivateHeli), activate);</p>
<h4>*CHeli::FindPointerToCatalinasHeli</h4>
<p>plugin::CallAndReturnDynGlobal<CHeli *>(gaddrof(CHeli::FindPointerToCatalinasHeli));</p>
<p>0AA7: call_function_return 0x54AA20 num_params 0 pop 0 func_ret [CHeli *]</p>
<p>define function CHeli__FindPointerToCatalinasHeli&lt;cdecl, 0x54AA20&gt;(): int</p>
<h4>CHeli::HasCatalinaBeenShotDown</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CHeli::HasCatalinaBeenShotDown));</p>
<p>0AA7: call_function_return 0x54AA10 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CHeli__HasCatalinaBeenShotDown&lt;cdecl, 0x54AA10&gt;(): int</p>
<h4>CHeli::TestBulletCollision</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *, CVector *, CVector *, int>(gaddrof(CHeli::TestBulletCollision), lineStart, lineEnd, bulletPos, damage);</p>
<p>0AA7: call_function_return 0x54AB30 num_params 4 pop 4 [lineStart] [lineEnd] [bulletPos] [damage] func_ret [bool]</p>
<p>define function CHeli__TestBulletCollision&lt;cdecl, 0x54AB30&gt;(lineStart, lineEnd, bulletPos, damage): int</p>
<h4>CHeli::TestRocketCollision</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CHeli::TestRocketCollision), coors);</p>
<p>0AA7: call_function_return 0x54AA30 num_params 1 pop 1 [coors] func_ret [bool]</p>
<p>define function CHeli__TestRocketCollision&lt;cdecl, 0x54AA30&gt;(coors): int</p>
<h4>*GenerateHeli</h4>
<p>plugin::CallAndReturnDynGlobal<CHeli *, bool>(gaddrof(GenerateHeli), catalina);</p>
<p>0AA7: call_function_return 0x54A640 num_params 1 pop 1 [catalina] func_ret [CHeli *]</p>
<p>define function GenerateHeli&lt;cdecl, 0x54A640&gt;(catalina): int</p>
<h4>*GetHeliAtomicObjectCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetHeliAtomicObjectCB), object, data);</p>
<p>0AA7: call_function_return 0x54AE30 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function GetHeliAtomicObjectCB&lt;cdecl, 0x54AE30&gt;(object, data): int</p><h3 id="plugin_iiigame_iiichudcpp">plugin_III\game_III\CHud.cpp</h3><h4>CHud::Draw</h4>
<p>plugin::Call<0x5052A0>();</p>
<p>0AA5: call_function 0x5052A0 num_params 0 pop 0</p>
<p>define function CHud__Draw&lt;cdecl, 0x5052A0&gt;()</p>
<h4>CHud::DrawAfterFade</h4>
<p>plugin::Call<0x509030>();</p>
<p>0AA5: call_function 0x509030 num_params 0 pop 0</p>
<p>define function CHud__DrawAfterFade&lt;cdecl, 0x509030&gt;()</p>
<h4>CHud::GetRidOfAllHudMessages</h4>
<p>plugin::Call<0x504F90>();</p>
<p>0AA5: call_function 0x504F90 num_params 0 pop 0</p>
<p>define function CHud__GetRidOfAllHudMessages&lt;cdecl, 0x504F90&gt;()</p>
<h4>CHud::Initialise</h4>
<p>plugin::Call<0x5048F0>();</p>
<p>0AA5: call_function 0x5048F0 num_params 0 pop 0</p>
<p>define function CHud__Initialise&lt;cdecl, 0x5048F0&gt;()</p>
<h4>CHud::ReInitialise</h4>
<p>plugin::Call<0x504CC0>();</p>
<p>0AA5: call_function 0x504CC0 num_params 0 pop 0</p>
<p>define function CHud__ReInitialise&lt;cdecl, 0x504CC0&gt;()</p>
<h4>CHud::SetBigMessage</h4>
<p>plugin::Call<0x50A250, wchar_t *, char>(message, style);</p>
<p>0AA5: call_function 0x50A250 num_params 2 pop 2 [message] [style]</p>
<p>define function CHud__SetBigMessage&lt;cdecl, 0x50A250&gt;(message, style)</p>
<h4>CHud::SetHelpMessage</h4>
<p>plugin::Call<0x5051E0, wchar_t *, bool>(message, quick);</p>
<p>0AA5: call_function 0x5051E0 num_params 2 pop 2 [message] [quick]</p>
<p>define function CHud__SetHelpMessage&lt;cdecl, 0x5051E0&gt;(message, quick)</p>
<h4>CHud::SetMessage</h4>
<p>plugin::Call<0x50A210, wchar_t *>(message);</p>
<p>0AA5: call_function 0x50A210 num_params 1 pop 1 [message]</p>
<p>define function CHud__SetMessage&lt;cdecl, 0x50A210&gt;(message)</p>
<h4>CHud::SetPagerMessage</h4>
<p>plugin::Call<0x50A320, wchar_t *>(message);</p>
<p>0AA5: call_function 0x50A320 num_params 1 pop 1 [message]</p>
<p>define function CHud__SetPagerMessage&lt;cdecl, 0x50A320&gt;(message)</p>
<h4>CHud::SetVehicleName</h4>
<p>plugin::Call<0x505290, wchar_t *>(name);</p>
<p>0AA5: call_function 0x505290 num_params 1 pop 1 [name]</p>
<p>define function CHud__SetVehicleName&lt;cdecl, 0x505290&gt;(name)</p>
<h4>CHud::SetZoneName</h4>
<p>plugin::Call<0x5051D0, wchar_t *>(name);</p>
<p>0AA5: call_function 0x5051D0 num_params 1 pop 1 [name]</p>
<p>define function CHud__SetZoneName&lt;cdecl, 0x5051D0&gt;(name)</p>
<h4>CHud::Shutdown</h4>
<p>plugin::Call<0x504C50>();</p>
<p>0AA5: call_function 0x504C50 num_params 0 pop 0</p>
<p>define function CHud__Shutdown&lt;cdecl, 0x504C50&gt;()</p><h3 id="plugin_iiigame_iiicinstancecpp">plugin_III\game_III\CInstance.cpp</h3><h4>CInstance::Shutdown</h4>
<p>plugin::CallMethodDynGlobal<CInstance *>(gaddrof(CInstance::Shutdown), this);</p>
<p>0AA6: call_method 0x50B850 struct [CInstance] num_params 0 pop 0</p>
<p>define function CInstance__Shutdown&lt;thiscall, 0x50B850&gt;()</p><h3 id="plugin_iiigame_iiickeyboardstatecpp">plugin_III\game_III\CKeyboardState.cpp</h3><h4>CKeyboardState::Clear</h4>
<p>plugin::CallMethod<0x491760, CKeyboardState *>(this);</p>
<p>0AA6: call_method 0x491760 struct [CKeyboardState] num_params 0 pop 0</p>
<p>define function CKeyboardState__Clear&lt;thiscall, 0x491760&gt;()</p><h3 id="plugin_iiigame_iiiclinescpp">plugin_III\game_III\CLines.cpp</h3><h4>CLines::RenderLineWithClipping</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, float, unsigned int, unsigned int>(gaddrof(CLines::RenderLineWithClipping), x1, y1, z1, x2, y2, z2, color1, color2);</p><h3 id="plugin_iiigame_iiicmatrixcpp">plugin_III\game_III\CMatrix.cpp</h3><h4>CMatrix::CMatrix</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(ctor_gaddr(CMatrix), this);</p>
<h4>CMatrix::CMatrix</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(ctor_gaddr_o(CMatrix, void(RwMatrix *, bool)), this, rwMatrix, deleteOnDetach);</p>
<h4>CMatrix::CMatrix</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(ctor_gaddr_o(CMatrix, void(CMatrix const &amp;)), this, matrix);</p>
<h4>CMatrix::~CMatrix</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(dtor_gaddr(CMatrix), this);</p>
<h4>CMatrix::operator+=</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof_o(CMatrix::operator+=, void (CMatrix::*)(CMatrix const &amp;)), this, right);</p>
<p>0AA6: call_method 0x4B8F90 struct [CMatrix] num_params 1 pop 0 [right]</p>
<p>define function CMatrix__operator+=&lt;thiscall, 0x4B8F90&gt;(right)</p>
<h4>CMatrix::operator=</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof_o(CMatrix::operator=, void (CMatrix::*)(CMatrix const &amp;)), this, right);</p>
<p>0AA6: call_method 0x4B8F40 struct [CMatrix] num_params 1 pop 0 [right]</p>
<p>define function CMatrix__operator=&lt;thiscall, 0x4B8F40&gt;(right)</p>
<h4>CMatrix::Attach</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(gaddrof(CMatrix::Attach), this, rwMatrix, deleteOnDetach);</p>
<p>0AA6: call_method 0x4B8DD0 struct [CMatrix] num_params 2 pop 0 [rwMatrix] [deleteOnDetach]</p>
<p>define function CMatrix__Attach&lt;thiscall, 0x4B8DD0&gt;(rwMatrix, deleteOnDetach)</p>
<h4>CMatrix::AttachRW</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, RwMatrix *, bool>(gaddrof(CMatrix::AttachRW), this, rwMatrix, deleteOnDetach);</p>
<p>0AA6: call_method 0x4B8E00 struct [CMatrix] num_params 2 pop 0 [rwMatrix] [deleteOnDetach]</p>
<p>define function CMatrix__AttachRW&lt;thiscall, 0x4B8E00&gt;(rwMatrix, deleteOnDetach)</p>
<h4>CMatrix::CopyOnlyMatrix</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, CMatrix const &>(gaddrof(CMatrix::CopyOnlyMatrix), this, matrix);</p>
<p>0AA6: call_method 0x4B8F70 struct [CMatrix] num_params 1 pop 0 [matrix]</p>
<p>define function CMatrix__CopyOnlyMatrix&lt;thiscall, 0x4B8F70&gt;(matrix)</p>
<h4>CMatrix::Detach</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Detach), this);</p>
<p>0AA6: call_method 0x4B8E30 struct [CMatrix] num_params 0 pop 0</p>
<p>define function CMatrix__Detach&lt;thiscall, 0x4B8E30&gt;()</p>
<h4>CMatrix::Reorthogonalise</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Reorthogonalise), this);</p>
<p>0AA6: call_method 0x4B9A80 struct [CMatrix] num_params 0 pop 0</p>
<p>define function CMatrix__Reorthogonalise&lt;thiscall, 0x4B9A80&gt;()</p>
<h4>CMatrix::ResetOrientation</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::ResetOrientation), this);</p>
<p>0AA6: call_method 0x4B9070 struct [CMatrix] num_params 0 pop 0</p>
<p>define function CMatrix__ResetOrientation&lt;thiscall, 0x4B9070&gt;()</p>
<h4>CMatrix::Rotate</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::Rotate), this, x, y, z);</p>
<p>0AA6: call_method 0x4B9770 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CMatrix__Rotate&lt;thiscall, 0x4B9770&gt;(x, y, z)</p>
<h4>CMatrix::RotateX</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::RotateX), this, angle);</p>
<p>0AA6: call_method 0x4B9510 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__RotateX&lt;thiscall, 0x4B9510&gt;(angle)</p>
<h4>CMatrix::RotateZ</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::RotateZ), this, angle);</p>
<p>0AA6: call_method 0x4B9640 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__RotateZ&lt;thiscall, 0x4B9640&gt;(angle)</p>
<h4>CMatrix::SetRotate</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::SetRotate), this, x, y, z);</p>
<p>0AA6: call_method 0x4B93A0 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CMatrix__SetRotate&lt;thiscall, 0x4B93A0&gt;(x, y, z)</p>
<h4>CMatrix::SetRotateX</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateX), this, angle);</p>
<p>0AA6: call_method 0x4B9310 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__SetRotateX&lt;thiscall, 0x4B9310&gt;(angle)</p>
<h4>CMatrix::SetRotateXOnly</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateXOnly), this, angle);</p>
<p>0AA6: call_method 0x4B9160 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__SetRotateXOnly&lt;thiscall, 0x4B9160&gt;(angle)</p>
<h4>CMatrix::SetRotateY</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateY), this, angle);</p>
<p>0AA6: call_method 0x4B9340 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__SetRotateY&lt;thiscall, 0x4B9340&gt;(angle)</p>
<h4>CMatrix::SetRotateYOnly</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateYOnly), this, angle);</p>
<p>0AA6: call_method 0x4B91F0 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__SetRotateYOnly&lt;thiscall, 0x4B91F0&gt;(angle)</p>
<h4>CMatrix::SetRotateZ</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateZ), this, angle);</p>
<p>0AA6: call_method 0x4B9370 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__SetRotateZ&lt;thiscall, 0x4B9370&gt;(angle)</p>
<h4>CMatrix::SetRotateZOnly</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetRotateZOnly), this, angle);</p>
<p>0AA6: call_method 0x4B9280 struct [CMatrix] num_params 1 pop 0 [angle]</p>
<p>define function CMatrix__SetRotateZOnly&lt;thiscall, 0x4B9280&gt;(angle)</p>
<h4>CMatrix::SetScale</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float>(gaddrof(CMatrix::SetScale), this, factor);</p>
<p>0AA6: call_method 0x4B90B0 struct [CMatrix] num_params 1 pop 0 [factor]</p>
<p>define function CMatrix__SetScale&lt;thiscall, 0x4B90B0&gt;(factor)</p>
<h4>CMatrix::SetTranslate</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof_o(CMatrix::SetTranslate, void (CMatrix::*)(float, float, float)), this, x, y, z);</p>
<p>0AA6: call_method 0x54A8C0 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CMatrix__SetTranslate&lt;thiscall, 0x54A8C0&gt;(x, y, z)</p>
<h4>CMatrix::SetTranslate</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, CVector *>(gaddrof_o(CMatrix::SetTranslate, void (CMatrix::*)(CVector *)), this, pos);</p>
<p>0AA6: call_method 0x54A8C0 struct [CMatrix] num_params 1 pop 0 [pos]</p>
<p>define function CMatrix__SetTranslate&lt;thiscall, 0x54A8C0&gt;(pos)</p>
<h4>CMatrix::SetTranslateOnly</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *, float, float, float>(gaddrof(CMatrix::SetTranslateOnly), this, x, y, z);</p>
<p>0AA6: call_method 0x4CBA70 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CMatrix__SetTranslateOnly&lt;thiscall, 0x4CBA70&gt;(x, y, z)</p>
<h4>CMatrix::SetUnity</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::SetUnity), this);</p>
<p>0AA6: call_method 0x4B9010 struct [CMatrix] num_params 0 pop 0</p>
<p>define function CMatrix__SetUnity&lt;thiscall, 0x4B9010&gt;()</p>
<h4>CMatrix::Update</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::Update), this);</p>
<p>0AA6: call_method 0x4B8E50 struct [CMatrix] num_params 0 pop 0</p>
<p>define function CMatrix__Update&lt;thiscall, 0x4B8E50&gt;()</p>
<h4>CMatrix::UpdateRW</h4>
<p>plugin::CallMethodDynGlobal<CMatrix *>(gaddrof(CMatrix::UpdateRW), this);</p>
<p>0AA6: call_method 0x4B8EC0 struct [CMatrix] num_params 0 pop 0</p>
<p>define function CMatrix__UpdateRW&lt;thiscall, 0x4B8EC0&gt;()</p><h3 id="plugin_iiigame_iiicmblurcpp">plugin_III\game_III\CMBlur.cpp</h3><h4>CMBlur::CreateImmediateModeData</h4>
<p>plugin::CallDynGlobal<RwCamera *, RwRect *>(gaddrof(CMBlur::CreateImmediateModeData), cam, rect);</p>
<h4>CMBlur::MotionBlurClose</h4>
<p>plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(CMBlur::MotionBlurClose));</p>
<p>0AA7: call_function_return 0x50B170 num_params 0 pop 0 func_ret [RwBool]</p>
<p>define function CMBlur__MotionBlurClose&lt;cdecl, 0x50B170&gt;(): int</p>
<h4>CMBlur::MotionBlurOpen</h4>
<p>plugin::CallAndReturnDynGlobal<RwBool, RwCamera *>(gaddrof(CMBlur::MotionBlurOpen), cam);</p>
<p>0AA7: call_function_return 0x50AE40 num_params 1 pop 1 [cam] func_ret [RwBool]</p>
<p>define function CMBlur__MotionBlurOpen&lt;cdecl, 0x50AE40&gt;(cam): int</p>
<h4>CMBlur::MotionBlurRender</h4>
<p>plugin::CallDynGlobal<RwCamera *, unsigned int, unsigned int, unsigned int, unsigned int, int, unsigned int>(gaddrof(CMBlur::MotionBlurRender), cam, red, green, blue, blur, type, blurAlpha);</p>
<h4>CMBlur::OverlayRender</h4>
<p>plugin::CallDynGlobal<RwCamera *, RwRaster *, RwRGBA, int, int>(gaddrof(CMBlur::OverlayRender), cam, raster, color, type, blurAlpha);</p><h3 id="plugin_iiigame_iiicmenumanagercpp">plugin_III\game_III\CMenuManager.cpp</h3><h4>CMenuManager::BuildStatLine</h4>
<p>plugin::CallMethod<0x483870, CMenuManager *, char *, float <em>, bool, float</em>>(this, text, stat, aFloat, stat2);</p>
<p>0AA6: call_method 0x483870 struct [CMenuManager] num_params 4 pop 0 [text] [stat] [aFloat] [stat2]</p>
<p>define function CMenuManager__BuildStatLine&lt;thiscall, 0x483870&gt;(text, stat, aFloat, stat2)</p>
<h4>CMenuManager::CentreMousePointer</h4>
<p>plugin::Call<0x48ACE0>();</p>
<p>0AA5: call_function 0x48ACE0 num_params 0 pop 0</p>
<p>define function CMenuManager__CentreMousePointer&lt;cdecl, 0x48ACE0&gt;()</p>
<h4>CMenuManager::CheckCodesForControls</h4>
<p>plugin::CallMethodAndReturn<int, 0x483870, CMenuManager *, int>(this, type);</p>
<p>0AA8: call_method_return 0x483870 struct [CMenuManager] num_params 1 pop 0 [type] func_ret [int]</p>
<p>define function CMenuManager__CheckCodesForControls&lt;thiscall, 0x483870&gt;(type): int</p>
<h4>CMenuManager::CheckHover</h4>
<p>plugin::CallMethodAndReturn<bool, 0x48ACA0, CMenuManager *, int, int, int, int>(this, x1, x2, y1, y2);</p>
<p>0AA8: call_method_return 0x48ACA0 struct [CMenuManager] num_params 4 pop 0 [x1] [x2] [y1] [y2] func_ret [bool]</p>
<p>define function CMenuManager__CheckHover&lt;thiscall, 0x48ACA0&gt;(x1, x2, y1, y2): int</p>
<h4>CMenuManager::CheckSliderMovement</h4>
<p>plugin::CallMethod<0x48B210, CMenuManager *, int>(this, direction);</p>
<p>0AA6: call_method 0x48B210 struct [CMenuManager] num_params 1 pop 0 [direction]</p>
<p>define function CMenuManager__CheckSliderMovement&lt;thiscall, 0x48B210&gt;(direction)</p>
<h4>CMenuManager::CostructStatLine</h4>
<p>plugin::CallMethodAndReturn<int, 0x482800, CMenuManager *, int>(this, line);</p>
<p>0AA8: call_method_return 0x482800 struct [CMenuManager] num_params 1 pop 0 [line] func_ret [int]</p>
<p>define function CMenuManager__CostructStatLine&lt;thiscall, 0x482800&gt;(line): int</p>
<h4>CMenuManager::DisplayHelperText</h4>
<p>plugin::CallMethod<0x48B490, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x48B490 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DisplayHelperText&lt;thiscall, 0x48B490&gt;()</p>
<h4>CMenuManager::DisplaySlider</h4>
<p>plugin::CallMethodAndReturn<float, 0x00, CMenuManager *>(this);</p>
<p>0AA8: call_method_return 0x00 struct [CMenuManager] num_params 0 pop 0 func_ret [float]</p>
<p>define function CMenuManager__DisplaySlider&lt;thiscall, 0x00&gt;(): float</p>
<h4>CMenuManager::DoSettingsBeforeStartingAGame</h4>
<p>plugin::CallMethod<0x48AB40, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x48AB40 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DoSettingsBeforeStartingAGame&lt;thiscall, 0x48AB40&gt;()</p>
<h4>CMenuManager::Draw</h4>
<p>plugin::CallMethod<0x47AE00, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x47AE00 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__Draw&lt;thiscall, 0x47AE00&gt;()</p>
<h4>CMenuManager::DrawControllerBound</h4>
<p>plugin::CallMethod<0x489710, CMenuManager *, int, int, int, char>(this, arg0, arg1, arg2, arg3);</p>
<p>0AA6: call_method 0x489710 struct [CMenuManager] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CMenuManager__DrawControllerBound&lt;thiscall, 0x489710&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CMenuManager::DrawControllerScreenExtraText</h4>
<p>plugin::CallMethod<0x4892F0, CMenuManager *, int, int, int>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x4892F0 struct [CMenuManager] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CMenuManager__DrawControllerScreenExtraText&lt;thiscall, 0x4892F0&gt;(arg0, arg1, arg2)</p>
<h4>CMenuManager::DrawControllerSetupScreen</h4>
<p>plugin::CallMethod<0x481210, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x481210 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DrawControllerSetupScreen&lt;thiscall, 0x481210&gt;()</p>
<h4>CMenuManager::DrawFrontEnd</h4>
<p>plugin::CallMethod<0x47A540, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x47A540 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DrawFrontEnd&lt;thiscall, 0x47A540&gt;()</p>
<h4>CMenuManager::DrawFrontEndNormal</h4>
<p>plugin::CallMethod<0x47A5B0, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x47A5B0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DrawFrontEndNormal&lt;thiscall, 0x47A5B0&gt;()</p>
<h4>CMenuManager::DrawPlayerSetupScreen</h4>
<p>plugin::CallMethod<0x47F2B0, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x47F2B0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DrawPlayerSetupScreen&lt;thiscall, 0x47F2B0&gt;()</p>
<h4>CMenuManager::FadeIn</h4>
<p>plugin::CallMethodAndReturn<int, 0x48AC60, CMenuManager *, int>(this, alpha);</p>
<p>0AA8: call_method_return 0x48AC60 struct [CMenuManager] num_params 1 pop 0 [alpha] func_ret [int]</p>
<p>define function CMenuManager__FadeIn&lt;thiscall, 0x48AC60&gt;(alpha): int</p>
<h4>CMenuManager::FilterOutColorMarkersFromString</h4>
<p>plugin::CallMethod<0x4889C0, CMenuManager *, char, CRGBA &>(this, s, color);</p>
<p>0AA6: call_method 0x4889C0 struct [CMenuManager] num_params 2 pop 0 [s] [color]</p>
<p>define function CMenuManager__FilterOutColorMarkersFromString&lt;thiscall, 0x4889C0&gt;(s, color)</p>
<h4>CMenuManager::GetStartOptionsCntrlConfigScreens</h4>
<p>plugin::CallMethodAndReturn<int, 0x489270, CMenuManager *>(this);</p>
<p>0AA8: call_method_return 0x489270 struct [CMenuManager] num_params 0 pop 0 func_ret [int]</p>
<p>define function CMenuManager__GetStartOptionsCntrlConfigScreens&lt;thiscall, 0x489270&gt;(): int</p>
<h4>CMenuManager::InitialiseChangedLanguageSettings</h4>
<p>plugin::Call<0x47A4D0>();</p>
<p>0AA5: call_function 0x47A4D0 num_params 0 pop 0</p>
<p>define function CMenuManager__InitialiseChangedLanguageSettings&lt;cdecl, 0x47A4D0&gt;()</p>
<h4>CMenuManager::LoadAllTextures</h4>
<p>plugin::CallMethod<0x47A230, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x47A230 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__LoadAllTextures&lt;thiscall, 0x47A230&gt;()</p>
<h4>CMenuManager::LoadSettings</h4>
<p>plugin::CallMethod<0x488EE0, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x488EE0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__LoadSettings&lt;thiscall, 0x488EE0&gt;()</p>
<h4>CMenuManager::MessageScreen</h4>
<p>plugin::Call<0x48B7E0, char *>(message);</p>
<p>0AA5: call_function 0x48B7E0 num_params 1 pop 1 [message]</p>
<p>define function CMenuManager__MessageScreen&lt;cdecl, 0x48B7E0&gt;(message)</p>
<h4>CMenuManager::PickNewPlayerColour</h4>
<p>plugin::Call<0x488C40>();</p>
<p>0AA5: call_function 0x488C40 num_params 0 pop 0</p>
<p>define function CMenuManager__PickNewPlayerColour&lt;cdecl, 0x488C40&gt;()</p>
<h4>CMenuManager::PrintBriefs</h4>
<p>plugin::CallMethod<0x484D60, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x484D60 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__PrintBriefs&lt;thiscall, 0x484D60&gt;()</p>
<h4>CMenuManager::PrintErrorMessage</h4>
<p>plugin::Call<0x484F70>();</p>
<p>0AA5: call_function 0x484F70 num_params 0 pop 0</p>
<p>define function CMenuManager__PrintErrorMessage&lt;cdecl, 0x484F70&gt;()</p>
<h4>CMenuManager::PrintStats</h4>
<p>plugin::CallMethod<0x482100, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x482100 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__PrintStats&lt;thiscall, 0x482100&gt;()</p>
<h4>CMenuManager::Process</h4>
<p>plugin::CallMethod<0x485100, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x485100 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__Process&lt;thiscall, 0x485100&gt;()</p>
<h4>CMenuManager::ProcessButtonPresses</h4>
<p>plugin::CallMethod<0x4856F0, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x4856F0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ProcessButtonPresses&lt;thiscall, 0x4856F0&gt;()</p>
<h4>CMenuManager::ProcessOnOffMenuOptions</h4>
<p>plugin::CallMethod<0x48AE60, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x48AE60 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ProcessOnOffMenuOptions&lt;thiscall, 0x48AE60&gt;()</p>
<h4>CMenuManager::RequestFrontEndShutDown</h4>
<p>plugin::Call<0x488750>();</p>
<p>0AA5: call_function 0x488750 num_params 0 pop 0</p>
<p>define function CMenuManager__RequestFrontEndShutDown&lt;cdecl, 0x488750&gt;()</p>
<h4>CMenuManager::RequestFrontEndStartUp</h4>
<p>plugin::Call<0x488770>();</p>
<p>0AA5: call_function 0x488770 num_params 0 pop 0</p>
<p>define function CMenuManager__RequestFrontEndStartUp&lt;cdecl, 0x488770&gt;()</p>
<h4>CMenuManager::ResetHelperText</h4>
<p>plugin::CallMethod<0x48B470, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x48B470 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ResetHelperText&lt;thiscall, 0x48B470&gt;()</p>
<h4>CMenuManager::SaveLoadFileError_SetUpErrorScreen</h4>
<p>plugin::CallMethod<0x488930, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x488930 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SaveLoadFileError_SetUpErrorScreen&lt;thiscall, 0x488930&gt;()</p>
<h4>CMenuManager::SaveSettings</h4>
<p>plugin::CallMethod<0x488CC0, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x488CC0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SaveSettings&lt;thiscall, 0x488CC0&gt;()</p>
<h4>CMenuManager::SetHelperText</h4>
<p>plugin::CallMethod<0x48B450, CMenuManager *, int>(this, text);</p>
<p>0AA6: call_method 0x48B450 struct [CMenuManager] num_params 1 pop 0 [text]</p>
<p>define function CMenuManager__SetHelperText&lt;thiscall, 0x48B450&gt;(text)</p>
<h4>CMenuManager::ShutdownJustMenu</h4>
<p>plugin::CallMethod<0x488920, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x488920 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ShutdownJustMenu&lt;thiscall, 0x488920&gt;()</p>
<h4>CMenuManager::StretchX</h4>
<p>plugin::CallMethodAndReturn<float, 0x48ABE0, CMenuManager *, float>(this, x);</p>
<p>0AA8: call_method_return 0x48ABE0 struct [CMenuManager] num_params 1 pop 0 [x] func_ret [float]</p>
<p>define function CMenuManager__StretchX&lt;thiscall, 0x48ABE0&gt;(x): float</p>
<h4>CMenuManager::StretchY</h4>
<p>plugin::CallMethodAndReturn<float, 0x48AC20, CMenuManager *, float>(this, y);</p>
<p>0AA8: call_method_return 0x48AC20 struct [CMenuManager] num_params 1 pop 0 [y] func_ret [float]</p>
<p>define function CMenuManager__StretchY&lt;thiscall, 0x48AC20&gt;(y): float</p>
<h4>CMenuManager::SwitchMenuOnAndOff</h4>
<p>plugin::CallMethod<0x488790, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x488790 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SwitchMenuOnAndOff&lt;thiscall, 0x488790&gt;()</p>
<h4>CMenuManager::UnloadTextures</h4>
<p>plugin::CallMethod<0x47A440, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x47A440 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__UnloadTextures&lt;thiscall, 0x47A440&gt;()</p>
<h4>CMenuManager::WaitForUserCD</h4>
<p>plugin::CallMethod<0x48ADD0, CMenuManager *>(this);</p>
<p>0AA6: call_method 0x48ADD0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__WaitForUserCD&lt;thiscall, 0x48ADD0&gt;()</p><h3 id="plugin_iiigame_iiicmessagescpp">plugin_III\game_III\CMessages.cpp</h3><h4>CMessages::Init</h4>
<p>plugin::Call<0x529310>();</p>
<p>0AA5: call_function 0x529310 num_params 0 pop 0</p>
<p>define function CMessages__Init&lt;cdecl, 0x529310&gt;()</p>
<h4>CMessages::GetWideStringLength</h4>
<p>plugin::CallAndReturn<int, 0x529490, wchar_t*>(str);</p>
<p>0AA7: call_function_return 0x529490 num_params 1 pop 1 [str] func_ret [int]</p>
<p>define function CMessages__GetWideStringLength&lt;cdecl, 0x529490&gt;(str): int</p>
<h4>CMessages::WideStringCopy</h4>
<p>plugin::CallAndReturn<int, 0x5294B0, wchar_t<em>, wchar_t</em>, unsigned short>(dst, src, size);</p>
<p>0AA7: call_function_return 0x5294B0 num_params 3 pop 3 [dst] [src] [size] func_ret [int]</p>
<p>define function CMessages__WideStringCopy&lt;cdecl, 0x5294B0&gt;(dst, src, size): int</p>
<h4>CMessages::WideStringCompare</h4>
<p>plugin::CallAndReturn<bool, 0x529510, wchar_t<em>, wchar_t</em>, unsigned short>(str1, str2, size);</p>
<p>0AA7: call_function_return 0x529510 num_params 3 pop 3 [str1] [str2] [size] func_ret [bool]</p>
<p>define function CMessages__WideStringCompare&lt;cdecl, 0x529510&gt;(str1, str2, size): int</p>
<h4>CMessages::Process</h4>
<p>plugin::Call<0x529580>();</p>
<p>0AA5: call_function 0x529580 num_params 0 pop 0</p>
<p>define function CMessages__Process&lt;cdecl, 0x529580&gt;()</p>
<h4>CMessages::Display</h4>
<p>plugin::Call<0x529800>();</p>
<p>0AA5: call_function 0x529800 num_params 0 pop 0</p>
<p>define function CMessages__Display&lt;cdecl, 0x529800&gt;()</p>
<h4>CMessages::AddMessage</h4>
<p>plugin::Call<0x529900, wchar_t*, unsigned int, unsigned short>(text, time, flag);</p>
<p>0AA5: call_function 0x529900 num_params 3 pop 3 [text] [time] [flag]</p>
<p>define function CMessages__AddMessage&lt;cdecl, 0x529900&gt;(text, time, flag)</p>
<h4>CMessages::AddMessageJumpQ</h4>
<p>plugin::Call<0x529A10, wchar_t*, unsigned int, unsigned short>(text, time, flag);</p>
<p>0AA5: call_function 0x529A10 num_params 3 pop 3 [text] [time] [flag]</p>
<p>define function CMessages__AddMessageJumpQ&lt;cdecl, 0x529A10&gt;(text, time, flag)</p>
<h4>CMessages::AddMessageSoon</h4>
<p>plugin::Call<0x529AF0, wchar_t*, unsigned int, unsigned short>(text, time, flag);</p>
<p>0AA5: call_function 0x529AF0 num_params 3 pop 3 [text] [time] [flag]</p>
<p>define function CMessages__AddMessageSoon&lt;cdecl, 0x529AF0&gt;(text, time, flag)</p>
<h4>CMessages::ClearMessages</h4>
<p>plugin::Call<0x529CE0>();</p>
<p>0AA5: call_function 0x529CE0 num_params 0 pop 0</p>
<p>define function CMessages__ClearMessages&lt;cdecl, 0x529CE0&gt;()</p>
<h4>CMessages::ClearSmallMessagesOnly</h4>
<p>plugin::Call<0x529E00>();</p>
<p>0AA5: call_function 0x529E00 num_params 0 pop 0</p>
<p>define function CMessages__ClearSmallMessagesOnly&lt;cdecl, 0x529E00&gt;()</p>
<h4>CMessages::AddBigMessage</h4>
<p>plugin::Call<0x529EB0, wchar_t*, unsigned int, unsigned short>(text, time, flag);</p>
<p>0AA5: call_function 0x529EB0 num_params 3 pop 3 [text] [time] [flag]</p>
<p>define function CMessages__AddBigMessage&lt;cdecl, 0x529EB0&gt;(text, time, flag)</p>
<h4>CMessages::AddBigMessageQ</h4>
<p>plugin::Call<0x529F60, wchar_t*, unsigned int, unsigned short>(text, time, flag);</p>
<p>0AA5: call_function 0x529F60 num_params 3 pop 3 [text] [time] [flag]</p>
<p>define function CMessages__AddBigMessageQ&lt;cdecl, 0x529F60&gt;(text, time, flag)</p>
<h4>CMessages::AddToPreviousBriefArray</h4>
<p>plugin::Call<0x52A040, wchar_t<em>, int, int, int, int, int, int, wchar_t</em>>(text, n1, n2, n3, n4, n5, n6, str);</p>
<p>0AA5: call_function 0x52A040 num_params 8 pop 8 [text] [n1] [n2] [n3] [n4] [n5] [n6] [str]</p>
<p>define function CMessages__AddToPreviousBriefArray&lt;cdecl, 0x52A040&gt;(text, n1, n2, n3, n4, n5, n6, str)</p>
<h4>CMessages::InsertNumberInString</h4>
<p>plugin::Call<0x52A1A0, wchar_t<em>, int, int, int, int, int, int, wchar_t</em>>(src, n1, n2, n3, n4, n5, n6, dst);</p>
<p>0AA5: call_function 0x52A1A0 num_params 8 pop 8 [src] [n1] [n2] [n3] [n4] [n5] [n6] [dst]</p>
<p>define function CMessages__InsertNumberInString&lt;cdecl, 0x52A1A0&gt;(src, n1, n2, n3, n4, n5, n6, dst)</p>
<h4>CMessages::InsertStringInString</h4>
<p>plugin::Call<0x52A300, wchar_t<em>, wchar_t</em>>(text, str);</p>
<p>0AA5: call_function 0x52A300 num_params 2 pop 2 [text] [str]</p>
<p>define function CMessages__InsertStringInString&lt;cdecl, 0x52A300&gt;(text, str)</p>
<h4>CMessages::InsertPlayerControlKeysInString</h4>
<p>plugin::Call<0x52A490, wchar_t*>(text);</p>
<p>0AA5: call_function 0x52A490 num_params 1 pop 1 [text]</p>
<p>define function CMessages__InsertPlayerControlKeysInString&lt;cdecl, 0x52A490&gt;(text)</p>
<h4>CMessages::AddMessageWithNumber</h4>
<p>plugin::Call<0x52A850, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);</p>
<p>0AA5: call_function 0x52A850 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]</p>
<p>define function CMessages__AddMessageWithNumber&lt;cdecl, 0x52A850&gt;(text, time, flag, n1, n2, n3, n4, n5, n6)</p>
<h4>CMessages::AddMessageJumpQWithNumber</h4>
<p>plugin::Call<0x52A9A0, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);</p>
<p>0AA5: call_function 0x52A9A0 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]</p>
<p>define function CMessages__AddMessageJumpQWithNumber&lt;cdecl, 0x52A9A0&gt;(text, time, flag, n1, n2, n3, n4, n5, n6)</p>
<h4>CMessages::AddMessageSoonWithNumber</h4>
<p>plugin::Call<0x52AAC0, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);</p>
<p>0AA5: call_function 0x52AAC0 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]</p>
<p>define function CMessages__AddMessageSoonWithNumber&lt;cdecl, 0x52AAC0&gt;(text, time, flag, n1, n2, n3, n4, n5, n6)</p>
<h4>CMessages::AddBigMessageWithNumber</h4>
<p>plugin::Call<0x52AD10, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);</p>
<p>0AA5: call_function 0x52AD10 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]</p>
<p>define function CMessages__AddBigMessageWithNumber&lt;cdecl, 0x52AD10&gt;(text, time, flag, n1, n2, n3, n4, n5, n6)</p>
<h4>CMessages::AddBigMessageWithNumberQ</h4>
<p>plugin::Call<0x52AE00, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(text, time, flag, n1, n2, n3, n4, n5, n6);</p>
<p>0AA5: call_function 0x52AE00 num_params 9 pop 9 [text] [time] [flag] [n1] [n2] [n3] [n4] [n5] [n6]</p>
<p>define function CMessages__AddBigMessageWithNumberQ&lt;cdecl, 0x52AE00&gt;(text, time, flag, n1, n2, n3, n4, n5, n6)</p>
<h4>CMessages::AddMessageWithString</h4>
<p>plugin::Call<0x52AF30, wchar_t<em>, unsigned int, unsigned short, wchar_t</em>>(text, time, flag, str);</p>
<p>0AA5: call_function 0x52AF30 num_params 4 pop 4 [text] [time] [flag] [str]</p>
<p>define function CMessages__AddMessageWithString&lt;cdecl, 0x52AF30&gt;(text, time, flag, str)</p>
<h4>CMessages::AddMessageJumpQWithString</h4>
<p>plugin::Call<0x52B050, wchar_t<em>, unsigned int, unsigned short, wchar_t</em>>(text, time, flag, str);</p>
<p>0AA5: call_function 0x52B050 num_params 4 pop 4 [text] [time] [flag] [str]</p>
<p>define function CMessages__AddMessageJumpQWithString&lt;cdecl, 0x52B050&gt;(text, time, flag, str)</p>
<h4>CMessages::ClearThisPrint</h4>
<p>plugin::Call<0x52B140, wchar_t*>(text);</p>
<p>0AA5: call_function 0x52B140 num_params 1 pop 1 [text]</p>
<p>define function CMessages__ClearThisPrint&lt;cdecl, 0x52B140&gt;(text)</p>
<h4>CMessages::ClearThisBigPrint</h4>
<p>plugin::Call<0x52B3C0, wchar_t*>(text);</p>
<p>0AA5: call_function 0x52B3C0 num_params 1 pop 1 [text]</p>
<p>define function CMessages__ClearThisBigPrint&lt;cdecl, 0x52B3C0&gt;(text)</p>
<h4>CMessages::ClearAllMessagesDisplayedByGame</h4>
<p>plugin::Call<0x52B670>();</p>
<p>0AA5: call_function 0x52B670 num_params 0 pop 0</p>
<p>define function CMessages__ClearAllMessagesDisplayedByGame&lt;cdecl, 0x52B670&gt;()</p><h3 id="plugin_iiigame_iiicmissioncleanupcpp">plugin_III\game_III\CMissionCleanup.cpp</h3><h4>CMissionCleanup::AddEntityToList</h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *, int, unsigned char>(gaddrof(CMissionCleanup::AddEntityToList), this, id, type);</p>
<p>0AA6: call_method 0x437BA0 struct [CMissionCleanup] num_params 2 pop 0 [id] [type]</p>
<p>define function CMissionCleanup__AddEntityToList&lt;thiscall, 0x437BA0&gt;(id, type)</p>
<h4>*CMissionCleanup::FindFree</h4>
<p>plugin::CallMethodAndReturnDynGlobal<tCleanupEntity *, CMissionCleanup *>(gaddrof(CMissionCleanup::FindFree), this);</p>
<p>0AA8: call_method_return 0x437B80 struct [*CMissionCleanup] num_params 0 pop 0 func_ret [tCleanupEntity *]</p>
<h4>CMissionCleanup::Init</h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *>(gaddrof(CMissionCleanup::Init), this);</p>
<p>0AA6: call_method 0x437AE0 struct [CMissionCleanup] num_params 0 pop 0</p>
<p>define function CMissionCleanup__Init&lt;thiscall, 0x437AE0&gt;()</p>
<h4>CMissionCleanup::Process</h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *>(gaddrof(CMissionCleanup::Process), this);</p>
<p>0AA6: call_method 0x437C10 struct [CMissionCleanup] num_params 0 pop 0</p>
<p>define function CMissionCleanup__Process&lt;thiscall, 0x437C10&gt;()</p>
<h4>CMissionCleanup::RemoveEntityFromList</h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *, int, unsigned char>(gaddrof(CMissionCleanup::RemoveEntityFromList), this, id, type);</p>
<p>0AA6: call_method 0x437BD0 struct [CMissionCleanup] num_params 2 pop 0 [id] [type]</p>
<p>define function CMissionCleanup__RemoveEntityFromList&lt;thiscall, 0x437BD0&gt;(id, type)</p><h3 id="plugin_iiigame_iiicmlomodelinfocpp">plugin_III\game_III\CMloModelInfo.cpp</h3><h4>CMloModelInfo::ConstructClump</h4>
<p>plugin::CallMethodDynGlobal<CMloModelInfo *>(gaddrof(CMloModelInfo::ConstructClump), this);</p>
<p>0AA6: call_method 0x50B1A0 struct [CMloModelInfo] num_params 0 pop 0</p>
<p>define function CMloModelInfo__ConstructClump&lt;thiscall, 0x50B1A0&gt;()</p><h3 id="plugin_iiigame_iiicmodelinfocpp">plugin_III\game_III\CModelInfo.cpp</h3><h4>*CModelInfo::AddClumpModel</h4>
<p>plugin::CallAndReturnDynGlobal<CClumpModelInfo *, int>(gaddrof(CModelInfo::AddClumpModel), index);</p>
<p>0AA7: call_function_return 0x50BA10 num_params 1 pop 1 [index] func_ret [CClumpModelInfo *]</p>
<p>define function CModelInfo__AddClumpModel&lt;cdecl, 0x50BA10&gt;(index): int</p>
<h4>*CModelInfo::AddMloModel</h4>
<p>plugin::CallAndReturnDynGlobal<CMloModelInfo *, int>(gaddrof(CModelInfo::AddMloModel), index);</p>
<p>0AA7: call_function_return 0x50B970 num_params 1 pop 1 [index] func_ret [CMloModelInfo *]</p>
<p>define function CModelInfo__AddMloModel&lt;cdecl, 0x50B970&gt;(index): int</p>
<h4>*CModelInfo::AddPedModel</h4>
<p>plugin::CallAndReturnDynGlobal<CPedModelInfo *, int>(gaddrof(CModelInfo::AddPedModel), index);</p>
<p>0AA7: call_function_return 0x50BAD0 num_params 1 pop 1 [index] func_ret [CPedModelInfo *]</p>
<p>define function CModelInfo__AddPedModel&lt;cdecl, 0x50BAD0&gt;(index): int</p>
<h4>*CModelInfo::AddSimpleModel</h4>
<p>plugin::CallAndReturnDynGlobal<CSimpleModelInfo *, int>(gaddrof(CModelInfo::AddSimpleModel), index);</p>
<p>0AA7: call_function_return 0x50B920 num_params 1 pop 1 [index] func_ret [CSimpleModelInfo *]</p>
<p>define function CModelInfo__AddSimpleModel&lt;cdecl, 0x50B920&gt;(index): int</p>
<h4>*CModelInfo::AddTimeModel</h4>
<p>plugin::CallAndReturnDynGlobal<CTimeModelInfo *, int>(gaddrof(CModelInfo::AddTimeModel), index);</p>
<p>0AA7: call_function_return 0x50B9C0 num_params 1 pop 1 [index] func_ret [CTimeModelInfo *]</p>
<p>define function CModelInfo__AddTimeModel&lt;cdecl, 0x50B9C0&gt;(index): int</p>
<h4>*CModelInfo::AddVehicleModel</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicleModelInfo *, int>(gaddrof(CModelInfo::AddVehicleModel), index);</p>
<p>0AA7: call_function_return 0x50BA60 num_params 1 pop 1 [index] func_ret [CVehicleModelInfo *]</p>
<p>define function CModelInfo__AddVehicleModel&lt;cdecl, 0x50BA60&gt;(index): int</p>
<h4>*CModelInfo::Get2dEffectStore</h4>
<p>plugin::CallAndReturnDynGlobal<CStore<C2dEffect, 2000> *&gt;(gaddrof(CModelInfo::Get2dEffectStore));</p>
<p>0AA7: call_function_return 0x50BB30 num_params 0 pop 0 func_ret [CStore&lt;C2dEffect]</p>
<p>define function CModelInfo__Get2dEffectStore&lt;cdecl, 0x50BB30&gt;(): int</p>
<h4>*CModelInfo::GetMloInstanceStore</h4>
<p>plugin::CallAndReturnDynGlobal<CStore<CInstance, 1> *&gt;(gaddrof(CModelInfo::GetMloInstanceStore));</p>
<p>0AA7: call_function_return 0x50BB20 num_params 0 pop 0 func_ret [CStore&lt;CInstance]</p>
<p>define function CModelInfo__GetMloInstanceStore&lt;cdecl, 0x50BB20&gt;(): int</p>
<h4>*CModelInfo::GetModelInfo</h4>
<p>plugin::CallAndReturnDynGlobal<CBaseModelInfo *, char const *, int *>(gaddrof(CModelInfo::GetModelInfo), name, index);</p>
<p>0AA7: call_function_return 0x50B860 num_params 2 pop 2 [name] [index] func_ret [CBaseModelInfo *]</p>
<p>define function CModelInfo__GetModelInfo&lt;cdecl, 0x50B860&gt;(name, index): int</p>
<h4>CModelInfo::IsBoatModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CModelInfo::IsBoatModel), index);</p>
<p>0AA7: call_function_return 0x50BB90 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CModelInfo__IsBoatModel&lt;cdecl, 0x50BB90&gt;(index): int</p>
<h4>CModelInfo::RemoveColModelsFromOtherLevels</h4>
<p>plugin::CallDynGlobal<eLevelName>(gaddrof(CModelInfo::RemoveColModelsFromOtherLevels), level);</p><h3 id="plugin_iiigame_iiicmoneymessagecpp">plugin_III\game_III\CMoneyMessage.cpp</h3><h4>CMoneyMessage::Render</h4>
<p>plugin::CallMethodDynGlobal<CMoneyMessage *>(gaddrof(CMoneyMessage::Render), this);</p>
<p>0AA6: call_method 0x51AD90 struct [CMoneyMessage] num_params 0 pop 0</p>
<p>define function CMoneyMessage__Render&lt;thiscall, 0x51AD90&gt;()</p><h3 id="plugin_iiigame_iiicmotionblurstreakscpp">plugin_III\game_III\CMotionBlurStreaks.cpp</h3><h4>CMotionBlurStreaks::RegisterStreak</h4>
<p>plugin::CallDynGlobal<unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(gaddrof(CMotionBlurStreaks::RegisterStreak), id, red, green, blue, leftPoint, rightPoint);</p><h3 id="plugin_iiigame_iiicmousecontrollerstatecpp">plugin_III\game_III\CMouseControllerState.cpp</h3><h4>CMouseControllerState::CMouseControllerState</h4>
<p>plugin::CallMethodDynGlobal<CMouseControllerState *>(ctor_gaddr(CMouseControllerState), this);</p>
<h4>CMouseControllerState::Clear</h4>
<p>plugin::CallMethodDynGlobal<CMouseControllerState *>(gaddrof(CMouseControllerState::Clear), this);</p>
<p>0AA6: call_method 0x491BB0 struct [CMouseControllerState] num_params 0 pop 0</p>
<p>define function CMouseControllerState__Clear&lt;thiscall, 0x491BB0&gt;()</p><h3 id="plugin_iiigame_iiicmousepointerstatehelpercpp">plugin_III\game_III\CMousePointerStateHelper.cpp</h3><h3 id="plugin_iiigame_iiicmovingthingcpp">plugin_III\game_III\CMovingThing.cpp</h3><h4>CMovingThing::AddToList</h4>
<p>plugin::CallMethodDynGlobal<CMovingThing *, CMovingThing *>(gaddrof(CMovingThing::AddToList), this, pThing);</p>
<p>0AA6: call_method 0x4FF320 struct [CMovingThing] num_params 1 pop 0 [pThing]</p>
<p>define function CMovingThing__AddToList&lt;thiscall, 0x4FF320&gt;(pThing)</p>
<h4>CMovingThing::RemoveFromList</h4>
<p>plugin::CallMethodDynGlobal<CMovingThing *>(gaddrof(CMovingThing::RemoveFromList), this);</p>
<p>0AA6: call_method 0x4FF340 struct [CMovingThing] num_params 0 pop 0</p>
<p>define function CMovingThing__RemoveFromList&lt;thiscall, 0x4FF340&gt;()</p>
<h4>CMovingThing::Update</h4>
<p>plugin::CallMethodDynGlobal<CMovingThing *>(gaddrof(CMovingThing::Update), this);</p>
<p>0AA6: call_method 0x4FF290 struct [CMovingThing] num_params 0 pop 0</p>
<p>define function CMovingThing__Update&lt;thiscall, 0x4FF290&gt;()</p><h3 id="plugin_iiigame_iiicmusicmanagercpp">plugin_III\game_III\cMusicManager.cpp</h3><h4>cMusicManager::ChangeMusicMode</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::ChangeMusicMode), this, mode);</p>
<p>0AA6: call_method 0x57D310 struct [cMusicManager] num_params 1 pop 0 [mode]</p>
<p>define function cMusicManager__ChangeMusicMode&lt;thiscall, 0x57D310&gt;(mode)</p>
<h4>cMusicManager::ChangeRadioChannel</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::ChangeRadioChannel), this);</p>
<p>0AA8: call_method_return 0x57E130 struct [cMusicManager] num_params 0 pop 0 func_ret [bool]</p>
<h4>cMusicManager::ComputeAmbienceVol</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, unsigned char &>(gaddrof(cMusicManager::ComputeAmbienceVol), this, reset, outVolume);</p>
<p>0AA6: call_method 0x57DEA0 struct [cMusicManager] num_params 2 pop 0 [reset] [outVolume]</p>
<p>define function cMusicManager__ComputeAmbienceVol&lt;thiscall, 0x57DEA0&gt;(reset, outVolume)</p>
<h4>cMusicManager::DisplayRadioStationName</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::DisplayRadioStationName), this);</p>
<p>0AA6: call_method 0x57E6D0 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__DisplayRadioStationName&lt;thiscall, 0x57E6D0&gt;()</p>
<h4>cMusicManager::GetCarTuning</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetCarTuning), this);</p>
<p>0AA8: call_method_return 0x57E530 struct [cMusicManager] num_params 0 pop 0 func_ret [unsigned char]</p>
<h4>cMusicManager::GetNextCarTuning</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetNextCarTuning), this);</p>
<p>0AA8: call_method_return 0x57E5A0 struct [cMusicManager] num_params 0 pop 0 func_ret [unsigned char]</p>
<h4>cMusicManager::GetRadioInCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, cMusicManager *>(gaddrof(cMusicManager::GetRadioInCar), this);</p>
<p>0AA8: call_method_return 0x57D1D0 struct [cMusicManager] num_params 0 pop 0 func_ret [unsigned char]</p>
<h4>cMusicManager::GetTrackStartPos</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, cMusicManager *, unsigned char>(gaddrof(cMusicManager::GetTrackStartPos), this, track);</p>
<p>0AA8: call_method_return 0x57E450 struct [cMusicManager] num_params 1 pop 0 [track] func_ret [unsigned int]</p>
<h4>cMusicManager::Initialise</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Initialise), this);</p>
<p>0AA6: call_method 0x57CF70 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__Initialise&lt;thiscall, 0x57CF70&gt;()</p>
<h4>cMusicManager::PlayAnnouncement</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::PlayAnnouncement), this, announcement);</p>
<p>0AA6: call_method 0x57E430 struct [cMusicManager] num_params 1 pop 0 [announcement]</p>
<p>define function cMusicManager__PlayAnnouncement&lt;thiscall, 0x57E430&gt;(announcement)</p>
<h4>cMusicManager::PlayFrontEndTrack</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, unsigned char>(gaddrof(cMusicManager::PlayFrontEndTrack), this, track, bPlayInFrontend);</p>
<p>0AA6: call_method 0x57E2E0 struct [cMusicManager] num_params 2 pop 0 [track] [bPlayInFrontend]</p>
<p>define function cMusicManager__PlayFrontEndTrack&lt;thiscall, 0x57E2E0&gt;(track, bPlayInFrontend)</p>
<h4>cMusicManager::PlayPreloadedCutSceneMusic</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::PlayPreloadedCutSceneMusic), this);</p>
<p>0AA6: call_method 0x57E290 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__PlayPreloadedCutSceneMusic&lt;thiscall, 0x57E290&gt;()</p>
<h4>cMusicManager::PlayerInCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::PlayerInCar), this);</p>
<p>0AA8: call_method_return 0x57E4B0 struct [cMusicManager] num_params 0 pop 0 func_ret [bool]</p>
<h4>cMusicManager::PreloadCutSceneMusic</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned char>(gaddrof(cMusicManager::PreloadCutSceneMusic), this, sound);</p>
<p>0AA6: call_method 0x57E210 struct [cMusicManager] num_params 1 pop 0 [sound]</p>
<p>define function cMusicManager__PreloadCutSceneMusic&lt;thiscall, 0x57E210&gt;(sound)</p>
<h4>cMusicManager::ResetMusicAfterReload</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ResetMusicAfterReload), this);</p>
<p>0AA6: call_method 0x57CF30 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__ResetMusicAfterReload&lt;thiscall, 0x57CF30&gt;()</p>
<h4>cMusicManager::ResetTimers</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned int>(gaddrof(cMusicManager::ResetTimers), this, time);</p>
<p>0AA6: call_method 0x57D420 struct [cMusicManager] num_params 1 pop 0 [time]</p>
<p>define function cMusicManager__ResetTimers&lt;thiscall, 0x57D420&gt;(time)</p>
<h4>cMusicManager::Service</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Service), this);</p>
<p>0AA6: call_method 0x57D440 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__Service&lt;thiscall, 0x57D440&gt;()</p>
<h4>cMusicManager::ServiceAmbience</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceAmbience), this);</p>
<p>0AA6: call_method 0x57DCB0 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__ServiceAmbience&lt;thiscall, 0x57DCB0&gt;()</p>
<h4>cMusicManager::ServiceAnnouncement</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *>(gaddrof(cMusicManager::ServiceAnnouncement), this);</p>
<p>0AA8: call_method_return 0x57DFC0 struct [cMusicManager] num_params 0 pop 0 func_ret [bool]</p>
<h4>cMusicManager::ServiceFrontEndMode</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceFrontEndMode), this);</p>
<p>0AA6: call_method 0x57D530 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__ServiceFrontEndMode&lt;thiscall, 0x57D530&gt;()</p>
<h4>cMusicManager::ServiceGameMode</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceGameMode), this);</p>
<p>0AA6: call_method 0x57D690 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__ServiceGameMode&lt;thiscall, 0x57D690&gt;()</p>
<h4>cMusicManager::ServiceTrack</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::ServiceTrack), this);</p>
<p>0AA6: call_method 0x57E100 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__ServiceTrack&lt;thiscall, 0x57E100&gt;()</p>
<h4>cMusicManager::SetRadioChannelByScript</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned char, int>(gaddrof(cMusicManager::SetRadioChannelByScript), this, station, position);</p>
<p>0AA6: call_method 0x57D180 struct [cMusicManager] num_params 2 pop 0 [station] [position]</p>
<p>define function cMusicManager__SetRadioChannelByScript&lt;thiscall, 0x57D180&gt;(station, position)</p>
<h4>cMusicManager::SetRadioInCar</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *, unsigned int>(gaddrof(cMusicManager::SetRadioInCar), this, radioStation);</p>
<p>0AA6: call_method 0x57D2C0 struct [cMusicManager] num_params 1 pop 0 [radioStation]</p>
<p>define function cMusicManager__SetRadioInCar&lt;thiscall, 0x57D2C0&gt;(radioStation)</p>
<h4>cMusicManager::StopCutSceneMusic</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::StopCutSceneMusic), this);</p>
<p>0AA6: call_method 0x57E2B0 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__StopCutSceneMusic&lt;thiscall, 0x57E2B0&gt;()</p>
<h4>cMusicManager::StopFrontEndTrack</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::StopFrontEndTrack), this);</p>
<p>0AA6: call_method 0x57E3D0 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__StopFrontEndTrack&lt;thiscall, 0x57E3D0&gt;()</p>
<h4>cMusicManager::Terminate</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(gaddrof(cMusicManager::Terminate), this);</p>
<p>0AA6: call_method 0x57D140 struct [cMusicManager] num_params 0 pop 0</p>
<p>define function cMusicManager__Terminate&lt;thiscall, 0x57D140&gt;()</p>
<h4>cMusicManager::UsesPoliceRadio</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, cMusicManager *, CVehicle *>(gaddrof(cMusicManager::UsesPoliceRadio), this, vehicle);</p>
<p>0AA8: call_method_return 0x57E6A0 struct [cMusicManager] num_params 1 pop 0 [vehicle] func_ret [bool]</p><h3 id="plugin_iiigame_iiicobjectcpp">plugin_III\game_III\CObject.cpp</h3><h4>CObject::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CObject *>(this);</p>
<h4>CObject::Teleport</h4>
<p>plugin::CallVirtualMethod<11, CObject *, CVector>(this, pos);</p>
<h4>CObject::Render</h4>
<p>plugin::CallVirtualMethod<13, CObject *>(this);</p>
<h4>CObject::SetupLighting</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 14, CObject *>(this);</p>
<h4>CObject::RemoveLighting</h4>
<p>plugin::CallVirtualMethod<15, CObject *, bool>(this, resetWorldColors);</p>
<h4>CObject::CanBeDeleted</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CObject *>(gaddrof(CObject::CanBeDeleted), this);</p>
<p>0AA8: call_method_return 0x4BB010 struct [CObject] num_params 0 pop 0 func_ret [bool]</p>
<h4>CObject::Init</h4>
<p>plugin::CallMethodDynGlobal<CObject *>(gaddrof(CObject::Init), this);</p>
<p>0AA6: call_method 0x4BAEC0 struct [CObject] num_params 0 pop 0</p>
<p>define function CObject__Init&lt;thiscall, 0x4BAEC0&gt;()</p>
<h4>CObject::ObjectDamage</h4>
<p>plugin::CallMethodDynGlobal<CObject *, float>(gaddrof(CObject::ObjectDamage), this, amount);</p>
<p>0AA6: call_method 0x4BB240 struct [CObject] num_params 1 pop 0 [amount]</p>
<p>define function CObject__ObjectDamage&lt;thiscall, 0x4BB240&gt;(amount)</p>
<h4>CObject::RefModelInfo</h4>
<p>plugin::CallMethodDynGlobal<CObject *, int>(gaddrof(CObject::RefModelInfo), this, modelIndex);</p>
<p>0AA6: call_method 0x4BBD80 struct [CObject] num_params 1 pop 0 [modelIndex]</p>
<p>define function CObject__RefModelInfo&lt;thiscall, 0x4BBD80&gt;(modelIndex)</p>
<h4>CObject::DeleteAllTempObjectsInArea</h4>
<p>plugin::CallDynGlobal<CVector, float>(gaddrof(CObject::DeleteAllTempObjectsInArea), point, radius);</p><h3 id="plugin_iiigame_iiicobjectdatacpp">plugin_III\game_III\CObjectData.cpp</h3><h4>CObjectData::Initialise</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CObjectData::Initialise), fileName);</p>
<h4>CObjectData::SetObjectData</h4>
<p>plugin::CallDynGlobal<int, CObject &>(gaddrof(CObjectData::SetObjectData), modelIndex, object);</p><h3 id="plugin_iiigame_iiicommoncpp">plugin_III\game_III\common.cpp</h3><h4>FindPlayerHeading</h4>
<p>plugin::CallAndReturn<float, 0x4A1220>();</p>
<p>0AA7: call_function_return 0x4A1220 num_params 0 pop 0 func_ret [float]</p>
<p>define function FindPlayerHeading&lt;cdecl, 0x4A1220&gt;(): float</p>
<h4>FindPlayerCentreOfWorld_NoSniperShift</h4>
<p>plugin::CallAndReturn<CVector&, 0x4A11C0>();</p>
<p>0AA7: call_function_return 0x4A11C0 num_params 0 pop 0 func_ret [CVector&amp;]</p>
<p>define function FindPlayerCentreOfWorld_NoSniperShift&lt;cdecl, 0x4A11C0&gt;(): int</p>
<h4>FindPlayerCentreOfWorld</h4>
<p>plugin::CallAndReturn<CVector&, 0x4A1170, int>(playerId);</p>
<p>0AA7: call_function_return 0x4A1170 num_params 1 pop 1 [playerId] func_ret [CVector&amp;]</p>
<p>define function FindPlayerCentreOfWorld&lt;cdecl, 0x4A1170&gt;(playerId): int</p>
<h4>FindPlayerPed</h4>
<p>plugin::CallAndReturn<CPlayerPed*, 0x4A1150>();</p>
<p>0AA7: call_function_return 0x4A1150 num_params 0 pop 0 func_ret [CPlayerPed*]</p>
<p>define function FindPlayerPed&lt;cdecl, 0x4A1150&gt;(): int</p>
<h4>FindPlayerTrain</h4>
<p>plugin::CallAndReturn<CTrain*, 0x4A1120>();</p>
<p>0AA7: call_function_return 0x4A1120 num_params 0 pop 0 func_ret [CTrain*]</p>
<p>define function FindPlayerTrain&lt;cdecl, 0x4A1120&gt;(): int</p>
<h4>FindPlayerEntity</h4>
<p>plugin::CallAndReturn<CEntity*, 0x4A10F0>();</p>
<p>0AA7: call_function_return 0x4A10F0 num_params 0 pop 0 func_ret [CEntity*]</p>
<p>define function FindPlayerEntity&lt;cdecl, 0x4A10F0&gt;(): int</p>
<h4>FindPlayerVehicle</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x4A10C0>();</p>
<p>0AA7: call_function_return 0x4A10C0 num_params 0 pop 0 func_ret [CVehicle*]</p>
<p>define function FindPlayerVehicle&lt;cdecl, 0x4A10C0&gt;(): int</p>
<h4>FindPlayerSpeed</h4>
<p>plugin::CallAndReturn<CVector&, 0x4A1090>();</p>
<p>0AA7: call_function_return 0x4A1090 num_params 0 pop 0 func_ret [CVector&amp;]</p>
<p>define function FindPlayerSpeed&lt;cdecl, 0x4A1090&gt;(): int</p>
<h4>FindPlayerCoors</h4>
<p>plugin::CallAndReturn<CVector&, 0x4A1030>();</p>
<p>0AA7: call_function_return 0x4A1030 num_params 0 pop 0 func_ret [CVector&amp;]</p>
<p>define function FindPlayerCoors&lt;cdecl, 0x4A1030&gt;(): int</p>
<h4>GetFirstTexture</h4>
<p>plugin::CallAndReturn<RwTexture<em>, 0x5264E0, RwTexDictionary</em>>(texDictionary);</p>
<p>0AA7: call_function_return 0x5264E0 num_params 1 pop 1 [texDictionary] func_ret [RwTexture*]</p>
<p>define function GetFirstTexture&lt;cdecl, 0x5264E0&gt;(texDictionary): int</p>
<h4>GetFirstObject</h4>
<p>plugin::CallAndReturn<RwObject<em>, 0x526460, RwFrame</em>>(frame);</p>
<p>0AA7: call_function_return 0x526460 num_params 1 pop 1 [frame] func_ret [RwObject*]</p>
<p>define function GetFirstObject&lt;cdecl, 0x526460&gt;(frame): int</p>
<h4>GetFirstAtomic</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x526420, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x526420 num_params 1 pop 1 [clump] func_ret [RpAtomic*]</p>
<p>define function GetFirstAtomic&lt;cdecl, 0x526420&gt;(clump): int</p>
<h4>SetAmbientColours</h4>
<p>plugin::Call<0x526FA0, RwRGBAReal*>(colours);</p>
<p>0AA5: call_function 0x526FA0 num_params 1 pop 1 [colours]</p>
<p>define function SetAmbientColours&lt;cdecl, 0x526FA0&gt;(colours)</p>
<h4>SetAmbientColoursForPedsCarsAndObjects</h4>
<p>plugin::Call<0x526F80>();</p>
<p>0AA5: call_function 0x526F80 num_params 0 pop 0</p>
<p>define function SetAmbientColoursForPedsCarsAndObjects&lt;cdecl, 0x526F80&gt;()</p>
<h4>SetAmbientColours</h4>
<p>plugin::Call<0x526F60>();</p>
<p>0AA5: call_function 0x526F60 num_params 0 pop 0</p>
<p>define function SetAmbientColours&lt;cdecl, 0x526F60&gt;()</p>
<h4>ActivateDirectional</h4>
<p>plugin::Call<0x526F50>();</p>
<p>0AA5: call_function 0x526F50 num_params 0 pop 0</p>
<p>define function ActivateDirectional&lt;cdecl, 0x526F50&gt;()</p>
<h4>DeActivateDirectional</h4>
<p>plugin::Call<0x526F40>();</p>
<p>0AA5: call_function 0x526F40 num_params 0 pop 0</p>
<p>define function DeActivateDirectional&lt;cdecl, 0x526F40&gt;()</p>
<h4>ReSetAmbientAndDirectionalColours</h4>
<p>plugin::Call<0x526F10>();</p>
<p>0AA5: call_function 0x526F10 num_params 0 pop 0</p>
<p>define function ReSetAmbientAndDirectionalColours&lt;cdecl, 0x526F10&gt;()</p>
<h4>SetBrightMarkerColours</h4>
<p>plugin::Call<0x526E60, float>(power);</p>
<p>0AA5: call_function 0x526E60 num_params 1 pop 1 [power]</p>
<p>define function SetBrightMarkerColours&lt;cdecl, 0x526E60&gt;(power)</p>
<h4>SetAmbientAndDirectionalColours</h4>
<p>plugin::Call<0x526DE0, float>(power);</p>
<p>0AA5: call_function 0x526DE0 num_params 1 pop 1 [power]</p>
<p>define function SetAmbientAndDirectionalColours&lt;cdecl, 0x526DE0&gt;(power)</p>
<h4>RemoveExtraDirectionalLights</h4>
<p>plugin::Call<0x526DB0, RpWorld*>(world);</p>
<p>0AA5: call_function 0x526DB0 num_params 1 pop 1 [world]</p>
<p>define function RemoveExtraDirectionalLights&lt;cdecl, 0x526DB0&gt;(world)</p>
<h4>AddAnExtraDirectionalLight</h4>
<p>plugin::Call<0x526C70, RpWorld*, float, float, float, float, float, float>(world, x, y, z, red, green, blue);</p>
<p>0AA5: call_function 0x526C70 num_params 7 pop 7 [world] [x] [y] [z] [red] [green] [blue]</p>
<p>define function AddAnExtraDirectionalLight&lt;cdecl, 0x526C70&gt;(world, x, y, z, red, green, blue)</p>
<h4>WorldReplaceNormalLightsWithScorched</h4>
<p>plugin::Call<0x526C10, RpWorld*, float>(world, intensity);</p>
<p>0AA5: call_function 0x526C10 num_params 2 pop 2 [world] [intensity]</p>
<p>define function WorldReplaceNormalLightsWithScorched&lt;cdecl, 0x526C10&gt;(world, intensity)</p>
<h4>LightsDestroy</h4>
<p>plugin::CallAndReturn<RpWorld<em>, 0x526B40, RpWorld</em>>(world);</p>
<p>0AA7: call_function_return 0x526B40 num_params 1 pop 1 [world] func_ret [RpWorld*]</p>
<p>define function LightsDestroy&lt;cdecl, 0x526B40&gt;(world): int</p>
<h4>LightsCreate</h4>
<p>plugin::CallAndReturn<RpWorld<em>, 0x5269A0, RpWorld</em>>(world);</p>
<p>0AA7: call_function_return 0x5269A0 num_params 1 pop 1 [world] func_ret [RpWorld*]</p>
<p>define function LightsCreate&lt;cdecl, 0x5269A0&gt;(world): int</p>
<h4>SetLightsWithTimeOfDayColour</h4>
<p>plugin::Call<0x526510, RpWorld*>(world);</p>
<p>0AA5: call_function 0x526510 num_params 1 pop 1 [world]</p>
<p>define function SetLightsWithTimeOfDayColour&lt;cdecl, 0x526510&gt;(world)</p>
<h4>GetFirstChild</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x5264A0, RwFrame</em>>(frame);</p>
<p>0AA7: call_function_return 0x5264A0 num_params 1 pop 1 [frame] func_ret [RwFrame*]</p>
<p>define function GetFirstChild&lt;cdecl, 0x5264A0&gt;(frame): int</p>
<h4>GetFirstAtomicCallback</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x526410, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x526410 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function GetFirstAtomicCallback&lt;cdecl, 0x526410&gt;(atomic, data): int</p>
<h4>GetFirstObjectCallback</h4>
<p>plugin::CallAndReturn<RwObject<em>, 0x526450, RwObject</em>, void*>(object, data);</p>
<p>0AA7: call_function_return 0x526450 num_params 2 pop 2 [object] [data] func_ret [RwObject*]</p>
<p>define function GetFirstObjectCallback&lt;cdecl, 0x526450&gt;(object, data): int</p>
<h4>GetFirstFrameCallback</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x526490, RwFrame</em>, void*>(frame, data);</p>
<p>0AA7: call_function_return 0x526490 num_params 2 pop 2 [frame] [data] func_ret [RwFrame*]</p>
<p>define function GetFirstFrameCallback&lt;cdecl, 0x526490&gt;(frame, data): int</p>
<h4>GetFirstTextureCallback</h4>
<p>plugin::CallAndReturn<RwTexture<em>, 0x5264D0, RwTexture</em>, void*>(texture, data);</p>
<p>0AA7: call_function_return 0x5264D0 num_params 2 pop 2 [texture] [data] func_ret [RwTexture*]</p>
<p>define function GetFirstTextureCallback&lt;cdecl, 0x5264D0&gt;(texture, data): int</p>
<h4>WorldReplaceScorchedLightsWithNormal</h4>
<p>plugin::Call<0x526C50, RpWorld*>(world);</p>
<p>0AA5: call_function 0x526C50 num_params 1 pop 1 [world]</p>
<p>define function WorldReplaceScorchedLightsWithNormal&lt;cdecl, 0x526C50&gt;(world)</p>
<h4>CreateDebugFont</h4>
<p>plugin::Call<0x526300>();</p>
<p>0AA5: call_function 0x526300 num_params 0 pop 0</p>
<p>define function CreateDebugFont&lt;cdecl, 0x526300&gt;()</p>
<h4>DestroyDebugFont</h4>
<p>plugin::Call<0x526310>();</p>
<p>0AA5: call_function 0x526310 num_params 0 pop 0</p>
<p>define function DestroyDebugFont&lt;cdecl, 0x526310&gt;()</p>
<h4>FlushObrsPrintfs</h4>
<p>plugin::Call<0x526320>();</p>
<p>0AA5: call_function 0x526320 num_params 0 pop 0</p>
<p>define function FlushObrsPrintfs&lt;cdecl, 0x526320&gt;()</p>
<h4>DefinedState</h4>
<p>plugin::Call<0x526330>();</p>
<p>0AA5: call_function 0x526330 num_params 0 pop 0</p>
<p>define function DefinedState&lt;cdecl, 0x526330&gt;()</p>
<h4>RpAnimBlendClumpGetAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation*, 0x4055C0>(clump, animId);</p>
<p>0AA7: call_function_return 0x4055C0 num_params 2 pop 2 [clump] [animId] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetAssociation&lt;cdecl, 0x4055C0&gt;(clump, animId): int</p><h3 id="plugin_iiigame_iiiconesheetcpp">plugin_III\game_III\COneSheet.cpp</h3><h4>COneSheet::AddToList</h4>
<p>plugin::CallMethodDynGlobal<COneSheet *, COneSheet *>(gaddrof(COneSheet::AddToList), this, list);</p>
<p>0AA6: call_method 0x512650 struct [COneSheet] num_params 1 pop 0 [list]</p>
<p>define function COneSheet__AddToList&lt;thiscall, 0x512650&gt;(list)</p>
<h4>COneSheet::RemoveFromList</h4>
<p>plugin::CallMethodDynGlobal<COneSheet *>(gaddrof(COneSheet::RemoveFromList), this);</p>
<p>0AA6: call_method 0x512670 struct [COneSheet] num_params 0 pop 0</p>
<p>define function COneSheet__RemoveFromList&lt;thiscall, 0x512670&gt;()</p><h3 id="plugin_iiigame_iiiconscreentimercpp">plugin_III\game_III\COnscreenTimer.cpp</h3><h4>COnscreenTimer::AddClock</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, char *>(gaddrof(COnscreenTimer::AddClock), this, offset, gxt);</p>
<p>0AA6: call_method 0x429350 struct [COnscreenTimer] num_params 2 pop 0 [offset] [gxt]</p>
<p>define function COnscreenTimer__AddClock&lt;thiscall, 0x429350&gt;(offset, gxt)</p>
<h4>COnscreenTimer::AddCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned short, char *>(gaddrof(COnscreenTimer::AddCounter), this, offset, type, gxt);</p>
<p>0AA6: call_method 0x4293B0 struct [COnscreenTimer] num_params 3 pop 0 [offset] [type] [gxt]</p>
<p>define function COnscreenTimer__AddCounter&lt;thiscall, 0x4293B0&gt;(offset, type, gxt)</p>
<h4>COnscreenTimer::ClearClock</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearClock), this, offset);</p>
<p>0AA6: call_method 0x429410 struct [COnscreenTimer] num_params 1 pop 0 [offset]</p>
<p>define function COnscreenTimer__ClearClock&lt;thiscall, 0x429410&gt;(offset)</p>
<h4>COnscreenTimer::ClearCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearCounter), this, offset);</p>
<p>0AA6: call_method 0x429450 struct [COnscreenTimer] num_params 1 pop 0 [offset]</p>
<p>define function COnscreenTimer__ClearCounter&lt;thiscall, 0x429450&gt;(offset)</p>
<h4>COnscreenTimer::Init</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Init), this);</p>
<p>0AA6: call_method 0x429220 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__Init&lt;thiscall, 0x429220&gt;()</p>
<h4>COnscreenTimer::Process</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Process), this);</p>
<p>0AA6: call_method 0x429320 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__Process&lt;thiscall, 0x429320&gt;()</p>
<h4>COnscreenTimer::ProcessForDisplay</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::ProcessForDisplay), this);</p>
<p>0AA6: call_method 0x4292E0 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__ProcessForDisplay&lt;thiscall, 0x4292E0&gt;()</p><h3 id="plugin_iiigame_iiiconscreentimerentrycpp">plugin_III\game_III\COnscreenTimerEntry.cpp</h3><h4>COnscreenTimerEntry::Process</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::Process), this);</p>
<p>0AA6: call_method 0x429160 struct [COnscreenTimerEntry] num_params 0 pop 0</p>
<p>define function COnscreenTimerEntry__Process&lt;thiscall, 0x429160&gt;()</p>
<h4>COnscreenTimerEntry::ProcessForDisplay</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplay), this);</p>
<p>0AA8: call_method_return 0x429110 struct [COnscreenTimerEntry] num_params 0 pop 0 func_ret [bool]</p>
<h4>COnscreenTimerEntry::ProcessForDisplayClock</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayClock), this);</p>
<p>0AA6: call_method 0x429080 struct [COnscreenTimerEntry] num_params 0 pop 0</p>
<p>define function COnscreenTimerEntry__ProcessForDisplayClock&lt;thiscall, 0x429080&gt;()</p>
<h4>COnscreenTimerEntry::ProcessForDisplayCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayCounter), this);</p>
<p>0AA6: call_method 0x4290F0 struct [COnscreenTimerEntry] num_params 0 pop 0</p>
<p>define function COnscreenTimerEntry__ProcessForDisplayCounter&lt;thiscall, 0x4290F0&gt;()</p><h3 id="plugin_iiigame_iiicpacmanpickupcpp">plugin_III\game_III\CPacManPickup.cpp</h3><h4>CPacManPickup::Update</h4>
<p>plugin::CallMethodDynGlobal<CPacManPickup *>(gaddrof(CPacManPickup::Update), this);</p>
<p>0AA6: call_method 0x4331B0 struct [CPacManPickup] num_params 0 pop 0</p>
<p>define function CPacManPickup__Update&lt;thiscall, 0x4331B0&gt;()</p><h3 id="plugin_iiigame_iiicpacmanpickupscpp">plugin_III\game_III\CPacManPickups.cpp</h3><h4>CPacManPickups::GenerateOnePMPickUp</h4>
<p>plugin::CallDynGlobal<CVector>(gaddrof(CPacManPickups::GenerateOnePMPickUp), pos);</p>
<h4>CPacManPickups::GeneratePMPickUps</h4>
<p>plugin::CallDynGlobal<CVector, float, short, unsigned char>(gaddrof(CPacManPickups::GeneratePMPickUps), pos, scrambleMult, count, type);</p>
<h4>CPacManPickups::GeneratePMPickUpsForRace</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPacManPickups::GeneratePMPickUpsForRace), race);</p>
<h4>CPacManPickups::QueryPowerPillsCarriedByPlayer</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CPacManPickups::QueryPowerPillsCarriedByPlayer));</p>
<p>0AA7: call_function_return 0x4333F0 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CPacManPickups__QueryPowerPillsCarriedByPlayer&lt;cdecl, 0x4333F0&gt;(): int</p>
<h4>CPacManPickups::QueryPowerPillsEatenInRace</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CPacManPickups::QueryPowerPillsEatenInRace));</p>
<p>0AA7: call_function_return 0x4333A0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CPacManPickups__QueryPowerPillsEatenInRace&lt;cdecl, 0x4333A0&gt;(): int</p>
<h4>CPacManPickups::StartPacManRace</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPacManPickups::StartPacManRace), race);</p>
<h4>CPacManPickups::StartPacManScramble</h4>
<p>plugin::CallDynGlobal<CVector, float, short>(gaddrof(CPacManPickups::StartPacManScramble), pos, scrambleMult, count);</p><h3 id="plugin_iiigame_iiicpadcpp">plugin_III\game_III\CPad.cpp</h3><h4>CPad::AddToPCCheatString</h4>
<p>plugin::CallMethod<0x492450, CPad *, char>(this, name);</p>
<p>0AA6: call_method 0x492450 struct [CPad] num_params 1 pop 0 [name]</p>
<p>define function CPad__AddToPCCheatString&lt;thiscall, 0x492450&gt;(name)</p>
<h4>CPad::CPad</h4>
<p>plugin::CallMethod<0x494EE0, CPad *>(this);</p>
<p>0AA6: call_method 0x494EE0 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__CPad&lt;thiscall, 0x494EE0&gt;()</p>
<h4>CPad::CarGunJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4934F0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4934F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CarGunJustDown&lt;thiscall, 0x4934F0&gt;(): int</p>
<h4>CPad::ChangeStationJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493870, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493870 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ChangeStationJustDown&lt;thiscall, 0x493870&gt;(): int</p>
<h4>CPad::Clear</h4>
<p>plugin::CallMethod<0x491A10, CPad *, bool>(this, enable);</p>
<p>0AA6: call_method 0x491A10 struct [CPad] num_params 1 pop 0 [enable]</p>
<p>define function CPad__Clear&lt;thiscall, 0x491A10&gt;(enable)</p>
<h4>CPad::ClearMouseHistory</h4>
<p>plugin::CallMethod<0x491B50, CPad *>(this);</p>
<p>0AA6: call_method 0x491B50 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__ClearMouseHistory&lt;thiscall, 0x491B50&gt;()</p>
<h4>CPad::CycleCameraModeDownJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493830, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493830 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CycleCameraModeDownJustDown&lt;thiscall, 0x493830&gt;(): int</p>
<h4>CPad::CycleCameraModeUpJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4937D0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4937D0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CycleCameraModeUpJustDown&lt;thiscall, 0x4937D0&gt;(): int</p>
<h4>CPad::CycleWeaponLeftJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493910, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493910 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CycleWeaponLeftJustDown&lt;thiscall, 0x493910&gt;(): int</p>
<h4>CPad::CycleWeaponRightJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493940, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493940 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CycleWeaponRightJustDown&lt;thiscall, 0x493940&gt;(): int</p>
<h4>CPad::DoCheats</h4>
<p>plugin::CallMethod<0x492F20, CPad *, short>(this, arg0);</p>
<p>0AA6: call_method 0x492F20 struct [CPad] num_params 1 pop 0 [arg0]</p>
<p>define function CPad__DoCheats&lt;thiscall, 0x492F20&gt;(arg0)</p>
<h4>CPad::DoCheats</h4>
<p>plugin::Call<0x492F00>();</p>
<p>0AA5: call_function 0x492F00 num_params 0 pop 0</p>
<p>define function CPad__DoCheats&lt;cdecl, 0x492F00&gt;()</p>
<h4>CPad::EditCodesForControls</h4>
<p>plugin::Call<0x494690, int*>(arg0);</p>
<p>0AA5: call_function 0x494690 num_params 1 pop 1 [arg0]</p>
<p>define function CPad__EditCodesForControls&lt;cdecl, 0x494690&gt;(arg0)</p>
<h4>CPad::EditString</h4>
<p>plugin::Call<0x4944B0, char*, int>(name, arg1);</p>
<p>0AA5: call_function 0x4944B0 num_params 2 pop 2 [name] [arg1]</p>
<p>define function CPad__EditString&lt;cdecl, 0x4944B0&gt;(name, arg1)</p>
<h4>CPad::ExitVehicleJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493650, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493650 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ExitVehicleJustDown&lt;thiscall, 0x493650&gt;(): int</p>
<h4>CPad::ForceCameraBehindPlayer</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493D80, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493D80 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ForceCameraBehindPlayer&lt;thiscall, 0x493D80&gt;(): int</p>
<h4>CPad::GetAccelerate</h4>
<p>plugin::CallMethodAndReturn<short, 0x493780, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493780 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetAccelerate&lt;thiscall, 0x493780&gt;(): int</p>
<h4>CPad::GetAnaloguePadDown</h4>
<p>plugin::CallAndReturn<bool, 0x493BA0>();</p>
<p>0AA7: call_function_return 0x493BA0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAnaloguePadDown&lt;cdecl, 0x493BA0&gt;(): int</p>
<h4>CPad::GetAnaloguePadLeft</h4>
<p>plugin::CallAndReturn<bool, 0x493C00>();</p>
<p>0AA7: call_function_return 0x493C00 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAnaloguePadLeft&lt;cdecl, 0x493C00&gt;(): int</p>
<h4>CPad::GetAnaloguePadLeftJustUp</h4>
<p>plugin::CallAndReturn<bool, 0x493CC0>();</p>
<p>0AA7: call_function_return 0x493CC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAnaloguePadLeftJustUp&lt;cdecl, 0x493CC0&gt;(): int</p>
<h4>CPad::GetAnaloguePadRight</h4>
<p>plugin::CallAndReturn<bool, 0x493C60>();</p>
<p>0AA7: call_function_return 0x493C60 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAnaloguePadRight&lt;cdecl, 0x493C60&gt;(): int</p>
<h4>CPad::GetAnaloguePadRightJustUp</h4>
<p>plugin::CallAndReturn<bool, 0x493D20>();</p>
<p>0AA7: call_function_return 0x493D20 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAnaloguePadRightJustUp&lt;cdecl, 0x493D20&gt;(): int</p>
<h4>CPad::GetAnaloguePadUp</h4>
<p>plugin::CallAndReturn<bool, 0x493B40>();</p>
<p>0AA7: call_function_return 0x493B40 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAnaloguePadUp&lt;cdecl, 0x493B40&gt;(): int</p>
<h4>CPad::GetAnalogueUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x493210, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493210 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetAnalogueUpDown&lt;thiscall, 0x493210&gt;(): int</p>
<h4>CPad::GetBrake</h4>
<p>plugin::CallMethodAndReturn<short, 0x4935A0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4935A0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetBrake&lt;thiscall, 0x4935A0&gt;(): int</p>
<h4>CPad::GetCarGunFired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493490, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493490 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetCarGunFired&lt;thiscall, 0x493490&gt;(): int</p>
<h4>CPad::GetCarGunLeftRight</h4>
<p>plugin::CallMethodAndReturn<short, 0x4930C0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4930C0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetCarGunLeftRight&lt;thiscall, 0x4930C0&gt;(): int</p>
<h4>CPad::GetCarGunUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x493070, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493070 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetCarGunUpDown&lt;thiscall, 0x493070&gt;(): int</p>
<h4>CPad::GetExitVehicle</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4935F0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4935F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetExitVehicle&lt;thiscall, 0x4935F0&gt;(): int</p>
<h4>CPad::GetHandBrake</h4>
<p>plugin::CallMethodAndReturn<short, 0x493560, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493560 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetHandBrake&lt;thiscall, 0x493560&gt;(): int</p>
<h4>CPad::GetHorn</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493350, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493350 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetHorn&lt;thiscall, 0x493350&gt;(): int</p>
<h4>CPad::GetLookBehindForCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4932F0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4932F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookBehindForCar&lt;thiscall, 0x4932F0&gt;(): int</p>
<h4>CPad::GetLookBehindForPed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493320, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493320 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookBehindForPed&lt;thiscall, 0x493320&gt;(): int</p>
<h4>CPad::GetLookLeft</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493290, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493290 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookLeft&lt;thiscall, 0x493290&gt;(): int</p>
<h4>CPad::GetLookRight</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4932C0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4932C0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookRight&lt;thiscall, 0x4932C0&gt;(): int</p>
<h4>CPad::GetPad</h4>
<p>plugin::CallAndReturn<CPad*, 0x492F60, int>(padNumber);</p>
<p>0AA7: call_function_return 0x492F60 num_params 1 pop 1 [padNumber] func_ret [CPad*]</p>
<p>define function CPad__GetPad&lt;cdecl, 0x492F60&gt;(padNumber): int</p>
<h4>CPad::GetPedWalkLeftRight</h4>
<p>plugin::CallMethodAndReturn<short, 0x493110, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493110 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetPedWalkLeftRight&lt;thiscall, 0x493110&gt;(): int</p>
<h4>CPad::GetPedWalkUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x493190, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493190 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetPedWalkUpDown&lt;thiscall, 0x493190&gt;(): int</p>
<h4>CPad::GetSprint</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493A70, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493A70 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetSprint&lt;thiscall, 0x493A70&gt;(): int</p>
<h4>CPad::GetSteeringLeftRight</h4>
<p>plugin::CallMethodAndReturn<short, 0x492F70, CPad *>(this);</p>
<p>0AA8: call_method_return 0x492F70 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetSteeringLeftRight&lt;thiscall, 0x492F70&gt;(): int</p>
<h4>CPad::GetSteeringUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x492FF0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x492FF0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetSteeringUpDown&lt;thiscall, 0x492FF0&gt;(): int</p>
<h4>CPad::GetTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493970, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493970 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetTarget&lt;thiscall, 0x493970&gt;(): int</p>
<h4>CPad::GetWeapon</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4936C0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4936C0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetWeapon&lt;thiscall, 0x4936C0&gt;(): int</p>
<h4>CPad::HornJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4933F0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4933F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__HornJustDown&lt;thiscall, 0x4933F0&gt;(): int</p>
<h4>CPad::JumpJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493A40, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493A40 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__JumpJustDown&lt;thiscall, 0x493A40&gt;(): int</p>
<h4>CPad::LookAroundLeftRight</h4>
<p>plugin::CallMethodAndReturn<int, 0x493F80, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493F80 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPad__LookAroundLeftRight&lt;thiscall, 0x493F80&gt;(): int</p>
<h4>CPad::LookAroundUpDown</h4>
<p>plugin::CallMethodAndReturn<int, 0x494130, CPad *>(this);</p>
<p>0AA8: call_method_return 0x494130 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPad__LookAroundUpDown&lt;thiscall, 0x494130&gt;(): int</p>
<h4>CPad::PrintErrorMessage</h4>
<p>plugin::Call<0x4942B0>();</p>
<p>0AA5: call_function 0x4942B0 num_params 0 pop 0</p>
<p>define function CPad__PrintErrorMessage&lt;cdecl, 0x4942B0&gt;()</p>
<h4>CPad::ProcessPCSpecificStuff</h4>
<p>plugin::CallMethod<0x492C60, CPad *>(this);</p>
<p>0AA6: call_method 0x492C60 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__ProcessPCSpecificStuff&lt;thiscall, 0x492C60&gt;()</p>
<h4>CPad::ReconcileTwoControllersInput</h4>
<p>plugin::CallMethod<0x491E60, CPad *, CControllerState const&, CControllerState const&>(this, controllerA, controllerB);</p>
<p>0AA6: call_method 0x491E60 struct [CPad] num_params 2 pop 0 [controllerA] [controllerB]</p>
<p>define function CPad__ReconcileTwoControllersInput&lt;thiscall, 0x491E60&gt;(controllerA, controllerB)</p>
<h4>CPad::ResetAverageWeapon</h4>
<p>plugin::CallMethod<0x494290, CPad *>(this);</p>
<p>0AA6: call_method 0x494290 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__ResetAverageWeapon&lt;thiscall, 0x494290&gt;()</p>
<h4>CPad::ResetCheats</h4>
<p>plugin::Call<0x494450>();</p>
<p>0AA5: call_function 0x494450 num_params 0 pop 0</p>
<p>define function CPad__ResetCheats&lt;cdecl, 0x494450&gt;()</p>
<h4>CPad::ShiftTargetLeftJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493AE0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493AE0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ShiftTargetLeftJustDown&lt;thiscall, 0x493AE0&gt;(): int</p>
<h4>CPad::ShiftTargetRightJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493B10, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493B10 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ShiftTargetRightJustDown&lt;thiscall, 0x493B10&gt;(): int</p>
<h4>CPad::SniperModeLookLeftRight</h4>
<p>plugin::CallMethodAndReturn<short, 0x493EE0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493EE0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__SniperModeLookLeftRight&lt;thiscall, 0x493EE0&gt;(): int</p>
<h4>CPad::SniperModeLookUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x493F30, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493F30 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__SniperModeLookUpDown&lt;thiscall, 0x493F30&gt;(): int</p>
<h4>CPad::SniperZoomIn</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493E00, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493E00 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__SniperZoomIn&lt;thiscall, 0x493E00&gt;(): int</p>
<h4>CPad::SniperZoomOut</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493E70, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493E70 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__SniperZoomOut&lt;thiscall, 0x493E70&gt;(): int</p>
<h4>CPad::StartShake</h4>
<p>plugin::CallMethod<0x492230, CPad *, short, unsigned char>(this, time, frequency);</p>
<p>0AA6: call_method 0x492230 struct [CPad] num_params 2 pop 0 [time] [frequency]</p>
<p>define function CPad__StartShake&lt;thiscall, 0x492230&gt;(time, frequency)</p>
<h4>CPad::StartShake_Distance</h4>
<p>plugin::CallMethod<0x492290, CPad *, short, unsigned char, float, float, float>(this, time, frequency, x, y, z);</p>
<p>0AA6: call_method 0x492290 struct [CPad] num_params 5 pop 0 [time] [frequency] [x] [y] [z]</p>
<p>define function CPad__StartShake_Distance&lt;thiscall, 0x492290&gt;(time, frequency, x, y, z)</p>
<h4>CPad::StartShake_Train</h4>
<p>plugin::CallMethod<0x492360, CPad *, float, float>(this, x, y);</p>
<p>0AA6: call_method 0x492360 struct [CPad] num_params 2 pop 0 [x] [y]</p>
<p>define function CPad__StartShake_Train&lt;thiscall, 0x492360&gt;(x, y)</p>
<h4>CPad::StopPadsShaking</h4>
<p>plugin::Call<0x492F30>();</p>
<p>0AA5: call_function 0x492F30 num_params 0 pop 0</p>
<p>define function CPad__StopPadsShaking&lt;cdecl, 0x492F30&gt;()</p>
<h4>CPad::StopShaking</h4>
<p>plugin::CallMethod<0x492F50, CPad *, short>(this, arg0);</p>
<p>0AA6: call_method 0x492F50 struct [CPad] num_params 1 pop 0 [arg0]</p>
<p>define function CPad__StopShaking&lt;thiscall, 0x492F50&gt;(arg0)</p>
<h4>CPad::TargetJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4939D0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x4939D0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__TargetJustDown&lt;thiscall, 0x4939D0&gt;(): int</p>
<h4>CPad::Update</h4>
<p>plugin::CallMethod<0x492C70, CPad *>(this);</p>
<p>0AA6: call_method 0x492C70 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__Update&lt;thiscall, 0x492C70&gt;()</p>
<h4>CPad::UpdateMouse</h4>
<p>plugin::CallMethod<0x491CA0, CPad *>(this);</p>
<p>0AA6: call_method 0x491CA0 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__UpdateMouse&lt;thiscall, 0x491CA0&gt;()</p>
<h4>CPad::UpdatePads</h4>
<p>plugin::Call<0x492720>();</p>
<p>0AA5: call_function 0x492720 num_params 0 pop 0</p>
<p>define function CPad__UpdatePads&lt;cdecl, 0x492720&gt;()</p>
<h4>CPad::WeaponJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x493700, CPad *>(this);</p>
<p>0AA8: call_method_return 0x493700 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__WeaponJustDown&lt;thiscall, 0x493700&gt;(): int</p>
<h4>CPad::~CPad</h4>
<p>plugin::CallMethod<0x494ED0, CPad *>(this);</p>
<p>0AA6: call_method 0x494ED0 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__~CPad&lt;thiscall, 0x494ED0&gt;()</p><h3 id="plugin_iiigame_iiicpagercpp">plugin_III\game_III\CPager.cpp</h3><h4>CPager::Init</h4>
<p>plugin::CallMethod<0x52B6F0, CPager *>(this);</p>
<p>0AA6: call_method 0x52B6F0 struct [CPager] num_params 0 pop 0</p>
<p>define function CPager__Init&lt;thiscall, 0x52B6F0&gt;()</p>
<h4>CPager::Process</h4>
<p>plugin::CallMethod<0x52B740, CPager *>(this);</p>
<p>0AA6: call_method 0x52B740 struct [CPager] num_params 0 pop 0</p>
<p>define function CPager__Process&lt;thiscall, 0x52B740&gt;()</p>
<h4>CPager::Display</h4>
<p>plugin::CallMethod<0x52B890, CPager *>(this);</p>
<p>0AA6: call_method 0x52B890 struct [CPager] num_params 0 pop 0</p>
<p>define function CPager__Display&lt;thiscall, 0x52B890&gt;()</p>
<h4>CPager::AddMessage</h4>
<p>plugin::CallMethod<0x52B940, CPager <em>, wchar_t</em>, unsigned short, unsigned short, unsigned short>(this, text, speed, priority, arg3);</p>
<p>0AA6: call_method 0x52B940 struct [CPager] num_params 4 pop 0 [text] [speed] [priority] [arg3]</p>
<p>define function CPager__AddMessage&lt;thiscall, 0x52B940&gt;(text, speed, priority, arg3)</p>
<h4>CPager::AddMessageWithNumber</h4>
<p>plugin::CallMethod<0x52BB50, CPager <em>, wchar_t</em>, int, int, int, int, int, int, unsigned short, unsigned short, unsigned short>(this, text, n1, n2, n3, n4, n5, n6, speed, priority, arg9);</p>
<p>0AA6: call_method 0x52BB50 struct [CPager] num_params 10 pop 0 [text] [n1] [n2] [n3] [n4] [n5] [n6] [speed] [priority] [arg9]</p>
<p>define function CPager__AddMessageWithNumber&lt;thiscall, 0x52BB50&gt;(text, n1, n2, n3, n4, n5, n6, speed, priority, arg9)</p>
<h4>CPager::ClearMessages</h4>
<p>plugin::CallMethod<0x52BE00, CPager *>(this);</p>
<p>0AA6: call_method 0x52BE00 struct [CPager] num_params 0 pop 0</p>
<p>define function CPager__ClearMessages&lt;thiscall, 0x52BE00&gt;()</p>
<h4>CPager::RestartCurrentMessage</h4>
<p>plugin::CallMethod<0x52BE50, CPager *>(this);</p>
<p>0AA6: call_method 0x52BE50 struct [CPager] num_params 0 pop 0</p>
<p>define function CPager__RestartCurrentMessage&lt;thiscall, 0x52BE50&gt;()</p><h3 id="plugin_iiigame_iiicparticlecpp">plugin_III\game_III\CParticle.cpp</h3><h4>CParticle::AddJetExplosion</h4>
<p>plugin::CallDynGlobal<CVector const &, float, float>(gaddrof(CParticle::AddJetExplosion), pos, power, size);</p>
<h4>*CParticle::AddParticle</h4>
<p>plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle <em>(</em>)(tParticleType, CVector const &amp;, CVector const &amp;, CEntity *, float, int, int, int, int)), type, pos, direction, entity, size, rotationSpeed, rotation, currentFrame, lifeSpan);</p>
<p>0AA7: call_function_return 0x50D190 num_params 9 pop 9 [type] [pos] [direction] [entity] [size] [rotationSpeed] [rotation] [currentFrame] [lifeSpan] func_ret [CParticle *]</p>
<p>define function CParticle__AddParticle&lt;cdecl, 0x50D190&gt;(type, pos, direction, entity, size, rotationSpeed, rotation, currentFrame, lifeSpan): int</p>
<h4>*CParticle::AddParticle</h4>
<p>plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const &, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle <em>(</em>)(tParticleType, CVector const &amp;, CVector const &amp;, CEntity *, float, RwRGBA const &amp;, int, int, int, int)), type, pos, direction, entity, size, color, rotationSpeed, rotation, currentFrame, lifeSpan);</p>
<p>0AA7: call_function_return 0x50D190 num_params 10 pop 10 [type] [pos] [direction] [entity] [size] [color] [rotationSpeed] [rotation] [currentFrame] [lifeSpan] func_ret [CParticle *]</p>
<p>define function CParticle__AddParticle&lt;cdecl, 0x50D190&gt;(type, pos, direction, entity, size, color, rotationSpeed, rotation, currentFrame, lifeSpan): int</p>
<h4>CParticle::AddYardieDoorSmoke</h4>
<p>plugin::CallDynGlobal<CVector const &, CMatrix const &>(gaddrof(CParticle::AddYardieDoorSmoke), pos, matrix);</p>
<h4>CParticle::RemovePSystem</h4>
<p>plugin::CallDynGlobal<tParticleType>(gaddrof(CParticle::RemovePSystem), type);</p>
<h4>CParticle::RemoveParticle</h4>
<p>plugin::CallDynGlobal<CParticle *, CParticle *, tParticleSystemData *>(gaddrof(CParticle::RemoveParticle), particle, previousParticle, particleSystem);</p><h3 id="plugin_iiigame_iiicparticleobjectcpp">plugin_III\game_III\CParticleObject.cpp</h3><h4>CParticleObject::RemoveObject</h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::RemoveObject), this);</p>
<p>0AA6: call_method 0x4BC9F0 struct [CParticleObject] num_params 0 pop 0</p>
<p>define function CParticleObject__RemoveObject&lt;thiscall, 0x4BC9F0&gt;()</p>
<h4>CParticleObject::UpdateClose</h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::UpdateClose), this);</p>
<p>0AA6: call_method 0x4BCA80 struct [CParticleObject] num_params 0 pop 0</p>
<p>define function CParticleObject__UpdateClose&lt;thiscall, 0x4BCA80&gt;()</p>
<h4>CParticleObject::UpdateFar</h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(gaddrof(CParticleObject::UpdateFar), this);</p>
<p>0AA6: call_method 0x4BF9F0 struct [CParticleObject] num_params 0 pop 0</p>
<p>define function CParticleObject__UpdateFar&lt;thiscall, 0x4BF9F0&gt;()</p>
<h4>*CParticleObject::AddObject</h4>
<p>plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject <em>(</em>)(unsigned short, CVector const &amp;, unsigned char)), type, pos, remove);</p>
<p>0AA7: call_function_return 0x4BC5B0 num_params 3 pop 3 [type] [pos] [remove] func_ret [CParticleObject *]</p>
<p>define function CParticleObject__AddObject&lt;cdecl, 0x4BC5B0&gt;(type, pos, remove): int</p>
<h4>*CParticleObject::AddObject</h4>
<p>plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, float, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject <em>(</em>)(unsigned short, CVector const &amp;, float, unsigned char)), type, pos, size, remove);</p>
<p>0AA7: call_function_return 0x4BC5B0 num_params 4 pop 4 [type] [pos] [size] [remove] func_ret [CParticleObject *]</p>
<p>define function CParticleObject__AddObject&lt;cdecl, 0x4BC5B0&gt;(type, pos, size, remove): int</p>
<h4>*CParticleObject::AddObject</h4>
<p>plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, CVector const &, float, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject <em>(</em>)(unsigned short, CVector const &amp;, CVector const &amp;, float, unsigned char)), type, pos, target, size, remove);</p>
<p>0AA7: call_function_return 0x4BC5B0 num_params 5 pop 5 [type] [pos] [target] [size] [remove] func_ret [CParticleObject *]</p>
<p>define function CParticleObject__AddObject&lt;cdecl, 0x4BC5B0&gt;(type, pos, target, size, remove): int</p>
<h4>*CParticleObject::AddObject</h4>
<p>plugin::CallAndReturnDynGlobal<CParticleObject *, unsigned short, CVector const &, CVector const &, float, unsigned int, RwRGBA const &, unsigned char>(gaddrof_o(CParticleObject::AddObject, CParticleObject <em>(</em>)(unsigned short, CVector const &amp;, CVector const &amp;, float, unsigned int, RwRGBA const &amp;, unsigned char)), type, pos, target, size, lifeTime, color, remove);</p>
<p>0AA7: call_function_return 0x4BC5B0 num_params 7 pop 7 [type] [pos] [target] [size] [lifeTime] [color] [remove] func_ret [CParticleObject *]</p>
<p>define function CParticleObject__AddObject&lt;cdecl, 0x4BC5B0&gt;(type, pos, target, size, lifeTime, color, remove): int</p>
<h4>CParticleObject::LoadParticle</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CParticleObject::LoadParticle), buffer, size);</p>
<h4>CParticleObject::MoveToList</h4>
<p>plugin::CallDynGlobal<CParticleObject **, CParticleObject **, CParticleObject *>(gaddrof(CParticleObject::MoveToList), from, to, object);</p>
<h4>CParticleObject::SaveParticle</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CParticleObject::SaveParticle), buffer, size);</p><h3 id="plugin_iiigame_iiicparticlesystemmgrcpp">plugin_III\game_III\cParticleSystemMgr.cpp</h3><h4>cParticleSystemMgr::cParticleSystemMgr</h4>
<p>plugin::CallMethod<0x50FCB0, cParticleSystemMgr *>(this);</p>
<p>0AA6: call_method 0x50FCB0 struct [cParticleSystemMgr] num_params 0 pop 0</p>
<p>define function cParticleSystemMgr__cParticleSystemMgr&lt;thiscall, 0x50FCB0&gt;()</p>
<h4>cParticleSystemMgr::Initialise</h4>
<p>plugin::CallMethod<0x50FCD0, cParticleSystemMgr *>(this);</p>
<p>0AA6: call_method 0x50FCD0 struct [cParticleSystemMgr] num_params 0 pop 0</p>
<p>define function cParticleSystemMgr__Initialise&lt;thiscall, 0x50FCD0&gt;()</p>
<h4>cParticleSystemMgr::LoadParticleData</h4>
<p>plugin::CallMethod<0x50FDF0, cParticleSystemMgr *>(this);</p>
<p>0AA6: call_method 0x50FDF0 struct [cParticleSystemMgr] num_params 0 pop 0</p>
<p>define function cParticleSystemMgr__LoadParticleData&lt;thiscall, 0x50FDF0&gt;()</p><h3 id="plugin_iiigame_iiicpathfindcpp">plugin_III\game_III\CPathFind.cpp</h3><h4>CPathFind::AddNodeToList</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, CPathNode *, int>(gaddrof(CPathFind::AddNodeToList), this, node, listId);</p>
<p>0AA6: call_method 0x42CBE0 struct [CPathFind] num_params 2 pop 0 [node] [listId]</p>
<p>define function CPathFind__AddNodeToList&lt;thiscall, 0x42CBE0&gt;(node, listId)</p>
<h4>CPathFind::AllocatePathFindInfoMem</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, short>(gaddrof(CPathFind::AllocatePathFindInfoMem), this, numPathGroups);</p>
<p>0AA6: call_method 0x42D580 struct [CPathFind] num_params 1 pop 0 [numPathGroups]</p>
<p>define function CPathFind__AllocatePathFindInfoMem&lt;thiscall, 0x42D580&gt;(numPathGroups)</p>
<h4>CPathFind::CalcNodeCoors</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, short, short, short, int, CVector *>(gaddrof(CPathFind::CalcNodeCoors), this, x, y, z, id, out);</p>
<p>0AA6: call_method 0x429560 struct [CPathFind] num_params 5 pop 0 [x] [y] [z] [id] [out]</p>
<p>define function CPathFind__CalcNodeCoors&lt;thiscall, 0x429560&gt;(x, y, z, id, out)</p>
<h4>CPathFind::CalcRoadDensity</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, float, float>(gaddrof(CPathFind::CalcRoadDensity), this, x, y);</p>
<p>0AA8: call_method_return 0x42C990 struct [CPathFind] num_params 2 pop 0 [x] [y] func_ret [float]</p>
<h4>CPathFind::CountFloodFillGroups</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, unsigned char>(gaddrof(CPathFind::CountFloodFillGroups), this, type);</p>
<p>0AA6: call_method 0x42B810 struct [CPathFind] num_params 1 pop 0 [type]</p>
<p>define function CPathFind__CountFloodFillGroups&lt;thiscall, 0x42B810&gt;(type)</p>
<h4>CPathFind::DoPathSearch</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CVector, int, CVector, CPathNode **, short *, short, CVehicle *, float *, float, int>(gaddrof(CPathFind::DoPathSearch), this, type, start, startNodeId, target, nodes, numNodes, maxNumNodes, vehicle, dist, distLimit, forcedTargetNode);</p>
<p>0AA6: call_method 0x42B040 struct [CPathFind] num_params 11 pop 0 [type] [start] [startNodeId] [target] [nodes] [numNodes] [maxNumNodes] [vehicle] [dist] [distLimit] [forcedTargetNode]</p>
<p>define function CPathFind__DoPathSearch&lt;thiscall, 0x42B040&gt;(type, start, startNodeId, target, nodes, numNodes, maxNumNodes, vehicle, dist, distLimit, forcedTargetNode)</p>
<h4>CPathFind::FindNextNodeWandering</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CVector, CPathNode **, CPathNode **, unsigned char, unsigned char *>(gaddrof(CPathFind::FindNextNodeWandering), this, type, coors, lastNode, nextNode, curDir, nextDir);</p>
<p>0AA6: call_method 0x42B9F0 struct [CPathFind] num_params 6 pop 0 [type] [coors] [lastNode] [nextNode] [curDir] [nextDir]</p>
<p>define function CPathFind__FindNextNodeWandering&lt;thiscall, 0x42B9F0&gt;(type, coors, lastNode, nextNode, curDir, nextDir)</p>
<h4>CPathFind::FindNodeClosestToCoors</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPathFind *, CVector, unsigned char, float, bool, bool>(gaddrof(CPathFind::FindNodeClosestToCoors), this, coors, type, distLimit, ignoreDisabled, ignoreBetweenLevels);</p>
<p>0AA8: call_method_return 0x42CC30 struct [CPathFind] num_params 5 pop 0 [coors] [type] [distLimit] [ignoreDisabled] [ignoreBetweenLevels] func_ret [int]</p>
<h4>CPathFind::FindNodeClosestToCoorsFavourDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPathFind *, CVector, unsigned char, float, float>(gaddrof(CPathFind::FindNodeClosestToCoorsFavourDirection), this, coors, type, dirX, dirY);</p>
<p>0AA8: call_method_return 0x42CDC0 struct [CPathFind] num_params 4 pop 0 [coors] [type] [dirX] [dirY] func_ret [int]</p>
<h4>CPathFind::FindNodeOrientationForCarPlacement</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, unsigned int>(gaddrof(CPathFind::FindNodeOrientationForCarPlacement), this, nodeId);</p>
<p>0AA8: call_method_return 0x42CFC0 struct [CPathFind] num_params 1 pop 0 [nodeId] func_ret [float]</p>
<h4>CPathFind::FindNodeOrientationForCarPlacementFacingDestination</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CPathFind *, unsigned int, float, float, bool>(gaddrof(CPathFind::FindNodeOrientationForCarPlacementFacingDestination), this, nodeId, x, y, towards);</p>
<p>0AA8: call_method_return 0x42D060 struct [CPathFind] num_params 4 pop 0 [nodeId] [x] [y] [towards] func_ret [float]</p>
<h4>*CPathFind::FindRoadObjectClosestToCoors</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CTreadable *, CPathFind *, CVector, unsigned char>(gaddrof(CPathFind::FindRoadObjectClosestToCoors), this, coors, type);</p>
<p>0AA8: call_method_return 0x42D2A0 struct [*CPathFind] num_params 2 pop 0 [coors] [type] func_ret [CTreadable *]</p>
<h4>CPathFind::GeneratePedCreationCoors</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, float, float, float, float, float, float, CVector *, int *, int *, float *, CMatrix *>(gaddrof(CPathFind::GeneratePedCreationCoors), this, x, y, minDist, maxDist, minDistOffScreen, maxDistOffScreen, posn, pNode1, pNode2, positionBetweenNodes, camMatrix);</p>
<p>0AA8: call_method_return 0x42C1E0 struct [CPathFind] num_params 11 pop 0 [x] [y] [minDist] [maxDist] [minDistOffScreen] [maxDistOffScreen] [posn] [pNode1] [pNode2] [positionBetweenNodes] [camMatrix] func_ret [bool]</p>
<h4>CPathFind::Init</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *>(gaddrof(CPathFind::Init), this);</p>
<p>0AA6: call_method 0x4294A0 struct [CPathFind] num_params 0 pop 0</p>
<p>define function CPathFind__Init&lt;thiscall, 0x4294A0&gt;()</p>
<h4>CPathFind::Load</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, unsigned char *, unsigned int>(gaddrof(CPathFind::Load), this, buf, size);</p>
<p>0AA6: call_method 0x42E550 struct [CPathFind] num_params 2 pop 0 [buf] [size]</p>
<p>define function CPathFind__Load&lt;thiscall, 0x42E550&gt;(buf, size)</p>
<h4>CPathFind::MarkRoadsBetweenLevelsInArea</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float>(gaddrof(CPathFind::MarkRoadsBetweenLevelsInArea), this, x1, x2, y1, y2, z1, z2);</p>
<p>0AA6: call_method 0x42DF50 struct [CPathFind] num_params 6 pop 0 [x1] [x2] [y1] [y2] [z1] [z2]</p>
<p>define function CPathFind__MarkRoadsBetweenLevelsInArea&lt;thiscall, 0x42DF50&gt;(x1, x2, y1, y2, z1, z2)</p>
<h4>CPathFind::MarkRoadsBetweenLevelsNodeAndNeighbours</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, int>(gaddrof(CPathFind::MarkRoadsBetweenLevelsNodeAndNeighbours), this, nodeId);</p>
<p>0AA6: call_method 0x42E140 struct [CPathFind] num_params 1 pop 0 [nodeId]</p>
<p>define function CPathFind__MarkRoadsBetweenLevelsNodeAndNeighbours&lt;thiscall, 0x42E140&gt;(nodeId)</p>
<h4>CPathFind::NewGenerateCarCreationCoors</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, float, float, float, float, float, float, bool, CVector *, int *, int *, float *, bool>(gaddrof(CPathFind::NewGenerateCarCreationCoors), this, x, y, dirX, dirY, spawnDist, angleLimit, forward, posn, pNode1, pNode2, positionBetweenNodes, ignoreDisabled);</p>
<p>0AA8: call_method_return 0x42BF10 struct [CPathFind] num_params 12 pop 0 [x] [y] [dirX] [dirY] [spawnDist] [angleLimit] [forward] [posn] [pNode1] [pNode2] [positionBetweenNodes] [ignoreDisabled] func_ret [bool]</p>
<h4>CPathFind::PedMarkRoadsBetweenLevelsInArea</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float>(gaddrof(CPathFind::PedMarkRoadsBetweenLevelsInArea), this, x1, x2, y1, y2, z1, z2);</p>
<p>0AA6: call_method 0x42E040 struct [CPathFind] num_params 6 pop 0 [x1] [x2] [y1] [y2] [z1] [z2]</p>
<p>define function CPathFind__PedMarkRoadsBetweenLevelsInArea&lt;thiscall, 0x42E040&gt;(x1, x2, y1, y2, z1, z2)</p>
<h4>CPathFind::PreparePathData</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *>(gaddrof(CPathFind::PreparePathData), this);</p>
<p>0AA6: call_method 0x429610 struct [CPathFind] num_params 0 pop 0</p>
<p>define function CPathFind__PreparePathData&lt;thiscall, 0x429610&gt;()</p>
<h4>CPathFind::PreparePathDataForType</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, unsigned char, CTempNode *, CPathInfoForObject *, float, CTempDetachedNode *, int>(gaddrof(CPathFind::PreparePathDataForType), this, type, tempNodes, info, maxDist, detachedNodes, numDetached);</p>
<p>0AA6: call_method 0x429C20 struct [CPathFind] num_params 6 pop 0 [type] [tempNodes] [info] [maxDist] [detachedNodes] [numDetached]</p>
<p>define function CPathFind__PreparePathDataForType&lt;thiscall, 0x429C20&gt;(type, tempNodes, info, maxDist, detachedNodes, numDetached)</p>
<h4>CPathFind::RegisterMapObject</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, CTreadable *>(gaddrof(CPathFind::RegisterMapObject), this, mapObject);</p>
<p>0AA6: call_method 0x429540 struct [CPathFind] num_params 1 pop 0 [mapObject]</p>
<p>define function CPathFind__RegisterMapObject&lt;thiscall, 0x429540&gt;(mapObject)</p>
<h4>CPathFind::RemoveBadStartNode</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, CVector, CPathNode **, short *>(gaddrof(CPathFind::RemoveBadStartNode), this, pos, nodes, nodeCount);</p>
<p>0AA6: call_method 0x42B790 struct [CPathFind] num_params 3 pop 0 [pos] [nodes] [nodeCount]</p>
<p>define function CPathFind__RemoveBadStartNode&lt;thiscall, 0x42B790&gt;(pos, nodes, nodeCount)</p>
<h4>CPathFind::RemoveNodeFromList</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, CPathNode *>(gaddrof(CPathFind::RemoveNodeFromList), this, node);</p>
<p>0AA6: call_method 0x42CBB0 struct [CPathFind] num_params 1 pop 0 [node]</p>
<p>define function CPathFind__RemoveNodeFromList&lt;thiscall, 0x42CBB0&gt;(node)</p>
<h4>CPathFind::Save</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, unsigned char *, unsigned int *>(gaddrof(CPathFind::Save), this, buf, size);</p>
<p>0AA6: call_method 0x42E450 struct [CPathFind] num_params 2 pop 0 [buf] [size]</p>
<p>define function CPathFind__Save&lt;thiscall, 0x42E450&gt;(buf, size)</p>
<h4>CPathFind::SetLinksBridgeLights</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, bool>(gaddrof(CPathFind::SetLinksBridgeLights), this, x1, y1, x2, y2, enable);</p>
<p>0AA6: call_method 0x42E3B0 struct [CPathFind] num_params 5 pop 0 [x1] [y1] [x2] [y2] [enable]</p>
<p>define function CPathFind__SetLinksBridgeLights&lt;thiscall, 0x42E3B0&gt;(x1, y1, x2, y2, enable)</p>
<h4>CPathFind::StoreNodeInfoCar</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, short, short, char, char, short, short, short, short, char, char>(gaddrof(CPathFind::StoreNodeInfoCar), this, id, node, type, next, x, y, z, width, numLeft, numRight);</p>
<p>0AA6: call_method 0x42D690 struct [CPathFind] num_params 10 pop 0 [id] [node] [type] [next] [x] [y] [z] [width] [numLeft] [numRight]</p>
<p>define function CPathFind__StoreNodeInfoCar&lt;thiscall, 0x42D690&gt;(id, node, type, next, x, y, z, width, numLeft, numRight)</p>
<h4>CPathFind::StoreNodeInfoPed</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, short, short, char, char, short, short, short, short, bool>(gaddrof(CPathFind::StoreNodeInfoPed), this, id, node, type, next, x, y, z, width, crossing);</p>
<p>0AA6: call_method 0x42D7E0 struct [CPathFind] num_params 9 pop 0 [id] [node] [type] [next] [x] [y] [z] [width] [crossing]</p>
<p>define function CPathFind__StoreNodeInfoPed&lt;thiscall, 0x42D7E0&gt;(id, node, type, next, x, y, z, width, crossing)</p>
<h4>CPathFind::SwitchOffNodeAndNeighbours</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, int, bool>(gaddrof(CPathFind::SwitchOffNodeAndNeighbours), this, nodeId, disable);</p>
<p>0AA6: call_method 0x42DED0 struct [CPathFind] num_params 2 pop 0 [nodeId] [disable]</p>
<p>define function CPathFind__SwitchOffNodeAndNeighbours&lt;thiscall, 0x42DED0&gt;(nodeId, disable)</p>
<h4>CPathFind::SwitchPedRoadsOffInArea</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, bool>(gaddrof(CPathFind::SwitchPedRoadsOffInArea), this, x1, x2, y1, y2, z1, z2, disable);</p>
<p>0AA6: call_method 0x42DA50 struct [CPathFind] num_params 7 pop 0 [x1] [x2] [y1] [y2] [z1] [z2] [disable]</p>
<p>define function CPathFind__SwitchPedRoadsOffInArea&lt;thiscall, 0x42DA50&gt;(x1, x2, y1, y2, z1, z2, disable)</p>
<h4>CPathFind::SwitchRoadsInAngledArea</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, float, unsigned char, unsigned char>(gaddrof(CPathFind::SwitchRoadsInAngledArea), this, x1, y1, z1, x2, y2, z2, length, type, enable);</p>
<p>0AA6: call_method 0x42DB50 struct [CPathFind] num_params 9 pop 0 [x1] [y1] [z1] [x2] [y2] [z2] [length] [type] [enable]</p>
<p>define function CPathFind__SwitchRoadsInAngledArea&lt;thiscall, 0x42DB50&gt;(x1, y1, z1, x2, y2, z2, length, type, enable)</p>
<h4>CPathFind::SwitchRoadsOffInArea</h4>
<p>plugin::CallMethodDynGlobal<CPathFind *, float, float, float, float, float, float, bool>(gaddrof(CPathFind::SwitchRoadsOffInArea), this, x1, x2, y1, y2, z1, z2, disable);</p>
<p>0AA6: call_method 0x42D960 struct [CPathFind] num_params 7 pop 0 [x1] [x2] [y1] [y2] [z1] [z2] [disable]</p>
<p>define function CPathFind__SwitchRoadsOffInArea&lt;thiscall, 0x42D960&gt;(x1, x2, y1, y2, z1, z2, disable)</p>
<h4>CPathFind::TestCoorsCloseness</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CVector, unsigned char, CVector>(gaddrof(CPathFind::TestCoorsCloseness), this, target, type, start);</p>
<p>0AA8: call_method_return 0x42C8C0 struct [CPathFind] num_params 3 pop 0 [target] [type] [start] func_ret [bool]</p>
<h4>CPathFind::TestCrossesRoad</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CPathNode *, CPathNode *>(gaddrof(CPathFind::TestCrossesRoad), this, node1, node2);</p>
<p>0AA8: call_method_return 0x42E340 struct [CPathFind] num_params 2 pop 0 [node1] [node2] func_ret [bool]</p>
<h4>CPathFind::TestForPedTrafficLight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPathFind *, CPathNode *, CPathNode *>(gaddrof(CPathFind::TestForPedTrafficLight), this, node1, node2);</p>
<p>0AA8: call_method_return 0x42E1B0 struct [CPathFind] num_params 2 pop 0 [node1] [node2] func_ret [bool]</p>
<h4>CPathFind::LoadPathFindData</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPathFind::LoadPathFindData));</p>
<p>0AA7: call_function_return 0x429C00 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPathFind__LoadPathFindData&lt;cdecl, 0x429C00&gt;(): int</p><h3 id="plugin_iiigame_iiicpedcpp">plugin_III\game_III\CPed.cpp</h3><h4>CPed::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CPed *, unsigned int>(this, modelIndex);</p>
<h4>CPed::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CPed *>(this);</p>
<h4>CPed::Teleport</h4>
<p>plugin::CallVirtualMethod<11, CPed *, CVector>(this, pos);</p>
<h4>CPed::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CPed *>(this);</p>
<h4>CPed::Render</h4>
<p>plugin::CallVirtualMethod<13, CPed *>(this);</p>
<h4>CPed::SetupLighting</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 14, CPed *>(this);</p>
<h4>CPed::RemoveLighting</h4>
<p>plugin::CallVirtualMethod<15, CPed *, bool>(this, resetWorldColors);</p>
<h4>CPed::FlagToDestroyWhenNextProcessed</h4>
<p>plugin::CallVirtualMethod<16, CPed *>(this);</p>
<h4>CPed::ProcessEntityCollision</h4>
<p>plugin::CallVirtualMethod<17, CPed *, CEntity *, CColPoint *>(this, entity, colPoint);</p>
<h4>CPed::SetMoveAnim</h4>
<p>plugin::CallVirtualMethod<18, CPed *>(this);</p>
<h4>CPed::AddWeaponModel</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::AddWeaponModel), this, modelIndex);</p>
<p>0AA6: call_method 0x4CF8F0 struct [CPed] num_params 1 pop 0 [modelIndex]</p>
<p>define function CPed__AddWeaponModel&lt;thiscall, 0x4CF8F0&gt;(modelIndex)</p>
<h4>CPed::AimGun</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::AimGun), this);</p>
<p>0AA6: call_method 0x4C6AA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__AimGun&lt;thiscall, 0x4C6AA0&gt;()</p>
<h4>CPed::ApplyHeadShot</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eWeaponType, CVector, unsigned char>(gaddrof(CPed::ApplyHeadShot), this, type, pos, evenOnPlayer);</p>
<p>0AA6: call_method 0x4EB470 struct [CPed] num_params 3 pop 0 [type] [pos] [evenOnPlayer]</p>
<p>define function CPed__ApplyHeadShot&lt;thiscall, 0x4EB470&gt;(type, pos, evenOnPlayer)</p>
<h4>CPed::Attack</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Attack), this);</p>
<p>0AA6: call_method 0x4E6BA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Attack&lt;thiscall, 0x4E6BA0&gt;()</p>
<h4>CPed::Avoid</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Avoid), this);</p>
<p>0AA6: call_method 0x4D2BB0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Avoid&lt;thiscall, 0x4D2BB0&gt;()</p>
<h4>CPed::BeingDraggedFromCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::BeingDraggedFromCar), this);</p>
<p>0AA6: call_method 0x4E07D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__BeingDraggedFromCar&lt;thiscall, 0x4E07D0&gt;()</p>
<h4>CPed::BuildPedLists</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::BuildPedLists), this);</p>
<p>0AA6: call_method 0x4C5350 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__BuildPedLists&lt;thiscall, 0x4C5350&gt;()</p>
<h4>CPed::CalculateNewOrientation</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CalculateNewOrientation), this);</p>
<p>0AA6: call_method 0x4C7EA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CalculateNewOrientation&lt;thiscall, 0x4C7EA0&gt;()</p>
<h4>CPed::CalculateNewVelocity</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CalculateNewVelocity), this);</p>
<p>0AA6: call_method 0x4C73F0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CalculateNewVelocity&lt;thiscall, 0x4C73F0&gt;()</p>
<h4>CPed::CanBeDeleted</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanBeDeleted), this);</p>
<p>0AA8: call_method_return 0x4CF8B0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::CanPedDriveOff</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedDriveOff), this);</p>
<p>0AA8: call_method_return 0x4D7AC0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::CanPedJumpThis</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedJumpThis), this);</p>
<p>0AA8: call_method_return 0x4D72F0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::CanPedReturnToState</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanPedReturnToState), this);</p>
<p>0AA8: call_method_return 0x4CE760 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::CanSeeEntity</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *, float>(gaddrof(CPed::CanSeeEntity), this, entity, threshold);</p>
<p>0AA8: call_method_return 0x4DD820 struct [CPed] num_params 2 pop 0 [entity] [threshold] func_ret [bool]</p>
<h4>CPed::CanSetPedState</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanSetPedState), this);</p>
<p>0AA8: call_method_return 0x4CE7A0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::CanStrafeOrMouseControl</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CanStrafeOrMouseControl), this);</p>
<p>0AA8: call_method_return 0x4CE7D0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::Chat</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Chat), this);</p>
<p>0AA6: call_method 0x4D3AC0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Chat&lt;thiscall, 0x4D3AC0&gt;()</p>
<h4>CPed::CheckAroundForPossibleCollisions</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CheckAroundForPossibleCollisions), this);</p>
<p>0AA6: call_method 0x4D0490 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CheckAroundForPossibleCollisions&lt;thiscall, 0x4D0490&gt;()</p>
<h4>*CPed::CheckForDeadPeds</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CPed *>(gaddrof(CPed::CheckForDeadPeds), this);</p>
<p>0AA8: call_method_return 0x4D4860 struct [*CPed] num_params 0 pop 0 func_ret [CPed *]</p>
<h4>CPed::CheckForExplosions</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector2D &>(gaddrof(CPed::CheckForExplosions), this, area);</p>
<p>0AA8: call_method_return 0x4D4650 struct [CPed] num_params 1 pop 0 [area] func_ret [bool]</p>
<h4>*CPed::CheckForGunShots</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CPed *>(gaddrof(CPed::CheckForGunShots), this);</p>
<p>0AA8: call_method_return 0x4D47D0 struct [*CPed] num_params 0 pop 0 func_ret [CPed *]</p>
<h4>CPed::CheckForPointBlankPeds</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, CPed *>(gaddrof(CPed::CheckForPointBlankPeds), this, pedToVerify);</p>
<p>0AA8: call_method_return 0x4E6990 struct [CPed] num_params 1 pop 0 [pedToVerify] func_ret [unsigned char]</p>
<h4>CPed::CheckIfInTheAir</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::CheckIfInTheAir), this);</p>
<p>0AA8: call_method_return 0x4D0BE0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::ClearAimFlag</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAimFlag), this);</p>
<p>0AA6: call_method 0x4C6A50 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAimFlag&lt;thiscall, 0x4C6A50&gt;()</p>
<h4>CPed::ClearAll</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAll), this);</p>
<p>0AA6: call_method 0x4C7F20 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAll&lt;thiscall, 0x4C7F20&gt;()</p>
<h4>CPed::ClearAttack</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAttack), this);</p>
<p>0AA6: call_method 0x4E6790 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAttack&lt;thiscall, 0x4E6790&gt;()</p>
<h4>CPed::ClearAttackByRemovingAnim</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearAttackByRemovingAnim), this);</p>
<p>0AA6: call_method 0x4E67F0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAttackByRemovingAnim&lt;thiscall, 0x4E67F0&gt;()</p>
<h4>CPed::ClearChat</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearChat), this);</p>
<p>0AA6: call_method 0x4D3C80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearChat&lt;thiscall, 0x4D3C80&gt;()</p>
<h4>CPed::ClearDuck</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearDuck), this);</p>
<p>0AA6: call_method 0x4E4A30 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearDuck&lt;thiscall, 0x4E4A30&gt;()</p>
<h4>CPed::ClearFall</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearFall), this);</p>
<p>0AA6: call_method 0x4D0BB0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearFall&lt;thiscall, 0x4D0BB0&gt;()</p>
<h4>CPed::ClearFlee</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearFlee), this);</p>
<p>0AA6: call_method 0x4D1EA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearFlee&lt;thiscall, 0x4D1EA0&gt;()</p>
<h4>CPed::ClearInvestigateEvent</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearInvestigateEvent), this);</p>
<p>0AA6: call_method 0x4EA360 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearInvestigateEvent&lt;thiscall, 0x4EA360&gt;()</p>
<h4>CPed::ClearLeader</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLeader), this);</p>
<p>0AA6: call_method 0x4D8E80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearLeader&lt;thiscall, 0x4D8E80&gt;()</p>
<h4>CPed::ClearLook</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLook), this);</p>
<p>0AA6: call_method 0x4D1360 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearLook&lt;thiscall, 0x4D1360&gt;()</p>
<h4>CPed::ClearLookFlag</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearLookFlag), this);</p>
<p>0AA6: call_method 0x4C64F0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearLookFlag&lt;thiscall, 0x4C64F0&gt;()</p>
<h4>CPed::ClearObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearObjective), this);</p>
<p>0AA6: call_method 0x4D8DF0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearObjective&lt;thiscall, 0x4D8DF0&gt;()</p>
<h4>CPed::ClearPause</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearPause), this);</p>
<p>0AA6: call_method 0x4D0970 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearPause&lt;thiscall, 0x4D0970&gt;()</p>
<h4>CPed::ClearPointGunAt</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearPointGunAt), this);</p>
<p>0AA6: call_method 0x4E6180 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearPointGunAt&lt;thiscall, 0x4E6180&gt;()</p>
<h4>CPed::ClearSeek</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearSeek), this);</p>
<p>0AA6: call_method 0x4D1620 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearSeek&lt;thiscall, 0x4D1620&gt;()</p>
<h4>CPed::ClearWeapons</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ClearWeapons), this);</p>
<p>0AA6: call_method 0x4CFB70 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearWeapons&lt;thiscall, 0x4CFB70&gt;()</p>
<h4>CPed::CollideWithPed</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::CollideWithPed), this, collideWith);</p>
<p>0AA6: call_method 0x4EB9A0 struct [CPed] num_params 1 pop 0 [collideWith]</p>
<p>define function CPed__CollideWithPed&lt;thiscall, 0x4EB9A0&gt;(collideWith)</p>
<h4>CPed::CreateDeadPedMoney</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CreateDeadPedMoney), this);</p>
<p>0AA6: call_method 0x433490 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CreateDeadPedMoney&lt;thiscall, 0x433490&gt;()</p>
<h4>CPed::CreateDeadPedWeaponPickups</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::CreateDeadPedWeaponPickups), this);</p>
<p>0AA6: call_method 0x433660 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CreateDeadPedWeaponPickups&lt;thiscall, 0x433660&gt;()</p>
<h4>CPed::Die</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Die), this);</p>
<p>0AA6: call_method 0x4D3A50 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Die&lt;thiscall, 0x4D3A50&gt;()</p>
<h4>CPed::DoesLOSBulletHitPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, CColPoint &>(gaddrof(CPed::DoesLOSBulletHitPed), this, colPoint);</p>
<p>0AA8: call_method_return 0x4EB5C0 struct [CPed] num_params 1 pop 0 [colPoint] func_ret [unsigned char]</p>
<h4>CPed::Duck</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Duck), this);</p>
<p>0AA6: call_method 0x4E4A10 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Duck&lt;thiscall, 0x4E4A10&gt;()</p>
<h4>CPed::DuckAndCover</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::DuckAndCover), this);</p>
<p>0AA8: call_method_return 0x4E3EC0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::EndFight</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned char>(gaddrof(CPed::EndFight), this, endType);</p>
<p>0AA6: call_method 0x4E8D30 struct [CPed] num_params 1 pop 0 [endType]</p>
<p>define function CPed__EndFight&lt;thiscall, 0x4E8D30&gt;(endType)</p>
<h4>CPed::EnterCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::EnterCar), this);</p>
<p>0AA6: call_method 0x4E0D30 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__EnterCar&lt;thiscall, 0x4E0D30&gt;()</p>
<h4>CPed::EnterTrain</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::EnterTrain), this);</p>
<p>0AA6: call_method 0x4E33B0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__EnterTrain&lt;thiscall, 0x4E33B0&gt;()</p>
<h4>CPed::ExitCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ExitCar), this);</p>
<p>0AA6: call_method 0x4E18D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ExitCar&lt;thiscall, 0x4E18D0&gt;()</p>
<h4>CPed::ExitTrain</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ExitTrain), this);</p>
<p>0AA6: call_method 0x4E36D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ExitTrain&lt;thiscall, 0x4E36D0&gt;()</p>
<h4>CPed::FacePhone</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::FacePhone), this);</p>
<p>0AA8: call_method_return 0x4D3CC0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::Fall</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Fall), this);</p>
<p>0AA6: call_method 0x4D0BC0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Fall&lt;thiscall, 0x4D0BC0&gt;()</p>
<h4>CPed::Fight</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Fight), this);</p>
<p>0AA6: call_method 0x4E7EE0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Fight&lt;thiscall, 0x4E7EE0&gt;()</p>
<h4>CPed::FightStrike</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVector &>(gaddrof(CPed::FightStrike), this, touchedNodePos);</p>
<p>0AA6: call_method 0x4E8EC0 struct [CPed] num_params 1 pop 0 [touchedNodePos]</p>
<p>define function CPed__FightStrike&lt;thiscall, 0x4E8EC0&gt;(touchedNodePos)</p>
<h4>CPed::FindBestCoordsFromNodes</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector, CVector *>(gaddrof(CPed::FindBestCoordsFromNodes), this, unused, bestCoords);</p>
<p>0AA8: call_method_return 0x4E3A90 struct [CPed] num_params 2 pop 0 [unused] [bestCoords] func_ret [bool]</p>
<h4>CPed::Flee</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Flee), this);</p>
<p>0AA6: call_method 0x4D1ED0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Flee&lt;thiscall, 0x4D1ED0&gt;()</p>
<h4>CPed::FollowPath</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::FollowPath), this);</p>
<p>0AA6: call_method 0x4D3020 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__FollowPath&lt;thiscall, 0x4D3020&gt;()</p>
<h4>CPed::ForceStoredObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eObjective>(gaddrof(CPed::ForceStoredObjective), this, objective);</p>
<p>0AA6: call_method 0x4D8250 struct [CPed] num_params 1 pop 0 [objective]</p>
<p>define function CPed__ForceStoredObjective&lt;thiscall, 0x4D8250&gt;(objective)</p>
<h4>*CPed::GetFormationPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVector *, CPed *>(gaddrof(CPed::GetFormationPosition), this);</p>
<p>0AA8: call_method_return 0x4DF420 struct [*CPed] num_params 0 pop 0 func_ret [CVector *]</p>
<h4>CPed::GetLocalDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPed *, CVector2D const &>(gaddrof(CPed::GetLocalDirection), this, posOffset);</p>
<p>0AA8: call_method_return 0x4CCE20 struct [CPed] num_params 1 pop 0 [posOffset] func_ret [int]</p>
<h4>CPed::GetNearestDoor</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestDoor), this, vehicle, posToOpen);</p>
<p>0AA6: call_method 0x4E1CF0 struct [CPed] num_params 2 pop 0 [vehicle] [posToOpen]</p>
<p>define function CPed__GetNearestDoor&lt;thiscall, 0x4E1CF0&gt;(vehicle, posToOpen)</p>
<h4>CPed::GetNearestPassengerDoor</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestPassengerDoor), this, vehicle, posToOpen);</p>
<p>0AA8: call_method_return 0x4E1F30 struct [CPed] num_params 2 pop 0 [vehicle] [posToOpen] func_ret [bool]</p>
<h4>CPed::GetNearestTrainDoor</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestTrainDoor), this, vehicle, doorPos);</p>
<p>0AA8: call_method_return 0x4E2D70 struct [CPed] num_params 2 pop 0 [vehicle] [doorPos] func_ret [bool]</p>
<h4>CPed::GetNearestTrainPedPosition</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, CVector &>(gaddrof(CPed::GetNearestTrainPedPosition), this, vehicle, enterPos);</p>
<p>0AA6: call_method 0x4E2E50 struct [CPed] num_params 2 pop 0 [vehicle] [enterPos]</p>
<p>define function CPed__GetNearestTrainPedPosition&lt;thiscall, 0x4E2E50&gt;(vehicle, enterPos)</p>
<h4>CPed::GetNextPointOnRoute</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPed *>(gaddrof(CPed::GetNextPointOnRoute), this);</p>
<p>0AA8: call_method_return 0x4DD720 struct [CPed] num_params 0 pop 0 func_ret [short]</p>
<h4>CPed::GetPedRadioCategory</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned char, CPed *, unsigned int>(gaddrof(CPed::GetPedRadioCategory), this, modelIndex);</p>
<p>0AA8: call_method_return 0x4D7B50 struct [CPed] num_params 1 pop 0 [modelIndex] func_ret [unsigned char]</p>
<h4>CPed::GetWeaponSlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPed *, eWeaponType>(gaddrof(CPed::GetWeaponSlot), this, type);</p>
<p>0AA8: call_method_return 0x4CFA40 struct [CPed] num_params 1 pop 0 [type] func_ret [int]</p>
<h4>CPed::GiveWeapon</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CPed *, eWeaponType, unsigned int>(gaddrof(CPed::GiveWeapon), this, type, ammo);</p>
<p>0AA8: call_method_return 0x4CF9B0 struct [CPed] num_params 2 pop 0 [type] [ammo] func_ret [unsigned int]</p>
<h4>CPed::GoToNearestDoor</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::GoToNearestDoor), this, vehicle);</p>
<p>0AA6: call_method 0x4E2220 struct [CPed] num_params 1 pop 0 [vehicle]</p>
<p>define function CPed__GoToNearestDoor&lt;thiscall, 0x4E2220&gt;(vehicle)</p>
<h4>CPed::GrantAmmo</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eWeaponType, unsigned int>(gaddrof(CPed::GrantAmmo), this, type, ammo);</p>
<p>0AA6: call_method 0x4CFAD0 struct [CPed] num_params 2 pop 0 [type] [ammo]</p>
<p>define function CPed__GrantAmmo&lt;thiscall, 0x4CFAD0&gt;(type, ammo)</p>
<h4>CPed::HaveReachedNextPointOnRoute</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, float>(gaddrof(CPed::HaveReachedNextPointOnRoute), this, distToCountReached);</p>
<p>0AA8: call_method_return 0x4DD7B0 struct [CPed] num_params 1 pop 0 [distToCountReached] func_ret [bool]</p>
<h4>CPed::Idle</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Idle), this);</p>
<p>0AA6: call_method 0x4D0690 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Idle&lt;thiscall, 0x4D0690&gt;()</p>
<h4>CPed::InTheAir</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::InTheAir), this);</p>
<p>0AA6: call_method 0x4D0D10 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__InTheAir&lt;thiscall, 0x4D0D10&gt;()</p>
<h4>CPed::InflictDamage</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *, eWeaponType, float, ePedPieceTypes, unsigned char>(gaddrof(CPed::InflictDamage), this, damagedBy, type, damage, pedPiece, direction);</p>
<p>0AA8: call_method_return 0x4EA420 struct [CPed] num_params 5 pop 0 [damagedBy] [type] [damage] [pedPiece] [direction] func_ret [bool]</p>
<h4>CPed::InformMyGangOfAttack</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::InformMyGangOfAttack), this, attacker);</p>
<p>0AA6: call_method 0x4E4AD0 struct [CPed] num_params 1 pop 0 [attacker]</p>
<p>define function CPed__InformMyGangOfAttack&lt;thiscall, 0x4E4AD0&gt;(attacker)</p>
<h4>CPed::InvestigateEvent</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::InvestigateEvent), this);</p>
<p>0AA6: call_method 0x4E9B50 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__InvestigateEvent&lt;thiscall, 0x4E9B50&gt;()</p>
<h4>CPed::IsGangMember</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsGangMember), this);</p>
<p>0AA8: call_method_return 0x4D4910 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::IsPedHeadAbovePos</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, float>(gaddrof(CPed::IsPedHeadAbovePos), this, zOffset);</p>
<p>0AA8: call_method_return 0x4EB670 struct [CPed] num_params 1 pop 0 [zOffset] func_ret [bool]</p>
<h4>CPed::IsPedInControl</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPedInControl), this);</p>
<p>0AA8: call_method_return 0x4CE6C0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::IsPedShootable</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPedShootable), this);</p>
<p>0AA8: call_method_return 0x4CE710 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::IsPlayer</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPlayer), this);</p>
<p>0AA8: call_method_return 0x4D48E0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::IsPointerValid</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsPointerValid), this);</p>
<p>0AA8: call_method_return 0x4D4930 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::IsRoomToBeCarJacked</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::IsRoomToBeCarJacked), this);</p>
<p>0AA8: call_method_return 0x4E4D90 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::IsTemporaryObjective</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, eObjective>(gaddrof(CPed::IsTemporaryObjective), this, objective);</p>
<p>0AA8: call_method_return 0x4D8290 struct [CPed] num_params 1 pop 0 [objective] func_ret [bool]</p>
<h4>CPed::KillPedWithCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, float>(gaddrof(CPed::KillPedWithCar), this, vehicle, impulse);</p>
<p>0AA6: call_method 0x4EC430 struct [CPed] num_params 2 pop 0 [vehicle] [impulse]</p>
<p>define function CPed__KillPedWithCar&lt;thiscall, 0x4EC430&gt;(vehicle, impulse)</p>
<h4>CPed::LineUpPedWithCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::LineUpPedWithCar), this, phase);</p>
<p>0AA6: call_method 0x4DF940 struct [CPed] num_params 1 pop 0 [phase]</p>
<p>define function CPed__LineUpPedWithCar&lt;thiscall, 0x4DF940&gt;(phase)</p>
<h4>CPed::LineUpPedWithTrain</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LineUpPedWithTrain), this);</p>
<p>0AA6: call_method 0x4E33D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__LineUpPedWithTrain&lt;thiscall, 0x4E33D0&gt;()</p>
<h4>CPed::Look</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Look), this);</p>
<p>0AA6: call_method 0x4D1380 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Look&lt;thiscall, 0x4D1380&gt;()</p>
<h4>CPed::LookForInterestingNodes</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::LookForInterestingNodes), this);</p>
<p>0AA8: call_method_return 0x4D5040 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::LookForSexyCars</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LookForSexyCars), this);</p>
<p>0AA6: call_method 0x4D4F50 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__LookForSexyCars&lt;thiscall, 0x4D4F50&gt;()</p>
<h4>CPed::LookForSexyPeds</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::LookForSexyPeds), this);</p>
<p>0AA6: call_method 0x4D4DF0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__LookForSexyPeds&lt;thiscall, 0x4D4DF0&gt;()</p>
<h4>CPed::MakePhonecall</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::MakePhonecall), this);</p>
<p>0AA8: call_method_return 0x4D3E20 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::MoveHeadToLook</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::MoveHeadToLook), this);</p>
<p>0AA6: call_method 0x4C65B0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__MoveHeadToLook&lt;thiscall, 0x4C65B0&gt;()</p>
<h4>CPed::Mug</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Mug), this);</p>
<p>0AA6: call_method 0x4D11D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Mug&lt;thiscall, 0x4D11D0&gt;()</p>
<h4>CPed::OurPedCanSeeThisOne</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *>(gaddrof(CPed::OurPedCanSeeThisOne), this, entity);</p>
<p>0AA8: call_method_return 0x4C5700 struct [CPed] num_params 1 pop 0 [entity] func_ret [bool]</p>
<h4>CPed::Pause</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Pause), this);</p>
<p>0AA6: call_method 0x4D0980 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Pause&lt;thiscall, 0x4D0980&gt;()</p>
<h4>CPed::PlacePedOnDryLand</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::PlacePedOnDryLand), this);</p>
<p>0AA8: call_method_return 0x4EB6E0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::PlayFootSteps</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::PlayFootSteps), this);</p>
<p>0AA6: call_method 0x4CC6C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__PlayFootSteps&lt;thiscall, 0x4CC6C0&gt;()</p>
<h4>CPed::PlayHitSound</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::PlayHitSound), this, hitTo);</p>
<p>0AA6: call_method 0x4E8E20 struct [CPed] num_params 1 pop 0 [hitTo]</p>
<p>define function CPed__PlayHitSound&lt;thiscall, 0x4E8E20&gt;(hitTo)</p>
<h4>CPed::PointGunAt</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::PointGunAt), this);</p>
<p>0AA6: call_method 0x4E60B0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__PointGunAt&lt;thiscall, 0x4E60B0&gt;()</p>
<h4>CPed::PositionPedOutOfCollision</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::PositionPedOutOfCollision), this);</p>
<p>0AA8: call_method_return 0x4E4F30 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::PossiblyFindBetterPosToSeekCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector *, CVehicle *>(gaddrof(CPed::PossiblyFindBetterPosToSeekCar), this, pos, vehicle);</p>
<p>0AA8: call_method_return 0x4D6A00 struct [CPed] num_params 2 pop 0 [pos] [vehicle] func_ret [bool]</p>
<h4>CPed::ProcessBuoyancy</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ProcessBuoyancy), this);</p>
<p>0AA6: call_method 0x4C7FF0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ProcessBuoyancy&lt;thiscall, 0x4C7FF0&gt;()</p>
<h4>CPed::ProcessObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ProcessObjective), this);</p>
<p>0AA6: call_method 0x4D94E0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ProcessObjective&lt;thiscall, 0x4D94E0&gt;()</p>
<h4>CPed::QuitEnteringCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::QuitEnteringCar), this);</p>
<p>0AA6: call_method 0x4E0E00 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__QuitEnteringCar&lt;thiscall, 0x4E0E00&gt;()</p>
<h4>CPed::ReactToAttack</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::ReactToAttack), this, attacker);</p>
<p>0AA6: call_method 0x4DDEC0 struct [CPed] num_params 1 pop 0 [attacker]</p>
<p>define function CPed__ReactToAttack&lt;thiscall, 0x4DDEC0&gt;(attacker)</p>
<h4>CPed::ReactToPointGun</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::ReactToPointGun), this, entWithGun);</p>
<p>0AA6: call_method 0x4DD980 struct [CPed] num_params 1 pop 0 [entWithGun]</p>
<p>define function CPed__ReactToPointGun&lt;thiscall, 0x4DD980&gt;(entWithGun)</p>
<h4>CPed::RegisterThreatWithGangPeds</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::RegisterThreatWithGangPeds), this, attacker);</p>
<p>0AA6: call_method 0x4E3870 struct [CPed] num_params 1 pop 0 [attacker]</p>
<p>define function CPed__RegisterThreatWithGangPeds&lt;thiscall, 0x4E3870&gt;(attacker)</p>
<h4>CPed::RemoveBodyPart</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int, char>(gaddrof(CPed::RemoveBodyPart), this, nodeId, direction);</p>
<p>0AA6: call_method 0x4EAEE0 struct [CPed] num_params 2 pop 0 [nodeId] [direction]</p>
<p>define function CPed__RemoveBodyPart&lt;thiscall, 0x4EAEE0&gt;(nodeId, direction)</p>
<h4>CPed::RemoveInCarAnims</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RemoveInCarAnims), this);</p>
<p>0AA6: call_method 0x4E4E20 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RemoveInCarAnims&lt;thiscall, 0x4E4E20&gt;()</p>
<h4>CPed::RemoveWeaponModel</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::RemoveWeaponModel), this, modelIndex);</p>
<p>0AA6: call_method 0x4CF980 struct [CPed] num_params 1 pop 0 [modelIndex]</p>
<p>define function CPed__RemoveWeaponModel&lt;thiscall, 0x4CF980&gt;(modelIndex)</p>
<h4>CPed::RestartNonPartialAnims</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestartNonPartialAnims), this);</p>
<p>0AA6: call_method 0x4C5D80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestartNonPartialAnims&lt;thiscall, 0x4C5D80&gt;()</p>
<h4>CPed::RestoreGunPosition</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreGunPosition), this);</p>
<p>0AA6: call_method 0x4C6BB0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestoreGunPosition&lt;thiscall, 0x4C6BB0&gt;()</p>
<h4>CPed::RestoreHeadPosition</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreHeadPosition), this);</p>
<p>0AA6: call_method 0x4C6930 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestoreHeadPosition&lt;thiscall, 0x4C6930&gt;()</p>
<h4>CPed::RestoreHeadingRate</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestoreHeadingRate), this);</p>
<p>0AA6: call_method 0x4D6540 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestoreHeadingRate&lt;thiscall, 0x4D6540&gt;()</p>
<h4>CPed::RestorePreviousObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestorePreviousObjective), this);</p>
<p>0AA6: call_method 0x4D9460 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestorePreviousObjective&lt;thiscall, 0x4D9460&gt;()</p>
<h4>CPed::RestorePreviousState</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::RestorePreviousState), this);</p>
<p>0AA6: call_method 0x4C5E30 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestorePreviousState&lt;thiscall, 0x4C5E30&gt;()</p>
<h4>CPed::RunToReportCrime</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, eCrimeType>(gaddrof(CPed::RunToReportCrime), this, type);</p>
<p>0AA8: call_method_return 0x4C10C0 struct [CPed] num_params 1 pop 0 [type] func_ret [bool]</p>
<h4>CPed::Say</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned short>(gaddrof(CPed::Say), this, audio);</p>
<p>0AA6: call_method 0x4E5A10 struct [CPed] num_params 1 pop 0 [audio]</p>
<p>define function CPed__Say&lt;thiscall, 0x4E5A10&gt;(audio)</p>
<h4>CPed::ScanForInterestingStuff</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ScanForInterestingStuff), this);</p>
<p>0AA6: call_method 0x4C6C10 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ScanForInterestingStuff&lt;thiscall, 0x4C6C10&gt;()</p>
<h4>CPed::ScanForThreats</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CPed *>(gaddrof(CPed::ScanForThreats), this);</p>
<p>0AA8: call_method_return 0x4C5FE0 struct [CPed] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>CPed::Seek</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::Seek), this);</p>
<p>0AA8: call_method_return 0x4D1640 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::SeekBoatPosition</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SeekBoatPosition), this);</p>
<p>0AA6: call_method 0x4E4C70 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SeekBoatPosition&lt;thiscall, 0x4E4C70&gt;()</p>
<h4>CPed::SeekCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SeekCar), this);</p>
<p>0AA6: call_method 0x4D3F90 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SeekCar&lt;thiscall, 0x4D3F90&gt;()</p>
<h4>CPed::SeekFollowingPath</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector *>(gaddrof(CPed::SeekFollowingPath), this, unused);</p>
<p>0AA8: call_method_return 0x4D2E70 struct [CPed] num_params 1 pop 0 [unused] func_ret [bool]</p>
<h4>CPed::SelectGunIfArmed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::SelectGunIfArmed), this);</p>
<p>0AA8: call_method_return 0x4DD920 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::ServiceTalking</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::ServiceTalking), this);</p>
<p>0AA6: call_method 0x4E5870 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ServiceTalking&lt;thiscall, 0x4E5870&gt;()</p>
<h4>CPed::ServiceTalkingWhenDead</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::ServiceTalkingWhenDead), this);</p>
<p>0AA8: call_method_return 0x4E5850 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::SetAimFlag</h4>
<p>plugin::CallMethodDynGlobal<CPed *, float>(gaddrof_o(CPed::SetAimFlag, void (CPed::*)(float)), this, direction);</p>
<p>0AA6: call_method 0x4C69E0 struct [CPed] num_params 1 pop 0 [direction]</p>
<p>define function CPed__SetAimFlag&lt;thiscall, 0x4C69E0&gt;(direction)</p>
<h4>CPed::SetAimFlag</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof_o(CPed::SetAimFlag, void (CPed::*)(CEntity *)), this, entity);</p>
<p>0AA6: call_method 0x4C69E0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetAimFlag&lt;thiscall, 0x4C69E0&gt;(entity)</p>
<h4>CPed::SetAmmo</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eWeaponType, unsigned int>(gaddrof(CPed::SetAmmo), this, type, ammo);</p>
<p>0AA6: call_method 0x4CFB20 struct [CPed] num_params 2 pop 0 [type] [ammo]</p>
<p>define function CPed__SetAmmo&lt;thiscall, 0x4CFB20&gt;(type, ammo)</p>
<h4>CPed::SetAttack</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetAttack), this, victim);</p>
<p>0AA6: call_method 0x4E6220 struct [CPed] num_params 1 pop 0 [victim]</p>
<p>define function CPed__SetAttack&lt;thiscall, 0x4E6220&gt;(victim)</p>
<h4>CPed::SetAttackTimer</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetAttackTimer), this, time);</p>
<p>0AA6: call_method 0x4D1300 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetAttackTimer&lt;thiscall, 0x4D1300&gt;(time)</p>
<h4>CPed::SetBeingDraggedFromCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, bool>(gaddrof(CPed::SetBeingDraggedFromCar), this, vehicle, doorNode, quickJack);</p>
<p>0AA6: call_method 0x4E0640 struct [CPed] num_params 3 pop 0 [vehicle] [doorNode] [quickJack]</p>
<p>define function CPed__SetBeingDraggedFromCar&lt;thiscall, 0x4E0640&gt;(vehicle, doorNode, quickJack)</p>
<h4>CPed::SetBuyIceCream</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetBuyIceCream), this);</p>
<p>0AA6: call_method 0x4D6950 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetBuyIceCream&lt;thiscall, 0x4D6950&gt;()</p>
<h4>CPed::SetCarJack</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetCarJack), this, vehicle);</p>
<p>0AA6: call_method 0x4E0220 struct [CPed] num_params 1 pop 0 [vehicle]</p>
<p>define function CPed__SetCarJack&lt;thiscall, 0x4E0220&gt;(vehicle)</p>
<h4>CPed::SetCarJack_AllClear</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, unsigned int>(gaddrof(CPed::SetCarJack_AllClear), this, vehicle, doorNode, doorFlag);</p>
<p>0AA6: call_method 0x4E03F0 struct [CPed] num_params 3 pop 0 [vehicle] [doorNode] [doorFlag]</p>
<p>define function CPed__SetCarJack_AllClear&lt;thiscall, 0x4E03F0&gt;(vehicle, doorNode, doorFlag)</p>
<h4>CPed::SetChat</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *, unsigned int>(gaddrof(CPed::SetChat), this, chatWith, time);</p>
<p>0AA6: call_method 0x4D3A60 struct [CPed] num_params 2 pop 0 [chatWith] [time]</p>
<p>define function CPed__SetChat&lt;thiscall, 0x4D3A60&gt;(chatWith, time)</p>
<h4>CPed::SetCurrentWeapon</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int>(gaddrof(CPed::SetCurrentWeapon), this, type);</p>
<p>0AA6: call_method 0x4CFA60 struct [CPed] num_params 1 pop 0 [type]</p>
<p>define function CPed__SetCurrentWeapon&lt;thiscall, 0x4CFA60&gt;(type)</p>
<h4>CPed::SetDead</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetDead), this);</p>
<p>0AA6: call_method 0x4D3970 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetDead&lt;thiscall, 0x4D3970&gt;()</p>
<h4>CPed::SetDie</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int, float, float>(gaddrof(CPed::SetDie), this, animId, delta, speed);</p>
<p>0AA6: call_method 0x4D37D0 struct [CPed] num_params 3 pop 0 [animId] [delta] [speed]</p>
<p>define function CPed__SetDie&lt;thiscall, 0x4D37D0&gt;(animId, delta, speed)</p>
<h4>CPed::SetDirectionToWalkAroundObject</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetDirectionToWalkAroundObject), this, entity);</p>
<p>0AA6: call_method 0x4CCEB0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetDirectionToWalkAroundObject&lt;thiscall, 0x4CCEB0&gt;(entity)</p>
<h4>CPed::SetDuck</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetDuck), this, time);</p>
<p>0AA6: call_method 0x4E4920 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetDuck&lt;thiscall, 0x4E4920&gt;(time)</p>
<h4>CPed::SetEnterCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetEnterCar), this, vehicle, unused);</p>
<p>0AA6: call_method 0x4E0920 struct [CPed] num_params 2 pop 0 [vehicle] [unused]</p>
<p>define function CPed__SetEnterCar&lt;thiscall, 0x4E0920&gt;(vehicle, unused)</p>
<h4>CPed::SetEnterCar_AllClear</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int, unsigned int>(gaddrof(CPed::SetEnterCar_AllClear), this, vehicle, doorNode, doorFlag);</p>
<p>0AA6: call_method 0x4E0A40 struct [CPed] num_params 3 pop 0 [vehicle] [doorNode] [doorFlag]</p>
<p>define function CPed__SetEnterCar_AllClear&lt;thiscall, 0x4E0A40&gt;(vehicle, doorNode, doorFlag)</p>
<h4>CPed::SetEnterTrain</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetEnterTrain), this, train, unused);</p>
<p>0AA6: call_method 0x4E32D0 struct [CPed] num_params 2 pop 0 [train] [unused]</p>
<p>define function CPed__SetEnterTrain&lt;thiscall, 0x4E32D0&gt;(train, unused)</p>
<h4>CPed::SetEvasiveDive</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CPhysical *, unsigned char>(gaddrof(CPed::SetEvasiveDive), this, reason, onlyRandomJump);</p>
<p>0AA6: call_method 0x4D33A0 struct [CPed] num_params 2 pop 0 [reason] [onlyRandomJump]</p>
<p>define function CPed__SetEvasiveDive&lt;thiscall, 0x4D33A0&gt;(reason, onlyRandomJump)</p>
<h4>CPed::SetEvasiveStep</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CPhysical *, unsigned char>(gaddrof(CPed::SetEvasiveStep), this, reason, animType);</p>
<p>0AA6: call_method 0x4D30C0 struct [CPed] num_params 2 pop 0 [reason] [animType]</p>
<p>define function CPed__SetEvasiveStep&lt;thiscall, 0x4D30C0&gt;(reason, animType)</p>
<h4>CPed::SetExitCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetExitCar), this, vehicle, doorNode);</p>
<p>0AA6: call_method 0x4E1010 struct [CPed] num_params 2 pop 0 [vehicle] [doorNode]</p>
<p>define function CPed__SetExitCar&lt;thiscall, 0x4E1010&gt;(vehicle, doorNode)</p>
<h4>CPed::SetExitTrain</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetExitTrain), this, train);</p>
<p>0AA6: call_method 0x4E3640 struct [CPed] num_params 1 pop 0 [train]</p>
<p>define function CPed__SetExitTrain&lt;thiscall, 0x4E3640&gt;(train)</p>
<h4>CPed::SetFall</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int, int, unsigned char>(gaddrof(CPed::SetFall), this, extraTime, animId, evenIfNotInControl);</p>
<p>0AA6: call_method 0x4D09B0 struct [CPed] num_params 3 pop 0 [extraTime] [animId] [evenIfNotInControl]</p>
<p>define function CPed__SetFall&lt;thiscall, 0x4D09B0&gt;(extraTime, animId, evenIfNotInControl)</p>
<h4>CPed::SetFlee</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVector2D const &, int>(gaddrof_o(CPed::SetFlee, void (CPed::*)(CVector2D const &amp;, int)), this, from, time);</p>
<p>0AA6: call_method 0x4D1D70 struct [CPed] num_params 2 pop 0 [from] [time]</p>
<p>define function CPed__SetFlee&lt;thiscall, 0x4D1D70&gt;(from, time)</p>
<h4>CPed::SetFlee</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *, int>(gaddrof_o(CPed::SetFlee, void (CPed::*)(CEntity *, int)), this, fleeFrom, time);</p>
<p>0AA6: call_method 0x4D1D70 struct [CPed] num_params 2 pop 0 [fleeFrom] [time]</p>
<p>define function CPed__SetFlee&lt;thiscall, 0x4D1D70&gt;(fleeFrom, time)</p>
<h4>CPed::SetFollowPath</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CVector>(gaddrof(CPed::SetFollowPath), this, dest);</p>
<p>0AA8: call_method_return 0x4D2EA0 struct [CPed] num_params 1 pop 0 [dest] func_ret [bool]</p>
<h4>CPed::SetFollowRoute</h4>
<p>plugin::CallMethodDynGlobal<CPed *, short, short>(gaddrof(CPed::SetFollowRoute), this, currentPoint, routeType);</p>
<p>0AA6: call_method 0x4DD690 struct [CPed] num_params 2 pop 0 [currentPoint] [routeType]</p>
<p>define function CPed__SetFollowRoute&lt;thiscall, 0x4DD690&gt;(currentPoint, routeType)</p>
<h4>CPed::SetFormation</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eFormation>(gaddrof(CPed::SetFormation), this, formation);</p>
<p>0AA6: call_method 0x4DF3E0 struct [CPed] num_params 1 pop 0 [formation]</p>
<p>define function CPed__SetFormation&lt;thiscall, 0x4DF3E0&gt;(formation)</p>
<h4>CPed::SetGetUp</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetGetUp), this);</p>
<p>0AA6: call_method 0x4D0F20 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetGetUp&lt;thiscall, 0x4D0F20&gt;()</p>
<h4>CPed::SetIdle</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetIdle), this);</p>
<p>0AA6: call_method 0x4D0600 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetIdle&lt;thiscall, 0x4D0600&gt;()</p>
<h4>CPed::SetInTheAir</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetInTheAir), this);</p>
<p>0AA6: call_method 0x4D0CA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetInTheAir&lt;thiscall, 0x4D0CA0&gt;()</p>
<h4>CPed::SetInvestigateEvent</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eEventType, CVector2D, float, unsigned short, float>(gaddrof(CPed::SetInvestigateEvent), this, type, pos, distanceToCountDone, time, angle);</p>
<p>0AA6: call_method 0x4E9A80 struct [CPed] num_params 5 pop 0 [type] [pos] [distanceToCountDone] [time] [angle]</p>
<p>define function CPed__SetInvestigateEvent&lt;thiscall, 0x4E9A80&gt;(type, pos, distanceToCountDone, time, angle)</p>
<h4>CPed::SetJump</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetJump), this);</p>
<p>0AA6: call_method 0x4D73D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetJump&lt;thiscall, 0x4D73D0&gt;()</p>
<h4>CPed::SetLanding</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetLanding), this);</p>
<p>0AA6: call_method 0x4D0E40 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetLanding&lt;thiscall, 0x4D0E40&gt;()</p>
<h4>CPed::SetLeader</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CPed *>(gaddrof(CPed::SetLeader), this, leader);</p>
<p>0AA6: call_method 0x4D72C0 struct [CPed] num_params 1 pop 0 [leader]</p>
<p>define function CPed__SetLeader&lt;thiscall, 0x4D72C0&gt;(leader)</p>
<h4>CPed::SetLookFlag</h4>
<p>plugin::CallMethodDynGlobal<CPed *, float, bool>(gaddrof_o(CPed::SetLookFlag, void (CPed::*)(float, bool)), this, direction, keepTryingToLook);</p>
<p>0AA6: call_method 0x4C6460 struct [CPed] num_params 2 pop 0 [direction] [keepTryingToLook]</p>
<p>define function CPed__SetLookFlag&lt;thiscall, 0x4C6460&gt;(direction, keepTryingToLook)</p>
<h4>CPed::SetLookFlag</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *, bool>(gaddrof_o(CPed::SetLookFlag, void (CPed::*)(CEntity *, bool)), this, target, keepTryingToLook);</p>
<p>0AA6: call_method 0x4C6460 struct [CPed] num_params 2 pop 0 [target] [keepTryingToLook]</p>
<p>define function CPed__SetLookFlag&lt;thiscall, 0x4C6460&gt;(target, keepTryingToLook)</p>
<h4>CPed::SetLookTimer</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetLookTimer), this, time);</p>
<p>0AA6: call_method 0x4D12E0 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetLookTimer&lt;thiscall, 0x4D12E0&gt;(time)</p>
<h4>CPed::SetMoveState</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eMoveState>(gaddrof(CPed::SetMoveState), this, state);</p>
<p>0AA6: call_method 0x4C5A30 struct [CPed] num_params 1 pop 0 [state]</p>
<p>define function CPed__SetMoveState&lt;thiscall, 0x4C5A30&gt;(state)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eObjective>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective)), this, objective);</p>
<p>0AA6: call_method 0x4D8A90 struct [CPed] num_params 1 pop 0 [objective]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x4D8A90&gt;(objective)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eObjective, void *>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, void *)), this, objective, entity);</p>
<p>0AA6: call_method 0x4D8A90 struct [CPed] num_params 2 pop 0 [objective] [entity]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x4D8A90&gt;(objective, entity)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eObjective, CVector, float>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, CVector, float)), this, objective, dest, safeDist);</p>
<p>0AA6: call_method 0x4D8A90 struct [CPed] num_params 3 pop 0 [objective] [dest] [safeDist]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x4D8A90&gt;(objective, dest, safeDist)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eObjective, short, short>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, short, short)), this, objective, routePoint, routeType);</p>
<p>0AA6: call_method 0x4D8A90 struct [CPed] num_params 3 pop 0 [objective] [routePoint] [routeType]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x4D8A90&gt;(objective, routePoint, routeType)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eObjective, CVector>(gaddrof_o(CPed::SetObjective, void (CPed::*)(eObjective, CVector)), this, objective, dest);</p>
<p>0AA6: call_method 0x4D8A90 struct [CPed] num_params 2 pop 0 [objective] [dest]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x4D8A90&gt;(objective, dest)</p>
<h4>CPed::SetObjectiveTimer</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetObjectiveTimer), this, time);</p>
<p>0AA6: call_method 0x4D81E0 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetObjectiveTimer&lt;thiscall, 0x4D81E0&gt;(time)</p>
<h4>CPed::SetPedPositionInCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetPedPositionInCar), this);</p>
<p>0AA6: call_method 0x4D4970 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetPedPositionInCar&lt;thiscall, 0x4D4970&gt;()</p>
<h4>CPed::SetPedPositionInTrain</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetPedPositionInTrain), this);</p>
<p>0AA6: call_method 0x4E33C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetPedPositionInTrain&lt;thiscall, 0x4E33C0&gt;()</p>
<h4>CPed::SetPedStats</h4>
<p>plugin::CallMethodDynGlobal<CPed *, ePedStats>(gaddrof(CPed::SetPedStats), this, stat);</p>
<p>0AA6: call_method 0x4C5330 struct [CPed] num_params 1 pop 0 [stat]</p>
<p>define function CPed__SetPedStats&lt;thiscall, 0x4C5330&gt;(stat)</p>
<h4>CPed::SetPointGunAt</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *>(gaddrof(CPed::SetPointGunAt), this, entity);</p>
<p>0AA6: call_method 0x4E5F70 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetPointGunAt&lt;thiscall, 0x4E5F70&gt;(entity)</p>
<h4>CPed::SetRadioStation</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetRadioStation), this);</p>
<p>0AA6: call_method 0x4D7BC0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetRadioStation&lt;thiscall, 0x4D7BC0&gt;()</p>
<h4>CPed::SetSeek</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVector, float>(gaddrof_o(CPed::SetSeek, void (CPed::*)(CVector, float)), this, pos, distanceToCountDone);</p>
<p>0AA6: call_method 0x4D15A0 struct [CPed] num_params 2 pop 0 [pos] [distanceToCountDone]</p>
<p>define function CPed__SetSeek&lt;thiscall, 0x4D15A0&gt;(pos, distanceToCountDone)</p>
<h4>CPed::SetSeek</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CEntity *, float>(gaddrof_o(CPed::SetSeek, void (CPed::*)(CEntity *, float)), this, seeking, distanceToCountDone);</p>
<p>0AA6: call_method 0x4D15A0 struct [CPed] num_params 2 pop 0 [seeking] [distanceToCountDone]</p>
<p>define function CPed__SetSeek&lt;thiscall, 0x4D15A0&gt;(seeking, distanceToCountDone)</p>
<h4>CPed::SetSeekBoatPosition</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::SetSeekBoatPosition), this, boat);</p>
<p>0AA6: call_method 0x4E4C00 struct [CPed] num_params 1 pop 0 [boat]</p>
<p>define function CPed__SetSeekBoatPosition&lt;thiscall, 0x4E4C00&gt;(boat)</p>
<h4>CPed::SetSeekCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *, unsigned int>(gaddrof(CPed::SetSeekCar), this, vehicle, doorNode);</p>
<p>0AA6: call_method 0x4D3EF0 struct [CPed] num_params 2 pop 0 [vehicle] [doorNode]</p>
<p>define function CPed__SetSeekCar&lt;thiscall, 0x4D3EF0&gt;(vehicle, doorNode)</p>
<h4>CPed::SetShootTimer</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetShootTimer), this, time);</p>
<p>0AA6: call_method 0x4D1340 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetShootTimer&lt;thiscall, 0x4D1340&gt;(time)</p>
<h4>CPed::SetSolicit</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned int>(gaddrof(CPed::SetSolicit), this, time);</p>
<p>0AA6: call_method 0x4D6620 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetSolicit&lt;thiscall, 0x4D6620&gt;(time)</p>
<h4>CPed::SetStoredObjective</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetStoredObjective), this);</p>
<p>0AA6: call_method 0x4D8220 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetStoredObjective&lt;thiscall, 0x4D8220&gt;()</p>
<h4>CPed::SetStoredState</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::SetStoredState), this);</p>
<p>0AA6: call_method 0x4C5DB0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetStoredState&lt;thiscall, 0x4C5DB0&gt;()</p>
<h4>CPed::SetWaitState</h4>
<p>plugin::CallMethodDynGlobal<CPed *, eWaitState, void *>(gaddrof(CPed::SetWaitState), this, state, time);</p>
<p>0AA6: call_method 0x4D58D0 struct [CPed] num_params 2 pop 0 [state] [time]</p>
<p>define function CPed__SetWaitState&lt;thiscall, 0x4D58D0&gt;(state, time)</p>
<h4>CPed::SetWanderPath</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, char>(gaddrof(CPed::SetWanderPath), this, pathStateDest);</p>
<p>0AA8: call_method_return 0x4D2750 struct [CPed] num_params 1 pop 0 [pathStateDest] func_ret [bool]</p>
<h4>CPed::Solicit</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Solicit), this);</p>
<p>0AA6: call_method 0x4D6780 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Solicit&lt;thiscall, 0x4D6780&gt;()</p>
<h4>CPed::SortPeds</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CPed **, int, int>(gaddrof(CPed::SortPeds), this, list, min, max);</p>
<p>0AA6: call_method 0x4C57F0 struct [CPed] num_params 3 pop 0 [list] [min] [max]</p>
<p>define function CPed__SortPeds&lt;thiscall, 0x4C57F0&gt;(list, min, max)</p>
<h4>CPed::SpawnFlyingComponent</h4>
<p>plugin::CallMethodDynGlobal<CPed *, int, char>(gaddrof(CPed::SpawnFlyingComponent), this, nodeId, direction);</p>
<p>0AA6: call_method 0x4EB060 struct [CPed] num_params 2 pop 0 [nodeId] [direction]</p>
<p>define function CPed__SpawnFlyingComponent&lt;thiscall, 0x4EB060&gt;(nodeId, direction)</p>
<h4>CPed::StartFightAttack</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned char>(gaddrof(CPed::StartFightAttack), this, buttonPressure);</p>
<p>0AA6: call_method 0x4E7530 struct [CPed] num_params 1 pop 0 [buttonPressure]</p>
<p>define function CPed__StartFightAttack&lt;thiscall, 0x4E7530&gt;(buttonPressure)</p>
<h4>CPed::StartFightDefend</h4>
<p>plugin::CallMethodDynGlobal<CPed *, unsigned char, unsigned char, unsigned char>(gaddrof(CPed::StartFightDefend), this, direction, hitLevel, strength);</p>
<p>0AA6: call_method 0x4E7780 struct [CPed] num_params 3 pop 0 [direction] [hitLevel] [strength]</p>
<p>define function CPed__StartFightDefend&lt;thiscall, 0x4E7780&gt;(direction, hitLevel, strength)</p>
<h4>CPed::StopNonPartialAnims</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::StopNonPartialAnims), this);</p>
<p>0AA6: call_method 0x4C5D50 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__StopNonPartialAnims&lt;thiscall, 0x4C5D50&gt;()</p>
<h4>CPed::TurnBody</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::TurnBody), this);</p>
<p>0AA8: call_method_return 0x4D1390 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::UpdateFromLeader</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::UpdateFromLeader), this);</p>
<p>0AA6: call_method 0x4D8F30 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__UpdateFromLeader&lt;thiscall, 0x4D8F30&gt;()</p>
<h4>CPed::UpdatePosition</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::UpdatePosition), this);</p>
<p>0AA6: call_method 0x4C7A00 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__UpdatePosition&lt;thiscall, 0x4C7A00&gt;()</p>
<h4>CPed::UseGroundColModel</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::UseGroundColModel), this);</p>
<p>0AA8: call_method_return 0x4CE730 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::Wait</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::Wait), this);</p>
<p>0AA6: call_method 0x4D5D80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Wait&lt;thiscall, 0x4D5D80&gt;()</p>
<h4>CPed::WanderPath</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::WanderPath), this);</p>
<p>0AA6: call_method 0x4D28D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__WanderPath&lt;thiscall, 0x4D28D0&gt;()</p>
<h4>CPed::WanderRange</h4>
<p>plugin::CallMethodDynGlobal<CPed *>(gaddrof(CPed::WanderRange), this);</p>
<p>0AA6: call_method 0x4D26C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__WanderRange&lt;thiscall, 0x4D26C0&gt;()</p>
<h4>CPed::WarpPedIntoCar</h4>
<p>plugin::CallMethodDynGlobal<CPed *, CVehicle *>(gaddrof(CPed::WarpPedIntoCar), this, vehicle);</p>
<p>0AA6: call_method 0x4D7D20 struct [CPed] num_params 1 pop 0 [vehicle]</p>
<p>define function CPed__WarpPedIntoCar&lt;thiscall, 0x4D7D20&gt;(vehicle)</p>
<h4>CPed::WarpPedToNearEntityOffScreen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CEntity *>(gaddrof(CPed::WarpPedToNearEntityOffScreen), this, warpTo);</p>
<p>0AA8: call_method_return 0x4E5570 struct [CPed] num_params 1 pop 0 [warpTo] func_ret [bool]</p>
<h4>CPed::WarpPedToNearLeaderOffScreen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *>(gaddrof(CPed::WarpPedToNearLeaderOffScreen), this);</p>
<p>0AA8: call_method_return 0x4E52A0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPed::WillChat</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPed *, CPed *>(gaddrof(CPed::WillChat), this, stranger);</p>
<p>0AA8: call_method_return 0x4C7340 struct [CPed] num_params 1 pop 0 [stranger] func_ret [bool]</p>
<h4>CPed::WorkOutHeadingForMovingFirstPerson</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CPed *, float>(gaddrof(CPed::WorkOutHeadingForMovingFirstPerson), this, offset);</p>
<p>0AA8: call_method_return 0x4C78F0 struct [CPed] num_params 1 pop 0 [offset] func_ret [float]</p>
<h4>CPed::FinishDieAnimCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishDieAnimCB), association, data);</p>
<h4>CPed::FinishFightMoveCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishFightMoveCB), association, data);</p>
<h4>CPed::FinishHitHeadCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishHitHeadCB), association, data);</p>
<h4>CPed::FinishJumpCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishJumpCB), association, data);</p>
<h4>CPed::FinishLaunchCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishLaunchCB), association, data);</p>
<h4>CPed::FinishedAttackCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishedAttackCB), association, data);</p>
<h4>CPed::FinishedWaitCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::FinishedWaitCB), association, data);</p>
<h4>CPed::PedAnimAlignCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimAlignCB), association, data);</p>
<h4>CPed::PedAnimDoorCloseCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorCloseCB), association, data);</p>
<h4>CPed::PedAnimDoorCloseRollingCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorCloseRollingCB), association, data);</p>
<h4>CPed::PedAnimDoorOpenCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimDoorOpenCB), association, data);</p>
<h4>CPed::PedAnimGetInCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimGetInCB), association, data);</p>
<h4>CPed::PedAnimPullPedOutCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimPullPedOutCB), association, data);</p>
<h4>CPed::PedAnimStepOutCarCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedAnimStepOutCarCB), association, data);</p>
<h4>CPed::PedEvadeCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedEvadeCB), association, data);</p>
<h4>CPed::PedGetupCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedGetupCB), association, data);</p>
<h4>CPed::PedLandCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedLandCB), association, data);</p>
<h4>CPed::PedSetDraggedOutCarCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetDraggedOutCarCB), association, data);</p>
<h4>CPed::PedSetDraggedOutCarPositionCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetDraggedOutCarPositionCB), association, data);</p>
<h4>CPed::PedSetInCarCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetInCarCB), association, data);</p>
<h4>CPed::PedSetInTrainCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetInTrainCB), association, data);</p>
<h4>CPed::PedSetOutCarCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetOutCarCB), association, data);</p>
<h4>CPed::PedSetOutTrainCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetOutTrainCB), association, data);</p>
<h4>CPed::PedSetQuickDraggedOutCarPositionCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedSetQuickDraggedOutCarPositionCB), association, data);</p>
<h4>CPed::PedStaggerCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::PedStaggerCB), association, data);</p>
<h4>CPed::RestoreHeadingRateCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(CPed::RestoreHeadingRateCB), association, data);</p>
<h4>FinishFuckUCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(FinishFuckUCB), anim, data);</p>
<h4>particleProduceFootSplash</h4>
<p>plugin::CallDynGlobal<CPed *, CVector const &, float, int>(gaddrof(particleProduceFootSplash), ped, pos, size, times);</p>
<h4>particleProduceFootDust</h4>
<p>plugin::CallDynGlobal<CPed *, CVector const &, float, int>(gaddrof(particleProduceFootDust), ped, pos, size, times);</p>
<h4>*RemoveAllModelCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(RemoveAllModelCB), object, data);</p>
<p>0AA7: call_function_return 0x4CF950 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function RemoveAllModelCB&lt;cdecl, 0x4CF950&gt;(object, data): int</p>
<h4>AddYardieDoorSmoke</h4>
<p>plugin::CallDynGlobal<CVehicle *, unsigned int>(gaddrof(AddYardieDoorSmoke), vehicle, doorNode);</p>
<h4>CheckForPedsOnGroundToAttack</h4>
<p>plugin::CallAndReturnDynGlobal<int, CPed *, CPed **>(gaddrof(CheckForPedsOnGroundToAttack), attacker, pedOnGround);</p>
<p>0AA7: call_function_return 0x4E5BD0 num_params 2 pop 2 [attacker] [pedOnGround] func_ret [int]</p>
<p>define function CheckForPedsOnGroundToAttack&lt;cdecl, 0x4E5BD0&gt;(attacker, pedOnGround): int</p>
<h4>*SetPedAtomicVisibilityCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(SetPedAtomicVisibilityCB), object, data);</p>
<p>0AA7: call_function_return 0x4EAE10 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function SetPedAtomicVisibilityCB&lt;cdecl, 0x4EAE10&gt;(object, data): int</p>
<h4>*RecurseFrameChildrenVisibilityCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(RecurseFrameChildrenVisibilityCB), frame, data);</p>
<p>0AA7: call_function_return 0x4EAE20 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function RecurseFrameChildrenVisibilityCB&lt;cdecl, 0x4EAE20&gt;(frame, data): int</p>
<h4>*CloneAtomicToFrameCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CloneAtomicToFrameCB), object, data);</p>
<p>0AA7: call_function_return 0x4EAE50 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function CloneAtomicToFrameCB&lt;cdecl, 0x4EAE50&gt;(object, data): int</p>
<h4>*RecurseFrameChildrenToCloneCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(RecurseFrameChildrenToCloneCB), frame, data);</p>
<p>0AA7: call_function_return 0x4EAE90 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function RecurseFrameChildrenToCloneCB&lt;cdecl, 0x4EAE90&gt;(frame, data): int</p><h3 id="plugin_iiigame_iiicpedikcpp">plugin_III\game_III\CPedIK.cpp</h3><h4>CPedIK::ExtractYawAndPitchLocal</h4>
<p>plugin::CallMethodDynGlobal<CPedIK *, RwMatrix *, float *, float *>(gaddrof(CPedIK::ExtractYawAndPitchLocal), this, matrix, yaw, pitch);</p>
<p>0AA6: call_method 0x4ED2C0 struct [CPedIK] num_params 3 pop 0 [matrix] [yaw] [pitch]</p>
<p>define function CPedIK__ExtractYawAndPitchLocal&lt;thiscall, 0x4ED2C0&gt;(matrix, yaw, pitch)</p>
<h4>CPedIK::ExtractYawAndPitchWorld</h4>
<p>plugin::CallMethodDynGlobal<CPedIK *, RwMatrix *, float *, float *>(gaddrof(CPedIK::ExtractYawAndPitchWorld), this, matrix, yaw, pitch);</p>
<p>0AA6: call_method 0x4ED140 struct [CPedIK] num_params 3 pop 0 [matrix] [yaw] [pitch]</p>
<p>define function CPedIK__ExtractYawAndPitchWorld&lt;thiscall, 0x4ED140&gt;(matrix, yaw, pitch)</p>
<h4>CPedIK::GetComponentPosition</h4>
<p>plugin::CallMethodDynGlobal<CPedIK *, RwV3d &, unsigned int>(gaddrof(CPedIK::GetComponentPosition), this, pos, node);</p>
<p>0AA6: call_method 0x4ED0F0 struct [CPedIK] num_params 2 pop 0 [pos] [node]</p>
<p>define function CPedIK__GetComponentPosition&lt;thiscall, 0x4ED0F0&gt;(pos, node)</p>
<h4>CPedIK::Init</h4>
<p>plugin::CallMethodDynGlobal<CPedIK *, CPed *>(gaddrof(CPedIK::Init), this, ped);</p>
<p>0AA6: call_method 0x4ED010 struct [CPedIK] num_params 1 pop 0 [ped]</p>
<p>define function CPedIK__Init&lt;thiscall, 0x4ED010&gt;(ped)</p>
<h4>CPedIK::LookAtPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, CVector const &>(gaddrof(CPedIK::LookAtPosition), this, pos);</p>
<p>0AA8: call_method_return 0x4ED590 struct [CPedIK] num_params 1 pop 0 [pos] func_ret [bool]</p>
<h4>CPedIK::LookInDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::LookInDirection), this, targetYaw, targetPitch);</p>
<p>0AA8: call_method_return 0x4ED620 struct [CPedIK] num_params 2 pop 0 [targetYaw] [targetPitch] func_ret [bool]</p>
<h4>CPedIK::MoveLimb</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CPedIK *, LimbOrientation &, float, float, LimbMovementInfo &>(gaddrof(CPedIK::MoveLimb), this, limb, targetYaw, targetPitch, moveInfo);</p>
<p>0AA8: call_method_return 0x4ED440 struct [CPedIK] num_params 4 pop 0 [limb] [targetYaw] [targetPitch] [moveInfo] func_ret [unsigned int]</p>
<h4>CPedIK::PointGunAtPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, CVector const &>(gaddrof(CPedIK::PointGunAtPosition), this, pos);</p>
<p>0AA8: call_method_return 0x4ED920 struct [CPedIK] num_params 1 pop 0 [pos] func_ret [bool]</p>
<h4>CPedIK::PointGunInDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::PointGunInDirection), this, targetYaw, targetPitch);</p>
<p>0AA8: call_method_return 0x4ED9B0 struct [CPedIK] num_params 2 pop 0 [targetYaw] [targetPitch] func_ret [bool]</p>
<h4>CPedIK::PointGunInDirectionUsingArm</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *, float, float>(gaddrof(CPedIK::PointGunInDirectionUsingArm), this, targetYaw, targetPitch);</p>
<p>0AA8: call_method_return 0x4EDB20 struct [CPedIK] num_params 2 pop 0 [targetYaw] [targetPitch] func_ret [bool]</p>
<h4>CPedIK::RestoreGunPosn</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *>(gaddrof(CPedIK::RestoreGunPosn), this);</p>
<p>0AA8: call_method_return 0x4EDD70 struct [CPedIK] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPedIK::RestoreLookAt</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedIK *>(gaddrof(CPedIK::RestoreLookAt), this);</p>
<p>0AA8: call_method_return 0x4ED810 struct [CPedIK] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPedIK::RotateTorso</h4>
<p>plugin::CallMethodDynGlobal<CPedIK *, AnimBlendFrameData *, LimbOrientation &, bool>(gaddrof(CPedIK::RotateTorso), this, frameData, limb, changeRoll);</p>
<p>0AA6: call_method 0x4EDDB0 struct [CPedIK] num_params 3 pop 0 [frameData] [limb] [changeRoll]</p>
<p>define function CPedIK__RotateTorso&lt;thiscall, 0x4EDDB0&gt;(frameData, limb, changeRoll)</p>
<h4>*CPedIK::GetWorldMatrix</h4>
<p>plugin::CallAndReturnDynGlobal<RwMatrix *, RwFrame *, RwMatrix *>(gaddrof(CPedIK::GetWorldMatrix), frame, matrix);</p>
<p>0AA7: call_function_return 0x4ED060 num_params 2 pop 2 [frame] [matrix] func_ret [RwMatrix *]</p>
<p>define function CPedIK__GetWorldMatrix&lt;cdecl, 0x4ED060&gt;(frame, matrix): int</p><h3 id="plugin_iiigame_iiicpedmodelinfocpp">plugin_III\game_III\CPedModelInfo.cpp</h3><h4>CPedModelInfo::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<2, CPedModelInfo *>(this);</p>
<h4>CPedModelInfo::SetClump</h4>
<p>plugin::CallVirtualMethod<6, CPedModelInfo *, RpClump *>(this, clump);</p>
<h4>CPedModelInfo::CreateHitColModel</h4>
<p>plugin::CallMethodDynGlobal<CPedModelInfo *>(gaddrof(CPedModelInfo::CreateHitColModel), this);</p>
<p>0AA6: call_method 0x5104D0 struct [CPedModelInfo] num_params 0 pop 0</p>
<p>define function CPedModelInfo__CreateHitColModel&lt;thiscall, 0x5104D0&gt;()</p>
<h4>CPedModelInfo::SetLowDetailClump</h4>
<p>plugin::CallMethodDynGlobal<CPedModelInfo *, RpClump *>(gaddrof(CPedModelInfo::SetLowDetailClump), this, clump);</p>
<p>0AA6: call_method 0x510390 struct [CPedModelInfo] num_params 1 pop 0 [clump]</p>
<p>define function CPedModelInfo__SetLowDetailClump&lt;thiscall, 0x510390&gt;(clump)</p><h3 id="plugin_iiigame_iiicpedpathcpp">plugin_III\game_III\CPedPath.cpp</h3><h4>CPedPath::AddBlockade</h4>
<p>plugin::CallDynGlobal<CEntity *, CPedPathNode(*)[40], CVector *>(gaddrof(CPedPath::AddBlockade), entity, pathNodes, posn);</p>
<h4>CPedPath::AddBlockadeSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, CPedPathNode(*)[40], CVector *>(gaddrof(CPedPath::AddBlockadeSectorList), list, pathNodes, posn);</p>
<h4>CPedPath::AddNodeToList</h4>
<p>plugin::CallDynGlobal<CPedPathNode *, short, CPedPathNode *>(gaddrof(CPedPath::AddNodeToList), pNode, index, pList);</p>
<h4>CPedPath::AddNodeToPathList</h4>
<p>plugin::CallDynGlobal<CPedPathNode *, short, CPedPathNode *>(gaddrof(CPedPath::AddNodeToPathList), pNode, index, pNodeList);</p>
<h4>CPedPath::CalcPedRoute</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned char, CVector, CVector, CVector *, short *, short>(gaddrof(CPedPath::CalcPedRoute), pathType, position, destination, pointPoses, pointsFound, maxPoints);</p>
<p>0AA7: call_function_return 0x42E680 num_params 6 pop 6 [pathType] [position] [destination] [pointPoses] [pointsFound] [maxPoints] func_ret [bool]</p>
<p>define function CPedPath__CalcPedRoute&lt;cdecl, 0x42E680&gt;(pathType, position, destination, pointPoses, pointsFound, maxPoints): int</p>
<h4>CPedPath::RemoveNodeFromList</h4>
<p>plugin::CallDynGlobal<CPedPathNode *>(gaddrof(CPedPath::RemoveNodeFromList), node);</p><h3 id="plugin_iiigame_iiicpedplacementcpp">plugin_III\game_III\CPedPlacement.cpp</h3><h4>CPedPlacement::FindZCoorForPed</h4>
<p>plugin::CallDynGlobal<CVector *>(gaddrof(CPedPlacement::FindZCoorForPed), position);</p>
<h4>CPedPlacement::IsPositionClearForPed</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPedPlacement::IsPositionClearForPed), position);</p>
<p>0AA7: call_function_return 0x4EE2C0 num_params 1 pop 1 [position] func_ret [bool]</p>
<p>define function CPedPlacement__IsPositionClearForPed&lt;cdecl, 0x4EE2C0&gt;(position): int</p>
<h4>*CPedPlacement::IsPositionClearOfCars</h4>
<p>plugin::CallAndReturnDynGlobal<CEntity *, CVector *>(gaddrof(CPedPlacement::IsPositionClearOfCars), position);</p>
<p>0AA7: call_function_return 0x4EE310 num_params 1 pop 1 [position] func_ret [CEntity *]</p>
<p>define function CPedPlacement__IsPositionClearOfCars&lt;cdecl, 0x4EE310&gt;(position): int</p><h3 id="plugin_iiigame_iiicpedstatscpp">plugin_III\game_III\CPedStats.cpp</h3><h4>CPedStats::GetPedStatType</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, char *>(gaddrof(CPedStats::GetPedStatType), name);</p>
<p>0AA7: call_function_return 0x4EF780 num_params 1 pop 1 [name] func_ret [unsigned int]</p>
<p>define function CPedStats__GetPedStatType&lt;cdecl, 0x4EF780&gt;(name): int</p><h3 id="plugin_iiigame_iiicpedtypecpp">plugin_III\game_III\CPedType.cpp</h3><h4>CPedType::FindPedFlag</h4>
<p>plugin::CallAndReturn<unsigned int, 0x4EEF40, char*>(flagName);</p>
<p>0AA7: call_function_return 0x4EEF40 num_params 1 pop 1 [flagName] func_ret [unsigned int]</p>
<p>define function CPedType__FindPedFlag&lt;cdecl, 0x4EEF40&gt;(flagName): int</p>
<h4>CPedType::FindPedType</h4>
<p>plugin::CallAndReturn<unsigned int, 0x4EEC10, char*>(pedName);</p>
<p>0AA7: call_function_return 0x4EEC10 num_params 1 pop 1 [pedName] func_ret [unsigned int]</p>
<p>define function CPedType__FindPedType&lt;cdecl, 0x4EEC10&gt;(pedName): int</p>
<h4>CPedType::Initialise</h4>
<p>plugin::Call<0x4EE7E0>();</p>
<p>0AA5: call_function 0x4EE7E0 num_params 0 pop 0</p>
<p>define function CPedType__Initialise&lt;cdecl, 0x4EE7E0&gt;()</p>
<h4>CPedType::Load</h4>
<p>plugin::Call<0x4EF3D0, unsigned char*, unsigned int>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4EF3D0 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CPedType__Load&lt;cdecl, 0x4EF3D0&gt;(bufferPointer, structSize)</p>
<h4>CPedType::LoadPedData</h4>
<p>plugin::Call<0x4EE8D0>();</p>
<p>0AA5: call_function 0x4EE8D0 num_params 0 pop 0</p>
<p>define function CPedType__LoadPedData&lt;cdecl, 0x4EE8D0&gt;()</p>
<h4>CPedType::Save</h4>
<p>plugin::Call<0x4EF320, unsigned char<em>, unsigned int</em>>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4EF320 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CPedType__Save&lt;cdecl, 0x4EF320&gt;(bufferPointer, structSize)</p>
<h4>CPedType::Shutdown</h4>
<p>plugin::Call<0x4EE890>();</p>
<p>0AA5: call_function 0x4EE890 num_params 0 pop 0</p>
<p>define function CPedType__Shutdown&lt;cdecl, 0x4EE890&gt;()</p><h3 id="plugin_iiigame_iiicphoneinfocpp">plugin_III\game_III\CPhoneInfo.cpp</h3><h4>CPhoneInfo::FindNearestFreePhone</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, CVector *>(gaddrof(CPhoneInfo::FindNearestFreePhone), this, point);</p>
<p>0AA8: call_method_return 0x42F720 struct [CPhoneInfo] num_params 1 pop 0 [point] func_ret [int]</p>
<h4>CPhoneInfo::GrabPhone</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, float, float>(gaddrof(CPhoneInfo::GrabPhone), this, x, y);</p>
<p>0AA8: call_method_return 0x42FDB0 struct [CPhoneInfo] num_params 2 pop 0 [x] [y] func_ret [int]</p>
<h4>CPhoneInfo::HasMessageBeenDisplayed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, int>(gaddrof(CPhoneInfo::HasMessageBeenDisplayed), this, index);</p>
<p>0AA8: call_method_return 0x42FFF0 struct [CPhoneInfo] num_params 1 pop 0 [index] func_ret [bool]</p>
<h4>CPhoneInfo::Initialise</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Initialise), this);</p>
<p>0AA6: call_method 0x42F640 struct [CPhoneInfo] num_params 0 pop 0</p>
<p>define function CPhoneInfo__Initialise&lt;thiscall, 0x42F640&gt;()</p>
<h4>CPhoneInfo::IsMessageBeingDisplayed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, int>(gaddrof(CPhoneInfo::IsMessageBeingDisplayed), this, index);</p>
<p>0AA8: call_method_return 0x430030 struct [CPhoneInfo] num_params 1 pop 0 [index] func_ret [bool]</p>
<h4>CPhoneInfo::Load</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int>(gaddrof(CPhoneInfo::Load), this, buf, size);</p>
<p>0AA6: call_method 0x430120 struct [CPhoneInfo] num_params 2 pop 0 [buf] [size]</p>
<p>define function CPhoneInfo__Load&lt;thiscall, 0x430120&gt;(buf, size)</p>
<h4>CPhoneInfo::PhoneAtThisPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhoneInfo *, CVector>(gaddrof(CPhoneInfo::PhoneAtThisPosition), this, point);</p>
<p>0AA8: call_method_return 0x42FD50 struct [CPhoneInfo] num_params 1 pop 0 [point] func_ret [bool]</p>
<h4>CPhoneInfo::Save</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int *>(gaddrof(CPhoneInfo::Save), this, buf, size);</p>
<p>0AA6: call_method 0x430060 struct [CPhoneInfo] num_params 2 pop 0 [buf] [size]</p>
<p>define function CPhoneInfo__Save&lt;thiscall, 0x430060&gt;(buf, size)</p>
<h4>CPhoneInfo::SetPhoneMessage_JustOnce</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_JustOnce), this, index, text_1, text_2, text_3, text_4, text_5, text_6);</p>
<p>0AA6: call_method 0x42FF90 struct [CPhoneInfo] num_params 7 pop 0 [index] [text_1] [text_2] [text_3] [text_4] [text_5] [text_6]</p>
<p>define function CPhoneInfo__SetPhoneMessage_JustOnce&lt;thiscall, 0x42FF90&gt;(index, text_1, text_2, text_3, text_4, text_5, text_6)</p>
<h4>CPhoneInfo::SetPhoneMessage_Repeatedly</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_Repeatedly), this, index, text_1, text_2, text_3, text_4, text_5, text_6);</p>
<p>0AA6: call_method 0x42FF30 struct [CPhoneInfo] num_params 7 pop 0 [index] [text_1] [text_2] [text_3] [text_4] [text_5] [text_6]</p>
<p>define function CPhoneInfo__SetPhoneMessage_Repeatedly&lt;thiscall, 0x42FF30&gt;(index, text_1, text_2, text_3, text_4, text_5, text_6)</p>
<h4>CPhoneInfo::Shutdown</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Shutdown), this);</p>
<p>0AA6: call_method 0x42F710 struct [CPhoneInfo] num_params 0 pop 0</p>
<p>define function CPhoneInfo__Shutdown&lt;thiscall, 0x42F710&gt;()</p>
<h4>CPhoneInfo::Update</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Update), this);</p>
<p>0AA6: call_method 0x42F7A0 struct [CPhoneInfo] num_params 0 pop 0</p>
<p>define function CPhoneInfo__Update&lt;thiscall, 0x42F7A0&gt;()</p>
<h4>PhonePickUpCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(PhonePickUpCB), association, data);</p>
<h4>PhonePutDownCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, void *>(gaddrof(PhonePutDownCB), association, data);</p><h3 id="plugin_iiigame_iiicphysicalcpp">plugin_III\game_III\CPhysical.cpp</h3><h4>CPhysical::Add</h4>
<p>plugin::CallVirtualMethod<1, CPhysical *>(this);</p>
<h4>CPhysical::Remove</h4>
<p>plugin::CallVirtualMethod<2, CPhysical *>(this);</p>
<h4>*CPhysical::GetBoundRect</h4>
<p>plugin::CallVirtualMethodAndReturn<CRect *, 7, CPhysical *>(this);</p>
<h4>CPhysical::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CPhysical *>(this);</p>
<h4>CPhysical::ProcessCollision</h4>
<p>plugin::CallVirtualMethod<9, CPhysical *>(this);</p>
<h4>CPhysical::ProcessShift</h4>
<p>plugin::CallVirtualMethod<10, CPhysical *>(this);</p>
<h4>CPhysical::ProcessEntityCollision</h4>
<p>plugin::CallVirtualMethod<17, CPhysical *, CEntity *, CColPoint *>(this, entity, colPoint);</p>
<h4>CPhysical::AddCollisionRecord</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::AddCollisionRecord), this, entity);</p>
<p>0AA6: call_method 0x497180 struct [CPhysical] num_params 1 pop 0 [entity]</p>
<p>define function CPhysical__AddCollisionRecord&lt;thiscall, 0x497180&gt;(entity)</p>
<h4>CPhysical::AddCollisionRecord_Treadable</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::AddCollisionRecord_Treadable), this, entity);</p>
<p>0AA6: call_method 0x4970C0 struct [CPhysical] num_params 1 pop 0 [entity]</p>
<p>define function CPhysical__AddCollisionRecord_Treadable&lt;thiscall, 0x4970C0&gt;(entity)</p>
<h4>CPhysical::AddToMovingList</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::AddToMovingList), this);</p>
<p>0AA6: call_method 0x4958F0 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__AddToMovingList&lt;thiscall, 0x4958F0&gt;()</p>
<h4>CPhysical::ApplyAirResistance</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyAirResistance), this);</p>
<p>0AA6: call_method 0x495C20 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__ApplyAirResistance&lt;thiscall, 0x495C20&gt;()</p>
<h4>CPhysical::ApplyCollision</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPhysical *, CColPoint &, float *, float *>(gaddrof(CPhysical::ApplyCollision), this, physical, colPoint, impulseA, impulseB);</p>
<p>0AA8: call_method_return 0x4973A0 struct [CPhysical] num_params 4 pop 0 [physical] [colPoint] [impulseA] [impulseB] func_ret [bool]</p>
<h4>CPhysical::ApplyCollisionAlt</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CEntity *, CColPoint &, float *, CVector &, CVector &>(gaddrof(CPhysical::ApplyCollisionAlt), this, entity, colPoint, impulse, moveSpeed, turnSpeed);</p>
<p>0AA8: call_method_return 0x4992A0 struct [CPhysical] num_params 5 pop 0 [entity] [colPoint] [impulse] [moveSpeed] [turnSpeed] func_ret [bool]</p>
<h4>CPhysical::ApplyFriction</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof_o(CPhysical::ApplyFriction, void (CPhysical::*)()), this);</p>
<p>0AA6: call_method 0x49A180 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__ApplyFriction&lt;thiscall, 0x49A180&gt;()</p>
<h4>CPhysical::ApplyFriction</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPhysical <em>, float, CColPoint &>(gaddrof_o(CPhysical::ApplyFriction, bool (CPhysical::</em>)(float, CColPoint &amp;)), this, adhesiveLimit, colPoint);</p>
<p>0AA8: call_method_return 0x49A180 struct [CPhysical] num_params 2 pop 0 [adhesiveLimit] [colPoint] func_ret [bool]</p>
<h4>CPhysical::ApplyFriction</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPhysical *, float, CColPoint &>(gaddrof_o(CPhysical::ApplyFriction, bool (CPhysical::*)(CPhysical *, float, CColPoint &amp;)), this, physical, adhesiveLimit, colPoint);</p>
<p>0AA8: call_method_return 0x49A180 struct [CPhysical] num_params 3 pop 0 [physical] [adhesiveLimit] [colPoint] func_ret [bool]</p>
<h4>CPhysical::ApplyFrictionMoveForce</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, float, float, float>(gaddrof(CPhysical::ApplyFrictionMoveForce), this, jx, jy, jz);</p>
<p>0AA6: call_method 0x495D90 struct [CPhysical] num_params 3 pop 0 [jx] [jy] [jz]</p>
<p>define function CPhysical__ApplyFrictionMoveForce&lt;thiscall, 0x495D90&gt;(jx, jy, jz)</p>
<h4>CPhysical::ApplyFrictionTurnForce</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, float, float, float, float, float, float>(gaddrof(CPhysical::ApplyFrictionTurnForce), this, jx, jy, jz, rx, ry, rz);</p>
<p>0AA6: call_method 0x495E10 struct [CPhysical] num_params 6 pop 0 [jx] [jy] [jz] [rx] [ry] [rz]</p>
<p>define function CPhysical__ApplyFrictionTurnForce&lt;thiscall, 0x495E10&gt;(jx, jy, jz, rx, ry, rz)</p>
<h4>CPhysical::ApplyGravity</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyGravity), this);</p>
<p>0AA6: call_method 0x495B50 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__ApplyGravity&lt;thiscall, 0x495B50&gt;()</p>
<h4>CPhysical::ApplyMoveForce</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, float, float, float>(gaddrof(CPhysical::ApplyMoveForce), this, jx, jy, jz);</p>
<p>0AA6: call_method 0x4959A0 struct [CPhysical] num_params 3 pop 0 [jx] [jy] [jz]</p>
<p>define function CPhysical__ApplyMoveForce&lt;thiscall, 0x4959A0&gt;(jx, jy, jz)</p>
<h4>CPhysical::ApplyMoveSpeed</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyMoveSpeed), this);</p>
<p>0AA6: call_method 0x495B10 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__ApplyMoveSpeed&lt;thiscall, 0x495B10&gt;()</p>
<h4>CPhysical::ApplySpringCollisionAlt</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CVector &, CVector &, float, float>(gaddrof(CPhysical::ApplySpringCollisionAlt), this, springConst, springDir, point, springRatio, bias);</p>
<p>0AA8: call_method_return 0x499890 struct [CPhysical] num_params 5 pop 0 [springConst] [springDir] [point] [springRatio] [bias] func_ret [bool]</p>
<h4>CPhysical::ApplySpringDampening</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, float, CVector &, CVector &, CVector &>(gaddrof(CPhysical::ApplySpringDampening), this, damping, springDir, point, speed);</p>
<p>0AA8: call_method_return 0x499990 struct [CPhysical] num_params 4 pop 0 [damping] [springDir] [point] [speed] func_ret [bool]</p>
<h4>CPhysical::ApplyTurnForce</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, float, float, float, float, float, float>(gaddrof(CPhysical::ApplyTurnForce), this, jx, jy, jz, px, py, pz);</p>
<p>0AA6: call_method 0x495A10 struct [CPhysical] num_params 6 pop 0 [jx] [jy] [jz] [px] [py] [pz]</p>
<p>define function CPhysical__ApplyTurnForce&lt;thiscall, 0x495A10&gt;(jx, jy, jz, px, py, pz)</p>
<h4>CPhysical::ApplyTurnSpeed</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::ApplyTurnSpeed), this);</p>
<p>0AA6: call_method 0x497280 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__ApplyTurnSpeed&lt;thiscall, 0x497280&gt;()</p>
<h4>CPhysical::CheckCollision</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *>(gaddrof(CPhysical::CheckCollision), this);</p>
<p>0AA8: call_method_return 0x496E50 struct [CPhysical] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPhysical::CheckCollision_SimpleCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *>(gaddrof(CPhysical::CheckCollision_SimpleCar), this);</p>
<p>0AA8: call_method_return 0x496EB0 struct [CPhysical] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPhysical::GetHasCollidedWith</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CEntity *>(gaddrof(CPhysical::GetHasCollidedWith), this, entity);</p>
<p>0AA8: call_method_return 0x497240 struct [CPhysical] num_params 1 pop 0 [entity] func_ret [bool]</p>
<h4>CPhysical::ProcessCollisionSectorList</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPtrList *>(gaddrof(CPhysical::ProcessCollisionSectorList), this, list);</p>
<p>0AA8: call_method_return 0x49B620 struct [CPhysical] num_params 1 pop 0 [list] func_ret [bool]</p>
<h4>CPhysical::ProcessCollisionSectorList_SimpleCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CSector *>(gaddrof(CPhysical::ProcessCollisionSectorList_SimpleCar), this, sector);</p>
<p>0AA8: call_method_return 0x49E790 struct [CPhysical] num_params 1 pop 0 [sector] func_ret [bool]</p>
<h4>CPhysical::ProcessShiftSectorList</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPhysical *, CPtrList *>(gaddrof(CPhysical::ProcessShiftSectorList), this, list);</p>
<p>0AA8: call_method_return 0x49DA10 struct [CPhysical] num_params 1 pop 0 [list] func_ret [bool]</p>
<h4>CPhysical::RemoveAndAdd</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::RemoveAndAdd), this);</p>
<p>0AA6: call_method 0x495540 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__RemoveAndAdd&lt;thiscall, 0x495540&gt;()</p>
<h4>CPhysical::RemoveFromMovingList</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *>(gaddrof(CPhysical::RemoveFromMovingList), this);</p>
<p>0AA6: call_method 0x495940 struct [CPhysical] num_params 0 pop 0</p>
<p>define function CPhysical__RemoveFromMovingList&lt;thiscall, 0x495940&gt;()</p>
<h4>CPhysical::RemoveRefsToEntity</h4>
<p>plugin::CallMethodDynGlobal<CPhysical *, CEntity *>(gaddrof(CPhysical::RemoveRefsToEntity), this, entity);</p>
<p>0AA6: call_method 0x49F820 struct [CPhysical] num_params 1 pop 0 [entity]</p>
<p>define function CPhysical__RemoveRefsToEntity&lt;thiscall, 0x49F820&gt;(entity)</p>
<h4>CPhysical::PlacePhysicalRelativeToOtherPhysical</h4>
<p>plugin::CallDynGlobal<CPhysical *, CPhysical *, CVector>(gaddrof(CPhysical::PlacePhysicalRelativeToOtherPhysical), other, physical, localPos);</p><h3 id="plugin_iiigame_iiicpickupcpp">plugin_III\game_III\CPickup.cpp</h3><h4>*CPickup::GiveUsAPickUpObject</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CObject *, CPickup *, int>(gaddrof(CPickup::GiveUsAPickUpObject), this, handle);</p>
<p>0AA8: call_method_return 0x433BA0 struct [*CPickup] num_params 1 pop 0 [handle] func_ret [CObject *]</p>
<h4>CPickup::Update</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPickup *, CPlayerPed *, CVehicle *, int>(gaddrof(CPickup::Update), this, player, vehicle, playerId);</p>
<p>0AA8: call_method_return 0x430860 struct [CPickup] num_params 3 pop 0 [player] [vehicle] [playerId] func_ret [bool]</p><h3 id="plugin_iiigame_iiicpickupscpp">plugin_III\game_III\CPickups.cpp</h3><h4>CPickups::AddToCollectedPickupsArray</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPickups::AddToCollectedPickupsArray), index);</p>
<h4>CPickups::DoCollectableEffects</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoCollectableEffects), entity);</p>
<h4>CPickups::DoMineEffects</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoMineEffects), entity);</p>
<h4>CPickups::DoMoneyEffects</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CPickups::DoMoneyEffects), entity);</p>
<h4>CPickups::DoPickUpEffects</h4>
<p>plugin::CallDynGlobal<CObject *>(gaddrof(CPickups::DoPickUpEffects), entity);</p>
<h4>CPickups::FindColourIndexForWeaponMI</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::FindColourIndexForWeaponMI), model);</p>
<p>0AA7: call_function_return 0x431510 num_params 1 pop 1 [model] func_ret [int]</p>
<p>define function CPickups__FindColourIndexForWeaponMI&lt;cdecl, 0x431510&gt;(model): int</p>
<h4>CPickups::GenerateNewOne</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector, unsigned int, unsigned char, unsigned int>(gaddrof(CPickups::GenerateNewOne), pos, modelIndex, type, quantity);</p>
<p>0AA7: call_function_return 0x4304B0 num_params 4 pop 4 [pos] [modelIndex] [type] [quantity] func_ret [int]</p>
<p>define function CPickups__GenerateNewOne&lt;cdecl, 0x4304B0&gt;(pos, modelIndex, type, quantity): int</p>
<h4>CPickups::GenerateNewOne_WeaponType</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector, eWeaponType, unsigned char, unsigned int>(gaddrof(CPickups::GenerateNewOne_WeaponType), pos, weaponType, type, quantity);</p>
<p>0AA7: call_function_return 0x430660 num_params 4 pop 4 [pos] [weaponType] [type] [quantity] func_ret [int]</p>
<p>define function CPickups__GenerateNewOne_WeaponType&lt;cdecl, 0x430660&gt;(pos, weaponType, type, quantity): int</p>
<h4>CPickups::GetActualPickupIndex</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::GetActualPickupIndex), index);</p>
<p>0AA7: call_function_return 0x433DF0 num_params 1 pop 1 [index] func_ret [int]</p>
<p>define function CPickups__GetActualPickupIndex&lt;cdecl, 0x433DF0&gt;(index): int</p>
<h4>CPickups::GetNewUniquePickupIndex</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPickups::GetNewUniquePickupIndex), handle);</p>
<p>0AA7: call_function_return 0x433DB0 num_params 1 pop 1 [handle] func_ret [int]</p>
<p>define function CPickups__GetNewUniquePickupIndex&lt;cdecl, 0x433DB0&gt;(handle): int</p>
<h4>CPickups::GivePlayerGoodiesWithPickUpMI</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned short, int>(gaddrof(CPickups::GivePlayerGoodiesWithPickUpMI), modelId, playerId);</p>
<p>0AA7: call_function_return 0x4339F0 num_params 2 pop 2 [modelId] [playerId] func_ret [bool]</p>
<p>define function CPickups__GivePlayerGoodiesWithPickUpMI&lt;cdecl, 0x4339F0&gt;(modelId, playerId): int</p>
<h4>CPickups::IsPickUpPickedUp</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CPickups::IsPickUpPickedUp), handle);</p>
<p>0AA7: call_function_return 0x430770 num_params 1 pop 1 [handle] func_ret [bool]</p>
<p>define function CPickups__IsPickUpPickedUp&lt;cdecl, 0x430770&gt;(handle): int</p>
<h4>CPickups::Load</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPickups::Load), buf, size);</p>
<h4>CPickups::ModelForWeapon</h4>
<p>plugin::CallAndReturnDynGlobal<int, eWeaponType>(gaddrof(CPickups::ModelForWeapon), weaponType);</p>
<p>0AA7: call_function_return 0x430690 num_params 1 pop 1 [weaponType] func_ret [int]</p>
<p>define function CPickups__ModelForWeapon&lt;cdecl, 0x430690&gt;(weaponType): int</p>
<h4>CPickups::PassTime</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CPickups::PassTime), time);</p>
<h4>CPickups::RemovePickUp</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPickups::RemovePickUp), handle);</p>
<h4>CPickups::Save</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPickups::Save), buf, size);</p>
<h4>CPickups::WeaponForModel</h4>
<p>plugin::CallAndReturnDynGlobal<eWeaponType, int>(gaddrof(CPickups::WeaponForModel), model);</p>
<p>0AA7: call_function_return 0x4306F0 num_params 1 pop 1 [model] func_ret [eWeaponType]</p>
<p>define function CPickups__WeaponForModel&lt;cdecl, 0x4306F0&gt;(model): int</p><h3 id="plugin_iiigame_iiicplaceablecpp">plugin_III\game_III\CPlaceable.cpp</h3><h4>&amp;CPlaceable::GetPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVector &, CPlaceable *>(gaddrof(CPlaceable::GetPosition), this);</p>
<p>0AA8: call_method_return 0x4CBAC0 struct [&amp;CPlaceable] num_params 0 pop 0 func_ret [CVector &amp;]</p>
<h4>CPlaceable::IsWithinArea</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPlaceable <em>, float, float, float, float>(gaddrof_o(CPlaceable::IsWithinArea, bool (CPlaceable::</em>)(float, float, float, float)), this, x1, y1, x2, y2);</p>
<p>0AA8: call_method_return 0x49FAF0 struct [CPlaceable] num_params 4 pop 0 [x1] [y1] [x2] [y2] func_ret [bool]</p>
<h4>CPlaceable::IsWithinArea</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPlaceable <em>, float, float, float, float, float, float>(gaddrof_o(CPlaceable::IsWithinArea, bool (CPlaceable::</em>)(float, float, float, float, float, float)), this, x1, y1, z1, x2, y2, z2);</p>
<p>0AA8: call_method_return 0x49FAF0 struct [CPlaceable] num_params 6 pop 0 [x1] [y1] [z1] [x2] [y2] [z2] func_ret [bool]</p>
<h4>CPlaceable::SetHeading</h4>
<p>plugin::CallMethodDynGlobal<CPlaceable *, float>(gaddrof(CPlaceable::SetHeading), this, angle);</p>
<p>0AA6: call_method 0x49FA00 struct [CPlaceable] num_params 1 pop 0 [angle]</p>
<p>define function CPlaceable__SetHeading&lt;thiscall, 0x49FA00&gt;(angle)</p>
<h4>CPlaceable::SetPosition</h4>
<p>plugin::CallMethodDynGlobal<CPlaceable *, float, float, float>(gaddrof(CPlaceable::SetPosition), this, x, y, z);</p>
<p>0AA6: call_method 0x4CBA50 struct [CPlaceable] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CPlaceable__SetPosition&lt;thiscall, 0x4CBA50&gt;(x, y, z)</p><h3 id="plugin_iiigame_iiicplacenamecpp">plugin_III\game_III\CPlaceName.cpp</h3><h4>CPlaceName::Display</h4>
<p>plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Display), this);</p>
<p>0AA6: call_method 0x4AD5B0 struct [CPlaceName] num_params 0 pop 0</p>
<p>define function CPlaceName__Display&lt;thiscall, 0x4AD5B0&gt;()</p>
<h4>CPlaceName::Init</h4>
<p>plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Init), this);</p>
<p>0AA6: call_method 0x4AD4C0 struct [CPlaceName] num_params 0 pop 0</p>
<p>define function CPlaceName__Init&lt;thiscall, 0x4AD4C0&gt;()</p>
<h4>CPlaceName::Process</h4>
<p>plugin::CallMethodDynGlobal<CPlaceName *>(gaddrof(CPlaceName::Process), this);</p>
<p>0AA6: call_method 0x4AD4E0 struct [CPlaceName] num_params 0 pop 0</p>
<p>define function CPlaceName__Process&lt;thiscall, 0x4AD4E0&gt;()</p><h3 id="plugin_iiigame_iiicplanecpp">plugin_III\game_III\CPlane.cpp</h3><h4>CPlane::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CPlane *, unsigned int>(this, modelIndex);</p>
<h4>CPlane::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<6, CPlane *>(this);</p>
<h4>CPlane::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CPlane *>(this);</p>
<h4>CPlane::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CPlane *>(this);</p>
<h4>CPlane::Render</h4>
<p>plugin::CallVirtualMethod<13, CPlane *>(this);</p>
<h4>CPlane::FlagToDestroyWhenNextProcessed</h4>
<p>plugin::CallVirtualMethod<16, CPlane *>(this);</p>
<h4>CPlane::HasCesnaBeenDestroyed</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasCesnaBeenDestroyed));</p>
<p>0AA7: call_function_return 0x54E150 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlane__HasCesnaBeenDestroyed&lt;cdecl, 0x54E150&gt;(): int</p>
<h4>CPlane::HasCesnaLanded</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasCesnaLanded));</p>
<p>0AA7: call_function_return 0x54E140 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlane__HasCesnaLanded&lt;cdecl, 0x54E140&gt;(): int</p>
<h4>CPlane::HasDropOffCesnaBeenShotDown</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CPlane::HasDropOffCesnaBeenShotDown));</p>
<p>0AA7: call_function_return 0x54E250 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlane__HasDropOffCesnaBeenShotDown&lt;cdecl, 0x54E250&gt;(): int</p>
<h4>*CPlane::LoadPath</h4>
<p>plugin::CallAndReturnDynGlobal<CPlaneNode *, char const *, int *, float *, bool>(gaddrof(CPlane::LoadPath), filename, numNodes, totalLength, loop);</p>
<p>0AA7: call_function_return 0x54BD50 num_params 4 pop 4 [filename] [numNodes] [totalLength] [loop] func_ret [CPlaneNode *]</p>
<p>define function CPlane__LoadPath&lt;cdecl, 0x54BD50&gt;(filename, numNodes, totalLength, loop): int</p>
<h4>CPlane::TestRocketCollision</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPlane::TestRocketCollision), coors);</p>
<p>0AA7: call_function_return 0x54DE90 num_params 1 pop 1 [coors] func_ret [bool]</p>
<p>define function CPlane__TestRocketCollision&lt;cdecl, 0x54DE90&gt;(coors): int</p><h3 id="plugin_iiigame_iiicplayerinfocpp">plugin_III\game_III\CPlayerInfo.cpp</h3><h4>CPlayerInfo::ArrestPlayer</h4>
<p>plugin::CallMethod<0x4A1330, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4A1330 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__ArrestPlayer&lt;thiscall, 0x4A1330&gt;()</p>
<h4>CPlayerInfo::AwardMoneyForExplosion</h4>
<p>plugin::CallMethod<0x4A15F0, CPlayerInfo <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA6: call_method 0x4A15F0 struct [CPlayerInfo] num_params 1 pop 0 [vehicle]</p>
<p>define function CPlayerInfo__AwardMoneyForExplosion&lt;thiscall, 0x4A15F0&gt;(vehicle)</p>
<h4>CPlayerInfo::BlowUpRCBuggy</h4>
<p>plugin::CallMethod<0x4A15C0, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4A15C0 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__BlowUpRCBuggy&lt;thiscall, 0x4A15C0&gt;()</p>
<h4>CPlayerInfo::CancelPlayerEnteringCars</h4>
<p>plugin::CallMethod<0x4A13B0, CPlayerInfo <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA6: call_method 0x4A13B0 struct [CPlayerInfo] num_params 1 pop 0 [vehicle]</p>
<p>define function CPlayerInfo__CancelPlayerEnteringCars&lt;thiscall, 0x4A13B0&gt;(vehicle)</p>
<h4>CPlayerInfo::Clear</h4>
<p>plugin::CallMethod<0x49FC10, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x49FC10 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__Clear&lt;thiscall, 0x49FC10&gt;()</p>
<h4>CPlayerInfo::DeletePlayerSkin</h4>
<p>plugin::CallMethod<0x4A1750, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4A1750 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__DeletePlayerSkin&lt;thiscall, 0x4A1750&gt;()</p>
<h4>CPlayerInfo::EvaluateCarPosition</h4>
<p>plugin::CallMethod<0x4A0EC0, CPlayerInfo <em>, CEntity</em>, CPed<em>, float, float</em>, CVehicle**>(this, entity, ped, radius, dist, vehicle);</p>
<p>0AA6: call_method 0x4A0EC0 struct [CPlayerInfo] num_params 5 pop 0 [entity] [ped] [radius] [dist] [vehicle]</p>
<p>define function CPlayerInfo__EvaluateCarPosition&lt;thiscall, 0x4A0EC0&gt;(entity, ped, radius, dist, vehicle)</p>
<h4>CPlayerInfo::FindClosestCarSectorList</h4>
<p>plugin::CallMethod<0x4A0CD0, CPlayerInfo <em>, CPtrList&, CPed</em>, float, float, float, float, float<em>, CVehicle</em>*>(this, list, ped, conrerAX, cornerAY, cornerBX, cornerBY, dist, closestCar);</p>
<p>0AA6: call_method 0x4A0CD0 struct [CPlayerInfo] num_params 8 pop 0 [list] [ped] [conrerAX] [cornerAY] [cornerBX] [cornerBY] [dist] [closestCar]</p>
<p>define function CPlayerInfo__FindClosestCarSectorList&lt;thiscall, 0x4A0CD0&gt;(list, ped, conrerAX, cornerAY, cornerBX, cornerBY, dist, closestCar)</p>
<h4>CPlayerInfo::GetPos</h4>
<p>plugin::CallMethodAndReturn<CVector*, 0x4A0FE0, CPlayerInfo *, CVector*>(this, point);</p>
<p>0AA8: call_method_return 0x4A0FE0 struct [CPlayerInfo] num_params 1 pop 0 [point] func_ret [CVector*]</p>
<p>define function CPlayerInfo__GetPos&lt;thiscall, 0x4A0FE0&gt;(point): int</p>
<h4>CPlayerInfo::IsPlayerInRemoteMode</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4A0930, CPlayerInfo *>(this);</p>
<p>0AA8: call_method_return 0x4A0930 struct [CPlayerInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerInfo__IsPlayerInRemoteMode&lt;thiscall, 0x4A0930&gt;(): int</p>
<h4>CPlayerInfo::IsRestartingAfterArrest</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4A12C0, CPlayerInfo *>(this);</p>
<p>0AA8: call_method_return 0x4A12C0 struct [CPlayerInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerInfo__IsRestartingAfterArrest&lt;thiscall, 0x4A12C0&gt;(): int</p>
<h4>CPlayerInfo::IsRestartingAfterDeath</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4A12A0, CPlayerInfo *>(this);</p>
<p>0AA8: call_method_return 0x4A12A0 struct [CPlayerInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerInfo__IsRestartingAfterDeath&lt;thiscall, 0x4A12A0&gt;(): int</p>
<h4>CPlayerInfo::KillPlayer</h4>
<p>plugin::CallMethod<0x4A12E0, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4A12E0 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__KillPlayer&lt;thiscall, 0x4A12E0&gt;()</p>
<h4>CPlayerInfo::LoadPlayerInfo</h4>
<p>plugin::CallMethod<0x4A0B20, CPlayerInfo <em>, unsigned char</em>, unsigned int>(this, bufferPointer, structSize);</p>
<p>0AA6: call_method 0x4A0B20 struct [CPlayerInfo] num_params 2 pop 0 [bufferPointer] [structSize]</p>
<p>define function CPlayerInfo__LoadPlayerInfo&lt;thiscall, 0x4A0B20&gt;(bufferPointer, structSize)</p>
<h4>CPlayerInfo::LoadPlayerSkin</h4>
<p>plugin::CallMethod<0x4A1700, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4A1700 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__LoadPlayerSkin&lt;thiscall, 0x4A1700&gt;()</p>
<h4>CPlayerInfo::MakePlayerSafe</h4>
<p>plugin::CallMethod<0x4A1400, CPlayerInfo *, bool>(this, safe);</p>
<p>0AA6: call_method 0x4A1400 struct [CPlayerInfo] num_params 1 pop 0 [safe]</p>
<p>define function CPlayerInfo__MakePlayerSafe&lt;thiscall, 0x4A1400&gt;(safe)</p>
<h4>CPlayerInfo::PlayerFailedCriticalMission</h4>
<p>plugin::CallMethod<0x4A1380, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4A1380 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__PlayerFailedCriticalMission&lt;thiscall, 0x4A1380&gt;()</p>
<h4>CPlayerInfo::Process</h4>
<p>plugin::CallMethod<0x49FD30, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x49FD30 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__Process&lt;thiscall, 0x49FD30&gt;()</p>
<h4>CPlayerInfo::SavePlayerInfo</h4>
<p>plugin::CallMethod<0x4A0960, CPlayerInfo <em>, unsigned char</em>, unsigned int*>(this, bufferPointer, structSize);</p>
<p>0AA6: call_method 0x4A0960 struct [CPlayerInfo] num_params 2 pop 0 [bufferPointer] [structSize]</p>
<p>define function CPlayerInfo__SavePlayerInfo&lt;thiscall, 0x4A0960&gt;(bufferPointer, structSize)</p>
<h4>CPlayerInfo::SetPlayerSkin</h4>
<p>plugin::CallMethod<0x4A16D0, CPlayerInfo <em>, char const</em>>(this, skinName);</p>
<p>0AA6: call_method 0x4A16D0 struct [CPlayerInfo] num_params 1 pop 0 [skinName]</p>
<p>define function CPlayerInfo__SetPlayerSkin&lt;thiscall, 0x4A16D0&gt;(skinName)</p>
<h4>CPlayerInfo::~CPlayerInfo</h4>
<p>plugin::CallMethod<0x4B5DC0, CPlayerInfo *>(this);</p>
<p>0AA6: call_method 0x4B5DC0 struct [CPlayerInfo] num_params 0 pop 0</p>
<p>define function CPlayerInfo__~CPlayerInfo&lt;thiscall, 0x4B5DC0&gt;()</p><h3 id="plugin_iiigame_iiicplayerpedcpp">plugin_III\game_III\CPlayerPed.cpp</h3><h4>CPlayerPed::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CPlayerPed *>(this);</p>
<h4>CPlayerPed::SetMoveAnim</h4>
<p>plugin::CallVirtualMethod<18, CPlayerPed *>(this);</p>
<h4>CPlayerPed::AnnoyPlayerPed</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, bool>(gaddrof(CPlayerPed::AnnoyPlayerPed), this, annoyedByPassingEntity);</p>
<p>0AA6: call_method 0x4F3700 struct [CPlayerPed] num_params 1 pop 0 [annoyedByPassingEntity]</p>
<p>define function CPlayerPed__AnnoyPlayerPed&lt;thiscall, 0x4F3700&gt;(annoyedByPassingEntity)</p>
<h4>CPlayerPed::ClearAdrenaline</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ClearAdrenaline), this);</p>
<p>0AA6: call_method 0x4F3730 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ClearAdrenaline&lt;thiscall, 0x4F3730&gt;()</p>
<h4>CPlayerPed::ClearWeaponTarget</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ClearWeaponTarget), this);</p>
<p>0AA6: call_method 0x4F28A0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ClearWeaponTarget&lt;thiscall, 0x4F28A0&gt;()</p>
<h4>CPlayerPed::DoStuffToGoOnFire</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::DoStuffToGoOnFire), this);</p>
<p>0AA6: call_method 0x4F36E0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__DoStuffToGoOnFire&lt;thiscall, 0x4F36E0&gt;()</p>
<h4>CPlayerPed::DoWeaponSmoothSpray</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *>(gaddrof(CPlayerPed::DoWeaponSmoothSpray), this);</p>
<p>0AA8: call_method_return 0x4F1380 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPlayerPed::DoesTargetHaveToBeBroken</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CVector, CWeapon *>(gaddrof(CPlayerPed::DoesTargetHaveToBeBroken), this, target, weapon);</p>
<p>0AA8: call_method_return 0x4F3350 struct [CPlayerPed] num_params 2 pop 0 [target] [weapon] func_ret [bool]</p>
<h4>CPlayerPed::EvaluateNeighbouringTarget</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CEntity *, CEntity **, float *, float, float, bool>(gaddrof(CPlayerPed::EvaluateNeighbouringTarget), this, candidate, targetPtr, lastCloseness, distLimit, angleOffset, lookToLeft);</p>
<p>0AA6: call_method 0x4F2FA0 struct [CPlayerPed] num_params 6 pop 0 [candidate] [targetPtr] [lastCloseness] [distLimit] [angleOffset] [lookToLeft]</p>
<p>define function CPlayerPed__EvaluateNeighbouringTarget&lt;thiscall, 0x4F2FA0&gt;(candidate, targetPtr, lastCloseness, distLimit, angleOffset, lookToLeft)</p>
<h4>CPlayerPed::EvaluateTarget</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CEntity *, CEntity **, float *, float, float, bool>(gaddrof(CPlayerPed::EvaluateTarget), this, candidate, targetPtr, lastCloseness, distLimit, angleOffset, priority);</p>
<p>0AA6: call_method 0x4F2B60 struct [CPlayerPed] num_params 6 pop 0 [candidate] [targetPtr] [lastCloseness] [distLimit] [angleOffset] [priority]</p>
<p>define function CPlayerPed__EvaluateTarget&lt;thiscall, 0x4F2B60&gt;(candidate, targetPtr, lastCloseness, distLimit, angleOffset, priority)</p>
<h4>CPlayerPed::FindNextWeaponLockOnTarget</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CEntity *, bool>(gaddrof(CPlayerPed::FindNextWeaponLockOnTarget), this, previousTarget, lookToLeft);</p>
<p>0AA8: call_method_return 0x4F2D50 struct [CPlayerPed] num_params 2 pop 0 [previousTarget] [lookToLeft] func_ret [bool]</p>
<h4>CPlayerPed::FindWeaponLockOnTarget</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *>(gaddrof(CPlayerPed::FindWeaponLockOnTarget), this);</p>
<p>0AA8: call_method_return 0x4F28D0 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<h4>*CPlayerPed::GetPlayerInfoForThisPlayerPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPlayerInfo *, CPlayerPed *>(gaddrof(CPlayerPed::GetPlayerInfoForThisPlayerPed), this);</p>
<p>0AA8: call_method_return 0x4F36C0 struct [*CPlayerPed] num_params 0 pop 0 func_ret [CPlayerInfo *]</p>
<h4>CPlayerPed::IsThisPedAttackingPlayer</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPlayerPed *, CPed *>(gaddrof(CPlayerPed::IsThisPedAttackingPlayer), this, ped);</p>
<p>0AA8: call_method_return 0x4F2D00 struct [CPlayerPed] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CPlayerPed::KeepAreaAroundPlayerClear</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::KeepAreaAroundPlayerClear), this);</p>
<p>0AA6: call_method 0x4F3460 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__KeepAreaAroundPlayerClear&lt;thiscall, 0x4F3460&gt;()</p>
<h4>CPlayerPed::MakeChangesForNewWeapon</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, char>(gaddrof(CPlayerPed::MakeChangesForNewWeapon), this, weaponType);</p>
<p>0AA6: call_method 0x4F2560 struct [CPlayerPed] num_params 1 pop 0 [weaponType]</p>
<p>define function CPlayerPed__MakeChangesForNewWeapon&lt;thiscall, 0x4F2560&gt;(weaponType)</p>
<h4>CPlayerPed::MakeObjectTargettable</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::MakeObjectTargettable), this, handle);</p>
<p>0AA6: call_method 0x4F32B0 struct [CPlayerPed] num_params 1 pop 0 [handle]</p>
<p>define function CPlayerPed__MakeObjectTargettable&lt;thiscall, 0x4F32B0&gt;(handle)</p>
<h4>CPlayerPed::PlayerControl1stPersonRunAround</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControl1stPersonRunAround), this, pad);</p>
<p>0AA6: call_method 0x4F1970 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControl1stPersonRunAround&lt;thiscall, 0x4F1970&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlFighter</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlFighter), this, pad);</p>
<p>0AA6: call_method 0x4F1810 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlFighter&lt;thiscall, 0x4F1810&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlM16</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlM16), this, pad);</p>
<p>0AA6: call_method 0x4F1DF0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlM16&lt;thiscall, 0x4F1DF0&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlSniper</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlSniper), this, pad);</p>
<p>0AA6: call_method 0x4F1CF0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlSniper&lt;thiscall, 0x4F1CF0&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlZelda</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::PlayerControlZelda), this, pad);</p>
<p>0AA6: call_method 0x4F13C0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlZelda&lt;thiscall, 0x4F13C0&gt;(pad)</p>
<h4>CPlayerPed::ProcessAnimGroups</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ProcessAnimGroups), this);</p>
<p>0AA6: call_method 0x4F2640 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ProcessAnimGroups&lt;thiscall, 0x4F2640&gt;()</p>
<h4>CPlayerPed::ProcessPlayerWeapon</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::ProcessPlayerWeapon), this, pad);</p>
<p>0AA6: call_method 0x4F1EF0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessPlayerWeapon&lt;thiscall, 0x4F1EF0&gt;(pad)</p>
<h4>CPlayerPed::ProcessWeaponSwitch</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::ProcessWeaponSwitch), this, pad);</p>
<p>0AA6: call_method 0x4F2310 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessWeaponSwitch&lt;thiscall, 0x4F2310&gt;(pad)</p>
<h4>CPlayerPed::ReApplyMoveAnims</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::ReApplyMoveAnims), this);</p>
<p>0AA6: call_method 0x4F07C0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ReApplyMoveAnims&lt;thiscall, 0x4F07C0&gt;()</p>
<h4>CPlayerPed::RestoreSprintEnergy</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, float>(gaddrof(CPlayerPed::RestoreSprintEnergy), this, restoreSpeed);</p>
<p>0AA6: call_method 0x4F1340 struct [CPlayerPed] num_params 1 pop 0 [restoreSpeed]</p>
<p>define function CPlayerPed__RestoreSprintEnergy&lt;thiscall, 0x4F1340&gt;(restoreSpeed)</p>
<h4>CPlayerPed::RunningLand</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, CPad *>(gaddrof(CPlayerPed::RunningLand), this, pad);</p>
<p>0AA6: call_method 0x4F31D0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__RunningLand&lt;thiscall, 0x4F31D0&gt;(pad)</p>
<h4>CPlayerPed::SetInitialState</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::SetInitialState), this);</p>
<p>0AA6: call_method 0x4EFC40 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__SetInitialState&lt;thiscall, 0x4EFC40&gt;()</p>
<h4>CPlayerPed::SetRealMoveAnim</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::SetRealMoveAnim), this);</p>
<p>0AA6: call_method 0x4F0880 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__SetRealMoveAnim&lt;thiscall, 0x4F0880&gt;()</p>
<h4>CPlayerPed::SetWantedLevel</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::SetWantedLevel), this, level);</p>
<p>0AA6: call_method 0x4F3190 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__SetWantedLevel&lt;thiscall, 0x4F3190&gt;(level)</p>
<h4>CPlayerPed::SetWantedLevelNoDrop</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *, int>(gaddrof(CPlayerPed::SetWantedLevelNoDrop), this, level);</p>
<p>0AA6: call_method 0x4F31B0 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__SetWantedLevelNoDrop&lt;thiscall, 0x4F31B0&gt;(level)</p>
<h4>CPlayerPed::UseSprintEnergy</h4>
<p>plugin::CallMethodDynGlobal<CPlayerPed *>(gaddrof(CPlayerPed::UseSprintEnergy), this);</p>
<p>0AA6: call_method 0x4F12A0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__UseSprintEnergy&lt;thiscall, 0x4F12A0&gt;()</p>
<h4>CPlayerPed::DeactivatePlayerPed</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::DeactivatePlayerPed), playerId);</p>
<h4>CPlayerPed::ReactivatePlayerPed</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::ReactivatePlayerPed), playerId);</p>
<h4>CPlayerPed::SetupPlayerPed</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPlayerPed::SetupPlayerPed), playerId);</p><h3 id="plugin_iiigame_iiicplayerskincpp">plugin_III\game_III\CPlayerSkin.cpp</h3><h4>*CPlayerSkin::GetSkinTexture</h4>
<p>plugin::CallAndReturnDynGlobal<RwTexture *, char const *>(gaddrof(CPlayerSkin::GetSkinTexture), name);</p>
<p>0AA7: call_function_return 0x59B9F0 num_params 1 pop 1 [name] func_ret [RwTexture *]</p>
<p>define function CPlayerSkin__GetSkinTexture&lt;cdecl, 0x59B9F0&gt;(name): int</p>
<h4>FindPlayerDff</h4>
<p>plugin::CallDynGlobal<unsigned int &, unsigned int &>(gaddrof(FindPlayerDff), offset, size);</p><h3 id="plugin_iiigame_iiicpointlightscpp">plugin_III\game_III\CPointLights.cpp</h3><h4>CPointLights::AddLight</h4>
<p>plugin::Call<0x510790, unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool>(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows);</p>
<p>0AA5: call_function 0x510790 num_params 9 pop 9 [lightType] [point] [direction] [radius] [red] [green] [blue] [fogType] [generateExtraShadows]</p>
<p>define function CPointLights__AddLight&lt;cdecl, 0x510790&gt;(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows)</p>
<h4>CPointLights::GenerateLightsAffectingObject</h4>
<p>plugin::CallAndReturn<float, 0x510960, CVector*>(point);</p>
<p>0AA7: call_function_return 0x510960 num_params 1 pop 1 [point] func_ret [float]</p>
<p>define function CPointLights__GenerateLightsAffectingObject&lt;cdecl, 0x510960&gt;(point): float</p>
<h4>CPointLights::RemoveLightsAffectingObject</h4>
<p>plugin::Call<0x510C20>();</p>
<p>0AA5: call_function 0x510C20 num_params 0 pop 0</p>
<p>define function CPointLights__RemoveLightsAffectingObject&lt;cdecl, 0x510C20&gt;()</p>
<h4>CPointLights::RenderFogEffect</h4>
<p>plugin::Call<0x510C30>();</p>
<p>0AA5: call_function 0x510C30 num_params 0 pop 0</p>
<p>define function CPointLights__RenderFogEffect&lt;cdecl, 0x510C30&gt;()</p>
<h4>CPointLight::CPointLight</h4>
<p>plugin::CallMethod<0x511930, CPointLight *>(this);</p>
<p>0AA6: call_method 0x511930 struct [CPointLight] num_params 0 pop 0</p>
<p>define function CPointLight__CPointLight&lt;thiscall, 0x511930&gt;()</p><h3 id="plugin_iiigame_iiicpoolscpp">plugin_III\game_III\CPools.cpp</h3><h4>*CPools::GetBuildingPool</h4>
<p>plugin::CallAndReturnDynGlobal<CPool<CBuilding> *&gt;(gaddrof(CPools::GetBuildingPool));</p>
<p>0AA7: call_function_return 0x545320 num_params 0 pop 0 func_ret [CPool<CBuilding> *]</p>
<p>define function CPools__GetBuildingPool&lt;cdecl, 0x545320&gt;(): int</p>
<h4>CPools::GetCCutsceneHeadSize</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CPools::GetCCutsceneHeadSize));</p>
<p>0AA7: call_function_return 0x4A2DA0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CPools__GetCCutsceneHeadSize&lt;cdecl, 0x4A2DA0&gt;(): int</p>
<h4>*CPools::GetObject</h4>
<p>plugin::CallAndReturnDynGlobal<CObject *, int>(gaddrof(CPools::GetObject), handle);</p>
<p>0AA7: call_function_return 0x4A1B20 num_params 1 pop 1 [handle] func_ret [CObject *]</p>
<p>define function CPools__GetObject&lt;cdecl, 0x4A1B20&gt;(handle): int</p>
<h4>*CPools::GetObjectPool</h4>
<p>plugin::CallAndReturnDynGlobal<CPool<CObject, CCutsceneObject> *&gt;(gaddrof(CPools::GetObjectPool));</p>
<p>0AA7: call_function_return 0x545310 num_params 0 pop 0 func_ret [CPool&lt;CObject]</p>
<p>define function CPools__GetObjectPool&lt;cdecl, 0x545310&gt;(): int</p>
<h4>CPools::GetObjectRef</h4>
<p>plugin::CallAndReturnDynGlobal<int, CObject *>(gaddrof(CPools::GetObjectRef), object);</p>
<p>0AA7: call_function_return 0x4A1B00 num_params 1 pop 1 [object] func_ret [int]</p>
<p>define function CPools__GetObjectRef&lt;cdecl, 0x4A1B00&gt;(object): int</p>
<h4>*CPools::GetPed</h4>
<p>plugin::CallAndReturnDynGlobal<CPed *, int>(gaddrof(CPools::GetPed), handle);</p>
<p>0AA7: call_function_return 0x4A1AA0 num_params 1 pop 1 [handle] func_ret [CPed *]</p>
<p>define function CPools__GetPed&lt;cdecl, 0x4A1AA0&gt;(handle): int</p>
<h4>CPools::GetPedRef</h4>
<p>plugin::CallAndReturnDynGlobal<int, CPed *>(gaddrof(CPools::GetPedRef), ped);</p>
<p>0AA7: call_function_return 0x4A1A80 num_params 1 pop 1 [ped] func_ret [int]</p>
<p>define function CPools__GetPedRef&lt;cdecl, 0x4A1A80&gt;(ped): int</p>
<h4>*CPools::GetVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CPools::GetVehicle), handle);</p>
<p>0AA7: call_function_return 0x4A1AE0 num_params 1 pop 1 [handle] func_ret [CVehicle *]</p>
<p>define function CPools__GetVehicle&lt;cdecl, 0x4A1AE0&gt;(handle): int</p>
<h4>*CPools::GetVehiclePool</h4>
<p>plugin::CallAndReturnDynGlobal<CPool<CVehicle, CAutomobile> *&gt;(gaddrof(CPools::GetVehiclePool));</p>
<p>0AA7: call_function_return 0x545300 num_params 0 pop 0 func_ret [CPool&lt;CVehicle]</p>
<p>define function CPools__GetVehiclePool&lt;cdecl, 0x545300&gt;(): int</p>
<h4>CPools::GetVehicleRef</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CPools::GetVehicleRef), vehicle);</p>
<p>0AA7: call_function_return 0x4A1AC0 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CPools__GetVehicleRef&lt;cdecl, 0x4A1AC0&gt;(vehicle): int</p>
<h4>CPools::LoadObjectPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadObjectPool), buffer, size);</p>
<h4>CPools::LoadPedPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadPedPool), buffer, size);</p>
<h4>CPools::LoadVehiclePool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadVehiclePool), buffer, size);</p>
<h4>CPools::MakeSureSlotInObjectPoolIsEmpty</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPools::MakeSureSlotInObjectPoolIsEmpty), slot);</p>
<h4>CPools::SaveObjectPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveObjectPool), buffer, outSize);</p>
<h4>CPools::SavePedPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SavePedPool), buffer, outSize);</p>
<h4>CPools::SaveVehiclePool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveVehiclePool), buffer, outSize);</p><h3 id="plugin_iiigame_iiicpopulationcpp">plugin_III\game_III\CPopulation.cpp</h3><h4>*CPopulation::AddPed</h4>
<p>plugin::CallAndReturnDynGlobal<CPed *, ePedType, unsigned int, CVector const &>(gaddrof(CPopulation::AddPed), pedType, modelIndexOrCopType, coors);</p>
<p>0AA7: call_function_return 0x4F5280 num_params 3 pop 3 [pedType] [modelIndexOrCopType] [coors] func_ret [CPed *]</p>
<p>define function CPopulation__AddPed&lt;cdecl, 0x4F5280&gt;(pedType, modelIndexOrCopType, coors): int</p>
<h4>*CPopulation::AddPedInCar</h4>
<p>plugin::CallAndReturnDynGlobal<CPed *, CVehicle *>(gaddrof(CPopulation::AddPedInCar), vehicle);</p>
<p>0AA7: call_function_return 0x4F5800 num_params 1 pop 1 [vehicle] func_ret [CPed *]</p>
<p>define function CPopulation__AddPedInCar&lt;cdecl, 0x4F5800&gt;(vehicle): int</p>
<h4>CPopulation::AddToPopulation</h4>
<p>plugin::CallDynGlobal<float, float, float, float>(gaddrof(CPopulation::AddToPopulation), minDist, maxDist, minDistOffScreen, maxDistOffScreen);</p>
<h4>CPopulation::ChooseCivilianOccupation</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPopulation::ChooseCivilianOccupation), group);</p>
<p>0AA7: call_function_return 0x4F5720 num_params 1 pop 1 [group] func_ret [int]</p>
<p>define function CPopulation__ChooseCivilianOccupation&lt;cdecl, 0x4F5720&gt;(group): int</p>
<h4>CPopulation::ChooseGangOccupation</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CPopulation::ChooseGangOccupation), gangId);</p>
<p>0AA7: call_function_return 0x4F5780 num_params 1 pop 1 [gangId] func_ret [int]</p>
<p>define function CPopulation__ChooseGangOccupation&lt;cdecl, 0x4F5780&gt;(gangId): int</p>
<h4>CPopulation::ChoosePolicePedOccupation</h4>
<p>plugin::CallAndReturnDynGlobal<eCopType>(gaddrof(CPopulation::ChoosePolicePedOccupation));</p>
<p>0AA7: call_function_return 0x4F5710 num_params 0 pop 0 func_ret [eCopType]</p>
<p>define function CPopulation__ChoosePolicePedOccupation&lt;cdecl, 0x4F5710&gt;(): int</p>
<h4>CPopulation::ConvertToDummyObject</h4>
<p>plugin::CallDynGlobal<CObject *>(gaddrof(CPopulation::ConvertToDummyObject), object);</p>
<h4>CPopulation::ConvertToRealObject</h4>
<p>plugin::CallDynGlobal<CDummyObject *>(gaddrof(CPopulation::ConvertToRealObject), dummy);</p>
<h4>CPopulation::DealWithZoneChange</h4>
<p>plugin::CallDynGlobal<eLevelName, eLevelName, bool>(gaddrof(CPopulation::DealWithZoneChange), oldLevel, newLevel, forceIndustrialZone);</p>
<h4>CPopulation::FindClosestZoneForCoors</h4>
<p>plugin::CallDynGlobal<CVector *, int *, eLevelName, eLevelName>(gaddrof(CPopulation::FindClosestZoneForCoors), coors, safeZoneOut, level1, level2);</p>
<h4>CPopulation::FindCollisionZoneForCoors</h4>
<p>plugin::CallDynGlobal<CVector *, int *, eLevelName *>(gaddrof(CPopulation::FindCollisionZoneForCoors), coors, safeZoneOut, levelOut);</p>
<h4>CPopulation::IsPointInSafeZone</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPopulation::IsPointInSafeZone), coors);</p>
<p>0AA7: call_function_return 0x4F60C0 num_params 1 pop 1 [coors] func_ret [bool]</p>
<p>define function CPopulation__IsPointInSafeZone&lt;cdecl, 0x4F60C0&gt;(coors): int</p>
<h4>CPopulation::PedCreationDistMultiplier</h4>
<p>plugin::CallAndReturnDynGlobal<float>(gaddrof(CPopulation::PedCreationDistMultiplier));</p>
<p>0AA7: call_function_return 0x4F6410 num_params 0 pop 0 func_ret [float]</p>
<p>define function CPopulation__PedCreationDistMultiplier&lt;cdecl, 0x4F6410&gt;(): float</p>
<h4>CPopulation::RemovePed</h4>
<p>plugin::CallDynGlobal<CPed *>(gaddrof(CPopulation::RemovePed), ped);</p>
<h4>CPopulation::TestRoomForDummyObject</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CObject *>(gaddrof(CPopulation::TestRoomForDummyObject), object);</p>
<p>0AA7: call_function_return 0x4F4690 num_params 1 pop 1 [object] func_ret [bool]</p>
<p>define function CPopulation__TestRoomForDummyObject&lt;cdecl, 0x4F4690&gt;(object): int</p>
<h4>CPopulation::TestSafeForRealObject</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CDummyObject *>(gaddrof(CPopulation::TestSafeForRealObject), dummy);</p>
<p>0AA7: call_function_return 0x4F4700 num_params 1 pop 1 [dummy] func_ret [bool]</p>
<p>define function CPopulation__TestSafeForRealObject&lt;cdecl, 0x4F4700&gt;(dummy): int</p>
<h4>CPopulation::UpdatePedCount</h4>
<p>plugin::CallDynGlobal<ePedType, bool>(gaddrof(CPopulation::UpdatePedCount), pedType, decrease);</p><h3 id="plugin_iiigame_iiicprojectileinfocpp">plugin_III\game_III\CProjectileInfo.cpp</h3><h4>CProjectileInfo::AddProjectile</h4>
<p>plugin::CallAndReturn<bool, 0x55B030, CEntity*, eWeaponType, CVector, float>(creator, weaponType, posn, force);</p>
<p>0AA7: call_function_return 0x55B030 num_params 4 pop 4 [creator] [weaponType] [posn] [force] func_ret [bool]</p>
<p>define function CProjectileInfo__AddProjectile&lt;cdecl, 0x55B030&gt;(creator, weaponType, posn, force): int</p>
<h4>CProjectileInfo::CProjectileInfo</h4>
<p>plugin::CallMethod<0x55BC50, CProjectileInfo *>(this);</p>
<p>0AA6: call_method 0x55BC50 struct [CProjectileInfo] num_params 0 pop 0</p>
<p>define function CProjectileInfo__CProjectileInfo&lt;thiscall, 0x55BC50&gt;()</p>
<h4>CProjectileInfo::GetProjectileInfo</h4>
<p>plugin::CallAndReturn<CProjectileInfo*, 0x55B010, int>(index);</p>
<p>0AA7: call_function_return 0x55B010 num_params 1 pop 1 [index] func_ret [CProjectileInfo*]</p>
<p>define function CProjectileInfo__GetProjectileInfo&lt;cdecl, 0x55B010&gt;(index): int</p>
<h4>CProjectileInfo::Initialise</h4>
<p>plugin::Call<0x55ADF0>();</p>
<p>0AA5: call_function 0x55ADF0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Initialise&lt;cdecl, 0x55ADF0&gt;()</p>
<h4>CProjectileInfo::IsProjectileInRange</h4>
<p>plugin::CallAndReturn<bool, 0x55BA50, float, float, float, float, float, float, bool>(x1, y1, z1, x2, y2, z2, bDestroy);</p>
<p>0AA7: call_function_return 0x55BA50 num_params 7 pop 7 [x1] [y1] [z1] [x2] [y2] [z2] [bDestroy] func_ret [bool]</p>
<p>define function CProjectileInfo__IsProjectileInRange&lt;cdecl, 0x55BA50&gt;(x1, y1, z1, x2, y2, z2, bDestroy): int</p>
<h4>CProjectileInfo::RemoveAllProjectiles</h4>
<p>plugin::Call<0x55BB80>();</p>
<p>0AA5: call_function 0x55BB80 num_params 0 pop 0</p>
<p>define function CProjectileInfo__RemoveAllProjectiles&lt;cdecl, 0x55BB80&gt;()</p>
<h4>CProjectileInfo::RemoveIfThisIsAProjectile</h4>
<p>plugin::CallAndReturn<bool, 0x55BBD0, CObject*>(object);</p>
<p>0AA7: call_function_return 0x55BBD0 num_params 1 pop 1 [object] func_ret [bool]</p>
<p>define function CProjectileInfo__RemoveIfThisIsAProjectile&lt;cdecl, 0x55BBD0&gt;(object): int</p>
<h4>CProjectileInfo::RemoveNotAdd</h4>
<p>plugin::Call<0x55B770, CEntity*, eWeaponType, CVector>(creator, weaponType, posn);</p>
<p>0AA5: call_function 0x55B770 num_params 3 pop 3 [creator] [weaponType] [posn]</p>
<p>define function CProjectileInfo__RemoveNotAdd&lt;cdecl, 0x55B770&gt;(creator, weaponType, posn)</p>
<h4>CProjectileInfo::RemoveProjectile</h4>
<p>plugin::Call<0x55B700, CProjectileInfo<em>, CProjectile</em>>(info, projectileObject);</p>
<p>0AA5: call_function 0x55B700 num_params 2 pop 2 [info] [projectileObject]</p>
<p>define function CProjectileInfo__RemoveProjectile&lt;cdecl, 0x55B700&gt;(info, projectileObject)</p>
<h4>CProjectileInfo::Shutdown</h4>
<p>plugin::Call<0x55AFF0>();</p>
<p>0AA5: call_function 0x55AFF0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Shutdown&lt;cdecl, 0x55AFF0&gt;()</p>
<h4>CProjectileInfo::Update</h4>
<p>plugin::Call<0x55B7C0>();</p>
<p>0AA5: call_function 0x55B7C0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Update&lt;cdecl, 0x55B7C0&gt;()</p><h3 id="plugin_iiigame_iiicquaternioncpp">plugin_III\game_III\CQuaternion.cpp</h3><h4>CQuaternion::Get</h4>
<p>plugin::CallMethodDynGlobal<CQuaternion *, RwMatrix *>(gaddrof(CQuaternion::Get), this, matrix);</p>
<p>0AA6: call_method 0x4BA0D0 struct [CQuaternion] num_params 1 pop 0 [matrix]</p>
<p>define function CQuaternion__Get&lt;thiscall, 0x4BA0D0&gt;(matrix)</p>
<h4>CQuaternion::Slerp</h4>
<p>plugin::CallMethodDynGlobal<CQuaternion *, CQuaternion const &, CQuaternion const &, float, float, float>(gaddrof(CQuaternion::Slerp), this, from, to, halftheta, sintheta_inv, t);</p>
<p>0AA6: call_method 0x4BA1C0 struct [CQuaternion] num_params 5 pop 0 [from] [to] [halftheta] [sintheta_inv] [t]</p>
<p>define function CQuaternion__Slerp&lt;thiscall, 0x4BA1C0&gt;(from, to, halftheta, sintheta_inv, t)</p><h3 id="plugin_iiigame_iiicradarcpp">plugin_III\game_III\CRadar.cpp</h3><h4>CRadar::CalculateBlipAlpha</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char, float>(gaddrof(CRadar::CalculateBlipAlpha), distance);</p>
<p>0AA7: call_function_return 0x4A4F90 num_params 1 pop 1 [distance] func_ret [unsigned char]</p>
<p>define function CRadar__CalculateBlipAlpha&lt;cdecl, 0x4A4F90&gt;(distance): int</p>
<h4>CRadar::ChangeBlipBrightness</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CRadar::ChangeBlipBrightness), i, bright);</p>
<h4>CRadar::ChangeBlipColour</h4>
<p>plugin::CallDynGlobal<int, unsigned int>(gaddrof(CRadar::ChangeBlipColour), i, colour);</p>
<h4>CRadar::ChangeBlipDisplay</h4>
<p>plugin::CallDynGlobal<int, eBlipDisplay>(gaddrof(CRadar::ChangeBlipDisplay), i, display);</p>
<h4>CRadar::ChangeBlipScale</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CRadar::ChangeBlipScale), i, scale);</p>
<h4>CRadar::ClearBlip</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CRadar::ClearBlip), i);</p>
<h4>CRadar::ClearBlipForEntity</h4>
<p>plugin::CallDynGlobal<eBlipType, int>(gaddrof(CRadar::ClearBlipForEntity), type, handle);</p>
<h4>CRadar::ClipRadarPoly</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector2D *, CVector2D const *>(gaddrof(CRadar::ClipRadarPoly), out, in);</p>
<p>0AA7: call_function_return 0x4A64A0 num_params 2 pop 2 [out] [in] func_ret [int]</p>
<p>define function CRadar__ClipRadarPoly&lt;cdecl, 0x4A64A0&gt;(out, in): int</p>
<h4>CRadar::DrawRadarSection</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CRadar::DrawRadarSection), x, y);</p>
<h4>CRadar::DrawRadarSprite</h4>
<p>plugin::CallDynGlobal<unsigned short, float, float, unsigned char>(gaddrof(CRadar::DrawRadarSprite), sprite, x, y, alpha);</p>
<h4>CRadar::DrawRotatingRadarSprite</h4>
<p>plugin::CallDynGlobal<CSprite2d *, float, float, float, unsigned char>(gaddrof(CRadar::DrawRotatingRadarSprite), sprite, x, y, angle, alpha);</p>
<h4>CRadar::GetActualBlipArrayIndex</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CRadar::GetActualBlipArrayIndex), i);</p>
<p>0AA7: call_function_return 0x4A41C0 num_params 1 pop 1 [i] func_ret [int]</p>
<p>define function CRadar__GetActualBlipArrayIndex&lt;cdecl, 0x4A41C0&gt;(i): int</p>
<h4>CRadar::GetNewUniqueBlipIndex</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CRadar::GetNewUniqueBlipIndex), i);</p>
<p>0AA7: call_function_return 0x4A4180 num_params 1 pop 1 [i] func_ret [int]</p>
<p>define function CRadar__GetNewUniqueBlipIndex&lt;cdecl, 0x4A4180&gt;(i): int</p>
<h4>CRadar::GetRadarTraceColour</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, bool>(gaddrof(CRadar::GetRadarTraceColour), colour, bright);</p>
<p>0AA7: call_function_return 0x4A5BB0 num_params 2 pop 2 [colour] [bright] func_ret [unsigned int]</p>
<p>define function CRadar__GetRadarTraceColour&lt;cdecl, 0x4A5BB0&gt;(colour, bright): int</p>
<h4>CRadar::LimitRadarPoint</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVector2D &>(gaddrof(CRadar::LimitRadarPoint), point);</p>
<p>0AA7: call_function_return 0x4A4F30 num_params 1 pop 1 [point] func_ret [float]</p>
<p>define function CRadar__LimitRadarPoint&lt;cdecl, 0x4A4F30&gt;(point): float</p>
<h4>CRadar::LoadAllRadarBlips</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CRadar::LoadAllRadarBlips), buf, size);</p>
<h4>CRadar::SaveAllRadarBlips</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CRadar::SaveAllRadarBlips), buf, size);</p>
<h4>CRadar::SetBlipSprite</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CRadar::SetBlipSprite), i, icon);</p>
<h4>CRadar::SetCoordBlip</h4>
<p>plugin::CallAndReturnDynGlobal<int, eBlipType, CVector, unsigned int, eBlipDisplay>(gaddrof(CRadar::SetCoordBlip), type, pos, colour, display);</p>
<p>0AA7: call_function_return 0x4A5590 num_params 4 pop 4 [type] [pos] [colour] [display] func_ret [int]</p>
<p>define function CRadar__SetCoordBlip&lt;cdecl, 0x4A5590&gt;(type, pos, colour, display): int</p>
<h4>CRadar::SetEntityBlip</h4>
<p>plugin::CallDynGlobal<eBlipType, int, unsigned int, eBlipDisplay>(gaddrof(CRadar::SetEntityBlip), type, handle, colour, display);</p>
<h4>CRadar::SetRadarMarkerState</h4>
<p>plugin::CallDynGlobal<int, unsigned char>(gaddrof(CRadar::SetRadarMarkerState), i, flag);</p>
<h4>CRadar::ShowRadarMarker</h4>
<p>plugin::CallDynGlobal<CVector, unsigned int, float>(gaddrof(CRadar::ShowRadarMarker), pos, colour, radius);</p>
<h4>CRadar::ShowRadarTrace</h4>
<p>plugin::CallDynGlobal<float, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char>(gaddrof(CRadar::ShowRadarTrace), x, y, size, red, green, blue, alpha);</p>
<h4>CRadar::StreamRadarSections</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof_o(CRadar::StreamRadarSections, void (*)(int, int)), x, y);</p>
<h4>CRadar::StreamRadarSections</h4>
<p>plugin::CallDynGlobal<CVector const &>(gaddrof_o(CRadar::StreamRadarSections, void (*)(CVector const &amp;)), pos);</p>
<h4>CRadar::TransformRadarPointToRealWorldSpace</h4>
<p>plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRadarPointToRealWorldSpace), out, in);</p>
<h4>CRadar::TransformRadarPointToScreenSpace</h4>
<p>plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRadarPointToScreenSpace), out, in);</p>
<h4>CRadar::TransformRealWorldPointToRadarSpace</h4>
<p>plugin::CallDynGlobal<CVector2D &, CVector2D const &>(gaddrof(CRadar::TransformRealWorldPointToRadarSpace), out, in);</p>
<h4>CRadar::TransformRealWorldToTexCoordSpace</h4>
<p>plugin::CallDynGlobal<CVector2D &, CVector2D const &, int, int>(gaddrof(CRadar::TransformRealWorldToTexCoordSpace), out, in, x, y);</p>
<h4>ClipRadarTileCoords</h4>
<p>plugin::CallDynGlobal<int &, int &>(gaddrof(ClipRadarTileCoords), x, y);</p>
<h4>RequestMapSection</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(RequestMapSection), x, y);</p>
<h4>RemoveMapSection</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(RemoveMapSection), x, y);</p>
<h4>IsPointInsideRadar</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector2D const &>(gaddrof(IsPointInsideRadar), point);</p>
<p>0AA7: call_function_return 0x4A6160 num_params 1 pop 1 [point] func_ret [bool]</p>
<p>define function IsPointInsideRadar&lt;cdecl, 0x4A6160&gt;(point): int</p>
<h4>GetTextureCorners</h4>
<p>plugin::CallDynGlobal<int, int, CVector2D *>(gaddrof(GetTextureCorners), x, y, out);</p>
<h4>LineRadarBoxCollision</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector2D &, CVector2D const &, CVector2D const &>(gaddrof(LineRadarBoxCollision), out, lineStart, lineEnd);</p>
<p>0AA7: call_function_return 0x4A6250 num_params 3 pop 3 [out] [lineStart] [lineEnd] func_ret [int]</p>
<p>define function LineRadarBoxCollision&lt;cdecl, 0x4A6250&gt;(out, lineStart, lineEnd): int</p><h3 id="plugin_iiigame_iiicrange2dcpp">plugin_III\game_III\CRange2D.cpp</h3><h4>*CRange2D::GetRandomPointInRange</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVector2D *, CRange2D *>(gaddrof(CRange2D::GetRandomPointInRange), this);</p>
<p>0AA8: call_method_return 0x4A7270 struct [*CRange2D] num_params 0 pop 0 func_ret [CVector2D *]</p><h3 id="plugin_iiigame_iiicrecorddataforchasecpp">plugin_III\game_III\CRecordDataForChase.cpp</h3><h4>CRecordDataForChase::GiveUsACar</h4>
<p>plugin::CallDynGlobal<int, CVector, float, CAutomobile **, unsigned char, unsigned char>(gaddrof(CRecordDataForChase::GiveUsACar), modelIndex, pos, angleZ, pCar, prim, sec);</p>
<h4>CRecordDataForChase::RemoveCarFromChase</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CRecordDataForChase::RemoveCarFromChase), index);</p>
<h4>CRecordDataForChase::RestoreInfoForCar</h4>
<p>plugin::CallDynGlobal<CAutomobile *, CCarStateEachFrame *, bool>(gaddrof(CRecordDataForChase::RestoreInfoForCar), car, carState, stop);</p>
<h4>CRecordDataForChase::RestoreInfoForMatrix</h4>
<p>plugin::CallDynGlobal<CMatrix &, CCarStateEachFrame *>(gaddrof(CRecordDataForChase::RestoreInfoForMatrix), matrix, carState);</p>
<h4>CRecordDataForChase::StartChaseScene</h4>
<p>plugin::CallDynGlobal<float>(gaddrof(CRecordDataForChase::StartChaseScene), startTime);</p>
<h4>CRecordDataForChase::StoreInfoForCar</h4>
<p>plugin::CallDynGlobal<CAutomobile *, CCarStateEachFrame *>(gaddrof(CRecordDataForChase::StoreInfoForCar), car, carState);</p>
<h4>*CRecordDataForChase::TurnChaseCarIntoScriptCar</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CRecordDataForChase::TurnChaseCarIntoScriptCar), index);</p>
<p>0AA7: call_function_return 0x435C00 num_params 1 pop 1 [index] func_ret [CVehicle *]</p>
<p>define function CRecordDataForChase__TurnChaseCarIntoScriptCar&lt;cdecl, 0x435C00&gt;(index): int</p><h3 id="plugin_iiigame_iiicrecorddataforgamecpp">plugin_III\game_III\CRecordDataForGame.cpp</h3><h4>CRecordDataForGame::CalcGameChecksum</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned short>(gaddrof(CRecordDataForGame::CalcGameChecksum));</p>
<p>0AA7: call_function_return 0x4346C0 num_params 0 pop 0 func_ret [unsigned short]</p>
<p>define function CRecordDataForGame__CalcGameChecksum&lt;cdecl, 0x4346C0&gt;(): int</p>
<h4>*CRecordDataForGame::PackCurrentPadValues</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char *, unsigned char *, CControllerState *, CControllerState *>(gaddrof(CRecordDataForGame::PackCurrentPadValues), buf, os, ns);</p>
<p>0AA7: call_function_return 0x4343B0 num_params 3 pop 3 [buf] [os] [ns] func_ret [unsigned char *]</p>
<p>define function CRecordDataForGame__PackCurrentPadValues&lt;cdecl, 0x4343B0&gt;(buf, os, ns): int</p>
<h4>*CRecordDataForGame::UnPackCurrentPadValues</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char *, unsigned char *, unsigned char, CControllerState *>(gaddrof(CRecordDataForGame::UnPackCurrentPadValues), buf, total, state);</p>
<p>0AA7: call_function_return 0x4345C0 num_params 3 pop 3 [buf] [total] [state] func_ret [unsigned char *]</p>
<p>define function CRecordDataForGame__UnPackCurrentPadValues&lt;cdecl, 0x4345C0&gt;(buf, total, state): int</p><h3 id="plugin_iiigame_iiicregisteredcoronacpp">plugin_III\game_III\CRegisteredCorona.cpp</h3><h4>CRegisteredCorona::Update</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredCorona *>(gaddrof(CRegisteredCorona::Update), this);</p>
<p>0AA6: call_method 0x4F8C40 struct [CRegisteredCorona] num_params 0 pop 0</p>
<p>define function CRegisteredCorona__Update&lt;thiscall, 0x4F8C40&gt;()</p><h3 id="plugin_iiigame_iiicregisteredmotionblurstreakcpp">plugin_III\game_III\CRegisteredMotionBlurStreak.cpp</h3><h4>CRegisteredMotionBlurStreak::Render</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(gaddrof(CRegisteredMotionBlurStreak::Render), this);</p>
<p>0AA6: call_method 0x519600 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0</p>
<p>define function CRegisteredMotionBlurStreak__Render&lt;thiscall, 0x519600&gt;()</p>
<h4>CRegisteredMotionBlurStreak::Update</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(gaddrof(CRegisteredMotionBlurStreak::Update), this);</p>
<p>0AA6: call_method 0x519580 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0</p>
<p>define function CRegisteredMotionBlurStreak__Update&lt;thiscall, 0x519580&gt;()</p><h3 id="plugin_iiigame_iiicremotecpp">plugin_III\game_III\CRemote.cpp</h3><h4>CRemote::GivePlayerRemoteControlledCar</h4>
<p>plugin::CallDynGlobal<float, float, float, float, unsigned short>(gaddrof(CRemote::GivePlayerRemoteControlledCar), x, y, z, angle, modelIndex);</p><h3 id="plugin_iiigame_iiicrestartcpp">plugin_III\game_III\CRestart.cpp</h3><h4>CRestart::AddHospitalRestartPoint</h4>
<p>plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::AddHospitalRestartPoint), pos, heading);</p>
<h4>CRestart::AddPoliceRestartPoint</h4>
<p>plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::AddPoliceRestartPoint), pos, heading);</p>
<h4>CRestart::FindClosestHospitalRestartPoint</h4>
<p>plugin::CallDynGlobal<CVector const &, CVector *, float *>(gaddrof(CRestart::FindClosestHospitalRestartPoint), pos, outPos, outHeading);</p>
<h4>CRestart::FindClosestPoliceRestartPoint</h4>
<p>plugin::CallDynGlobal<CVector const &, CVector *, float *>(gaddrof(CRestart::FindClosestPoliceRestartPoint), pos, outPos, outHeading);</p>
<h4>CRestart::LoadAllRestartPoints</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CRestart::LoadAllRestartPoints), buf, size);</p>
<h4>CRestart::OverrideNextRestart</h4>
<p>plugin::CallDynGlobal<CVector const &, float>(gaddrof(CRestart::OverrideNextRestart), pos, heading);</p>
<h4>CRestart::SaveAllRestartPoints</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CRestart::SaveAllRestartPoints), buf, size);</p><h3 id="plugin_iiigame_iiicroadblockscpp">plugin_III\game_III\CRoadBlocks.cpp</h3><h4>CRoadBlocks::GenerateRoadBlockCopsForCar</h4>
<p>plugin::CallDynGlobal<CVehicle *, int, short>(gaddrof(CRoadBlocks::GenerateRoadBlockCopsForCar), vehicle, roadBlockType, roadBlockNode);</p><h3 id="plugin_iiigame_iiicroutenodecpp">plugin_III\game_III\CRouteNode.cpp</h3><h4>CRouteNode::AddRoutePoint</h4>
<p>plugin::CallDynGlobal<short, CVector>(gaddrof(CRouteNode::AddRoutePoint), route, pos);</p>
<h4>CRouteNode::GetRouteStart</h4>
<p>plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteStart), route);</p>
<p>0AA7: call_function_return 0x4EE760 num_params 1 pop 1 [route] func_ret [short]</p>
<p>define function CRouteNode__GetRouteStart&lt;cdecl, 0x4EE760&gt;(route): int</p>
<h4>CRouteNode::GetRouteThisPointIsOn</h4>
<p>plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteThisPointIsOn), point);</p>
<p>0AA7: call_function_return 0x4EE7A0 num_params 1 pop 1 [point] func_ret [short]</p>
<p>define function CRouteNode__GetRouteThisPointIsOn&lt;cdecl, 0x4EE7A0&gt;(point): int</p>
<h4>CRouteNode::RemoveRoute</h4>
<p>plugin::CallDynGlobal<short>(gaddrof(CRouteNode::RemoveRoute), route);</p><h3 id="plugin_iiigame_iiicrubbishcpp">plugin_III\game_III\CRubbish.cpp</h3><h4>CRubbish::SetVisibility</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CRubbish::SetVisibility), visible);</p>
<h4>CRubbish::StirUp</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CRubbish::StirUp), vehicle);</p><h3 id="plugin_iiigame_iiicrunningscriptcpp">plugin_III\game_III\CRunningScript.cpp</h3><h4>CRunningScript::Init</h4>
<p>plugin::CallMethod<0x4386C0, CRunningScript *>(this);</p>
<p>0AA6: call_method 0x4386C0 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__Init&lt;thiscall, 0x4386C0&gt;()</p>
<h4>CRunningScript::ProcessOneCommand</h4>
<p>plugin::CallMethodAndReturn<char, 0x439500, CRunningScript *>(this);</p>
<p>0AA8: call_method_return 0x439500 struct [CRunningScript] num_params 0 pop 0 func_ret [char]</p>
<p>define function CRunningScript__ProcessOneCommand&lt;thiscall, 0x439500&gt;(): int</p>
<h4>CRunningScript::CollectParameters</h4>
<p>plugin::CallMethod<0x4382E0, CRunningScript <em>, int</em>, short>(this, arg0, count);</p>
<p>0AA6: call_method 0x4382E0 struct [CRunningScript] num_params 2 pop 0 [arg0] [count]</p>
<p>define function CRunningScript__CollectParameters&lt;thiscall, 0x4382E0&gt;(arg0, count)</p>
<h4>CRunningScript::UpdateCompareFlag</h4>
<p>plugin::CallMethod<0x44FD90, CRunningScript *, unsigned char>(this, flag);</p>
<p>0AA6: call_method 0x44FD90 struct [CRunningScript] num_params 1 pop 0 [flag]</p>
<p>define function CRunningScript__UpdateCompareFlag&lt;thiscall, 0x44FD90&gt;(flag)</p><h3 id="plugin_iiigame_iiicsceneeditcpp">plugin_III\game_III\CSceneEdit.cpp</h3><h4>CSceneEdit::LoadMovie</h4>
<p>plugin::Call<0x5850A0>();</p>
<p>0AA5: call_function 0x5850A0 num_params 0 pop 0</p>
<p>define function CSceneEdit__LoadMovie&lt;cdecl, 0x5850A0&gt;()</p>
<h4>CSceneEdit::SaveMovie</h4>
<p>plugin::Call<0x585110>();</p>
<p>0AA5: call_function 0x585110 num_params 0 pop 0</p>
<p>define function CSceneEdit__SaveMovie&lt;cdecl, 0x585110&gt;()</p>
<h4>CSceneEdit::Initialise</h4>
<p>plugin::Call<0x585170>();</p>
<p>0AA5: call_function 0x585170 num_params 0 pop 0</p>
<p>define function CSceneEdit__Initialise&lt;cdecl, 0x585170&gt;()</p>
<h4>CSceneEdit::InitPlayBack</h4>
<p>plugin::Call<0x5852C0>();</p>
<p>0AA5: call_function 0x5852C0 num_params 0 pop 0</p>
<p>define function CSceneEdit__InitPlayBack&lt;cdecl, 0x5852C0&gt;()</p>
<h4>CSceneEdit::ReInitialise</h4>
<p>plugin::Call<0x5853F0>();</p>
<p>0AA5: call_function 0x5853F0 num_params 0 pop 0</p>
<p>define function CSceneEdit__ReInitialise&lt;cdecl, 0x5853F0&gt;()</p>
<h4>CSceneEdit::Update</h4>
<p>plugin::Call<0x585570>();</p>
<p>0AA5: call_function 0x585570 num_params 0 pop 0</p>
<p>define function CSceneEdit__Update&lt;cdecl, 0x585570&gt;()</p>
<h4>CSceneEdit::Draw</h4>
<p>plugin::Call<0x5855F0>();</p>
<p>0AA5: call_function 0x5855F0 num_params 0 pop 0</p>
<p>define function CSceneEdit__Draw&lt;cdecl, 0x5855F0&gt;()</p>
<h4>CSceneEdit::ProcessCommand</h4>
<p>plugin::Call<0x585BB0>();</p>
<p>0AA5: call_function 0x585BB0 num_params 0 pop 0</p>
<p>define function CSceneEdit__ProcessCommand&lt;cdecl, 0x585BB0&gt;()</p>
<h4>CSceneEdit::PlayBack</h4>
<p>plugin::Call<0x587200>();</p>
<p>0AA5: call_function 0x587200 num_params 0 pop 0</p>
<p>define function CSceneEdit__PlayBack&lt;cdecl, 0x587200&gt;()</p>
<h4>CSceneEdit::ClearForNewCommand</h4>
<p>plugin::Call<0x587AF0>();</p>
<p>0AA5: call_function 0x587AF0 num_params 0 pop 0</p>
<p>define function CSceneEdit__ClearForNewCommand&lt;cdecl, 0x587AF0&gt;()</p>
<h4>CSceneEdit::SelectActor</h4>
<p>plugin::CallAndReturn<bool, 0x587B30>();</p>
<p>0AA7: call_function_return 0x587B30 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectActor&lt;cdecl, 0x587B30&gt;(): int</p>
<h4>CSceneEdit::SelectActor2</h4>
<p>plugin::CallAndReturn<bool, 0x587DC0>();</p>
<p>0AA7: call_function_return 0x587DC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectActor2&lt;cdecl, 0x587DC0&gt;(): int</p>
<h4>CSceneEdit::SelectVehicle</h4>
<p>plugin::CallAndReturn<bool, 0x588040>();</p>
<p>0AA7: call_function_return 0x588040 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectVehicle&lt;cdecl, 0x588040&gt;(): int</p>
<h4>CSceneEdit::SelectWeapon</h4>
<p>plugin::CallAndReturn<bool, 0x588220>();</p>
<p>0AA7: call_function_return 0x588220 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectWeapon&lt;cdecl, 0x588220&gt;(): int</p>
<h4>NextValidModelId</h4>
<p>plugin::CallAndReturn<int, 0x585050, int, int>(currentModelIndex, PrevOrNextModelIndex);</p>
<p>0AA7: call_function_return 0x585050 num_params 2 pop 2 [currentModelIndex] [PrevOrNextModelIndex] func_ret [int]</p>
<p>define function NextValidModelId&lt;cdecl, 0x585050&gt;(currentModelIndex, PrevOrNextModelIndex): int</p><h3 id="plugin_iiigame_iiicscrollbarcpp">plugin_III\game_III\CScrollBar.cpp</h3><h4>CScrollBar::Init</h4>
<p>plugin::CallMethodDynGlobal<CScrollBar *, CVector, unsigned char, float, float, float, unsigned char, unsigned char, unsigned char, float>(gaddrof(CScrollBar::Init), this, pos, type, sizeX, sizeY, sizeZ, red, green, blue, scale);</p>
<p>0AA6: call_method 0x4FF610 struct [CScrollBar] num_params 9 pop 0 [pos] [type] [sizeX] [sizeY] [sizeZ] [red] [green] [blue] [scale]</p>
<p>define function CScrollBar__Init&lt;thiscall, 0x4FF610&gt;(pos, type, sizeX, sizeY, sizeZ, red, green, blue, scale)</p>
<h4>CScrollBar::Render</h4>
<p>plugin::CallMethodDynGlobal<CScrollBar *>(gaddrof(CScrollBar::Render), this);</p>
<p>0AA6: call_method 0x4FFCE0 struct [CScrollBar] num_params 0 pop 0</p>
<p>define function CScrollBar__Render&lt;thiscall, 0x4FFCE0&gt;()</p>
<h4>CScrollBar::Update</h4>
<p>plugin::CallMethodDynGlobal<CScrollBar *>(gaddrof(CScrollBar::Update), this);</p>
<p>0AA6: call_method 0x4FF6E0 struct [CScrollBar] num_params 0 pop 0</p>
<p>define function CScrollBar__Update&lt;thiscall, 0x4FF6E0&gt;()</p>
<h4>*CScrollBar::GetBridgeString</h4>
<p>plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CScrollBar::GetBridgeString));</p>
<p>0AA7: call_function_return 0x4FF390 num_params 0 pop 0 func_ret [char const *]</p>
<p>define function CScrollBar__GetBridgeString&lt;cdecl, 0x4FF390&gt;(): int</p>
<h4>*CScrollBar::GetTunnelString</h4>
<p>plugin::CallAndReturnDynGlobal<char const *>(gaddrof(CScrollBar::GetTunnelString));</p>
<p>0AA7: call_function_return 0x4FF360 num_params 0 pop 0 func_ret [char const *]</p>
<p>define function CScrollBar__GetTunnelString&lt;cdecl, 0x4FF360&gt;(): int</p><h3 id="plugin_iiigame_iiicshadowscpp">plugin_III\game_III\CShadows.cpp</h3><h4>CPermanentShadow::CPermanentShadow</h4>
<p>plugin::CallMethod<0x517900, CPermanentShadow *>(this);</p>
<p>0AA6: call_method 0x517900 struct [CPermanentShadow] num_params 0 pop 0</p>
<p>define function CPermanentShadow__CPermanentShadow&lt;thiscall, 0x517900&gt;()</p>
<h4>CStaticShadow::CStaticShadow</h4>
<p>plugin::CallMethod<0x517910, CStaticShadow *>(this);</p>
<p>0AA6: call_method 0x517910 struct [CStaticShadow] num_params 0 pop 0</p>
<p>define function CStaticShadow__CStaticShadow&lt;thiscall, 0x517910&gt;()</p>
<h4>CStaticShadow::Free</h4>
<p>plugin::CallMethod<0x516E70, CStaticShadow *>(this);</p>
<p>0AA6: call_method 0x516E70 struct [CStaticShadow] num_params 0 pop 0</p>
<p>define function CStaticShadow__Free&lt;thiscall, 0x516E70&gt;()</p>
<h4>CPolyBunch::CPolyBunch</h4>
<p>plugin::CallMethod<0x517920, CPolyBunch *>(this);</p>
<p>0AA6: call_method 0x517920 struct [CPolyBunch] num_params 0 pop 0</p>
<p>define function CPolyBunch__CPolyBunch&lt;thiscall, 0x517920&gt;()</p>
<h4>CRegisteredShadow::CRegisteredShadow</h4>
<p>plugin::CallMethod<0x517940, CRegisteredShadow *>(this);</p>
<p>0AA6: call_method 0x517940 struct [CRegisteredShadow] num_params 0 pop 0</p>
<p>define function CRegisteredShadow__CRegisteredShadow&lt;thiscall, 0x517940&gt;()</p>
<h4>CShadows::RenderIndicatorShadow</h4>
<p>plugin::Call<0x517810, unsigned int, unsigned char, RwTexture<em>, CVector</em>, float, float, float, float, short>(id, shadowType, texture, posn, frontX, frontY, sideX, sideY, intensity);</p>
<p>0AA5: call_function 0x517810 num_params 9 pop 9 [id] [shadowType] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity]</p>
<p>define function CShadows__RenderIndicatorShadow&lt;cdecl, 0x517810&gt;(id, shadowType, texture, posn, frontX, frontY, sideX, sideY, intensity)</p>
<h4>CShadows::Init</h4>
<p>plugin::Call<0x512AB0>();</p>
<p>0AA5: call_function 0x512AB0 num_params 0 pop 0</p>
<p>define function CShadows__Init&lt;cdecl, 0x512AB0&gt;()</p>
<h4>CShadows::Shutdown</h4>
<p>plugin::Call<0x512F20>();</p>
<p>0AA5: call_function 0x512F20 num_params 0 pop 0</p>
<p>define function CShadows__Shutdown&lt;cdecl, 0x512F20&gt;()</p>
<h4>CShadows::AddPermanentShadow</h4>
<p>plugin::Call<0x512FD0, unsigned char, RwTexture<em>, CVector</em>, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, unsigned int, float>(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, time, upDistance);</p>
<p>0AA5: call_function 0x512FD0 num_params 14 pop 14 [type] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [time] [upDistance]</p>
<p>define function CShadows__AddPermanentShadow&lt;cdecl, 0x512FD0&gt;(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, time, upDistance)</p>
<h4>CShadows::StoreStaticShadow</h4>
<p>plugin::Call<0x5130A0, unsigned int, unsigned char, RwTexture<em>, CVector</em>, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, float, bool, float>(id, type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, drawDistance, temporaryShadow, upDistance);</p>
<p>0AA5: call_function 0x5130A0 num_params 17 pop 17 [id] [type] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [scale] [drawDistance] [temporaryShadow] [upDistance]</p>
<p>define function CShadows__StoreStaticShadow&lt;cdecl, 0x5130A0&gt;(id, type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, drawDistance, temporaryShadow, upDistance)</p>
<h4>CShadows::StoreShadowToBeRendered</h4>
<p>plugin::Call<0x513550, unsigned char, CVector*, float, float, float, float, short, unsigned char, unsigned char, unsigned char>(shadowTextureType, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue);</p>
<p>0AA5: call_function 0x513550 num_params 10 pop 10 [shadowTextureType] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue]</p>
<p>define function CShadows__StoreShadowToBeRendered&lt;cdecl, 0x513550&gt;(shadowTextureType, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue)</p>
<h4>CShadows::StoreShadowToBeRendered</h4>
<p>plugin::Call<0x513750, unsigned char, RwTexture<em>, CVector</em>, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, bool, float>(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, drawOnWater, scale);</p>
<p>0AA5: call_function 0x513750 num_params 14 pop 14 [type] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [drawOnWater] [scale]</p>
<p>define function CShadows__StoreShadowToBeRendered&lt;cdecl, 0x513750&gt;(type, texture, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, drawOnWater, scale)</p>
<h4>CShadows::StoreShadowForCar</h4>
<p>plugin::Call<0x513830, CAutomobile*>(car);</p>
<p>0AA5: call_function 0x513830 num_params 1 pop 1 [car]</p>
<p>define function CShadows__StoreShadowForCar&lt;cdecl, 0x513830&gt;(car)</p>
<h4>CShadows::StoreCarLightShadow</h4>
<p>plugin::Call<0x513A70, CVehicle<em>, int, RwTexture</em>, CVector*, float, float, float, float, unsigned char, unsigned char, unsigned char, float>(vehicle, id, texture, posn, frontX, frontY, sideX, sideY, red, green, blue, maxViewAngle);</p>
<p>0AA5: call_function 0x513A70 num_params 12 pop 12 [vehicle] [id] [texture] [posn] [frontX] [frontY] [sideX] [sideY] [red] [green] [blue] [maxViewAngle]</p>
<p>define function CShadows__StoreCarLightShadow&lt;cdecl, 0x513A70&gt;(vehicle, id, texture, posn, frontX, frontY, sideX, sideY, red, green, blue, maxViewAngle)</p>
<h4>CShadows::StoreShadowForPed</h4>
<p>plugin::Call<0x513C50, CPed*, float, float, float, float, float, float>(ped, displacementX, displacementY, frontX, frontY, sideX, sideY);</p>
<p>0AA5: call_function 0x513C50 num_params 7 pop 7 [ped] [displacementX] [displacementY] [frontX] [frontY] [sideX] [sideY]</p>
<p>define function CShadows__StoreShadowForPed&lt;cdecl, 0x513C50&gt;(ped, displacementX, displacementY, frontX, frontY, sideX, sideY)</p>
<h4>CShadows::StoreShadowForPedObject</h4>
<p>plugin::Call<0x513CB0, CEntity*, float, float, float, float, float, float>(entity, displacementX, displacementY, frontX, frontY, sideX, sideY);</p>
<p>0AA5: call_function 0x513CB0 num_params 7 pop 7 [entity] [displacementX] [displacementY] [frontX] [frontY] [sideX] [sideY]</p>
<p>define function CShadows__StoreShadowForPedObject&lt;cdecl, 0x513CB0&gt;(entity, displacementX, displacementY, frontX, frontY, sideX, sideY)</p>
<h4>CShadows::StoreShadowForTree</h4>
<p>plugin::Call<0x513E00, CEntity*>(entity);</p>
<p>0AA5: call_function 0x513E00 num_params 1 pop 1 [entity]</p>
<p>define function CShadows__StoreShadowForTree&lt;cdecl, 0x513E00&gt;(entity)</p>
<h4>CShadows::StoreShadowForPole</h4>
<p>plugin::Call<0x513E10, CEntity*, float, float, float, float, float, unsigned int>(entity, offsetX, offsetY, offsetZ, poleHeight, poleWidth, localId);</p>
<p>0AA5: call_function 0x513E10 num_params 7 pop 7 [entity] [offsetX] [offsetY] [offsetZ] [poleHeight] [poleWidth] [localId]</p>
<p>define function CShadows__StoreShadowForPole&lt;cdecl, 0x513E10&gt;(entity, offsetX, offsetY, offsetZ, poleHeight, poleWidth, localId)</p>
<h4>CShadows::SetRenderModeForShadowType</h4>
<p>plugin::Call<0x513FC0, unsigned char>(shadowType);</p>
<p>0AA5: call_function 0x513FC0 num_params 1 pop 1 [shadowType]</p>
<p>define function CShadows__SetRenderModeForShadowType&lt;cdecl, 0x513FC0&gt;(shadowType)</p>
<h4>CShadows::RenderStoredShadows</h4>
<p>plugin::Call<0x514010>();</p>
<p>0AA5: call_function 0x514010 num_params 0 pop 0</p>
<p>define function CShadows__RenderStoredShadows&lt;cdecl, 0x514010&gt;()</p>
<h4>CShadows::RenderStaticShadows</h4>
<p>plugin::Call<0x5145F0>();</p>
<p>0AA5: call_function 0x5145F0 num_params 0 pop 0</p>
<p>define function CShadows__RenderStaticShadows&lt;cdecl, 0x5145F0&gt;()</p>
<h4>CShadows::GeneratePolysForStaticShadow</h4>
<p>plugin::Call<0x514910, short>(staticShadowIndex);</p>
<p>0AA5: call_function 0x514910 num_params 1 pop 1 [staticShadowIndex]</p>
<p>define function CShadows__GeneratePolysForStaticShadow&lt;cdecl, 0x514910&gt;(staticShadowIndex)</p>
<h4>CShadows::CastShadowSectorList</h4>
<p>plugin::Call<0x514C90, CPtrList&, float, float, float, float, CVector<em>, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, CPolyBunch</em>*>(ptrList, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch);</p>
<p>0AA5: call_function 0x514C90 num_params 17 pop 17 [ptrList] [conrerAX] [cornerAY] [cornerBX] [cornerBY] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [scale] [ppPolyBunch]</p>
<p>define function CShadows__CastShadowSectorList&lt;cdecl, 0x514C90&gt;(ptrList, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch)</p>
<h4>CShadows::CastShadowEntity</h4>
<p>plugin::Call<0x514E30, CEntity<em>, float, float, float, float, CVector</em>, float, float, float, float, short, unsigned char, unsigned char, unsigned char, float, float, CPolyBunch**>(entity, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch);</p>
<p>0AA5: call_function 0x514E30 num_params 17 pop 17 [entity] [conrerAX] [cornerAY] [cornerBX] [cornerBY] [posn] [frontX] [frontY] [sideX] [sideY] [intensity] [red] [green] [blue] [zDistance] [scale] [ppPolyBunch]</p>
<p>define function CShadows__CastShadowEntity&lt;cdecl, 0x514E30&gt;(entity, conrerAX, cornerAY, cornerBX, cornerBY, posn, frontX, frontY, sideX, sideY, intensity, red, green, blue, zDistance, scale, ppPolyBunch)</p>
<h4>CShadows::UpdateStaticShadows</h4>
<p>plugin::Call<0x516BE0>();</p>
<p>0AA5: call_function 0x516BE0 num_params 0 pop 0</p>
<p>define function CShadows__UpdateStaticShadows&lt;cdecl, 0x516BE0&gt;()</p>
<h4>CShadows::UpdatePermanentShadows</h4>
<p>plugin::Call<0x516C40>();</p>
<p>0AA5: call_function 0x516C40 num_params 0 pop 0</p>
<p>define function CShadows__UpdatePermanentShadows&lt;cdecl, 0x516C40&gt;()</p>
<h4>CShadows::CalcPedShadowValues</h4>
<p>plugin::Call<0x516EB0, CVector, float<em>, float</em>, float<em>, float</em>, float<em>, float</em>>(sunPosn, displacementX, displacementY, frontX, frontY, sideX, sideY);</p>
<p>0AA5: call_function 0x516EB0 num_params 7 pop 7 [sunPosn] [displacementX] [displacementY] [frontX] [frontY] [sideX] [sideY]</p>
<p>define function CShadows__CalcPedShadowValues&lt;cdecl, 0x516EB0&gt;(sunPosn, displacementX, displacementY, frontX, frontY, sideX, sideY)</p>
<h4>CShadows::RenderExtraPlayerShadows</h4>
<p>plugin::Call<0x516F90>();</p>
<p>0AA5: call_function 0x516F90 num_params 0 pop 0</p>
<p>define function CShadows__RenderExtraPlayerShadows&lt;cdecl, 0x516F90&gt;()</p>
<h4>CShadows::TidyUpShadows</h4>
<p>plugin::Call<0x517570>();</p>
<p>0AA5: call_function 0x517570 num_params 0 pop 0</p>
<p>define function CShadows__TidyUpShadows&lt;cdecl, 0x517570&gt;()</p><h3 id="plugin_iiigame_iiicshinytextscpp">plugin_III\game_III\CShinyTexts.cpp</h3><h4>CShinyTexts::RegisterOne</h4>
<p>plugin::CallDynGlobal<CVector, CVector, CVector, CVector, float, float, float, float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, float>(gaddrof(CShinyTexts::RegisterOne), cornerAA, cornerAB, cornerBA, cornerBB, u1, v1, u2, v2, u3, v3, u4, v4, type, red, green, blue, maxDistance);</p><h3 id="plugin_iiigame_iiicshotinfocpp">plugin_III\game_III\CShotInfo.cpp</h3><h4>CShotInfo::AddShot</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CEntity *, eWeaponType, CVector, CVector>(gaddrof(CShotInfo::AddShot), sourceEntity, weaponType, startPos, endPos);</p>
<p>0AA7: call_function_return 0x55BD70 num_params 4 pop 4 [sourceEntity] [weaponType] [startPos] [endPos] func_ret [bool]</p>
<p>define function CShotInfo__AddShot&lt;cdecl, 0x55BD70&gt;(sourceEntity, weaponType, startPos, endPos): int</p><h3 id="plugin_iiigame_iiicsimplemodelinfocpp">plugin_III\game_III\CSimpleModelInfo.cpp</h3><h4>CSimpleModelInfo::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<2, CSimpleModelInfo *>(this);</p>
<h4>*CSimpleModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 3, CSimpleModelInfo *>(this);</p>
<h4>*CSimpleModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 4, CSimpleModelInfo *, RwMatrix *>(this, matrix);</p>
<h4>*CSimpleModelInfo::GetRwObject</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 5, CSimpleModelInfo *>(this);</p>
<h4>CSimpleModelInfo::FindRelatedModel</h4>
<p>plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::FindRelatedModel), this);</p>
<p>0AA6: call_method 0x517C00 struct [CSimpleModelInfo] num_params 0 pop 0</p>
<p>define function CSimpleModelInfo__FindRelatedModel&lt;thiscall, 0x517C00&gt;()</p>
<h4>*CSimpleModelInfo::GetAtomicFromDistance</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RpAtomic *, CSimpleModelInfo *, float>(gaddrof(CSimpleModelInfo::GetAtomicFromDistance), this, distance);</p>
<p>0AA8: call_method_return 0x517A00 struct [*CSimpleModelInfo] num_params 1 pop 0 [distance] func_ret [RpAtomic *]</p>
<h4>CSimpleModelInfo::GetLargestLodDistance</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::GetLargestLodDistance), this);</p>
<p>0AA8: call_method_return 0x517A60 struct [CSimpleModelInfo] num_params 0 pop 0 func_ret [float]</p>
<h4>CSimpleModelInfo::GetNearDistance</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::GetNearDistance), this);</p>
<p>0AA8: call_method_return 0x517A90 struct [CSimpleModelInfo] num_params 0 pop 0 func_ret [float]</p>
<h4>CSimpleModelInfo::IncreaseAlpha</h4>
<p>plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::IncreaseAlpha), this);</p>
<p>0AA6: call_method 0x517C60 struct [CSimpleModelInfo] num_params 0 pop 0</p>
<p>define function CSimpleModelInfo__IncreaseAlpha&lt;thiscall, 0x517C60&gt;()</p>
<h4>CSimpleModelInfo::Init</h4>
<p>plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::Init), this);</p>
<p>0AA6: call_method 0x517990 struct [CSimpleModelInfo] num_params 0 pop 0</p>
<p>define function CSimpleModelInfo__Init&lt;thiscall, 0x517990&gt;()</p>
<h4>CSimpleModelInfo::SetAtomic</h4>
<p>plugin::CallMethodDynGlobal<CSimpleModelInfo *, int, RpAtomic *>(gaddrof(CSimpleModelInfo::SetAtomic), this, number, atomic);</p>
<p>0AA6: call_method 0x517950 struct [CSimpleModelInfo] num_params 2 pop 0 [number] [atomic]</p>
<p>define function CSimpleModelInfo__SetAtomic&lt;thiscall, 0x517950&gt;(number, atomic)</p>
<h4>CSimpleModelInfo::SetLodDistances</h4>
<p>plugin::CallMethodDynGlobal<CSimpleModelInfo *, float *>(gaddrof(CSimpleModelInfo::SetLodDistances), this, distance);</p>
<p>0AA6: call_method 0x517AA0 struct [CSimpleModelInfo] num_params 1 pop 0 [distance]</p>
<p>define function CSimpleModelInfo__SetLodDistances&lt;thiscall, 0x517AA0&gt;(distance)</p>
<h4>CSimpleModelInfo::SetupBigBuilding</h4>
<p>plugin::CallMethodDynGlobal<CSimpleModelInfo *>(gaddrof(CSimpleModelInfo::SetupBigBuilding), this);</p>
<p>0AA6: call_method 0x517B90 struct [CSimpleModelInfo] num_params 0 pop 0</p>
<p>define function CSimpleModelInfo__SetupBigBuilding&lt;thiscall, 0x517B90&gt;()</p><h3 id="plugin_iiigame_iiicskidmarkscpp">plugin_III\game_III\CSkidmarks.cpp</h3><h4>CSkidmarks::RegisterOne</h4>
<p>plugin::CallDynGlobal<unsigned int, CVector, float, float, bool *, bool *>(gaddrof(CSkidmarks::RegisterOne), id, pos, fwdX, fwdY, isMuddy, isBloody);</p><h3 id="plugin_iiigame_iiicspecialfxcpp">plugin_III\game_III\CSpecialFX.cpp</h3><h4>*LookForBatCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(LookForBatCB), object, data);</p>
<p>0AA7: call_function_return 0x518BF0 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function LookForBatCB&lt;cdecl, 0x518BF0&gt;(object, data): int</p><h3 id="plugin_iiigame_iiicspecialparticlestuffcpp">plugin_III\game_III\CSpecialParticleStuff.cpp</h3><h4>CSpecialParticleStuff::CreateFoamAroundObject</h4>
<p>plugin::CallDynGlobal<CMatrix *, float, float, float, int>(gaddrof(CSpecialParticleStuff::CreateFoamAroundObject), matrix, x, y, z, particles);</p>
<h4>CSpecialParticleStuff::UpdateBoatFoamAnimation</h4>
<p>plugin::CallDynGlobal<CMatrix *>(gaddrof(CSpecialParticleStuff::UpdateBoatFoamAnimation), matrix);</p><h3 id="plugin_iiigame_iiicspritecpp">plugin_III\game_III\CSprite.cpp</h3><h4>CSprite::CalcHorizonCoors</h4>
<p>plugin::CallAndReturnDynGlobal<float>(gaddrof(CSprite::CalcHorizonCoors));</p>
<p>0AA7: call_function_return 0x51C4A0 num_params 0 pop 0 func_ret [float]</p>
<p>define function CSprite__CalcHorizonCoors&lt;cdecl, 0x51C4A0&gt;(): float</p>
<h4>CSprite::CalcScreenCoors</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RwV3d const &, RwV3d *, float *, float *, bool>(gaddrof(CSprite::CalcScreenCoors), in, out, outW, outH, farClip);</p>
<p>0AA7: call_function_return 0x51C3A0 num_params 5 pop 5 [in] [out] [outW] [outH] [farClip] func_ret [bool]</p>
<p>define function CSprite__CalcScreenCoors&lt;cdecl, 0x51C3A0&gt;(in, out, outW, outH, farClip): int</p>
<h4>CSprite::RenderBufferedOneXLUSprite</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite), x, y, z, w, h, red, green, blue, alpha, rhw, intensity);</p>
<h4>CSprite::RenderBufferedOneXLUSprite2D</h4>
<p>plugin::CallDynGlobal<float, float, float, float, RwRGBA const &, short, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite2D), x, y, w, h, color, intensity, alpha);</p>
<h4>CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension</h4>
<p>plugin::CallDynGlobal<float, float, float, float, RwRGBA const &, short, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension), x, y, w, h, color, intensity, angle, alpha);</p>
<h4>CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float, float, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours), x, y, z, w, h, red, green, blue, red2, green2, blue2, colx, coly, rhw, angle, intensity);</p>
<h4>CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);</p>
<h4>CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);</p>
<h4>CSprite::RenderOneXLUSprite</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, unsigned char>(gaddrof(CSprite::RenderOneXLUSprite), x, y, z, w, h, red, green, blue, alpha, rhw, intensity);</p>
<h4>CSprite::RenderOneXLUSprite_Rotate_Aspect</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, unsigned char, unsigned char, unsigned char, short, float, float, unsigned char>(gaddrof(CSprite::RenderOneXLUSprite_Rotate_Aspect), x, y, z, w, h, red, green, blue, alpha, rhw, angle, intensity);</p>
<h4>CSprite::Set6Vertices2D</h4>
<p>plugin::CallDynGlobal<RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite::Set6Vertices2D, void (*)(RwIm2DVertex *, CRect const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;)), vertex, rect, color1, color2, color3, color4);</p>
<h4>CSprite::Set6Vertices2D</h4>
<p>plugin::CallDynGlobal<RwIm2DVertex *, float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite::Set6Vertices2D, void (*)(RwIm2DVertex *, float, float, float, float, float, float, float, float, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;)), vertex, x1, y1, x2, y2, x3, y3, x4, y4, color1, color2, color3, color4);</p><h3 id="plugin_iiigame_iiicsprite2dcpp">plugin_III\game_III\CSprite2d.cpp</h3><h4>CSprite2d::Delete</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(gaddrof(CSprite2d::Delete), this);</p>
<p>0AA6: call_method 0x51EA00 struct [CSprite2d] num_params 0 pop 0</p>
<p>define function CSprite2d__Delete&lt;thiscall, 0x51EA00&gt;()</p>
<h4>CSprite2d::Draw</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, float, float, float, float, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(float, float, float, float, CRGBA const &amp;)), this, x, y, w, h, color);</p>
<p>0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 5 pop 0 [x] [y] [w] [h] [color]</p>
<p>define function CSprite2d__Draw&lt;thiscall, 0x51EE40&gt;(x, y, w, h, color)</p>
<h4>CSprite2d::Draw</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &amp;, CRGBA const &amp;)), this, rect, color);</p>
<p>0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 2 pop 0 [rect] [color]</p>
<p>define function CSprite2d__Draw&lt;thiscall, 0x51EE40&gt;(rect, color)</p>
<h4>CSprite2d::Draw</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &amp;, CRGBA const &amp;, float, float, float, float, float, float, float, float)), this, rect, color, u1, v1, u2, v2, u3, v3, u4, v4);</p>
<p>0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 10 pop 0 [rect] [color] [u1] [v1] [u2] [v2] [u3] [v3] [u4] [v4]</p>
<p>define function CSprite2d__Draw&lt;thiscall, 0x51EE40&gt;(rect, color, u1, v1, u2, v2, u3, v3, u4, v4)</p>
<h4>CSprite2d::Draw</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(CRect const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;)), this, rect, color1, color2, color3, color4);</p>
<p>0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 5 pop 0 [rect] [color1] [color2] [color3] [color4]</p>
<p>define function CSprite2d__Draw&lt;thiscall, 0x51EE40&gt;(rect, color1, color2, color3, color4)</p>
<h4>CSprite2d::Draw</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, float, float, float, float, float, float, float, float, CRGBA const &>(gaddrof_o(CSprite2d::Draw, void (CSprite2d::*)(float, float, float, float, float, float, float, float, CRGBA const &amp;)), this, x1, y1, x2, y2, x3, y3, x4, y4, color);</p>
<p>0AA6: call_method 0x51EE40 struct [CSprite2d] num_params 9 pop 0 [x1] [y1] [x2] [y2] [x3] [y3] [x4] [y4] [color]</p>
<p>define function CSprite2d__Draw&lt;thiscall, 0x51EE40&gt;(x1, y1, x2, y2, x3, y3, x4, y4, color)</p>
<h4>CSprite2d::SetAddressing</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, RwTextureAddressMode>(gaddrof(CSprite2d::SetAddressing), this, modeUV);</p>
<p>0AA6: call_method 0x51EAA0 struct [CSprite2d] num_params 1 pop 0 [modeUV]</p>
<p>define function CSprite2d__SetAddressing&lt;thiscall, 0x51EAA0&gt;(modeUV)</p>
<h4>CSprite2d::SetRenderState</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(gaddrof(CSprite2d::SetRenderState), this);</p>
<p>0AA6: call_method 0x51F950 struct [CSprite2d] num_params 0 pop 0</p>
<p>define function CSprite2d__SetRenderState&lt;thiscall, 0x51F950&gt;()</p>
<h4>CSprite2d::SetTexture</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, char *>(gaddrof_o(CSprite2d::SetTexture, void (CSprite2d::*)(char *)), this, name);</p>
<p>0AA6: call_method 0x51EA70 struct [CSprite2d] num_params 1 pop 0 [name]</p>
<p>define function CSprite2d__SetTexture&lt;thiscall, 0x51EA70&gt;(name)</p>
<h4>CSprite2d::SetTexture</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *, char *, char *>(gaddrof_o(CSprite2d::SetTexture, void (CSprite2d::*)(char *, char *)), this, name, maskName);</p>
<p>0AA6: call_method 0x51EA70 struct [CSprite2d] num_params 2 pop 0 [name] [maskName]</p>
<p>define function CSprite2d__SetTexture&lt;thiscall, 0x51EA70&gt;(name, maskName)</p>
<h4>CSprite2d::AddSpriteToBank</h4>
<p>plugin::CallDynGlobal<int, CRect const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof(CSprite2d::AddSpriteToBank), bank, rect, color, u1, v1, u2, v2, u3, v3, u4, v4);</p>
<h4>CSprite2d::DrawBank</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CSprite2d::DrawBank), bank);</p>
<h4>CSprite2d::DrawRect</h4>
<p>plugin::CallDynGlobal<CRect const &, CRGBA const &>(gaddrof_o(CSprite2d::DrawRect, void (*)(CRect const &amp;, CRGBA const &amp;)), rect, color);</p>
<h4>CSprite2d::DrawRect</h4>
<p>plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::DrawRect, void (*)(CRect const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;)), rect, color1, color2, color3, color4);</p>
<h4>CSprite2d::DrawRectXLU</h4>
<p>plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof(CSprite2d::DrawRectXLU), rect, color1, color2, color3, color4);</p>
<h4>CSprite2d::GetBank</h4>
<p>plugin::CallAndReturnDynGlobal<int, int, RwTexture *>(gaddrof(CSprite2d::GetBank), n, texture);</p>
<p>0AA7: call_function_return 0x51EB70 num_params 2 pop 2 [n] [texture] func_ret [int]</p>
<p>define function CSprite2d__GetBank&lt;cdecl, 0x51EB70&gt;(n, texture): int</p>
<h4>CSprite2d::SetMaskVertices</h4>
<p>plugin::CallDynGlobal<int, float *>(gaddrof(CSprite2d::SetMaskVertices), numVerts, pos);</p>
<h4>CSprite2d::SetVertices</h4>
<p>plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, unsigned int>(gaddrof_o(CSprite2d::SetVertices, void (*)(CRect const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, unsigned int)), rect, color1, color2, color3, color4, bFar);</p>
<h4>CSprite2d::SetVertices</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, float, float, float, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &>(gaddrof_o(CSprite2d::SetVertices, void (*)(float, float, float, float, float, float, float, float, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;)), x1, y1, x2, y2, x3, y3, x4, y4, color1, color2, color3, color4);</p>
<h4>CSprite2d::SetVertices</h4>
<p>plugin::CallDynGlobal<CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::SetVertices, void (*)(CRect const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, float, float, float, float, float, float, float, float)), rect, color1, color2, color3, color4, u1, v1, u2, v2, u3, v3, u4, v4);</p>
<h4>CSprite2d::SetVertices</h4>
<p>plugin::CallDynGlobal<int, float *, float *, CRGBA const &>(gaddrof_o(CSprite2d::SetVertices, void (*)(int, float *, float *, CRGBA const &amp;)), numVerts, pos, texCoors, color);</p>
<h4>CSprite2d::SetVertices</h4>
<p>plugin::CallDynGlobal<RwIm2DVertex *, CRect const &, CRGBA const &, CRGBA const &, CRGBA const &, CRGBA const &, float, float, float, float, float, float, float, float>(gaddrof_o(CSprite2d::SetVertices, void (*)(RwIm2DVertex *, CRect const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, CRGBA const &amp;, float, float, float, float, float, float, float, float)), vertices, rect, color1, color2, color3, color4, u1, v1, u2, v2, u3, v3, u4, v4);</p><h3 id="plugin_iiigame_iiicstatscpp">plugin_III\game_III\CStats.cpp</h3><h4>CStats::AnotherCriminalCaught</h4>
<p>plugin::Call<0x4AB050>();</p>
<p>0AA5: call_function 0x4AB050 num_params 0 pop 0</p>
<p>define function CStats__AnotherCriminalCaught&lt;cdecl, 0x4AB050&gt;()</p>
<h4>CStats::AnotherFireExtinguished</h4>
<p>plugin::Call<0x4AB080>();</p>
<p>0AA5: call_function 0x4AB080 num_params 0 pop 0</p>
<p>define function CStats__AnotherFireExtinguished&lt;cdecl, 0x4AB080&gt;()</p>
<h4>CStats::AnotherKillFrenzyPassed</h4>
<p>plugin::Call<0x4AB240>();</p>
<p>0AA5: call_function 0x4AB240 num_params 0 pop 0</p>
<p>define function CStats__AnotherKillFrenzyPassed&lt;cdecl, 0x4AB240&gt;()</p>
<h4>CStats::AnotherLifeSavedWithAmbulance</h4>
<p>plugin::Call<0x4AB040>();</p>
<p>0AA5: call_function 0x4AB040 num_params 0 pop 0</p>
<p>define function CStats__AnotherLifeSavedWithAmbulance&lt;cdecl, 0x4AB040&gt;()</p>
<h4>CStats::CheckPointReachedSuccessfully</h4>
<p>plugin::Call<0x4AB270>();</p>
<p>0AA5: call_function 0x4AB270 num_params 0 pop 0</p>
<p>define function CStats__CheckPointReachedSuccessfully&lt;cdecl, 0x4AB270&gt;()</p>
<h4>CStats::CheckPointReachedUnsuccessfully</h4>
<p>plugin::Call<0x4AB290>();</p>
<p>0AA5: call_function 0x4AB290 num_params 0 pop 0</p>
<p>define function CStats__CheckPointReachedUnsuccessfully&lt;cdecl, 0x4AB290&gt;()</p>
<h4>CStats::FindCriminalRatingNumber</h4>
<p>plugin::CallAndReturn<int, 0x4AB2A0>();</p>
<p>0AA7: call_function_return 0x4AB2A0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStats__FindCriminalRatingNumber&lt;cdecl, 0x4AB2A0&gt;(): int</p>
<h4>CStats::FindCriminalRatingString</h4>
<p>plugin::CallAndReturn<wchar_t*, 0x4AB090>();</p>
<p>0AA7: call_function_return 0x4AB090 num_params 0 pop 0 func_ret [wchar_t*]</p>
<p>define function CStats__FindCriminalRatingString&lt;cdecl, 0x4AB090&gt;(): int</p>
<h4>CStats::Init</h4>
<p>plugin::Call<0x4AAC60>();</p>
<p>0AA5: call_function 0x4AAC60 num_params 0 pop 0</p>
<p>define function CStats__Init&lt;cdecl, 0x4AAC60&gt;()</p>
<h4>CStats::LoadStats</h4>
<p>plugin::Call<0x4AB670, unsigned char*, unsigned int>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4AB670 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CStats__LoadStats&lt;cdecl, 0x4AB670&gt;(bufferPointer, structSize)</p>
<h4>CStats::Register4x4MayhemTime</h4>
<p>plugin::Call<0x4AB020, int>(time);</p>
<p>0AA5: call_function 0x4AB020 num_params 1 pop 1 [time]</p>
<p>define function CStats__Register4x4MayhemTime&lt;cdecl, 0x4AB020&gt;(time)</p>
<h4>CStats::Register4x4OneTime</h4>
<p>plugin::Call<0x4AAFC0, int>(time);</p>
<p>0AA5: call_function 0x4AAFC0 num_params 1 pop 1 [time]</p>
<p>define function CStats__Register4x4OneTime&lt;cdecl, 0x4AAFC0&gt;(time)</p>
<h4>CStats::Register4x4ThreeTime</h4>
<p>plugin::Call<0x4AB000, int>(time);</p>
<p>0AA5: call_function 0x4AB000 num_params 1 pop 1 [time]</p>
<p>define function CStats__Register4x4ThreeTime&lt;cdecl, 0x4AB000&gt;(time)</p>
<h4>CStats::Register4x4TwoTime</h4>
<p>plugin::Call<0x4AAFE0, int>(time);</p>
<p>0AA5: call_function 0x4AAFE0 num_params 1 pop 1 [time]</p>
<p>define function CStats__Register4x4TwoTime&lt;cdecl, 0x4AAFE0&gt;(time)</p>
<h4>CStats::RegisterElBurroTime</h4>
<p>plugin::Call<0x4AAFA0, int>(time);</p>
<p>0AA5: call_function 0x4AAFA0 num_params 1 pop 1 [time]</p>
<p>define function CStats__RegisterElBurroTime&lt;cdecl, 0x4AAFA0&gt;(time)</p>
<h4>CStats::RegisterFastestTime</h4>
<p>plugin::Call<0x4AAF50, int, int>(statID, time);</p>
<p>0AA5: call_function 0x4AAF50 num_params 2 pop 2 [statID] [time]</p>
<p>define function CStats__RegisterFastestTime&lt;cdecl, 0x4AAF50&gt;(statID, time)</p>
<h4>CStats::RegisterHighestScore</h4>
<p>plugin::Call<0x4AAF80, int, int>(statID, score);</p>
<p>0AA5: call_function 0x4AAF80 num_params 2 pop 2 [statID] [score]</p>
<p>define function CStats__RegisterHighestScore&lt;cdecl, 0x4AAF80&gt;(statID, score)</p>
<h4>CStats::RegisterLevelAmbulanceMission</h4>
<p>plugin::Call<0x4AB060, int>(level);</p>
<p>0AA5: call_function 0x4AB060 num_params 1 pop 1 [level]</p>
<p>define function CStats__RegisterLevelAmbulanceMission&lt;cdecl, 0x4AB060&gt;(level)</p>
<h4>CStats::RegisterLongestFlightInDodo</h4>
<p>plugin::Call<0x4AB200, int>(distance);</p>
<p>0AA5: call_function 0x4AB200 num_params 1 pop 1 [distance]</p>
<p>define function CStats__RegisterLongestFlightInDodo&lt;cdecl, 0x4AB200&gt;(distance)</p>
<h4>CStats::RegisterTimeTakenDefuseMission</h4>
<p>plugin::Call<0x4AB220, int>(time);</p>
<p>0AA5: call_function 0x4AB220 num_params 1 pop 1 [time]</p>
<p>define function CStats__RegisterTimeTakenDefuseMission&lt;cdecl, 0x4AB220&gt;(time)</p>
<h4>CStats::SaveStats</h4>
<p>plugin::Call<0x4AB3E0, unsigned char<em>, unsigned int</em>>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4AB3E0 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CStats__SaveStats&lt;cdecl, 0x4AB3E0&gt;(bufferPointer, structSize)</p>
<h4>CStats::SetTotalNumberKillFrenzies</h4>
<p>plugin::Call<0x4AB250, int>(number);</p>
<p>0AA5: call_function 0x4AB250 num_params 1 pop 1 [number]</p>
<p>define function CStats__SetTotalNumberKillFrenzies&lt;cdecl, 0x4AB250&gt;(number)</p>
<h4>CStats::SetTotalNumberMissions</h4>
<p>plugin::Call<0x4AB260, int>(number);</p>
<p>0AA5: call_function 0x4AB260 num_params 1 pop 1 [number]</p>
<p>define function CStats__SetTotalNumberMissions&lt;cdecl, 0x4AB260&gt;(number)</p><h3 id="plugin_iiigame_iiicstoredcarcpp">plugin_III\game_III\CStoredCar.cpp</h3><h4>*CStoredCar::RestoreCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVehicle *, CStoredCar *>(gaddrof(CStoredCar::RestoreCar), this);</p>
<p>0AA8: call_method_return 0x427690 struct [*CStoredCar] num_params 0 pop 0 func_ret [CVehicle *]</p>
<h4>CStoredCar::StoreCar</h4>
<p>plugin::CallMethodDynGlobal<CStoredCar *, CVehicle *>(gaddrof(CStoredCar::StoreCar), this, vehicle);</p>
<p>0AA6: call_method 0x4275C0 struct [CStoredCar] num_params 1 pop 0 [vehicle]</p>
<p>define function CStoredCar__StoreCar&lt;thiscall, 0x4275C0&gt;(vehicle)</p>
<h4>CStoredCar::SetExtras</h4>
<p>plugin::CallDynGlobal<char, char>(gaddrof(CStoredCar::SetExtras), first, second);</p><h3 id="plugin_iiigame_iiicstreamingcpp">plugin_III\game_III\CStreaming.cpp</h3><h4>CStreaming::RequestModel</h4>
<p>plugin::Call<0x407EA0, int, int>(modelIndex, flags);</p>
<p>0AA5: call_function 0x407EA0 num_params 2 pop 2 [modelIndex] [flags]</p>
<p>define function CStreaming__RequestModel&lt;cdecl, 0x407EA0&gt;(modelIndex, flags)</p>
<h4>CStreaming::LoadRequestedModels</h4>
<p>plugin::Call<0x40A390>();</p>
<p>0AA5: call_function 0x40A390 num_params 0 pop 0</p>
<p>define function CStreaming__LoadRequestedModels&lt;cdecl, 0x40A390&gt;()</p>
<h4>CStreaming::Init</h4>
<p>plugin::Call<0x406430>();</p>
<p>0AA5: call_function 0x406430 num_params 0 pop 0</p>
<p>define function CStreaming__Init&lt;cdecl, 0x406430&gt;()</p>
<h4>CStreaming::FlushChannels</h4>
<p>plugin::Call<0x40A610>();</p>
<p>0AA5: call_function 0x40A610 num_params 0 pop 0</p>
<p>define function CStreaming__FlushChannels&lt;cdecl, 0x40A610&gt;()</p>
<h4>CStreaming::FlushRequestList</h4>
<p>plugin::Call<0x40A680>();</p>
<p>0AA5: call_function 0x40A680 num_params 0 pop 0</p>
<p>define function CStreaming__FlushRequestList&lt;cdecl, 0x40A680&gt;()</p>
<h4>CStreaming::GetAvailableVehicleSlot</h4>
<p>plugin::CallAndReturn<int, 0x40B160>();</p>
<p>0AA7: call_function_return 0x40B160 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStreaming__GetAvailableVehicleSlot&lt;cdecl, 0x40B160&gt;(): int</p>
<h4>CStreaming::IsTxdUsedByRequestedModels</h4>
<p>plugin::CallAndReturn<bool, 0x4094C0, int>(index);</p>
<p>0AA7: call_function_return 0x4094C0 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CStreaming__IsTxdUsedByRequestedModels&lt;cdecl, 0x4094C0&gt;(index): int</p>
<h4>CStreaming::LoadAllRequestedModels</h4>
<p>plugin::Call<0x40A440, bool>(onlyQuickRequests);</p>
<p>0AA5: call_function 0x40A440 num_params 1 pop 1 [onlyQuickRequests]</p>
<p>define function CStreaming__LoadAllRequestedModels&lt;cdecl, 0x40A440&gt;(onlyQuickRequests)</p>
<h4>CStreaming::RemoveModel</h4>
<p>plugin::Call<0x408830, int>(modelIndex);</p>
<p>0AA5: call_function 0x408830 num_params 1 pop 1 [modelIndex]</p>
<p>define function CStreaming__RemoveModel&lt;cdecl, 0x408830&gt;(modelIndex)</p>
<h4>CStreaming::RemoveLeastUsedModel</h4>
<p>plugin::CallAndReturn<bool, 0x4089B0>();</p>
<p>0AA7: call_function_return 0x4089B0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__RemoveLeastUsedModel&lt;cdecl, 0x4089B0&gt;(): int</p>
<h4>CStreaming::RemoveLoadedVehicle</h4>
<p>plugin::CallAndReturn<bool, 0x40B180>();</p>
<p>0AA7: call_function_return 0x40B180 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__RemoveLoadedVehicle&lt;cdecl, 0x40B180&gt;(): int</p>
<h4>CStreaming::RemoveAllUnusedModels</h4>
<p>plugin::Call<0x408940>();</p>
<p>0AA5: call_function 0x408940 num_params 0 pop 0</p>
<p>define function CStreaming__RemoveAllUnusedModels&lt;cdecl, 0x408940&gt;()</p>
<h4>CStreaming::RemoveCurrentZonesModels</h4>
<p>plugin::Call<0x40AD00>();</p>
<p>0AA5: call_function 0x40AD00 num_params 0 pop 0</p>
<p>define function CStreaming__RemoveCurrentZonesModels&lt;cdecl, 0x40AD00&gt;()</p>
<h4>CStreaming::RemoveUnusedModelsInLoadedList</h4>
<p>plugin::Call<0x4089A0>();</p>
<p>0AA5: call_function 0x4089A0 num_params 0 pop 0</p>
<p>define function CStreaming__RemoveUnusedModelsInLoadedList&lt;cdecl, 0x4089A0&gt;()</p>
<h4>CStreaming::RequestModelStream</h4>
<p>plugin::Call<0x40A060, int>(streamnum);</p>
<p>0AA5: call_function 0x40A060 num_params 1 pop 1 [streamnum]</p>
<p>define function CStreaming__RequestModelStream&lt;cdecl, 0x40A060&gt;(streamnum)</p>
<h4>CStreaming::RequestSpecialChar</h4>
<p>plugin::Call<0x40ADA0, int, char const*, int>(index, txdname, modelrequestflag);</p>
<p>0AA5: call_function 0x40ADA0 num_params 3 pop 3 [index] [txdname] [modelrequestflag]</p>
<p>define function CStreaming__RequestSpecialChar&lt;cdecl, 0x40ADA0&gt;(index, txdname, modelrequestflag)</p>
<h4>CStreaming::RequestSpecialModel</h4>
<p>plugin::Call<0x40A890, int, char const*, int>(slot, name, modelrequestflag);</p>
<p>0AA5: call_function 0x40A890 num_params 3 pop 3 [slot] [name] [modelrequestflag]</p>
<p>define function CStreaming__RequestSpecialModel&lt;cdecl, 0x40A890&gt;(slot, name, modelrequestflag)</p>
<h4>CStreaming::RequestSubway</h4>
<p>plugin::Call<0x407FD0>();</p>
<p>0AA5: call_function 0x407FD0 num_params 0 pop 0</p>
<p>define function CStreaming__RequestSubway&lt;cdecl, 0x407FD0&gt;()</p>
<h4>CStreaming::SetMissionDoesntRequireModel</h4>
<p>plugin::Call<0x40A820, int>(modelIndex);</p>
<p>0AA5: call_function 0x40A820 num_params 1 pop 1 [modelIndex]</p>
<p>define function CStreaming__SetMissionDoesntRequireModel&lt;cdecl, 0x40A820&gt;(modelIndex)</p>
<h4>CStreaming::SetMissionDoesntRequireSpecialChar</h4>
<p>plugin::Call<0x40ADE0, int>(index);</p>
<p>0AA5: call_function 0x40ADE0 num_params 1 pop 1 [index]</p>
<p>define function CStreaming__SetMissionDoesntRequireSpecialChar&lt;cdecl, 0x40ADE0&gt;(index)</p>
<h4>CStreaming::SetModelIsDeletable</h4>
<p>plugin::Call<0x40A790, int>(modelIndex);</p>
<p>0AA5: call_function 0x40A790 num_params 1 pop 1 [modelIndex]</p>
<p>define function CStreaming__SetModelIsDeletable&lt;cdecl, 0x40A790&gt;(modelIndex)</p>
<h4>CStreaming::SetModelTxdIsDeletable</h4>
<p>plugin::Call<0x40A800, int>(modelIndex);</p>
<p>0AA5: call_function 0x40A800 num_params 1 pop 1 [modelIndex]</p>
<p>define function CStreaming__SetModelTxdIsDeletable&lt;cdecl, 0x40A800&gt;(modelIndex)</p>
<h4>CStreaming::Shutdown</h4>
<p>plugin::Call<0x406C80>();</p>
<p>0AA5: call_function 0x406C80 num_params 0 pop 0</p>
<p>define function CStreaming__Shutdown&lt;cdecl, 0x406C80&gt;()</p>
<h4>CStreaming::StreamVehiclesAndPeds</h4>
<p>plugin::Call<0x40AE60>();</p>
<p>0AA5: call_function 0x40AE60 num_params 0 pop 0</p>
<p>define function CStreaming__StreamVehiclesAndPeds&lt;cdecl, 0x40AE60&gt;()</p>
<h4>CStreaming::Update</h4>
<p>plugin::Call<0x4076C0>();</p>
<p>0AA5: call_function 0x4076C0 num_params 0 pop 0</p>
<p>define function CStreaming__Update&lt;cdecl, 0x4076C0&gt;()</p>
<h4>CStreaming::UpdateMemoryUsed</h4>
<p>plugin::Call<0x4076B0>();</p>
<p>0AA5: call_function 0x4076B0 num_params 0 pop 0</p>
<p>define function CStreaming__UpdateMemoryUsed&lt;cdecl, 0x4076B0&gt;()</p>
<h4>CStreaming::AddModelsToRequestList</h4>
<p>plugin::Call<0x4078F0, CVector const&>(point);</p>
<p>0AA5: call_function 0x4078F0 num_params 1 pop 1 [point]</p>
<p>define function CStreaming__AddModelsToRequestList&lt;cdecl, 0x4078F0&gt;(point)</p>
<h4>CStreaming::AddToLoadedVehiclesList</h4>
<p>plugin::Call<0x40B060, int>(vehicleId);</p>
<p>0AA5: call_function 0x40B060 num_params 1 pop 1 [vehicleId]</p>
<p>define function CStreaming__AddToLoadedVehiclesList&lt;cdecl, 0x40B060&gt;(vehicleId)</p>
<h4>CStreaming::ConvertBufferToObject</h4>
<p>plugin::CallAndReturn<bool, 0x409740, char*, int>(pFileContect, modelIndex);</p>
<p>0AA7: call_function_return 0x409740 num_params 2 pop 2 [pFileContect] [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__ConvertBufferToObject&lt;cdecl, 0x409740&gt;(pFileContect, modelIndex): int</p>
<h4>CStreaming::DeleteAllRwObjects</h4>
<p>plugin::Call<0x407390>();</p>
<p>0AA5: call_function 0x407390 num_params 0 pop 0</p>
<p>define function CStreaming__DeleteAllRwObjects&lt;cdecl, 0x407390&gt;()</p>
<h4>CStreaming::DeleteFarAwayRwObjects</h4>
<p>plugin::Call<0x407070, CVector const&>(point);</p>
<p>0AA5: call_function 0x407070 num_params 1 pop 1 [point]</p>
<p>define function CStreaming__DeleteFarAwayRwObjects&lt;cdecl, 0x407070&gt;(point)</p>
<h4>CStreaming::DeleteRwObjectsAfterDeath</h4>
<p>plugin::Call<0x407400, CVector const&>(point);</p>
<p>0AA5: call_function 0x407400 num_params 1 pop 1 [point]</p>
<p>define function CStreaming__DeleteRwObjectsAfterDeath&lt;cdecl, 0x407400&gt;(point)</p>
<h4>CStreaming::DeleteRwObjectsBehindCamera</h4>
<p>plugin::Call<0x408A60, int>(size);</p>
<p>0AA5: call_function 0x408A60 num_params 1 pop 1 [size]</p>
<p>define function CStreaming__DeleteRwObjectsBehindCamera&lt;cdecl, 0x408A60&gt;(size)</p>
<h4>CStreaming::DeleteRwObjectsBehindCameraInSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x409340, CPtrList&, int>(list, size);</p>
<p>0AA7: call_function_return 0x409340 num_params 2 pop 2 [list] [size] func_ret [bool]</p>
<p>define function CStreaming__DeleteRwObjectsBehindCameraInSectorList&lt;cdecl, 0x409340&gt;(list, size): int</p>
<h4>CStreaming::DeleteRwObjectsInOverlapSectorList</h4>
<p>plugin::Call<0x4075A0, CPtrList&, int, int>(list, arg1, arg2);</p>
<p>0AA5: call_function 0x4075A0 num_params 3 pop 3 [list] [arg1] [arg2]</p>
<p>define function CStreaming__DeleteRwObjectsInOverlapSectorList&lt;cdecl, 0x4075A0&gt;(list, arg1, arg2)</p>
<h4>CStreaming::DeleteRwObjectsInSectorList</h4>
<p>plugin::Call<0x407560, CPtrList&>(list);</p>
<p>0AA5: call_function 0x407560 num_params 1 pop 1 [list]</p>
<p>define function CStreaming__DeleteRwObjectsInSectorList&lt;cdecl, 0x407560&gt;(list)</p>
<h4>CStreaming::DeleteRwObjectsNotInFrustumInSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x4093C0, CPtrList&, int>(list, size);</p>
<p>0AA7: call_function_return 0x4093C0 num_params 2 pop 2 [list] [size] func_ret [bool]</p>
<p>define function CStreaming__DeleteRwObjectsNotInFrustumInSectorList&lt;cdecl, 0x4093C0&gt;(list, size): int</p>
<h4>CStreaming::FinishLoadingLargeFile</h4>
<p>plugin::CallAndReturn<bool, 0x409580, char*, int>(FileName, modelIndex);</p>
<p>0AA7: call_function_return 0x409580 num_params 2 pop 2 [FileName] [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__FinishLoadingLargeFile&lt;cdecl, 0x409580&gt;(FileName, modelIndex): int</p>
<h4>CStreaming::GetCdImageOffset</h4>
<p>plugin::CallAndReturn<unsigned int, 0x409FF0, int>(arg0);</p>
<p>0AA7: call_function_return 0x409FF0 num_params 1 pop 1 [arg0] func_ret [unsigned int]</p>
<p>define function CStreaming__GetCdImageOffset&lt;cdecl, 0x409FF0&gt;(arg0): int</p>
<h4>CStreaming::GetNextFileOnCd</h4>
<p>plugin::CallAndReturn<int, 0x409E50, int, bool>(arg0, arg1);</p>
<p>0AA7: call_function_return 0x409E50 num_params 2 pop 2 [arg0] [arg1] func_ret [int]</p>
<p>define function CStreaming__GetNextFileOnCd&lt;cdecl, 0x409E50&gt;(arg0, arg1): int</p>
<h4>CStreaming::HasSpecialCharLoaded</h4>
<p>plugin::CallAndReturn<bool, 0x40ADC0, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x40ADC0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__HasSpecialCharLoaded&lt;cdecl, 0x40ADC0&gt;(modelIndex): int</p>
<h4>CStreaming::HaveAllBigBuildingsLoaded</h4>
<p>plugin::Call<0x408280, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x408280 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__HaveAllBigBuildingsLoaded&lt;cdecl, 0x408280&gt;(levelName)</p>
<h4>CStreaming::IHaveUsedStreamingMemory</h4>
<p>plugin::Call<0x409BD0>();</p>
<p>0AA5: call_function 0x409BD0 num_params 0 pop 0</p>
<p>define function CStreaming__IHaveUsedStreamingMemory&lt;cdecl, 0x409BD0&gt;()</p>
<h4>CStreaming::ImGonnaUseStreamingMemory</h4>
<p>plugin::Call<0x409BC0>();</p>
<p>0AA5: call_function 0x409BC0 num_params 0 pop 0</p>
<p>define function CStreaming__ImGonnaUseStreamingMemory&lt;cdecl, 0x409BC0&gt;()</p>
<h4>CStreaming::IsObjectInCdImage</h4>
<p>plugin::CallAndReturn<bool, 0x407E70, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x407E70 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__IsObjectInCdImage&lt;cdecl, 0x407E70&gt;(modelIndex): int</p>
<h4>CStreaming::LoadCdDirectory</h4>
<p>plugin::Call<0x406DA0, char const*, int>(archivename, archiveID);</p>
<p>0AA5: call_function 0x406DA0 num_params 2 pop 2 [archivename] [archiveID]</p>
<p>define function CStreaming__LoadCdDirectory&lt;cdecl, 0x406DA0&gt;(archivename, archiveID)</p>
<h4>CStreaming::LoadCdDirectory</h4>
<p>plugin::Call<0x406CC0>();</p>
<p>0AA5: call_function 0x406CC0 num_params 0 pop 0</p>
<p>define function CStreaming__LoadCdDirectory&lt;cdecl, 0x406CC0&gt;()</p>
<h4>CStreaming::LoadInitialPeds</h4>
<p>plugin::Call<0x40AA00>();</p>
<p>0AA5: call_function 0x40AA00 num_params 0 pop 0</p>
<p>define function CStreaming__LoadInitialPeds&lt;cdecl, 0x40AA00&gt;()</p>
<h4>CStreaming::LoadInitialVehicles</h4>
<p>plugin::Call<0x40ADF0>();</p>
<p>0AA5: call_function 0x40ADF0 num_params 0 pop 0</p>
<p>define function CStreaming__LoadInitialVehicles&lt;cdecl, 0x40ADF0&gt;()</p>
<h4>CStreaming::LoadScene</h4>
<p>plugin::Call<0x40A6D0, CVector const&>(point);</p>
<p>0AA5: call_function 0x40A6D0 num_params 1 pop 1 [point]</p>
<p>define function CStreaming__LoadScene&lt;cdecl, 0x40A6D0&gt;(point)</p>
<h4>CStreaming::MakeSpaceFor</h4>
<p>plugin::Call<0x409B70, int>(size);</p>
<p>0AA5: call_function 0x409B70 num_params 1 pop 1 [size]</p>
<p>define function CStreaming__MakeSpaceFor&lt;cdecl, 0x409B70&gt;(size)</p>
<h4>CStreaming::MemoryCardLoad</h4>
<p>plugin::Call<0x40B250, unsigned char*, unsigned int>(arg0, arg1);</p>
<p>0AA5: call_function 0x40B250 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CStreaming__MemoryCardLoad&lt;cdecl, 0x40B250&gt;(arg0, arg1)</p>
<h4>CStreaming::MemoryCardSave</h4>
<p>plugin::Call<0x40B210, unsigned char<em>, unsigned int</em>>(arg0, arg1);</p>
<p>0AA5: call_function 0x40B210 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CStreaming__MemoryCardSave&lt;cdecl, 0x40B210&gt;(arg0, arg1)</p>
<h4>CStreaming::ProcessEntitiesInSectorList</h4>
<p>plugin::Call<0x407DD0, CPtrList&>(list);</p>
<p>0AA5: call_function 0x407DD0 num_params 1 pop 1 [list]</p>
<p>define function CStreaming__ProcessEntitiesInSectorList&lt;cdecl, 0x407DD0&gt;(list)</p>
<h4>CStreaming::ProcessEntitiesInSectorList</h4>
<p>plugin::Call<0x407C50, CPtrList&, float, float, float, float, float, float>(list, x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x407C50 num_params 7 pop 7 [list] [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CStreaming__ProcessEntitiesInSectorList&lt;cdecl, 0x407C50&gt;(list, x1, y1, z1, x2, y2, z2)</p>
<h4>CStreaming::ProcessLoadingChannel</h4>
<p>plugin::CallAndReturn<bool, 0x409BE0, int>(channelindex);</p>
<p>0AA7: call_function_return 0x409BE0 num_params 1 pop 1 [channelindex] func_ret [bool]</p>
<p>define function CStreaming__ProcessLoadingChannel&lt;cdecl, 0x409BE0&gt;(channelindex): int</p>
<h4>CStreaming::RemoveBigBuildings</h4>
<p>plugin::Call<0x408680, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x408680 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RemoveBigBuildings&lt;cdecl, 0x408680&gt;(levelName)</p>
<h4>CStreaming::RemoveBuildings</h4>
<p>plugin::Call<0x4083D0, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x4083D0 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RemoveBuildings&lt;cdecl, 0x4083D0&gt;(levelName)</p>
<h4>CStreaming::RemoveIslandsNotUsed</h4>
<p>plugin::Call<0x408780, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x408780 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RemoveIslandsNotUsed&lt;cdecl, 0x408780&gt;(levelName)</p>
<h4>CStreaming::RemoveReferencedTxds</h4>
<p>plugin::CallAndReturn<bool, 0x409450, int>(arg0);</p>
<p>0AA7: call_function_return 0x409450 num_params 1 pop 1 [arg0] func_ret [bool]</p>
<p>define function CStreaming__RemoveReferencedTxds&lt;cdecl, 0x409450&gt;(arg0): int</p>
<h4>CStreaming::RemoveUnusedBigBuildings</h4>
<p>plugin::Call<0x408640, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x408640 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RemoveUnusedBigBuildings&lt;cdecl, 0x408640&gt;(levelName)</p>
<h4>CStreaming::RemoveUnusedBuildings</h4>
<p>plugin::Call<0x4083A0, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x4083A0 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RemoveUnusedBuildings&lt;cdecl, 0x4083A0&gt;(levelName)</p>
<h4>CStreaming::RequestBigBuildings</h4>
<p>plugin::Call<0x408190, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x408190 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RequestBigBuildings&lt;cdecl, 0x408190&gt;(levelName)</p>
<h4>CStreaming::RequestIslands</h4>
<p>plugin::Call<0x408210, eLevelName>(levelName);</p>
<p>0AA5: call_function 0x408210 num_params 1 pop 1 [levelName]</p>
<p>define function CStreaming__RequestIslands&lt;cdecl, 0x408210&gt;(levelName)</p>
<h4>CStreaming::RetryLoadFile</h4>
<p>plugin::Call<0x4077F0, int>(streamnum);</p>
<p>0AA5: call_function 0x4077F0 num_params 1 pop 1 [streamnum]</p>
<p>define function CStreaming__RetryLoadFile&lt;cdecl, 0x4077F0&gt;(streamnum)</p>
<h4>CStreaming::StreamZoneModels</h4>
<p>plugin::Call<0x40AA30, CVector const&>(point);</p>
<p>0AA5: call_function 0x40AA30 num_params 1 pop 1 [point]</p>
<p>define function CStreaming__StreamZoneModels&lt;cdecl, 0x40AA30&gt;(point)</p>
<h4>DeleteIsland</h4>
<p>plugin::Call<0x408740, CEntity*>(entity);</p>
<p>0AA5: call_function 0x408740 num_params 1 pop 1 [entity]</p>
<p>define function DeleteIsland&lt;cdecl, 0x408740&gt;(entity)</p><h3 id="plugin_iiigame_iiicstreaminginfocpp">plugin_III\game_III\CStreamingInfo.cpp</h3><h4>CStreamingInfo::AddToList</h4>
<p>plugin::CallMethod<0x406380, CStreamingInfo <em>, CStreamingInfo</em>>(this, listStart);</p>
<p>0AA6: call_method 0x406380 struct [CStreamingInfo] num_params 1 pop 0 [listStart]</p>
<p>define function CStreamingInfo__AddToList&lt;thiscall, 0x406380&gt;(listStart)</p>
<h4>CStreamingInfo::GetCdPosnAndSize</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4063E0, CStreamingInfo *, unsigned int&, unsigned int&>(this, posn, size);</p>
<p>0AA8: call_method_return 0x4063E0 struct [CStreamingInfo] num_params 2 pop 0 [posn] [size] func_ret [bool]</p>
<p>define function CStreamingInfo__GetCdPosnAndSize&lt;thiscall, 0x4063E0&gt;(posn, size): int</p>
<h4>CStreamingInfo::GetCdSize</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x4063D0, CStreamingInfo *>(this);</p>
<p>0AA8: call_method_return 0x4063D0 struct [CStreamingInfo] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CStreamingInfo__GetCdSize&lt;thiscall, 0x4063D0&gt;(): int</p>
<h4>CStreamingInfo::RemoveFromList</h4>
<p>plugin::CallMethod<0x4063A0, CStreamingInfo *>(this);</p>
<p>0AA6: call_method 0x4063A0 struct [CStreamingInfo] num_params 0 pop 0</p>
<p>define function CStreamingInfo__RemoveFromList&lt;thiscall, 0x4063A0&gt;()</p>
<h4>CStreamingInfo::SetCdPosnAndSize</h4>
<p>plugin::CallMethod<0x406410, CStreamingInfo *, unsigned int, unsigned int>(this, posn, size);</p>
<p>0AA6: call_method 0x406410 struct [CStreamingInfo] num_params 2 pop 0 [posn] [size]</p>
<p>define function CStreamingInfo__SetCdPosnAndSize&lt;thiscall, 0x406410&gt;(posn, size)</p><h3 id="plugin_iiigame_iiicstuckcarcheckcpp">plugin_III\game_III\CStuckCarCheck.cpp</h3><h4>CStuckCarCheck::AddCarToCheck</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *, int, float, unsigned int>(gaddrof(CStuckCarCheck::AddCarToCheck), this, id, radius, time);</p>
<p>0AA6: call_method 0x4381C0 struct [CStuckCarCheck] num_params 3 pop 0 [id] [radius] [time]</p>
<p>define function CStuckCarCheck__AddCarToCheck&lt;thiscall, 0x4381C0&gt;(id, radius, time)</p>
<h4>CStuckCarCheck::HasCarBeenStuckForAWhile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::HasCarBeenStuckForAWhile), this, id);</p>
<p>0AA8: call_method_return 0x4382A0 struct [CStuckCarCheck] num_params 1 pop 0 [id] func_ret [bool]</p>
<h4>CStuckCarCheck::Init</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Init), this);</p>
<p>0AA6: call_method 0x438050 struct [CStuckCarCheck] num_params 0 pop 0</p>
<p>define function CStuckCarCheck__Init&lt;thiscall, 0x438050&gt;()</p>
<h4>CStuckCarCheck::Process</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Process), this);</p>
<p>0AA6: call_method 0x4380A0 struct [CStuckCarCheck] num_params 0 pop 0</p>
<p>define function CStuckCarCheck__Process&lt;thiscall, 0x4380A0&gt;()</p>
<h4>CStuckCarCheck::RemoveCarFromCheck</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::RemoveCarFromCheck), this, id);</p>
<p>0AA6: call_method 0x438240 struct [CStuckCarCheck] num_params 1 pop 0 [id]</p>
<p>define function CStuckCarCheck__RemoveCarFromCheck&lt;thiscall, 0x438240&gt;(id)</p><h3 id="plugin_iiigame_iiicsurfacetablecpp">plugin_III\game_III\CSurfaceTable.cpp</h3><h4>CSurfaceTable::GetAdhesionGroup</h4>
<p>plugin::CallAndReturnDynGlobal<int, unsigned char>(gaddrof(CSurfaceTable::GetAdhesionGroup), surfaceType);</p>
<p>0AA7: call_function_return 0x4ABA60 num_params 1 pop 1 [surfaceType] func_ret [int]</p>
<p>define function CSurfaceTable__GetAdhesionGroup&lt;cdecl, 0x4ABA60&gt;(surfaceType): int</p>
<h4>CSurfaceTable::GetAdhesiveLimit</h4>
<p>plugin::CallAndReturnDynGlobal<float, CColPoint &>(gaddrof(CSurfaceTable::GetAdhesiveLimit), colPoint);</p>
<p>0AA7: call_function_return 0x4ABA30 num_params 1 pop 1 [colPoint] func_ret [float]</p>
<p>define function CSurfaceTable__GetAdhesiveLimit&lt;cdecl, 0x4ABA30&gt;(colPoint): float</p>
<h4>CSurfaceTable::GetWetMultiplier</h4>
<p>plugin::CallAndReturnDynGlobal<float, unsigned char>(gaddrof(CSurfaceTable::GetWetMultiplier), surfaceType);</p>
<p>0AA7: call_function_return 0x4ABAA0 num_params 1 pop 1 [surfaceType] func_ret [float]</p>
<p>define function CSurfaceTable__GetWetMultiplier&lt;cdecl, 0x4ABAA0&gt;(surfaceType): float</p>
<h4>CSurfaceTable::Initialise</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CSurfaceTable::Initialise), fileName);</p><h3 id="plugin_iiigame_iiictextcpp">plugin_III\game_III\CText.cpp</h3><h4>*CKeyArray::BinarySearch</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CKeyEntry *, CKeyArray *, char const *, CKeyEntry *, short, short>(gaddrof(CKeyArray::BinarySearch), this, key, entries, low, high);</p>
<p>0AA8: call_method_return 0x52C060 struct [*CKeyArray] num_params 4 pop 0 [key] [entries] [low] [high] func_ret [CKeyEntry *]</p>
<h4>CKeyArray::Load</h4>
<p>plugin::CallMethodDynGlobal<CKeyArray *, unsigned int, unsigned char *, unsigned int *>(gaddrof(CKeyArray::Load), this, length, data, offset);</p>
<p>0AA6: call_method 0x52BE70 struct [CKeyArray] num_params 3 pop 0 [length] [data] [offset]</p>
<p>define function CKeyArray__Load&lt;thiscall, 0x52BE70&gt;(length, data, offset)</p>
<h4>*CKeyArray::Search</h4>
<p>plugin::CallMethodAndReturnDynGlobal<wchar_t *, CKeyArray *, char const *>(gaddrof(CKeyArray::Search), this, key);</p>
<p>0AA8: call_method_return 0x52BFB0 struct [*CKeyArray] num_params 1 pop 0 [key] func_ret [wchar_t *]</p>
<h4>CKeyArray::Unload</h4>
<p>plugin::CallMethodDynGlobal<CKeyArray *>(gaddrof(CKeyArray::Unload), this);</p>
<p>0AA6: call_method 0x52BF60 struct [CKeyArray] num_params 0 pop 0</p>
<p>define function CKeyArray__Unload&lt;thiscall, 0x52BF60&gt;()</p>
<h4>CKeyArray::Update</h4>
<p>plugin::CallMethodDynGlobal<CKeyArray *, wchar_t *>(gaddrof(CKeyArray::Update), this, chars);</p>
<p>0AA6: call_method 0x52BF80 struct [CKeyArray] num_params 1 pop 0 [chars]</p>
<p>define function CKeyArray__Update&lt;thiscall, 0x52BF80&gt;(chars)</p>
<h4>CData::Load</h4>
<p>plugin::CallMethodDynGlobal<CData *, unsigned int, char *, int *>(gaddrof(CData::Load), this, length, data, offset);</p>
<p>0AA6: call_method 0x52C120 struct [CData] num_params 3 pop 0 [length] [data] [offset]</p>
<p>define function CData__Load&lt;thiscall, 0x52C120&gt;(length, data, offset)</p>
<h4>CData::Unload</h4>
<p>plugin::CallMethodDynGlobal<CData *>(gaddrof(CData::Unload), this);</p>
<p>0AA6: call_method 0x52C200 struct [CData] num_params 0 pop 0</p>
<p>define function CData__Unload&lt;thiscall, 0x52C200&gt;()</p>
<h4>*CText::Get</h4>
<p>plugin::CallMethodAndReturnDynGlobal<wchar_t *, CText *, char const *>(gaddrof(CText::Get), this, key);</p>
<p>0AA8: call_method_return 0x52C5A0 struct [*CText] num_params 1 pop 0 [key] func_ret [wchar_t *]</p>
<h4>CText::GetUpperCase</h4>
<p>plugin::CallMethodAndReturnDynGlobal<wchar_t, CText *, wchar_t>(gaddrof(CText::GetUpperCase), this, c);</p>
<p>0AA8: call_method_return 0x52C220 struct [CText] num_params 1 pop 0 [c] func_ret [wchar_t]</p>
<h4>CText::Load</h4>
<p>plugin::CallMethodDynGlobal<CText *>(gaddrof(CText::Load), this);</p>
<p>0AA6: call_method 0x52C3C0 struct [CText] num_params 0 pop 0</p>
<p>define function CText__Load&lt;thiscall, 0x52C3C0&gt;()</p>
<h4>CText::Unload</h4>
<p>plugin::CallMethodDynGlobal<CText *>(gaddrof(CText::Unload), this);</p>
<p>0AA6: call_method 0x52C580 struct [CText] num_params 0 pop 0</p>
<p>define function CText__Unload&lt;thiscall, 0x52C580&gt;()</p>
<h4>CText::UpperCase</h4>
<p>plugin::CallMethodDynGlobal<CText *, wchar_t *>(gaddrof(CText::UpperCase), this, s);</p>
<p>0AA6: call_method 0x52C2C0 struct [CText] num_params 1 pop 0 [s]</p>
<p>define function CText__UpperCase&lt;thiscall, 0x52C2C0&gt;(s)</p>
<h4>*UnicodeToAscii</h4>
<p>plugin::CallAndReturnDynGlobal<char *, wchar_t *>(gaddrof(UnicodeToAscii), src);</p>
<p>0AA7: call_function_return 0x52C2F0 num_params 1 pop 1 [src] func_ret [char *]</p>
<p>define function UnicodeToAscii&lt;cdecl, 0x52C2F0&gt;(src): int</p>
<h4>*UnicodeToAsciiForSaveLoad</h4>
<p>plugin::CallAndReturnDynGlobal<char *, wchar_t *>(gaddrof(UnicodeToAsciiForSaveLoad), src);</p>
<p>0AA7: call_function_return 0x52C340 num_params 1 pop 1 [src] func_ret [char *]</p>
<p>define function UnicodeToAsciiForSaveLoad&lt;cdecl, 0x52C340&gt;(src): int</p>
<h4>TextCopy</h4>
<p>plugin::CallDynGlobal<wchar_t *, wchar_t const *>(gaddrof(TextCopy), dst, src);</p><h3 id="plugin_iiigame_iiicthecargeneratorscpp">plugin_III\game_III\CTheCarGenerators.cpp</h3><h4>CTheCarGenerators::CreateCarGenerator</h4>
<p>plugin::CallAndReturnDynGlobal<int, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(gaddrof(CTheCarGenerators::CreateCarGenerator), x, y, z, angle, modelId, colorPrim, colorSec, forceSpawn, alarm, doorLock, minDelay, maxDelay);</p>
<p>0AA7: call_function_return 0x542FC0 num_params 12 pop 12 [x] [y] [z] [angle] [modelId] [colorPrim] [colorSec] [forceSpawn] [alarm] [doorLock] [minDelay] [maxDelay] func_ret [int]</p>
<p>define function CTheCarGenerators__CreateCarGenerator&lt;cdecl, 0x542FC0&gt;(x, y, z, angle, modelId, colorPrim, colorSec, forceSpawn, alarm, doorLock, minDelay, maxDelay): int</p>
<h4>CTheCarGenerators::LoadAllCarGenerators</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CTheCarGenerators::LoadAllCarGenerators), buffer, size);</p>
<h4>CTheCarGenerators::SaveAllCarGenerators</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CTheCarGenerators::SaveAllCarGenerators), buffer, size);</p><h3 id="plugin_iiigame_iiicthescriptscpp">plugin_III\game_III\CTheScripts.cpp</h3><h4>CTheScripts::Init</h4>
<p>plugin::Call<0x438790>();</p>
<p>0AA5: call_function 0x438790 num_params 0 pop 0</p>
<p>define function CTheScripts__Init&lt;cdecl, 0x438790&gt;()</p>
<h4>CTheScripts::IsPedStopped</h4>
<p>plugin::CallAndReturn<bool, 0x454670, CPed*>(ped);</p>
<p>0AA7: call_function_return 0x454670 num_params 1 pop 1 [ped] func_ret [bool]</p>
<p>define function CTheScripts__IsPedStopped&lt;cdecl, 0x454670&gt;(ped): int</p>
<h4>CTheScripts::IsPlayerOnAMission</h4>
<p>plugin::CallAndReturn<bool, 0x439410>();</p>
<p>0AA7: call_function_return 0x439410 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CTheScripts__IsPlayerOnAMission&lt;cdecl, 0x439410&gt;(): int</p>
<h4>CTheScripts::IsPlayerStopped</h4>
<p>plugin::CallAndReturn<bool, 0x4546C0, CPlayerInfo*>(info);</p>
<p>0AA7: call_function_return 0x4546C0 num_params 1 pop 1 [info] func_ret [bool]</p>
<p>define function CTheScripts__IsPlayerStopped&lt;cdecl, 0x4546C0&gt;(info): int</p>
<h4>CTheScripts::IsVehicleStopped</h4>
<p>plugin::CallAndReturn<bool, 0x454770, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x454770 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CTheScripts__IsVehicleStopped&lt;cdecl, 0x454770&gt;(vehicle): int</p>
<h4>CTheScripts::CleanUpThisPed</h4>
<p>plugin::Call<0x4547A0, CPed*>(ped);</p>
<p>0AA5: call_function 0x4547A0 num_params 1 pop 1 [ped]</p>
<p>define function CTheScripts__CleanUpThisPed&lt;cdecl, 0x4547A0&gt;(ped)</p>
<h4>CTheScripts::CleanUpThisObject</h4>
<p>plugin::Call<0x454910, CObject*>(object);</p>
<p>0AA5: call_function 0x454910 num_params 1 pop 1 [object]</p>
<p>define function CTheScripts__CleanUpThisObject&lt;cdecl, 0x454910&gt;(object)</p>
<h4>CTheScripts::CleanUpThisVehicle</h4>
<p>plugin::Call<0x4548D0, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x4548D0 num_params 1 pop 1 [vehicle]</p>
<p>define function CTheScripts__CleanUpThisVehicle&lt;cdecl, 0x4548D0&gt;(vehicle)</p>
<h4>CTheScripts::ClearSpaceForMissionEntity</h4>
<p>plugin::Call<0x454060, CVector const&, CEntity*>(position, entity);</p>
<p>0AA5: call_function 0x454060 num_params 2 pop 2 [position] [entity]</p>
<p>define function CTheScripts__ClearSpaceForMissionEntity&lt;cdecl, 0x454060&gt;(position, entity)</p><h3 id="plugin_iiigame_iiicthezonescpp">plugin_III\game_III\CTheZones.cpp</h3><h4>CTheZones::FindSmallestZonePosition</h4>
<p>plugin::CallAndReturn<CZone*, 0x4B69B0, CVector const&>(pos);</p>
<p>0AA7: call_function_return 0x4B69B0 num_params 1 pop 1 [pos] func_ret [CZone*]</p>
<p>define function CTheZones__FindSmallestZonePosition&lt;cdecl, 0x4B69B0&gt;(pos): int</p>
<h4>CTheZones::FindSmallestZonePositionType</h4>
<p>plugin::CallAndReturn<CZone*, 0x4B6790, CVector const&, int>(pos, type);</p>
<p>0AA7: call_function_return 0x4B6790 num_params 2 pop 2 [pos] [type] func_ret [CZone*]</p>
<p>define function CTheZones__FindSmallestZonePositionType&lt;cdecl, 0x4B6790&gt;(pos, type): int</p>
<h4>CTheZones::GetZoneInfo</h4>
<p>plugin::CallAndReturn<CZoneInfo*, 0x4B6A10, CVector const&, char>(pos, day);</p>
<p>0AA7: call_function_return 0x4B6A10 num_params 2 pop 2 [pos] [day] func_ret [CZoneInfo*]</p>
<p>define function CTheZones__GetZoneInfo&lt;cdecl, 0x4B6A10&gt;(pos, day): int</p><h3 id="plugin_iiigame_iiictimemodelinfocpp">plugin_III\game_III\CTimeModelInfo.cpp</h3><h4>*CTimeModelInfo::FindOtherTimeModel</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CTimeModelInfo *, CTimeModelInfo *>(gaddrof(CTimeModelInfo::FindOtherTimeModel), this);</p>
<p>0AA8: call_method_return 0x517C80 struct [*CTimeModelInfo] num_params 0 pop 0 func_ret [CTimeModelInfo *]</p><h3 id="plugin_iiigame_iiictimercpp">plugin_III\game_III\CTimer.cpp</h3><h4>CTimer::GetCurrentTimeInCycles</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CTimer::GetCurrentTimeInCycles));</p>
<p>0AA7: call_function_return 0x4AD410 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CTimer__GetCurrentTimeInCycles&lt;cdecl, 0x4AD410&gt;(): int</p>
<h4>CTimer::GetCyclesPerMillisecond</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CTimer::GetCyclesPerMillisecond));</p>
<p>0AA7: call_function_return 0x4AD3F0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CTimer__GetCyclesPerMillisecond&lt;cdecl, 0x4AD3F0&gt;(): int</p>
<h4>CTimer::GetIsSlowMotionActive</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTimer::GetIsSlowMotionActive));</p>
<p>0AA7: call_function_return 0x4AD450 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CTimer__GetIsSlowMotionActive&lt;cdecl, 0x4AD450&gt;(): int</p><h3 id="plugin_iiigame_iiictowerclockcpp">plugin_III\game_III\CTowerClock.cpp</h3><h4>CTowerClock::Init</h4>
<p>plugin::CallMethodDynGlobal<CTowerClock *, CVector, float, float, unsigned char, unsigned char, unsigned char, float, float>(gaddrof(CTowerClock::Init), this, pos, sizeX, sizeY, red, green, blue, drawDistance, scale);</p>
<p>0AA6: call_method 0x5000D0 struct [CTowerClock] num_params 8 pop 0 [pos] [sizeX] [sizeY] [red] [green] [blue] [drawDistance] [scale]</p>
<p>define function CTowerClock__Init&lt;thiscall, 0x5000D0&gt;(pos, sizeX, sizeY, red, green, blue, drawDistance, scale)</p>
<h4>CTowerClock::Render</h4>
<p>plugin::CallMethodDynGlobal<CTowerClock *>(gaddrof(CTowerClock::Render), this);</p>
<p>0AA6: call_method 0x5001D0 struct [CTowerClock] num_params 0 pop 0</p>
<p>define function CTowerClock__Render&lt;thiscall, 0x5001D0&gt;()</p>
<h4>CTowerClock::Update</h4>
<p>plugin::CallMethodDynGlobal<CTowerClock *>(gaddrof(CTowerClock::Update), this);</p>
<p>0AA6: call_method 0x500130 struct [CTowerClock] num_params 0 pop 0</p>
<p>define function CTowerClock__Update&lt;thiscall, 0x500130&gt;()</p><h3 id="plugin_iiigame_iiictrafficlightscpp">plugin_III\game_III\CTrafficLights.cpp</h3><h4>CTrafficLights::DisplayActualLight</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CTrafficLights::DisplayActualLight), entity);</p>
<h4>CTrafficLights::FindTrafficLightType</h4>
<p>plugin::CallAndReturnDynGlobal<int, CEntity *>(gaddrof(CTrafficLights::FindTrafficLightType), entity);</p>
<p>0AA7: call_function_return 0x4564A0 num_params 1 pop 1 [entity] func_ret [int]</p>
<p>define function CTrafficLights__FindTrafficLightType&lt;cdecl, 0x4564A0&gt;(entity): int</p>
<h4>CTrafficLights::LightForCars1</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForCars1));</p>
<p>0AA7: call_function_return 0x455760 num_params 0 pop 0 func_ret [unsigned char]</p>
<p>define function CTrafficLights__LightForCars1&lt;cdecl, 0x455760&gt;(): int</p>
<h4>CTrafficLights::LightForCars2</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForCars2));</p>
<p>0AA7: call_function_return 0x455790 num_params 0 pop 0 func_ret [unsigned char]</p>
<p>define function CTrafficLights__LightForCars2&lt;cdecl, 0x455790&gt;(): int</p>
<h4>CTrafficLights::LightForPeds</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char>(gaddrof(CTrafficLights::LightForPeds));</p>
<p>0AA7: call_function_return 0x4557D0 num_params 0 pop 0 func_ret [unsigned char]</p>
<p>define function CTrafficLights__LightForPeds&lt;cdecl, 0x4557D0&gt;(): int</p>
<h4>CTrafficLights::ShouldCarStopForBridge</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTrafficLights::ShouldCarStopForBridge), vehicle);</p>
<p>0AA7: call_function_return 0x456460 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CTrafficLights__ShouldCarStopForBridge&lt;cdecl, 0x456460&gt;(vehicle): int</p>
<h4>CTrafficLights::ShouldCarStopForLight</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *, bool>(gaddrof(CTrafficLights::ShouldCarStopForLight), vehicle, alwaysStop);</p>
<p>0AA7: call_function_return 0x455350 num_params 2 pop 2 [vehicle] [alwaysStop] func_ret [bool]</p>
<p>define function CTrafficLights__ShouldCarStopForLight&lt;cdecl, 0x455350&gt;(vehicle, alwaysStop): int</p><h3 id="plugin_iiigame_iiictraincpp">plugin_III\game_III\CTrain.cpp</h3><h4>CTrain::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CTrain *, unsigned int>(this, modelIndex);</p>
<h4>CTrain::ProcessControl</h4>
<p>plugin::CallVirtualMethod<8, CTrain *>(this);</p>
<h4>CTrain::PreRender</h4>
<p>plugin::CallVirtualMethod<12, CTrain *>(this);</p>
<h4>CTrain::Render</h4>
<p>plugin::CallVirtualMethod<13, CTrain *>(this);</p>
<h4>CTrain::AddPassenger</h4>
<p>plugin::CallMethodDynGlobal<CTrain *, CPed *>(gaddrof(CTrain::AddPassenger), this, passenger);</p>
<p>0AA6: call_method 0x5504A0 struct [CTrain] num_params 1 pop 0 [passenger]</p>
<p>define function CTrain__AddPassenger&lt;thiscall, 0x5504A0&gt;(passenger)</p>
<h4>CTrain::OpenTrainDoor</h4>
<p>plugin::CallMethodDynGlobal<CTrain *, float>(gaddrof(CTrain::OpenTrainDoor), this, angle);</p>
<p>0AA6: call_method 0x550360 struct [CTrain] num_params 1 pop 0 [angle]</p>
<p>define function CTrain__OpenTrainDoor&lt;thiscall, 0x550360&gt;(angle)</p>
<h4>CTrain::TrainHitStuff</h4>
<p>plugin::CallMethodDynGlobal<CTrain *, CPtrList &>(gaddrof(CTrain::TrainHitStuff), this, list);</p>
<p>0AA6: call_method 0x550300 struct [CTrain] num_params 1 pop 0 [list]</p>
<p>define function CTrain__TrainHitStuff&lt;thiscall, 0x550300&gt;(list)</p>
<h4>CTrain::ReadAndInterpretTrackFile</h4>
<p>plugin::CallDynGlobal<char const *, CTrainNode **, short *, int, float *, float *, float *, CTrainInterpolationLine *, bool>(gaddrof(CTrain::ReadAndInterpretTrackFile), filename, nodes, numNodes, numStations, stationDists, totalLength, totalDuration, line, rightRail);</p>
<h4>PlayAnnouncement</h4>
<p>plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(PlayAnnouncement), sound, station);</p><h3 id="plugin_iiigame_iiictraindoorcpp">plugin_III\game_III\CTrainDoor.cpp</h3><h4>CTrainDoor::IsClosed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CTrainDoor *>(gaddrof(CTrainDoor::IsClosed), this);</p>
<p>0AA8: call_method_return 0x5460F0 struct [CTrainDoor] num_params 0 pop 0 func_ret [bool]</p>
<h4>CTrainDoor::IsFullyOpen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CTrainDoor *>(gaddrof(CTrainDoor::IsFullyOpen), this);</p>
<p>0AA8: call_method_return 0x546120 struct [CTrainDoor] num_params 0 pop 0 func_ret [bool]</p>
<h4>CTrainDoor::Open</h4>
<p>plugin::CallMethodDynGlobal<CTrainDoor *, float>(gaddrof(CTrainDoor::Open), this, angle);</p>
<p>0AA6: call_method 0x546200 struct [CTrainDoor] num_params 1 pop 0 [angle]</p>
<p>define function CTrainDoor__Open&lt;thiscall, 0x546200&gt;(angle)</p>
<h4>CTrainDoor::RetTranslationWhenClosed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CTrainDoor *>(gaddrof(CTrainDoor::RetTranslationWhenClosed), this);</p>
<p>0AA8: call_method_return 0x546180 struct [CTrainDoor] num_params 0 pop 0 func_ret [float]</p>
<h4>CTrainDoor::RetTranslationWhenOpen</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CTrainDoor *>(gaddrof(CTrainDoor::RetTranslationWhenOpen), this);</p>
<p>0AA8: call_method_return 0x5461C0 struct [CTrainDoor] num_params 0 pop 0 func_ret [float]</p><h3 id="plugin_iiigame_iiictransmissioncpp">plugin_III\game_III\cTransmission.cpp</h3><h4>cTransmission::CalculateDriveAcceleration</h4>
<p>plugin::CallMethodAndReturn<float, 0x5506B0, cTransmission *, float const&, unsigned char&, float&, float const&, bool>(this, gasPedal, currrentGear, pSpeed, pCurrentSpeed, bCheat);</p>
<p>0AA8: call_method_return 0x5506B0 struct [cTransmission] num_params 5 pop 0 [gasPedal] [currrentGear] [pSpeed] [pCurrentSpeed] [bCheat] func_ret [float]</p>
<p>define function cTransmission__CalculateDriveAcceleration&lt;thiscall, 0x5506B0&gt;(gasPedal, currrentGear, pSpeed, pCurrentSpeed, bCheat): float</p>
<h4>cTransmission::CalculateGearForSimpleCar</h4>
<p>plugin::CallMethod<0x550A00, cTransmission *, float, unsigned char&>(this, velocity, currrentGear);</p>
<p>0AA6: call_method 0x550A00 struct [cTransmission] num_params 2 pop 0 [velocity] [currrentGear]</p>
<p>define function cTransmission__CalculateGearForSimpleCar&lt;thiscall, 0x550A00&gt;(velocity, currrentGear)</p>
<h4>cTransmission::InitGearRatios</h4>
<p>plugin::CallMethod<0x550590, cTransmission *>(this);</p>
<p>0AA6: call_method 0x550590 struct [cTransmission] num_params 0 pop 0</p>
<p>define function cTransmission__InitGearRatios&lt;thiscall, 0x550590&gt;()</p>
<h4>cTransmission::cTransmission</h4>
<p>plugin::CallMethod<0x550580, cTransmission *>(this);</p>
<p>0AA6: call_method 0x550580 struct [cTransmission] num_params 0 pop 0</p>
<p>define function cTransmission__cTransmission&lt;thiscall, 0x550580&gt;()</p><h3 id="plugin_iiigame_iiictreadablecpp">plugin_III\game_III\CTreadable.cpp</h3><h4>CTreadable::GetIsATreadable</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 17, CTreadable *>(this);</p><h3 id="plugin_iiigame_iiictxdstorecpp">plugin_III\game_III\CTxdStore.cpp</h3><h4>CTxdStore::Initialise</h4>
<p>plugin::Call<0x527440>();</p>
<p>0AA5: call_function 0x527440 num_params 0 pop 0</p>
<p>define function CTxdStore__Initialise&lt;cdecl, 0x527440&gt;()</p>
<h4>CTxdStore::Shutdown</h4>
<p>plugin::Call<0x527470>();</p>
<p>0AA5: call_function 0x527470 num_params 0 pop 0</p>
<p>define function CTxdStore__Shutdown&lt;cdecl, 0x527470&gt;()</p>
<h4>CTxdStore::GameShutdown</h4>
<p>plugin::Call<0x527490>();</p>
<p>0AA5: call_function 0x527490 num_params 0 pop 0</p>
<p>define function CTxdStore__GameShutdown&lt;cdecl, 0x527490&gt;()</p>
<h4>CTxdStore::AddTxdSlot</h4>
<p>plugin::CallAndReturn<int, 0x5274E0, char const*>(name);</p>
<p>0AA7: call_function_return 0x5274E0 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CTxdStore__AddTxdSlot&lt;cdecl, 0x5274E0&gt;(name): int</p>
<h4>CTxdStore::RemoveTxdSlot</h4>
<p>plugin::Call<0x527520, int>(id);</p>
<p>0AA5: call_function 0x527520 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__RemoveTxdSlot&lt;cdecl, 0x527520&gt;(id)</p>
<h4>CTxdStore::GetTxdName</h4>
<p>plugin::CallAndReturn<char*, 0x527590, int>(id);</p>
<p>0AA7: call_function_return 0x527590 num_params 1 pop 1 [id] func_ret [char*]</p>
<p>define function CTxdStore__GetTxdName&lt;cdecl, 0x527590&gt;(id): int</p>
<h4>CTxdStore::FindTxdSlot</h4>
<p>plugin::CallAndReturn<int, 0x5275D0, char const*>(name);</p>
<p>0AA7: call_function_return 0x5275D0 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CTxdStore__FindTxdSlot&lt;cdecl, 0x5275D0&gt;(name): int</p>
<h4>CTxdStore::LoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x5276B0, int, char const*>(id, name);</p>
<p>0AA7: call_function_return 0x5276B0 num_params 2 pop 2 [id] [name] func_ret [bool]</p>
<p>define function CTxdStore__LoadTxd&lt;cdecl, 0x5276B0&gt;(id, name): int</p>
<h4>CTxdStore::LoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x527700, int, RwStream*>(id, stream);</p>
<p>0AA7: call_function_return 0x527700 num_params 2 pop 2 [id] [stream] func_ret [bool]</p>
<p>define function CTxdStore__LoadTxd&lt;cdecl, 0x527700&gt;(id, stream): int</p>
<h4>CTxdStore::StartLoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x527770, int, RwStream*>(id, stream);</p>
<p>0AA7: call_function_return 0x527770 num_params 2 pop 2 [id] [stream] func_ret [bool]</p>
<p>define function CTxdStore__StartLoadTxd&lt;cdecl, 0x527770&gt;(id, stream): int</p>
<h4>CTxdStore::FinishLoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x5277E0, int, RwStream*>(id, stream);</p>
<p>0AA7: call_function_return 0x5277E0 num_params 2 pop 2 [id] [stream] func_ret [bool]</p>
<p>define function CTxdStore__FinishLoadTxd&lt;cdecl, 0x5277E0&gt;(id, stream): int</p>
<h4>CTxdStore::Create</h4>
<p>plugin::Call<0x527830, int>(id);</p>
<p>0AA5: call_function 0x527830 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__Create&lt;cdecl, 0x527830&gt;(id)</p>
<h4>CTxdStore::RemoveTxd</h4>
<p>plugin::Call<0x527870, int>(id);</p>
<p>0AA5: call_function 0x527870 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__RemoveTxd&lt;cdecl, 0x527870&gt;(id)</p>
<h4>CTxdStore::SetCurrentTxd</h4>
<p>plugin::Call<0x5278C0, int>(id);</p>
<p>0AA5: call_function 0x5278C0 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__SetCurrentTxd&lt;cdecl, 0x5278C0&gt;(id)</p>
<h4>CTxdStore::PushCurrentTxd</h4>
<p>plugin::Call<0x527900>();</p>
<p>0AA5: call_function 0x527900 num_params 0 pop 0</p>
<p>define function CTxdStore__PushCurrentTxd&lt;cdecl, 0x527900&gt;()</p>
<h4>CTxdStore::PopCurrentTxd</h4>
<p>plugin::Call<0x527910>();</p>
<p>0AA5: call_function 0x527910 num_params 0 pop 0</p>
<p>define function CTxdStore__PopCurrentTxd&lt;cdecl, 0x527910&gt;()</p>
<h4>CTxdStore::AddRef</h4>
<p>plugin::Call<0x527930, int>(id);</p>
<p>0AA5: call_function 0x527930 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__AddRef&lt;cdecl, 0x527930&gt;(id)</p>
<h4>CTxdStore::RemoveRef</h4>
<p>plugin::Call<0x527970, int>(id);</p>
<p>0AA5: call_function 0x527970 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__RemoveRef&lt;cdecl, 0x527970&gt;(id)</p>
<h4>CTxdStore::RemoveRefWithoutDelete</h4>
<p>plugin::Call<0x5279C0, int>(id);</p>
<p>0AA5: call_function 0x5279C0 num_params 1 pop 1 [id]</p>
<p>define function CTxdStore__RemoveRefWithoutDelete&lt;cdecl, 0x5279C0&gt;(id)</p>
<h4>CTxdStore::GetNumRefs</h4>
<p>plugin::CallAndReturn<int, 0x527A00, int>(id);</p>
<p>0AA7: call_function_return 0x527A00 num_params 1 pop 1 [id] func_ret [int]</p>
<p>define function CTxdStore__GetNumRefs&lt;cdecl, 0x527A00&gt;(id): int</p><h3 id="plugin_iiigame_iiicupsidedowncarcheckcpp">plugin_III\game_III\CUpsideDownCarCheck.cpp</h3><h4>CUpsideDownCarCheck::AddCarToCheck</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::AddCarToCheck), this, id);</p>
<p>0AA6: call_method 0x437FB0 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id]</p>
<p>define function CUpsideDownCarCheck__AddCarToCheck&lt;thiscall, 0x437FB0&gt;(id)</p>
<h4>CUpsideDownCarCheck::AreAnyCarsUpsideDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::AreAnyCarsUpsideDown), this);</p>
<p>0AA8: call_method_return 0x437F80 struct [CUpsideDownCarCheck] num_params 0 pop 0 func_ret [bool]</p>
<h4>CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile), this, id);</p>
<p>0AA8: call_method_return 0x438010 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id] func_ret [bool]</p>
<h4>CUpsideDownCarCheck::Init</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::Init), this);</p>
<p>0AA6: call_method 0x437DC0 struct [CUpsideDownCarCheck] num_params 0 pop 0</p>
<p>define function CUpsideDownCarCheck__Init&lt;thiscall, 0x437DC0&gt;()</p>
<h4>CUpsideDownCarCheck::IsCarUpsideDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::IsCarUpsideDown), this, id);</p>
<p>0AA8: call_method_return 0x437E10 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id] func_ret [bool]</p>
<h4>CUpsideDownCarCheck::RemoveCarFromCheck</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::RemoveCarFromCheck), this, id);</p>
<p>0AA6: call_method 0x437FE0 struct [CUpsideDownCarCheck] num_params 1 pop 0 [id]</p>
<p>define function CUpsideDownCarCheck__RemoveCarFromCheck&lt;thiscall, 0x437FE0&gt;(id)</p>
<h4>CUpsideDownCarCheck::UpdateTimers</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::UpdateTimers), this);</p>
<p>0AA6: call_method 0x437EE0 struct [CUpsideDownCarCheck] num_params 0 pop 0</p>
<p>define function CUpsideDownCarCheck__UpdateTimers&lt;thiscall, 0x437EE0&gt;()</p><h3 id="plugin_iiigame_iiicvehiclecpp">plugin_III\game_III\CVehicle.cpp</h3><h4>CVehicle::SetModelIndex</h4>
<p>plugin::CallVirtualMethod<3, CVehicle *, unsigned int>(this, modelIndex);</p>
<h4>CVehicle::SetupLighting</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 14, CVehicle *>(this);</p>
<h4>CVehicle::RemoveLighting</h4>
<p>plugin::CallVirtualMethod<15, CVehicle *, bool>(this, reset);</p>
<h4>CVehicle::FlagToDestroyWhenNextProcessed</h4>
<p>plugin::CallVirtualMethod<16, CVehicle *>(this);</p>
<h4>CVehicle::ProcessControlInputs</h4>
<p>plugin::CallVirtualMethod<18, CVehicle *, unsigned char>(this, padNumber);</p>
<h4>CVehicle::GetComponentWorldPosition</h4>
<p>plugin::CallVirtualMethod<19, CVehicle *, int, CVector &>(this, component, pos);</p>
<h4>CVehicle::IsComponentPresent</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 20, CVehicle *, int>(this, component);</p>
<h4>CVehicle::SetComponentRotation</h4>
<p>plugin::CallVirtualMethod<21, CVehicle *, int, CVector>(this, component, rotation);</p>
<h4>CVehicle::OpenDoor</h4>
<p>plugin::CallVirtualMethod<22, CVehicle *, int, eDoors, float>(this, component, door, angle);</p>
<h4>CVehicle::ProcessOpenDoor</h4>
<p>plugin::CallVirtualMethod<23, CVehicle *, unsigned int, unsigned int, float>(this, component, anim, angle);</p>
<h4>CVehicle::IsDoorReady</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 24, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorFullyOpen</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 25, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorClosed</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 26, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorMissing</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 27, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::RemoveRefsToVehicle</h4>
<p>plugin::CallVirtualMethod<28, CVehicle *, CEntity *>(this, entity);</p>
<h4>CVehicle::BlowUpCar</h4>
<p>plugin::CallVirtualMethod<29, CVehicle *, CEntity *>(this, entity);</p>
<h4>CVehicle::SetUpWheelColModel</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 30, CVehicle *, CColModel *>(this, colModel);</p>
<h4>CVehicle::BurstTyre</h4>
<p>plugin::CallVirtualMethod<31, CVehicle *, unsigned char>(this, wheel);</p>
<h4>CVehicle::IsRoomForPedToLeaveCar</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 32, CVehicle *, unsigned int, CVector *>(this, component, doorOffset);</p>
<h4>CVehicle::GetHeightAboveRoad</h4>
<p>plugin::CallVirtualMethodAndReturn<float, 33, CVehicle *>(this);</p>
<h4>CVehicle::PlayCarHorn</h4>
<p>plugin::CallVirtualMethod<34, CVehicle *>(this);</p>
<h4>CVehicle::AddPassenger</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *>(gaddrof_o(CVehicle::AddPassenger, bool (CVehicle::*)(CPed *)), this, passenger);</p>
<p>0AA8: call_method_return 0x551E10 struct [CVehicle] num_params 1 pop 0 [passenger] func_ret [bool]</p>
<h4>CVehicle::AddPassenger</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *, unsigned char>(gaddrof_o(CVehicle::AddPassenger, bool (CVehicle::*)(CPed *, unsigned char)), this, passenger, number);</p>
<p>0AA8: call_method_return 0x551E10 struct [CVehicle] num_params 2 pop 0 [passenger] [number] func_ret [bool]</p>
<h4>CVehicle::CanBeDeleted</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanBeDeleted), this);</p>
<p>0AA8: call_method_return 0x5511B0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::CanPedEnterCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanPedEnterCar), this);</p>
<p>0AA8: call_method_return 0x5522F0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::CanPedExitCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CanPedExitCar), this);</p>
<p>0AA8: call_method_return 0x5523C0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::CanPedOpenLocks</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, CPed *>(gaddrof(CVehicle::CanPedOpenLocks), this, ped);</p>
<p>0AA8: call_method_return 0x5522A0 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CVehicle::CarHasRoof</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::CarHasRoof), this);</p>
<p>0AA8: call_method_return 0x552B70 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::ChangeLawEnforcerState</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *, unsigned char>(gaddrof(CVehicle::ChangeLawEnforcerState), this, enable);</p>
<p>0AA6: call_method 0x552820 struct [CVehicle] num_params 1 pop 0 [enable]</p>
<p>define function CVehicle__ChangeLawEnforcerState&lt;thiscall, 0x552820&gt;(enable)</p>
<h4>CVehicle::DoFixedMachineGuns</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::DoFixedMachineGuns), this);</p>
<p>0AA6: call_method 0x564300 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__DoFixedMachineGuns&lt;thiscall, 0x564300&gt;()</p>
<h4>CVehicle::ExtinguishCarFire</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ExtinguishCarFire), this);</p>
<p>0AA6: call_method 0x552AF0 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ExtinguishCarFire&lt;thiscall, 0x552AF0&gt;()</p>
<h4>CVehicle::FlyingControl</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *, eFlightModel>(gaddrof(CVehicle::FlyingControl), this, flightModel);</p>
<p>0AA6: call_method 0x552BB0 struct [CVehicle] num_params 1 pop 0 [flightModel]</p>
<p>define function CVehicle__FlyingControl&lt;thiscall, 0x552BB0&gt;(flightModel)</p>
<h4>CVehicle::InflictDamage</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *, CEntity *, eWeaponType, float>(gaddrof(CVehicle::InflictDamage), this, entity, weaponType, damage);</p>
<p>0AA6: call_method 0x551950 struct [CVehicle] num_params 3 pop 0 [entity] [weaponType] [damage]</p>
<p>define function CVehicle__InflictDamage&lt;thiscall, 0x551950&gt;(entity, weaponType, damage)</p>
<h4>CVehicle::IsLawEnforcementVehicle</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsLawEnforcementVehicle), this);</p>
<p>0AA8: call_method_return 0x552880 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::IsOnItsSide</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsOnItsSide), this);</p>
<p>0AA8: call_method_return 0x552260 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::IsSphereTouchingVehicle</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, float, float, float, float>(gaddrof(CVehicle::IsSphereTouchingVehicle), this, x, y, z, radius);</p>
<p>0AA8: call_method_return 0x552620 struct [CVehicle] num_params 4 pop 0 [x] [y] [z] [radius] func_ret [bool]</p>
<h4>CVehicle::IsUpsideDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsUpsideDown), this);</p>
<p>0AA8: call_method_return 0x552230 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::IsVehicleNormal</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::IsVehicleNormal), this);</p>
<p>0AA8: call_method_return 0x5527E0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::ProcessCarAlarm</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ProcessCarAlarm), this);</p>
<p>0AA6: call_method 0x5525A0 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ProcessCarAlarm&lt;thiscall, 0x5525A0&gt;()</p>
<h4>CVehicle::ProcessDelayedExplosion</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::ProcessDelayedExplosion), this);</p>
<p>0AA6: call_method 0x551C90 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ProcessDelayedExplosion&lt;thiscall, 0x551C90&gt;()</p>
<h4>CVehicle::ProcessWheel</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *, CVector &, CVector &, CVector &, CVector &, int, float, float, float, char, float *, tWheelState *, unsigned short>(gaddrof(CVehicle::ProcessWheel), this, wheelFwd, wheelRight, wheelContactSpeed, wheelContactPoint, wheelsOnGround, thrust, brake, adhesion, wheelId, wheelSpeed, wheelState, wheelStatus);</p>
<p>0AA6: call_method 0x5512E0 struct [CVehicle] num_params 12 pop 0 [wheelFwd] [wheelRight] [wheelContactSpeed] [wheelContactPoint] [wheelsOnGround] [thrust] [brake] [adhesion] [wheelId] [wheelSpeed] [wheelState] [wheelStatus]</p>
<p>define function CVehicle__ProcessWheel&lt;thiscall, 0x5512E0&gt;(wheelFwd, wheelRight, wheelContactSpeed, wheelContactPoint, wheelsOnGround, thrust, brake, adhesion, wheelId, wheelSpeed, wheelState, wheelStatus)</p>
<h4>CVehicle::ProcessWheelRotation</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CVehicle *, tWheelState, CVector const &, CVector const &, float>(gaddrof(CVehicle::ProcessWheelRotation), this, state, fwd, speed, radius);</p>
<p>0AA8: call_method_return 0x551280 struct [CVehicle] num_params 4 pop 0 [state] [fwd] [speed] [radius] func_ret [float]</p>
<h4>CVehicle::RemoveDriver</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *>(gaddrof(CVehicle::RemoveDriver), this);</p>
<p>0AA6: call_method 0x5520A0 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__RemoveDriver&lt;thiscall, 0x5520A0&gt;()</p>
<h4>CVehicle::RemovePassenger</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *, CPed *>(gaddrof(CVehicle::RemovePassenger), this, passenger);</p>
<p>0AA6: call_method 0x551EB0 struct [CVehicle] num_params 1 pop 0 [passenger]</p>
<p>define function CVehicle__RemovePassenger&lt;thiscall, 0x551EB0&gt;(passenger)</p>
<h4>CVehicle::SetDriver</h4>
<p>plugin::CallMethodDynGlobal<CVehicle *, CPed *>(gaddrof(CVehicle::SetDriver), this, driver);</p>
<p>0AA6: call_method 0x551F20 struct [CVehicle] num_params 1 pop 0 [driver]</p>
<p>define function CVehicle__SetDriver&lt;thiscall, 0x551F20&gt;(driver)</p>
<h4>*CVehicle::SetUpDriver</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CVehicle *>(gaddrof(CVehicle::SetUpDriver), this);</p>
<p>0AA8: call_method_return 0x5520C0 struct [*CVehicle] num_params 0 pop 0 func_ret [CPed *]</p>
<h4>*CVehicle::SetupPassenger</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CVehicle *, int>(gaddrof(CVehicle::SetupPassenger), this, number);</p>
<p>0AA8: call_method_return 0x552160 struct [*CVehicle] num_params 1 pop 0 [number] func_ret [CPed *]</p>
<h4>CVehicle::ShufflePassengersToMakeSpace</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CVehicle::ShufflePassengersToMakeSpace), this);</p>
<p>0AA8: call_method_return 0x5528A0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<h4>CVehicle::UsesSiren</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CVehicle *, unsigned int>(gaddrof(CVehicle::UsesSiren), this, vehicleModel);</p>
<p>0AA8: call_method_return 0x552200 struct [CVehicle] num_params 1 pop 0 [vehicleModel] func_ret [bool]</p>
<h4>DestroyVehicleAndDriverAndPassengers</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(DestroyVehicleAndDriverAndPassengers), vehicle);</p><h3 id="plugin_iiigame_iiicvehiclemodelinfocpp">plugin_III\game_III\CVehicleModelInfo.cpp</h3><h4>CVehicleModelInfo::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<2, CVehicleModelInfo *>(this);</p>
<h4>*CVehicleModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 3, CVehicleModelInfo *>(this);</p>
<h4>CVehicleModelInfo::SetClump</h4>
<p>plugin::CallVirtualMethod<6, CVehicleModelInfo *, RpClump *>(this, clump);</p>
<h4>CVehicleModelInfo::AvoidSameVehicleColour</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char *, unsigned char *>(gaddrof(CVehicleModelInfo::AvoidSameVehicleColour), this, prim, sec);</p>
<p>0AA6: call_method 0x5210A0 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]</p>
<p>define function CVehicleModelInfo__AvoidSameVehicleColour&lt;thiscall, 0x5210A0&gt;(prim, sec)</p>
<h4>CVehicleModelInfo::ChooseComponent</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::ChooseComponent), this);</p>
<p>0AA8: call_method_return 0x520AB0 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]</p>
<h4>CVehicleModelInfo::ChooseSecondComponent</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::ChooseSecondComponent), this);</p>
<p>0AA8: call_method_return 0x520BE0 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]</p>
<h4>CVehicleModelInfo::ChooseVehicleColour</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char *, unsigned char *>(gaddrof(CVehicleModelInfo::ChooseVehicleColour), this, prim, sec);</p>
<p>0AA6: call_method 0x520FD0 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]</p>
<p>define function CVehicleModelInfo__ChooseVehicleColour&lt;thiscall, 0x520FD0&gt;(prim, sec)</p>
<h4>CVehicleModelInfo::FindEditableMaterialList</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::FindEditableMaterialList), this);</p>
<p>0AA6: call_method 0x520DE0 struct [CVehicleModelInfo] num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__FindEditableMaterialList&lt;thiscall, 0x520DE0&gt;()</p>
<h4>CVehicleModelInfo::GetWheelPosn</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *, int, CVector &>(gaddrof(CVehicleModelInfo::GetWheelPosn), this, wheel, outPos);</p>
<p>0AA6: call_method 0x520840 struct [CVehicleModelInfo] num_params 2 pop 0 [wheel] [outPos]</p>
<p>define function CVehicleModelInfo__GetWheelPosn&lt;thiscall, 0x520840&gt;(wheel, outPos)</p>
<h4>CVehicleModelInfo::PreprocessHierarchy</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::PreprocessHierarchy), this);</p>
<p>0AA6: call_method 0x5204D0 struct [CVehicleModelInfo] num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__PreprocessHierarchy&lt;thiscall, 0x5204D0&gt;()</p>
<h4>CVehicleModelInfo::SetAtomicRenderCallbacks</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::SetAtomicRenderCallbacks), this);</p>
<p>0AA6: call_method 0x5202C0 struct [CVehicleModelInfo] num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__SetAtomicRenderCallbacks&lt;thiscall, 0x5202C0&gt;()</p>
<h4>CVehicleModelInfo::SetEnvironmentMap</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *>(gaddrof(CVehicleModelInfo::SetEnvironmentMap), this);</p>
<p>0AA6: call_method 0x521890 struct [CVehicleModelInfo] num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__SetEnvironmentMap&lt;thiscall, 0x521890&gt;()</p>
<h4>CVehicleModelInfo::SetVehicleColour</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *, unsigned char, unsigned char>(gaddrof(CVehicleModelInfo::SetVehicleColour), this, prim, sec);</p>
<p>0AA6: call_method 0x520E70 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]</p>
<p>define function CVehicleModelInfo__SetVehicleColour&lt;thiscall, 0x520E70&gt;(prim, sec)</p>
<h4>CVehicleModelInfo::SetVehicleComponentFlags</h4>
<p>plugin::CallMethodDynGlobal<CVehicleModelInfo *, RwFrame *, unsigned int>(gaddrof(CVehicleModelInfo::SetVehicleComponentFlags), this, frame, flags);</p>
<p>0AA6: call_method 0x5203C0 struct [CVehicleModelInfo] num_params 2 pop 0 [frame] [flags]</p>
<p>define function CVehicleModelInfo__SetVehicleComponentFlags&lt;thiscall, 0x5203C0&gt;(frame, flags)</p>
<h4>*CVehicleModelInfo::ClearAtomicFlagCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::ClearAtomicFlagCB), object, data);</p>
<p>0AA7: call_function_return 0x520360 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function CVehicleModelInfo__ClearAtomicFlagCB&lt;cdecl, 0x520360&gt;(object, data): int</p>
<h4>*CVehicleModelInfo::CollapseFramesCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(CVehicleModelInfo::CollapseFramesCB), frame, data);</p>
<p>0AA7: call_function_return 0x51FE10 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function CVehicleModelInfo__CollapseFramesCB&lt;cdecl, 0x51FE10&gt;(frame, data): int</p>
<h4>*CVehicleModelInfo::GetEditableMaterialListCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof_o(CVehicleModelInfo::GetEditableMaterialListCB, RpMaterial <em>(</em>)(RpMaterial *, void *)), material, data);</p>
<p>0AA7: call_function_return 0x520DC0 num_params 2 pop 2 [material] [data] func_ret [RpMaterial *]</p>
<p>define function CVehicleModelInfo__GetEditableMaterialListCB&lt;cdecl, 0x520DC0&gt;(material, data): int</p>
<h4>*CVehicleModelInfo::GetEditableMaterialListCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof_o(CVehicleModelInfo::GetEditableMaterialListCB, RpAtomic <em>(</em>)(RpAtomic *, void *)), atomic, data);</p>
<p>0AA7: call_function_return 0x520DC0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__GetEditableMaterialListCB&lt;cdecl, 0x520DC0&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors), modelIndex);</p>
<p>0AA7: call_function_return 0x5219D0 num_params 1 pop 1 [modelIndex] func_ret [int]</p>
<p>define function CVehicleModelInfo__GetMaximumNumberOfPassengersFromNumberOfDoors&lt;cdecl, 0x5219D0&gt;(modelIndex): int</p>
<h4>*CVehicleModelInfo::HasAlphaMaterialCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(CVehicleModelInfo::HasAlphaMaterialCB), material, data);</p>
<p>0AA7: call_function_return 0x51FEF0 num_params 2 pop 2 [material] [data] func_ret [RpMaterial *]</p>
<p>define function CVehicleModelInfo__HasAlphaMaterialCB&lt;cdecl, 0x51FEF0&gt;(material, data): int</p>
<h4>*CVehicleModelInfo::HasSpecularMaterialCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(CVehicleModelInfo::HasSpecularMaterialCB), material, data);</p>
<p>0AA7: call_function_return 0x521770 num_params 2 pop 2 [material] [data] func_ret [RpMaterial *]</p>
<p>define function CVehicleModelInfo__HasSpecularMaterialCB&lt;cdecl, 0x521770&gt;(material, data): int</p>
<h4>*CVehicleModelInfo::HideAllComponentsAtomicCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::HideAllComponentsAtomicCB), atomic, data);</p>
<p>0AA7: call_function_return 0x51FED0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__HideAllComponentsAtomicCB&lt;cdecl, 0x51FED0&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::HideDamagedAtomicCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::HideDamagedAtomicCB), atomic, data);</p>
<p>0AA7: call_function_return 0x51FE70 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__HideDamagedAtomicCB&lt;cdecl, 0x51FE70&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::MoveObjectsCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::MoveObjectsCB), object, data);</p>
<p>0AA7: call_function_return 0x51FE50 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function CVehicleModelInfo__MoveObjectsCB&lt;cdecl, 0x51FE50&gt;(object, data): int</p>
<h4>*CVehicleModelInfo::SetAtomicFlagCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(CVehicleModelInfo::SetAtomicFlagCB), object, data);</p>
<p>0AA7: call_function_return 0x520340 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function CVehicleModelInfo__SetAtomicFlagCB&lt;cdecl, 0x520340&gt;(object, data): int</p>
<h4>*CVehicleModelInfo::SetAtomicRendererCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB), atomic, data);</p>
<p>0AA7: call_function_return 0x51FF10 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB&lt;cdecl, 0x51FF10&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::SetAtomicRendererCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_BigVehicle), atomic, data);</p>
<p>0AA7: call_function_return 0x520030 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_BigVehicle&lt;cdecl, 0x520030&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::SetAtomicRendererCB_Boat</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Boat), atomic, data);</p>
<p>0AA7: call_function_return 0x520120 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_Boat&lt;cdecl, 0x520120&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::SetAtomicRendererCB_Heli</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Heli), atomic, data);</p>
<p>0AA7: call_function_return 0x520210 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_Heli&lt;cdecl, 0x520210&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::SetAtomicRendererCB_Train</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CVehicleModelInfo::SetAtomicRendererCB_Train), atomic, data);</p>
<p>0AA7: call_function_return 0x520230 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_Train&lt;cdecl, 0x520230&gt;(atomic, data): int</p>
<h4>*CVehicleModelInfo::SetEnvironmentMapCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof_o(CVehicleModelInfo::SetEnvironmentMapCB, RpMaterial <em>(</em>)(RpMaterial *, void *)), material, data);</p>
<p>0AA7: call_function_return 0x521820 num_params 2 pop 2 [material] [data] func_ret [RpMaterial *]</p>
<p>define function CVehicleModelInfo__SetEnvironmentMapCB&lt;cdecl, 0x521820&gt;(material, data): int</p>
<h4>*CVehicleModelInfo::SetEnvironmentMapCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof_o(CVehicleModelInfo::SetEnvironmentMapCB, RpAtomic <em>(</em>)(RpAtomic *, void *)), atomic, data);</p>
<p>0AA7: call_function_return 0x521820 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CVehicleModelInfo__SetEnvironmentMapCB&lt;cdecl, 0x521820&gt;(atomic, data): int</p>
<h4>*GetOkAndDamagedAtomicCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwObject *, RwObject *, void *>(gaddrof(GetOkAndDamagedAtomicCB), object, data);</p>
<p>0AA7: call_function_return 0x520380 num_params 2 pop 2 [object] [data] func_ret [RwObject *]</p>
<p>define function GetOkAndDamagedAtomicCB&lt;cdecl, 0x520380&gt;(object, data): int</p>
<h4>IsValidCompRule</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(IsValidCompRule), rule);</p>
<p>0AA7: call_function_return 0x520880 num_params 1 pop 1 [rule] func_ret [bool]</p>
<p>define function IsValidCompRule&lt;cdecl, 0x520880&gt;(rule): int</p>
<h4>GetListOfComponentsNotUsedByRules</h4>
<p>plugin::CallAndReturnDynGlobal<int, unsigned int, int, int *>(gaddrof(GetListOfComponentsNotUsedByRules), compRulesBits, numExtras, variationsList);</p>
<p>0AA7: call_function_return 0x5208C0 num_params 3 pop 3 [compRulesBits] [numExtras] [variationsList] func_ret [int]</p>
<p>define function GetListOfComponentsNotUsedByRules&lt;cdecl, 0x5208C0&gt;(compRulesBits, numExtras, variationsList): int</p>
<h4>CountCompsInRule</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CountCompsInRule), compRulesBits);</p>
<p>0AA7: call_function_return 0x520990 num_params 1 pop 1 [compRulesBits] func_ret [int]</p>
<p>define function CountCompsInRule&lt;cdecl, 0x520990&gt;(compRulesBits): int</p>
<h4>ChooseComponent</h4>
<p>plugin::CallAndReturnDynGlobal<int, int, int>(gaddrof(ChooseComponent), rule, compRulesBits);</p>
<p>0AA7: call_function_return 0x5209C0 num_params 2 pop 2 [rule] [compRulesBits] func_ret [int]</p>
<p>define function ChooseComponent&lt;cdecl, 0x5209C0&gt;(rule, compRulesBits): int</p>
<h4>*CreateCarColourTexture</h4>
<p>plugin::CallAndReturnDynGlobal<RwTexture *, unsigned char, unsigned char, unsigned char>(gaddrof(CreateCarColourTexture), red, green, blue);</p>
<p>0AA7: call_function_return 0x521160 num_params 3 pop 3 [red] [green] [blue] func_ret [RwTexture *]</p>
<p>define function CreateCarColourTexture&lt;cdecl, 0x521160&gt;(red, green, blue): int</p><h3 id="plugin_iiigame_iiicvisibilitypluginscpp">plugin_III\game_III\CVisibilityPlugins.cpp</h3><h4>*CVisibilityPlugins::AtomicConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicConstructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527CC0 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__AtomicConstructor&lt;cdecl, 0x527CC0&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*CVisibilityPlugins::AtomicCopyConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527CE0 num_params 4 pop 4 [dstObject] [srcObject] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__AtomicCopyConstructor&lt;cdecl, 0x527CE0&gt;(dstObject, srcObject, offsetInObject, sizeInObject): int</p>
<h4>*CVisibilityPlugins::AtomicDestructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::AtomicDestructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527D00 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__AtomicDestructor&lt;cdecl, 0x527D00&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>CVisibilityPlugins::ClearAtomicFlag</h4>
<p>plugin::CallDynGlobal<RpAtomic *, int>(gaddrof(CVisibilityPlugins::ClearAtomicFlag), atomic, flag);</p>
<h4>*CVisibilityPlugins::ClumpConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpConstructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527D60 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__ClumpConstructor&lt;cdecl, 0x527D60&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*CVisibilityPlugins::ClumpCopyConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527D90 num_params 4 pop 4 [dstObject] [srcObject] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__ClumpCopyConstructor&lt;cdecl, 0x527D90&gt;(dstObject, srcObject, offsetInObject, sizeInObject): int</p>
<h4>*CVisibilityPlugins::ClumpDestructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::ClumpDestructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527DB0 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__ClumpDestructor&lt;cdecl, 0x527DB0&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>CVisibilityPlugins::DefaultVisibilityCB</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::DefaultVisibilityCB), clump);</p>
<p>0AA7: call_function_return 0x528D90 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__DefaultVisibilityCB&lt;cdecl, 0x528D90&gt;(clump): int</p>
<h4>*CVisibilityPlugins::FrameConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameConstructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527D10 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__FrameConstructor&lt;cdecl, 0x527D10&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*CVisibilityPlugins::FrameCopyConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameCopyConstructor), dstObject, srcObject, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527D30 num_params 4 pop 4 [dstObject] [srcObject] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__FrameCopyConstructor&lt;cdecl, 0x527D30&gt;(dstObject, srcObject, offsetInObject, sizeInObject): int</p>
<h4>*CVisibilityPlugins::FrameDestructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(CVisibilityPlugins::FrameDestructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527D50 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function CVisibilityPlugins__FrameDestructor&lt;cdecl, 0x527D50&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>CVisibilityPlugins::FrustumSphereCB</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::FrustumSphereCB), clump);</p>
<p>0AA7: call_function_return 0x528DA0 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__FrustumSphereCB&lt;cdecl, 0x528DA0&gt;(clump): int</p>
<h4>CVisibilityPlugins::GetAtomicId</h4>
<p>plugin::CallAndReturnDynGlobal<int, RpAtomic *>(gaddrof(CVisibilityPlugins::GetAtomicId), atomic);</p>
<p>0AA7: call_function_return 0x527F50 num_params 1 pop 1 [atomic] func_ret [int]</p>
<p>define function CVisibilityPlugins__GetAtomicId&lt;cdecl, 0x527F50&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::GetAtomicModelInfo</h4>
<p>plugin::CallAndReturnDynGlobal<CSimpleModelInfo *, RpAtomic *>(gaddrof(CVisibilityPlugins::GetAtomicModelInfo), atomic);</p>
<p>0AA7: call_function_return 0x527F00 num_params 1 pop 1 [atomic] func_ret [CSimpleModelInfo *]</p>
<p>define function CVisibilityPlugins__GetAtomicModelInfo&lt;cdecl, 0x527F00&gt;(atomic): int</p>
<h4>CVisibilityPlugins::GetClumpAlpha</h4>
<p>plugin::CallAndReturnDynGlobal<int, RpClump *>(gaddrof(CVisibilityPlugins::GetClumpAlpha), clump);</p>
<p>0AA7: call_function_return 0x528F70 num_params 1 pop 1 [clump] func_ret [int]</p>
<p>define function CVisibilityPlugins__GetClumpAlpha&lt;cdecl, 0x528F70&gt;(clump): int</p>
<h4>CVisibilityPlugins::GetDistanceSquaredFromCamera</h4>
<p>plugin::CallAndReturnDynGlobal<float, RwFrame *>(gaddrof(CVisibilityPlugins::GetDistanceSquaredFromCamera), frame);</p>
<p>0AA7: call_function_return 0x529120 num_params 1 pop 1 [frame] func_ret [float]</p>
<p>define function CVisibilityPlugins__GetDistanceSquaredFromCamera&lt;cdecl, 0x529120&gt;(frame): float</p>
<h4>CVisibilityPlugins::GetDotProductWithCameraVector</h4>
<p>plugin::CallAndReturnDynGlobal<float, RwMatrix *, RwMatrix *, unsigned int>(gaddrof(CVisibilityPlugins::GetDotProductWithCameraVector), atomicMat, clumpMat, flag);</p>
<p>0AA7: call_function_return 0x5282A0 num_params 3 pop 3 [atomicMat] [clumpMat] [flag] func_ret [float]</p>
<p>define function CVisibilityPlugins__GetDotProductWithCameraVector&lt;cdecl, 0x5282A0&gt;(atomicMat, clumpMat, flag): float</p>
<h4>CVisibilityPlugins::GetFrameHierarchyId</h4>
<p>plugin::CallAndReturnDynGlobal<int, RwFrame *>(gaddrof(CVisibilityPlugins::GetFrameHierarchyId), frame);</p>
<p>0AA7: call_function_return 0x528D80 num_params 1 pop 1 [frame] func_ret [int]</p>
<p>define function CVisibilityPlugins__GetFrameHierarchyId&lt;cdecl, 0x528D80&gt;(frame): int</p>
<h4>CVisibilityPlugins::InsertAtomicIntoSortedList</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpAtomic *, float>(gaddrof(CVisibilityPlugins::InsertAtomicIntoSortedList), atomic, dist);</p>
<p>0AA7: call_function_return 0x528FA0 num_params 2 pop 2 [atomic] [dist] func_ret [bool]</p>
<p>define function CVisibilityPlugins__InsertAtomicIntoSortedList&lt;cdecl, 0x528FA0&gt;(atomic, dist): int</p>
<h4>CVisibilityPlugins::InsertEntityIntoSortedList</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CEntity *, float>(gaddrof(CVisibilityPlugins::InsertEntityIntoSortedList), entity, dist);</p>
<p>0AA7: call_function_return 0x528FF0 num_params 2 pop 2 [entity] [dist] func_ret [bool]</p>
<p>define function CVisibilityPlugins__InsertEntityIntoSortedList&lt;cdecl, 0x528FF0&gt;(entity, dist): int</p>
<h4>CVisibilityPlugins::MloVisibilityCB</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::MloVisibilityCB), clump);</p>
<p>0AA7: call_function_return 0x528E20 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__MloVisibilityCB&lt;cdecl, 0x528E20&gt;(clump): int</p>
<h4>CVisibilityPlugins::PluginAttach</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CVisibilityPlugins::PluginAttach));</p>
<p>0AA7: call_function_return 0x527DC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVisibilityPlugins__PluginAttach&lt;cdecl, 0x527DC0&gt;(): int</p>
<h4>*CVisibilityPlugins::RenderAlphaAtomic</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, int>(gaddrof(CVisibilityPlugins::RenderAlphaAtomic), atomic, alpha);</p>
<p>0AA7: call_function_return 0x5280B0 num_params 2 pop 2 [atomic] [alpha] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderAlphaAtomic&lt;cdecl, 0x5280B0&gt;(atomic, alpha): int</p>
<h4>*CVisibilityPlugins::RenderFadingAtomic</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, float>(gaddrof(CVisibilityPlugins::RenderFadingAtomic), atomic, camdist);</p>
<p>0AA7: call_function_return 0x528100 num_params 2 pop 2 [atomic] [camdist] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderFadingAtomic&lt;cdecl, 0x528100&gt;(atomic, camdist): int</p>
<h4>*CVisibilityPlugins::RenderObjAlwaysAtomic</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderObjAlwaysAtomic), atomic);</p>
<p>0AA7: call_function_return 0x528000 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderObjAlwaysAtomic&lt;cdecl, 0x528000&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderPedHiDetailCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPedHiDetailCB), atomic);</p>
<p>0AA7: call_function_return 0x528BC0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderPedHiDetailCB&lt;cdecl, 0x528BC0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderPedLowDetailCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPedLowDetailCB), atomic);</p>
<p>0AA7: call_function_return 0x528B60 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderPedLowDetailCB&lt;cdecl, 0x528B60&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderPlayerCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderPlayerCB), atomic);</p>
<p>0AA7: call_function_return 0x528B30 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderPlayerCB&lt;cdecl, 0x528B30&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderTrainHiDetailAlphaCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderTrainHiDetailAlphaCB), atomic);</p>
<p>0AA7: call_function_return 0x5286A0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderTrainHiDetailAlphaCB&lt;cdecl, 0x5286A0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderTrainHiDetailCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderTrainHiDetailCB), atomic);</p>
<p>0AA7: call_function_return 0x5285D0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderTrainHiDetailCB&lt;cdecl, 0x5285D0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleHiDetailAlphaCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailAlphaCB), atomic);</p>
<p>0AA7: call_function_return 0x5284B0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailAlphaCB&lt;cdecl, 0x5284B0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle), atomic);</p>
<p>0AA7: call_function_return 0x528A10 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailAlphaCB_BigVehicle&lt;cdecl, 0x528A10&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleHiDetailCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB), atomic);</p>
<p>0AA7: call_function_return 0x5283E0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailCB&lt;cdecl, 0x5283E0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle), atomic);</p>
<p>0AA7: call_function_return 0x5288A0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailCB_BigVehicle&lt;cdecl, 0x5288A0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleHiDetailCB_Boat</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleHiDetailCB_Boat), atomic);</p>
<p>0AA7: call_function_return 0x528AD0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailCB_Boat&lt;cdecl, 0x528AD0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleLowDetailAlphaCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleLowDetailAlphaCB_BigVehicle), atomic);</p>
<p>0AA7: call_function_return 0x528940 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleLowDetailAlphaCB_BigVehicle&lt;cdecl, 0x528940&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleLowDetailCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleLowDetailCB_BigVehicle), atomic);</p>
<p>0AA7: call_function_return 0x5287F0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleLowDetailCB_BigVehicle&lt;cdecl, 0x5287F0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleReallyLowDetailCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleReallyLowDetailCB), atomic);</p>
<p>0AA7: call_function_return 0x528240 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleReallyLowDetailCB&lt;cdecl, 0x528240&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle), atomic);</p>
<p>0AA7: call_function_return 0x5287B0 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderVehicleReallyLowDetailCB_BigVehicle&lt;cdecl, 0x5287B0&gt;(atomic): int</p>
<h4>*CVisibilityPlugins::RenderWheelAtomicCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *>(gaddrof(CVisibilityPlugins::RenderWheelAtomicCB), atomic);</p>
<p>0AA7: call_function_return 0x527F70 num_params 1 pop 1 [atomic] func_ret [RpAtomic *]</p>
<p>define function CVisibilityPlugins__RenderWheelAtomicCB&lt;cdecl, 0x527F70&gt;(atomic): int</p>
<h4>CVisibilityPlugins::SetAtomicFlag</h4>
<p>plugin::CallDynGlobal<RpAtomic *, int>(gaddrof(CVisibilityPlugins::SetAtomicFlag), atomic, flag);</p>
<h4>CVisibilityPlugins::SetAtomicModelInfo</h4>
<p>plugin::CallDynGlobal<RpAtomic *, CSimpleModelInfo *>(gaddrof(CVisibilityPlugins::SetAtomicModelInfo), atomic, info);</p>
<h4>CVisibilityPlugins::SetAtomicRenderCallback</h4>
<p>plugin::CallDynGlobal<RpAtomic *, RpAtomic *(*)(RpAtomic *)>(gaddrof(CVisibilityPlugins::SetAtomicRenderCallback), atomic, f);</p>
<h4>CVisibilityPlugins::SetClumpAlpha</h4>
<p>plugin::CallDynGlobal<RpClump *, int>(gaddrof(CVisibilityPlugins::SetClumpAlpha), clump, alpha);</p>
<h4>CVisibilityPlugins::SetClumpModelInfo</h4>
<p>plugin::CallDynGlobal<RpClump *, CClumpModelInfo *>(gaddrof(CVisibilityPlugins::SetClumpModelInfo), clump, info);</p>
<h4>CVisibilityPlugins::SetFrameHierarchyId</h4>
<p>plugin::CallDynGlobal<RwFrame *, int>(gaddrof(CVisibilityPlugins::SetFrameHierarchyId), frame, id);</p>
<h4>CVisibilityPlugins::SetRenderWareCamera</h4>
<p>plugin::CallDynGlobal<RwCamera *>(gaddrof(CVisibilityPlugins::SetRenderWareCamera), camera);</p>
<h4>CVisibilityPlugins::VehicleVisibilityCB</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::VehicleVisibilityCB), clump);</p>
<p>0AA7: call_function_return 0x528E80 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__VehicleVisibilityCB&lt;cdecl, 0x528E80&gt;(clump): int</p>
<h4>CVisibilityPlugins::VehicleVisibilityCB_BigVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(CVisibilityPlugins::VehicleVisibilityCB_BigVehicle), clump);</p>
<p>0AA7: call_function_return 0x528EC0 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__VehicleVisibilityCB_BigVehicle&lt;cdecl, 0x528EC0&gt;(clump): int</p>
<h4>*SetAlphaCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(SetAlphaCB), material, data);</p>
<p>0AA7: call_function_return 0x527F60 num_params 2 pop 2 [material] [data] func_ret [RpMaterial *]</p>
<p>define function SetAlphaCB&lt;cdecl, 0x527F60&gt;(material, data): int</p>
<h4>*SetTextureCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpMaterial *, RpMaterial *, void *>(gaddrof(SetTextureCB), material, data);</p>
<p>0AA7: call_function_return 0x528B10 num_params 2 pop 2 [material] [data] func_ret [RpMaterial *]</p>
<p>define function SetTextureCB&lt;cdecl, 0x528B10&gt;(material, data): int</p><h3 id="plugin_iiigame_iiicwantedcpp">plugin_III\game_III\CWanted.cpp</h3><h4>CCrimeBeingQd::operator=</h4>
<p>plugin::CallMethodDynGlobal<CCrimeBeingQd *, CCrimeBeingQd const &>(gaddrof_o(CCrimeBeingQd::operator=, void (CCrimeBeingQd::*)(CCrimeBeingQd const &amp;)), this, right);</p>
<p>0AA6: call_method 0x5966A0 struct [CCrimeBeingQd] num_params 1 pop 0 [right]</p>
<p>define function CCrimeBeingQd__operator=&lt;thiscall, 0x5966A0&gt;(right)</p>
<h4>CWanted::AddCrimeToQ</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWanted *, eCrimeType, int, CVector const &, bool, bool>(gaddrof(CWanted::AddCrimeToQ), this, crimeType, crimeId, pos, bAlreadyReported, bPoliceDontReallyCare);</p>
<p>0AA8: call_method_return 0x4ADFD0 struct [CWanted] num_params 5 pop 0 [crimeType] [crimeId] [pos] [bAlreadyReported] [bPoliceDontReallyCare] func_ret [bool]</p>
<h4>CWanted::AreArmyRequired</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreArmyRequired), this);</p>
<p>0AA8: call_method_return 0x4ADBE0 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<h4>CWanted::AreFbiRequired</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreFbiRequired), this);</p>
<p>0AA8: call_method_return 0x4ADBC0 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<h4>CWanted::AreSwatRequired</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWanted *>(gaddrof(CWanted::AreSwatRequired), this);</p>
<p>0AA8: call_method_return 0x4ADBA0 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<h4>CWanted::ClearQdCrimes</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::ClearQdCrimes), this);</p>
<p>0AA6: call_method 0x4ADF20 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__ClearQdCrimes&lt;thiscall, 0x4ADF20&gt;()</p>
<h4>CWanted::Initialise</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Initialise), this);</p>
<p>0AA6: call_method 0x4AD6E0 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Initialise&lt;thiscall, 0x4AD6E0&gt;()</p>
<h4>CWanted::NumOfHelisRequired</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CWanted *>(gaddrof(CWanted::NumOfHelisRequired), this);</p>
<p>0AA8: call_method_return 0x4ADC00 struct [CWanted] num_params 0 pop 0 func_ret [int]</p>
<h4>CWanted::RegisterCrime</h4>
<p>plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, unsigned int, bool>(gaddrof(CWanted::RegisterCrime), this, crimeType, pos, crimeId, bPoliceDontReallyCare);</p>
<p>0AA6: call_method 0x4AD9F0 struct [CWanted] num_params 4 pop 0 [crimeType] [pos] [crimeId] [bPoliceDontReallyCare]</p>
<p>define function CWanted__RegisterCrime&lt;thiscall, 0x4AD9F0&gt;(crimeType, pos, crimeId, bPoliceDontReallyCare)</p>
<h4>CWanted::RegisterCrime_Immediately</h4>
<p>plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, unsigned int, bool>(gaddrof(CWanted::RegisterCrime_Immediately), this, crimeType, pos, crimeId, bPoliceDontReallyCare);</p>
<p>0AA6: call_method 0x4ADA10 struct [CWanted] num_params 4 pop 0 [crimeType] [pos] [crimeId] [bPoliceDontReallyCare]</p>
<p>define function CWanted__RegisterCrime_Immediately&lt;thiscall, 0x4ADA10&gt;(crimeType, pos, crimeId, bPoliceDontReallyCare)</p>
<h4>CWanted::ReportCrimeNow</h4>
<p>plugin::CallMethodDynGlobal<CWanted *, eCrimeType, CVector const &, bool>(gaddrof(CWanted::ReportCrimeNow), this, crimeType, pos, bPoliceDontReallyCare);</p>
<p>0AA6: call_method 0x4AE110 struct [CWanted] num_params 3 pop 0 [crimeType] [pos] [bPoliceDontReallyCare]</p>
<p>define function CWanted__ReportCrimeNow&lt;thiscall, 0x4AE110&gt;(crimeType, pos, bPoliceDontReallyCare)</p>
<h4>CWanted::Reset</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Reset), this);</p>
<p>0AA6: call_method 0x4AD790 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Reset&lt;thiscall, 0x4AD790&gt;()</p>
<h4>CWanted::ResetPolicePursuit</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::ResetPolicePursuit), this);</p>
<p>0AA6: call_method 0x4ADC40 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__ResetPolicePursuit&lt;thiscall, 0x4ADC40&gt;()</p>
<h4>CWanted::SetWantedLevel</h4>
<p>plugin::CallMethodDynGlobal<CWanted *, int>(gaddrof(CWanted::SetWantedLevel), this, level);</p>
<p>0AA6: call_method 0x4ADA50 struct [CWanted] num_params 1 pop 0 [level]</p>
<p>define function CWanted__SetWantedLevel&lt;thiscall, 0x4ADA50&gt;(level)</p>
<h4>CWanted::SetWantedLevelNoDrop</h4>
<p>plugin::CallMethodDynGlobal<CWanted *, int>(gaddrof(CWanted::SetWantedLevelNoDrop), this, level);</p>
<p>0AA6: call_method 0x4ADAC0 struct [CWanted] num_params 1 pop 0 [level]</p>
<p>define function CWanted__SetWantedLevelNoDrop&lt;thiscall, 0x4ADAC0&gt;(level)</p>
<h4>CWanted::Update</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::Update), this);</p>
<p>0AA6: call_method 0x4AD7B0 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Update&lt;thiscall, 0x4AD7B0&gt;()</p>
<h4>CWanted::UpdateCrimesQ</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::UpdateCrimesQ), this);</p>
<p>0AA6: call_method 0x4AE090 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__UpdateCrimesQ&lt;thiscall, 0x4AE090&gt;()</p>
<h4>CWanted::UpdateWantedLevel</h4>
<p>plugin::CallMethodDynGlobal<CWanted *>(gaddrof(CWanted::UpdateWantedLevel), this);</p>
<p>0AA6: call_method 0x4AD900 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__UpdateWantedLevel&lt;thiscall, 0x4AD900&gt;()</p>
<h4>CWanted::SetMaximumWantedLevel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CWanted::SetMaximumWantedLevel), level);</p>
<h4>CWanted::WorkOutPolicePresence</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector, float>(gaddrof(CWanted::WorkOutPolicePresence), pos, radius);</p>
<p>0AA7: call_function_return 0x4ADD00 num_params 2 pop 2 [pos] [radius] func_ret [int]</p>
<p>define function CWanted__WorkOutPolicePresence&lt;cdecl, 0x4ADD00&gt;(pos, radius): int</p><h3 id="plugin_iiigame_iiicwatercannoncpp">plugin_III\game_III\CWaterCannon.cpp</h3><h4>CWaterCannon::Init</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::Init), this);</p>
<p>0AA6: call_method 0x521A30 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__Init&lt;thiscall, 0x521A30&gt;()</p>
<h4>CWaterCannon::PushPeds</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::PushPeds), this);</p>
<p>0AA6: call_method 0x5220B0 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__PushPeds&lt;thiscall, 0x5220B0&gt;()</p>
<h4>CWaterCannon::Render</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *>(gaddrof(CWaterCannon::Render), this);</p>
<p>0AA6: call_method 0x521D30 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__Render&lt;thiscall, 0x521D30&gt;()</p>
<h4>CWaterCannon::Update_NewInput</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *, CVector *, CVector *>(gaddrof(CWaterCannon::Update_NewInput), this, pos, dir);</p>
<p>0AA6: call_method 0x521CC0 struct [CWaterCannon] num_params 2 pop 0 [pos] [dir]</p>
<p>define function CWaterCannon__Update_NewInput&lt;thiscall, 0x521CC0&gt;(pos, dir)</p>
<h4>CWaterCannon::Update_OncePerFrame</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *, short>(gaddrof(CWaterCannon::Update_OncePerFrame), this, index);</p>
<p>0AA6: call_method 0x521B80 struct [CWaterCannon] num_params 1 pop 0 [index]</p>
<p>define function CWaterCannon__Update_OncePerFrame&lt;thiscall, 0x521B80&gt;(index)</p><h3 id="plugin_iiigame_iiicwatercannonscpp">plugin_III\game_III\CWaterCannons.cpp</h3><h4>CWaterCannons::UpdateOne</h4>
<p>plugin::CallDynGlobal<unsigned int, CVector *, CVector *>(gaddrof(CWaterCannons::UpdateOne), id, pos, dir);</p><h3 id="plugin_iiigame_iiicweaponcpp">plugin_III\game_III\CWeapon.cpp</h3><h4>CWeapon::AddGunshell</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *, CEntity *, CVector const &, CVector2D const &, float>(gaddrof(CWeapon::AddGunshell), this, shooter, source, direction, size);</p>
<p>0AA6: call_method 0x55F770 struct [CWeapon] num_params 4 pop 0 [shooter] [source] [direction] [size]</p>
<p>define function CWeapon__AddGunshell&lt;thiscall, 0x55F770&gt;(shooter, source, direction, size)</p>
<h4>CWeapon::DoBulletImpact</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *, CEntity *, CEntity *, CVector *, CVector *, CColPoint *, CVector2D>(gaddrof(CWeapon::DoBulletImpact), this, shooter, victim, source, target, colPoint, ahead);</p>
<p>0AA6: call_method 0x55F950 struct [CWeapon] num_params 6 pop 0 [shooter] [victim] [source] [target] [colPoint] [ahead]</p>
<p>define function CWeapon__DoBulletImpact&lt;thiscall, 0x55F950&gt;(shooter, victim, source, target, colPoint, ahead)</p>
<h4>CWeapon::Fire</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::Fire), this, shooter, fireSource);</p>
<p>0AA8: call_method_return 0x55C380 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]</p>
<h4>CWeapon::FireAreaEffect</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireAreaEffect), this, shooter, fireSource);</p>
<p>0AA8: call_method_return 0x561E00 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]</p>
<h4>CWeapon::FireFromCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CAutomobile *, bool>(gaddrof(CWeapon::FireFromCar), this, shooter, left);</p>
<p>0AA8: call_method_return 0x55C940 struct [CWeapon] num_params 2 pop 0 [shooter] [left] func_ret [bool]</p>
<h4>CWeapon::FireInstantHit</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireInstantHit), this, shooter, fireSource);</p>
<p>0AA8: call_method_return 0x55D2E0 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]</p>
<h4>CWeapon::FireInstantHitFromCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CAutomobile *, bool>(gaddrof(CWeapon::FireInstantHitFromCar), this, shooter, left);</p>
<p>0AA8: call_method_return 0x5624D0 struct [CWeapon] num_params 2 pop 0 [shooter] [left] func_ret [bool]</p>
<h4>CWeapon::FireM16_1stPerson</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *>(gaddrof(CWeapon::FireM16_1stPerson), this, shooter);</p>
<p>0AA8: call_method_return 0x562180 struct [CWeapon] num_params 1 pop 0 [shooter] func_ret [bool]</p>
<h4>CWeapon::FireMelee</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector &>(gaddrof(CWeapon::FireMelee), this, shooter, fireSource);</p>
<p>0AA8: call_method_return 0x55CA20 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]</p>
<h4>CWeapon::FireProjectile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *, float>(gaddrof(CWeapon::FireProjectile), this, shooter, fireSource, power);</p>
<p>0AA8: call_method_return 0x561900 struct [CWeapon] num_params 3 pop 0 [shooter] [fireSource] [power] func_ret [bool]</p>
<h4>CWeapon::FireShotgun</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *>(gaddrof(CWeapon::FireShotgun), this, shooter, fireSource);</p>
<p>0AA8: call_method_return 0x560620 struct [CWeapon] num_params 2 pop 0 [shooter] [fireSource] func_ret [bool]</p>
<h4>CWeapon::FireSniper</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *>(gaddrof(CWeapon::FireSniper), this, shooter);</p>
<p>0AA8: call_method_return 0x561FE0 struct [CWeapon] num_params 1 pop 0 [shooter] func_ret [bool]</p>
<h4>CWeapon::HasWeaponAmmoToBeUsed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::HasWeaponAmmoToBeUsed), this);</p>
<p>0AA8: call_method_return 0x564B80 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<h4>CWeapon::HitsGround</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *, CEntity *, CVector *, CEntity *>(gaddrof(CWeapon::HitsGround), this, holder, fireSource, aimingTo);</p>
<p>0AA8: call_method_return 0x564890 struct [CWeapon] num_params 3 pop 0 [holder] [fireSource] [aimingTo] func_ret [bool]</p>
<h4>CWeapon::Initialise</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *, eWeaponType, int>(gaddrof(CWeapon::Initialise), this, type, ammo);</p>
<p>0AA6: call_method 0x55C330 struct [CWeapon] num_params 2 pop 0 [type] [ammo]</p>
<p>define function CWeapon__Initialise&lt;thiscall, 0x55C330&gt;(type, ammo)</p>
<h4>CWeapon::IsType2Handed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::IsType2Handed), this);</p>
<p>0AA8: call_method_return 0x563FD0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<h4>CWeapon::IsTypeMelee</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CWeapon *>(gaddrof(CWeapon::IsTypeMelee), this);</p>
<p>0AA8: call_method_return 0x563FB0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<h4>CWeapon::Reload</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(gaddrof(CWeapon::Reload), this);</p>
<p>0AA6: call_method 0x5639D0 struct [CWeapon] num_params 0 pop 0</p>
<p>define function CWeapon__Reload&lt;thiscall, 0x5639D0&gt;()</p>
<h4>CWeapon::Update</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *, int>(gaddrof(CWeapon::Update), this, audioEntity);</p>
<p>0AA6: call_method 0x563A10 struct [CWeapon] num_params 1 pop 0 [audioEntity]</p>
<p>define function CWeapon__Update&lt;thiscall, 0x563A10&gt;(audioEntity)</p>
<h4>CWeapon::BlowUpExplosiveThings</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CWeapon::BlowUpExplosiveThings), thing);</p>
<h4>CWeapon::DoDoomAiming</h4>
<p>plugin::CallDynGlobal<CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoDoomAiming), shooter, source, target);</p>
<h4>CWeapon::DoDriveByAutoAiming</h4>
<p>plugin::CallDynGlobal<CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoDriveByAutoAiming), shooter, source, target);</p>
<h4>CWeapon::DoTankDoomAiming</h4>
<p>plugin::CallDynGlobal<CEntity *, CEntity *, CVector *, CVector *>(gaddrof(CWeapon::DoTankDoomAiming), shooter, driver, source, target);</p>
<h4>CWeapon::GenerateFlameThrowerParticles</h4>
<p>plugin::CallDynGlobal<CVector, CVector>(gaddrof(CWeapon::GenerateFlameThrowerParticles), pos, dir);</p>
<h4>CWeapon::MakePedsJumpAtShot</h4>
<p>plugin::CallDynGlobal<CPhysical *, CVector *, CVector *>(gaddrof(CWeapon::MakePedsJumpAtShot), shooter, source, target);</p>
<h4>CWeapon::ProcessLineOfSight</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector const &, CVector const &, CColPoint &, CEntity **, eWeaponType, CEntity *, bool, bool, bool, bool, bool, bool, bool>(gaddrof(CWeapon::ProcessLineOfSight), origin, target, point, outEntity, type, entity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x564C00 num_params 13 pop 13 [origin] [target] [point] [outEntity] [type] [entity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWeapon__ProcessLineOfSight&lt;cdecl, 0x564C00&gt;(origin, target, point, outEntity, type, entity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>FireOneInstantHitRound</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *, int>(gaddrof(FireOneInstantHitRound), source, target, damage);</p><h3 id="plugin_iiigame_iiicweaponeffectscpp">plugin_III\game_III\CWeaponEffects.cpp</h3><h4>CWeaponEffects::CWeaponEffects</h4>
<p>plugin::CallMethod<0x564C40, CWeaponEffects *>(this);</p>
<p>0AA6: call_method 0x564C40 struct [CWeaponEffects] num_params 0 pop 0</p>
<p>define function CWeaponEffects__CWeaponEffects&lt;thiscall, 0x564C40&gt;()</p>
<h4>CWeaponEffects::ClearCrossHair</h4>
<p>plugin::Call<0x564D60>();</p>
<p>0AA5: call_function 0x564D60 num_params 0 pop 0</p>
<p>define function CWeaponEffects__ClearCrossHair&lt;cdecl, 0x564D60&gt;()</p>
<h4>CWeaponEffects::Init</h4>
<p>plugin::Call<0x564C60>();</p>
<p>0AA5: call_function 0x564C60 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Init&lt;cdecl, 0x564C60&gt;()</p>
<h4>CWeaponEffects::MarkTarget</h4>
<p>plugin::Call<0x564D00, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float>(pos, red, green, blue, alpha, size);</p>
<p>0AA5: call_function 0x564D00 num_params 6 pop 6 [pos] [red] [green] [blue] [alpha] [size]</p>
<p>define function CWeaponEffects__MarkTarget&lt;cdecl, 0x564D00&gt;(pos, red, green, blue, alpha, size)</p>
<h4>CWeaponEffects::Render</h4>
<p>plugin::Call<0x564D70>();</p>
<p>0AA5: call_function 0x564D70 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Render&lt;cdecl, 0x564D70&gt;()</p>
<h4>CWeaponEffects::Shutdown</h4>
<p>plugin::Call<0x564CF0>();</p>
<p>0AA5: call_function 0x564CF0 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Shutdown&lt;cdecl, 0x564CF0&gt;()</p>
<h4>CWeaponEffects::~CWeaponEffects</h4>
<p>plugin::CallMethod<0x564C50, CWeaponEffects *>(this);</p>
<p>0AA6: call_method 0x564C50 struct [CWeaponEffects] num_params 0 pop 0</p>
<p>define function CWeaponEffects__~CWeaponEffects&lt;thiscall, 0x564C50&gt;()</p><h3 id="plugin_iiigame_iiicweaponinfocpp">plugin_III\game_III\CWeaponInfo.cpp</h3><h4>CWeaponInfo::CWeaponInfo</h4>
<p>plugin::CallMethod<0x5654F0, CWeaponInfo *>(this);</p>
<p>0AA6: call_method 0x5654F0 struct [CWeaponInfo] num_params 0 pop 0</p>
<p>define function CWeaponInfo__CWeaponInfo&lt;thiscall, 0x5654F0&gt;()</p>
<h4>CWeaponInfo::GetWeaponInfo</h4>
<p>plugin::CallAndReturn<CWeaponInfo*, 0x564FD0, eWeaponType>(weaponType);</p>
<p>0AA7: call_function_return 0x564FD0 num_params 1 pop 1 [weaponType] func_ret [CWeaponInfo*]</p>
<p>define function CWeaponInfo__GetWeaponInfo&lt;cdecl, 0x564FD0&gt;(weaponType): int</p>
<h4>CWeaponInfo::Initialise</h4>
<p>plugin::Call<0x564EA0>();</p>
<p>0AA5: call_function 0x564EA0 num_params 0 pop 0</p>
<p>define function CWeaponInfo__Initialise&lt;cdecl, 0x564EA0&gt;()</p>
<h4>CWeaponInfo::LoadWeaponData</h4>
<p>plugin::Call<0x564FE0>();</p>
<p>0AA5: call_function 0x564FE0 num_params 0 pop 0</p>
<p>define function CWeaponInfo__LoadWeaponData&lt;cdecl, 0x564FE0&gt;()</p>
<h4>CWeaponInfo::Shutdown</h4>
<p>plugin::Call<0x564FB0>();</p>
<p>0AA5: call_function 0x564FB0 num_params 0 pop 0</p>
<p>define function CWeaponInfo__Shutdown&lt;cdecl, 0x564FB0&gt;()</p>
<h4>CWeaponInfo::~CWeaponInfo</h4>
<p>plugin::CallMethod<0x5654E0, CWeaponInfo *>(this);</p>
<p>0AA6: call_method 0x5654E0 struct [CWeaponInfo] num_params 0 pop 0</p>
<p>define function CWeaponInfo__~CWeaponInfo&lt;thiscall, 0x5654E0&gt;()</p><h3 id="plugin_iiigame_iiicweathercpp">plugin_III\game_III\CWeather.cpp</h3><h4>CWeather::ForceWeather</h4>
<p>plugin::CallDynGlobal<short>(gaddrof(CWeather::ForceWeather), weather);</p>
<h4>CWeather::ForceWeatherNow</h4>
<p>plugin::CallDynGlobal<short>(gaddrof(CWeather::ForceWeatherNow), weather);</p>
<h4>RenderOneRainStreak</h4>
<p>plugin::CallDynGlobal<CVector, CVector, int, bool, float>(gaddrof(RenderOneRainStreak), pos, unused, intensity, scale, distance);</p><h3 id="plugin_iiigame_iiicworldcpp">plugin_III\game_III\CWorld.cpp</h3><h4>CWorld::Add</h4>
<p>plugin::Call<0x4AE930, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4AE930 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__Add&lt;cdecl, 0x4AE930&gt;(entity)</p>
<h4>CWorld::AddParticles</h4>
<p>plugin::Call<0x4B4010>();</p>
<p>0AA5: call_function 0x4B4010 num_params 0 pop 0</p>
<p>define function CWorld__AddParticles&lt;cdecl, 0x4B4010&gt;()</p>
<h4>CWorld::CallOffChaseForArea</h4>
<p>plugin::Call<0x4B5530, float, float, float, float>(x1, y1, x2, y2);</p>
<p>0AA5: call_function 0x4B5530 num_params 4 pop 4 [x1] [y1] [x2] [y2]</p>
<p>define function CWorld__CallOffChaseForArea&lt;cdecl, 0x4B5530&gt;(x1, y1, x2, y2)</p>
<h4>CWorld::CallOffChaseForAreaSectorListPeds</h4>
<p>plugin::Call<0x4B5A60, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x4B5A60 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CWorld__CallOffChaseForAreaSectorListPeds&lt;cdecl, 0x4B5A60&gt;(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8)</p>
<h4>CWorld::CallOffChaseForAreaSectorListVehicles</h4>
<p>plugin::Call<0x4B57B0, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x4B57B0 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CWorld__CallOffChaseForAreaSectorListVehicles&lt;cdecl, 0x4B57B0&gt;(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8)</p>
<h4>CWorld::CameraToIgnoreThisObject</h4>
<p>plugin::CallAndReturn<bool, 0x4B5C30, CEntity*>(entity);</p>
<p>0AA7: call_function_return 0x4B5C30 num_params 1 pop 1 [entity] func_ret [bool]</p>
<p>define function CWorld__CameraToIgnoreThisObject&lt;cdecl, 0x4B5C30&gt;(entity): int</p>
<h4>CWorld::ClearCarsFromArea</h4>
<p>plugin::Call<0x4B50E0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x4B50E0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CWorld__ClearCarsFromArea&lt;cdecl, 0x4B50E0&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CWorld::ClearExcitingStuffFromArea</h4>
<p>plugin::Call<0x4B4E70, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);</p>
<p>0AA5: call_function 0x4B4E70 num_params 3 pop 3 [point] [radius] [bRemoveProjectilesAndShadows]</p>
<p>define function CWorld__ClearExcitingStuffFromArea&lt;cdecl, 0x4B4E70&gt;(point, radius, bRemoveProjectilesAndShadows)</p>
<h4>CWorld::ClearForRestart</h4>
<p>plugin::Call<0x4AE850>();</p>
<p>0AA5: call_function 0x4AE850 num_params 0 pop 0</p>
<p>define function CWorld__ClearForRestart&lt;cdecl, 0x4AE850&gt;()</p>
<h4>CWorld::ClearPedsFromArea</h4>
<p>plugin::Call<0x4B52B0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x4B52B0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CWorld__ClearPedsFromArea&lt;cdecl, 0x4B52B0&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CWorld::ClearScanCodes</h4>
<p>plugin::Call<0x4B1F60>();</p>
<p>0AA5: call_function 0x4B1F60 num_params 0 pop 0</p>
<p>define function CWorld__ClearScanCodes&lt;cdecl, 0x4B1F60&gt;()</p>
<h4>CWorld::ExtinguishAllCarFiresInArea</h4>
<p>plugin::Call<0x4B5460, CVector, float>(point, radius);</p>
<p>0AA5: call_function 0x4B5460 num_params 2 pop 2 [point] [radius]</p>
<p>define function CWorld__ExtinguishAllCarFiresInArea&lt;cdecl, 0x4B5460&gt;(point, radius)</p>
<h4>CWorld::FindGroundZFor3DCoord</h4>
<p>plugin::CallAndReturn<float, 0x4B3AE0, float, float, float, bool*>(x, y, z, outResult);</p>
<p>0AA7: call_function_return 0x4B3AE0 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]</p>
<p>define function CWorld__FindGroundZFor3DCoord&lt;cdecl, 0x4B3AE0&gt;(x, y, z, outResult): float</p>
<h4>CWorld::FindGroundZForCoord</h4>
<p>plugin::CallAndReturn<float, 0x4B3A80, float, float>(x, y);</p>
<p>0AA7: call_function_return 0x4B3A80 num_params 2 pop 2 [x] [y] func_ret [float]</p>
<p>define function CWorld__FindGroundZForCoord&lt;cdecl, 0x4B3A80&gt;(x, y): float</p>
<h4>CWorld::FindMissionEntitiesIntersectingCube</h4>
<p>plugin::Call<0x4B3680, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);</p>
<p>0AA5: call_function 0x4B3680 num_params 8 pop 8 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehicles] [peds] [objects]</p>
<p>define function CWorld__FindMissionEntitiesIntersectingCube&lt;cdecl, 0x4B3680&gt;(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects)</p>
<h4>CWorld::FindMissionEntitiesIntersectingCubeSectorList</h4>
<p>plugin::Call<0x4B3920, CPtrList&, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool>(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);</p>
<p>0AA5: call_function 0x4B3920 num_params 9 pop 9 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehiclesList] [pedsList] [objectsList]</p>
<p>define function CWorld__FindMissionEntitiesIntersectingCubeSectorList&lt;cdecl, 0x4B3920&gt;(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList)</p>
<h4>CWorld::FindObjectsInRange</h4>
<p>plugin::Call<0x4B2200, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4B2200 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsInRange&lt;cdecl, 0x4B2200&gt;(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsInRangeSectorList</h4>
<p>plugin::Call<0x4B2540, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(list, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4B2540 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsInRangeSectorList&lt;cdecl, 0x4B2540&gt;(list, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsIntersectingAngledCollisionBox</h4>
<p>plugin::Call<0x4B3280, CColBox const&, CMatrix const&, CVector const&, float, float, float, float, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4B3280 num_params 15 pop 15 [box] [transform] [point] [x1] [y1] [x2] [y2] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsIntersectingAngledCollisionBox&lt;cdecl, 0x4B3280&gt;(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList</h4>
<p>plugin::Call<0x4B3590, CPtrList&, CColBox const&, CMatrix const&, CVector const&, short<em>, short, CEntity</em>*>(list, box, transform, poin, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4B3590 num_params 7 pop 7 [list] [box] [transform] [poin] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsIntersectingAngledCollisionBoxSectorList&lt;cdecl, 0x4B3590&gt;(list, box, transform, poin, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsIntersectingCube</h4>
<p>plugin::Call<0x4B2E70, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4B2E70 num_params 10 pop 10 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsIntersectingCube&lt;cdecl, 0x4B2E70&gt;(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsIntersectingCubeSectorList</h4>
<p>plugin::Call<0x4B3150, CPtrList&, CVector const&, CVector const&, short<em>, short, CEntity</em>*>(list, cornerA, cornerB, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4B3150 num_params 6 pop 6 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsIntersectingCubeSectorList&lt;cdecl, 0x4B3150&gt;(list, cornerA, cornerB, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsKindaColliding</h4>
<p>plugin::Call<0x4B2A30, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4B2A30 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsKindaColliding&lt;cdecl, 0x4B2A30&gt;(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsKindaCollidingSectorList</h4>
<p>plugin::Call<0x4B2D70, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(list, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4B2D70 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsKindaCollidingSectorList&lt;cdecl, 0x4B2D70&gt;(list, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsOfTypeInRange</h4>
<p>plugin::Call<0x4B2600, unsigned int, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4B2600 num_params 12 pop 12 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsOfTypeInRange&lt;cdecl, 0x4B2600&gt;(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsOfTypeInRangeSectorList</h4>
<p>plugin::Call<0x4B2960, unsigned int, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(modelId, list, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4B2960 num_params 8 pop 8 [modelId] [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsOfTypeInRangeSectorList&lt;cdecl, 0x4B2960&gt;(modelId, list, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindRoofZFor3DCoord</h4>
<p>plugin::CallAndReturn<float, 0x4B3B50, float, float, float, bool*>(x, y, z, outResult);</p>
<p>0AA7: call_function_return 0x4B3B50 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]</p>
<p>define function CWorld__FindRoofZFor3DCoord&lt;cdecl, 0x4B3B50&gt;(x, y, z, outResult): float</p>
<h4>CWorld::GetIsLineOfSightClear</h4>
<p>plugin::CallAndReturn<bool, 0x4AEAA0, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4AEAA0 num_params 9 pop 9 [origin] [target] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightClear&lt;cdecl, 0x4AEAA0&gt;(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::GetIsLineOfSightSectorClear</h4>
<p>plugin::CallAndReturn<bool, 0x4B2000, CSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4B2000 num_params 9 pop 9 [sector] [line] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightSectorClear&lt;cdecl, 0x4B2000&gt;(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::GetIsLineOfSightSectorListClear</h4>
<p>plugin::CallAndReturn<bool, 0x4B2160, CPtrList&, CColLine const&, bool, bool>(list, line, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4B2160 num_params 4 pop 4 [list] [line] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightSectorListClear&lt;cdecl, 0x4B2160&gt;(list, line, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::Initialise</h4>
<p>plugin::Call<0x4AE410>();</p>
<p>0AA5: call_function 0x4AE410 num_params 0 pop 0</p>
<p>define function CWorld__Initialise&lt;cdecl, 0x4AE410&gt;()</p>
<h4>CWorld::Process</h4>
<p>plugin::Call<0x4B1A60>();</p>
<p>0AA5: call_function 0x4B1A60 num_params 0 pop 0</p>
<p>define function CWorld__Process&lt;cdecl, 0x4B1A60&gt;()</p>
<h4>CWorld::ProcessLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x4AF970, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4AF970 num_params 11 pop 11 [origin] [target] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSight&lt;cdecl, 0x4AF970&gt;(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::ProcessLineOfSightSector</h4>
<p>plugin::CallAndReturn<bool, 0x4B0A80, CSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool>(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4B0A80 num_params 12 pop 12 [sector] [line] [outColPoint] [maxTouchDistance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSightSector&lt;cdecl, 0x4B0A80&gt;(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::ProcessLineOfSightSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x4B0C70, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4B0C70 num_params 7 pop 7 [list] [line] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSightSectorList&lt;cdecl, 0x4B0C70&gt;(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::ProcessVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x4B0DE0, CVector const&, float, CColPoint&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x4B0DE0 num_params 11 pop 11 [origin] [distance] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLine&lt;cdecl, 0x4B0DE0&gt;(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::ProcessVerticalLineSector</h4>
<p>plugin::CallAndReturn<bool, 0x4B0EF0, CSector&, CColLine const&, CColPoint&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x4B0EF0 num_params 11 pop 11 [sector] [line] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSector&lt;cdecl, 0x4B0EF0&gt;(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::ProcessVerticalLineSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x4B1090, CPtrList&, CColLine const&, CColPoint&, float&, CEntity<em>&, bool, CStoredCollPoly</em>>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x4B1090 num_params 7 pop 7 [list] [line] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSectorList&lt;cdecl, 0x4B1090&gt;(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::Remove</h4>
<p>plugin::Call<0x4AE9D0, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4AE9D0 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__Remove&lt;cdecl, 0x4AE9D0&gt;(entity)</p>
<h4>CWorld::RemoveEntityInsteadOfProcessingIt</h4>
<p>plugin::Call<0x4B4E10, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4B4E10 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RemoveEntityInsteadOfProcessingIt&lt;cdecl, 0x4B4E10&gt;(entity)</p>
<h4>CWorld::RemoveFallenCars</h4>
<p>plugin::Call<0x4B4170>();</p>
<p>0AA5: call_function 0x4B4170 num_params 0 pop 0</p>
<p>define function CWorld__RemoveFallenCars&lt;cdecl, 0x4B4170&gt;()</p>
<h4>CWorld::RemoveFallenPeds</h4>
<p>plugin::Call<0x4B4060>();</p>
<p>0AA5: call_function 0x4B4060 num_params 0 pop 0</p>
<p>define function CWorld__RemoveFallenPeds&lt;cdecl, 0x4B4060&gt;()</p>
<h4>CWorld::RemoveReferencesToDeletedObject</h4>
<p>plugin::Call<0x4B3BF0, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4B3BF0 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RemoveReferencesToDeletedObject&lt;cdecl, 0x4B3BF0&gt;(entity)</p>
<h4>CWorld::RemoveStaticObjects</h4>
<p>plugin::Call<0x4B4D50>();</p>
<p>0AA5: call_function 0x4B4D50 num_params 0 pop 0</p>
<p>define function CWorld__RemoveStaticObjects&lt;cdecl, 0x4B4D50&gt;()</p>
<h4>CWorld::RepositionCertainDynamicObjects</h4>
<p>plugin::Call<0x4B42B0>();</p>
<p>0AA5: call_function 0x4B42B0 num_params 0 pop 0</p>
<p>define function CWorld__RepositionCertainDynamicObjects&lt;cdecl, 0x4B42B0&gt;()</p>
<h4>CWorld::RepositionOneObject</h4>
<p>plugin::Call<0x4B4300, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4B4300 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RepositionOneObject&lt;cdecl, 0x4B4300&gt;(entity)</p>
<h4>CWorld::SetAllCarsCanBeDamaged</h4>
<p>plugin::Call<0x4B53F0, bool>(enable);</p>
<p>0AA5: call_function 0x4B53F0 num_params 1 pop 1 [enable]</p>
<p>define function CWorld__SetAllCarsCanBeDamaged&lt;cdecl, 0x4B53F0&gt;(enable)</p>
<h4>CWorld::SetCarsOnFire</h4>
<p>plugin::Call<0x4B3E90, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);</p>
<p>0AA5: call_function 0x4B3E90 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]</p>
<p>define function CWorld__SetCarsOnFire&lt;cdecl, 0x4B3E90&gt;(x, y, z, radius, fireCreator)</p>
<h4>CWorld::SetPedsOnFire</h4>
<p>plugin::Call<0x4B3D30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);</p>
<p>0AA5: call_function 0x4B3D30 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]</p>
<p>define function CWorld__SetPedsOnFire&lt;cdecl, 0x4B3D30&gt;(x, y, z, radius, fireCreator)</p>
<h4>CWorld::ShutDown</h4>
<p>plugin::Call<0x4AE450>();</p>
<p>0AA5: call_function 0x4AE450 num_params 0 pop 0</p>
<p>define function CWorld__ShutDown&lt;cdecl, 0x4AE450&gt;()</p>
<h4>CWorld::StopAllLawEnforcersInTheirTracks</h4>
<p>plugin::Call<0x4B5BC0>();</p>
<p>0AA5: call_function 0x4B5BC0 num_params 0 pop 0</p>
<p>define function CWorld__StopAllLawEnforcersInTheirTracks&lt;cdecl, 0x4B5BC0&gt;()</p>
<h4>CWorld::TestSphereAgainstSectorList</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x4B4AC0, CPtrList&, CVector, float, CEntity</em>, bool>(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4B4AC0 num_params 5 pop 5 [list] [sphereCenter] [sphereRadius] [ignoreEntity] [doCameraIgnoreCheck] func_ret [CEntity*]</p>
<p>define function CWorld__TestSphereAgainstSectorList&lt;cdecl, 0x4B4AC0&gt;(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck): int</p>
<h4>CWorld::TestSphereAgainstWorld</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x4B4710, CVector, float, CEntity</em>, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck);</p>
<p>0AA7: call_function_return 0x4B4710 num_params 9 pop 9 [sphereCenter] [sphereRadius] [ignoreEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] func_ret [CEntity*]</p>
<p>define function CWorld__TestSphereAgainstWorld&lt;cdecl, 0x4B4710&gt;(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck): int</p>
<h4>CWorld::TriggerExplosion</h4>
<p>plugin::Call<0x4B1140, CVector const&, float, float, CEntity*, bool>(point, radius, visibleDistance, entity, processVehicleBombTimer);</p>
<p>0AA5: call_function 0x4B1140 num_params 5 pop 5 [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]</p>
<p>define function CWorld__TriggerExplosion&lt;cdecl, 0x4B1140&gt;(point, radius, visibleDistance, entity, processVehicleBombTimer)</p>
<h4>CWorld::TriggerExplosionSectorList</h4>
<p>plugin::Call<0x4B1340, CPtrList&, CVector const&, float, float, CEntity*, bool>(list, point, radius, visibleDistance, entity, processVehicleBombTimer);</p>
<p>0AA5: call_function 0x4B1340 num_params 6 pop 6 [list] [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]</p>
<p>define function CWorld__TriggerExplosionSectorList&lt;cdecl, 0x4B1340&gt;(list, point, radius, visibleDistance, entity, processVehicleBombTimer)</p>
<h4>CWorld::UseDetonator</h4>
<p>plugin::Call<0x4B4650, CEntity*>(creator);</p>
<p>0AA5: call_function 0x4B4650 num_params 1 pop 1 [creator]</p>
<p>define function CWorld__UseDetonator&lt;cdecl, 0x4B4650&gt;(creator)</p><h3 id="plugin_iiigame_iiicxtracompsmodelinfocpp">plugin_III\game_III\CXtraCompsModelInfo.cpp</h3><h4>CXtraCompsModelInfo::Shutdown</h4>
<p>plugin::CallVirtualMethod<1, CXtraCompsModelInfo *>(this);</p>
<h4>*CXtraCompsModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject *, 3, CXtraCompsModelInfo *>(this);</p>
<h4>CXtraCompsModelInfo::SetClump</h4>
<p>plugin::CallVirtualMethod<6, CXtraCompsModelInfo *, RpClump *>(this, clump);</p><h3 id="plugin_iiigame_iiiczonecpp">plugin_III\game_III\CZone.cpp</h3><h4>*CZone::GetTranslatedName</h4>
<p>plugin::CallMethodAndReturnDynGlobal<wchar_t *, CZone *>(gaddrof(CZone::GetTranslatedName), this);</p>
<p>0AA8: call_method_return 0x4B5DD0 struct [*CZone] num_params 0 pop 0 func_ret [wchar_t *]</p><h3 id="plugin_iiigame_iiigenericgamestoragecpp">plugin_III\game_III\GenericGameStorage.cpp</h3><h4>GenericSave</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(GenericSave), file);</p>
<p>0AA7: call_function_return 0x58F8D0 num_params 1 pop 1 [file] func_ret [bool]</p>
<p>define function GenericSave&lt;cdecl, 0x58F8D0&gt;(file): int</p>
<h4>GenericLoad</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(GenericLoad));</p>
<p>0AA7: call_function_return 0x590A00 num_params 0 pop 0 func_ret [bool]</p>
<p>define function GenericLoad&lt;cdecl, 0x590A00&gt;(): int</p>
<h4>ReadInSizeofSaveFileBuffer</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int &, unsigned int &>(gaddrof(ReadInSizeofSaveFileBuffer), file, size);</p>
<p>0AA7: call_function_return 0x591910 num_params 2 pop 2 [file] [size] func_ret [bool]</p>
<p>define function ReadInSizeofSaveFileBuffer&lt;cdecl, 0x591910&gt;(file, size): int</p>
<h4>ReadDataFromFile</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, unsigned char *, unsigned int>(gaddrof(ReadDataFromFile), file, buf, size);</p>
<p>0AA7: call_function_return 0x591990 num_params 3 pop 3 [file] [buf] [size] func_ret [bool]</p>
<p>define function ReadDataFromFile&lt;cdecl, 0x591990&gt;(file, buf, size): int</p>
<h4>CloseFile</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CloseFile), file);</p>
<p>0AA7: call_function_return 0x591A00 num_params 1 pop 1 [file] func_ret [bool]</p>
<p>define function CloseFile&lt;cdecl, 0x591A00&gt;(file): int</p>
<h4>CheckSlotDataValid</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CheckSlotDataValid), slot);</p>
<p>0AA7: call_function_return 0x591A40 num_params 1 pop 1 [slot] func_ret [bool]</p>
<p>define function CheckSlotDataValid&lt;cdecl, 0x591A40&gt;(slot): int</p>
<h4>MakeSpaceForSizeInBufferPointer</h4>
<p>plugin::CallDynGlobal<unsigned char *&, unsigned char *&, unsigned char *&>(gaddrof(MakeSpaceForSizeInBufferPointer), preSize, buf, postSize);</p>
<h4>CopySizeAndPreparePointer</h4>
<p>plugin::CallDynGlobal<unsigned char *&, unsigned char *&, unsigned char *&, unsigned int &, unsigned int &>(gaddrof(CopySizeAndPreparePointer), buf, postBuf, postBuf2, unused, size);</p>
<h4>MakeValidSaveName</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(MakeValidSaveName), slot);</p>
<h4>*GetSavedGameDateAndTime</h4>
<p>plugin::CallAndReturnDynGlobal<wchar_t *, int>(gaddrof(GetSavedGameDateAndTime), slot);</p>
<p>0AA7: call_function_return 0x591B50 num_params 1 pop 1 [slot] func_ret [wchar_t *]</p>
<p>define function GetSavedGameDateAndTime&lt;cdecl, 0x591B50&gt;(slot): int</p>
<h4>*GetNameOfSavedGame</h4>
<p>plugin::CallAndReturnDynGlobal<wchar_t *, int>(gaddrof(GetNameOfSavedGame), slot);</p>
<p>0AA7: call_function_return 0x591B60 num_params 1 pop 1 [slot] func_ret [wchar_t *]</p>
<p>define function GetNameOfSavedGame&lt;cdecl, 0x591B60&gt;(slot): int</p>
<h4>CheckDataNotCorrupt</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CheckDataNotCorrupt), slot, name);</p>
<p>0AA7: call_function_return 0x591B70 num_params 2 pop 2 [slot] [name] func_ret [bool]</p>
<p>define function CheckDataNotCorrupt&lt;cdecl, 0x591B70&gt;(slot, name): int</p>
<h4>RestoreForStartLoad</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(RestoreForStartLoad));</p>
<p>0AA7: call_function_return 0x591D60 num_params 0 pop 0 func_ret [bool]</p>
<p>define function RestoreForStartLoad&lt;cdecl, 0x591D60&gt;(): int</p>
<h4>align4bytes</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(align4bytes), size);</p>
<p>0AA7: call_function_return 0x591E80 num_params 1 pop 1 [size] func_ret [int]</p>
<p>define function align4bytes&lt;cdecl, 0x591E80&gt;(size): int</p><h3 id="plugin_iiigame_iiinodenamecpp">plugin_III\game_III\NodeName.cpp</h3><h4>*NodeNameConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameConstructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527010 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function NodeNameConstructor&lt;cdecl, 0x527010&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameDestructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameDestructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527030 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function NodeNameDestructor&lt;cdecl, 0x527030&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameCopy</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(NodeNameCopy), dstObject, srcObject, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527040 num_params 4 pop 4 [dstObject] [srcObject] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function NodeNameCopy&lt;cdecl, 0x527040&gt;(dstObject, srcObject, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameStreamWrite</h4>
<p>plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamWrite), stream, binaryLength, object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x527070 num_params 5 pop 5 [stream] [binaryLength] [object] [offsetInObject] [sizeInObject] func_ret [RwStream *]</p>
<p>define function NodeNameStreamWrite&lt;cdecl, 0x527070&gt;(stream, binaryLength, object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameStreamRead</h4>
<p>plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void *, RwInt32, RwInt32>(gaddrof(NodeNameStreamRead), stream, binaryLength, object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x5270A0 num_params 5 pop 5 [stream] [binaryLength] [object] [offsetInObject] [sizeInObject] func_ret [RwStream *]</p>
<p>define function NodeNameStreamRead&lt;cdecl, 0x5270A0&gt;(stream, binaryLength, object, offsetInObject, sizeInObject): int</p>
<h4>NodeNameStreamGetSize</h4>
<p>plugin::CallAndReturnDynGlobal<RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamGetSize), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x5270D0 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [RwInt32]</p>
<p>define function NodeNameStreamGetSize&lt;cdecl, 0x5270D0&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>NodeNamePluginAttach</h4>
<p>plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(NodeNamePluginAttach));</p>
<p>0AA7: call_function_return 0x527100 num_params 0 pop 0 func_ret [RwBool]</p>
<p>define function NodeNamePluginAttach&lt;cdecl, 0x527100&gt;(): int</p>
<h4>*GetFrameNodeName</h4>
<p>plugin::CallAndReturnDynGlobal<char *, RwFrame *>(gaddrof(GetFrameNodeName), frame);</p>
<p>0AA7: call_function_return 0x527150 num_params 1 pop 1 [frame] func_ret [char *]</p>
<p>define function GetFrameNodeName&lt;cdecl, 0x527150&gt;(frame): int</p><h3 id="plugin_iiigame_iiirenderbuffercpp">plugin_III\game_III\RenderBuffer.cpp</h3><h4>RenderBuffer::StartStoring</h4>
<p>plugin::CallDynGlobal<int, int, RwImVertexIndex **, RwIm3DVertex **>(gaddrof(RenderBuffer::StartStoring), numIndices, numVertices, indexStart, vertexStart);</p><h3 id="plugin_iiigame_iiirpanimblendcpp">plugin_III\game_III\RpAnimBlend.cpp</h3><h4>RpAnimBlendClumpUpdateAnimations</h4>
<p>plugin::CallDynGlobal<RpClump *, float>(gaddrof(RpAnimBlendClumpUpdateAnimations), clump, timeDelta);</p>
<h4>FrameUpdateCallBack</h4>
<p>plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBack), frames, data);</p>
<h4>FrameUpdateCallBackWithVelocityExtraction</h4>
<p>plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBackWithVelocityExtraction), frames, data);</p>
<h4>FrameUpdateCallBackWith3dVelocityExtraction</h4>
<p>plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameUpdateCallBackWith3dVelocityExtraction), frames, data);</p>
<h4>*RpAnimBlendClumpGetFirstAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *>(gaddrof_o(RpAnimBlendClumpGetFirstAssociation, CAnimBlendAssociation <em>(</em>)(RpClump *)), clump);</p>
<p>0AA7: call_function_return 0x405750 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetFirstAssociation&lt;cdecl, 0x405750&gt;(clump): int</p>
<h4>*AnimBlendClumpDestroy</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpDestroy), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x405240 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function AnimBlendClumpDestroy&lt;cdecl, 0x405240&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*AnimBlendClumpCreate</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpCreate), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x405280 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function AnimBlendClumpCreate&lt;cdecl, 0x405280&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>RpAnimBlendAllocateData</h4>
<p>plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendAllocateData), clump);</p>
<h4>*AnimBlendClumpCopy</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(AnimBlendClumpCopy), dstObject, srcObject, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x4052C0 num_params 4 pop 4 [dstObject] [srcObject] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function AnimBlendClumpCopy&lt;cdecl, 0x4052C0&gt;(dstObject, srcObject, offsetInObject, sizeInObject): int</p>
<h4>RpAnimBlendPluginAttach</h4>
<p>plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(RpAnimBlendPluginAttach));</p>
<p>0AA7: call_function_return 0x4052D0 num_params 0 pop 0 func_ret [RwBool]</p>
<p>define function RpAnimBlendPluginAttach&lt;cdecl, 0x4052D0&gt;(): int</p>
<h4>*FrameForAllChildrenCountCBnonskin</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(FrameForAllChildrenCountCBnonskin), frame, data);</p>
<p>0AA7: call_function_return 0x405310 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function FrameForAllChildrenCountCBnonskin&lt;cdecl, 0x405310&gt;(frame, data): int</p>
<h4>*FrameForAllChildrenFillFrameArrayCBnonskin</h4>
<p>plugin::CallAndReturnDynGlobal<RwFrame *, RwFrame *, void *>(gaddrof(FrameForAllChildrenFillFrameArrayCBnonskin), frame, data);</p>
<p>0AA7: call_function_return 0x405330 num_params 2 pop 2 [frame] [data] func_ret [RwFrame *]</p>
<p>define function FrameForAllChildrenFillFrameArrayCBnonskin&lt;cdecl, 0x405330&gt;(frame, data): int</p>
<h4>FrameInitCBnonskin</h4>
<p>plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameInitCBnonskin), frames, data);</p>
<h4>FrameFindByNameCBnonskin</h4>
<p>plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FrameFindByNameCBnonskin), frames, data);</p>
<h4>FillFrameArrayCBnonskin</h4>
<p>plugin::CallDynGlobal<AnimBlendFrameData *, void *>(gaddrof(FillFrameArrayCBnonskin), frames, data);</p>
<h4>*RpAnimBlendClumpFindFrame</h4>
<p>plugin::CallAndReturnDynGlobal<AnimBlendFrameData *, RpClump *, char const *>(gaddrof(RpAnimBlendClumpFindFrame), clump, name);</p>
<p>0AA7: call_function_return 0x405430 num_params 2 pop 2 [clump] [name] func_ret [AnimBlendFrameData *]</p>
<p>define function RpAnimBlendClumpFindFrame&lt;cdecl, 0x405430&gt;(clump, name): int</p>
<h4>RpAnimBlendClumpFillFrameArray</h4>
<p>plugin::CallDynGlobal<RpClump *, AnimBlendFrameData **>(gaddrof(RpAnimBlendClumpFillFrameArray), clump, frames);</p>
<h4>RpAnimBlendClumpInit</h4>
<p>plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendClumpInit), clump);</p>
<h4>RpAnimBlendClumpIsInitialized</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RpClump *>(gaddrof(RpAnimBlendClumpIsInitialized), clump);</p>
<p>0AA7: call_function_return 0x405500 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function RpAnimBlendClumpIsInitialized&lt;cdecl, 0x405500&gt;(clump): int</p>
<h4>RpAnimBlendClumpSetBlendDeltas</h4>
<p>plugin::CallDynGlobal<RpClump *, unsigned int, float>(gaddrof(RpAnimBlendClumpSetBlendDeltas), clump, mask, delta);</p>
<h4>RpAnimBlendClumpRemoveAllAssociations</h4>
<p>plugin::CallDynGlobal<RpClump *>(gaddrof(RpAnimBlendClumpRemoveAllAssociations), clump);</p>
<h4>RpAnimBlendClumpRemoveAssociations</h4>
<p>plugin::CallDynGlobal<RpClump *, unsigned int>(gaddrof(RpAnimBlendClumpRemoveAssociations), clump, mask);</p>
<h4>*RpAnimBlendClumpGetAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, unsigned int>(gaddrof(RpAnimBlendClumpGetAssociation), clump, id);</p>
<p>0AA7: call_function_return 0x4055C0 num_params 2 pop 2 [clump] [id] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetAssociation&lt;cdecl, 0x4055C0&gt;(clump, id): int</p>
<h4>*RpAnimBlendClumpGetMainAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendAssociation **, float *>(gaddrof(RpAnimBlendClumpGetMainAssociation), clump, assocRet, blendRet);</p>
<p>0AA7: call_function_return 0x4055F0 num_params 3 pop 3 [clump] [assocRet] [blendRet] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetMainAssociation&lt;cdecl, 0x4055F0&gt;(clump, assocRet, blendRet): int</p>
<h4>*RpAnimBlendClumpGetMainPartialAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *>(gaddrof(RpAnimBlendClumpGetMainPartialAssociation), clump);</p>
<p>0AA7: call_function_return 0x405680 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetMainPartialAssociation&lt;cdecl, 0x405680&gt;(clump): int</p>
<h4>*RpAnimBlendClumpGetMainAssociation_N</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int>(gaddrof(RpAnimBlendClumpGetMainAssociation_N), clump, n);</p>
<p>0AA7: call_function_return 0x4056D0 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetMainAssociation_N&lt;cdecl, 0x4056D0&gt;(clump, n): int</p>
<h4>*RpAnimBlendClumpGetMainPartialAssociation_N</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, int>(gaddrof(RpAnimBlendClumpGetMainPartialAssociation_N), clump, n);</p>
<p>0AA7: call_function_return 0x405710 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetMainPartialAssociation_N&lt;cdecl, 0x405710&gt;(clump, n): int</p>
<h4>*RpAnimBlendClumpGetFirstAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, RpClump *, unsigned int>(gaddrof_o(RpAnimBlendClumpGetFirstAssociation, CAnimBlendAssociation <em>(</em>)(RpClump *, unsigned int)), clump, mask);</p>
<p>0AA7: call_function_return 0x405750 num_params 2 pop 2 [clump] [mask] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendClumpGetFirstAssociation&lt;cdecl, 0x405750&gt;(clump, mask): int</p>
<h4>*RpAnimBlendGetNextAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof_o(RpAnimBlendGetNextAssociation, CAnimBlendAssociation <em>(</em>)(CAnimBlendAssociation *)), assoc);</p>
<p>0AA7: call_function_return 0x4057A0 num_params 1 pop 1 [assoc] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendGetNextAssociation&lt;cdecl, 0x4057A0&gt;(assoc): int</p>
<h4>*RpAnimBlendGetNextAssociation</h4>
<p>plugin::CallAndReturnDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *, unsigned int>(gaddrof_o(RpAnimBlendGetNextAssociation, CAnimBlendAssociation <em>(</em>)(CAnimBlendAssociation *, unsigned int)), assoc, mask);</p>
<p>0AA7: call_function_return 0x4057A0 num_params 2 pop 2 [assoc] [mask] func_ret [CAnimBlendAssociation *]</p>
<p>define function RpAnimBlendGetNextAssociation&lt;cdecl, 0x4057A0&gt;(assoc, mask): int</p><h3 id="plugin_iiigame_iiimetametac2deffectsmodelinfoh">plugin_III\game_III\meta\meta.C2deffectsModelInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), reinterpret_cast<C2deffectsModelInfo *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), reinterpret_cast<C2deffectsModelInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(ctor_gaddr(C2deffectsModelInfo), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<C2deffectsModelInfo *>(dtor_gaddr(C2deffectsModelInfo), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametac3dmarkerh">plugin_III\game_III\meta\meta.C3dMarker.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), reinterpret_cast<C3dMarker *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), reinterpret_cast<C3dMarker *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(ctor_gaddr(C3dMarker), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(dtor_gaddr(C3dMarker), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacaccidenth">plugin_III\game_III\meta\meta.CAccident.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), reinterpret_cast<CAccident *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), reinterpret_cast<CAccident *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAccident *>(ctor_gaddr(CAccident), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAccident *>(dtor_gaddr(CAccident), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacaccidentmanagerh">plugin_III\game_III\meta\meta.CAccidentManager.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), reinterpret_cast<CAccidentManager *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *>(ctor_gaddr(CAccidentManager), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *>(del_dtor_gaddr(CAccidentManager), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAccidentManager *>(del_dtor_gaddr(CAccidentManager), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacanimblendassocgrouph">plugin_III\game_III\meta\meta.CAnimBlendAssocGroup.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), reinterpret_cast<CAnimBlendAssocGroup *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), reinterpret_cast<CAnimBlendAssocGroup *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(ctor_gaddr(CAnimBlendAssocGroup), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssocGroup *>(dtor_gaddr(CAnimBlendAssocGroup), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacanimblendassociationh">plugin_III\game_III\meta\meta.CAnimBlendAssociation.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &amp;)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), other);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(dtor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), &amp;objArray[i]);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &amp;)), obj, other);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendAssociation *, int>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendAssociation *, int>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametacanimblendclumpdatah">plugin_III\game_III\meta\meta.CAnimBlendClumpData.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), reinterpret_cast<CAnimBlendClumpData *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), reinterpret_cast<CAnimBlendClumpData *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacanimblendhierarchyh">plugin_III\game_III\meta\meta.CAnimBlendHierarchy.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), reinterpret_cast<CAnimBlendHierarchy *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), reinterpret_cast<CAnimBlendHierarchy *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(ctor_gaddr(CAnimBlendHierarchy), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendHierarchy *>(dtor_gaddr(CAnimBlendHierarchy), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacanimblendsequenceh">plugin_III\game_III\meta\meta.CAnimBlendSequence.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), reinterpret_cast<CAnimBlendSequence *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *>(dtor_gaddr(CAnimBlendSequence), reinterpret_cast<CAnimBlendSequence *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendSequence *>(ctor_gaddr(CAnimBlendSequence), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendSequence *, int>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendSequence *, int>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametacantennah">plugin_III\game_III\meta\meta.CAntenna.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), reinterpret_cast<CAntenna *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAntenna *>(ctor_gaddr(CAntenna), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacaudiocollisionh">plugin_III\game_III\meta\meta.cAudioCollision.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), reinterpret_cast<cAudioCollision *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioCollision *>(ctor_gaddr(cAudioCollision), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacaudiohydranth">plugin_III\game_III\meta\meta.CAudioHydrant.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), reinterpret_cast<CAudioHydrant *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAudioHydrant *>(ctor_gaddr(CAudioHydrant), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacaudioscriptobjecth">plugin_III\game_III\meta\meta.cAudioScriptObject.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</p>
<h4>*operator_new<cAudioScriptObject></h4>
<p>plugin::CallAndReturnDynGlobal<void *, unsigned int>(op_new_gaddr(cAudioScriptObject), sizeof(cAudioScriptObject));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), obj);</p>
<h4>plugin::CallMethodDynGlobal<cAudioScriptObject *></h4>
<p>plugin::CallDynGlobal<void *>(op_delete_gaddr(cAudioScriptObject), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacbasemodelinfoh">plugin_III\game_III\meta\meta.CBaseModelInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *, ModelInfoType>(ctor_gaddr_o(CBaseModelInfo, void(ModelInfoType)), reinterpret_cast<CBaseModelInfo *>(objBuff), type);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *>(dtor_gaddr(CBaseModelInfo), reinterpret_cast<CBaseModelInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CBaseModelInfo *, ModelInfoType>(ctor_gaddr_o(CBaseModelInfo, void(ModelInfoType)), obj, type);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CBaseModelInfo *>(obj);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CBaseModelInfo *>(&amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacbrightlighth">plugin_III\game_III\meta\meta.CBrightLight.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), reinterpret_cast<CBrightLight *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CBrightLight *>(ctor_gaddr(CBrightLight), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacbulletinfoh">plugin_III\game_III\meta\meta.CBulletInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), reinterpret_cast<CBulletInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CBulletInfo *>(ctor_gaddr(CBulletInfo), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacbullettraceh">plugin_III\game_III\meta\meta.CBulletTrace.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), reinterpret_cast<CBulletTrace *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametaccamerah">plugin_III\game_III\meta\meta.CCamera.h</h3><h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(dtor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CCamera *, char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CCamera *, char>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametaccargeneratorh">plugin_III\game_III\meta\meta.CCarGenerator.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), reinterpret_cast<CCarGenerator *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(ctor_gaddr(CCarGenerator), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametaccollineh">plugin_III\game_III\meta\meta.CColLine.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), reinterpret_cast<CColLine *>(objBuff));</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(ctor_gaddr_o(CColLine, void(CVector const &amp;, CVector const &amp;)), reinterpret_cast<CColLine *>(objBuff), start, end);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CColLine *>(ctor_gaddr(CColLine), &amp;objArray[i]);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CColLine *, CVector const &, CVector const &>(ctor_gaddr_o(CColLine, void(CVector const &amp;, CVector const &amp;)), obj, start, end);</p><h3 id="plugin_iiigame_iiimetametaccolpointh">plugin_III\game_III\meta\meta.CColPoint.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), reinterpret_cast<CColPoint *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CColPoint *>(ctor_gaddr(CColPoint), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametaccurrentvehicleh">plugin_III\game_III\meta\meta.CCurrentVehicle.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), reinterpret_cast<CCurrentVehicle *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCurrentVehicle *>(ctor_gaddr(CCurrentVehicle), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacdateh">plugin_III\game_III\meta\meta.CDate.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), reinterpret_cast<CDate *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacdigitalclockh">plugin_III\game_III\meta\meta.CDigitalClock.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), reinterpret_cast<CDigitalClock *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CDigitalClock *>(ctor_gaddr(CDigitalClock), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacdirectoryh">plugin_III\game_III\meta\meta.CDirectory.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), reinterpret_cast<CDirectory *>(objBuff), capacity);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), reinterpret_cast<CDirectory *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), obj, capacity);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacdmaudioh">plugin_III\game_III\meta\meta.cDMAudio.h</h3><h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), reinterpret_cast<cDMAudio *>(objBuff));</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cDMAudio *>(dtor_gaddr(cDMAudio), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacentityh">plugin_III\game_III\meta\meta.CEntity.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), reinterpret_cast<CEntity *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(dtor_gaddr(CEntity), reinterpret_cast<CEntity *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CEntity *>(ctor_gaddr(CEntity), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CEntity *, char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CEntity *, char>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametaceventlisth">plugin_III\game_III\meta\meta.CEventList.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), reinterpret_cast<CEvent *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CEvent *>(ctor_gaddr(CEvent), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacfallingglasspaneh">plugin_III\game_III\meta\meta.CFallingGlassPane.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), reinterpret_cast<CFallingGlassPane *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), reinterpret_cast<CFallingGlassPane *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(ctor_gaddr(CFallingGlassPane), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFallingGlassPane *>(dtor_gaddr(CFallingGlassPane), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacfireh">plugin_III\game_III\meta\meta.CFire.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), reinterpret_cast<CFire *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), reinterpret_cast<CFire *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFire *>(ctor_gaddr(CFire), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFire *>(dtor_gaddr(CFire), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacfiremanagerh">plugin_III\game_III\meta\meta.CFireManager.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), reinterpret_cast<CFireManager *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), reinterpret_cast<CFireManager *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(ctor_gaddr(CFireManager), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CFireManager *>(dtor_gaddr(CFireManager), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacganginfoh">plugin_III\game_III\meta\meta.CGangInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacinstanceh">plugin_III\game_III\meta\meta.CInstance.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), reinterpret_cast<CInstance *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CInstance *>(dtor_gaddr(CInstance), reinterpret_cast<CInstance *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CInstance *>(ctor_gaddr(CInstance), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CInstance *, char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CInstance *, char>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametacmissioncleanuph">plugin_III\game_III\meta\meta.CMissionCleanup.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), reinterpret_cast<CMissionCleanup *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMissionCleanup *>(ctor_gaddr(CMissionCleanup), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacmoneymessageh">plugin_III\game_III\meta\meta.CMoneyMessage.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), reinterpret_cast<CMoneyMessage *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMoneyMessage *>(ctor_gaddr(CMoneyMessage), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacmovieh">plugin_III\game_III\meta\meta.CMovie.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), reinterpret_cast<CMovie *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMovie *>(ctor_gaddr(CMovie), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacmovingthingh">plugin_III\game_III\meta\meta.CMovingThing.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), reinterpret_cast<CMovingThing *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMovingThing *>(ctor_gaddr(CMovingThing), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacmusicmanagerh">plugin_III\game_III\meta\meta.cMusicManager.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), reinterpret_cast<cMusicManager *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cMusicManager *>(ctor_gaddr(cMusicManager), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacpacmanpickuph">plugin_III\game_III\meta\meta.CPacManPickup.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), reinterpret_cast<CPacManPickup *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPacManPickup *>(ctor_gaddr(CPacManPickup), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacparticleh">plugin_III\game_III\meta\meta.CParticle.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacparticleobjecth">plugin_III\game_III\meta\meta.CParticleObject.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), reinterpret_cast<CParticleObject *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(dtor_gaddr(CParticleObject), reinterpret_cast<CParticleObject *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticleObject *>(ctor_gaddr(CParticleObject), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CParticleObject *, char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CParticleObject *, char>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametacpathnodeh">plugin_III\game_III\meta\meta.CPathNode.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), reinterpret_cast<CPathNode *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPathNode *>(ctor_gaddr(CPathNode), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacphoneh">plugin_III\game_III\meta\meta.CPhone.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacphoneinfoh">plugin_III\game_III\meta\meta.CPhoneInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(ctor_gaddr(CPhoneInfo), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacpickuph">plugin_III\game_III\meta\meta.CPickup.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), reinterpret_cast<CPickup *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPickup *>(ctor_gaddr(CPickup), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacplaceableh">plugin_III\game_III\meta\meta.CPlaceable.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), reinterpret_cast<CPlaceable *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPlaceable *>(dtor_gaddr(CPlaceable), reinterpret_cast<CPlaceable *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPlaceable *>(ctor_gaddr(CPlaceable), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CPlaceable *, unsigned char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CPlaceable *, unsigned char>(&amp;objArray[i], 1);</p><h3 id="plugin_iiigame_iiimetametacplacenameh">plugin_III\game_III\meta\meta.CPlaceName.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), reinterpret_cast<CPlaceName *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPlaceName *>(ctor_gaddr(CPlaceName), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacradarh">plugin_III\game_III\meta\meta.CRadar.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<tRadarTrace*>(ctor_gaddr(tRadarTrace), reinterpret_cast<tRadarTrace *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<tRadarTrace *>(ctor_gaddr(tRadarTrace), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<tRadarTrace *>(ctor_gaddr(tRadarTrace), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacregisteredcoronah">plugin_III\game_III\meta\meta.CRegisteredCorona.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), reinterpret_cast<CRegisteredCorona *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CRegisteredCorona *>(ctor_gaddr(CRegisteredCorona), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacregisteredmotionblurstreakh">plugin_III\game_III\meta\meta.CRegisteredMotionBlurStreak.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), reinterpret_cast<CRegisteredMotionBlurStreak *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CRegisteredMotionBlurStreak *>(ctor_gaddr(CRegisteredMotionBlurStreak), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacregisteredshinytexth">plugin_III\game_III\meta\meta.CRegisteredShinyText.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), reinterpret_cast<CRegisteredShinyText *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CRegisteredShinyText *>(ctor_gaddr(CRegisteredShinyText), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacroutenodeh">plugin_III\game_III\meta\meta.CRouteNode.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), reinterpret_cast<CRouteNode *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacscrollbarh">plugin_III\game_III\meta\meta.CScrollBar.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), reinterpret_cast<CScrollBar *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CScrollBar *>(ctor_gaddr(CScrollBar), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacshotinfoh">plugin_III\game_III\meta\meta.CShotInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), reinterpret_cast<CShotInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CShotInfo *>(ctor_gaddr(CShotInfo), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacskidmarkh">plugin_III\game_III\meta\meta.CSkidmark.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), reinterpret_cast<CSkidmark *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CSkidmark *>(ctor_gaddr(CSkidmark), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacsprite2dh">plugin_III\game_III\meta\meta.CSprite2d.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), reinterpret_cast<CSprite2d *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), reinterpret_cast<CSprite2d *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(ctor_gaddr(CSprite2d), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CSprite2d *>(dtor_gaddr(CSprite2d), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacstoredcollpolyh">plugin_III\game_III\meta\meta.CStoredCollPoly.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), reinterpret_cast<CStoredCollPoly *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CStoredCollPoly *>(ctor_gaddr(CStoredCollPoly), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacstuckcarcheckh">plugin_III\game_III\meta\meta.CStuckCarCheck.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), reinterpret_cast<CStuckCarCheck *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(ctor_gaddr(CStuckCarCheck), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametactempnodeh">plugin_III\game_III\meta\meta.CTempNode.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), reinterpret_cast<CTempNode *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CTempNode *>(ctor_gaddr(CTempNode), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametactexth">plugin_III\game_III\meta\meta.CText.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), reinterpret_cast<CText *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), reinterpret_cast<CText *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CText *>(ctor_gaddr(CText), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CText *>(dtor_gaddr(CText), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametactowerclockh">plugin_III\game_III\meta\meta.CTowerClock.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), reinterpret_cast<CTowerClock *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CTowerClock *>(ctor_gaddr(CTowerClock), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametactraincamnodeh">plugin_III\game_III\meta\meta.CTrainCamNode.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), reinterpret_cast<CTrainCamNode *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CTrainCamNode *>(ctor_gaddr(CTrainCamNode), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametactraindoorh">plugin_III\game_III\meta\meta.CTrainDoor.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), reinterpret_cast<CTrainDoor *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CTrainDoor *>(ctor_gaddr(CTrainDoor), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacwantedh">plugin_III\game_III\meta\meta.CWanted.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), reinterpret_cast<CCrimeBeingQd *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCrimeBeingQd *>(ctor_gaddr(CCrimeBeingQd), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacwatercannonh">plugin_III\game_III\meta\meta.CWaterCannon.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), reinterpret_cast<CWaterCannon *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CWaterCannon *>(ctor_gaddr(CWaterCannon), &amp;objArray[i]);</p><h3 id="plugin_iiigame_iiimetametacweaponh">plugin_III\game_III\meta\meta.CWeapon.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), reinterpret_cast<CWeapon *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), reinterpret_cast<CWeapon *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(ctor_gaddr(CWeapon), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CWeapon *>(dtor_gaddr(CWeapon), &amp;objArray[i]);</p><h3 id="plugin_sagame_sac_pcsavecpp">plugin_sa\game_sa\C_PcSave.cpp</h3><h4>C_PcSave::PopulateSlotInfo</h4>
<p>plugin::CallMethod<0x619140, C_PcSave*>(this);</p>
<p>0AA6: call_method 0x619140 struct [C_PcSave] num_params 0 pop 0</p>
<p>define function C_PcSave__PopulateSlotInfo&lt;thiscall, 0x619140&gt;()</p>
<h4>C_PcSave::DeleteSlot</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6190D0, C_PcSave*, int>(this, slot);</p>
<p>0AA8: call_method_return 0x6190D0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]</p>
<p>define function C_PcSave__DeleteSlot&lt;thiscall, 0x6190D0&gt;(slot): int</p>
<h4>C_PcSave::SaveSlot</h4>
<p>plugin::CallMethodAndReturn<bool, 0x619060, C_PcSave*, int>(this, slot);</p>
<p>0AA8: call_method_return 0x619060 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]</p>
<p>define function C_PcSave__SaveSlot&lt;thiscall, 0x619060&gt;(slot): int</p>
<h4>C_PcSave::SetSaveDirectory</h4>
<p>plugin::Call<0x619040, const char*>(path);</p>
<p>0AA5: call_function 0x619040 num_params 1 pop 1 [path]</p>
<p>define function C_PcSave__SetSaveDirectory&lt;cdecl, 0x619040&gt;(path)</p><h3 id="plugin_sagame_sac3dmarkercpp">plugin_sa\game_sa\C3dMarker.cpp</h3><h4>C3dMarker::AddMarker</h4>
<p>plugin::CallMethodAndReturn<bool, 0x722230, C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(this, id, type, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);</p>
<p>0AA8: call_method_return 0x722230 struct [C3dMarker] num_params 10 pop 0 [id] [type] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] func_ret [bool]</p>
<p>define function C3dMarker__AddMarker&lt;thiscall, 0x722230&gt;(id, type, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate): int</p>
<h4>C3dMarker::DeleteMarkerObject</h4>
<p>plugin::CallMethod<0x722390, C3dMarker *>(this);</p>
<p>0AA6: call_method 0x722390 struct [C3dMarker] num_params 0 pop 0</p>
<p>define function C3dMarker__DeleteMarkerObject&lt;thiscall, 0x722390&gt;()</p>
<h4>C3dMarker::IsZCoordinateUpToDate</h4>
<p>plugin::CallMethodAndReturn<bool, 0x7226A0, C3dMarker *>(this);</p>
<p>0AA8: call_method_return 0x7226A0 struct [C3dMarker] num_params 0 pop 0 func_ret [bool]</p>
<p>define function C3dMarker__IsZCoordinateUpToDate&lt;thiscall, 0x7226A0&gt;(): int</p>
<h4>C3dMarker::Render</h4>
<p>plugin::CallMethod<0x7223D0, C3dMarker *>(this);</p>
<p>0AA6: call_method 0x7223D0 struct [C3dMarker] num_params 0 pop 0</p>
<p>define function C3dMarker__Render&lt;thiscall, 0x7223D0&gt;()</p>
<h4>C3dMarker::SetZCoordinateIfNotUpToDate</h4>
<p>plugin::CallMethod<0x724E10, C3dMarker *, float>(this, coordinate);</p>
<p>0AA6: call_method 0x724E10 struct [C3dMarker] num_params 1 pop 0 [coordinate]</p>
<p>define function C3dMarker__SetZCoordinateIfNotUpToDate&lt;thiscall, 0x724E10&gt;(coordinate)</p>
<h4>C3dMarker::UpdateZCoordinate</h4>
<p>plugin::CallMethod<0x724D40, C3dMarker *, CVector, float>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x724D40 struct [C3dMarker] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function C3dMarker__UpdateZCoordinate&lt;thiscall, 0x724D40&gt;(arg0, arg1)</p><h3 id="plugin_sagame_sac3dmarkerscpp">plugin_sa\game_sa\C3dMarkers.cpp</h3><h4>C3dMarkers::DirectionArrowFindFirstFreeSlot</h4>
<p>plugin::CallAndReturn<int, 0x721120>();</p>
<p>0AA7: call_function_return 0x721120 num_params 0 pop 0 func_ret [int]</p>
<p>define function C3dMarkers__DirectionArrowFindFirstFreeSlot&lt;cdecl, 0x721120&gt;(): int</p>
<h4>C3dMarkers::DirectionArrowSet</h4>
<p>plugin::Call<0x721140, CVector, float, int, int, int, int, float, float, float>(posn, size, red, green, blue, alpha, dir_x, dir_y, dir_z);</p>
<p>0AA5: call_function 0x721140 num_params 9 pop 9 [posn] [size] [red] [green] [blue] [alpha] [dir_x] [dir_y] [dir_z]</p>
<p>define function C3dMarkers__DirectionArrowSet&lt;cdecl, 0x721140&gt;(posn, size, red, green, blue, alpha, dir_x, dir_y, dir_z)</p>
<h4>C3dMarkers::DirectionArrowsDraw</h4>
<p>plugin::Call<0x7211F0>();</p>
<p>0AA5: call_function 0x7211F0 num_params 0 pop 0</p>
<p>define function C3dMarkers__DirectionArrowsDraw&lt;cdecl, 0x7211F0&gt;()</p>
<h4>C3dMarkers::DirectionArrowsInit</h4>
<p>plugin::Call<0x721100>();</p>
<p>0AA5: call_function 0x721100 num_params 0 pop 0</p>
<p>define function C3dMarkers__DirectionArrowsInit&lt;cdecl, 0x721100&gt;()</p>
<h4>C3dMarkers::ForceRender</h4>
<p>plugin::Call<0x722870, unsigned char>(bEnable);</p>
<p>0AA5: call_function 0x722870 num_params 1 pop 1 [bEnable]</p>
<p>define function C3dMarkers__ForceRender&lt;cdecl, 0x722870&gt;(bEnable)</p>
<h4>C3dMarkers::Init</h4>
<p>plugin::Call<0x724E40>();</p>
<p>0AA5: call_function 0x724E40 num_params 0 pop 0</p>
<p>define function C3dMarkers__Init&lt;cdecl, 0x724E40&gt;()</p>
<h4>C3dMarkers::LoadMarker</h4>
<p>plugin::CallAndReturn<RpClump<em>, 0x722810, char const</em>>(modelName);</p>
<p>0AA7: call_function_return 0x722810 num_params 1 pop 1 [modelName] func_ret [RpClump*]</p>
<p>define function C3dMarkers__LoadMarker&lt;cdecl, 0x722810&gt;(modelName): int</p>
<h4>C3dMarkers::LoadUser3dMarkers</h4>
<p>plugin::CallAndReturn<bool, 0x5D42E0>();</p>
<p>0AA7: call_function_return 0x5D42E0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function C3dMarkers__LoadUser3dMarkers&lt;cdecl, 0x5D42E0&gt;(): int</p>
<h4>C3dMarkers::PlaceMarker</h4>
<p>plugin::CallAndReturn<C3dMarker*, 0x725120, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short, float, float, float, bool>(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, nrm_x, nrm_y, nrm_z, zCheck);</p>
<p>0AA7: call_function_return 0x725120 num_params 15 pop 15 [id] [type] [posn] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] [nrm_x] [nrm_y] [nrm_z] [zCheck] func_ret [C3dMarker*]</p>
<p>define function C3dMarkers__PlaceMarker&lt;cdecl, 0x725120&gt;(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, nrm_x, nrm_y, nrm_z, zCheck): int</p>
<h4>C3dMarkers::PlaceMarkerCone</h4>
<p>plugin::Call<0x726D40, unsigned int, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short, unsigned char>(id, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, bEnableCollision);</p>
<p>0AA5: call_function 0x726D40 num_params 11 pop 11 [id] [posn] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] [bEnableCollision]</p>
<p>define function C3dMarkers__PlaceMarkerCone&lt;cdecl, 0x726D40&gt;(id, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate, bEnableCollision)</p>
<h4>C3dMarkers::PlaceMarkerSet</h4>
<p>plugin::Call<0x725BA0, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);</p>
<p>0AA5: call_function 0x725BA0 num_params 11 pop 11 [id] [type] [posn] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate]</p>
<p>define function C3dMarkers__PlaceMarkerSet&lt;cdecl, 0x725BA0&gt;(id, type, posn, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate)</p>
<h4>C3dMarkers::Render</h4>
<p>plugin::Call<0x725040>();</p>
<p>0AA5: call_function 0x725040 num_params 0 pop 0</p>
<p>define function C3dMarkers__Render&lt;cdecl, 0x725040&gt;()</p>
<h4>C3dMarkers::SaveUser3dMarkers</h4>
<p>plugin::Call<0x5D4300>();</p>
<p>0AA5: call_function 0x5D4300 num_params 0 pop 0</p>
<p>define function C3dMarkers__SaveUser3dMarkers&lt;cdecl, 0x5D4300&gt;()</p>
<h4>C3dMarkers::Shutdown</h4>
<p>plugin::Call<0x722710>();</p>
<p>0AA5: call_function 0x722710 num_params 0 pop 0</p>
<p>define function C3dMarkers__Shutdown&lt;cdecl, 0x722710&gt;()</p>
<h4>C3dMarkers::Update</h4>
<p>plugin::Call<0x7227B0>();</p>
<p>0AA5: call_function 0x7227B0 num_params 0 pop 0</p>
<p>define function C3dMarkers__Update&lt;cdecl, 0x7227B0&gt;()</p>
<h4>C3dMarkers::User3dMarkerAtomicCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x7210D0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x7210D0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function C3dMarkers__User3dMarkerAtomicCB&lt;cdecl, 0x7210D0&gt;(atomic, data): int</p>
<h4>C3dMarkers::User3dMarkerDelete</h4>
<p>plugin::Call<0x721090, int>(slotIndex);</p>
<p>0AA5: call_function 0x721090 num_params 1 pop 1 [slotIndex]</p>
<p>define function C3dMarkers__User3dMarkerDelete&lt;cdecl, 0x721090&gt;(slotIndex)</p>
<h4>C3dMarkers::User3dMarkerDeleteAll</h4>
<p>plugin::Call<0x7210B0>();</p>
<p>0AA5: call_function 0x7210B0 num_params 0 pop 0</p>
<p>define function C3dMarkers__User3dMarkerDeleteAll&lt;cdecl, 0x7210B0&gt;()</p>
<h4>C3dMarkers::User3dMarkerFindFirstFreeSlot</h4>
<p>plugin::CallAndReturn<int, 0x720FB0>();</p>
<p>0AA7: call_function_return 0x720FB0 num_params 0 pop 0 func_ret [int]</p>
<p>define function C3dMarkers__User3dMarkerFindFirstFreeSlot&lt;cdecl, 0x720FB0&gt;(): int</p>
<h4>C3dMarkers::User3dMarkerSet</h4>
<p>plugin::CallAndReturn<int, 0x720FD0, float, float, float, int>(x, y, z, colour);</p>
<p>0AA7: call_function_return 0x720FD0 num_params 4 pop 4 [x] [y] [z] [colour] func_ret [int]</p>
<p>define function C3dMarkers__User3dMarkerSet&lt;cdecl, 0x720FD0&gt;(x, y, z, colour): int</p>
<h4>C3dMarkers::User3dMarkersDraw</h4>
<p>plugin::Call<0x723240>();</p>
<p>0AA5: call_function 0x723240 num_params 0 pop 0</p>
<p>define function C3dMarkers__User3dMarkersDraw&lt;cdecl, 0x723240&gt;()</p>
<h4>MarkerAtomicCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x722220, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x722220 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function MarkerAtomicCB&lt;cdecl, 0x722220&gt;(atomic, data): int</p><h3 id="plugin_sagame_sacaeaudiohardwarecpp">plugin_sa\game_sa\CAEAudioHardware.cpp</h3><h4>CAEAudioHardware::GetActiveTrackID</h4>
<p>plugin::CallMethodAndReturn<int, 0x4D8F80, CAEAudioHardware*>(this);</p>
<p>0AA8: call_method_return 0x4D8F80 struct [CAEAudioHardware] num_params 0 pop 0 func_ret [int]</p>
<p>define function CAEAudioHardware__GetActiveTrackID&lt;thiscall, 0x4D8F80&gt;(): int</p><h3 id="plugin_sagame_sacaecutscenetrackmanagercpp">plugin_sa\game_sa\CAECutsceneTrackManager.cpp</h3><h4>CAECutsceneTrackManager::StopCutsceneTrack</h4>
<p>plugin::CallMethod<0x4DBE80, CAECutsceneTrackManager*>(this);</p>
<p>0AA6: call_method 0x4DBE80 struct [CAECutsceneTrackManager] num_params 0 pop 0</p>
<p>define function CAECutsceneTrackManager__StopCutsceneTrack&lt;thiscall, 0x4DBE80&gt;()</p>
<h4>CAECutsceneTrackManager::StartTrackPlayback</h4>
<p>plugin::CallMethod<0x4DBF10, CAECutsceneTrackManager*>(this);</p>
<p>0AA6: call_method 0x4DBF10 struct [CAECutsceneTrackManager] num_params 0 pop 0</p>
<p>define function CAECutsceneTrackManager__StartTrackPlayback&lt;thiscall, 0x4DBF10&gt;()</p>
<h4>CAECutsceneTrackManager::Service</h4>
<p>plugin::CallMethod<0x4DBFB0, CAECutsceneTrackManager*, int>(this, time);</p>
<p>0AA6: call_method 0x4DBFB0 struct [CAECutsceneTrackManager] num_params 1 pop 0 [time]</p>
<p>define function CAECutsceneTrackManager__Service&lt;thiscall, 0x4DBFB0&gt;(time)</p>
<h4>CAECutsceneTrackManager::PreloadBeatTrack</h4>
<p>plugin::CallMethod<0x4DC130, CAECutsceneTrackManager*, char, bool>(this, arg1, arg2);</p>
<p>0AA6: call_method 0x4DC130 struct [CAECutsceneTrackManager] num_params 2 pop 0 [arg1] [arg2]</p>
<p>define function CAECutsceneTrackManager__PreloadBeatTrack&lt;thiscall, 0x4DC130&gt;(arg1, arg2)</p>
<h4>CAECutsceneTrackManager::PlayPreloadedCutsceneTrack</h4>
<p>plugin::CallMethod<0x4DBE70, CAECutsceneTrackManager*>(this);</p>
<p>0AA6: call_method 0x4DBE70 struct [CAECutsceneTrackManager] num_params 0 pop 0</p>
<p>define function CAECutsceneTrackManager__PlayPreloadedCutsceneTrack&lt;thiscall, 0x4DBE70&gt;()</p>
<h4>CAECutsceneTrackManager::IsCutsceneTrackActive</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4DBEB0, CAECutsceneTrackManager*>(this);</p>
<p>0AA8: call_method_return 0x4DBEB0 struct [CAECutsceneTrackManager] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAECutsceneTrackManager__IsCutsceneTrackActive&lt;thiscall, 0x4DBEB0&gt;(): int</p>
<h4>CAECutsceneTrackManager::GetCutsceneTrackStatus</h4>
<p>plugin::CallMethodAndReturn<char, 0x4DBEC0, CAECutsceneTrackManager*>(this);</p>
<p>0AA8: call_method_return 0x4DBEC0 struct [CAECutsceneTrackManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CAECutsceneTrackManager__GetCutsceneTrackStatus&lt;thiscall, 0x4DBEC0&gt;(): int</p><h3 id="plugin_sagame_sacaeradiotrackmanagercpp">plugin_sa\game_sa\CAERadioTrackManager.cpp</h3><h4>CAERadioTrackManager::StartRadio</h4>
<p>plugin::CallMethod<0x4EB3C0, CAERadioTrackManager*, int, float, int, char>(this, stationId, bass, arg, unused);</p>
<p>0AA6: call_method 0x4EB3C0 struct [CAERadioTrackManager] num_params 4 pop 0 [stationId] [bass] [arg] [unused]</p>
<p>define function CAERadioTrackManager__StartRadio&lt;thiscall, 0x4EB3C0&gt;(stationId, bass, arg, unused)</p>
<h4>CAERadioTrackManager::StopRadio</h4>
<p>plugin::CallMethod<0x4E9820, CAERadioTrackManager<em>, tVehicleAudioSettings</em>, char>(this, settings, arg);</p>
<p>0AA6: call_method 0x4E9820 struct [CAERadioTrackManager] num_params 2 pop 0 [settings] [arg]</p>
<p>define function CAERadioTrackManager__StopRadio&lt;thiscall, 0x4E9820&gt;(settings, arg)</p><h3 id="plugin_sagame_sacaestreamthreadcpp">plugin_sa\game_sa\CAEStreamThread.cpp</h3><h4>CAEStreamThread::Initialise</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F1680, CAEStreamThread*>(this);</p>
<p>0AA8: call_method_return 0x4F1680 struct [CAEStreamThread] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAEStreamThread__Initialise&lt;thiscall, 0x4F1680&gt;(): int</p>
<h4>CAEStreamThread::GetActiveTrackID</h4>
<p>plugin::CallMethodAndReturn<int, 0x4F1560, CAEStreamThread*>(this);</p>
<p>0AA8: call_method_return 0x4F1560 struct [CAEStreamThread] num_params 0 pop 0 func_ret [int]</p>
<p>define function CAEStreamThread__GetActiveTrackID&lt;thiscall, 0x4F1560&gt;(): int</p><h3 id="plugin_sagame_sacaeweaponaudioentitycpp">plugin_sa\game_sa\CAEWeaponAudioEntity.cpp</h3><h4>CAEWeaponAudioEntity::CAEWeaponAudioEntity</h4>
<p>plugin::CallMethod<0x507560, CAEWeaponAudioEntity *>(this);</p>
<p>0AA6: call_method 0x507560 struct [CAEWeaponAudioEntity] num_params 0 pop 0</p>
<p>define function CAEWeaponAudioEntity__CAEWeaponAudioEntity&lt;thiscall, 0x507560&gt;()</p>
<h4>CAEWeaponAudioEntity::WeaponReload</h4>
<p>plugin::CallMethod<0x503690, CAEWeaponAudioEntity <em>, eWeaponType, CPhysical</em>, int>(this, weaptype, entity, AudioEventId);</p>
<p>0AA6: call_method 0x503690 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [weaptype] [entity] [AudioEventId]</p>
<p>define function CAEWeaponAudioEntity__WeaponReload&lt;thiscall, 0x503690&gt;(weaptype, entity, AudioEventId)</p>
<h4>CAEWeaponAudioEntity::WeaponFire</h4>
<p>plugin::CallMethod<0x504F80, CAEWeaponAudioEntity <em>, eWeaponType, CPhysical</em>, int>(this, weaptype, entity, AudioEventId);</p>
<p>0AA6: call_method 0x504F80 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [weaptype] [entity] [AudioEventId]</p>
<p>define function CAEWeaponAudioEntity__WeaponFire&lt;thiscall, 0x504F80&gt;(weaptype, entity, AudioEventId)</p>
<h4>CAEWeaponAudioEntity::Terminate</h4>
<p>plugin::CallMethod<0x503480, CAEWeaponAudioEntity *>(this);</p>
<p>0AA6: call_method 0x503480 struct [CAEWeaponAudioEntity] num_params 0 pop 0</p>
<p>define function CAEWeaponAudioEntity__Terminate&lt;thiscall, 0x503480&gt;()</p>
<h4>CAEWeaponAudioEntity::StopFlameThrowerIdleGasLoop</h4>
<p>plugin::CallMethod<0x5034E0, CAEWeaponAudioEntity *>(this);</p>
<p>0AA6: call_method 0x5034E0 struct [CAEWeaponAudioEntity] num_params 0 pop 0</p>
<p>define function CAEWeaponAudioEntity__StopFlameThrowerIdleGasLoop&lt;thiscall, 0x5034E0&gt;()</p>
<h4>CAEWeaponAudioEntity::Reset</h4>
<p>plugin::CallMethod<0x503490, CAEWeaponAudioEntity *>(this);</p>
<p>0AA6: call_method 0x503490 struct [CAEWeaponAudioEntity] num_params 0 pop 0</p>
<p>define function CAEWeaponAudioEntity__Reset&lt;thiscall, 0x503490&gt;()</p>
<h4>CAEWeaponAudioEntity::ReportStealthKill</h4>
<p>plugin::CallMethod<0x503B20, CAEWeaponAudioEntity <em>, eWeaponType, CPhysical</em>, int>(this, weaptype, entity, AudioEventId);</p>
<p>0AA6: call_method 0x503B20 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [weaptype] [entity] [AudioEventId]</p>
<p>define function CAEWeaponAudioEntity__ReportStealthKill&lt;thiscall, 0x503B20&gt;(weaptype, entity, AudioEventId)</p>
<h4>CAEWeaponAudioEntity::ReportChainsawEvent</h4>
<p>plugin::CallMethod<0x503910, CAEWeaponAudioEntity <em>, CPhysical</em>, int>(this, entity, AudioEventId);</p>
<p>0AA6: call_method 0x503910 struct [CAEWeaponAudioEntity] num_params 2 pop 0 [entity] [AudioEventId]</p>
<p>define function CAEWeaponAudioEntity__ReportChainsawEvent&lt;thiscall, 0x503910&gt;(entity, AudioEventId)</p>
<h4>CAEWeaponAudioEntity::PlayWeaponLoopSound</h4>
<p>plugin::CallMethod<0x504610, CAEWeaponAudioEntity <em>, CPhysical</em>, short, int, float, float, int>(this, arg0, sfxId, AudioEventId, audability, speed, finalEvent);</p>
<p>0AA6: call_method 0x504610 struct [CAEWeaponAudioEntity] num_params 6 pop 0 [arg0] [sfxId] [AudioEventId] [audability] [speed] [finalEvent]</p>
<p>define function CAEWeaponAudioEntity__PlayWeaponLoopSound&lt;thiscall, 0x504610&gt;(arg0, sfxId, AudioEventId, audability, speed, finalEvent)</p>
<h4>CAEWeaponAudioEntity::PlayMiniGunStopSound</h4>
<p>plugin::CallMethod<0x504960, CAEWeaponAudioEntity <em>, CPhysical</em>>(this, entity);</p>
<p>0AA6: call_method 0x504960 struct [CAEWeaponAudioEntity] num_params 1 pop 0 [entity]</p>
<p>define function CAEWeaponAudioEntity__PlayMiniGunStopSound&lt;thiscall, 0x504960&gt;(entity)</p>
<h4>CAEWeaponAudioEntity::PlayMiniGunFireSounds</h4>
<p>plugin::CallMethod<0x5047C0, CAEWeaponAudioEntity <em>, CPhysical</em>, int>(this, entity, AudioEventId);</p>
<p>0AA6: call_method 0x5047C0 struct [CAEWeaponAudioEntity] num_params 2 pop 0 [entity] [AudioEventId]</p>
<p>define function CAEWeaponAudioEntity__PlayMiniGunFireSounds&lt;thiscall, 0x5047C0&gt;(entity, AudioEventId)</p>
<h4>CAEWeaponAudioEntity::PlayGunSounds</h4>
<p>plugin::CallMethod<0x503CE0, CAEWeaponAudioEntity <em>, CPhysical</em>, short, short, short, short, short, int, float, float, float>(this, entity, emptySfxId, farSfxId2, highPitchSfxId3, lowPitchSfxId4, echoSfxId5, nAudioEventId, volumeChange, speed1, speed2);</p>
<p>0AA6: call_method 0x503CE0 struct [CAEWeaponAudioEntity] num_params 10 pop 0 [entity] [emptySfxId] [farSfxId2] [highPitchSfxId3] [lowPitchSfxId4] [echoSfxId5] [nAudioEventId] [volumeChange] [speed1] [speed2]</p>
<p>define function CAEWeaponAudioEntity__PlayGunSounds&lt;thiscall, 0x503CE0&gt;(entity, emptySfxId, farSfxId2, highPitchSfxId3, lowPitchSfxId4, echoSfxId5, nAudioEventId, volumeChange, speed1, speed2)</p>
<h4>CAEWeaponAudioEntity::PlayGoggleSound</h4>
<p>plugin::CallMethod<0x503500, CAEWeaponAudioEntity *, short, int>(this, sfxId, AudioEventId);</p>
<p>0AA6: call_method 0x503500 struct [CAEWeaponAudioEntity] num_params 2 pop 0 [sfxId] [AudioEventId]</p>
<p>define function CAEWeaponAudioEntity__PlayGoggleSound&lt;thiscall, 0x503500&gt;(sfxId, AudioEventId)</p>
<h4>CAEWeaponAudioEntity::PlayFlameThrowerSounds</h4>
<p>plugin::CallMethod<0x504470, CAEWeaponAudioEntity <em>, CPhysical</em>, short, short, int, float, float>(this, entity, sfx1, sfx2, AudioEventId, audability, speed);</p>
<p>0AA6: call_method 0x504470 struct [CAEWeaponAudioEntity] num_params 6 pop 0 [entity] [sfx1] [sfx2] [AudioEventId] [audability] [speed]</p>
<p>define function CAEWeaponAudioEntity__PlayFlameThrowerSounds&lt;thiscall, 0x504470&gt;(entity, sfx1, sfx2, AudioEventId, audability, speed)</p>
<h4>CAEWeaponAudioEntity::PlayFlameThrowerIdleGasLoop</h4>
<p>plugin::CallMethod<0x503870, CAEWeaponAudioEntity <em>, CPhysical</em>>(this, entity);</p>
<p>0AA6: call_method 0x503870 struct [CAEWeaponAudioEntity] num_params 1 pop 0 [entity]</p>
<p>define function CAEWeaponAudioEntity__PlayFlameThrowerIdleGasLoop&lt;thiscall, 0x503870&gt;(entity)</p>
<h4>CAEWeaponAudioEntity::PlayChainsawStopSound</h4>
<p>plugin::CallMethod<0x504AA0, CAEWeaponAudioEntity <em>, CPhysical</em>>(this, entity);</p>
<p>0AA6: call_method 0x504AA0 struct [CAEWeaponAudioEntity] num_params 1 pop 0 [entity]</p>
<p>define function CAEWeaponAudioEntity__PlayChainsawStopSound&lt;thiscall, 0x504AA0&gt;(entity)</p>
<h4>CAEWeaponAudioEntity::PlayCameraSound</h4>
<p>plugin::CallMethod<0x5046F0, CAEWeaponAudioEntity <em>, CPhysical</em>, int, float>(this, entity, AudioEventId, audability);</p>
<p>0AA6: call_method 0x5046F0 struct [CAEWeaponAudioEntity] num_params 3 pop 0 [entity] [AudioEventId] [audability]</p>
<p>define function CAEWeaponAudioEntity__PlayCameraSound&lt;thiscall, 0x5046F0&gt;(entity, AudioEventId, audability)</p>
<h4>CAEWeaponAudioEntity::Initialise</h4>
<p>plugin::CallMethod<0x503450, CAEWeaponAudioEntity *>(this);</p>
<p>0AA6: call_method 0x503450 struct [CAEWeaponAudioEntity] num_params 0 pop 0</p>
<p>define function CAEWeaponAudioEntity__Initialise&lt;thiscall, 0x503450&gt;()</p><h3 id="plugin_sagame_sacanimatedbuildingcpp">plugin_sa\game_sa\CAnimatedBuilding.cpp</h3><h4>CAnimatedBuilding::CAnimatedBuilding</h4>
<p>plugin::CallMethod<0x537A10, CAnimatedBuilding *>(this);</p>
<p>0AA6: call_method 0x537A10 struct [CAnimatedBuilding] num_params 0 pop 0</p>
<p>define function CAnimatedBuilding__CAnimatedBuilding&lt;thiscall, 0x537A10&gt;()</p><h3 id="plugin_sagame_sacanimblendassocgroupcpp">plugin_sa\game_sa\CAnimBlendAssocGroup.cpp</h3><h4>CAnimBlendAssocGroup::CAnimBlendAssocGroup</h4>
<p>plugin::CallMethod<0x4CDE70, CAnimBlendAssocGroup *>(this);</p>
<p>0AA6: call_method 0x4CDE70 struct [CAnimBlendAssocGroup] num_params 0 pop 0</p>
<p>define function CAnimBlendAssocGroup__CAnimBlendAssocGroup&lt;thiscall, 0x4CDE70&gt;()</p>
<h4>CAnimBlendAssocGroup::CopyAnimation</h4>
<p>plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE0B0, CAnimBlendAssocGroup *, char const*>(this, AnimName);</p>
<p>0AA8: call_method_return 0x4CE0B0 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [AnimName] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimBlendAssocGroup__CopyAnimation&lt;thiscall, 0x4CE0B0&gt;(AnimName): int</p>
<h4>CAnimBlendAssocGroup::CopyAnimation</h4>
<p>plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE130, CAnimBlendAssocGroup *, unsigned int>(this, ID);</p>
<p>0AA8: call_method_return 0x4CE130 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [ID] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimBlendAssocGroup__CopyAnimation&lt;thiscall, 0x4CE130&gt;(ID): int</p>
<h4>CAnimBlendAssocGroup::CreateAssociations</h4>
<p>plugin::CallMethod<0x4CE220, CAnimBlendAssocGroup <em>, char const</em>>(this, szBlockName);</p>
<p>0AA6: call_method 0x4CE220 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [szBlockName]</p>
<p>define function CAnimBlendAssocGroup__CreateAssociations&lt;thiscall, 0x4CE220&gt;(szBlockName)</p>
<h4>CAnimBlendAssocGroup::CreateAssociations</h4>
<p>plugin::CallMethod<0x4CE6E0, CAnimBlendAssocGroup <em>, char const</em>, RpClump<em>, char</em>*, int>(this, AnimName, pClump, arg3, NumAnimations);</p>
<p>0AA6: call_method 0x4CE6E0 struct [CAnimBlendAssocGroup] num_params 4 pop 0 [AnimName] [pClump] [arg3] [NumAnimations]</p>
<p>define function CAnimBlendAssocGroup__CreateAssociations&lt;thiscall, 0x4CE6E0&gt;(AnimName, pClump, arg3, NumAnimations)</p>
<h4>CAnimBlendAssocGroup::CreateAssociations</h4>
<p>plugin::CallMethod<0x4CE3B0, CAnimBlendAssocGroup <em>, char const</em>, char const<em>, char const</em>, int>(this, AnimName, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x4CE3B0 struct [CAnimBlendAssocGroup] num_params 4 pop 0 [AnimName] [arg2] [arg3] [arg4]</p>
<p>define function CAnimBlendAssocGroup__CreateAssociations&lt;thiscall, 0x4CE3B0&gt;(AnimName, arg2, arg3, arg4)</p>
<h4>CAnimBlendAssocGroup::DestroyAssociations</h4>
<p>plugin::CallMethod<0x4CDFF0, CAnimBlendAssocGroup *>(this);</p>
<p>0AA6: call_method 0x4CDFF0 struct [CAnimBlendAssocGroup] num_params 0 pop 0</p>
<p>define function CAnimBlendAssocGroup__DestroyAssociations&lt;thiscall, 0x4CDFF0&gt;()</p>
<h4>CAnimBlendAssocGroup::GetAnimation</h4>
<p>plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE040, CAnimBlendAssocGroup *, char const*>(this, AnimName);</p>
<p>0AA8: call_method_return 0x4CE040 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [AnimName] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimBlendAssocGroup__GetAnimation&lt;thiscall, 0x4CE040&gt;(AnimName): int</p>
<h4>CAnimBlendAssocGroup::GetAnimation</h4>
<p>plugin::CallMethodAndReturn<CAnimBlendAssociation*, 0x4CE090, CAnimBlendAssocGroup *, unsigned int>(this, ID);</p>
<p>0AA8: call_method_return 0x4CE090 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [ID] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimBlendAssocGroup__GetAnimation&lt;thiscall, 0x4CE090&gt;(ID): int</p>
<h4>CAnimBlendAssocGroup::GetAnimationId</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x4CE1B0, CAnimBlendAssocGroup *, char const*>(this, AnimName);</p>
<p>0AA8: call_method_return 0x4CE1B0 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [AnimName] func_ret [unsigned int]</p>
<p>define function CAnimBlendAssocGroup__GetAnimationId&lt;thiscall, 0x4CE1B0&gt;(AnimName): int</p>
<h4>CAnimBlendAssocGroup::InitEmptyAssociations</h4>
<p>plugin::CallMethod<0x4CDFB0, CAnimBlendAssocGroup <em>, RpClump</em>>(this, pClump);</p>
<p>0AA6: call_method 0x4CDFB0 struct [CAnimBlendAssocGroup] num_params 1 pop 0 [pClump]</p>
<p>define function CAnimBlendAssocGroup__InitEmptyAssociations&lt;thiscall, 0x4CDFB0&gt;(pClump)</p>
<h4>CAnimBlendAssocGroup::~CAnimBlendAssocGroup</h4>
<p>plugin::CallMethod<0x4CE1D0, CAnimBlendAssocGroup *>(this);</p>
<p>0AA6: call_method 0x4CE1D0 struct [CAnimBlendAssocGroup] num_params 0 pop 0</p>
<p>define function CAnimBlendAssocGroup__~CAnimBlendAssocGroup&lt;thiscall, 0x4CE1D0&gt;()</p><h3 id="plugin_sagame_sacanimblendassociationcpp">plugin_sa\game_sa\CAnimBlendAssociation.cpp</h3><h4>CAnimBlendAssociation::AllocateAnimBlendNodeArray</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::AllocateAnimBlendNodeArray), this, count);</p>
<p>0AA6: call_method 0x4CE9F0 struct [CAnimBlendAssociation] num_params 1 pop 0 [count]</p>
<p>define function CAnimBlendAssociation__AllocateAnimBlendNodeArray&lt;thiscall, 0x4CE9F0&gt;(count)</p>
<h4>CAnimBlendAssociation::FreeAnimBlendNodeArray</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::FreeAnimBlendNodeArray), this);</p>
<p>0AA6: call_method 0x4CEA40 struct [CAnimBlendAssociation] num_params 0 pop 0</p>
<p>define function CAnimBlendAssociation__FreeAnimBlendNodeArray&lt;thiscall, 0x4CEA40&gt;()</p>
<h4>*CAnimBlendAssociation::GetNode</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CAnimBlendNode *, CAnimBlendAssociation *, int>(gaddrof(CAnimBlendAssociation::GetNode), this, nodeIndex);</p>
<p>0AA8: call_method_return 0x4CEB60 struct [*CAnimBlendAssociation] num_params 1 pop 0 [nodeIndex] func_ret [CAnimBlendNode *]</p>
<h4>CAnimBlendAssociation::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(RpClump *, CAnimBlendHierarchy *)), this, clump, hierarchy);</p>
<p>0AA6: call_method 0x4CEEC0 struct [CAnimBlendAssociation] num_params 2 pop 0 [clump] [hierarchy]</p>
<p>define function CAnimBlendAssociation__Init&lt;thiscall, 0x4CEEC0&gt;(clump, hierarchy)</p>
<h4>CAnimBlendAssociation::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendAssociation &amp;)), this, source);</p>
<p>0AA6: call_method 0x4CEEC0 struct [CAnimBlendAssociation] num_params 1 pop 0 [source]</p>
<p>define function CAnimBlendAssociation__Init&lt;thiscall, 0x4CEEC0&gt;(source)</p>
<h4>CAnimBlendAssociation::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendStaticAssociation &>(gaddrof_o(CAnimBlendAssociation::Init, void (CAnimBlendAssociation::*)(CAnimBlendStaticAssociation &amp;)), this, source);</p>
<p>0AA6: call_method 0x4CEEC0 struct [CAnimBlendAssociation] num_params 1 pop 0 [source]</p>
<p>define function CAnimBlendAssociation__Init&lt;thiscall, 0x4CEEC0&gt;(source)</p>
<h4>CAnimBlendAssociation::ReferenceAnimBlock</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::ReferenceAnimBlock), this);</p>
<p>0AA6: call_method 0x4CEA50 struct [CAnimBlendAssociation] num_params 0 pop 0</p>
<p>define function CAnimBlendAssociation__ReferenceAnimBlock&lt;thiscall, 0x4CEA50&gt;()</p>
<h4>CAnimBlendAssociation::SetBlend</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlend), this, blendAmount, blendDelta);</p>
<p>0AA6: call_method 0x4CEBA0 struct [CAnimBlendAssociation] num_params 2 pop 0 [blendAmount] [blendDelta]</p>
<p>define function CAnimBlendAssociation__SetBlend&lt;thiscall, 0x4CEBA0&gt;(blendAmount, blendDelta)</p>
<h4>CAnimBlendAssociation::SetBlendTo</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::SetBlendTo), this, blendAmount, blendDelta);</p>
<p>0AA6: call_method 0x4CEB80 struct [CAnimBlendAssociation] num_params 2 pop 0 [blendAmount] [blendDelta]</p>
<p>define function CAnimBlendAssociation__SetBlendTo&lt;thiscall, 0x4CEB80&gt;(blendAmount, blendDelta)</p>
<h4>CAnimBlendAssociation::SetCurrentTime</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::SetCurrentTime), this, currentTime);</p>
<p>0AA6: call_method 0x4CEA80 struct [CAnimBlendAssociation] num_params 1 pop 0 [currentTime]</p>
<p>define function CAnimBlendAssociation__SetCurrentTime&lt;thiscall, 0x4CEA80&gt;(currentTime)</p>
<h4>CAnimBlendAssociation::SetDeleteCallback</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetDeleteCallback), this, callback, data);</p>
<p>0AA6: call_method 0x4CEBC0 struct [CAnimBlendAssociation] num_params 2 pop 0 [callback] [data]</p>
<p>define function CAnimBlendAssociation__SetDeleteCallback&lt;thiscall, 0x4CEBC0&gt;(callback, data)</p>
<h4>CAnimBlendAssociation::SetFinishCallback</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, void(*)(CAnimBlendAssociation *, void *), void *>(gaddrof(CAnimBlendAssociation::SetFinishCallback), this, callback, data);</p>
<p>0AA6: call_method 0x4CEBE0 struct [CAnimBlendAssociation] num_params 2 pop 0 [callback] [data]</p>
<p>define function CAnimBlendAssociation__SetFinishCallback&lt;thiscall, 0x4CEBE0&gt;(callback, data)</p>
<h4>CAnimBlendAssociation::Start</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::Start), this, currentTime);</p>
<p>0AA6: call_method 0x4CEB70 struct [CAnimBlendAssociation] num_params 1 pop 0 [currentTime]</p>
<p>define function CAnimBlendAssociation__Start&lt;thiscall, 0x4CEB70&gt;(currentTime)</p>
<h4>CAnimBlendAssociation::SyncAnimation</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation *>(gaddrof(CAnimBlendAssociation::SyncAnimation), this, syncWith);</p>
<p>0AA6: call_method 0x4CEB40 struct [CAnimBlendAssociation] num_params 1 pop 0 [syncWith]</p>
<p>define function CAnimBlendAssociation__SyncAnimation&lt;thiscall, 0x4CEB40&gt;(syncWith)</p>
<h4>CAnimBlendAssociation::UpdateBlend</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float>(gaddrof(CAnimBlendAssociation::UpdateBlend), this, blendDeltaMult);</p>
<p>0AA8: call_method_return 0x4D1490 struct [CAnimBlendAssociation] num_params 1 pop 0 [blendDeltaMult] func_ret [bool]</p>
<h4>CAnimBlendAssociation::UpdateTime</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTime), this, unused1, unused2);</p>
<p>0AA8: call_method_return 0x4D13D0 struct [CAnimBlendAssociation] num_params 2 pop 0 [unused1] [unused2] func_ret [bool]</p>
<h4>CAnimBlendAssociation::UpdateTimeStep</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, float, float>(gaddrof(CAnimBlendAssociation::UpdateTimeStep), this, speedMult, timeMult);</p>
<p>0AA6: call_method 0x4D13A0 struct [CAnimBlendAssociation] num_params 2 pop 0 [speedMult] [timeMult]</p>
<p>define function CAnimBlendAssociation__UpdateTimeStep&lt;thiscall, 0x4D13A0&gt;(speedMult, timeMult)</p><h3 id="plugin_sagame_sacanimblendclumpdatacpp">plugin_sa\game_sa\CAnimBlendClumpData.cpp</h3><h4>CAnimBlendClumpData::CAnimBlendClumpData</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(ctor_gaddr(CAnimBlendClumpData), this);</p>
<h4>CAnimBlendClumpData::~CAnimBlendClumpData</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(dtor_gaddr(CAnimBlendClumpData), this);</p>
<h4>CAnimBlendClumpData::ForAllFrames</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *>(gaddrof(CAnimBlendClumpData::ForAllFrames), this, callback, data);</p>
<p>0AA6: call_method 0x4CF190 struct [CAnimBlendClumpData] num_params 2 pop 0 [callback] [data]</p>
<p>define function CAnimBlendClumpData__ForAllFrames&lt;thiscall, 0x4CF190&gt;(callback, data)</p>
<h4>CAnimBlendClumpData::ForAllFramesInSPR</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *, void(*)(AnimBlendFrameData *, void *), void *, unsigned int>(gaddrof(CAnimBlendClumpData::ForAllFramesInSPR), this, callback, data, a3);</p>
<p>0AA6: call_method 0x4CF1E0 struct [CAnimBlendClumpData] num_params 3 pop 0 [callback] [data] [a3]</p>
<p>define function CAnimBlendClumpData__ForAllFramesInSPR&lt;thiscall, 0x4CF1E0&gt;(callback, data, a3)</p>
<h4>CAnimBlendClumpData::LoadFramesIntoSPR</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *>(gaddrof(CAnimBlendClumpData::LoadFramesIntoSPR), this);</p>
<p>0AA6: call_method 0x4CF1D0 struct [CAnimBlendClumpData] num_params 0 pop 0</p>
<p>define function CAnimBlendClumpData__LoadFramesIntoSPR&lt;thiscall, 0x4CF1D0&gt;()</p>
<h4>CAnimBlendClumpData::SetNumberOfBones</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendClumpData *, int>(gaddrof(CAnimBlendClumpData::SetNumberOfBones), this, numBones);</p>
<p>0AA6: call_method 0x4CF140 struct [CAnimBlendClumpData] num_params 1 pop 0 [numBones]</p>
<p>define function CAnimBlendClumpData__SetNumberOfBones&lt;thiscall, 0x4CF140&gt;(numBones)</p><h3 id="plugin_sagame_sacanimblendhierarchycpp">plugin_sa\game_sa\CAnimBlendHierarchy.cpp</h3><h4>CAnimBlendHierarchy::AllocSequenceBlock</h4>
<p>plugin::CallMethodAndReturn<void*, 0x4CF510, CAnimBlendHierarchy *, bool>(this, arg1);</p>
<p>0AA8: call_method_return 0x4CF510 struct [CAnimBlendHierarchy] num_params 1 pop 0 [arg1] func_ret [void*]</p>
<p>define function CAnimBlendHierarchy__AllocSequenceBlock&lt;thiscall, 0x4CF510&gt;(arg1): int</p>
<h4>CAnimBlendHierarchy::CAnimBlendHierarchy</h4>
<p>plugin::CallMethod<0x4CF270, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF270 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__CAnimBlendHierarchy&lt;thiscall, 0x4CF270&gt;()</p>
<h4>CAnimBlendHierarchy::CalcTotalTime</h4>
<p>plugin::CallMethod<0x4CF2F0, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF2F0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__CalcTotalTime&lt;thiscall, 0x4CF2F0&gt;()</p>
<h4>CAnimBlendHierarchy::CalcTotalTimeCompressed</h4>
<p>plugin::CallMethod<0x4CF3E0, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF3E0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__CalcTotalTimeCompressed&lt;thiscall, 0x4CF3E0&gt;()</p>
<h4>CAnimBlendHierarchy::RemoveAnimSequences</h4>
<p>plugin::CallMethod<0x4CF8E0, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF8E0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__RemoveAnimSequences&lt;thiscall, 0x4CF8E0&gt;()</p>
<h4>CAnimBlendHierarchy::RemoveQuaternionFlips</h4>
<p>plugin::CallMethod<0x4CF4E0, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF4E0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__RemoveQuaternionFlips&lt;thiscall, 0x4CF4E0&gt;()</p>
<h4>CAnimBlendHierarchy::RemoveUncompressedData</h4>
<p>plugin::CallMethod<0x4CF760, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF760 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__RemoveUncompressedData&lt;thiscall, 0x4CF760&gt;()</p>
<h4>CAnimBlendHierarchy::SetName</h4>
<p>plugin::CallMethod<0x4CF2D0, CAnimBlendHierarchy <em>, char const</em>>(this, string);</p>
<p>0AA6: call_method 0x4CF2D0 struct [CAnimBlendHierarchy] num_params 1 pop 0 [string]</p>
<p>define function CAnimBlendHierarchy__SetName&lt;thiscall, 0x4CF2D0&gt;(string)</p>
<h4>CAnimBlendHierarchy::Shutdown</h4>
<p>plugin::CallMethod<0x4CF980, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF980 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__Shutdown&lt;thiscall, 0x4CF980&gt;()</p>
<h4>CAnimBlendHierarchy::Uncompress</h4>
<p>plugin::CallMethod<0x4CF5F0, CAnimBlendHierarchy *>(this);</p>
<p>0AA6: call_method 0x4CF5F0 struct [CAnimBlendHierarchy] num_params 0 pop 0</p>
<p>define function CAnimBlendHierarchy__Uncompress&lt;thiscall, 0x4CF5F0&gt;()</p><h3 id="plugin_sagame_sacanimblendnodecpp">plugin_sa\game_sa\CAnimBlendNode.cpp</h3><h4>CAnimBlendNode::CalcDeltas</h4>
<p>plugin::CallMethod<0x4D0190, CAnimBlendNode *>(this);</p>
<p>0AA6: call_method 0x4D0190 struct [CAnimBlendNode] num_params 0 pop 0</p>
<p>define function CAnimBlendNode__CalcDeltas&lt;thiscall, 0x4D0190&gt;()</p>
<h4>CAnimBlendNode::CalcDeltasCompressed</h4>
<p>plugin::CallMethod<0x4D0350, CAnimBlendNode *>(this);</p>
<p>0AA6: call_method 0x4D0350 struct [CAnimBlendNode] num_params 0 pop 0</p>
<p>define function CAnimBlendNode__CalcDeltasCompressed&lt;thiscall, 0x4D0350&gt;()</p>
<h4>CAnimBlendNode::FindKeyFrame</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D0240, CAnimBlendNode *, float>(this, arg1);</p>
<p>0AA8: call_method_return 0x4D0240 struct [CAnimBlendNode] num_params 1 pop 0 [arg1] func_ret [bool]</p>
<p>define function CAnimBlendNode__FindKeyFrame&lt;thiscall, 0x4D0240&gt;(arg1): int</p>
<h4>CAnimBlendNode::GetCurrentTranslation</h4>
<p>plugin::CallMethod<0x4CFC50, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);</p>
<p>0AA6: call_method 0x4CFC50 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]</p>
<p>define function CAnimBlendNode__GetCurrentTranslation&lt;thiscall, 0x4CFC50&gt;(Vector, arg2)</p>
<h4>CAnimBlendNode::GetCurrentTranslationCompressed</h4>
<p>plugin::CallMethod<0x4CFE60, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);</p>
<p>0AA6: call_method 0x4CFE60 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]</p>
<p>define function CAnimBlendNode__GetCurrentTranslationCompressed&lt;thiscall, 0x4CFE60&gt;(Vector, arg2)</p>
<h4>CAnimBlendNode::GetEndTranslation</h4>
<p>plugin::CallMethod<0x4CFD90, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);</p>
<p>0AA6: call_method 0x4CFD90 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]</p>
<p>define function CAnimBlendNode__GetEndTranslation&lt;thiscall, 0x4CFD90&gt;(Vector, arg2)</p>
<h4>CAnimBlendNode::GetEndTranslationCompressed</h4>
<p>plugin::CallMethod<0x4D0000, CAnimBlendNode *, CVector&, float>(this, Vector, arg2);</p>
<p>0AA6: call_method 0x4D0000 struct [CAnimBlendNode] num_params 2 pop 0 [Vector] [arg2]</p>
<p>define function CAnimBlendNode__GetEndTranslationCompressed&lt;thiscall, 0x4D0000&gt;(Vector, arg2)</p>
<h4>CAnimBlendNode::Init</h4>
<p>plugin::CallMethod<0x4CFB70, CAnimBlendNode *>(this);</p>
<p>0AA6: call_method 0x4CFB70 struct [CAnimBlendNode] num_params 0 pop 0</p>
<p>define function CAnimBlendNode__Init&lt;thiscall, 0x4CFB70&gt;()</p>
<h4>CAnimBlendNode::NextKeyFrame</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D04A0, CAnimBlendNode *>(this);</p>
<p>0AA8: call_method_return 0x4D04A0 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAnimBlendNode__NextKeyFrame&lt;thiscall, 0x4D04A0&gt;(): int</p>
<h4>CAnimBlendNode::NextKeyFrameCompressed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D0570, CAnimBlendNode *>(this);</p>
<p>0AA8: call_method_return 0x4D0570 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAnimBlendNode__NextKeyFrameCompressed&lt;thiscall, 0x4D0570&gt;(): int</p>
<h4>CAnimBlendNode::NextKeyFrameNoCalc</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4CFB90, CAnimBlendNode *>(this);</p>
<p>0AA8: call_method_return 0x4CFB90 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAnimBlendNode__NextKeyFrameNoCalc&lt;thiscall, 0x4CFB90&gt;(): int</p>
<h4>CAnimBlendNode::SetupKeyFrameCompressed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D0650, CAnimBlendNode *>(this);</p>
<p>0AA8: call_method_return 0x4D0650 struct [CAnimBlendNode] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAnimBlendNode__SetupKeyFrameCompressed&lt;thiscall, 0x4D0650&gt;(): int</p>
<h4>CAnimBlendNode::Update</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D06C0, CAnimBlendNode *, CVector&, CQuaternion&, float>(this, Vector, Qauternion, arg3);</p>
<p>0AA8: call_method_return 0x4D06C0 struct [CAnimBlendNode] num_params 3 pop 0 [Vector] [Qauternion] [arg3] func_ret [bool]</p>
<p>define function CAnimBlendNode__Update&lt;thiscall, 0x4D06C0&gt;(Vector, Qauternion, arg3): int</p>
<h4>CAnimBlendNode::UpdateCompressed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D08D0, CAnimBlendNode *, CVector&, CQuaternion&, float>(this, Vector, Quaternion, arg3);</p>
<p>0AA8: call_method_return 0x4D08D0 struct [CAnimBlendNode] num_params 3 pop 0 [Vector] [Quaternion] [arg3] func_ret [bool]</p>
<p>define function CAnimBlendNode__UpdateCompressed&lt;thiscall, 0x4D08D0&gt;(Vector, Quaternion, arg3): int</p><h3 id="plugin_sagame_sacanimblendsequencecpp">plugin_sa\game_sa\CAnimBlendSequence.cpp</h3><h4>CAnimBlendSequence::CAnimBlendSequence</h4>
<p>plugin::CallMethod<0x4D0C10, CAnimBlendSequence *>(this);</p>
<p>0AA6: call_method 0x4D0C10 struct [CAnimBlendSequence] num_params 0 pop 0</p>
<p>define function CAnimBlendSequence__CAnimBlendSequence&lt;thiscall, 0x4D0C10&gt;()</p>
<h4>CAnimBlendSequence::CompressKeyframes</h4>
<p>plugin::CallMethod<0x4D0F40, CAnimBlendSequence <em>, unsigned char</em>>(this, arg1);</p>
<p>0AA6: call_method 0x4D0F40 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1]</p>
<p>define function CAnimBlendSequence__CompressKeyframes&lt;thiscall, 0x4D0F40&gt;(arg1)</p>
<h4>CAnimBlendSequence::GetDataSize</h4>
<p>plugin::CallMethodAndReturn<int, 0x4D0C90, CAnimBlendSequence *, bool>(this, arg1);</p>
<p>0AA8: call_method_return 0x4D0C90 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1] func_ret [int]</p>
<p>define function CAnimBlendSequence__GetDataSize&lt;thiscall, 0x4D0C90&gt;(arg1): int</p>
<h4>CAnimBlendSequence::MoveMemorY</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1150, CAnimBlendSequence *>(this);</p>
<p>0AA8: call_method_return 0x4D1150 struct [CAnimBlendSequence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAnimBlendSequence__MoveMemorY&lt;thiscall, 0x4D1150&gt;(): int</p>
<h4>CAnimBlendSequence::RemoveQuaternionFlips</h4>
<p>plugin::CallMethodAndReturn<int, 0x4D1190, CAnimBlendSequence *>(this);</p>
<p>0AA8: call_method_return 0x4D1190 struct [CAnimBlendSequence] num_params 0 pop 0 func_ret [int]</p>
<p>define function CAnimBlendSequence__RemoveQuaternionFlips&lt;thiscall, 0x4D1190&gt;(): int</p>
<h4>CAnimBlendSequence::RemoveUncompressedData</h4>
<p>plugin::CallMethod<0x4D12A0, CAnimBlendSequence <em>, unsigned char</em>>(this, arg1);</p>
<p>0AA6: call_method 0x4D12A0 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1]</p>
<p>define function CAnimBlendSequence__RemoveUncompressedData&lt;thiscall, 0x4D12A0&gt;(arg1)</p>
<h4>CAnimBlendSequence::SetBoneTag</h4>
<p>plugin::CallMethod<0x4D0C70, CAnimBlendSequence *, int>(this, hash);</p>
<p>0AA6: call_method 0x4D0C70 struct [CAnimBlendSequence] num_params 1 pop 0 [hash]</p>
<p>define function CAnimBlendSequence__SetBoneTag&lt;thiscall, 0x4D0C70&gt;(hash)</p>
<h4>CAnimBlendSequence::SetName</h4>
<p>plugin::CallMethod<0x4D0C50, CAnimBlendSequence <em>, char const</em>>(this, string);</p>
<p>0AA6: call_method 0x4D0C50 struct [CAnimBlendSequence] num_params 1 pop 0 [string]</p>
<p>define function CAnimBlendSequence__SetName&lt;thiscall, 0x4D0C50&gt;(string)</p>
<h4>CAnimBlendSequence::SetNumFrames</h4>
<p>plugin::CallMethod<0x4D0CD0, CAnimBlendSequence <em>, int, bool, bool, unsigned char</em>>(this, count, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x4D0CD0 struct [CAnimBlendSequence] num_params 4 pop 0 [count] [arg2] [arg3] [arg4]</p>
<p>define function CAnimBlendSequence__SetNumFrames&lt;thiscall, 0x4D0CD0&gt;(count, arg2, arg3, arg4)</p>
<h4>CAnimBlendSequence::Uncompress</h4>
<p>plugin::CallMethod<0x4D0D40, CAnimBlendSequence <em>, unsigned char</em>>(this, arg1);</p>
<p>0AA6: call_method 0x4D0D40 struct [CAnimBlendSequence] num_params 1 pop 0 [arg1]</p>
<p>define function CAnimBlendSequence__Uncompress&lt;thiscall, 0x4D0D40&gt;(arg1)</p>
<h4>CAnimBlendSequence::~CAnimBlendSequence</h4>
<p>plugin::CallMethod<0x4D0C30, CAnimBlendSequence *>(this);</p>
<p>0AA6: call_method 0x4D0C30 struct [CAnimBlendSequence] num_params 0 pop 0</p>
<p>define function CAnimBlendSequence__~CAnimBlendSequence&lt;thiscall, 0x4D0C30&gt;()</p><h3 id="plugin_sagame_sacanimblendstaticassociationcpp">plugin_sa\game_sa\CAnimBlendStaticAssociation.cpp</h3><h4>CAnimBlendStaticAssociation::AllocateSequenceArray</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, int>(gaddrof(CAnimBlendStaticAssociation::AllocateSequenceArray), this, count);</p>
<p>0AA6: call_method 0x4CE960 struct [CAnimBlendStaticAssociation] num_params 1 pop 0 [count]</p>
<p>define function CAnimBlendStaticAssociation__AllocateSequenceArray&lt;thiscall, 0x4CE960&gt;(count)</p>
<h4>CAnimBlendStaticAssociation::FreeSequenceArray</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(gaddrof(CAnimBlendStaticAssociation::FreeSequenceArray), this);</p>
<p>0AA6: call_method 0x4CE9A0 struct [CAnimBlendStaticAssociation] num_params 0 pop 0</p>
<p>define function CAnimBlendStaticAssociation__FreeSequenceArray&lt;thiscall, 0x4CE9A0&gt;()</p>
<h4>CAnimBlendStaticAssociation::Init</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(gaddrof(CAnimBlendStaticAssociation::Init), this, clump, hierarchy);</p>
<p>0AA6: call_method 0x4CEC20 struct [CAnimBlendStaticAssociation] num_params 2 pop 0 [clump] [hierarchy]</p>
<p>define function CAnimBlendStaticAssociation__Init&lt;thiscall, 0x4CEC20&gt;(clump, hierarchy)</p><h3 id="plugin_sagame_sacanimmanagercpp">plugin_sa\game_sa\CAnimManager.cpp</h3><h4>CAnimManager::GetAnimationBlock</h4>
<p>plugin::CallAndReturn<CAnimBlock<em>, 0x4D3940, char const</em>>(name);</p>
<p>0AA7: call_function_return 0x4D3940 num_params 1 pop 1 [name] func_ret [CAnimBlock*]</p>
<p>define function CAnimManager__GetAnimationBlock&lt;cdecl, 0x4D3940&gt;(name): int</p>
<h4>CAnimManager::GetAnimationBlockIndex</h4>
<p>plugin::CallAndReturn<int, 0x4D3990, char const*>(name);</p>
<p>0AA7: call_function_return 0x4D3990 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CAnimManager__GetAnimationBlockIndex&lt;cdecl, 0x4D3990&gt;(name): int</p>
<h4>CAnimManager::GetFirstAssocGroup</h4>
<p>plugin::CallAndReturn<int, 0x4D39B0, char const*>(basename);</p>
<p>0AA7: call_function_return 0x4D39B0 num_params 1 pop 1 [basename] func_ret [int]</p>
<p>define function CAnimManager__GetFirstAssocGroup&lt;cdecl, 0x4D39B0&gt;(basename): int</p>
<h4>CAnimManager::GetAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendHierarchy<em>, 0x4D39F0, unsigned int, CAnimBlock const</em>>(hash, ifp);</p>
<p>0AA7: call_function_return 0x4D39F0 num_params 2 pop 2 [hash] [ifp] func_ret [CAnimBlendHierarchy*]</p>
<p>define function CAnimManager__GetAnimation&lt;cdecl, 0x4D39F0&gt;(hash, ifp): int</p>
<h4>CAnimManager::GetAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendHierarchy<em>, 0x4D42F0, char const</em>, CAnimBlock const*>(animName, ifp);</p>
<p>0AA7: call_function_return 0x4D42F0 num_params 2 pop 2 [animName] [ifp] func_ret [CAnimBlendHierarchy*]</p>
<p>define function CAnimManager__GetAnimation&lt;cdecl, 0x4D42F0&gt;(animName, ifp): int</p>
<h4>CAnimManager::GetAnimGroupName</h4>
<p>plugin::CallAndReturn<char*, 0x4D3A20, int>(AssocGroupId);</p>
<p>0AA7: call_function_return 0x4D3A20 num_params 1 pop 1 [AssocGroupId] func_ret [char*]</p>
<p>define function CAnimManager__GetAnimGroupName&lt;cdecl, 0x4D3A20&gt;(AssocGroupId): int</p>
<h4>CAnimManager::GetAnimBlockName</h4>
<p>plugin::CallAndReturn<char*, 0x4D3A30, int>(AssocGroupId);</p>
<p>0AA7: call_function_return 0x4D3A30 num_params 1 pop 1 [AssocGroupId] func_ret [char*]</p>
<p>define function CAnimManager__GetAnimBlockName&lt;cdecl, 0x4D3A30&gt;(AssocGroupId): int</p>
<h4>CAnimManager::CreateAnimAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation*, 0x4D3A40, int, int>(AssocGroupId, AnimationId);</p>
<p>0AA7: call_function_return 0x4D3A40 num_params 2 pop 2 [AssocGroupId] [AnimationId] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__CreateAnimAssociation&lt;cdecl, 0x4D3A40&gt;(AssocGroupId, AnimationId): int</p>
<h4>CAnimManager::GetAnimAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendStaticAssociation*, 0x4D3A60, int, int>(AssocGroupId, AnimationId);</p>
<p>0AA7: call_function_return 0x4D3A60 num_params 2 pop 2 [AssocGroupId] [AnimationId] func_ret [CAnimBlendStaticAssociation*]</p>
<p>define function CAnimManager__GetAnimAssociation&lt;cdecl, 0x4D3A60&gt;(AssocGroupId, AnimationId): int</p>
<h4>CAnimManager::GetAnimAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendStaticAssociation<em>, 0x4D3A80, int, char const</em>>(AssocGroupId, arg2);</p>
<p>0AA7: call_function_return 0x4D3A80 num_params 2 pop 2 [AssocGroupId] [arg2] func_ret [CAnimBlendStaticAssociation*]</p>
<p>define function CAnimManager__GetAnimAssociation&lt;cdecl, 0x4D3A80&gt;(AssocGroupId, arg2): int</p>
<h4>CAnimManager::AddAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D3AA0, RpClump</em>, int, int>(clump, AssocGroupId, AnimationId);</p>
<p>0AA7: call_function_return 0x4D3AA0 num_params 3 pop 3 [clump] [AssocGroupId] [AnimationId] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__AddAnimation&lt;cdecl, 0x4D3AA0&gt;(clump, AssocGroupId, AnimationId): int</p>
<h4>CAnimManager::AddAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D4330, RpClump</em>, CAnimBlendHierarchy*, int>(clump, pAnimBlendHier, clumpAssocFlag);</p>
<p>0AA7: call_function_return 0x4D4330 num_params 3 pop 3 [clump] [pAnimBlendHier] [clumpAssocFlag] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__AddAnimation&lt;cdecl, 0x4D4330&gt;(clump, pAnimBlendHier, clumpAssocFlag): int</p>
<h4>CAnimManager::AddAnimationAndSync</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D3B30, RpClump</em>, CAnimBlendAssociation*, int, int>(clump, pAnimBlendAssoc, AssocGroupId, AnimationId);</p>
<p>0AA7: call_function_return 0x4D3B30 num_params 4 pop 4 [clump] [pAnimBlendAssoc] [AssocGroupId] [AnimationId] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__AddAnimationAndSync&lt;cdecl, 0x4D3B30&gt;(clump, pAnimBlendAssoc, AssocGroupId, AnimationId): int</p>
<h4>CAnimManager::AddAnimAssocDefinition</h4>
<p>plugin::CallAndReturn<CAnimationStyleDescriptor<em>, 0x4D3BA0, char const</em>, char const<em>, unsigned int, unsigned int, void</em>>(groupName, blockName, arg3, animsCount, pAnimDescriptor);</p>
<p>0AA7: call_function_return 0x4D3BA0 num_params 5 pop 5 [groupName] [blockName] [arg3] [animsCount] [pAnimDescriptor] func_ret [CAnimationStyleDescriptor*]</p>
<p>define function CAnimManager__AddAnimAssocDefinition&lt;cdecl, 0x4D3BA0&gt;(groupName, blockName, arg3, animsCount, pAnimDescriptor): int</p>
<h4>CAnimManager::AddAnimToAssocDefinition</h4>
<p>plugin::CallAndReturn<void<em>, 0x4D3C80, void</em>, char const*>(pAnimAssocDefinition, arg2);</p>
<p>0AA7: call_function_return 0x4D3C80 num_params 2 pop 2 [pAnimAssocDefinition] [arg2] func_ret [void*]</p>
<p>define function CAnimManager__AddAnimToAssocDefinition&lt;cdecl, 0x4D3C80&gt;(pAnimAssocDefinition, arg2): int</p>
<h4>CAnimManager::CreateAnimAssocGroups</h4>
<p>plugin::Call<0x4D3CC0>();</p>
<p>0AA5: call_function 0x4D3CC0 num_params 0 pop 0</p>
<p>define function CAnimManager__CreateAnimAssocGroups&lt;cdecl, 0x4D3CC0&gt;()</p>
<h4>CAnimManager::RegisterAnimBlock</h4>
<p>plugin::CallAndReturn<int, 0x4D3E50, char const*>(name);</p>
<p>0AA7: call_function_return 0x4D3E50 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CAnimManager__RegisterAnimBlock&lt;cdecl, 0x4D3E50&gt;(name): int</p>
<h4>CAnimManager::RemoveLastAnimFile</h4>
<p>plugin::Call<0x4D3ED0>();</p>
<p>0AA5: call_function 0x4D3ED0 num_params 0 pop 0</p>
<p>define function CAnimManager__RemoveLastAnimFile&lt;cdecl, 0x4D3ED0&gt;()</p>
<h4>CAnimManager::RemoveAnimBlock</h4>
<p>plugin::Call<0x4D3F40, int>(index);</p>
<p>0AA5: call_function 0x4D3F40 num_params 1 pop 1 [index]</p>
<p>define function CAnimManager__RemoveAnimBlock&lt;cdecl, 0x4D3F40&gt;(index)</p>
<h4>CAnimManager::AddAnimBlockRef</h4>
<p>plugin::Call<0x4D3FB0, int>(index);</p>
<p>0AA5: call_function 0x4D3FB0 num_params 1 pop 1 [index]</p>
<p>define function CAnimManager__AddAnimBlockRef&lt;cdecl, 0x4D3FB0&gt;(index)</p>
<h4>CAnimManager::RemoveAnimBlockRef</h4>
<p>plugin::Call<0x4D3FD0, int>(index);</p>
<p>0AA5: call_function 0x4D3FD0 num_params 1 pop 1 [index]</p>
<p>define function CAnimManager__RemoveAnimBlockRef&lt;cdecl, 0x4D3FD0&gt;(index)</p>
<h4>CAnimManager::RemoveAnimBlockRefWithoutDelete</h4>
<p>plugin::Call<0x4D3FF0, int>(index);</p>
<p>0AA5: call_function 0x4D3FF0 num_params 1 pop 1 [index]</p>
<p>define function CAnimManager__RemoveAnimBlockRefWithoutDelete&lt;cdecl, 0x4D3FF0&gt;(index)</p>
<h4>CAnimManager::GetNumRefsToAnimBlock</h4>
<p>plugin::CallAndReturn<int, 0x4D4010, int>(index);</p>
<p>0AA7: call_function_return 0x4D4010 num_params 1 pop 1 [index] func_ret [int]</p>
<p>define function CAnimManager__GetNumRefsToAnimBlock&lt;cdecl, 0x4D4010&gt;(index): int</p>
<h4>CAnimManager::Shutdown</h4>
<p>plugin::Call<0x4D4130>();</p>
<p>0AA5: call_function 0x4D4130 num_params 0 pop 0</p>
<p>define function CAnimManager__Shutdown&lt;cdecl, 0x4D4130&gt;()</p>
<h4>CAnimManager::UncompressAnimation</h4>
<p>plugin::Call<0x4D41C0, CAnimBlendHierarchy*>(pAnimBlendHier);</p>
<p>0AA5: call_function 0x4D41C0 num_params 1 pop 1 [pAnimBlendHier]</p>
<p>define function CAnimManager__UncompressAnimation&lt;cdecl, 0x4D41C0&gt;(pAnimBlendHier)</p>
<h4>CAnimManager::RemoveFromUncompressedCache</h4>
<p>plugin::Call<0x4D42A0, CAnimBlendHierarchy*>(pAnimBlendHier);</p>
<p>0AA5: call_function 0x4D42A0 num_params 1 pop 1 [pAnimBlendHier]</p>
<p>define function CAnimManager__RemoveFromUncompressedCache&lt;cdecl, 0x4D42A0&gt;(pAnimBlendHier)</p>
<h4>CAnimManager::BlendAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D4410, RpClump</em>, CAnimBlendHierarchy*, int, float>(clump, pAnimBlendHier, flags, clumpAssocBlendData);</p>
<p>0AA7: call_function_return 0x4D4410 num_params 4 pop 4 [clump] [pAnimBlendHier] [flags] [clumpAssocBlendData] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__BlendAnimation&lt;cdecl, 0x4D4410&gt;(clump, pAnimBlendHier, flags, clumpAssocBlendData): int</p>
<h4>CAnimManager::BlendAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D4610, RpClump</em>, int, int, float>(clump, AssocGroupId, AnimationId, clumpAssocBlendData);</p>
<p>0AA7: call_function_return 0x4D4610 num_params 4 pop 4 [clump] [AssocGroupId] [AnimationId] [clumpAssocBlendData] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__BlendAnimation&lt;cdecl, 0x4D4610&gt;(clump, AssocGroupId, AnimationId, clumpAssocBlendData): int</p>
<h4>CAnimManager::LoadAnimFile</h4>
<p>plugin::Call<0x4D47F0, RwStream<em>, bool, char const(</em>)[32]>(stream, arg1, string);</p>
<p>0AA5: call_function 0x4D47F0 num_params 3 pop 3 [stream] [arg1] [string]</p>
<p>define function CAnimManager__LoadAnimFile&lt;cdecl, 0x4D47F0&gt;(stream, arg1, string)</p>
<h4>CAnimManager::LoadAnimFiles</h4>
<p>plugin::Call<0x4D5620>();</p>
<p>0AA5: call_function 0x4D5620 num_params 0 pop 0</p>
<p>define function CAnimManager__LoadAnimFiles&lt;cdecl, 0x4D5620&gt;()</p>
<h4>CAnimManager::ReadAnimAssociationDefinitions</h4>
<p>plugin::Call<0x5BC910>();</p>
<p>0AA5: call_function 0x5BC910 num_params 0 pop 0</p>
<p>define function CAnimManager__ReadAnimAssociationDefinitions&lt;cdecl, 0x5BC910&gt;()</p>
<h4>CAnimManager::Initialise</h4>
<p>plugin::Call<0x5BF6B0>();</p>
<p>0AA5: call_function 0x5BF6B0 num_params 0 pop 0</p>
<p>define function CAnimManager__Initialise&lt;cdecl, 0x5BF6B0&gt;()</p><h3 id="plugin_sagame_sacaudioenginecpp">plugin_sa\game_sa\CAudioEngine.cpp</h3><h4>CAudioEngine::Initialise</h4>
<p>plugin::CallMethod<0x5B9C60, CAudioEngine*>(this);</p>
<p>0AA6: call_method 0x5B9C60 struct [CAudioEngine] num_params 0 pop 0</p>
<p>define function CAudioEngine__Initialise&lt;thiscall, 0x5B9C60&gt;()</p>
<h4>CAudioEngine::Restart</h4>
<p>plugin::CallMethod<0x506DB0, CAudioEngine*>(this);</p>
<p>0AA6: call_method 0x506DB0 struct [CAudioEngine] num_params 0 pop 0</p>
<p>define function CAudioEngine__Restart&lt;thiscall, 0x506DB0&gt;()</p>
<h4>CAudioEngine::Shutdown</h4>
<p>plugin::CallMethod<0x507CB0, CAudioEngine*>(this);</p>
<p>0AA6: call_method 0x507CB0 struct [CAudioEngine] num_params 0 pop 0</p>
<p>define function CAudioEngine__Shutdown&lt;thiscall, 0x507CB0&gt;()</p>
<h4>CAudioEngine::SetEffectsMasterVolume</h4>
<p>plugin::CallMethod<0x506E10, CAudioEngine*, char>(this, volume);</p>
<p>0AA6: call_method 0x506E10 struct [CAudioEngine] num_params 1 pop 0 [volume]</p>
<p>define function CAudioEngine__SetEffectsMasterVolume&lt;thiscall, 0x506E10&gt;(volume)</p>
<h4>CAudioEngine::SetMusicMasterVolume</h4>
<p>plugin::CallMethod<0x506DE0, CAudioEngine*, char>(this, volume);</p>
<p>0AA6: call_method 0x506DE0 struct [CAudioEngine] num_params 1 pop 0 [volume]</p>
<p>define function CAudioEngine__SetMusicMasterVolume&lt;thiscall, 0x506DE0&gt;(volume)</p>
<h4>CAudioEngine::SetBassEnhanceOnOff</h4>
<p>plugin::CallMethod<0x506F90, CAudioEngine*, bool>(this, on);</p>
<p>0AA6: call_method 0x506F90 struct [CAudioEngine] num_params 1 pop 0 [on]</p>
<p>define function CAudioEngine__SetBassEnhanceOnOff&lt;thiscall, 0x506F90&gt;(on)</p>
<h4>CAudioEngine::SetRadioAutoRetuneOnOff</h4>
<p>plugin::CallMethod<0x506F80, CAudioEngine*, bool>(this, on);</p>
<p>0AA6: call_method 0x506F80 struct [CAudioEngine] num_params 1 pop 0 [on]</p>
<p>define function CAudioEngine__SetRadioAutoRetuneOnOff&lt;thiscall, 0x506F80&gt;(on)</p>
<h4>CAudioEngine::RetuneRadio</h4>
<p>plugin::CallMethod<0x507E10, CAudioEngine*, char>(this, stationId);</p>
<p>0AA6: call_method 0x507E10 struct [CAudioEngine] num_params 1 pop 0 [stationId]</p>
<p>define function CAudioEngine__RetuneRadio&lt;thiscall, 0x507E10&gt;(stationId)</p>
<h4>CAudioEngine::ReportFrontendAudioEvent</h4>
<p>plugin::CallMethodAndReturn<CReference<em>, 0x506EA0, CAudioEngine</em>, int, float, float>(this, id, volume, speed);</p>
<p>0AA8: call_method_return 0x506EA0 struct [CAudioEngine] num_params 3 pop 0 [id] [volume] [speed] func_ret [CReference*]</p>
<p>define function CAudioEngine__ReportFrontendAudioEvent&lt;thiscall, 0x506EA0&gt;(id, volume, speed): int</p>
<h4>CAudioEngine::ReportMissionAudioEvent</h4>
<p>plugin::CallMethod<0x507340, CAudioEngine<em>, eAudioEvents,CVector const</em>>(this,audioEvent,coords);</p>
<p>0AA6: call_method 0x507340 struct [CAudioEngine] num_params 2 pop 0 [audioEvent] [coords]</p>
<p>define function CAudioEngine__ReportMissionAudioEvent&lt;thiscall, 0x507340&gt;(audioEvent, coords)</p>
<h4>CAudioEngine::Service</h4>
<p>plugin::CallMethod<0x507750, CAudioEngine*>(this);</p>
<p>0AA6: call_method 0x507750 struct [CAudioEngine] num_params 0 pop 0</p>
<p>define function CAudioEngine__Service&lt;thiscall, 0x507750&gt;()</p>
<h4>CAudioEngine::ServiceLoadingTune</h4>
<p>plugin::CallMethod<0x5078A0, CAudioEngine*, float>(this, fade);</p>
<p>0AA6: call_method 0x5078A0 struct [CAudioEngine] num_params 1 pop 0 [fade]</p>
<p>define function CAudioEngine__ServiceLoadingTune&lt;thiscall, 0x5078A0&gt;(fade)</p>
<h4>CAudioEngine::StartRadio</h4>
<p>plugin::CallMethod<0x507DC0, CAudioEngine*, int, char>(this, radioStation, arg);</p>
<p>0AA6: call_method 0x507DC0 struct [CAudioEngine] num_params 2 pop 0 [radioStation] [arg]</p>
<p>define function CAudioEngine__StartRadio&lt;thiscall, 0x507DC0&gt;(radioStation, arg)</p>
<h4>CAudioEngine::StopRadio</h4>
<p>plugin::CallMethod<0x506F70, CAudioEngine<em>, tVehicleAudioSettings</em>, bool>(this, settings, arg);</p>
<p>0AA6: call_method 0x506F70 struct [CAudioEngine] num_params 2 pop 0 [settings] [arg]</p>
<p>define function CAudioEngine__StopRadio&lt;thiscall, 0x506F70&gt;(settings, arg)</p>
<h4>CAudioEngine::IsRadioRetuneInProgress</h4>
<p>plugin::CallMethodAndReturn<bool, 0x506FF0, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x506FF0 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__IsRadioRetuneInProgress&lt;thiscall, 0x506FF0&gt;(): int</p>
<h4>CAudioEngine::IsLoadingTuneActive</h4>
<p>plugin::CallMethodAndReturn<bool, 0x506D90, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x506D90 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__IsLoadingTuneActive&lt;thiscall, 0x506D90&gt;(): int</p>
<h4>CAudioEngine::IsRadioOn</h4>
<p>plugin::CallMethodAndReturn<bool, 0x506FD0, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x506FD0 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__IsRadioOn&lt;thiscall, 0x506FD0&gt;(): int</p>
<h4>CAudioEngine::IsAmbienceTrackActive</h4>
<p>plugin::CallMethodAndReturn<bool, 0x507210, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x507210 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__IsAmbienceTrackActive&lt;thiscall, 0x507210&gt;(): int</p>
<h4>CAudioEngine::StartLoadingTune</h4>
<p>plugin::CallMethodAndReturn<bool, 0x507410, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x507410 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__StartLoadingTune&lt;thiscall, 0x507410&gt;(): int</p>
<h4>CAudioEngine::GetCurrentRadioStationID</h4>
<p>plugin::CallMethodAndReturn<bool, 0x507040, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x507040 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__GetCurrentRadioStationID&lt;thiscall, 0x507040&gt;(): int</p>
<h4>CAudioEngine::IsVehicleRadioActive</h4>
<p>plugin::CallMethodAndReturn<bool, 0x507050, CAudioEngine*>(this);</p>
<p>0AA8: call_method_return 0x507050 struct [CAudioEngine] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAudioEngine__IsVehicleRadioActive&lt;thiscall, 0x507050&gt;(): int</p>
<h4>CAudioEngine::InitialisePostLoading</h4>
<p>plugin::CallMethod<0x5078F0, CAudioEngine*>(this);</p>
<p>0AA6: call_method 0x5078F0 struct [CAudioEngine] num_params 0 pop 0</p>
<p>define function CAudioEngine__InitialisePostLoading&lt;thiscall, 0x5078F0&gt;()</p><h3 id="plugin_sagame_sacbasemodelinfocpp">plugin_sa\game_sa\CBaseModelInfo.cpp</h3><h4>CBaseModelInfo::GetIsDrawLast</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5328C0, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x5328C0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__GetIsDrawLast&lt;thiscall, 0x5328C0&gt;(): int</p>
<h4>CBaseModelInfo::HasBeenPreRendered</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5328B0, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x5328B0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__HasBeenPreRendered&lt;thiscall, 0x5328B0&gt;(): int</p>
<h4>CBaseModelInfo::HasComplexHierarchy</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4C4E00, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x4C4E00 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__HasComplexHierarchy&lt;thiscall, 0x4C4E00&gt;(): int</p>
<h4>CBaseModelInfo::IsBackfaceCulled</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5328F0, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x5328F0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__IsBackfaceCulled&lt;thiscall, 0x5328F0&gt;(): int</p>
<h4>CBaseModelInfo::IsBreakableStatuePart</h4>
<p>plugin::CallMethodAndReturn<bool, 0x59F090, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x59F090 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__IsBreakableStatuePart&lt;thiscall, 0x59F090&gt;(): int</p>
<h4>CBaseModelInfo::IsLod</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4C4A00, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x4C4A00 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__IsLod&lt;thiscall, 0x4C4A00&gt;(): int</p>
<h4>CBaseModelInfo::IsRoad</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4C4DF0, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x4C4DF0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__IsRoad&lt;thiscall, 0x4C4DF0&gt;(): int</p>
<h4>CBaseModelInfo::IsTagModel</h4>
<p>plugin::CallMethodAndReturn<bool, 0x49CC20, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x49CC20 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__IsTagModel&lt;thiscall, 0x49CC20&gt;(): int</p>
<h4>CBaseModelInfo::SwaysInWind</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4212C0, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x4212C0 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CBaseModelInfo__SwaysInWind&lt;thiscall, 0x4212C0&gt;(): int</p>
<h4>CBaseModelInfo::SetHasBeenPreRendered</h4>
<p>plugin::CallMethod<0x4C42F0, CBaseModelInfo *, int>(this, bHasBeenPreRendered);</p>
<p>0AA6: call_method 0x4C42F0 struct [CBaseModelInfo] num_params 1 pop 0 [bHasBeenPreRendered]</p>
<p>define function CBaseModelInfo__SetHasBeenPreRendered&lt;thiscall, 0x4C42F0&gt;(bHasBeenPreRendered)</p>
<h4>CBaseModelInfo::SetIsLod</h4>
<p>plugin::CallMethod<0x4C4A10, CBaseModelInfo *, int>(this, bIsLod);</p>
<p>0AA6: call_method 0x4C4A10 struct [CBaseModelInfo] num_params 1 pop 0 [bIsLod]</p>
<p>define function CBaseModelInfo__SetIsLod&lt;thiscall, 0x4C4A10&gt;(bIsLod)</p>
<h4>CBaseModelInfo::SetOwnsColModel</h4>
<p>plugin::CallMethod<0x5328D0, CBaseModelInfo *, int>(this, bOwns);</p>
<p>0AA6: call_method 0x5328D0 struct [CBaseModelInfo] num_params 1 pop 0 [bOwns]</p>
<p>define function CBaseModelInfo__SetOwnsColModel&lt;thiscall, 0x5328D0&gt;(bOwns)</p>
<h4>CBaseModelInfo::IncreaseAlpha</h4>
<p>plugin::CallMethod<0x532900, CBaseModelInfo *>(this);</p>
<p>0AA6: call_method 0x532900 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__IncreaseAlpha&lt;thiscall, 0x532900&gt;()</p><h3 id="plugin_sagame_sacbirdscpp">plugin_sa\game_sa\CBirds.cpp</h3><h4>CBirds::Init</h4>
<p>plugin::Call<0x711EC0>();</p>
<p>0AA5: call_function 0x711EC0 num_params 0 pop 0</p>
<p>define function CBirds__Init&lt;cdecl, 0x711EC0&gt;()</p>
<h4>CBirds::CreateNumberOfBirds</h4>
<p>plugin::CallAndReturn<int, 0x711EF0, CVector, CVector, int, int, bool>(pos, destination, count, birdType, checkObstacles);</p>
<p>0AA7: call_function_return 0x711EF0 num_params 5 pop 5 [pos] [destination] [count] [birdType] [checkObstacles] func_ret [int]</p>
<p>define function CBirds__CreateNumberOfBirds&lt;cdecl, 0x711EF0&gt;(pos, destination, count, birdType, checkObstacles): int</p>
<h4>CBirds::Shutdown</h4>
<p>plugin::Call<0x712300>();</p>
<p>0AA5: call_function 0x712300 num_params 0 pop 0</p>
<p>define function CBirds__Shutdown&lt;cdecl, 0x712300&gt;()</p>
<h4>CBirds::Update</h4>
<p>plugin::Call<0x712330>();</p>
<p>0AA5: call_function 0x712330 num_params 0 pop 0</p>
<p>define function CBirds__Update&lt;cdecl, 0x712330&gt;()</p>
<h4>CBirds::Render</h4>
<p>plugin::Call<0x712810>();</p>
<p>0AA5: call_function 0x712810 num_params 0 pop 0</p>
<p>define function CBirds__Render&lt;cdecl, 0x712810&gt;()</p>
<h4>CBirds::HandleGunShot</h4>
<p>plugin::Call<0x712E40, CVector const<em>, CVector const</em>>(pointA, pointB);</p>
<p>0AA5: call_function 0x712E40 num_params 2 pop 2 [pointA] [pointB]</p>
<p>define function CBirds__HandleGunShot&lt;cdecl, 0x712E40&gt;(pointA, pointB)</p><h3 id="plugin_sagame_sacbouncingpanelcpp">plugin_sa\game_sa\CBouncingPanel.cpp</h3><h4>CBouncingPanel::ResetPanel</h4>
<p>plugin::CallMethod<0x6F4910, CBouncingPanel *>(this);</p>
<p>0AA6: call_method 0x6F4910 struct [CBouncingPanel] num_params 0 pop 0</p>
<p>define function CBouncingPanel__ResetPanel&lt;thiscall, 0x6F4910&gt;()</p>
<h4>CBouncingPanel::SetPanel</h4>
<p>plugin::CallMethod<0x6F4920, CBouncingPanel *, short, short, float>(this, frameId, axis, angleLimit);</p>
<p>0AA6: call_method 0x6F4920 struct [CBouncingPanel] num_params 3 pop 0 [frameId] [axis] [angleLimit]</p>
<p>define function CBouncingPanel__SetPanel&lt;thiscall, 0x6F4920&gt;(frameId, axis, angleLimit)</p>
<h4>CBouncingPanel::ProcessPanel</h4>
<p>plugin::CallMethod<0x6F49A0, CBouncingPanel <em>, CVehicle</em>, RwFrame*, CVector, CVector, float, float>(this, vehicle, frame, arg2, arg3, arg4, arg5);</p>
<p>0AA6: call_method 0x6F49A0 struct [CBouncingPanel] num_params 6 pop 0 [vehicle] [frame] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CBouncingPanel__ProcessPanel&lt;thiscall, 0x6F49A0&gt;(vehicle, frame, arg2, arg3, arg4, arg5)</p><h3 id="plugin_sagame_sacboundingboxcpp">plugin_sa\game_sa\CBoundingBox.cpp</h3><h4>CBoundingBox::CBoundingBox</h4>
<p>plugin::CallMethod<0x40FAF0, CBoundingBox *>(this);</p>
<p>0AA6: call_method 0x40FAF0 struct [CBoundingBox] num_params 0 pop 0</p>
<p>define function CBoundingBox__CBoundingBox&lt;thiscall, 0x40FAF0&gt;()</p><h3 id="plugin_sagame_sacbrightlightscpp">plugin_sa\game_sa\CBrightLights.cpp</h3><h4>CBrightLights::RenderOutGeometryBuffer</h4>
<p>plugin::Call<0x722150>();</p>
<p>0AA5: call_function 0x722150 num_params 0 pop 0</p>
<p>define function CBrightLights__RenderOutGeometryBuffer&lt;cdecl, 0x722150&gt;()</p>
<h4>CBrightLights::Render</h4>
<p>plugin::Call<0x7241C0>();</p>
<p>0AA5: call_function 0x7241C0 num_params 0 pop 0</p>
<p>define function CBrightLights__Render&lt;cdecl, 0x7241C0&gt;()</p>
<h4>CBrightLights::RegisterOne</h4>
<p>plugin::Call<0x724770, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(posn, top, right, at, color, arg5, arg6, arg7);</p>
<p>0AA5: call_function 0x724770 num_params 8 pop 8 [posn] [top] [right] [at] [color] [arg5] [arg6] [arg7]</p>
<p>define function CBrightLights__RegisterOne&lt;cdecl, 0x724770&gt;(posn, top, right, at, color, arg5, arg6, arg7)</p>
<h4>CBrightLights::Init</h4>
<p>plugin::Call<0x722140>();</p>
<p>0AA5: call_function 0x722140 num_params 0 pop 0</p>
<p>define function CBrightLights__Init&lt;cdecl, 0x722140&gt;()</p><h3 id="plugin_sagame_sacbuildingcpp">plugin_sa\game_sa\CBuilding.cpp</h3><h4>CBuilding::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x404090, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x404090 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CBuilding__operator new&lt;cdecl, 0x404090&gt;(size): int</p>
<h4>CBuilding::operator delete</h4>
<p>plugin::Call<0x4040A0, void*>(data);</p>
<p>0AA5: call_function 0x4040A0 num_params 1 pop 1 [data]</p>
<p>define function CBuilding__operator delete&lt;cdecl, 0x4040A0&gt;(data)</p>
<h4>CBuilding::CBuilding</h4>
<p>plugin::CallMethod<0x403E00, CBuilding *>(this);</p>
<p>0AA6: call_method 0x403E00 struct [CBuilding] num_params 0 pop 0</p>
<p>define function CBuilding__CBuilding&lt;thiscall, 0x403E00&gt;()</p><h3 id="plugin_sagame_sacbulletinfocpp">plugin_sa\game_sa\CBulletInfo.cpp</h3><h4>CBulletInfo::Initialise</h4>
<p>plugin::Call<0x735FD0>();</p>
<p>0AA5: call_function 0x735FD0 num_params 0 pop 0</p>
<p>define function CBulletInfo__Initialise&lt;cdecl, 0x735FD0&gt;()</p>
<h4>CBulletInfo::Shutdown</h4>
<p>plugin::Call<0x736000>();</p>
<p>0AA5: call_function 0x736000 num_params 0 pop 0</p>
<p>define function CBulletInfo__Shutdown&lt;cdecl, 0x736000&gt;()</p>
<h4>CBulletInfo::AddBullet</h4>
<p>plugin::CallAndReturn<bool, 0x736010, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, position, velocity);</p>
<p>0AA7: call_function_return 0x736010 num_params 4 pop 4 [creator] [weaponType] [position] [velocity] func_ret [bool]</p>
<p>define function CBulletInfo__AddBullet&lt;cdecl, 0x736010&gt;(creator, weaponType, position, velocity): int</p>
<h4>CBulletInfo::Update</h4>
<p>plugin::Call<0x7360D0>();</p>
<p>0AA5: call_function 0x7360D0 num_params 0 pop 0</p>
<p>define function CBulletInfo__Update&lt;cdecl, 0x7360D0&gt;()</p><h3 id="plugin_sagame_sacbullettracecpp">plugin_sa\game_sa\CBulletTrace.cpp</h3><h4>CBulletTrace::Update</h4>
<p>plugin::CallMethod<0x721D70, CBulletTrace *>(this);</p>
<p>0AA6: call_method 0x721D70 struct [CBulletTrace] num_params 0 pop 0</p>
<p>define function CBulletTrace__Update&lt;thiscall, 0x721D70&gt;()</p><h3 id="plugin_sagame_sacbullettracescpp">plugin_sa\game_sa\CBulletTraces.cpp</h3><h4>CBulletTraces::AddTrace</h4>
<p>plugin::Call<0x726AF0, CVector<em>, CVector</em>, int, CEntity*>(start, end, weaponType, entity);</p>
<p>0AA5: call_function 0x726AF0 num_params 4 pop 4 [start] [end] [weaponType] [entity]</p>
<p>define function CBulletTraces__AddTrace&lt;cdecl, 0x726AF0&gt;(start, end, weaponType, entity)</p>
<h4>CBulletTraces::Init</h4>
<p>plugin::Call<0x721D50>();</p>
<p>0AA5: call_function 0x721D50 num_params 0 pop 0</p>
<p>define function CBulletTraces__Init&lt;cdecl, 0x721D50&gt;()</p><h3 id="plugin_sagame_saccameracpp">plugin_sa\game_sa\CCamera.cpp</h3><h4>CCamera::AddShakeSimple</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, int, float>(gaddrof(CCamera::AddShakeSimple), this, duration, type, intensity);</p>
<p>0AA6: call_method 0x50D240 struct [CCamera] num_params 3 pop 0 [duration] [type] [intensity]</p>
<p>define function CCamera__AddShakeSimple&lt;thiscall, 0x50D240&gt;(duration, type, intensity)</p>
<h4>CCamera::AllowShootingWith2PlayersInCar</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::AllowShootingWith2PlayersInCar), this, bAllowShootingWith2PlayersInCar);</p>
<p>0AA6: call_method 0x50C280 struct [CCamera] num_params 1 pop 0 [bAllowShootingWith2PlayersInCar]</p>
<p>define function CCamera__AllowShootingWith2PlayersInCar&lt;thiscall, 0x50C280&gt;(bAllowShootingWith2PlayersInCar)</p>
<h4>CCamera::ApplyVehicleCameraTweaks</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVehicle *>(gaddrof(CCamera::ApplyVehicleCameraTweaks), this, vehicle);</p>
<p>0AA6: call_method 0x50A480 struct [CCamera] num_params 1 pop 0 [vehicle]</p>
<p>define function CCamera__ApplyVehicleCameraTweaks&lt;thiscall, 0x50A480&gt;(vehicle)</p>
<h4>CCamera::AvoidTheGeometry</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const *, CVector const *, CVector *, float>(gaddrof(CCamera::AvoidTheGeometry), this, arg2, arg3, arg4, FOV);</p>
<p>0AA6: call_method 0x514030 struct [CCamera] num_params 4 pop 0 [arg2] [arg3] [arg4] [FOV]</p>
<p>define function CCamera__AvoidTheGeometry&lt;thiscall, 0x514030&gt;(arg2, arg3, arg4, FOV)</p>
<h4>CCamera::CalculateDerivedValues</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, bool, bool>(gaddrof(CCamera::CalculateDerivedValues), this, bForMirror, bOriented);</p>
<p>0AA6: call_method 0x5150E0 struct [CCamera] num_params 2 pop 0 [bForMirror] [bOriented]</p>
<p>define function CCamera__CalculateDerivedValues&lt;thiscall, 0x5150E0&gt;(bForMirror, bOriented)</p>
<h4>CCamera::CalculateFrustumPlanes</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::CalculateFrustumPlanes), this, bForMirror);</p>
<p>0AA6: call_method 0x514D60 struct [CCamera] num_params 1 pop 0 [bForMirror]</p>
<p>define function CCamera__CalculateFrustumPlanes&lt;thiscall, 0x514D60&gt;(bForMirror)</p>
<h4>CCamera::CalculateGroundHeight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *, unsigned int>(gaddrof(CCamera::CalculateGroundHeight), this, type);</p>
<p>0AA8: call_method_return 0x514B80 struct [CCamera] num_params 1 pop 0 [type] func_ret [float]</p>
<h4>CCamera::CalculateMirroredMatrix</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector, float, CMatrix *, CMatrix *>(gaddrof(CCamera::CalculateMirroredMatrix), this, posn, MirrorV, CamMat, MirrorMat);</p>
<p>0AA6: call_method 0x50B380 struct [CCamera] num_params 4 pop 0 [posn] [MirrorV] [CamMat] [MirrorMat]</p>
<p>define function CCamera__CalculateMirroredMatrix&lt;thiscall, 0x50B380&gt;(posn, MirrorV, CamMat, MirrorMat)</p>
<h4>CCamera::CamControl</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CamControl), this);</p>
<p>0AA6: call_method 0x527FA0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__CamControl&lt;thiscall, 0x527FA0&gt;()</p>
<h4>CCamera::CamShake</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, float, float, float>(gaddrof(CCamera::CamShake), this, arg2, x, y, z);</p>
<p>0AA6: call_method 0x50A9F0 struct [CCamera] num_params 4 pop 0 [arg2] [x] [y] [z]</p>
<p>define function CCamera__CamShake&lt;thiscall, 0x50A9F0&gt;(arg2, x, y, z)</p>
<h4>CCamera::CameraColDetAndReact</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CCamera *, CVector *, CVector *>(gaddrof(CCamera::CameraColDetAndReact), this, source, target);</p>
<p>0AA8: call_method_return 0x520190 struct [CCamera] num_params 2 pop 0 [source] [target] func_ret [char]</p>
<h4>CCamera::CameraGenericModeSpecialCases</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::CameraGenericModeSpecialCases), this, targetPed);</p>
<p>0AA6: call_method 0x50CD30 struct [CCamera] num_params 1 pop 0 [targetPed]</p>
<p>define function CCamera__CameraGenericModeSpecialCases&lt;thiscall, 0x50CD30&gt;(targetPed)</p>
<h4>CCamera::CameraPedAimModeSpecialCases</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::CameraPedAimModeSpecialCases), this, targPed);</p>
<p>0AA6: call_method 0x50CDA0 struct [CCamera] num_params 1 pop 0 [targPed]</p>
<p>define function CCamera__CameraPedAimModeSpecialCases&lt;thiscall, 0x50CDA0&gt;(targPed)</p>
<h4>CCamera::CameraPedModeSpecialCases</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::CameraPedModeSpecialCases), this);</p>
<p>0AA6: call_method 0x50CD80 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__CameraPedModeSpecialCases&lt;thiscall, 0x50CD80&gt;()</p>
<h4>CCamera::CameraVehicleModeSpecialCases</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVehicle *>(gaddrof(CCamera::CameraVehicleModeSpecialCases), this, targVehicle);</p>
<p>0AA6: call_method 0x50CDE0 struct [CCamera] num_params 1 pop 0 [targVehicle]</p>
<p>define function CCamera__CameraVehicleModeSpecialCases&lt;thiscall, 0x50CDE0&gt;(targVehicle)</p>
<h4>CCamera::ClearPlayerWeaponMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ClearPlayerWeaponMode), this);</p>
<p>0AA6: call_method 0x50AB10 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ClearPlayerWeaponMode&lt;thiscall, 0x50AB10&gt;()</p>
<h4>CCamera::ConeCastCollisionResolve</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector *, CVector *, CVector *, float, float, float *>(gaddrof(CCamera::ConeCastCollisionResolve), this, source, center, pVecOut, radius, arg5, pFloatOut);</p>
<p>0AA8: call_method_return 0x51A5D0 struct [CCamera] num_params 6 pop 0 [source] [center] [pVecOut] [radius] [arg5] [pFloatOut] func_ret [bool]</p>
<h4>CCamera::ConsiderPedAsDucking</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CPed *>(gaddrof(CCamera::ConsiderPedAsDucking), this, ped);</p>
<p>0AA8: call_method_return 0x50CEB0 struct [CCamera] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CCamera::CopyCameraMatrixToRWCam</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, bool>(gaddrof(CCamera::CopyCameraMatrixToRWCam), this, bUpdateMatrix);</p>
<p>0AA6: call_method 0x50AFA0 struct [CCamera] num_params 1 pop 0 [bUpdateMatrix]</p>
<p>define function CCamera__CopyCameraMatrixToRWCam&lt;thiscall, 0x50AFA0&gt;(bUpdateMatrix)</p>
<h4>CCamera::DealWithMirrorBeforeConstructRenderList</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, bool, CVector, float, CMatrix *>(gaddrof(CCamera::DealWithMirrorBeforeConstructRenderList), this, bActiveMirror, MirrorNormal, MirrorV, matMirror);</p>
<p>0AA6: call_method 0x50B510 struct [CCamera] num_params 4 pop 0 [bActiveMirror] [MirrorNormal] [MirrorV] [matMirror]</p>
<p>define function CCamera__DealWithMirrorBeforeConstructRenderList&lt;thiscall, 0x50B510&gt;(bActiveMirror, MirrorNormal, MirrorV, matMirror)</p>
<h4>CCamera::DeleteCutSceneCamDataMemory</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DeleteCutSceneCamDataMemory), this);</p>
<p>0AA6: call_method 0x5B24A0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__DeleteCutSceneCamDataMemory&lt;thiscall, 0x5B24A0&gt;()</p>
<h4>CCamera::DrawBordersForWideScreen</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::DrawBordersForWideScreen), this);</p>
<p>0AA6: call_method 0x514860 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__DrawBordersForWideScreen&lt;thiscall, 0x514860&gt;()</p>
<h4>CCamera::Enable1rstPersonCamCntrlsScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Enable1rstPersonCamCntrlsScript), this);</p>
<p>0AA6: call_method 0x50AC00 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Enable1rstPersonCamCntrlsScript&lt;thiscall, 0x50AC00&gt;()</p>
<h4>CCamera::Enable1rstPersonWeaponsCamera</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Enable1rstPersonWeaponsCamera), this);</p>
<p>0AA6: call_method 0x50AC10 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Enable1rstPersonWeaponsCamera&lt;thiscall, 0x50AC10&gt;()</p>
<h4>CCamera::Fade</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, short>(gaddrof(CCamera::Fade), this, fadeDuration, FadeInOutFlag);</p>
<p>0AA6: call_method 0x50AC20 struct [CCamera] num_params 2 pop 0 [fadeDuration] [FadeInOutFlag]</p>
<p>define function CCamera__Fade&lt;thiscall, 0x50AC20&gt;(fadeDuration, FadeInOutFlag)</p>
<h4>CCamera::Find3rdPersonCamTargetVector</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, CVector, CVector *, CVector *>(gaddrof(CCamera::Find3rdPersonCamTargetVector), this, range, source, pCamera, pPoint);</p>
<p>0AA6: call_method 0x514970 struct [CCamera] num_params 4 pop 0 [range] [source] [pCamera] [pPoint]</p>
<p>define function CCamera__Find3rdPersonCamTargetVector&lt;thiscall, 0x514970&gt;(range, source, pCamera, pPoint)</p>
<h4>CCamera::Find3rdPersonQuickAimPitch</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::Find3rdPersonQuickAimPitch), this);</p>
<p>0AA8: call_method_return 0x50AD40 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<h4>CCamera::FindCamFOV</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::FindCamFOV), this);</p>
<p>0AA8: call_method_return 0x50AD20 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<h4>CCamera::FinishCutscene</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::FinishCutscene), this);</p>
<p>0AA6: call_method 0x514950 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__FinishCutscene&lt;thiscall, 0x514950&gt;()</p>
<h4>CCamera::GetArrPosForVehicleType</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int, int *>(gaddrof(CCamera::GetArrPosForVehicleType), this, type, arrPos);</p>
<p>0AA6: call_method 0x50AF00 struct [CCamera] num_params 2 pop 0 [type] [arrPos]</p>
<p>define function CCamera__GetArrPosForVehicleType&lt;thiscall, 0x50AF00&gt;(type, arrPos)</p>
<h4>CCamera::GetCutSceneFinishTime</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::GetCutSceneFinishTime), this);</p>
<p>0AA8: call_method_return 0x50AD90 struct [CCamera] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>CCamera::GetFading</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetFading), this);</p>
<p>0AA8: call_method_return 0x50ADE0 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::GetFadingDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::GetFadingDirection), this);</p>
<p>0AA8: call_method_return 0x50ADF0 struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<h4>*CCamera::GetGameCamPosition</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CVector *, CCamera *>(gaddrof(CCamera::GetGameCamPosition), this);</p>
<p>0AA8: call_method_return 0x50AE50 struct [*CCamera] num_params 0 pop 0 func_ret [CVector *]</p>
<h4>CCamera::GetLookDirection</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed int, CCamera *>(gaddrof(CCamera::GetLookDirection), this);</p>
<p>0AA8: call_method_return 0x50AE90 struct [CCamera] num_params 0 pop 0 func_ret [signed int]</p>
<h4>CCamera::GetLookingForwardFirstPerson</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingForwardFirstPerson), this);</p>
<p>0AA8: call_method_return 0x50AED0 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::GetLookingLRBFirstPerson</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::GetLookingLRBFirstPerson), this);</p>
<p>0AA8: call_method_return 0x50AE60 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::GetPositionAlongSpline</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetPositionAlongSpline), this);</p>
<p>0AA8: call_method_return 0x50AF80 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<h4>CCamera::GetRoughDistanceToGround</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCamera *>(gaddrof(CCamera::GetRoughDistanceToGround), this);</p>
<p>0AA8: call_method_return 0x516B00 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<h4>CCamera::GetScreenFadeStatus</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed int, CCamera *>(gaddrof(CCamera::GetScreenFadeStatus), this);</p>
<p>0AA8: call_method_return 0x50AE20 struct [CCamera] num_params 0 pop 0 func_ret [signed int]</p>
<h4>CCamera::GetScreenRect</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CRect *>(gaddrof(CCamera::GetScreenRect), this, pRect);</p>
<p>0AA6: call_method 0x50AB50 struct [CCamera] num_params 1 pop 0 [pRect]</p>
<p>define function CCamera__GetScreenRect&lt;thiscall, 0x50AB50&gt;(pRect)</p>
<h4>CCamera::Get_Just_Switched_Status</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Get_Just_Switched_Status), this);</p>
<p>0AA8: call_method_return 0x50AE10 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::HandleCameraMotionForDucking</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CPed *, CVector *, CVector *, bool>(gaddrof(CCamera::HandleCameraMotionForDucking), this, ped, source, targPosn, arg5);</p>
<p>0AA6: call_method 0x50CFA0 struct [CCamera] num_params 4 pop 0 [ped] [source] [targPosn] [arg5]</p>
<p>define function CCamera__HandleCameraMotionForDucking&lt;thiscall, 0x50CFA0&gt;(ped, source, targPosn, arg5)</p>
<h4>CCamera::HandleCameraMotionForDuckingDuringAim</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CPed *, CVector *, CVector *, bool>(gaddrof(CCamera::HandleCameraMotionForDuckingDuringAim), this, ped, source, targPosn, arg5);</p>
<p>0AA6: call_method 0x50D090 struct [CCamera] num_params 4 pop 0 [ped] [source] [targPosn] [arg5]</p>
<p>define function CCamera__HandleCameraMotionForDuckingDuringAim&lt;thiscall, 0x50D090&gt;(ped, source, targPosn, arg5)</p>
<h4>CCamera::ImproveNearClip</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVehicle *, CPed *, CVector *, CVector *>(gaddrof(CCamera::ImproveNearClip), this, pVehicle, pPed, source, targPosn);</p>
<p>0AA6: call_method 0x516B20 struct [CCamera] num_params 4 pop 0 [pVehicle] [pPed] [source] [targPosn]</p>
<p>define function CCamera__ImproveNearClip&lt;thiscall, 0x516B20&gt;(pVehicle, pPed, source, targPosn)</p>
<h4>CCamera::Init</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Init), this);</p>
<p>0AA6: call_method 0x5BC520 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Init&lt;thiscall, 0x5BC520&gt;()</p>
<h4>CCamera::InitCameraVehicleTweaks</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::InitCameraVehicleTweaks), this);</p>
<p>0AA6: call_method 0x50A3B0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__InitCameraVehicleTweaks&lt;thiscall, 0x50A3B0&gt;()</p>
<h4>CCamera::InitialiseScriptableComponents</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CCamera *>(gaddrof(CCamera::InitialiseScriptableComponents), this);</p>
<p>0AA8: call_method_return 0x50D2D0 struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<h4>CCamera::IsExtraEntityToIgnore</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CEntity *>(gaddrof(CCamera::IsExtraEntityToIgnore), this, entity);</p>
<p>0AA8: call_method_return 0x50CE80 struct [CCamera] num_params 1 pop 0 [entity] func_ret [bool]</p>
<h4>CCamera::IsItTimeForNewcam</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int, int>(gaddrof(CCamera::IsItTimeForNewcam), this, CamSequence, StartTime);</p>
<p>0AA8: call_method_return 0x51D770 struct [CCamera] num_params 2 pop 0 [CamSequence] [StartTime] func_ret [bool]</p>
<h4>CCamera::IsSphereVisible</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, CVector const &, float, RwMatrixTag *>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::*)(CVector const &amp;, float, RwMatrixTag *)), this, origin, radius, transformMatrix);</p>
<p>0AA8: call_method_return 0x420D40 struct [CCamera] num_params 3 pop 0 [origin] [radius] [transformMatrix] func_ret [bool]</p>
<h4>CCamera::IsSphereVisible</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CCamera <em>, CVector const &, float>(gaddrof_o(CCamera::IsSphereVisible, bool (CCamera::</em>)(CVector const &amp;, float)), this, origin, radius);</p>
<p>0AA8: call_method_return 0x420D40 struct [CCamera] num_params 2 pop 0 [origin] [radius] func_ret [bool]</p>
<h4>CCamera::LerpFOV</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, float, float, bool>(gaddrof(CCamera::LerpFOV), this, zoomInFactor, zoomOutFactor, timelimit, bEase);</p>
<p>0AA6: call_method 0x50D280 struct [CCamera] num_params 4 pop 0 [zoomInFactor] [zoomOutFactor] [timelimit] [bEase]</p>
<p>define function CCamera__LerpFOV&lt;thiscall, 0x50D280&gt;(zoomInFactor, zoomOutFactor, timelimit, bEase)</p>
<h4>CCamera::LoadPathSplines</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::LoadPathSplines), this, pFile);</p>
<p>0AA6: call_method 0x5B24D0 struct [CCamera] num_params 1 pop 0 [pFile]</p>
<p>define function CCamera__LoadPathSplines&lt;thiscall, 0x5B24D0&gt;(pFile)</p>
<h4>CCamera::Process</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Process), this);</p>
<p>0AA6: call_method 0x52B730 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Process&lt;thiscall, 0x52B730&gt;()</p>
<h4>CCamera::ProcessFOVLerp</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessFOVLerp, void (CCamera::*)(float)), this, ratio);</p>
<p>0AA6: call_method 0x516500 struct [CCamera] num_params 1 pop 0 [ratio]</p>
<p>define function CCamera__ProcessFOVLerp&lt;thiscall, 0x516500&gt;(ratio)</p>
<h4>CCamera::ProcessFOVLerp</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessFOVLerp, void (CCamera::*)()), this);</p>
<p>0AA6: call_method 0x516500 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessFOVLerp&lt;thiscall, 0x516500&gt;()</p>
<h4>CCamera::ProcessFade</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessFade), this);</p>
<p>0AA6: call_method 0x50B5D0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessFade&lt;thiscall, 0x50B5D0&gt;()</p>
<h4>CCamera::ProcessMusicFade</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessMusicFade), this);</p>
<p>0AA6: call_method 0x50B6D0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessMusicFade&lt;thiscall, 0x50B6D0&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraBoat</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraBoat), this);</p>
<p>0AA6: call_method 0x526E20 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraBoat&lt;thiscall, 0x526E20&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraCar</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraCar), this);</p>
<p>0AA6: call_method 0x5267C0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraCar&lt;thiscall, 0x5267C0&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraHeli</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraHeli), this);</p>
<p>0AA6: call_method 0x526AE0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraHeli&lt;thiscall, 0x526AE0&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPed), this);</p>
<p>0AA8: call_method_return 0x50B880 struct [CCamera] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>CCamera::ProcessObbeCinemaCameraPlane</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraPlane), this);</p>
<p>0AA6: call_method 0x526C80 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraPlane&lt;thiscall, 0x526C80&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraTrain</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessObbeCinemaCameraTrain), this);</p>
<p>0AA6: call_method 0x526950 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraTrain&lt;thiscall, 0x526950&gt;()</p>
<h4>CCamera::ProcessScriptedCommands</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessScriptedCommands), this);</p>
<p>0AA6: call_method 0x516AE0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessScriptedCommands&lt;thiscall, 0x516AE0&gt;()</p>
<h4>CCamera::ProcessShake</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessShake, void (CCamera::*)(float)), this, JiggleIntensity);</p>
<p>0AA6: call_method 0x51A6F0 struct [CCamera] num_params 1 pop 0 [JiggleIntensity]</p>
<p>define function CCamera__ProcessShake&lt;thiscall, 0x51A6F0&gt;(JiggleIntensity)</p>
<h4>CCamera::ProcessShake</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessShake, void (CCamera::*)()), this);</p>
<p>0AA6: call_method 0x51A6F0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessShake&lt;thiscall, 0x51A6F0&gt;()</p>
<h4>CCamera::ProcessVectorMoveLinear</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessVectorMoveLinear, void (CCamera::*)(float)), this, ratio);</p>
<p>0AA6: call_method 0x5164A0 struct [CCamera] num_params 1 pop 0 [ratio]</p>
<p>define function CCamera__ProcessVectorMoveLinear&lt;thiscall, 0x5164A0&gt;(ratio)</p>
<h4>CCamera::ProcessVectorMoveLinear</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessVectorMoveLinear, void (CCamera::*)()), this);</p>
<p>0AA6: call_method 0x5164A0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessVectorMoveLinear&lt;thiscall, 0x5164A0&gt;()</p>
<h4>CCamera::ProcessVectorTrackLinear</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof_o(CCamera::ProcessVectorTrackLinear, void (CCamera::*)(float)), this, ratio);</p>
<p>0AA6: call_method 0x516440 struct [CCamera] num_params 1 pop 0 [ratio]</p>
<p>define function CCamera__ProcessVectorTrackLinear&lt;thiscall, 0x516440&gt;(ratio)</p>
<h4>CCamera::ProcessVectorTrackLinear</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof_o(CCamera::ProcessVectorTrackLinear, void (CCamera::*)()), this);</p>
<p>0AA6: call_method 0x516440 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessVectorTrackLinear&lt;thiscall, 0x516440&gt;()</p>
<h4>CCamera::ProcessWideScreenOn</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::ProcessWideScreenOn), this);</p>
<p>0AA6: call_method 0x50B890 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessWideScreenOn&lt;thiscall, 0x50B890&gt;()</p>
<h4>CCamera::RenderMotionBlur</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RenderMotionBlur), this);</p>
<p>0AA6: call_method 0x50B8F0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RenderMotionBlur&lt;thiscall, 0x50B8F0&gt;()</p>
<h4>CCamera::ResetDuckingSystem</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::ResetDuckingSystem), this, ped);</p>
<p>0AA6: call_method 0x50CEF0 struct [CCamera] num_params 1 pop 0 [ped]</p>
<p>define function CCamera__ResetDuckingSystem&lt;thiscall, 0x50CEF0&gt;(ped)</p>
<h4>CCamera::Restore</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::Restore), this);</p>
<p>0AA6: call_method 0x50B930 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Restore&lt;thiscall, 0x50B930&gt;()</p>
<h4>CCamera::RestoreCameraAfterMirror</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreCameraAfterMirror), this);</p>
<p>0AA6: call_method 0x51A5A0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RestoreCameraAfterMirror&lt;thiscall, 0x51A5A0&gt;()</p>
<h4>CCamera::RestoreWithJumpCut</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::RestoreWithJumpCut), this);</p>
<p>0AA6: call_method 0x50BAB0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RestoreWithJumpCut&lt;thiscall, 0x50BAB0&gt;()</p>
<h4>CCamera::SetCamCutSceneOffSet</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const *>(gaddrof(CCamera::SetCamCutSceneOffSet), this, cutsceneOffset);</p>
<p>0AA6: call_method 0x50BD20 struct [CCamera] num_params 1 pop 0 [cutsceneOffset]</p>
<p>define function CCamera__SetCamCutSceneOffSet&lt;thiscall, 0x50BD20&gt;(cutsceneOffset)</p>
<h4>CCamera::SetCamPositionForFixedMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const *, CVector const *>(gaddrof(CCamera::SetCamPositionForFixedMode), this, fixedModeSource, fixedModeUpOffset);</p>
<p>0AA6: call_method 0x50BEC0 struct [CCamera] num_params 2 pop 0 [fixedModeSource] [fixedModeUpOffset]</p>
<p>define function CCamera__SetCamPositionForFixedMode&lt;thiscall, 0x50BEC0&gt;(fixedModeSource, fixedModeUpOffset)</p>
<h4>CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString), this);</p>
<p>0AA6: call_method 0x50BD40 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetCameraDirectlyBehindForFollowPed_CamOnAString&lt;thiscall, 0x50BD40&gt;()</p>
<h4>CCamera::SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CPed *>(gaddrof(CCamera::SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString), this, targetPed);</p>
<p>0AA6: call_method 0x50BDA0 struct [CCamera] num_params 1 pop 0 [targetPed]</p>
<p>define function CCamera__SetCameraDirectlyBehindForFollowPed_ForAPed_CamOnAString&lt;thiscall, 0x50BDA0&gt;(targetPed)</p>
<h4>CCamera::SetCameraUpForMirror</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetCameraUpForMirror), this);</p>
<p>0AA6: call_method 0x51A560 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetCameraUpForMirror&lt;thiscall, 0x51A560&gt;()</p>
<h4>CCamera::SetFadeColour</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, unsigned char, unsigned char, unsigned char>(gaddrof(CCamera::SetFadeColour), this, Red, Green, Blue);</p>
<p>0AA6: call_method 0x50BF00 struct [CCamera] num_params 3 pop 0 [Red] [Green] [Blue]</p>
<p>define function CCamera__SetFadeColour&lt;thiscall, 0x50BF00&gt;(Red, Green, Blue)</p>
<h4>CCamera::SetMotionBlur</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int, int, int, int, int>(gaddrof(CCamera::SetMotionBlur), this, Red, Green, Blue, value, Blurtype);</p>
<p>0AA6: call_method 0x50BF40 struct [CCamera] num_params 5 pop 0 [Red] [Green] [Blue] [value] [Blurtype]</p>
<p>define function CCamera__SetMotionBlur&lt;thiscall, 0x50BF40&gt;(Red, Green, Blue, value, Blurtype)</p>
<h4>CCamera::SetMotionBlurAlpha</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, int>(gaddrof(CCamera::SetMotionBlurAlpha), this, Alpha);</p>
<p>0AA6: call_method 0x50BF80 struct [CCamera] num_params 1 pop 0 [Alpha]</p>
<p>define function CCamera__SetMotionBlurAlpha&lt;thiscall, 0x50BF80&gt;(Alpha)</p>
<h4>CCamera::SetNearClipBasedOnPedCollision</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipBasedOnPedCollision), this, arg2);</p>
<p>0AA6: call_method 0x50CB90 struct [CCamera] num_params 1 pop 0 [arg2]</p>
<p>define function CCamera__SetNearClipBasedOnPedCollision&lt;thiscall, 0x50CB90&gt;(arg2)</p>
<h4>CCamera::SetNearClipScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetNearClipScript), this, NearClip);</p>
<p>0AA6: call_method 0x50BF90 struct [CCamera] num_params 1 pop 0 [NearClip]</p>
<p>define function CCamera__SetNearClipScript&lt;thiscall, 0x50BF90&gt;(NearClip)</p>
<h4>CCamera::SetNewPlayerWeaponMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short, short, short>(gaddrof(CCamera::SetNewPlayerWeaponMode), this, mode, maxZoom, minZoom);</p>
<p>0AA6: call_method 0x50BFB0 struct [CCamera] num_params 3 pop 0 [mode] [maxZoom] [minZoom]</p>
<p>define function CCamera__SetNewPlayerWeaponMode&lt;thiscall, 0x50BFB0&gt;(mode, maxZoom, minZoom)</p>
<h4>CCamera::SetParametersForScriptInterpolation</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float, float, unsigned int>(gaddrof(CCamera::SetParametersForScriptInterpolation), this, InterpolationToStopMoving, InterpolationToCatchUp, TimeForInterPolation);</p>
<p>0AA6: call_method 0x50C030 struct [CCamera] num_params 3 pop 0 [InterpolationToStopMoving] [InterpolationToCatchUp] [TimeForInterPolation]</p>
<p>define function CCamera__SetParametersForScriptInterpolation&lt;thiscall, 0x50C030&gt;(InterpolationToStopMoving, InterpolationToCatchUp, TimeForInterPolation)</p>
<h4>CCamera::SetPercentAlongCutScene</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, float>(gaddrof(CCamera::SetPercentAlongCutScene), this, percent);</p>
<p>0AA6: call_method 0x50C070 struct [CCamera] num_params 1 pop 0 [percent]</p>
<p>define function CCamera__SetPercentAlongCutScene&lt;thiscall, 0x50C070&gt;(percent)</p>
<h4>CCamera::SetRwCamera</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, RwCamera *>(gaddrof(CCamera::SetRwCamera), this, rwcamera);</p>
<p>0AA6: call_method 0x50C100 struct [CCamera] num_params 1 pop 0 [rwcamera]</p>
<p>define function CCamera__SetRwCamera&lt;thiscall, 0x50C100&gt;(rwcamera)</p>
<h4>CCamera::SetWideScreenOff</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOff), this);</p>
<p>0AA6: call_method 0x50C150 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetWideScreenOff&lt;thiscall, 0x50C150&gt;()</p>
<h4>CCamera::SetWideScreenOn</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::SetWideScreenOn), this);</p>
<p>0AA6: call_method 0x50C140 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetWideScreenOn&lt;thiscall, 0x50C140&gt;()</p>
<h4>CCamera::SetZoomValueCamStringScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueCamStringScript), this, zoomMode);</p>
<p>0AA6: call_method 0x50C1B0 struct [CCamera] num_params 1 pop 0 [zoomMode]</p>
<p>define function CCamera__SetZoomValueCamStringScript&lt;thiscall, 0x50C1B0&gt;(zoomMode)</p>
<h4>CCamera::SetZoomValueFollowPedScript</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::SetZoomValueFollowPedScript), this, zoomMode);</p>
<p>0AA6: call_method 0x50C160 struct [CCamera] num_params 1 pop 0 [zoomMode]</p>
<p>define function CCamera__SetZoomValueFollowPedScript&lt;thiscall, 0x50C160&gt;(zoomMode)</p>
<h4>CCamera::StartCooperativeCamMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::StartCooperativeCamMode), this);</p>
<p>0AA6: call_method 0x50C260 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__StartCooperativeCamMode&lt;thiscall, 0x50C260&gt;()</p>
<h4>CCamera::StartTransition</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransition), this, currentCamMode);</p>
<p>0AA6: call_method 0x515200 struct [CCamera] num_params 1 pop 0 [currentCamMode]</p>
<p>define function CCamera__StartTransition&lt;thiscall, 0x515200&gt;(currentCamMode)</p>
<h4>CCamera::StartTransitionWhenNotFinishedInter</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::StartTransitionWhenNotFinishedInter), this, currentCamMode);</p>
<p>0AA6: call_method 0x515BC0 struct [CCamera] num_params 1 pop 0 [currentCamMode]</p>
<p>define function CCamera__StartTransitionWhenNotFinishedInter&lt;thiscall, 0x515BC0&gt;(currentCamMode)</p>
<h4>CCamera::StopCooperativeCamMode</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::StopCooperativeCamMode), this);</p>
<p>0AA6: call_method 0x50C270 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__StopCooperativeCamMode&lt;thiscall, 0x50C270&gt;()</p>
<h4>CCamera::StoreValuesDuringInterPol</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, CVector *, float *>(gaddrof(CCamera::StoreValuesDuringInterPol), this, SourceDuringInter, TargetDuringInter, UpDuringInter, FOVDuringInter);</p>
<p>0AA6: call_method 0x50C290 struct [CCamera] num_params 4 pop 0 [SourceDuringInter] [TargetDuringInter] [UpDuringInter] [FOVDuringInter]</p>
<p>define function CCamera__StoreValuesDuringInterPol&lt;thiscall, 0x50C290&gt;(SourceDuringInter, TargetDuringInter, UpDuringInter, FOVDuringInter)</p>
<h4>CCamera::TakeControl</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CEntity *, short, short, int>(gaddrof(CCamera::TakeControl), this, target, ModeToGoTo, TypeOfSwitch, WhoIsInControlOfTheCamera);</p>
<p>0AA6: call_method 0x50C7C0 struct [CCamera] num_params 4 pop 0 [target] [ModeToGoTo] [TypeOfSwitch] [WhoIsInControlOfTheCamera]</p>
<p>define function CCamera__TakeControl&lt;thiscall, 0x50C7C0&gt;(target, ModeToGoTo, TypeOfSwitch, WhoIsInControlOfTheCamera)</p>
<h4>CCamera::TakeControlAttachToEntity</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CEntity *, CEntity *, CVector *, CVector *, float, short, int>(gaddrof(CCamera::TakeControlAttachToEntity), this, target, attached, AttachedCamOffset, AttachedCamLookAt, AttachedCamAngle, TypeOfSwitch, WhoIsInControlOfTheCamera);</p>
<p>0AA6: call_method 0x50C910 struct [CCamera] num_params 7 pop 0 [target] [attached] [AttachedCamOffset] [AttachedCamLookAt] [AttachedCamAngle] [TypeOfSwitch] [WhoIsInControlOfTheCamera]</p>
<p>define function CCamera__TakeControlAttachToEntity&lt;thiscall, 0x50C910&gt;(target, attached, AttachedCamOffset, AttachedCamLookAt, AttachedCamAngle, TypeOfSwitch, WhoIsInControlOfTheCamera)</p>
<h4>CCamera::TakeControlNoEntity</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const *, short, int>(gaddrof(CCamera::TakeControlNoEntity), this, FixedModeVector, TypeOfSwitch, WhoIsInControlOfTheCamera);</p>
<p>0AA6: call_method 0x50C8B0 struct [CCamera] num_params 3 pop 0 [FixedModeVector] [TypeOfSwitch] [WhoIsInControlOfTheCamera]</p>
<p>define function CCamera__TakeControlNoEntity&lt;thiscall, 0x50C8B0&gt;(FixedModeVector, TypeOfSwitch, WhoIsInControlOfTheCamera)</p>
<h4>CCamera::TakeControlWithSpline</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, short>(gaddrof(CCamera::TakeControlWithSpline), this, TypeOfSwitch);</p>
<p>0AA6: call_method 0x50CAE0 struct [CCamera] num_params 1 pop 0 [TypeOfSwitch]</p>
<p>define function CCamera__TakeControlWithSpline&lt;thiscall, 0x50CAE0&gt;(TypeOfSwitch)</p>
<h4>CCamera::TryToStartNewCamMode</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *, int>(gaddrof(CCamera::TryToStartNewCamMode), this, CamSequence);</p>
<p>0AA8: call_method_return 0x51E560 struct [CCamera] num_params 1 pop 0 [CamSequence] func_ret [bool]</p>
<h4>CCamera::UpdateAimingCoors</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector const *>(gaddrof(CCamera::UpdateAimingCoors), this, AimingTargetCoors);</p>
<p>0AA6: call_method 0x50CB10 struct [CCamera] num_params 1 pop 0 [AimingTargetCoors]</p>
<p>define function CCamera__UpdateAimingCoors&lt;thiscall, 0x50CB10&gt;(AimingTargetCoors)</p>
<h4>CCamera::UpdateSoundDistances</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateSoundDistances), this);</p>
<p>0AA6: call_method 0x515BD0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__UpdateSoundDistances&lt;thiscall, 0x515BD0&gt;()</p>
<h4>CCamera::UpdateTargetEntity</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(gaddrof(CCamera::UpdateTargetEntity), this);</p>
<p>0AA6: call_method 0x50C360 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__UpdateTargetEntity&lt;thiscall, 0x50C360&gt;()</p>
<h4>CCamera::Using1stPersonWeaponMode</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::Using1stPersonWeaponMode), this);</p>
<p>0AA8: call_method_return 0x50BFF0 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::VectorMoveLinear</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, float, bool>(gaddrof(CCamera::VectorMoveLinear), this, MoveLinearPosnEnd, MoveLinearPosnStart, duration, bMoveLinearWithEase);</p>
<p>0AA6: call_method 0x50D160 struct [CCamera] num_params 4 pop 0 [MoveLinearPosnEnd] [MoveLinearPosnStart] [duration] [bMoveLinearWithEase]</p>
<p>define function CCamera__VectorMoveLinear&lt;thiscall, 0x50D160&gt;(MoveLinearPosnEnd, MoveLinearPosnStart, duration, bMoveLinearWithEase)</p>
<h4>CCamera::VectorMoveRunning</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::VectorMoveRunning), this);</p>
<p>0AA8: call_method_return 0x4748A0 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::VectorTrackLinear</h4>
<p>plugin::CallMethodDynGlobal<CCamera *, CVector *, CVector *, float, bool>(gaddrof(CCamera::VectorTrackLinear), this, TrackLinearStartPoint, TrackLinearEndPoint, duration, bEase);</p>
<p>0AA6: call_method 0x50D1D0 struct [CCamera] num_params 4 pop 0 [TrackLinearStartPoint] [TrackLinearEndPoint] [duration] [bEase]</p>
<p>define function CCamera__VectorTrackLinear&lt;thiscall, 0x50D1D0&gt;(TrackLinearStartPoint, TrackLinearEndPoint, duration, bEase)</p>
<h4>CCamera::VectorTrackRunning</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCamera *>(gaddrof(CCamera::VectorTrackRunning), this);</p>
<p>0AA8: call_method_return 0x474870 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCamera::SetCamCollisionVarDataSet</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CCamera::SetCamCollisionVarDataSet), index);</p>
<h4>CCamera::SetColVarsAimWeapon</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CCamera::SetColVarsAimWeapon), aimingType);</p>
<h4>CCamera::SetColVarsPed</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CCamera::SetColVarsPed), pedtype, nCamPedZoom);</p>
<h4>CCamera::SetColVarsVehicle</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CCamera::SetColVarsVehicle), vehicletype, CamVehicleZoom);</p><h3 id="plugin_sagame_saccaraicpp">plugin_sa\game_sa\CCarAI.cpp</h3><h4>CCarAI::BackToCruisingIfNoWantedLevel</h4>
<p>plugin::Call<0x41BFA0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41BFA0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__BackToCruisingIfNoWantedLevel&lt;cdecl, 0x41BFA0&gt;(pVehicle)</p>
<h4>CCarAI::CarHasReasonToStop</h4>
<p>plugin::Call<0x41C050, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41C050 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__CarHasReasonToStop&lt;cdecl, 0x41C050&gt;(pVehicle)</p>
<h4>CCarAI::AddPoliceCarOccupants</h4>
<p>plugin::Call<0x41C070, CVehicle*, bool>(pVehicle, arg2);</p>
<p>0AA5: call_function 0x41C070 num_params 2 pop 2 [pVehicle] [arg2]</p>
<p>define function CCarAI__AddPoliceCarOccupants&lt;cdecl, 0x41C070&gt;(pVehicle, arg2)</p>
<h4>CCarAI::AddAmbulanceOccupants</h4>
<p>plugin::Call<0x41C4A0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41C4A0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__AddAmbulanceOccupants&lt;cdecl, 0x41C4A0&gt;(pVehicle)</p>
<h4>CCarAI::AddFiretruckOccupants</h4>
<p>plugin::Call<0x41C600, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41C600 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__AddFiretruckOccupants&lt;cdecl, 0x41C600&gt;(pVehicle)</p>
<h4>CCarAI::TellOccupantsToLeaveCar</h4>
<p>plugin::Call<0x41C760, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41C760 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__TellOccupantsToLeaveCar&lt;cdecl, 0x41C760&gt;(pVehicle)</p>
<h4>CCarAI::TellCarToFollowOtherCar</h4>
<p>plugin::Call<0x41C960, CVehicle<em>, CVehicle</em>, float>(pVehicle1, pVehicle2, radius);</p>
<p>0AA5: call_function 0x41C960 num_params 3 pop 3 [pVehicle1] [pVehicle2] [radius]</p>
<p>define function CCarAI__TellCarToFollowOtherCar&lt;cdecl, 0x41C960&gt;(pVehicle1, pVehicle2, radius)</p>
<h4>CCarAI::FindPoliceBikeMissionForWantedLevel</h4>
<p>plugin::CallAndReturn<char, 0x41CA40>();</p>
<p>0AA7: call_function_return 0x41CA40 num_params 0 pop 0 func_ret [char]</p>
<p>define function CCarAI__FindPoliceBikeMissionForWantedLevel&lt;cdecl, 0x41CA40&gt;(): int</p>
<h4>CCarAI::FindPoliceBoatMissionForWantedLevel</h4>
<p>plugin::CallAndReturn<char, 0x41CA50>();</p>
<p>0AA7: call_function_return 0x41CA50 num_params 0 pop 0 func_ret [char]</p>
<p>define function CCarAI__FindPoliceBoatMissionForWantedLevel&lt;cdecl, 0x41CA50&gt;(): int</p>
<h4>CCarAI::FindPoliceCarSpeedForWantedLevel</h4>
<p>plugin::CallAndReturn<int, 0x41CAA0, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x41CAA0 num_params 1 pop 1 [pVehicle] func_ret [int]</p>
<p>define function CCarAI__FindPoliceCarSpeedForWantedLevel&lt;cdecl, 0x41CAA0&gt;(pVehicle): int</p>
<h4>CCarAI::GetCarToGoToCoors</h4>
<p>plugin::CallAndReturn<float, 0x41CE30, CVehicle<em>, CVector</em>, int, bool>(pVehicle1, pVector, drivingStyle, bSpeedLimit20);</p>
<p>0AA7: call_function_return 0x41CE30 num_params 4 pop 4 [pVehicle1] [pVector] [drivingStyle] [bSpeedLimit20] func_ret [float]</p>
<p>define function CCarAI__GetCarToGoToCoors&lt;cdecl, 0x41CE30&gt;(pVehicle1, pVector, drivingStyle, bSpeedLimit20): float</p>
<h4>CCarAI::GetCarToParkAtCoors</h4>
<p>plugin::CallAndReturn<float, 0x41D350, CVehicle<em>, CVector</em>>(pVehicle, pVector);</p>
<p>0AA7: call_function_return 0x41D350 num_params 2 pop 2 [pVehicle] [pVector] func_ret [float]</p>
<p>define function CCarAI__GetCarToParkAtCoors&lt;cdecl, 0x41D350&gt;(pVehicle, pVector): float</p>
<h4>CCarAI::MellowOutChaseSpeed</h4>
<p>plugin::Call<0x41D3D0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41D3D0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__MellowOutChaseSpeed&lt;cdecl, 0x41D3D0&gt;(pVehicle)</p>
<h4>CCarAI::MakeWayForCarWithSiren</h4>
<p>plugin::Call<0x41D660, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41D660 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__MakeWayForCarWithSiren&lt;cdecl, 0x41D660&gt;(pVehicle)</p>
<h4>CCarAI::UpdateCarAI</h4>
<p>plugin::Call<0x41DA30, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x41DA30 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarAI__UpdateCarAI&lt;cdecl, 0x41DA30&gt;(pVehicle)</p>
<h4>CCarAI::FindPoliceCarMissionForWantedLevel</h4>
<p>plugin::CallAndReturn<char, 0x41C9D0>();</p>
<p>0AA7: call_function_return 0x41C9D0 num_params 0 pop 0 func_ret [char]</p>
<p>define function CCarAI__FindPoliceCarMissionForWantedLevel&lt;cdecl, 0x41C9D0&gt;(): int</p><h3 id="plugin_sagame_saccarctrlcpp">plugin_sa\game_sa\CCarCtrl.cpp</h3><h4>CCarCtrl::ChooseBoatModel</h4>
<p>plugin::CallAndReturn<int, 0x421970>();</p>
<p>0AA7: call_function_return 0x421970 num_params 0 pop 0 func_ret [int]</p>
<p>define function CCarCtrl__ChooseBoatModel&lt;cdecl, 0x421970&gt;(): int</p>
<h4>CCarCtrl::ChooseCarModelToLoad</h4>
<p>plugin::CallAndReturn<int, 0x421900, int>(arg1);</p>
<p>0AA7: call_function_return 0x421900 num_params 1 pop 1 [arg1] func_ret [int]</p>
<p>define function CCarCtrl__ChooseCarModelToLoad&lt;cdecl, 0x421900&gt;(arg1): int</p>
<h4>CCarCtrl::ChooseGangCarModel</h4>
<p>plugin::CallAndReturn<int, 0x421A40, int>(arg1);</p>
<p>0AA7: call_function_return 0x421A40 num_params 1 pop 1 [arg1] func_ret [int]</p>
<p>define function CCarCtrl__ChooseGangCarModel&lt;cdecl, 0x421A40&gt;(arg1): int</p>
<h4>CCarCtrl::ChooseModel</h4>
<p>plugin::CallAndReturn<int, 0x424CE0, int*>(arg1);</p>
<p>0AA7: call_function_return 0x424CE0 num_params 1 pop 1 [arg1] func_ret [int]</p>
<p>define function CCarCtrl__ChooseModel&lt;cdecl, 0x424CE0&gt;(arg1): int</p>
<h4>CCarCtrl::ChoosePoliceCarModel</h4>
<p>plugin::CallAndReturn<int, 0x421980, unsigned int>(arg0);</p>
<p>0AA7: call_function_return 0x421980 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CCarCtrl__ChoosePoliceCarModel&lt;cdecl, 0x421980&gt;(arg0): int</p>
<h4>CCarCtrl::ClearInterestingVehicleList</h4>
<p>plugin::Call<0x423F00>();</p>
<p>0AA5: call_function 0x423F00 num_params 0 pop 0</p>
<p>define function CCarCtrl__ClearInterestingVehicleList&lt;cdecl, 0x423F00&gt;()</p>
<h4>CCarCtrl::ClipTargetOrientationToLink</h4>
<p>plugin::Call<0x422760, CVehicle<em>, CCarPathLinkAddress, char, float</em>, float, float>(pVehicle, arg2, arg3, arg4, arg5, arg6);</p>
<p>0AA5: call_function 0x422760 num_params 6 pop 6 [pVehicle] [arg2] [arg3] [arg4] [arg5] [arg6]</p>
<p>define function CCarCtrl__ClipTargetOrientationToLink&lt;cdecl, 0x422760&gt;(pVehicle, arg2, arg3, arg4, arg5, arg6)</p>
<h4>CCarCtrl::CreateCarForScript</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x431F80, int, CVector, unsigned char>(modelid, posn, MissionCleanUpFlag);</p>
<p>0AA7: call_function_return 0x431F80 num_params 3 pop 3 [modelid] [posn] [MissionCleanUpFlag] func_ret [CVehicle*]</p>
<p>define function CCarCtrl__CreateCarForScript&lt;cdecl, 0x431F80&gt;(modelid, posn, MissionCleanUpFlag): int</p>
<h4>CCarCtrl::CreateConvoy</h4>
<p>plugin::CallAndReturn<bool, 0x42C740, CVehicle*, int>(pVehicle, arg2);</p>
<p>0AA7: call_function_return 0x42C740 num_params 2 pop 2 [pVehicle] [arg2] func_ret [bool]</p>
<p>define function CCarCtrl__CreateConvoy&lt;cdecl, 0x42C740&gt;(pVehicle, arg2): int</p>
<h4>CCarCtrl::CreatePoliceChase</h4>
<p>plugin::CallAndReturn<bool, 0x42C2B0, CVehicle*, int, CNodeAddress>(pVehicle, arg2, NodeAddress);</p>
<p>0AA7: call_function_return 0x42C2B0 num_params 3 pop 3 [pVehicle] [arg2] [NodeAddress] func_ret [bool]</p>
<p>define function CCarCtrl__CreatePoliceChase&lt;cdecl, 0x42C2B0&gt;(pVehicle, arg2, NodeAddress): int</p>
<h4>CCarCtrl::DealWithBend_Racing</h4>
<p>plugin::CallAndReturn<bool, 0x428040, CVehicle<em>, CCarPathLinkAddress, CCarPathLinkAddress, CCarPathLinkAddress, CCarPathLinkAddress, char, char, char, char, float, float</em>, float<em>, float</em>, float<em>, CVector</em>>(pVehicle, LinkAddress1, LinkAddress2, LinkAddress3, LinkAddress4, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, pVector);</p>
<p>0AA7: call_function_return 0x428040 num_params 15 pop 15 [pVehicle] [LinkAddress1] [LinkAddress2] [LinkAddress3] [LinkAddress4] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12] [arg13] [arg14] [pVector] func_ret [bool]</p>
<p>define function CCarCtrl__DealWithBend_Racing&lt;cdecl, 0x428040&gt;(pVehicle, LinkAddress1, LinkAddress2, LinkAddress3, LinkAddress4, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, pVector): int</p>
<h4>CCarCtrl::DragCarToPoint</h4>
<p>plugin::Call<0x42EC90, CVehicle<em>, CVector</em>>(pVehicle, pVector);</p>
<p>0AA5: call_function 0x42EC90 num_params 2 pop 2 [pVehicle] [pVector]</p>
<p>define function CCarCtrl__DragCarToPoint&lt;cdecl, 0x42EC90&gt;(pVehicle, pVector)</p>
<h4>CCarCtrl::FindAngleToWeaveThroughTraffic</h4>
<p>plugin::CallAndReturn<float, 0x4325C0, CVehicle<em>, CPhysical</em>, float, float, float>(pVehicle, pPhysical, arg3, arg4, arg5);</p>
<p>0AA7: call_function_return 0x4325C0 num_params 5 pop 5 [pVehicle] [pPhysical] [arg3] [arg4] [arg5] func_ret [float]</p>
<p>define function CCarCtrl__FindAngleToWeaveThroughTraffic&lt;cdecl, 0x4325C0&gt;(pVehicle, pPhysical, arg3, arg4, arg5): float</p>
<h4>CCarCtrl::FindIntersection2Lines</h4>
<p>plugin::Call<0x4226F0, float, float, float, float, float, float, float, float, float<em>, float</em>>(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);</p>
<p>0AA5: call_function 0x4226F0 num_params 10 pop 10 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10]</p>
<p>define function CCarCtrl__FindIntersection2Lines&lt;cdecl, 0x4226F0&gt;(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)</p>
<h4>CCarCtrl::FindLinksToGoWithTheseNodes</h4>
<p>plugin::Call<0x42B470, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x42B470 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__FindLinksToGoWithTheseNodes&lt;cdecl, 0x42B470&gt;(pVehicle)</p>
<h4>CCarCtrl::FindMaximumSpeedForThisCarInTraffic</h4>
<p>plugin::CallAndReturn<float, 0x434400, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x434400 num_params 1 pop 1 [pVehicle] func_ret [float]</p>
<p>define function CCarCtrl__FindMaximumSpeedForThisCarInTraffic&lt;cdecl, 0x434400&gt;(pVehicle): float</p>
<h4>CCarCtrl::FindNodesThisCarIsNearestTo</h4>
<p>plugin::Call<0x42BD20, CVehicle*, CNodeAddress&, CNodeAddress&>(pVehicle, NodeAddress1, NodeAddress2);</p>
<p>0AA5: call_function 0x42BD20 num_params 3 pop 3 [pVehicle] [NodeAddress1] [NodeAddress2]</p>
<p>define function CCarCtrl__FindNodesThisCarIsNearestTo&lt;cdecl, 0x42BD20&gt;(pVehicle, NodeAddress1, NodeAddress2)</p>
<h4>CCarCtrl::FindPathDirection</h4>
<p>plugin::CallAndReturn<char, 0x422090, CNodeAddress, CNodeAddress, CNodeAddress, bool*>(NodeAddress1, NodeAddress2, NodeAddress3, arg4);</p>
<p>0AA7: call_function_return 0x422090 num_params 4 pop 4 [NodeAddress1] [NodeAddress2] [NodeAddress3] [arg4] func_ret [char]</p>
<p>define function CCarCtrl__FindPathDirection&lt;cdecl, 0x422090&gt;(NodeAddress1, NodeAddress2, NodeAddress3, arg4): int</p>
<h4>CCarCtrl::FindPercDependingOnDistToLink</h4>
<p>plugin::CallAndReturn<float, 0x422620, CVehicle*, CCarPathLinkAddress>(pVehicle, LinkAddress);</p>
<p>0AA7: call_function_return 0x422620 num_params 2 pop 2 [pVehicle] [LinkAddress] func_ret [float]</p>
<p>define function CCarCtrl__FindPercDependingOnDistToLink&lt;cdecl, 0x422620&gt;(pVehicle, LinkAddress): float</p>
<h4>CCarCtrl::FindSequenceElement</h4>
<p>plugin::CallAndReturn<int, 0x421770, int>(arg1);</p>
<p>0AA7: call_function_return 0x421770 num_params 1 pop 1 [arg1] func_ret [int]</p>
<p>define function CCarCtrl__FindSequenceElement&lt;cdecl, 0x421770&gt;(arg1): int</p>
<h4>CCarCtrl::FindSpeedMultiplier</h4>
<p>plugin::CallAndReturn<float, 0x4224E0, float, float, float, float>(arg1, arg2, arg3, arg4);</p>
<p>0AA7: call_function_return 0x4224E0 num_params 4 pop 4 [arg1] [arg2] [arg3] [arg4] func_ret [float]</p>
<p>define function CCarCtrl__FindSpeedMultiplier&lt;cdecl, 0x4224E0&gt;(arg1, arg2, arg3, arg4): float</p>
<h4>CCarCtrl::FindSpeedMultiplierWithSpeedFromNodes</h4>
<p>plugin::CallAndReturn<float, 0x424130, char>(arg1);</p>
<p>0AA7: call_function_return 0x424130 num_params 1 pop 1 [arg1] func_ret [float]</p>
<p>define function CCarCtrl__FindSpeedMultiplierWithSpeedFromNodes&lt;cdecl, 0x424130&gt;(arg1): float</p>
<h4>CCarCtrl::FireHeliRocketsAtTarget</h4>
<p>plugin::Call<0x42B270, CAutomobile<em>, CEntity</em>>(pEntityLauncher, pEntity);</p>
<p>0AA5: call_function 0x42B270 num_params 2 pop 2 [pEntityLauncher] [pEntity]</p>
<p>define function CCarCtrl__FireHeliRocketsAtTarget&lt;cdecl, 0x42B270&gt;(pEntityLauncher, pEntity)</p>
<h4>CCarCtrl::FlyAIHeliInCertainDirection</h4>
<p>plugin::Call<0x429A70, CHeli*, float, float, bool>(pHeli, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x429A70 num_params 4 pop 4 [pHeli] [arg2] [arg3] [arg4]</p>
<p>define function CCarCtrl__FlyAIHeliInCertainDirection&lt;cdecl, 0x429A70&gt;(pHeli, arg2, arg3, arg4)</p>
<h4>CCarCtrl::FlyAIHeliToTarget_FixedOrientation</h4>
<p>plugin::Call<0x423940, CHeli*, float, CVector>(pHeli, Orientation, posn);</p>
<p>0AA5: call_function 0x423940 num_params 3 pop 3 [pHeli] [Orientation] [posn]</p>
<p>define function CCarCtrl__FlyAIHeliToTarget_FixedOrientation&lt;cdecl, 0x423940&gt;(pHeli, Orientation, posn)</p>
<h4>CCarCtrl::FlyAIPlaneInCertainDirection</h4>
<p>plugin::Call<0x423000, CPlane*>(pPlane);</p>
<p>0AA5: call_function 0x423000 num_params 1 pop 1 [pPlane]</p>
<p>define function CCarCtrl__FlyAIPlaneInCertainDirection&lt;cdecl, 0x423000&gt;(pPlane)</p>
<h4>CCarCtrl::GenerateCarCreationCoors2</h4>
<p>plugin::CallAndReturn<bool, 0x424210, CVector, float, float, float, bool, float, float, CVector<em>, CNodeAddress</em>, CNodeAddress<em>, float</em>, bool, bool>(posn, radius, arg3, arg4, arg5, arg6, arg7, pOrigin, pNodeAddress1, pNodeAddress12, arg11, arg12, arg13);</p>
<p>0AA7: call_function_return 0x424210 num_params 13 pop 13 [posn] [radius] [arg3] [arg4] [arg5] [arg6] [arg7] [pOrigin] [pNodeAddress1] [pNodeAddress12] [arg11] [arg12] [arg13] func_ret [bool]</p>
<p>define function CCarCtrl__GenerateCarCreationCoors2&lt;cdecl, 0x424210&gt;(posn, radius, arg3, arg4, arg5, arg6, arg7, pOrigin, pNodeAddress1, pNodeAddress12, arg11, arg12, arg13): int</p>
<h4>CCarCtrl::GenerateEmergencyServicesCar</h4>
<p>plugin::Call<0x42F9C0>();</p>
<p>0AA5: call_function 0x42F9C0 num_params 0 pop 0</p>
<p>define function CCarCtrl__GenerateEmergencyServicesCar&lt;cdecl, 0x42F9C0&gt;()</p>
<h4>CCarCtrl::GenerateOneEmergencyServicesCar</h4>
<p>plugin::CallAndReturn<bool, 0x42B7D0, unsigned int, CVector>(modelID, posn);</p>
<p>0AA7: call_function_return 0x42B7D0 num_params 2 pop 2 [modelID] [posn] func_ret [bool]</p>
<p>define function CCarCtrl__GenerateOneEmergencyServicesCar&lt;cdecl, 0x42B7D0&gt;(modelID, posn): int</p>
<h4>CCarCtrl::GenerateOneRandomCar</h4>
<p>plugin::Call<0x430050>();</p>
<p>0AA5: call_function 0x430050 num_params 0 pop 0</p>
<p>define function CCarCtrl__GenerateOneRandomCar&lt;cdecl, 0x430050&gt;()</p>
<h4>CCarCtrl::GenerateRandomCars</h4>
<p>plugin::Call<0x4341C0>();</p>
<p>0AA5: call_function 0x4341C0 num_params 0 pop 0</p>
<p>define function CCarCtrl__GenerateRandomCars&lt;cdecl, 0x4341C0&gt;()</p>
<h4>CCarCtrl::GetAIHeliToAttackPlayer</h4>
<p>plugin::Call<0x42F3C0, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42F3C0 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__GetAIHeliToAttackPlayer&lt;cdecl, 0x42F3C0&gt;(pAutomobile)</p>
<h4>CCarCtrl::GetAIHeliToFlyInDirection</h4>
<p>plugin::Call<0x42A730, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42A730 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__GetAIHeliToFlyInDirection&lt;cdecl, 0x42A730&gt;(pAutomobile)</p>
<h4>CCarCtrl::GetAIPlaneToAttackPlayer</h4>
<p>plugin::Call<0x429780, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x429780 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__GetAIPlaneToAttackPlayer&lt;cdecl, 0x429780&gt;(pAutomobile)</p>
<h4>CCarCtrl::GetAIPlaneToDoDogFight</h4>
<p>plugin::Call<0x429890, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x429890 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__GetAIPlaneToDoDogFight&lt;cdecl, 0x429890&gt;(pAutomobile)</p>
<h4>CCarCtrl::GetAIPlaneToDoDogFightAgainstPlayer</h4>
<p>plugin::Call<0x42F370, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42F370 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__GetAIPlaneToDoDogFightAgainstPlayer&lt;cdecl, 0x42F370&gt;(pAutomobile)</p>
<h4>CCarCtrl::GetNewVehicleDependingOnCarModel</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x421440, int, unsigned char>(modelID, createdBy);</p>
<p>0AA7: call_function_return 0x421440 num_params 2 pop 2 [modelID] [createdBy] func_ret [CVehicle*]</p>
<p>define function CCarCtrl__GetNewVehicleDependingOnCarModel&lt;cdecl, 0x421440&gt;(modelID, createdBy): int</p>
<h4>CCarCtrl::Init</h4>
<p>plugin::Call<0x4212E0>();</p>
<p>0AA5: call_function 0x4212E0 num_params 0 pop 0</p>
<p>define function CCarCtrl__Init&lt;cdecl, 0x4212E0&gt;()</p>
<h4>CCarCtrl::InitSequence</h4>
<p>plugin::Call<0x421740, int>(SequenceElements);</p>
<p>0AA5: call_function 0x421740 num_params 1 pop 1 [SequenceElements]</p>
<p>define function CCarCtrl__InitSequence&lt;cdecl, 0x421740&gt;(SequenceElements)</p>
<h4>CCarCtrl::IsAnyoneParking</h4>
<p>plugin::CallAndReturn<bool, 0x42C250>();</p>
<p>0AA7: call_function_return 0x42C250 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCarCtrl__IsAnyoneParking&lt;cdecl, 0x42C250&gt;(): int</p>
<h4>CCarCtrl::IsThisAnAppropriateNode</h4>
<p>plugin::CallAndReturn<bool, 0x42DAB0, CVehicle*, CNodeAddress, CNodeAddress, CNodeAddress, bool>(pVehicle, NodeAddress1, NodeAddress2, NodeAddress3, arg5);</p>
<p>0AA7: call_function_return 0x42DAB0 num_params 5 pop 5 [pVehicle] [NodeAddress1] [NodeAddress2] [NodeAddress3] [arg5] func_ret [bool]</p>
<p>define function CCarCtrl__IsThisAnAppropriateNode&lt;cdecl, 0x42DAB0&gt;(pVehicle, NodeAddress1, NodeAddress2, NodeAddress3, arg5): int</p>
<h4>CCarCtrl::IsThisVehicleInteresting</h4>
<p>plugin::CallAndReturn<bool, 0x423EA0, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x423EA0 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCarCtrl__IsThisVehicleInteresting&lt;cdecl, 0x423EA0&gt;(pVehicle): int</p>
<h4>CCarCtrl::JoinCarWithRoadAccordingToMission</h4>
<p>plugin::Call<0x432CB0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x432CB0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__JoinCarWithRoadAccordingToMission&lt;cdecl, 0x432CB0&gt;(pVehicle)</p>
<h4>CCarCtrl::JoinCarWithRoadSystem</h4>
<p>plugin::Call<0x42F5A0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x42F5A0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__JoinCarWithRoadSystem&lt;cdecl, 0x42F5A0&gt;(pVehicle)</p>
<h4>CCarCtrl::JoinCarWithRoadSystemGotoCoors</h4>
<p>plugin::CallAndReturn<bool, 0x42F870, CVehicle*, CVector const&, bool, bool>(pVehicle, posn, unused, bIsBoat);</p>
<p>0AA7: call_function_return 0x42F870 num_params 4 pop 4 [pVehicle] [posn] [unused] [bIsBoat] func_ret [bool]</p>
<p>define function CCarCtrl__JoinCarWithRoadSystemGotoCoors&lt;cdecl, 0x42F870&gt;(pVehicle, posn, unused, bIsBoat): int</p>
<h4>CCarCtrl::PickNextNodeAccordingStrategy</h4>
<p>plugin::CallAndReturn<bool, 0x432B10, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x432B10 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCarCtrl__PickNextNodeAccordingStrategy&lt;cdecl, 0x432B10&gt;(pVehicle): int</p>
<h4>CCarCtrl::PickNextNodeRandomly</h4>
<p>plugin::Call<0x42DE80, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x42DE80 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__PickNextNodeRandomly&lt;cdecl, 0x42DE80&gt;(pVehicle)</p>
<h4>CCarCtrl::PickNextNodeToChaseCar</h4>
<p>plugin::CallAndReturn<bool, 0x426EF0, CVehicle*, float, float, float>(pVehicle, x_dest, y_dest, z_dest);</p>
<p>0AA7: call_function_return 0x426EF0 num_params 4 pop 4 [pVehicle] [x_dest] [y_dest] [z_dest] func_ret [bool]</p>
<p>define function CCarCtrl__PickNextNodeToChaseCar&lt;cdecl, 0x426EF0&gt;(pVehicle, x_dest, y_dest, z_dest): int</p>
<h4>CCarCtrl::PickNextNodeToFollowPath</h4>
<p>plugin::CallAndReturn<bool, 0x427740, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x427740 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCarCtrl__PickNextNodeToFollowPath&lt;cdecl, 0x427740&gt;(pVehicle): int</p>
<h4>CCarCtrl::PossiblyFireHSMissile</h4>
<p>plugin::Call<0x429600, CVehicle<em>, CEntity</em>>(pEntityLauncher, pTargetEntity);</p>
<p>0AA5: call_function 0x429600 num_params 2 pop 2 [pEntityLauncher] [pTargetEntity]</p>
<p>define function CCarCtrl__PossiblyFireHSMissile&lt;cdecl, 0x429600&gt;(pEntityLauncher, pTargetEntity)</p>
<h4>CCarCtrl::PossiblyRemoveVehicle</h4>
<p>plugin::Call<0x424F80, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x424F80 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__PossiblyRemoveVehicle&lt;cdecl, 0x424F80&gt;(pVehicle)</p>
<h4>CCarCtrl::PruneVehiclesOfInterest</h4>
<p>plugin::Call<0x423F10>();</p>
<p>0AA5: call_function 0x423F10 num_params 0 pop 0</p>
<p>define function CCarCtrl__PruneVehiclesOfInterest&lt;cdecl, 0x423F10&gt;()</p>
<h4>CCarCtrl::ReInit</h4>
<p>plugin::Call<0x4213B0>();</p>
<p>0AA5: call_function 0x4213B0 num_params 0 pop 0</p>
<p>define function CCarCtrl__ReInit&lt;cdecl, 0x4213B0&gt;()</p>
<h4>CCarCtrl::ReconsiderRoute</h4>
<p>plugin::Call<0x42FC40, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x42FC40 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__ReconsiderRoute&lt;cdecl, 0x42FC40&gt;(pVehicle)</p>
<h4>CCarCtrl::RegisterVehicleOfInterest</h4>
<p>plugin::Call<0x423DE0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x423DE0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__RegisterVehicleOfInterest&lt;cdecl, 0x423DE0&gt;(pVehicle)</p>
<h4>CCarCtrl::RemoveCarsIfThePoolGetsFull</h4>
<p>plugin::Call<0x4322B0>();</p>
<p>0AA5: call_function 0x4322B0 num_params 0 pop 0</p>
<p>define function CCarCtrl__RemoveCarsIfThePoolGetsFull&lt;cdecl, 0x4322B0&gt;()</p>
<h4>CCarCtrl::RemoveDistantCars</h4>
<p>plugin::Call<0x42CD10>();</p>
<p>0AA5: call_function 0x42CD10 num_params 0 pop 0</p>
<p>define function CCarCtrl__RemoveDistantCars&lt;cdecl, 0x42CD10&gt;()</p>
<h4>CCarCtrl::RemoveFromInterestingVehicleList</h4>
<p>plugin::Call<0x423ED0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x423ED0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__RemoveFromInterestingVehicleList&lt;cdecl, 0x423ED0&gt;(pVehicle)</p>
<h4>CCarCtrl::ScanForPedDanger</h4>
<p>plugin::Call<0x42CE40, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x42CE40 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__ScanForPedDanger&lt;cdecl, 0x42CE40&gt;(pVehicle)</p>
<h4>CCarCtrl::ScriptGenerateOneEmergencyServicesCar</h4>
<p>plugin::CallAndReturn<bool, 0x42FBC0, unsigned int, CVector>(modelID, posn);</p>
<p>0AA7: call_function_return 0x42FBC0 num_params 2 pop 2 [modelID] [posn] func_ret [bool]</p>
<p>define function CCarCtrl__ScriptGenerateOneEmergencyServicesCar&lt;cdecl, 0x42FBC0&gt;(modelID, posn): int</p>
<h4>CCarCtrl::SetCoordsOfScriptCar</h4>
<p>plugin::Call<0x4342A0, CVehicle*, float, float, float, unsigned char, unsigned char>(pVehicle, x, y, z, arg5, arg6);</p>
<p>0AA5: call_function 0x4342A0 num_params 6 pop 6 [pVehicle] [x] [y] [z] [arg5] [arg6]</p>
<p>define function CCarCtrl__SetCoordsOfScriptCar&lt;cdecl, 0x4342A0&gt;(pVehicle, x, y, z, arg5, arg6)</p>
<h4>CCarCtrl::SetUpDriverAndPassengersForVehicle</h4>
<p>plugin::Call<0x4217C0, CVehicle*, int, int, bool, bool, int>(pVehicle, arg2, arg3, arg4, arg5, passengersNum);</p>
<p>0AA5: call_function 0x4217C0 num_params 6 pop 6 [pVehicle] [arg2] [arg3] [arg4] [arg5] [passengersNum]</p>
<p>define function CCarCtrl__SetUpDriverAndPassengersForVehicle&lt;cdecl, 0x4217C0&gt;(pVehicle, arg2, arg3, arg4, arg5, passengersNum)</p>
<h4>CCarCtrl::SlowCarDownForCarsSectorList</h4>
<p>plugin::Call<0x432420, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x432420 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__SlowCarDownForCarsSectorList&lt;cdecl, 0x432420&gt;(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::SlowCarDownForObject</h4>
<p>plugin::Call<0x426220, CEntity<em>, CVehicle</em>, float*, float>(pEntity, pVehicle, arg3, arg4);</p>
<p>0AA5: call_function 0x426220 num_params 4 pop 4 [pEntity] [pVehicle] [arg3] [arg4]</p>
<p>define function CCarCtrl__SlowCarDownForObject&lt;cdecl, 0x426220&gt;(pEntity, pVehicle, arg3, arg4)</p>
<h4>CCarCtrl::SlowCarDownForObjectsSectorList</h4>
<p>plugin::Call<0x42D4F0, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x42D4F0 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__SlowCarDownForObjectsSectorList&lt;cdecl, 0x42D4F0&gt;(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::SlowCarDownForOtherCar</h4>
<p>plugin::Call<0x42D0E0, CEntity<em>, CVehicle</em>, float*, float>(pCar1, pCar2, arg3, arg4);</p>
<p>0AA5: call_function 0x42D0E0 num_params 4 pop 4 [pCar1] [pCar2] [arg3] [arg4]</p>
<p>define function CCarCtrl__SlowCarDownForOtherCar&lt;cdecl, 0x42D0E0&gt;(pCar1, pCar2, arg3, arg4)</p>
<h4>CCarCtrl::SlowCarDownForPedsSectorList</h4>
<p>plugin::Call<0x425440, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x425440 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__SlowCarDownForPedsSectorList&lt;cdecl, 0x425440&gt;(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::SlowCarOnRailsDownForTrafficAndLights</h4>
<p>plugin::Call<0x434790, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x434790 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__SlowCarOnRailsDownForTrafficAndLights&lt;cdecl, 0x434790&gt;(pVehicle)</p>
<h4>CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer</h4>
<p>plugin::Call<0x428DE0, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x428DE0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAIBoatWithPhysicsAttackingPlayer&lt;cdecl, 0x428DE0&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAIBoatWithPhysicsCirclingPlayer</h4>
<p>plugin::Call<0x429090, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x429090 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAIBoatWithPhysicsCirclingPlayer&lt;cdecl, 0x429090&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget</h4>
<p>plugin::Call<0x428BE0, CVehicle<em>, float, float, float</em>, float<em>, float</em>>(pVehicle, arg2, arg3, arg4, arg5, arg6);</p>
<p>0AA5: call_function 0x428BE0 num_params 6 pop 6 [pVehicle] [arg2] [arg3] [arg4] [arg5] [arg6]</p>
<p>define function CCarCtrl__SteerAIBoatWithPhysicsHeadingForTarget&lt;cdecl, 0x428BE0&gt;(pVehicle, arg2, arg3, arg4, arg5, arg6)</p>
<h4>CCarCtrl::SteerAICarBlockingPlayerForwardAndBack</h4>
<p>plugin::Call<0x422B20, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x422B20 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarBlockingPlayerForwardAndBack&lt;cdecl, 0x422B20&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarParkParallel</h4>
<p>plugin::Call<0x433BA0, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x433BA0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarParkParallel&lt;cdecl, 0x433BA0&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarParkPerpendicular</h4>
<p>plugin::Call<0x433EA0, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x433EA0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarParkPerpendicular&lt;cdecl, 0x433EA0&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarTowardsPointInEscort</h4>
<p>plugin::Call<0x4336D0, CVehicle<em>, CVehicle</em>, float, float, float<em>, float</em>, float<em>, bool</em>>(pVehicle1, pVehicle2, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x4336D0 num_params 8 pop 8 [pVehicle1] [pVehicle2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__SteerAICarTowardsPointInEscort&lt;cdecl, 0x4336D0&gt;(pVehicle1, pVehicle2, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::SteerAICarWithPhysics</h4>
<p>plugin::Call<0x437C20, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x437C20 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__SteerAICarWithPhysics&lt;cdecl, 0x437C20&gt;(pVehicle)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsFollowPath</h4>
<p>plugin::Call<0x434900, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x434900 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsFollowPath&lt;cdecl, 0x434900&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsFollowPath_Racing</h4>
<p>plugin::Call<0x435830, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x435830 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsFollowPath_Racing&lt;cdecl, 0x435830&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsFollowPreRecordedPath</h4>
<p>plugin::Call<0x432DD0, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x432DD0 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsFollowPreRecordedPath&lt;cdecl, 0x432DD0&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsHeadingForTarget</h4>
<p>plugin::Call<0x433280, CVehicle<em>, CPhysical</em>, float, float, float<em>, float</em>, float<em>, bool</em>>(pVehicle, pTarget, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x433280 num_params 8 pop 8 [pVehicle] [pTarget] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsHeadingForTarget&lt;cdecl, 0x433280&gt;(pVehicle, pTarget, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget</h4>
<p>plugin::Call<0x4335E0, CVehicle<em>, CEntity</em>, float, float, float, float, float<em>, float</em>, float<em>, bool</em>>(pVehicle, Unusued, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);</p>
<p>0AA5: call_function 0x4335E0 num_params 10 pop 10 [pVehicle] [Unusued] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsTryingToBlockTarget&lt;cdecl, 0x4335E0&gt;(pVehicle, Unusued, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop</h4>
<p>plugin::Call<0x428990, CVehicle<em>, float, float, float, float, float</em>, float<em>, float</em>, bool*>(pVehicle, x, y, arg4, arg5, arg6, arg7, arg8, arg9);</p>
<p>0AA5: call_function 0x428990 num_params 9 pop 9 [pVehicle] [x] [y] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsTryingToBlockTarget_Stop&lt;cdecl, 0x428990&gt;(pVehicle, x, y, arg4, arg5, arg6, arg7, arg8, arg9)</p>
<h4>CCarCtrl::SteerAICarWithPhysics_OnlyMission</h4>
<p>plugin::Call<0x436A90, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(pVehicle, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x436A90 num_params 5 pop 5 [pVehicle] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAICarWithPhysics_OnlyMission&lt;cdecl, 0x436A90&gt;(pVehicle, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAIHeliAsPoliceHeli</h4>
<p>plugin::Call<0x42AAD0, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42AAD0 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliAsPoliceHeli&lt;cdecl, 0x42AAD0&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIHeliFlyingAwayFromPlayer</h4>
<p>plugin::Call<0x42ACB0, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42ACB0 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliFlyingAwayFromPlayer&lt;cdecl, 0x42ACB0&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIHeliToCrashAndBurn</h4>
<p>plugin::Call<0x4238E0, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x4238E0 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliToCrashAndBurn&lt;cdecl, 0x4238E0&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIHeliToFollowEntity</h4>
<p>plugin::Call<0x42A750, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42A750 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliToFollowEntity&lt;cdecl, 0x42A750&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIHeliToKeepEntityInView</h4>
<p>plugin::Call<0x42AEB0, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42AEB0 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliToKeepEntityInView&lt;cdecl, 0x42AEB0&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIHeliToLand</h4>
<p>plugin::Call<0x42AD30, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42AD30 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliToLand&lt;cdecl, 0x42AD30&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIHeliTowardsTargetCoors</h4>
<p>plugin::Call<0x42A630, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x42A630 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIHeliTowardsTargetCoors&lt;cdecl, 0x42A630&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIPlaneToCrashAndBurn</h4>
<p>plugin::Call<0x423880, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x423880 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIPlaneToCrashAndBurn&lt;cdecl, 0x423880&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIPlaneToFollowEntity</h4>
<p>plugin::Call<0x4237F0, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x4237F0 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIPlaneToFollowEntity&lt;cdecl, 0x4237F0&gt;(pAutomobile)</p>
<h4>CCarCtrl::SteerAIPlaneTowardsTargetCoors</h4>
<p>plugin::Call<0x423790, CAutomobile*>(pAutomobile);</p>
<p>0AA5: call_function 0x423790 num_params 1 pop 1 [pAutomobile]</p>
<p>define function CCarCtrl__SteerAIPlaneTowardsTargetCoors&lt;cdecl, 0x423790&gt;(pAutomobile)</p>
<h4>CCarCtrl::StopCarIfNodesAreInvalid</h4>
<p>plugin::CallAndReturn<bool, 0x422590, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x422590 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCarCtrl__StopCarIfNodesAreInvalid&lt;cdecl, 0x422590&gt;(pVehicle): int</p>
<h4>CCarCtrl::SwitchBetweenPhysicsAndGhost</h4>
<p>plugin::Call<0x4222A0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x4222A0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__SwitchBetweenPhysicsAndGhost&lt;cdecl, 0x4222A0&gt;(pVehicle)</p>
<h4>CCarCtrl::SwitchVehicleToRealPhysics</h4>
<p>plugin::Call<0x423FC0, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x423FC0 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__SwitchVehicleToRealPhysics&lt;cdecl, 0x423FC0&gt;(pVehicle)</p>
<h4>CCarCtrl::TestCollisionBetween2MovingRects</h4>
<p>plugin::CallAndReturn<float, 0x425B30, CVehicle<em>, CVehicle</em>, float, float, CVector<em>, CVector</em>>(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2);</p>
<p>0AA7: call_function_return 0x425B30 num_params 6 pop 6 [pVehicle1] [pVehicle2] [arg3] [arg4] [pVector1] [pVector2] func_ret [float]</p>
<p>define function CCarCtrl__TestCollisionBetween2MovingRects&lt;cdecl, 0x425B30&gt;(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2): float</p>
<h4>CCarCtrl::TestCollisionBetween2MovingRects_OnlyFrontBumper</h4>
<p>plugin::CallAndReturn<float, 0x425F70, CVehicle<em>, CVehicle</em>, float, float, CVector<em>, CVector</em>>(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2);</p>
<p>0AA7: call_function_return 0x425F70 num_params 6 pop 6 [pVehicle1] [pVehicle2] [arg3] [arg4] [pVector1] [pVector2] func_ret [float]</p>
<p>define function CCarCtrl__TestCollisionBetween2MovingRects_OnlyFrontBumper&lt;cdecl, 0x425F70&gt;(pVehicle1, pVehicle2, arg3, arg4, pVector1, pVector2): float</p>
<h4>CCarCtrl::TestWhetherToFirePlaneGuns</h4>
<p>plugin::Call<0x429520, CVehicle<em>, CEntity</em>>(pVehicle, pTarget);</p>
<p>0AA5: call_function 0x429520 num_params 2 pop 2 [pVehicle] [pTarget]</p>
<p>define function CCarCtrl__TestWhetherToFirePlaneGuns&lt;cdecl, 0x429520&gt;(pVehicle, pTarget)</p>
<h4>CCarCtrl::ThisVehicleShouldTryNotToTurn</h4>
<p>plugin::CallAndReturn<bool, 0x421FE0, CVehicle*>(pVehicle);</p>
<p>0AA7: call_function_return 0x421FE0 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCarCtrl__ThisVehicleShouldTryNotToTurn&lt;cdecl, 0x421FE0&gt;(pVehicle): int</p>
<h4>CCarCtrl::TriggerDogFightMoves</h4>
<p>plugin::Call<0x429300, CVehicle<em>, CVehicle</em>>(pVehicle1, pVehicle2);</p>
<p>0AA5: call_function 0x429300 num_params 2 pop 2 [pVehicle1] [pVehicle2]</p>
<p>define function CCarCtrl__TriggerDogFightMoves&lt;cdecl, 0x429300&gt;(pVehicle1, pVehicle2)</p>
<h4>CCarCtrl::UpdateCarCount</h4>
<p>plugin::Call<0x424000, CVehicle*, unsigned char>(pVehicle, bDecrease);</p>
<p>0AA5: call_function 0x424000 num_params 2 pop 2 [pVehicle] [bDecrease]</p>
<p>define function CCarCtrl__UpdateCarCount&lt;cdecl, 0x424000&gt;(pVehicle, bDecrease)</p>
<h4>CCarCtrl::UpdateCarOnRails</h4>
<p>plugin::Call<0x436540, CVehicle*>(pVehicle);</p>
<p>0AA5: call_function 0x436540 num_params 1 pop 1 [pVehicle]</p>
<p>define function CCarCtrl__UpdateCarOnRails&lt;cdecl, 0x436540&gt;(pVehicle)</p>
<h4>CCarCtrl::WeaveForObject</h4>
<p>plugin::Call<0x426BC0, CEntity<em>, CVehicle</em>, float<em>, float</em>>(pEntity, pVehicle, arg3, arg4);</p>
<p>0AA5: call_function 0x426BC0 num_params 4 pop 4 [pEntity] [pVehicle] [arg3] [arg4]</p>
<p>define function CCarCtrl__WeaveForObject&lt;cdecl, 0x426BC0&gt;(pEntity, pVehicle, arg3, arg4)</p>
<h4>CCarCtrl::WeaveForOtherCar</h4>
<p>plugin::Call<0x426350, CEntity<em>, CVehicle</em>, float<em>, float</em>>(pEntity, pVehicle, arg3, arg4);</p>
<p>0AA5: call_function 0x426350 num_params 4 pop 4 [pEntity] [pVehicle] [arg3] [arg4]</p>
<p>define function CCarCtrl__WeaveForOtherCar&lt;cdecl, 0x426350&gt;(pEntity, pVehicle, arg3, arg4)</p>
<h4>CCarCtrl::WeaveThroughCarsSectorList</h4>
<p>plugin::Call<0x42D680, CPtrList&, CVehicle<em>, CPhysical</em>, float, float, float, float, float<em>, float</em>>(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9);</p>
<p>0AA5: call_function 0x42D680 num_params 9 pop 9 [PtrList] [pVehicle] [pPhysical] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]</p>
<p>define function CCarCtrl__WeaveThroughCarsSectorList&lt;cdecl, 0x42D680&gt;(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9)</p>
<h4>CCarCtrl::WeaveThroughObjectsSectorList</h4>
<p>plugin::Call<0x42D950, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float*>(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x42D950 num_params 8 pop 8 [PtrList] [pVehicle] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__WeaveThroughObjectsSectorList&lt;cdecl, 0x42D950&gt;(PtrList, pVehicle, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::WeaveThroughPedsSectorList</h4>
<p>plugin::Call<0x42D7E0, CPtrList&, CVehicle<em>, CPhysical</em>, float, float, float, float, float<em>, float</em>>(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9);</p>
<p>0AA5: call_function 0x42D7E0 num_params 9 pop 9 [PtrList] [pVehicle] [pPhysical] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]</p>
<p>define function CCarCtrl__WeaveThroughPedsSectorList&lt;cdecl, 0x42D7E0&gt;(PtrList, pVehicle, pPhysical, arg4, arg5, arg6, arg7, arg8, arg9)</p><h3 id="plugin_sagame_saccarenterexitcpp">plugin_sa\game_sa\CCarEnterExit.cpp</h3><h4>CCarEnterExit::AddInCarAnim</h4>
<p>plugin::CallDynGlobal<CVehicle const *, CPed *, bool>(gaddrof(CCarEnterExit::AddInCarAnim), vehicle, ped, bAsDriver);</p>
<h4>CCarEnterExit::CarHasDoorToClose</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasDoorToClose), vehicle, doorId);</p>
<p>0AA7: call_function_return 0x64EE10 num_params 2 pop 2 [vehicle] [doorId] func_ret [bool]</p>
<p>define function CCarEnterExit__CarHasDoorToClose&lt;cdecl, 0x64EE10&gt;(vehicle, doorId): int</p>
<h4>CCarEnterExit::CarHasDoorToOpen</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasDoorToOpen), vehicle, doorID);</p>
<p>0AA7: call_function_return 0x64EDD0 num_params 2 pop 2 [vehicle] [doorID] func_ret [bool]</p>
<p>define function CCarEnterExit__CarHasDoorToOpen&lt;cdecl, 0x64EDD0&gt;(vehicle, doorID): int</p>
<h4>CCarEnterExit::CarHasOpenableDoor</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CPed const *>(gaddrof(CCarEnterExit::CarHasOpenableDoor), vehicle, DoorID_UnusedArg, ped);</p>
<p>0AA7: call_function_return 0x64EE50 num_params 3 pop 3 [vehicle] [DoorID_UnusedArg] [ped] func_ret [bool]</p>
<p>define function CCarEnterExit__CarHasOpenableDoor&lt;cdecl, 0x64EE50&gt;(vehicle, DoorID_UnusedArg, ped): int</p>
<h4>CCarEnterExit::CarHasPartiallyOpenDoor</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::CarHasPartiallyOpenDoor), vehicle, doorID);</p>
<p>0AA7: call_function_return 0x64EE70 num_params 2 pop 2 [vehicle] [doorID] func_ret [bool]</p>
<p>define function CCarEnterExit__CarHasPartiallyOpenDoor&lt;cdecl, 0x64EE70&gt;(vehicle, doorID): int</p>
<h4>CCarEnterExit::ComputeDoorFlag</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle const *, int, bool>(gaddrof(CCarEnterExit::ComputeDoorFlag), vehicle, doorId, bCheckVehicleType);</p>
<p>0AA7: call_function_return 0x64E550 num_params 3 pop 3 [vehicle] [doorId] [bCheckVehicleType] func_ret [int]</p>
<p>define function CCarEnterExit__ComputeDoorFlag&lt;cdecl, 0x64E550&gt;(vehicle, doorId, bCheckVehicleType): int</p>
<h4>CCarEnterExit::ComputeOppositeDoorFlag</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle const *, int, bool>(gaddrof(CCarEnterExit::ComputeOppositeDoorFlag), vehicle, doorId, bCheckVehicleType);</p>
<p>0AA7: call_function_return 0x64E610 num_params 3 pop 3 [vehicle] [doorId] [bCheckVehicleType] func_ret [int]</p>
<p>define function CCarEnterExit__ComputeOppositeDoorFlag&lt;cdecl, 0x64E610&gt;(vehicle, doorId, bCheckVehicleType): int</p>
<h4>CCarEnterExit::ComputePassengerIndexFromCarDoor</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputePassengerIndexFromCarDoor), vehicle, doorID);</p>
<p>0AA7: call_function_return 0x64F1E0 num_params 2 pop 2 [vehicle] [doorID] func_ret [signed int]</p>
<p>define function CCarEnterExit__ComputePassengerIndexFromCarDoor&lt;cdecl, 0x64F1E0&gt;(vehicle, doorID): int</p>
<h4>CCarEnterExit::ComputeSlowJackedPed</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputeSlowJackedPed), vehicle, doorID);</p>
<p>0AA7: call_function_return 0x64F070 num_params 2 pop 2 [vehicle] [doorID] func_ret [int]</p>
<p>define function CCarEnterExit__ComputeSlowJackedPed&lt;cdecl, 0x64F070&gt;(vehicle, doorID): int</p>
<h4>CCarEnterExit::ComputeTargetDoorToEnterAsPassenger</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, CVehicle const *, int>(gaddrof(CCarEnterExit::ComputeTargetDoorToEnterAsPassenger), pVehicle, nPassengerNum);</p>
<p>0AA7: call_function_return 0x64F190 num_params 2 pop 2 [pVehicle] [nPassengerNum] func_ret [signed int]</p>
<p>define function CCarEnterExit__ComputeTargetDoorToEnterAsPassenger&lt;cdecl, 0x64F190&gt;(pVehicle, nPassengerNum): int</p>
<h4>CCarEnterExit::ComputeTargetDoorToExit</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::ComputeTargetDoorToExit), pVehicle, pPed);</p>
<p>0AA7: call_function_return 0x64F110 num_params 2 pop 2 [pVehicle] [pPed] func_ret [int]</p>
<p>define function CCarEnterExit__ComputeTargetDoorToExit&lt;cdecl, 0x64F110&gt;(pVehicle, pPed): int</p>
<h4>CCarEnterExit::GetNearestCarDoor</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, CVector *, int>(gaddrof(CCarEnterExit::GetNearestCarDoor), pPed, pVehicle, outPos, doorID);</p>
<p>0AA7: call_function_return 0x6528F0 num_params 4 pop 4 [pPed] [pVehicle] [outPos] [doorID] func_ret [bool]</p>
<p>define function CCarEnterExit__GetNearestCarDoor&lt;cdecl, 0x6528F0&gt;(pPed, pVehicle, outPos, doorID): int</p>
<h4>CCarEnterExit::GetNearestCarPassengerDoor</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, CVector *, int *, bool, bool, bool>(gaddrof(CCarEnterExit::GetNearestCarPassengerDoor), ped, vehicle, outVec, doorId, flag1, flag2, flag3);</p>
<p>0AA7: call_function_return 0x650BB0 num_params 7 pop 7 [ped] [vehicle] [outVec] [doorId] [flag1] [flag2] [flag3] func_ret [bool]</p>
<p>define function CCarEnterExit__GetNearestCarPassengerDoor&lt;cdecl, 0x650BB0&gt;(ped, vehicle, outVec, doorId, flag1, flag2, flag3): int</p>
<h4>*CCarEnterExit::GetPositionToOpenCarDoor</h4>
<p>plugin::CallAndReturnDynGlobal<CVector *, CVector *, CVehicle const *, int>(gaddrof(CCarEnterExit::GetPositionToOpenCarDoor), out, vehicle, doorId);</p>
<p>0AA7: call_function_return 0x64E740 num_params 3 pop 3 [out] [vehicle] [doorId] func_ret [CVector *]</p>
<p>define function CCarEnterExit__GetPositionToOpenCarDoor&lt;cdecl, 0x64E740&gt;(out, vehicle, doorId): int</p>
<h4>CCarEnterExit::IsCarDoorInUse</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, int>(gaddrof(CCarEnterExit::IsCarDoorInUse), vehicle, door1Id, door2Id);</p>
<p>0AA7: call_function_return 0x64EC90 num_params 3 pop 3 [vehicle] [door1Id] [door2Id] func_ret [bool]</p>
<p>define function CCarEnterExit__IsCarDoorInUse&lt;cdecl, 0x64EC90&gt;(vehicle, door1Id, door2Id): int</p>
<h4>CCarEnterExit::IsCarDoorReady</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::IsCarDoorReady), vehicle, doorID);</p>
<p>0AA7: call_function_return 0x64ED90 num_params 2 pop 2 [vehicle] [doorID] func_ret [bool]</p>
<p>define function CCarEnterExit__IsCarDoorReady&lt;cdecl, 0x64ED90&gt;(vehicle, doorID): int</p>
<h4>CCarEnterExit::IsCarQuickJackPossible</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CPed const *>(gaddrof(CCarEnterExit::IsCarQuickJackPossible), vehicle, doorID, ped);</p>
<p>0AA7: call_function_return 0x64EF00 num_params 3 pop 3 [vehicle] [doorID] [ped] func_ret [bool]</p>
<p>define function CCarEnterExit__IsCarQuickJackPossible&lt;cdecl, 0x64EF00&gt;(vehicle, doorID, ped): int</p>
<h4>CCarEnterExit::IsCarSlowJackRequired</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int>(gaddrof(CCarEnterExit::IsCarSlowJackRequired), vehicle, doorID);</p>
<p>0AA7: call_function_return 0x64EF70 num_params 2 pop 2 [vehicle] [doorID] func_ret [bool]</p>
<p>define function CCarEnterExit__IsCarSlowJackRequired&lt;cdecl, 0x64EF70&gt;(vehicle, doorID): int</p>
<h4>CCarEnterExit::IsClearToDriveAway</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *>(gaddrof(CCarEnterExit::IsClearToDriveAway), outVehicle);</p>
<p>0AA7: call_function_return 0x6509B0 num_params 1 pop 1 [outVehicle] func_ret [bool]</p>
<p>define function CCarEnterExit__IsClearToDriveAway&lt;cdecl, 0x6509B0&gt;(outVehicle): int</p>
<h4>CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle *, CVector const *>(gaddrof(CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel), ped, vehicle, pos);</p>
<p>0AA7: call_function_return 0x651210 num_params 3 pop 3 [ped] [vehicle] [pos] func_ret [bool]</p>
<p>define function CCarEnterExit__IsPathToDoorBlockedByVehicleCollisionModel&lt;cdecl, 0x651210&gt;(ped, vehicle, pos): int</p>
<h4>CCarEnterExit::IsPedHealthy</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CCarEnterExit::IsPedHealthy), vehicle);</p>
<p>0AA7: call_function_return 0x64EEE0 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarEnterExit__IsPedHealthy&lt;cdecl, 0x64EEE0&gt;(vehicle): int</p>
<h4>CCarEnterExit::IsPlayerToQuitCarEnter</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed const *, CVehicle const *, int, CTask *>(gaddrof(CCarEnterExit::IsPlayerToQuitCarEnter), ped, vehicle, StartTime, task);</p>
<p>0AA7: call_function_return 0x64F240 num_params 4 pop 4 [ped] [vehicle] [StartTime] [task] func_ret [bool]</p>
<p>define function CCarEnterExit__IsPlayerToQuitCarEnter&lt;cdecl, 0x64F240&gt;(ped, vehicle, StartTime, task): int</p>
<h4>CCarEnterExit::IsRoomForPedToLeaveCar</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, int, CVector *>(gaddrof(CCarEnterExit::IsRoomForPedToLeaveCar), veh, doorID, pos);</p>
<p>0AA7: call_function_return 0x6504C0 num_params 3 pop 3 [veh] [doorID] [pos] func_ret [bool]</p>
<p>define function CCarEnterExit__IsRoomForPedToLeaveCar&lt;cdecl, 0x6504C0&gt;(veh, doorID, pos): int</p>
<h4>CCarEnterExit::IsVehicleHealthy</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *>(gaddrof(CCarEnterExit::IsVehicleHealthy), vehicle);</p>
<p>0AA7: call_function_return 0x64EEC0 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarEnterExit__IsVehicleHealthy&lt;cdecl, 0x64EEC0&gt;(vehicle): int</p>
<h4>CCarEnterExit::IsVehicleStealable</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::IsVehicleStealable), vehicle, ped);</p>
<p>0AA7: call_function_return 0x6510D0 num_params 2 pop 2 [vehicle] [ped] func_ret [bool]</p>
<p>define function CCarEnterExit__IsVehicleStealable&lt;cdecl, 0x6510D0&gt;(vehicle, ped): int</p>
<h4>CCarEnterExit::MakeUndraggedDriverPedLeaveCar</h4>
<p>plugin::CallDynGlobal<CVehicle const *, CPed const *>(gaddrof(CCarEnterExit::MakeUndraggedDriverPedLeaveCar), vehicle, ped);</p>
<h4>CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar</h4>
<p>plugin::CallDynGlobal<CVehicle const *, CPed const *, CPed const *>(gaddrof(CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar), targetVehicle, draggedPed, ped);</p>
<h4>CCarEnterExit::QuitEnteringCar</h4>
<p>plugin::CallDynGlobal<CPed *, CVehicle *, int, bool>(gaddrof(CCarEnterExit::QuitEnteringCar), ped, vehicle, doorID, bCarWasBeingJacked);</p>
<h4>CCarEnterExit::RemoveCarSitAnim</h4>
<p>plugin::CallDynGlobal<CPed const *>(gaddrof(CCarEnterExit::RemoveCarSitAnim), ped);</p>
<h4>CCarEnterExit::RemoveGetInAnims</h4>
<p>plugin::CallDynGlobal<CPed const *>(gaddrof(CCarEnterExit::RemoveGetInAnims), ped);</p>
<h4>CCarEnterExit::SetPedInCarDirect</h4>
<p>plugin::CallDynGlobal<CPed *, CVehicle *, int, bool>(gaddrof(CCarEnterExit::SetPedInCarDirect), ped, vehicle, seatNumber, bAsDriver);</p><h3 id="plugin_sagame_saccargeneratorcpp">plugin_sa\game_sa\CCarGenerator.cpp</h3><h4>CCarGenerator::CheckForBlockage</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *, int>(gaddrof(CCarGenerator::CheckForBlockage), this, modelId);</p>
<p>0AA8: call_method_return 0x6F32E0 struct [CCarGenerator] num_params 1 pop 0 [modelId] func_ret [bool]</p>
<h4>CCarGenerator::CheckIfWithinRangeOfAnyPlayers</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCarGenerator *>(gaddrof(CCarGenerator::CheckIfWithinRangeOfAnyPlayers), this);</p>
<p>0AA8: call_method_return 0x6F2F40 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCarGenerator::DoInternalProcessing</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::DoInternalProcessing), this);</p>
<p>0AA6: call_method 0x6F34D0 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__DoInternalProcessing&lt;thiscall, 0x6F34D0&gt;()</p>
<h4>CCarGenerator::Process</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::Process), this);</p>
<p>0AA6: call_method 0x6F3E90 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__Process&lt;thiscall, 0x6F3E90&gt;()</p>
<h4>CCarGenerator::Setup</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short, unsigned char, unsigned char>(gaddrof(CCarGenerator::Setup), this, x, y, z, angle, modelId, color1, color2, bforceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer);</p>
<p>0AA6: call_method 0x6F2E50 struct [CCarGenerator] num_params 14 pop 0 [x] [y] [z] [angle] [modelId] [color1] [color2] [bforceSpawn] [alarm_chances] [doorLock_chances] [minDelay] [maxDelay] [iplId] [bOwnedbyplayer]</p>
<p>define function CCarGenerator__Setup&lt;thiscall, 0x6F2E50&gt;(x, y, z, angle, modelId, color1, color2, bforceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer)</p>
<h4>CCarGenerator::SwitchOff</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOff), this);</p>
<p>0AA6: call_method 0x6F2E30 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__SwitchOff&lt;thiscall, 0x6F2E30&gt;()</p>
<h4>CCarGenerator::SwitchOn</h4>
<p>plugin::CallMethodDynGlobal<CCarGenerator *>(gaddrof(CCarGenerator::SwitchOn), this);</p>
<p>0AA6: call_method 0x6F32C0 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__SwitchOn&lt;thiscall, 0x6F32C0&gt;()</p>
<h4>CCarGenerator::CalcNextGen</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CCarGenerator::CalcNextGen));</p>
<p>0AA7: call_function_return 0x6F2E40 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CCarGenerator__CalcNextGen&lt;cdecl, 0x6F2E40&gt;(): int</p>
<h4>*CCarGenerator::Get</h4>
<p>plugin::CallAndReturnDynGlobal<CCarGenerator *, unsigned short>(gaddrof(CCarGenerator::Get), index);</p>
<p>0AA7: call_function_return 0x479D60 num_params 1 pop 1 [index] func_ret [CCarGenerator *]</p>
<p>define function CCarGenerator__Get&lt;cdecl, 0x479D60&gt;(index): int</p><h3 id="plugin_sagame_saccarpathlinkcpp">plugin_sa\game_sa\CCarPathLink.cpp</h3><h4>CCarPathLink::OneWayLaneOffset</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CCarPathLink *>(gaddrof(CCarPathLink::OneWayLaneOffset), this);</p>
<p>0AA8: call_method_return 0x44DB00 struct [CCarPathLink] num_params 0 pop 0 func_ret [float]</p><h3 id="plugin_sagame_saccheatcpp">plugin_sa\game_sa\CCheat.cpp</h3><h4>CCheat::AddToCheatString</h4>
<p>plugin::CallDynGlobal<char>(gaddrof(CCheat::AddToCheatString), LastPressedKey);</p>
<h4>CCheat::HandleSpecialCheats</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CCheat::HandleSpecialCheats), CheatID);</p>
<h4>CCheat::VehicleCheat</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicle*,int>(gaddrof(CCheat::VehicleCheat), vehicleModelId);</p>
<p>0AA7: call_function_return 0x43A0B0 num_params 1 pop 1 [vehicleModelId] func_ret [CVehicle*]</p>
<p>define function CCheat__VehicleCheat&lt;cdecl, 0x43A0B0&gt;(vehicleModelId): int</p>
<h4>CCheat::ResetCheats</h4>
<p>plugin::Call<0x438450>();</p>
<p>0AA5: call_function 0x438450 num_params 0 pop 0</p>
<p>define function CCheat__ResetCheats&lt;cdecl, 0x438450&gt;()</p><h3 id="plugin_sagame_saccheckpointcpp">plugin_sa\game_sa\CCheckpoint.cpp</h3><h4>CCheckpoint::Render</h4>
<p>plugin::CallMethod<0x725C00, CCheckpoint *>(this);</p>
<p>0AA6: call_method 0x725C00 struct [CCheckpoint] num_params 0 pop 0</p>
<p>define function CCheckpoint__Render&lt;thiscall, 0x725C00&gt;()</p><h3 id="plugin_sagame_saccheckpointscpp">plugin_sa\game_sa\CCheckpoints.cpp</h3><h4>CCheckpoints::DeleteCP</h4>
<p>plugin::Call<0x722FC0, unsigned int, unsigned short>(id, type);</p>
<p>0AA5: call_function 0x722FC0 num_params 2 pop 2 [id] [type]</p>
<p>define function CCheckpoints__DeleteCP&lt;cdecl, 0x722FC0&gt;(id, type)</p>
<h4>CCheckpoints::Init</h4>
<p>plugin::Call<0x722880>();</p>
<p>0AA5: call_function 0x722880 num_params 0 pop 0</p>
<p>define function CCheckpoints__Init&lt;cdecl, 0x722880&gt;()</p>
<h4>CCheckpoints::PlaceMarker</h4>
<p>plugin::CallAndReturn<CCheckpoint*, 0x722C40, unsigned int, unsigned short, CVector&, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, posn, direction, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate);</p>
<p>0AA7: call_function_return 0x722C40 num_params 12 pop 12 [id] [type] [posn] [direction] [size] [red] [green] [blue] [alpha] [pulsePeriod] [pulseFraction] [rotateRate] func_ret [CCheckpoint*]</p>
<p>define function CCheckpoints__PlaceMarker&lt;cdecl, 0x722C40&gt;(id, type, posn, direction, size, red, green, blue, alpha, pulsePeriod, pulseFraction, rotateRate): int</p>
<h4>CCheckpoints::Render</h4>
<p>plugin::Call<0x726060>();</p>
<p>0AA5: call_function 0x726060 num_params 0 pop 0</p>
<p>define function CCheckpoints__Render&lt;cdecl, 0x726060&gt;()</p>
<h4>CCheckpoints::SetHeading</h4>
<p>plugin::Call<0x722970, unsigned int, float>(id, angle);</p>
<p>0AA5: call_function 0x722970 num_params 2 pop 2 [id] [angle]</p>
<p>define function CCheckpoints__SetHeading&lt;cdecl, 0x722970&gt;(id, angle)</p>
<h4>CCheckpoints::Shutdown</h4>
<p>plugin::Call<0x7228F0>();</p>
<p>0AA5: call_function 0x7228F0 num_params 0 pop 0</p>
<p>define function CCheckpoints__Shutdown&lt;cdecl, 0x7228F0&gt;()</p>
<h4>CCheckpoints::Update</h4>
<p>plugin::Call<0x7229C0>();</p>
<p>0AA5: call_function 0x7229C0 num_params 0 pop 0</p>
<p>define function CCheckpoints__Update&lt;cdecl, 0x7229C0&gt;()</p>
<h4>CCheckpoints::UpdatePos</h4>
<p>plugin::Call<0x722900, unsigned int, CVector&>(id, posn);</p>
<p>0AA5: call_function 0x722900 num_params 2 pop 2 [id] [posn]</p>
<p>define function CCheckpoints__UpdatePos&lt;cdecl, 0x722900&gt;(id, posn)</p><h3 id="plugin_sagame_sacclockcpp">plugin_sa\game_sa\CClock.cpp</h3><h4>CClock::GetGameClockMinutesUntil</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned short, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);</p>
<p>0AA7: call_function_return 0x52CEB0 num_params 2 pop 2 [hours] [minutes] func_ret [unsigned short]</p>
<p>define function CClock__GetGameClockMinutesUntil&lt;cdecl, 0x52CEB0&gt;(hours, minutes): int</p>
<h4>CClock::GetIsTimeInRange</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);</p>
<p>0AA7: call_function_return 0x52CEE0 num_params 2 pop 2 [hourA] [hourB] func_ret [bool]</p>
<p>define function CClock__GetIsTimeInRange&lt;cdecl, 0x52CEE0&gt;(hourA, hourB): int</p>
<h4>CClock::Initialise</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);</p>
<h4>CClock::OffsetClockByADay</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::OffsetClockByADay), timeDirection);</p>
<h4>CClock::SetGameClock</h4>
<p>plugin::CallDynGlobal<unsigned char, unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes, day);</p><h3 id="plugin_sagame_sacclothescpp">plugin_sa\game_sa\CClothes.cpp</h3><h4>CClothes::ConstructPedModel</h4>
<p>plugin::Call<0x5A81E0, unsigned int, CPedClothesDesc&, CPedClothesDesc const*, bool>(modelid, newclothes, oldclothes, bCutscenePlayer);</p>
<p>0AA5: call_function 0x5A81E0 num_params 4 pop 4 [modelid] [newclothes] [oldclothes] [bCutscenePlayer]</p>
<p>define function CClothes__ConstructPedModel&lt;cdecl, 0x5A81E0&gt;(modelid, newclothes, oldclothes, bCutscenePlayer)</p>
<h4>CClothes::RequestMotionGroupAnims</h4>
<p>plugin::Call<0x5A8120>();</p>
<p>0AA5: call_function 0x5A8120 num_params 0 pop 0</p>
<p>define function CClothes__RequestMotionGroupAnims&lt;cdecl, 0x5A8120&gt;()</p>
<h4>CClothes::RebuildPlayerIfNeeded</h4>
<p>plugin::Call<0x5A8390, CPlayerPed*>(player);</p>
<p>0AA5: call_function 0x5A8390 num_params 1 pop 1 [player]</p>
<p>define function CClothes__RebuildPlayerIfNeeded&lt;cdecl, 0x5A8390&gt;(player)</p>
<h4>CClothes::RebuildPlayer</h4>
<p>plugin::Call<0x5A82C0, CPlayerPed*, bool>(player, bIgnoreFatAndMuscle);</p>
<p>0AA5: call_function 0x5A82C0 num_params 2 pop 2 [player] [bIgnoreFatAndMuscle]</p>
<p>define function CClothes__RebuildPlayer&lt;cdecl, 0x5A82C0&gt;(player, bIgnoreFatAndMuscle)</p>
<h4>CClothes::RebuildCutscenePlayer</h4>
<p>plugin::Call<0x5A8270, CPlayerPed*, int>(player, modelid);</p>
<p>0AA5: call_function 0x5A8270 num_params 2 pop 2 [player] [modelid]</p>
<p>define function CClothes__RebuildCutscenePlayer&lt;cdecl, 0x5A8270&gt;(player, modelid)</p>
<h4>CClothes::LoadClothesFile</h4>
<p>plugin::Call<0x5A7B30>();</p>
<p>0AA5: call_function 0x5A7B30 num_params 0 pop 0</p>
<p>define function CClothes__LoadClothesFile&lt;cdecl, 0x5A7B30&gt;()</p>
<h4>CClothes::Init</h4>
<p>plugin::Call<0x5A80D0>();</p>
<p>0AA5: call_function 0x5A80D0 num_params 0 pop 0</p>
<p>define function CClothes__Init&lt;cdecl, 0x5A80D0&gt;()</p>
<h4>CClothes::GetPlayerMotionGroupToLoad</h4>
<p>plugin::CallAndReturn<int, 0x5A7FB0>();</p>
<p>0AA7: call_function_return 0x5A7FB0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CClothes__GetPlayerMotionGroupToLoad&lt;cdecl, 0x5A7FB0&gt;(): int</p>
<h4>CClothes::GetDefaultPlayerMotionGroup</h4>
<p>plugin::CallAndReturn<int, 0x5A81B0>();</p>
<p>0AA7: call_function_return 0x5A81B0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CClothes__GetDefaultPlayerMotionGroup&lt;cdecl, 0x5A81B0&gt;(): int</p><h3 id="plugin_sagame_sacclothesbuildercpp">plugin_sa\game_sa\CClothesBuilder.cpp</h3><h4>CClothesBuilder::BlendTextures</h4>
<p>plugin::Call<0x5A5BC0, RwTexture<em>, RwTexture</em>, RwTexture<em>, float, float, float, int, RwTexture</em>>(texture1, texture2, texture3, factorA, factorB, factorC, arg7, texture4);</p>
<p>0AA5: call_function 0x5A5BC0 num_params 8 pop 8 [texture1] [texture2] [texture3] [factorA] [factorB] [factorC] [arg7] [texture4]</p>
<p>define function CClothesBuilder__BlendTextures&lt;cdecl, 0x5A5BC0&gt;(texture1, texture2, texture3, factorA, factorB, factorC, arg7, texture4)</p>
<h4>CClothesBuilder::BlendTextures</h4>
<p>plugin::Call<0x5A59C0, RwTexture<em>, RwTexture</em>, RwTexture*, float, float, float>(texture1, texture2, texture3, factorA, factorB, factorC);</p>
<p>0AA5: call_function 0x5A59C0 num_params 6 pop 6 [texture1] [texture2] [texture3] [factorA] [factorB] [factorC]</p>
<p>define function CClothesBuilder__BlendTextures&lt;cdecl, 0x5A59C0&gt;(texture1, texture2, texture3, factorA, factorB, factorC)</p>
<h4>CClothesBuilder::BlendTextures</h4>
<p>plugin::Call<0x5A5820, RwTexture<em>, RwTexture</em>, float, float>(texture1, texture2, arg3, arg4);</p>
<p>0AA5: call_function 0x5A5820 num_params 4 pop 4 [texture1] [texture2] [arg3] [arg4]</p>
<p>define function CClothesBuilder__BlendTextures&lt;cdecl, 0x5A5820&gt;(texture1, texture2, arg3, arg4)</p>
<h4>CClothesBuilder::BuildBoneIndexConversionTable</h4>
<p>plugin::Call<0x5A56E0, unsigned char<em>, RpHAnimHierarchy</em>, int>(arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x5A56E0 num_params 3 pop 3 [arg1] [arg2] [arg3]</p>
<p>define function CClothesBuilder__BuildBoneIndexConversionTable&lt;cdecl, 0x5A56E0&gt;(arg1, arg2, arg3)</p>
<h4>CClothesBuilder::ConstructGeometryAndSkinArrays</h4>
<p>plugin::Call<0x5A6530, RpHAnimHierarchy<em>, RpGeometry<strong>, RwMatrixWeights</strong>, unsigned int<strong>, unsigned int, RpGeometry</strong>, RpMaterial</em>*>(arg1, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA5: call_function 0x5A6530 num_params 7 pop 7 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]</p>
<p>define function CClothesBuilder__ConstructGeometryAndSkinArrays&lt;cdecl, 0x5A6530&gt;(arg1, arg2, arg3, arg4, arg5, arg6, arg7)</p>
<h4>CClothesBuilder::ConstructGeometryArray</h4>
<p>plugin::Call<0x5A55A0, RpGeometry*<em>, unsigned int</em>, float, float, float>(arg1, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x5A55A0 num_params 5 pop 5 [arg1] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CClothesBuilder__ConstructGeometryArray&lt;cdecl, 0x5A55A0&gt;(arg1, arg2, arg3, arg4, arg5)</p>
<h4>CClothesBuilder::ConstructTextures</h4>
<p>plugin::Call<0x5A6040, RwTexDictionary<em>, unsigned int</em>, float, float, float>(dict, hashes, factorA, factorB, factorC);</p>
<p>0AA5: call_function 0x5A6040 num_params 5 pop 5 [dict] [hashes] [factorA] [factorB] [factorC]</p>
<p>define function CClothesBuilder__ConstructTextures&lt;cdecl, 0x5A6040&gt;(dict, hashes, factorA, factorB, factorC)</p>
<h4>CClothesBuilder::CopyTexture</h4>
<p>plugin::CallAndReturn<RwTexture<em>, 0x5A5730, RwTexture</em>>(texture);</p>
<p>0AA7: call_function_return 0x5A5730 num_params 1 pop 1 [texture] func_ret [RwTexture*]</p>
<p>define function CClothesBuilder__CopyTexture&lt;cdecl, 0x5A5730&gt;(texture): int</p>
<h4>CClothesBuilder::CreateSkinnedClump</h4>
<p>plugin::CallAndReturn<RpClump<em>, 0x5A69D0, RpClump</em>, RwTexDictionary<em>, CPedClothesDesc&, CPedClothesDesc const</em>, bool>(clump, dict, newclothes, oldclothes, bCutscenePlayer);</p>
<p>0AA7: call_function_return 0x5A69D0 num_params 5 pop 5 [clump] [dict] [newclothes] [oldclothes] [bCutscenePlayer] func_ret [RpClump*]</p>
<p>define function CClothesBuilder__CreateSkinnedClump&lt;cdecl, 0x5A69D0&gt;(clump, dict, newclothes, oldclothes, bCutscenePlayer): int</p>
<h4>CClothesBuilder::DestroySkinArrays</h4>
<p>plugin::Call<0x5A56C0, RwMatrixWeights<em>, unsigned int</em>>(arg1, arg2);</p>
<p>0AA5: call_function 0x5A56C0 num_params 2 pop 2 [arg1] [arg2]</p>
<p>define function CClothesBuilder__DestroySkinArrays&lt;cdecl, 0x5A56C0&gt;(arg1, arg2)</p>
<h4>CClothesBuilder::FindNearestColour</h4>
<p>plugin::CallAndReturn<int, 0x5A5F40, RwRGBA*>(color);</p>
<p>0AA7: call_function_return 0x5A5F40 num_params 1 pop 1 [color] func_ret [int]</p>
<p>define function CClothesBuilder__FindNearestColour&lt;cdecl, 0x5A5F40&gt;(color): int</p>
<h4>CClothesBuilder::InitPaletteOctTree</h4>
<p>plugin::Call<0x5A5EB0, int>(numColors);</p>
<p>0AA5: call_function 0x5A5EB0 num_params 1 pop 1 [numColors]</p>
<p>define function CClothesBuilder__InitPaletteOctTree&lt;cdecl, 0x5A5EB0&gt;(numColors)</p>
<h4>CClothesBuilder::LoadCdDirectory</h4>
<p>plugin::Call<0x5A4190>();</p>
<p>0AA5: call_function 0x5A4190 num_params 0 pop 0</p>
<p>define function CClothesBuilder__LoadCdDirectory&lt;cdecl, 0x5A4190&gt;()</p>
<h4>CClothesBuilder::PlaceTextureOnTopOfTexture</h4>
<p>plugin::Call<0x5A57B0, RwTexture<em>, RwTexture</em>>(texture1, texture2);</p>
<p>0AA5: call_function 0x5A57B0 num_params 2 pop 2 [texture1] [texture2]</p>
<p>define function CClothesBuilder__PlaceTextureOnTopOfTexture&lt;cdecl, 0x5A57B0&gt;(texture1, texture2)</p>
<h4>CClothesBuilder::PreprocessClothesDesc</h4>
<p>plugin::Call<0x5A44C0, CPedClothesDesc&, bool>(arg1, arg2);</p>
<p>0AA5: call_function 0x5A44C0 num_params 2 pop 2 [arg1] [arg2]</p>
<p>define function CClothesBuilder__PreprocessClothesDesc&lt;cdecl, 0x5A44C0&gt;(arg1, arg2)</p>
<h4>CClothesBuilder::ReducePaletteSize</h4>
<p>plugin::Call<0x5A6870, RwTexture*, int>(texture, numColorsToReduce);</p>
<p>0AA5: call_function 0x5A6870 num_params 2 pop 2 [texture] [numColorsToReduce]</p>
<p>define function CClothesBuilder__ReducePaletteSize&lt;cdecl, 0x5A6870&gt;(texture, numColorsToReduce)</p>
<h4>CClothesBuilder::ReleaseGeometry</h4>
<p>plugin::Call<0x5A47B0, int>(numToRelease);</p>
<p>0AA5: call_function 0x5A47B0 num_params 1 pop 1 [numToRelease]</p>
<p>define function CClothesBuilder__ReleaseGeometry&lt;cdecl, 0x5A47B0&gt;(numToRelease)</p>
<h4>CClothesBuilder::RequestGeometry</h4>
<p>plugin::CallMethod<0x5A41C0, CClothesBuilder *, int, unsigned int>(this, modelid, crc);</p>
<p>0AA6: call_method 0x5A41C0 struct [CClothesBuilder] num_params 2 pop 0 [modelid] [crc]</p>
<p>define function CClothesBuilder__RequestGeometry&lt;thiscall, 0x5A41C0&gt;(modelid, crc)</p>
<h4>CClothesBuilder::StoreBoneArray</h4>
<p>plugin::Call<0x5A48B0, RpClump*, int>(clump, arg2);</p>
<p>0AA5: call_function 0x5A48B0 num_params 2 pop 2 [clump] [arg2]</p>
<p>define function CClothesBuilder__StoreBoneArray&lt;cdecl, 0x5A48B0&gt;(clump, arg2)</p>
<h4>CClothesBuilder::BlendGeometry</h4>
<p>plugin::CallAndReturn<RpGeometry<em>, 0x5A4940, RpClump</em>, char const<em>, char const</em>, char const*, float, float, float>(clump, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA7: call_function_return 0x5A4940 num_params 7 pop 7 [clump] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] func_ret [RpGeometry*]</p>
<p>define function CClothesBuilder__BlendGeometry&lt;cdecl, 0x5A4940&gt;(clump, arg2, arg3, arg4, arg5, arg6, arg7): int</p>
<h4>CClothesBuilder::BlendGeometry</h4>
<p>plugin::CallAndReturn<RpGeometry<em>, 0x5A4F10, RpClump</em>, char const<em>, char const</em>, float, float>(clump, arg2, arg3, arg4, arg5);</p>
<p>0AA7: call_function_return 0x5A4F10 num_params 5 pop 5 [clump] [arg2] [arg3] [arg4] [arg5] func_ret [RpGeometry*]</p>
<p>define function CClothesBuilder__BlendGeometry&lt;cdecl, 0x5A4F10&gt;(clump, arg2, arg3, arg4, arg5): int</p>
<h4>CClothesBuilder::CopyGeometry</h4>
<p>plugin::CallAndReturn<RpGeometry<em>, 0x5A5340, RpClump</em>, char const<em>, char const</em>>(clump, arg2, arg3);</p>
<p>0AA7: call_function_return 0x5A5340 num_params 3 pop 3 [clump] [arg2] [arg3] func_ret [RpGeometry*]</p>
<p>define function CClothesBuilder__CopyGeometry&lt;cdecl, 0x5A5340&gt;(clump, arg2, arg3): int</p>
<h4>CClothesBuilder::ShutdownPaletteOctTree</h4>
<p>plugin::Call<0x5A5EE0>();</p>
<p>0AA5: call_function 0x5A5EE0 num_params 0 pop 0</p>
<p>define function CClothesBuilder__ShutdownPaletteOctTree&lt;cdecl, 0x5A5EE0&gt;()</p>
<h4>CClothesBuilder::ReducePaletteOctTree</h4>
<p>plugin::Call<0x5A5EF0, int>(numColorsToReduce);</p>
<p>0AA5: call_function 0x5A5EF0 num_params 1 pop 1 [numColorsToReduce]</p>
<p>define function CClothesBuilder__ReducePaletteOctTree&lt;cdecl, 0x5A5EF0&gt;(numColorsToReduce)</p>
<h4>CClothesBuilder::AddColour</h4>
<p>plugin::CallAndReturn<bool, 0x5A5F00, RwRGBA*>(color);</p>
<p>0AA7: call_function_return 0x5A5F00 num_params 1 pop 1 [color] func_ret [bool]</p>
<p>define function CClothesBuilder__AddColour&lt;cdecl, 0x5A5F00&gt;(color): int</p>
<h4>CClothesBuilder::FillPalette</h4>
<p>plugin::Call<0x5A5F30, RwRGBA*>(color);</p>
<p>0AA5: call_function 0x5A5F30 num_params 1 pop 1 [color]</p>
<p>define function CClothesBuilder__FillPalette&lt;cdecl, 0x5A5F30&gt;(color)</p><h3 id="plugin_sagame_saccloudscpp">plugin_sa\game_sa\CClouds.cpp</h3><h4>CClouds::Shutdown</h4>
<p>plugin::Call<0x712FA0>();</p>
<p>0AA5: call_function 0x712FA0 num_params 0 pop 0</p>
<p>define function CClouds__Shutdown&lt;cdecl, 0x712FA0&gt;()</p>
<h4>CClouds::Update</h4>
<p>plugin::Call<0x712FF0>();</p>
<p>0AA5: call_function 0x712FF0 num_params 0 pop 0</p>
<p>define function CClouds__Update&lt;cdecl, 0x712FF0&gt;()</p>
<h4>CClouds::SetUpOneSkyPoly</h4>
<p>plugin::Call<0x713060, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char>(vert1pos, vert2pos, vert3pos, vert4pos, topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue);</p>
<p>0AA5: call_function 0x713060 num_params 10 pop 10 [vert1pos] [vert2pos] [vert3pos] [vert4pos] [topRed] [topGreen] [topBlue] [bottomRed] [bottomGreen] [bottomBlue]</p>
<p>define function CClouds__SetUpOneSkyPoly&lt;cdecl, 0x713060&gt;(vert1pos, vert2pos, vert3pos, vert4pos, topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue)</p>
<h4>CClouds::VolumetricCloudsInit</h4>
<p>plugin::Call<0x7131C0>();</p>
<p>0AA5: call_function 0x7131C0 num_params 0 pop 0</p>
<p>define function CClouds__VolumetricCloudsInit&lt;cdecl, 0x7131C0&gt;()</p>
<h4>CClouds::VolumetricClouds_GetFirstFreeSlot</h4>
<p>plugin::CallAndReturn<int, 0x7135C0>();</p>
<p>0AA7: call_function_return 0x7135C0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CClouds__VolumetricClouds_GetFirstFreeSlot&lt;cdecl, 0x7135C0&gt;(): int</p>
<h4>CClouds::VolumetricClouds_Delete</h4>
<p>plugin::Call<0x7135F0, int>(vcSlotIndex);</p>
<p>0AA5: call_function 0x7135F0 num_params 1 pop 1 [vcSlotIndex]</p>
<p>define function CClouds__VolumetricClouds_Delete&lt;cdecl, 0x7135F0&gt;(vcSlotIndex)</p>
<h4>CClouds::VolumetricCloudsGetMaxDistance</h4>
<p>plugin::CallAndReturn<float, 0x713630>();</p>
<p>0AA7: call_function_return 0x713630 num_params 0 pop 0 func_ret [float]</p>
<p>define function CClouds__VolumetricCloudsGetMaxDistance&lt;cdecl, 0x713630&gt;(): float</p>
<h4>CClouds::MovingFogInit</h4>
<p>plugin::Call<0x713660>();</p>
<p>0AA5: call_function 0x713660 num_params 0 pop 0</p>
<p>define function CClouds__MovingFogInit&lt;cdecl, 0x713660&gt;()</p>
<h4>CClouds::MovingFog_GetFXIntensity</h4>
<p>plugin::CallAndReturn<float, 0x7136D0>();</p>
<p>0AA7: call_function_return 0x7136D0 num_params 0 pop 0 func_ret [float]</p>
<p>define function CClouds__MovingFog_GetFXIntensity&lt;cdecl, 0x7136D0&gt;(): float</p>
<h4>CClouds::MovingFog_GetFirstFreeSlot</h4>
<p>plugin::CallAndReturn<int, 0x713710>();</p>
<p>0AA7: call_function_return 0x713710 num_params 0 pop 0 func_ret [int]</p>
<p>define function CClouds__MovingFog_GetFirstFreeSlot&lt;cdecl, 0x713710&gt;(): int</p>
<h4>CClouds::MovingFog_Delete</h4>
<p>plugin::Call<0x713730, int>(fogSlotIndex);</p>
<p>0AA5: call_function 0x713730 num_params 1 pop 1 [fogSlotIndex]</p>
<p>define function CClouds__MovingFog_Delete&lt;cdecl, 0x713730&gt;(fogSlotIndex)</p>
<h4>CClouds::MovingFog_Create</h4>
<p>plugin::Call<0x713760, CVector*>(posn);</p>
<p>0AA5: call_function 0x713760 num_params 1 pop 1 [posn]</p>
<p>define function CClouds__MovingFog_Create&lt;cdecl, 0x713760&gt;(posn)</p>
<h4>CClouds::Init</h4>
<p>plugin::Call<0x7138D0>();</p>
<p>0AA5: call_function 0x7138D0 num_params 0 pop 0</p>
<p>define function CClouds__Init&lt;cdecl, 0x7138D0&gt;()</p>
<h4>CClouds::Render</h4>
<p>plugin::Call<0x713950>();</p>
<p>0AA5: call_function 0x713950 num_params 0 pop 0</p>
<p>define function CClouds__Render&lt;cdecl, 0x713950&gt;()</p>
<h4>CClouds::RenderSkyPolys</h4>
<p>plugin::Call<0x714650>();</p>
<p>0AA5: call_function 0x714650 num_params 0 pop 0</p>
<p>define function CClouds__RenderSkyPolys&lt;cdecl, 0x714650&gt;()</p>
<h4>CClouds::RenderBottomFromHeight</h4>
<p>plugin::Call<0x7154B0>();</p>
<p>0AA5: call_function 0x7154B0 num_params 0 pop 0</p>
<p>define function CClouds__RenderBottomFromHeight&lt;cdecl, 0x7154B0&gt;()</p>
<h4>CClouds::VolumetricClouds_Create</h4>
<p>plugin::Call<0x715F40, CVector*>(posn);</p>
<p>0AA5: call_function 0x715F40 num_params 1 pop 1 [posn]</p>
<p>define function CClouds__VolumetricClouds_Create&lt;cdecl, 0x715F40&gt;(posn)</p>
<h4>CClouds::VolumetricCloudsRender</h4>
<p>plugin::Call<0x716380>();</p>
<p>0AA5: call_function 0x716380 num_params 0 pop 0</p>
<p>define function CClouds__VolumetricCloudsRender&lt;cdecl, 0x716380&gt;()</p>
<h4>CClouds::MovingFog_Update</h4>
<p>plugin::Call<0x716B10>();</p>
<p>0AA5: call_function 0x716B10 num_params 0 pop 0</p>
<p>define function CClouds__MovingFog_Update&lt;cdecl, 0x716B10&gt;()</p>
<h4>CClouds::MovingFogRender</h4>
<p>plugin::Call<0x716C90>();</p>
<p>0AA5: call_function 0x716C90 num_params 0 pop 0</p>
<p>define function CClouds__MovingFogRender&lt;cdecl, 0x716C90&gt;()</p><h3 id="plugin_sagame_sacclumpmodelinfocpp">plugin_sa\game_sa\CClumpModelInfo.cpp</h3><h4>CClumpModelInfo::SetFrameIds</h4>
<p>plugin::CallMethod<0x4C5460, CClumpModelInfo <em>, RwObjectNameIdAssocation</em>>(this, data);</p>
<p>0AA6: call_method 0x4C5460 struct [CClumpModelInfo] num_params 1 pop 0 [data]</p>
<p>define function CClumpModelInfo__SetFrameIds&lt;thiscall, 0x4C5460&gt;(data)</p><h3 id="plugin_sagame_saccolaccelcpp">plugin_sa\game_sa\CColAccel.cpp</h3><h4>CColAccel::IsCacheLoading</h4>
<p>plugin::CallAndReturn<bool, 0x5B2AC0>();</p>
<p>0AA7: call_function_return 0x5B2AC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CColAccel__IsCacheLoading&lt;cdecl, 0x5B2AC0&gt;(): int</p><h3 id="plugin_sagame_saccoldiskcpp">plugin_sa\game_sa\CColDisk.cpp</h3><h4>CColDisk::Set</h4>
<p>plugin::CallMethod<0x40FD50, CColDisk *, float, CVector const&, CVector const&, float, unsigned char, unsigned char, unsigned char>(this, startRadius, start, end, endRadius, material, pieceType, lighting);</p>
<p>0AA6: call_method 0x40FD50 struct [CColDisk] num_params 7 pop 0 [startRadius] [start] [end] [endRadius] [material] [pieceType] [lighting]</p>
<p>define function CColDisk__Set&lt;thiscall, 0x40FD50&gt;(startRadius, start, end, endRadius, material, pieceType, lighting)</p><h3 id="plugin_sagame_saccollisioncpp">plugin_sa\game_sa\CCollision.cpp</h3><h4>CCollision::Update</h4>
<p>plugin::Call<0x411E20>();</p>
<p>0AA5: call_function 0x411E20 num_params 0 pop 0</p>
<p>define function CCollision__Update&lt;cdecl, 0x411E20&gt;()</p>
<h4>CCollision::SortOutCollisionAfterLoad</h4>
<p>plugin::Call<0x411E30>();</p>
<p>0AA5: call_function 0x411E30 num_params 0 pop 0</p>
<p>define function CCollision__SortOutCollisionAfterLoad&lt;cdecl, 0x411E30&gt;()</p>
<h4>CCollision::TestSphereSphere</h4>
<p>plugin::CallAndReturn<bool, 0x411E70, CColSphere const&, CColSphere const&>(sphere1, sphere2);</p>
<p>0AA7: call_function_return 0x411E70 num_params 2 pop 2 [sphere1] [sphere2] func_ret [bool]</p>
<p>define function CCollision__TestSphereSphere&lt;cdecl, 0x411E70&gt;(sphere1, sphere2): int</p>
<h4>CalculateColPointInsideBox</h4>
<p>plugin::Call<0x411EC0, CBox const&, CVector const&, CColPoint&>(box, point, colPoint);</p>
<p>0AA5: call_function 0x411EC0 num_params 3 pop 3 [box] [point] [colPoint]</p>
<p>define function CalculateColPointInsideBox&lt;cdecl, 0x411EC0&gt;(box, point, colPoint)</p>
<h4>CCollision::TestSphereBox</h4>
<p>plugin::CallAndReturn<bool, 0x4120C0, CSphere const&, CBox const&>(sphere, box);</p>
<p>0AA7: call_function_return 0x4120C0 num_params 2 pop 2 [sphere] [box] func_ret [bool]</p>
<p>define function CCollision__TestSphereBox&lt;cdecl, 0x4120C0&gt;(sphere, box): int</p>
<h4>CCollision::ProcessSphereBox</h4>
<p>plugin::CallAndReturn<bool, 0x412130, CColSphere const&, CColBox const&, CColPoint&, float&>(sphere, box, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x412130 num_params 4 pop 4 [sphere] [box] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessSphereBox&lt;cdecl, 0x412130&gt;(sphere, box, colPoint, maxTouchDistance): int</p>
<h4>CCollision::PointInTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x412700, CVector const&, CVector const*>(point, triPoints);</p>
<p>0AA7: call_function_return 0x412700 num_params 2 pop 2 [point] [triPoints] func_ret [bool]</p>
<p>define function CCollision__PointInTriangle&lt;cdecl, 0x412700&gt;(point, triPoints): int</p>
<h4>CCollision::DistToLineSqr</h4>
<p>plugin::CallAndReturn<float, 0x412850, CVector const<em>, CVector const</em>, CVector const*>(lineStart, lineEnd, point);</p>
<p>0AA7: call_function_return 0x412850 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]</p>
<p>define function CCollision__DistToLineSqr&lt;cdecl, 0x412850&gt;(lineStart, lineEnd, point): float</p>
<h4>CCollision::DistToMathematicalLine</h4>
<p>plugin::CallAndReturn<float, 0x412970, CVector const<em>, CVector const</em>, CVector const*>(lineStart, lineEnd, point);</p>
<p>0AA7: call_function_return 0x412970 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]</p>
<p>define function CCollision__DistToMathematicalLine&lt;cdecl, 0x412970&gt;(lineStart, lineEnd, point): float</p>
<h4>CCollision::DistToMathematicalLine2D</h4>
<p>plugin::CallAndReturn<float, 0x412A30, float, float, float, float, float, float>(lineStartX, lineStartY, lineEndX, lineEndY, pointX, pointY);</p>
<p>0AA7: call_function_return 0x412A30 num_params 6 pop 6 [lineStartX] [lineStartY] [lineEndX] [lineEndY] [pointX] [pointY] func_ret [float]</p>
<p>define function CCollision__DistToMathematicalLine2D&lt;cdecl, 0x412A30&gt;(lineStartX, lineStartY, lineEndX, lineEndY, pointX, pointY): float</p>
<h4>CCollision::DistAlongLine2D</h4>
<p>plugin::CallAndReturn<float, 0x412A80, float, float, float, float, float, float>(lineX, lineY, lineDirX, lineDirY, pointX, pointY);</p>
<p>0AA7: call_function_return 0x412A80 num_params 6 pop 6 [lineX] [lineY] [lineDirX] [lineDirY] [pointX] [pointY] func_ret [float]</p>
<p>define function CCollision__DistAlongLine2D&lt;cdecl, 0x412A80&gt;(lineX, lineY, lineDirX, lineDirY, pointX, pointY): float</p>
<h4>CCollision::ProcessLineSphere</h4>
<p>plugin::CallAndReturn<bool, 0x412AA0, CColLine const&, CColSphere const&, CColPoint&, float&>(line, sphere, colPoint, depth);</p>
<p>0AA7: call_function_return 0x412AA0 num_params 4 pop 4 [line] [sphere] [colPoint] [depth] func_ret [bool]</p>
<p>define function CCollision__ProcessLineSphere&lt;cdecl, 0x412AA0&gt;(line, sphere, colPoint, depth): int</p>
<h4>CCollision::TestLineBox_DW</h4>
<p>plugin::CallAndReturn<bool, 0x412C70, CColLine const&, CBox const&>(line, box);</p>
<p>0AA7: call_function_return 0x412C70 num_params 2 pop 2 [line] [box] func_ret [bool]</p>
<p>define function CCollision__TestLineBox_DW&lt;cdecl, 0x412C70&gt;(line, box): int</p>
<h4>CCollision::TestLineBox</h4>
<p>plugin::CallAndReturn<bool, 0x413070, CColLine const&, CBox const&>(line, box);</p>
<p>0AA7: call_function_return 0x413070 num_params 2 pop 2 [line] [box] func_ret [bool]</p>
<p>define function CCollision__TestLineBox&lt;cdecl, 0x413070&gt;(line, box): int</p>
<h4>CCollision::TestVerticalLineBox</h4>
<p>plugin::CallAndReturn<bool, 0x413080, CColLine const&, CBox const&>(line, box);</p>
<p>0AA7: call_function_return 0x413080 num_params 2 pop 2 [line] [box] func_ret [bool]</p>
<p>define function CCollision__TestVerticalLineBox&lt;cdecl, 0x413080&gt;(line, box): int</p>
<h4>CCollision::ProcessLineBox</h4>
<p>plugin::CallAndReturn<bool, 0x413100, CColLine const&, CColBox const&, CColPoint&, float&>(line, box, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x413100 num_params 4 pop 4 [line] [box] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessLineBox&lt;cdecl, 0x413100&gt;(line, box, colPoint, maxTouchDistance): int</p>
<h4>CCollision::Test2DLineAgainst2DLine</h4>
<p>plugin::CallAndReturn<bool, 0x4138D0, float, float, float, float, float, float, float, float>(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY);</p>
<p>0AA7: call_function_return 0x4138D0 num_params 8 pop 8 [line1StartX] [line1StartY] [line1EndX] [line1EndY] [line2StartX] [line2StartY] [line2EndX] [line2EndY] func_ret [bool]</p>
<p>define function CCollision__Test2DLineAgainst2DLine&lt;cdecl, 0x4138D0&gt;(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY): int</p>
<h4>ProcessDiscCollision</h4>
<p>plugin::CallAndReturn<bool, 0x413960, CColPoint&, CMatrix const&, CColDisk const&, CColPoint&, bool&, float&, CColPoint&>(colPoint1, mat, disk, colPoint2, arg4, arg5, colPoint3);</p>
<p>0AA7: call_function_return 0x413960 num_params 7 pop 7 [colPoint1] [mat] [disk] [colPoint2] [arg4] [arg5] [colPoint3] func_ret [bool]</p>
<p>define function ProcessDiscCollision&lt;cdecl, 0x413960&gt;(colPoint1, mat, disk, colPoint2, arg4, arg5, colPoint3): int</p>
<h4>CCollision::TestLineTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x413AC0, CColLine const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(line, verts, tri, triPlane);</p>
<p>0AA7: call_function_return 0x413AC0 num_params 4 pop 4 [line] [verts] [tri] [triPlane] func_ret [bool]</p>
<p>define function CCollision__TestLineTriangle&lt;cdecl, 0x413AC0&gt;(line, verts, tri, triPlane): int</p>
<h4>CCollision::ProcessLineTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x4140F0, CColLine const&, CompressedVector const<em>, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly</em>>(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly);</p>
<p>0AA7: call_function_return 0x4140F0 num_params 7 pop 7 [line] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] [collPoly] func_ret [bool]</p>
<p>define function CCollision__ProcessLineTriangle&lt;cdecl, 0x4140F0&gt;(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly): int</p>
<h4>CCollision::ProcessVerticalLineTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x4147E0, CColLine const&, CompressedVector const<em>, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&, CStoredCollPoly</em>>(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly);</p>
<p>0AA7: call_function_return 0x4147E0 num_params 7 pop 7 [line] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] [collPoly] func_ret [bool]</p>
<p>define function CCollision__ProcessVerticalLineTriangle&lt;cdecl, 0x4147E0&gt;(line, verts, tri, triPlane, colPoint, maxTouchDistance, collPoly): int</p>
<h4>CCollision::IsStoredPolyStillValidVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x414D70, CVector const&, float, CColPoint&, CStoredCollPoly*>(lineOrigin, lineDist, colPoint, collPoly);</p>
<p>0AA7: call_function_return 0x414D70 num_params 4 pop 4 [lineOrigin] [lineDist] [colPoint] [collPoly] func_ret [bool]</p>
<p>define function CCollision__IsStoredPolyStillValidVerticalLine&lt;cdecl, 0x414D70&gt;(lineOrigin, lineDist, colPoint, collPoly): int</p>
<h4>CCollision::GetBoundingBoxFromTwoSpheres</h4>
<p>plugin::Call<0x415230, CColBox<em>, CColSphere</em>, CColSphere*>(bbox, sphere1, sphere2);</p>
<p>0AA5: call_function 0x415230 num_params 3 pop 3 [bbox] [sphere1] [sphere2]</p>
<p>define function CCollision__GetBoundingBoxFromTwoSpheres&lt;cdecl, 0x415230&gt;(bbox, sphere1, sphere2)</p>
<h4>CCollision::IsThisVehicleSittingOnMe</h4>
<p>plugin::CallAndReturn<bool, 0x4152C0, CVehicle<em>, CVehicle</em>>(vehicle, vehicleOnMe);</p>
<p>0AA7: call_function_return 0x4152C0 num_params 2 pop 2 [vehicle] [vehicleOnMe] func_ret [bool]</p>
<p>define function CCollision__IsThisVehicleSittingOnMe&lt;cdecl, 0x4152C0&gt;(vehicle, vehicleOnMe): int</p>
<h4>CCollision::CheckCameraCollisionPeds</h4>
<p>plugin::CallAndReturn<bool, 0x415320, int, int, CVector<em>, CVector</em>, float*>(sectorX, sectorY, pos, dir, arg4);</p>
<p>0AA7: call_function_return 0x415320 num_params 5 pop 5 [sectorX] [sectorY] [pos] [dir] [arg4] func_ret [bool]</p>
<p>define function CCollision__CheckCameraCollisionPeds&lt;cdecl, 0x415320&gt;(sectorX, sectorY, pos, dir, arg4): int</p>
<h4>CCollision::CheckPeds</h4>
<p>plugin::CallAndReturn<bool, 0x4154A0, CVector<em>, CVector</em>, float*>(pos, dir, arg2);</p>
<p>0AA7: call_function_return 0x4154A0 num_params 3 pop 3 [pos] [dir] [arg2] func_ret [bool]</p>
<p>define function CCollision__CheckPeds&lt;cdecl, 0x4154A0&gt;(pos, dir, arg2): int</p>
<h4>ResetMadeInvisibleObjects</h4>
<p>plugin::Call<0x415540>();</p>
<p>0AA5: call_function 0x415540 num_params 0 pop 0</p>
<p>define function ResetMadeInvisibleObjects&lt;cdecl, 0x415540&gt;()</p>
<h4>CCollision::SphereCastVsBBox</h4>
<p>plugin::CallAndReturn<bool, 0x415590, CColSphere<em>, CColSphere</em>, CColBox*>(sphere1, sphere2, box);</p>
<p>0AA7: call_function_return 0x415590 num_params 3 pop 3 [sphere1] [sphere2] [box] func_ret [bool]</p>
<p>define function CCollision__SphereCastVsBBox&lt;cdecl, 0x415590&gt;(sphere1, sphere2, box): int</p>
<h4>CCollision::RayPolyPOP</h4>
<p>plugin::CallAndReturn<bool, 0x415620, CVector<em>, CVector</em>, CColTriangle<em>, CVector</em>, CVector*>(arg0, arg1, arg2, arg3, arg4);</p>
<p>0AA7: call_function_return 0x415620 num_params 5 pop 5 [arg0] [arg1] [arg2] [arg3] [arg4] func_ret [bool]</p>
<p>define function CCollision__RayPolyPOP&lt;cdecl, 0x415620&gt;(arg0, arg1, arg2, arg3, arg4): int</p>
<h4>CCollision::GetPrincipleAxis</h4>
<p>plugin::CallAndReturn<int, 0x4156D0, CVector*>(vec);</p>
<p>0AA7: call_function_return 0x4156D0 num_params 1 pop 1 [vec] func_ret [int]</p>
<p>define function CCollision__GetPrincipleAxis&lt;cdecl, 0x4156D0&gt;(vec): int</p>
<h4>CCollision::PointInPoly</h4>
<p>plugin::CallAndReturn<bool, 0x415730, CVector<em>, CColTriangle</em>, CVector<em>, CVector</em>>(point, tri, arg2, triVerts);</p>
<p>0AA7: call_function_return 0x415730 num_params 4 pop 4 [point] [tri] [arg2] [triVerts] func_ret [bool]</p>
<p>define function CCollision__PointInPoly&lt;cdecl, 0x415730&gt;(point, tri, arg2, triVerts): int</p>
<h4>CCollision::Closest3</h4>
<p>plugin::Call<0x415950, CVector<em>, CVector</em>>(arg0, arg1);</p>
<p>0AA5: call_function 0x415950 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CCollision__Closest3&lt;cdecl, 0x415950&gt;(arg0, arg1)</p>
<h4>ClosestSquaredDistanceBetweenFiniteLines</h4>
<p>plugin::CallAndReturn<float, 0x415A40, CVector<em>, CVector</em>, CVector<em>, CVector</em>, float>(line1Start, line1End, line2Start, line2End, arg4);</p>
<p>0AA7: call_function_return 0x415A40 num_params 5 pop 5 [line1Start] [line1End] [line2Start] [line2End] [arg4] func_ret [float]</p>
<p>define function ClosestSquaredDistanceBetweenFiniteLines&lt;cdecl, 0x415A40&gt;(line1Start, line1End, line2Start, line2End, arg4): float</p>
<h4>CCollision::SphereCastVersusVsPoly</h4>
<p>plugin::CallAndReturn<bool, 0x415CF0, CColSphere<em>, CColSphere</em>, CColTriangle<em>, CColTrianglePlane</em>, CompressedVector*>(sphere1, sphere2, tri, triPlane, verts);</p>
<p>0AA7: call_function_return 0x415CF0 num_params 5 pop 5 [sphere1] [sphere2] [tri] [triPlane] [verts] func_ret [bool]</p>
<p>define function CCollision__SphereCastVersusVsPoly&lt;cdecl, 0x415CF0&gt;(sphere1, sphere2, tri, triPlane, verts): int</p>
<h4>CCollision::Init</h4>
<p>plugin::Call<0x416260>();</p>
<p>0AA5: call_function 0x416260 num_params 0 pop 0</p>
<p>define function CCollision__Init&lt;cdecl, 0x416260&gt;()</p>
<h4>CCollision::Shutdown</h4>
<p>plugin::Call<0x4162E0>();</p>
<p>0AA5: call_function 0x4162E0 num_params 0 pop 0</p>
<p>define function CCollision__Shutdown&lt;cdecl, 0x4162E0&gt;()</p>
<h4>CCollision::CalculateTrianglePlanes</h4>
<p>plugin::Call<0x416330, CCollisionData*>(colData);</p>
<p>0AA5: call_function 0x416330 num_params 1 pop 1 [colData]</p>
<p>define function CCollision__CalculateTrianglePlanes&lt;cdecl, 0x416330&gt;(colData)</p>
<h4>CCollision::RemoveTrianglePlanes</h4>
<p>plugin::Call<0x416400, CCollisionData*>(colData);</p>
<p>0AA5: call_function 0x416400 num_params 1 pop 1 [colData]</p>
<p>define function CCollision__RemoveTrianglePlanes&lt;cdecl, 0x416400&gt;(colData)</p>
<h4>CCollision::ProcessSphereSphere</h4>
<p>plugin::CallAndReturn<bool, 0x416450, CColSphere const&, CColSphere const&, CColPoint&, float&>(sphere1, sphere2, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x416450 num_params 4 pop 4 [sphere1] [sphere2] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessSphereSphere&lt;cdecl, 0x416450&gt;(sphere1, sphere2, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestSphereTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x4165B0, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&>(sphere, verts, tri, triPlane);</p>
<p>0AA7: call_function_return 0x4165B0 num_params 4 pop 4 [sphere] [verts] [tri] [triPlane] func_ret [bool]</p>
<p>define function CCollision__TestSphereTriangle&lt;cdecl, 0x4165B0&gt;(sphere, verts, tri, triPlane): int</p>
<h4>CCollision::ProcessSphereTriangle</h4>
<p>plugin::CallAndReturn<bool, 0x416BA0, CColSphere const&, CompressedVector const*, CColTriangle const&, CColTrianglePlane const&, CColPoint&, float&>(sphere, verts, tri, triPlane, colPoint, maxTouchDistance);</p>
<p>0AA7: call_function_return 0x416BA0 num_params 6 pop 6 [sphere] [verts] [tri] [triPlane] [colPoint] [maxTouchDistance] func_ret [bool]</p>
<p>define function CCollision__ProcessSphereTriangle&lt;cdecl, 0x416BA0&gt;(sphere, verts, tri, triPlane, colPoint, maxTouchDistance): int</p>
<h4>CCollision::TestLineSphere</h4>
<p>plugin::CallAndReturn<bool, 0x417470, CColLine const&, CColSphere const&>(line, sphere);</p>
<p>0AA7: call_function_return 0x417470 num_params 2 pop 2 [line] [sphere] func_ret [bool]</p>
<p>define function CCollision__TestLineSphere&lt;cdecl, 0x417470&gt;(line, sphere): int</p>
<h4>CCollision::DistToLine</h4>
<p>plugin::CallAndReturn<float, 0x417610, CVector const<em>, CVector const</em>, CVector const*>(lineStart, lineEnd, point);</p>
<p>0AA7: call_function_return 0x417610 num_params 3 pop 3 [lineStart] [lineEnd] [point] func_ret [float]</p>
<p>define function CCollision__DistToLine&lt;cdecl, 0x417610&gt;(lineStart, lineEnd, point): float</p>
<h4>CCollision::TestLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x417730, CColLine const&, CMatrix const&, CColModel&, bool, bool>(line, transform, colModel, doSeeThroughCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x417730 num_params 5 pop 5 [line] [transform] [colModel] [doSeeThroughCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CCollision__TestLineOfSight&lt;cdecl, 0x417730&gt;(line, transform, colModel, doSeeThroughCheck, doShootThroughCheck): int</p>
<h4>CCollision::ProcessLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x417950, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, bool>(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x417950 num_params 7 pop 7 [line] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CCollision__ProcessLineOfSight&lt;cdecl, 0x417950&gt;(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck): int</p>
<h4>CCollision::ProcessVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x417BF0, CColLine const&, CMatrix const&, CColModel&, CColPoint&, float&, bool, bool, CStoredCollPoly*>(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck, collPoly);</p>
<p>0AA7: call_function_return 0x417BF0 num_params 8 pop 8 [line] [transform] [colModel] [colPoint] [maxTouchDistance] [doSeeThroughCheck] [doShootThroughCheck] [collPoly] func_ret [bool]</p>
<p>define function CCollision__ProcessVerticalLine&lt;cdecl, 0x417BF0&gt;(line, transform, colModel, colPoint, maxTouchDistance, doSeeThroughCheck, doShootThroughCheck, collPoly): int</p>
<h4>CCollision::SphereCastVsSphere</h4>
<p>plugin::CallAndReturn<bool, 0x417F20, CColSphere<em>, CColSphere</em>, CColSphere*>(arg0, arg1, arg2);</p>
<p>0AA7: call_function_return 0x417F20 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [bool]</p>
<p>define function CCollision__SphereCastVsSphere&lt;cdecl, 0x417F20&gt;(arg0, arg1, arg2): int</p>
<h4>CCollision::ClosestPointOnLine</h4>
<p>plugin::Call<0x417FD0, CVector<em>, CVector</em>, CVector<em>, CVector</em>>(arg0, arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x417FD0 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CCollision__ClosestPointOnLine&lt;cdecl, 0x417FD0&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CCollision::ClosestPointsOnPoly</h4>
<p>plugin::Call<0x418100, CColTriangle<em>, CVector</em>, CVector<em>, CVector</em>>(arg0, arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x418100 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CCollision__ClosestPointsOnPoly&lt;cdecl, 0x418100&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CCollision::ClosestPointOnPoly</h4>
<p>plugin::Call<0x418150, CColTriangle<em>, CVector</em>, CVector*>(arg0, arg1, arg2);</p>
<p>0AA5: call_function 0x418150 num_params 3 pop 3 [arg0] [arg1] [arg2]</p>
<p>define function CCollision__ClosestPointOnPoly&lt;cdecl, 0x418150&gt;(arg0, arg1, arg2)</p>
<h4>CCollision::SphereCastVsCaches</h4>
<p>plugin::CallAndReturn<bool, 0x4181B0, CColSphere<em>, CVector</em>, int, CColCacheEntry<em>, int</em>, CColCacheEntry*>(sphere, arg1, arg2, arg3, arg4, arg5);</p>
<p>0AA7: call_function_return 0x4181B0 num_params 6 pop 6 [sphere] [arg1] [arg2] [arg3] [arg4] [arg5] func_ret [bool]</p>
<p>define function CCollision__SphereCastVsCaches&lt;cdecl, 0x4181B0&gt;(sphere, arg1, arg2, arg3, arg4, arg5): int</p>
<h4>CCollision::CalculateTrianglePlanes</h4>
<p>plugin::Call<0x418580, CColModel*>(colModel);</p>
<p>0AA5: call_function 0x418580 num_params 1 pop 1 [colModel]</p>
<p>define function CCollision__CalculateTrianglePlanes&lt;cdecl, 0x418580&gt;(colModel)</p>
<h4>CCollision::RemoveTrianglePlanes</h4>
<p>plugin::Call<0x4185A0, CColModel*>(colModel);</p>
<p>0AA5: call_function 0x4185A0 num_params 1 pop 1 [colModel]</p>
<p>define function CCollision__RemoveTrianglePlanes&lt;cdecl, 0x4185A0&gt;(colModel)</p>
<h4>CCollision::ProcessColModels</h4>
<p>plugin::CallAndReturn<int, 0x4185C0, CMatrix const&, CColModel&, CMatrix const&, CColModel&, CColPoint<em>, CColPoint</em>, float*, bool>(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance, arg7);</p>
<p>0AA7: call_function_return 0x4185C0 num_params 8 pop 8 [transform1] [colModel1] [transform2] [colModel2] [colPoint1] [colPoint2] [maxTouchDistance] [arg7] func_ret [int]</p>
<p>define function CCollision__ProcessColModels&lt;cdecl, 0x4185C0&gt;(transform1, colModel1, transform2, colModel2, colPoint1, colPoint2, maxTouchDistance, arg7): int</p>
<h4>CCollision::SphereCastVsEntity</h4>
<p>plugin::CallAndReturn<bool, 0x419F00, CColSphere<em>, CColSphere</em>, CEntity*>(sphere1, sphere2, entity);</p>
<p>0AA7: call_function_return 0x419F00 num_params 3 pop 3 [sphere1] [sphere2] [entity] func_ret [bool]</p>
<p>define function CCollision__SphereCastVsEntity&lt;cdecl, 0x419F00&gt;(sphere1, sphere2, entity): int</p>
<h4>CCollision::SphereVsEntity</h4>
<p>plugin::CallAndReturn<bool, 0x41A5A0, CColSphere<em>, CEntity</em>>(sphere, entity);</p>
<p>0AA7: call_function_return 0x41A5A0 num_params 2 pop 2 [sphere] [entity] func_ret [bool]</p>
<p>define function CCollision__SphereVsEntity&lt;cdecl, 0x41A5A0&gt;(sphere, entity): int</p>
<h4>CCollision::CheckCameraCollisionBuildings</h4>
<p>plugin::CallAndReturn<bool, 0x41A820, int, int, CColBox<em>, CColSphere</em>, CColSphere<em>, CColSphere</em>>(sectorX, sectorY, arg2, arg3, arg4, arg5);</p>
<p>0AA7: call_function_return 0x41A820 num_params 6 pop 6 [sectorX] [sectorY] [arg2] [arg3] [arg4] [arg5] func_ret [bool]</p>
<p>define function CCollision__CheckCameraCollisionBuildings&lt;cdecl, 0x41A820&gt;(sectorX, sectorY, arg2, arg3, arg4, arg5): int</p>
<h4>CCollision::CheckCameraCollisionVehicles</h4>
<p>plugin::CallAndReturn<bool, 0x41A990, int, int, CColBox<em>, CColSphere</em>, CColSphere<em>, CColSphere</em>, CVector*>(sectorX, sectorY, arg2, arg3, arg4, arg5, arg6);</p>
<p>0AA7: call_function_return 0x41A990 num_params 7 pop 7 [sectorX] [sectorY] [arg2] [arg3] [arg4] [arg5] [arg6] func_ret [bool]</p>
<p>define function CCollision__CheckCameraCollisionVehicles&lt;cdecl, 0x41A990&gt;(sectorX, sectorY, arg2, arg3, arg4, arg5, arg6): int</p>
<h4>CCollision::CheckCameraCollisionObjects</h4>
<p>plugin::CallAndReturn<bool, 0x41AB20, int, int, CColBox<em>, CColSphere</em>, CColSphere<em>, CColSphere</em>>(sectorX, sectorY, arg2, arg3, arg4, arg5);</p>
<p>0AA7: call_function_return 0x41AB20 num_params 6 pop 6 [sectorX] [sectorY] [arg2] [arg3] [arg4] [arg5] func_ret [bool]</p>
<p>define function CCollision__CheckCameraCollisionObjects&lt;cdecl, 0x41AB20&gt;(sectorX, sectorY, arg2, arg3, arg4, arg5): int</p>
<h4>CCollision::BuildCacheOfCameraCollision</h4>
<p>plugin::CallAndReturn<bool, 0x41AC40, CColSphere<em>, CColSphere</em>>(sphere1, sphere2);</p>
<p>0AA7: call_function_return 0x41AC40 num_params 2 pop 2 [sphere1] [sphere2] func_ret [bool]</p>
<p>define function CCollision__BuildCacheOfCameraCollision&lt;cdecl, 0x41AC40&gt;(sphere1, sphere2): int</p>
<h4>CCollision::CameraConeCastVsWorldCollision</h4>
<p>plugin::CallAndReturn<bool, 0x41B000, CColSphere<em>, CColSphere</em>, float*, float>(sphere1, sphere2, arg2, arg3);</p>
<p>0AA7: call_function_return 0x41B000 num_params 4 pop 4 [sphere1] [sphere2] [arg2] [arg3] func_ret [bool]</p>
<p>define function CCollision__CameraConeCastVsWorldCollision&lt;cdecl, 0x41B000&gt;(sphere1, sphere2, arg2, arg3): int</p><h3 id="plugin_sagame_saccollisiondatacpp">plugin_sa\game_sa\CCollisionData.cpp</h3><h4>CCollisionData::CCollisionData</h4>
<p>plugin::CallMethod<0x40F030, CCollisionData *>(this);</p>
<p>0AA6: call_method 0x40F030 struct [CCollisionData] num_params 0 pop 0</p>
<p>define function CCollisionData__CCollisionData&lt;thiscall, 0x40F030&gt;()</p>
<h4>CCollisionData::RemoveCollisionVolumes</h4>
<p>plugin::CallMethod<0x40F070, CCollisionData *>(this);</p>
<p>0AA6: call_method 0x40F070 struct [CCollisionData] num_params 0 pop 0</p>
<p>define function CCollisionData__RemoveCollisionVolumes&lt;thiscall, 0x40F070&gt;()</p>
<h4>CCollisionData::Copy</h4>
<p>plugin::CallMethod<0x40F120, CCollisionData *, CCollisionData const&>(this, arg0);</p>
<p>0AA6: call_method 0x40F120 struct [CCollisionData] num_params 1 pop 0 [arg0]</p>
<p>define function CCollisionData__Copy&lt;thiscall, 0x40F120&gt;(arg0)</p>
<h4>CCollisionData::CalculateTrianglePlanes</h4>
<p>plugin::CallMethod<0x40F590, CCollisionData *>(this);</p>
<p>0AA6: call_method 0x40F590 struct [CCollisionData] num_params 0 pop 0</p>
<p>define function CCollisionData__CalculateTrianglePlanes&lt;thiscall, 0x40F590&gt;()</p>
<h4>CCollisionData::GetTrianglePoint</h4>
<p>plugin::CallMethod<0x40F5E0, CCollisionData *, CVector&, int>(this, outVec, vertId);</p>
<p>0AA6: call_method 0x40F5E0 struct [CCollisionData] num_params 2 pop 0 [outVec] [vertId]</p>
<p>define function CCollisionData__GetTrianglePoint&lt;thiscall, 0x40F5E0&gt;(outVec, vertId)</p>
<h4>CCollisionData::GetShadTrianglePoint</h4>
<p>plugin::CallMethod<0x40F640, CCollisionData *, CVector&, int>(this, outVec, vertId);</p>
<p>0AA6: call_method 0x40F640 struct [CCollisionData] num_params 2 pop 0 [outVec] [vertId]</p>
<p>define function CCollisionData__GetShadTrianglePoint&lt;thiscall, 0x40F640&gt;(outVec, vertId)</p>
<h4>CCollisionData::RemoveTrianglePlanes</h4>
<p>plugin::CallMethod<0x40F6A0, CCollisionData *>(this);</p>
<p>0AA6: call_method 0x40F6A0 struct [CCollisionData] num_params 0 pop 0</p>
<p>define function CCollisionData__RemoveTrianglePlanes&lt;thiscall, 0x40F6A0&gt;()</p>
<h4>CCollisionData::SetLinkPtr</h4>
<p>plugin::CallMethod<0x40F6C0, CCollisionData <em>, CLink<CCollisionData</em>> *&gt;(this, link);</p>
<p>0AA6: call_method 0x40F6C0 struct [CCollisionData] num_params 1 pop 0 [link]</p>
<p>define function CCollisionData__SetLinkPtr&lt;thiscall, 0x40F6C0&gt;(link)</p>
<h4>*CCollisionData::GetLinkPtr</h4>
<p>plugin::CallMethodAndReturn<CLink<CCollisionData*> *, 0x40F6E0, CCollisionData *&gt;(this);</p>
<p>0AA8: call_method_return 0x40F6E0 struct [<em>CCollisionData] num_params 0 pop 0 func_ret [CLink<CCollisionData</em>&gt; *]</p>
<p>define function CCollisionData__GetLinkPtr&lt;thiscall, 0x40F6E0&gt;(): int</p><h3 id="plugin_sagame_saccolmodelcpp">plugin_sa\game_sa\CColModel.cpp</h3><h4>CColModel::CColModel</h4>
<p>plugin::CallMethod<0x40FB60, CColModel *>(this);</p>
<p>0AA6: call_method 0x40FB60 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__CColModel&lt;thiscall, 0x40FB60&gt;()</p>
<h4>CColModel::~CColModel</h4>
<p>plugin::CallMethod<0x40F700, CColModel *>(this);</p>
<p>0AA6: call_method 0x40F700 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__~CColModel&lt;thiscall, 0x40F700&gt;()</p>
<h4>CColModel::MakeMultipleAlloc</h4>
<p>plugin::CallMethod<0x40F740, CColModel *>(this);</p>
<p>0AA6: call_method 0x40F740 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__MakeMultipleAlloc&lt;thiscall, 0x40F740&gt;()</p>
<h4>CColModel::operator=</h4>
<p>plugin::CallMethodAndReturn<CColModel&, 0x40F7C0, CColModel *, CColModel const&>(this, colModel);</p>
<p>0AA8: call_method_return 0x40F7C0 struct [CColModel] num_params 1 pop 0 [colModel] func_ret [CColModel&amp;]</p>
<p>define function CColModel__operator=&lt;thiscall, 0x40F7C0&gt;(colModel): int</p>
<h4>CColModel::AllocateData</h4>
<p>plugin::CallMethod<0x40F810, CColModel *>(this);</p>
<p>0AA6: call_method 0x40F810 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__AllocateData&lt;thiscall, 0x40F810&gt;()</p>
<h4>CColModel::AllocateData</h4>
<p>plugin::CallMethod<0x40F870, CColModel *, int, int, int, int, int, bool>(this, numSpheres, numBoxes, numLines, numVertices, numTriangles, disks);</p>
<p>0AA6: call_method 0x40F870 struct [CColModel] num_params 6 pop 0 [numSpheres] [numBoxes] [numLines] [numVertices] [numTriangles] [disks]</p>
<p>define function CColModel__AllocateData&lt;thiscall, 0x40F870&gt;(numSpheres, numBoxes, numLines, numVertices, numTriangles, disks)</p>
<h4>CColModel::AllocateData</h4>
<p>plugin::CallMethod<0x40F9B0, CColModel *, int>(this, size);</p>
<p>0AA6: call_method 0x40F9B0 struct [CColModel] num_params 1 pop 0 [size]</p>
<p>define function CColModel__AllocateData&lt;thiscall, 0x40F9B0&gt;(size)</p>
<h4>CColModel::RemoveCollisionVolumes</h4>
<p>plugin::CallMethod<0x40F9E0, CColModel *>(this);</p>
<p>0AA6: call_method 0x40F9E0 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__RemoveCollisionVolumes&lt;thiscall, 0x40F9E0&gt;()</p>
<h4>CColModel::CalculateTrianglePlanes</h4>
<p>plugin::CallMethod<0x40FA30, CColModel *>(this);</p>
<p>0AA6: call_method 0x40FA30 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__CalculateTrianglePlanes&lt;thiscall, 0x40FA30&gt;()</p>
<h4>CColModel::RemoveTrianglePlanes</h4>
<p>plugin::CallMethod<0x40FA40, CColModel *>(this);</p>
<p>0AA6: call_method 0x40FA40 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__RemoveTrianglePlanes&lt;thiscall, 0x40FA40&gt;()</p>
<h4>CColModel::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x40FC30, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x40FC30 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CColModel__operator new&lt;cdecl, 0x40FC30&gt;(size): int</p>
<h4>CColModel::operator delete</h4>
<p>plugin::Call<0x40FC40, void*>(data);</p>
<p>0AA5: call_function 0x40FC40 num_params 1 pop 1 [data]</p>
<p>define function CColModel__operator delete&lt;cdecl, 0x40FC40&gt;(data)</p><h3 id="plugin_sagame_saccoloursetcpp">plugin_sa\game_sa\CColourSet.cpp</h3><h4>CColourSet::CColourSet</h4>
<p>plugin::CallMethod<0x55F4B0, CColourSet *, int, int>(this, weatherId, timeId);</p>
<p>0AA6: call_method 0x55F4B0 struct [CColourSet] num_params 2 pop 0 [weatherId] [timeId]</p>
<p>define function CColourSet__CColourSet&lt;thiscall, 0x55F4B0&gt;(weatherId, timeId)</p>
<h4>CColourSet::Interpolate</h4>
<p>plugin::CallMethod<0x55F870, CColourSet <em>, CColourSet</em>, CColourSet*, float, float, bool>(this, a, b, factor_a, factor_b, bIgnoreSky);</p>
<p>0AA6: call_method 0x55F870 struct [CColourSet] num_params 5 pop 0 [a] [b] [factor_a] [factor_b] [bIgnoreSky]</p>
<p>define function CColourSet__Interpolate&lt;thiscall, 0x55F870&gt;(a, b, factor_a, factor_b, bIgnoreSky)</p><h3 id="plugin_sagame_saccontrollerconfigmanagercpp">plugin_sa\game_sa\CControllerConfigManager.cpp</h3><h4>CControllerConfigManager::GetIsKeyboardKeyDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x52DDB0, CControllerConfigManager *, RsKeyCodes>(this, key);</p>
<p>0AA8: call_method_return 0x52DDB0 struct [CControllerConfigManager] num_params 1 pop 0 [key] func_ret [bool]</p>
<p>define function CControllerConfigManager__GetIsKeyboardKeyDown&lt;thiscall, 0x52DDB0&gt;(key): int</p>
<h4>CControllerConfigManager::GetIsKeyboardKeyJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x52E450, CControllerConfigManager *, RsKeyCodes>(this, key);</p>
<p>0AA8: call_method_return 0x52E450 struct [CControllerConfigManager] num_params 1 pop 0 [key] func_ret [bool]</p>
<p>define function CControllerConfigManager__GetIsKeyboardKeyJustDown&lt;thiscall, 0x52E450&gt;(key): int</p>
<h4>CControllerConfigManager::ResetSettingOrder</h4>
<p>plugin::CallMethod<0x52F5F0, CControllerConfigManager*, e_ControllerAction>(this, action);</p>
<p>0AA6: call_method 0x52F5F0 struct [CControllerConfigManager] num_params 1 pop 0 [action]</p>
<p>define function CControllerConfigManager__ResetSettingOrder&lt;thiscall, 0x52F5F0&gt;(action)</p><h3 id="plugin_sagame_saccovercpp">plugin_sa\game_sa\CCover.cpp</h3><h4>CCover::AddCoverPoint</h4>
<p>plugin::CallDynGlobal<int, CEntity *, CVector *, char, unsigned char>(gaddrof(CCover::AddCoverPoint), maxPeds, coverEntity, position, coverType, direction);</p>
<h4>CCover::CalculateHorizontalSize</h4>
<p>plugin::CallAndReturnDynGlobal<float, CColTriangle *, CVector *>(gaddrof(CCover::CalculateHorizontalSize), triangle, vertPositions);</p>
<p>0AA7: call_function_return 0x6987F0 num_params 2 pop 2 [triangle] [vertPositions] func_ret [float]</p>
<p>define function CCover__CalculateHorizontalSize&lt;cdecl, 0x6987F0&gt;(triangle, vertPositions): float</p>
<h4>CCover::DoLineCheckWithinObject</h4>
<p>plugin::CallAndReturnDynGlobal<char, CColTriangle *, int, CVector *, CVector *, CVector, CVector>(gaddrof(CCover::DoLineCheckWithinObject), triangle, a2, a3, a4, a5, a6);</p>
<p>0AA7: call_function_return 0x698990 num_params 6 pop 6 [triangle] [a2] [a3] [a4] [a5] [a6] func_ret [char]</p>
<p>define function CCover__DoLineCheckWithinObject&lt;cdecl, 0x698990&gt;(triangle, a2, a3, a4, a5, a6): int</p>
<h4>CCover::DoesCoverPointStillProvideCover</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CCoverPoint *, CVector>(gaddrof(CCover::DoesCoverPointStillProvideCover), point, position);</p>
<p>0AA7: call_function_return 0x698DD0 num_params 2 pop 2 [point] [position] func_ret [bool]</p>
<p>define function CCover__DoesCoverPointStillProvideCover&lt;cdecl, 0x698DD0&gt;(point, position): int</p>
<h4>CCover::Find2HighestPoints</h4>
<p>plugin::CallDynGlobal<CColTriangle *, CVector *, int &, int &>(gaddrof(CCover::Find2HighestPoints), triangle, vertPositions, outPoint1, outPoint2);</p>
<h4>*CCover::FindAndReserveCoverPoint</h4>
<p>plugin::CallAndReturnDynGlobal<CCoverPoint *, CPed *, CVector &, bool>(gaddrof(CCover::FindAndReserveCoverPoint), ped, position, a3);</p>
<p>0AA7: call_function_return 0x6992B0 num_params 3 pop 3 [ped] [position] [a3] func_ret [CCoverPoint *]</p>
<p>define function CCover__FindAndReserveCoverPoint&lt;cdecl, 0x6992B0&gt;(ped, position, a3): int</p>
<h4>CCover::FindCoordinatesCoverPoint</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CCoverPoint *, CPed *, CVector &, CVector &>(gaddrof(CCover::FindCoordinatesCoverPoint), point, ped, position, outCoordinates);</p>
<p>0AA7: call_function_return 0x699570 num_params 4 pop 4 [point] [ped] [position] [outCoordinates] func_ret [bool]</p>
<p>define function CCover__FindCoordinatesCoverPoint&lt;cdecl, 0x699570&gt;(point, ped, position, outCoordinates): int</p>
<h4>CCover::FindCoverPointsForThisBuilding</h4>
<p>plugin::CallDynGlobal<CBuilding *>(gaddrof(CCover::FindCoverPointsForThisBuilding), building);</p>
<h4>CCover::FindDirFromVector</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char, float, float>(gaddrof(CCover::FindDirFromVector), x, y);</p>
<p>0AA7: call_function_return 0x698D40 num_params 2 pop 2 [x] [y] func_ret [unsigned char]</p>
<p>define function CCover__FindDirFromVector&lt;cdecl, 0x698D40&gt;(x, y): int</p>
<h4>CCover::RemoveCoverPointIfEntityLost</h4>
<p>plugin::CallDynGlobal<CCoverPoint *>(gaddrof(CCover::RemoveCoverPointIfEntityLost), point);</p>
<h4>CCover::RemoveCoverPointsForThisEntity</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CCover::RemoveCoverPointsForThisEntity), entity);</p>
<h4>CCover::ShouldThisBuildingHaveItsCoverPointsCreated</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CBuilding *>(gaddrof(CCover::ShouldThisBuildingHaveItsCoverPointsCreated), building);</p>
<p>0AA7: call_function_return 0x699230 num_params 1 pop 1 [building] func_ret [bool]</p>
<p>define function CCover__ShouldThisBuildingHaveItsCoverPointsCreated&lt;cdecl, 0x699230&gt;(building): int</p><h3 id="plugin_sagame_saccoverpointcpp">plugin_sa\game_sa\CCoverPoint.cpp</h3><h4>CCoverPoint::CanAccomodateAnotherPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCoverPoint *>(gaddrof(CCoverPoint::CanAccomodateAnotherPed), this);</p>
<p>0AA8: call_method_return 0x698E70 struct [CCoverPoint] num_params 0 pop 0 func_ret [bool]</p>
<h4>CCoverPoint::ReleaseCoverPointForPed</h4>
<p>plugin::CallMethodDynGlobal<CCoverPoint *, CPed *>(gaddrof(CCoverPoint::ReleaseCoverPointForPed), this, ped);</p>
<p>0AA6: call_method 0x698EF0 struct [CCoverPoint] num_params 1 pop 0 [ped]</p>
<p>define function CCoverPoint__ReleaseCoverPointForPed&lt;thiscall, 0x698EF0&gt;(ped)</p>
<h4>CCoverPoint::ReserveCoverPointForPed</h4>
<p>plugin::CallMethodDynGlobal<CCoverPoint *, CPed *>(gaddrof(CCoverPoint::ReserveCoverPointForPed), this, ped);</p>
<p>0AA6: call_method 0x698EB0 struct [CCoverPoint] num_params 1 pop 0 [ped]</p>
<p>define function CCoverPoint__ReserveCoverPointForPed&lt;thiscall, 0x698EB0&gt;(ped)</p><h3 id="plugin_sagame_saccreditscpp">plugin_sa\game_sa\CCredits.cpp</h3><h4>CCredits::Render</h4>
<p>plugin::Call<0x53D5B0>();</p>
<p>0AA5: call_function 0x53D5B0 num_params 0 pop 0</p>
<p>define function CCredits__Render&lt;cdecl, 0x53D5B0&gt;()</p>
<h4>CCredits::PrintCreditText</h4>
<p>plugin::Call<0x5A8660, float, float, unsigned short*, unsigned int&, float, bool>(scaleX, scaleY, text, position, currentOffset, highlighted);</p>
<p>0AA5: call_function 0x5A8660 num_params 6 pop 6 [scaleX] [scaleY] [text] [position] [currentOffset] [highlighted]</p>
<p>define function CCredits__PrintCreditText&lt;cdecl, 0x5A8660&gt;(scaleX, scaleY, text, position, currentOffset, highlighted)</p>
<h4>CCredits::PrintCreditSpace</h4>
<p>plugin::Call<0x5A87C0, float, unsigned int&>(spaceSize, position);</p>
<p>0AA5: call_function 0x5A87C0 num_params 2 pop 2 [spaceSize] [position]</p>
<p>define function CCredits__PrintCreditSpace&lt;cdecl, 0x5A87C0&gt;(spaceSize, position)</p>
<h4>CCredits::RenderCredits</h4>
<p>plugin::Call<0x5A87F0>();</p>
<p>0AA5: call_function 0x5A87F0 num_params 0 pop 0</p>
<p>define function CCredits__RenderCredits&lt;cdecl, 0x5A87F0&gt;()</p>
<h4>CCredits::Start</h4>
<p>plugin::Call<0x7170E0>();</p>
<p>0AA5: call_function 0x7170E0 num_params 0 pop 0</p>
<p>define function CCredits__Start&lt;cdecl, 0x7170E0&gt;()</p>
<h4>CCredits::Stop</h4>
<p>plugin::Call<0x717100>();</p>
<p>0AA5: call_function 0x717100 num_params 0 pop 0</p>
<p>define function CCredits__Stop&lt;cdecl, 0x717100&gt;()</p><h3 id="plugin_sagame_saccullzonescpp">plugin_sa\game_sa\CCullZones.cpp</h3><h4>CZoneDef::IsPointWithin</h4>
<p>plugin::CallMethodAndReturn<bool, 0x72D850>(this, point);</p>
<p>0AA8: call_method_return 0x72D850 struct [CZoneDef] num_params 1 pop 0 [point] func_ret [bool]</p>
<p>define function CZoneDef__IsPointWithin&lt;thiscall, 0x72D850&gt;(point): int</p>
<h4>CCullZones::Init</h4>
<p>plugin::Call<0x72D6B0>();</p>
<p>0AA5: call_function 0x72D6B0 num_params 0 pop 0</p>
<p>define function CCullZones__Init&lt;cdecl, 0x72D6B0&gt;()</p>
<h4>CCullZones::Update</h4>
<p>plugin::Call<0x72DEC0>();</p>
<p>0AA5: call_function 0x72DEC0 num_params 0 pop 0</p>
<p>define function CCullZones__Update&lt;cdecl, 0x72DEC0&gt;()</p>
<h4>CCullZones::AddCullZone</h4>
<p>plugin::Call<0x72DF70>();</p>
<p>0AA5: call_function 0x72DF70 num_params 0 pop 0</p>
<p>define function CCullZones__AddCullZone&lt;cdecl, 0x72DF70&gt;()</p>
<h4>CCullZones::AddTunnelAttributeZone</h4>
<p>plugin::Call<0x72DB50>();</p>
<p>0AA5: call_function 0x72DB50 num_params 0 pop 0</p>
<p>define function CCullZones__AddTunnelAttributeZone&lt;cdecl, 0x72DB50&gt;()</p>
<h4>CCullZones::AddMirrorAttributeZone</h4>
<p>plugin::Call<0x72DC10>();</p>
<p>0AA5: call_function 0x72DC10 num_params 0 pop 0</p>
<p>define function CCullZones__AddMirrorAttributeZone&lt;cdecl, 0x72DC10&gt;()</p>
<h4>CCullZones::InRoomForAudio</h4>
<p>plugin::CallAndReturn<bool, 0x72DD70>();</p>
<p>0AA7: call_function_return 0x72DD70 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__InRoomForAudio&lt;cdecl, 0x72DD70&gt;(): int</p>
<h4>CCullZones::FewerCars</h4>
<p>plugin::CallAndReturn<bool, 0x72DD80>();</p>
<p>0AA7: call_function_return 0x72DD80 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__FewerCars&lt;cdecl, 0x72DD80&gt;(): int</p>
<h4>CCullZones::CamNoRain</h4>
<p>plugin::CallAndReturn<bool, 0x72DDB0>();</p>
<p>0AA7: call_function_return 0x72DDB0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__CamNoRain&lt;cdecl, 0x72DDB0&gt;(): int</p>
<h4>CCullZones::PlayerNoRain</h4>
<p>plugin::CallAndReturn<bool, 0x72DDC0>();</p>
<p>0AA7: call_function_return 0x72DDC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__PlayerNoRain&lt;cdecl, 0x72DDC0&gt;(): int</p>
<h4>CCullZones::FewerPeds</h4>
<p>plugin::CallAndReturn<bool, 0x72DD90>();</p>
<p>0AA7: call_function_return 0x72DD90 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__FewerPeds&lt;cdecl, 0x72DD90&gt;(): int</p>
<h4>CCullZones::NoPolice</h4>
<p>plugin::CallAndReturn<bool, 0x72DD50>();</p>
<p>0AA7: call_function_return 0x72DD50 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__NoPolice&lt;cdecl, 0x72DD50&gt;(): int</p>
<h4>CCullZones::DoExtraAirResistanceForPlayer</h4>
<p>plugin::CallAndReturn<bool, 0x72DDD0>();</p>
<p>0AA7: call_function_return 0x72DDD0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCullZones__DoExtraAirResistanceForPlayer&lt;cdecl, 0x72DDD0&gt;(): int</p>
<h4>CCullZones::FindTunnelAttributesForCoors</h4>
<p>plugin::CallAndReturn<eZoneAttributes, 0x72D9F0>(point);</p>
<p>0AA7: call_function_return 0x72D9F0 num_params 1 pop 1 [point] func_ret [eZoneAttributes]</p>
<p>define function CCullZones__FindTunnelAttributesForCoors&lt;cdecl, 0x72D9F0&gt;(point): int</p>
<h4>CCullZones::FindMirrorAttributesForCoors</h4>
<p>plugin::CallAndReturn<CCullZoneReflection*, 0x72DA70>(cameraPosition);</p>
<p>0AA7: call_function_return 0x72DA70 num_params 1 pop 1 [cameraPosition] func_ret [CCullZoneReflection*]</p>
<p>define function CCullZones__FindMirrorAttributesForCoors&lt;cdecl, 0x72DA70&gt;(cameraPosition): int</p>
<h4>CCullZones::FindZoneWithStairsAttributeForPlayer</h4>
<p>plugin::CallAndReturn<CCullZone*, 0x72DAD0>();</p>
<p>0AA7: call_function_return 0x72DAD0 num_params 0 pop 0 func_ret [CCullZone*]</p>
<p>define function CCullZones__FindZoneWithStairsAttributeForPlayer&lt;cdecl, 0x72DAD0&gt;(): int</p>
<h4>CCullZones::FindAttributesForCoors</h4>
<p>plugin::CallAndReturn<eZoneAttributes, 0x72D970>(pos);</p>
<p>0AA7: call_function_return 0x72D970 num_params 1 pop 1 [pos] func_ret [eZoneAttributes]</p>
<p>define function CCullZones__FindAttributesForCoors&lt;cdecl, 0x72D970&gt;(pos): int</p><h3 id="plugin_sagame_saccustomcarenvmappipelinecpp">plugin_sa\game_sa\CCustomCarEnvMapPipeline.cpp</h3><h4>CCustomCarEnvMapPipeline::CustomPipeInstanceCB</h4>
<p>plugin::CallAndReturn<int,0x5D8490, int, int, int(__cdecl *)(int, int, int)>(arg1, arg2, callback);</p>
<p>0AA7: call_function_return 0x5D8490 num_params 3 pop 3 [arg1] [arg2] [callback] func_ret [int]</p>
<p>define function CCustomCarEnvMapPipeline__CustomPipeInstanceCB&lt;cdecl, 0x5D8490&gt;(arg1, arg2, callback): int</p>
<h4>CCustomCarEnvMapPipeline::PreRenderUpdate</h4>
<p>plugin::Call<0x5D8870>();</p>
<p>0AA5: call_function 0x5D8870 num_params 0 pop 0</p>
<p>define function CCustomCarEnvMapPipeline__PreRenderUpdate&lt;cdecl, 0x5D8870&gt;()</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvMatConstructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D8BD0, void</em>, int>(object, offset);</p>
<p>0AA7: call_function_return 0x5D8BD0 num_params 2 pop 2 [object] [offset] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvMatConstructorCB&lt;cdecl, 0x5D8BD0&gt;(object, offset): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvMatStreamWriteCB</h4>
<p>plugin::CallAndReturn<RwStream<em>, 0x5D8CD0, RwStream</em>, int, void const*, int>(stream, length, arg3, arg4);</p>
<p>0AA7: call_function_return 0x5D8CD0 num_params 4 pop 4 [stream] [length] [arg3] [arg4] func_ret [RwStream*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvMatStreamWriteCB&lt;cdecl, 0x5D8CD0&gt;(stream, length, arg3, arg4): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvMatStreamGetSizeCB</h4>
<p>plugin::CallAndReturn<int, 0x5D8D10, void const*>(arg0);</p>
<p>0AA7: call_function_return 0x5D8D10 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvMatStreamGetSizeCB&lt;cdecl, 0x5D8D10&gt;(arg0): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvAtmConstructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D8D30, void</em>, int>(object, offset);</p>
<p>0AA7: call_function_return 0x5D8D30 num_params 2 pop 2 [object] [offset] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvAtmConstructorCB&lt;cdecl, 0x5D8D30&gt;(object, offset): int</p>
<h4>CCustomCarEnvMapPipeline::pluginSpecMatConstructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D8D40, void</em>>(object);</p>
<p>0AA7: call_function_return 0x5D8D40 num_params 1 pop 1 [object] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginSpecMatConstructorCB&lt;cdecl, 0x5D8D40&gt;(object): int</p>
<h4>CCustomCarEnvMapPipeline::pluginSpecMatStreamWriteCB</h4>
<p>plugin::CallAndReturn<RwStream<em>, 0x5D8D60, RwStream</em>, int, void const*>(stream, length, object);</p>
<p>0AA7: call_function_return 0x5D8D60 num_params 3 pop 3 [stream] [length] [object] func_ret [RwStream*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginSpecMatStreamWriteCB&lt;cdecl, 0x5D8D60&gt;(stream, length, object): int</p>
<h4>CCustomCarEnvMapPipeline::pluginSpecMatStreamGetSizeCB</h4>
<p>plugin::CallAndReturn<signed int, 0x5D8DD0>();</p>
<p>0AA7: call_function_return 0x5D8DD0 num_params 0 pop 0 func_ret [signed int]</p>
<p>define function CCustomCarEnvMapPipeline__pluginSpecMatStreamGetSizeCB&lt;cdecl, 0x5D8DD0&gt;(): int</p>
<h4>CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData</h4>
<p>plugin::CallAndReturn<CustomEnvMapPipeMaterialData<em>, 0x5D9570, CustomEnvMapPipeMaterialData</em>*>(arg0);</p>
<p>0AA7: call_function_return 0x5D9570 num_params 1 pop 1 [arg0] func_ret [CustomEnvMapPipeMaterialData*]</p>
<p>define function CCustomCarEnvMapPipeline__DuplicateCustomEnvMapPipeMaterialData&lt;cdecl, 0x5D9570&gt;(arg0): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvMatDestructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D95B0, void</em>, int>(object, offset);</p>
<p>0AA7: call_function_return 0x5D95B0 num_params 2 pop 2 [object] [offset] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvMatDestructorCB&lt;cdecl, 0x5D95B0&gt;(object, offset): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvMatCopyConstructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D9600, void</em>, void const*, int, int>(object_dst, object_src, offset, size);</p>
<p>0AA7: call_function_return 0x5D9600 num_params 4 pop 4 [object_dst] [object_src] [offset] [size] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvMatCopyConstructorCB&lt;cdecl, 0x5D9600&gt;(object_dst, object_src, offset, size): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvMatStreamReadCB</h4>
<p>plugin::CallAndReturn<RwStream<em>, 0x5D9660, RwStream</em>, int, void*, int>(stream, length, object, offset);</p>
<p>0AA7: call_function_return 0x5D9660 num_params 4 pop 4 [stream] [length] [object] [offset] func_ret [RwStream*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvMatStreamReadCB&lt;cdecl, 0x5D9660&gt;(stream, length, object, offset): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvAtmDestructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D9730, void</em>, int>(object, offset);</p>
<p>0AA7: call_function_return 0x5D9730 num_params 2 pop 2 [object] [offset] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvAtmDestructorCB&lt;cdecl, 0x5D9730&gt;(object, offset): int</p>
<h4>CCustomCarEnvMapPipeline::pluginEnvAtmCopyConstructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D9780, void</em>, void const*, int, int>(object_dst, object_src, offset, size);</p>
<p>0AA7: call_function_return 0x5D9780 num_params 4 pop 4 [object_dst] [object_src] [offset] [size] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginEnvAtmCopyConstructorCB&lt;cdecl, 0x5D9780&gt;(object_dst, object_src, offset, size): int</p>
<h4>CCustomCarEnvMapPipeline::pluginSpecMatDestructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D97D0, void</em>>(object);</p>
<p>0AA7: call_function_return 0x5D97D0 num_params 1 pop 1 [object] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginSpecMatDestructorCB&lt;cdecl, 0x5D97D0&gt;(object): int</p>
<h4>CCustomCarEnvMapPipeline::pluginSpecMatCopyConstructorCB</h4>
<p>plugin::CallAndReturn<void<em>, 0x5D9830, void</em>, void const*>(object_dst, object_src);</p>
<p>0AA7: call_function_return 0x5D9830 num_params 2 pop 2 [object_dst] [object_src] func_ret [void*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginSpecMatCopyConstructorCB&lt;cdecl, 0x5D9830&gt;(object_dst, object_src): int</p>
<h4>CCustomCarEnvMapPipeline::pluginSpecMatStreamReadCB</h4>
<p>plugin::CallAndReturn<RwStream<em>, 0x5D9880, RwStream</em>, int, void*>(stream, length, object);</p>
<p>0AA7: call_function_return 0x5D9880 num_params 3 pop 3 [stream] [length] [object] func_ret [RwStream*]</p>
<p>define function CCustomCarEnvMapPipeline__pluginSpecMatStreamReadCB&lt;cdecl, 0x5D9880&gt;(stream, length, object): int</p>
<h4>CCustomCarEnvMapPipeline::CustomPipeRenderCB</h4>
<p>plugin::CallAndReturn<int, 0x5D9900, RwResEntry<em>, void</em>, unsigned char, unsigned int>(atomic, object, flags1, flags2);</p>
<p>0AA7: call_function_return 0x5D9900 num_params 4 pop 4 [atomic] [object] [flags1] [flags2] func_ret [int]</p>
<p>define function CCustomCarEnvMapPipeline__CustomPipeRenderCB&lt;cdecl, 0x5D9900&gt;(atomic, object, flags1, flags2): int</p>
<h4>CCustomCarEnvMapPipeline::CreateCustomOpenGLObjPipe</h4>
<p>plugin::CallAndReturn<RxPipeline*, 0x5D9F80>();</p>
<p>0AA7: call_function_return 0x5D9F80 num_params 0 pop 0 func_ret [RxPipeline*]</p>
<p>define function CCustomCarEnvMapPipeline__CreateCustomOpenGLObjPipe&lt;cdecl, 0x5D9F80&gt;(): int</p>
<h4>CCustomCarEnvMapPipeline::CreatePipe</h4>
<p>plugin::CallAndReturn<char, 0x5DA020>();</p>
<p>0AA7: call_function_return 0x5DA020 num_params 0 pop 0 func_ret [char]</p>
<p>define function CCustomCarEnvMapPipeline__CreatePipe&lt;cdecl, 0x5DA020&gt;(): int</p>
<h4>CCustomCarEnvMapPipeline::DestroyPipe</h4>
<p>plugin::Call<0x5DA130>();</p>
<p>0AA5: call_function 0x5DA130 num_params 0 pop 0</p>
<p>define function CCustomCarEnvMapPipeline__DestroyPipe&lt;cdecl, 0x5DA130&gt;()</p>
<h4>CCustomCarEnvMapPipeline::SetFxEnvTexture</h4>
<p>plugin::Call<0x5DA230, RpMaterial<em>, RwTexture</em>>(material, texture);</p>
<p>0AA5: call_function 0x5DA230 num_params 2 pop 2 [material] [texture]</p>
<p>define function CCustomCarEnvMapPipeline__SetFxEnvTexture&lt;cdecl, 0x5DA230&gt;(material, texture)</p>
<h4>CCustomCarEnvMapPipeline::RegisterPlugin</h4>
<p>plugin::CallAndReturn<char, 0x5DA450>();</p>
<p>0AA7: call_function_return 0x5DA450 num_params 0 pop 0 func_ret [char]</p>
<p>define function CCustomCarEnvMapPipeline__RegisterPlugin&lt;cdecl, 0x5DA450&gt;(): int</p>
<h4>CCustomCarEnvMapPipeline::CustomPipeMaterialSetup</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x5DA560, RpMaterial</em>, void*>(arg0, arg1);</p>
<p>0AA7: call_function_return 0x5DA560 num_params 2 pop 2 [arg0] [arg1] func_ret [RpMaterial*]</p>
<p>define function CCustomCarEnvMapPipeline__CustomPipeMaterialSetup&lt;cdecl, 0x5DA560&gt;(arg0, arg1): int</p>
<h4>CCustomCarEnvMapPipeline::CustomPipeAtomicSetup</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x5DA610, RpAtomic</em>>(arg0);</p>
<p>0AA7: call_function_return 0x5DA610 num_params 1 pop 1 [arg0] func_ret [RpAtomic*]</p>
<p>define function CCustomCarEnvMapPipeline__CustomPipeAtomicSetup&lt;cdecl, 0x5DA610&gt;(arg0): int</p><h3 id="plugin_sagame_saccustomcarplatemgrcpp">plugin_sa\game_sa\CCustomCarPlateMgr.cpp</h3><h4>CCustomCarPlateMgr::Initialise</h4>
<p>plugin::CallAndReturn<bool, 0x6FD500>();</p>
<p>0AA7: call_function_return 0x6FD500 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCustomCarPlateMgr__Initialise&lt;cdecl, 0x6FD500&gt;(): int</p>
<h4>CCustomCarPlateMgr::GeneratePlateText</h4>
<p>plugin::CallAndReturn<bool, 0x6FD5B0, char*, int>(plateTextBuf, length);</p>
<p>0AA7: call_function_return 0x6FD5B0 num_params 2 pop 2 [plateTextBuf] [length] func_ret [bool]</p>
<p>define function CCustomCarPlateMgr__GeneratePlateText&lt;cdecl, 0x6FD5B0&gt;(plateTextBuf, length): int</p>
<h4>CCustomCarPlateMgr::Shutdown</h4>
<p>plugin::CallAndReturn<bool, 0x6FD720>();</p>
<p>0AA7: call_function_return 0x6FD720 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCustomCarPlateMgr__Shutdown&lt;cdecl, 0x6FD720&gt;(): int</p>
<h4>CCustomCarPlateMgr::GetMapRegionPlateDesign</h4>
<p>plugin::CallAndReturn<unsigned char, 0x6FD7A0>();</p>
<p>0AA7: call_function_return 0x6FD7A0 num_params 0 pop 0 func_ret [unsigned char]</p>
<p>define function CCustomCarPlateMgr__GetMapRegionPlateDesign&lt;cdecl, 0x6FD7A0&gt;(): int</p>
<h4>CCustomCarPlateMgr::LoadPlatecharsetDat</h4>
<p>plugin::CallAndReturn<bool, 0x6FDC00, char const<em>, unsigned char</em>, int, int>(filename, data, arg2, arg3);</p>
<p>0AA7: call_function_return 0x6FDC00 num_params 4 pop 4 [filename] [data] [arg2] [arg3] func_ret [bool]</p>
<p>define function CCustomCarPlateMgr__LoadPlatecharsetDat&lt;cdecl, 0x6FDC00&gt;(filename, data, arg2, arg3): int</p>
<h4>RenderLicenseplateTextToRaster</h4>
<p>plugin::CallAndReturn<bool, 0x6FDD70, char<em>, RwRaster</em>, void<em>, RwRaster</em>>(text, charsetRaster, palette, resultRaster);</p>
<p>0AA7: call_function_return 0x6FDD70 num_params 4 pop 4 [text] [charsetRaster] [palette] [resultRaster] func_ret [bool]</p>
<p>define function RenderLicenseplateTextToRaster&lt;cdecl, 0x6FDD70&gt;(text, charsetRaster, palette, resultRaster): int</p>
<h4>CCustomCarPlateMgr::SetupMaterialPlatebackTexture</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x6FDE50, RpMaterial</em>, unsigned char>(material, plateType);</p>
<p>0AA7: call_function_return 0x6FDE50 num_params 2 pop 2 [material] [plateType] func_ret [RpMaterial*]</p>
<p>define function CCustomCarPlateMgr__SetupMaterialPlatebackTexture&lt;cdecl, 0x6FDE50&gt;(material, plateType): int</p>
<h4>CCustomCarPlateMgr::CreatePlateTexture</h4>
<p>plugin::CallAndReturn<RwTexture<em>, 0x6FDEA0, char</em>, unsigned char>(text, plateType);</p>
<p>0AA7: call_function_return 0x6FDEA0 num_params 2 pop 2 [text] [plateType] func_ret [RwTexture*]</p>
<p>define function CCustomCarPlateMgr__CreatePlateTexture&lt;cdecl, 0x6FDEA0&gt;(text, plateType): int</p>
<h4>MaterialUpgradeSetCarplateTextureCB</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x6FDF50, RpMaterial</em>, void*>(material, data);</p>
<p>0AA7: call_function_return 0x6FDF50 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]</p>
<p>define function MaterialUpgradeSetCarplateTextureCB&lt;cdecl, 0x6FDF50&gt;(material, data): int</p>
<h4>AtomicUpgradeSetCarplateTextureCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x6FDFC0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x6FDFC0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function AtomicUpgradeSetCarplateTextureCB&lt;cdecl, 0x6FDFC0&gt;(atomic, data): int</p>
<h4>CCustomCarPlateMgr::SetupClumpAfterVehicleUpgrade</h4>
<p>plugin::CallAndReturn<bool, 0x6FDFE0, RpClump<em>, RpMaterial</em>, unsigned char>(clump, plateMaterial, plateType);</p>
<p>0AA7: call_function_return 0x6FDFE0 num_params 3 pop 3 [clump] [plateMaterial] [plateType] func_ret [bool]</p>
<p>define function CCustomCarPlateMgr__SetupClumpAfterVehicleUpgrade&lt;cdecl, 0x6FDFE0&gt;(clump, plateMaterial, plateType): int</p>
<h4>CCustomCarPlateMgr::SetupMaterialPlateTexture</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x6FE020, RpMaterial</em>, char*, unsigned char>(material, plateText, plateType);</p>
<p>0AA7: call_function_return 0x6FE020 num_params 3 pop 3 [material] [plateText] [plateType] func_ret [RpMaterial*]</p>
<p>define function CCustomCarPlateMgr__SetupMaterialPlateTexture&lt;cdecl, 0x6FE020&gt;(material, plateText, plateType): int</p>
<h4>MaterialSetCarplateTextureCB</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x6FE060, RpMaterial</em>, void*>(material, data);</p>
<p>0AA7: call_function_return 0x6FE060 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]</p>
<p>define function MaterialSetCarplateTextureCB&lt;cdecl, 0x6FE060&gt;(material, data): int</p>
<h4>AtomicSetCarplateTextureCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x6FE0D0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x6FE0D0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function AtomicSetCarplateTextureCB&lt;cdecl, 0x6FE0D0&gt;(atomic, data): int</p>
<h4>CCustomCarPlateMgr::SetupClump</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x6FE0F0, RpClump</em>, char*, unsigned char>(clump, plateText, plateType);</p>
<p>0AA7: call_function_return 0x6FE0F0 num_params 3 pop 3 [clump] [plateText] [plateType] func_ret [RpMaterial*]</p>
<p>define function CCustomCarPlateMgr__SetupClump&lt;cdecl, 0x6FE0F0&gt;(clump, plateText, plateType): int</p><h3 id="plugin_sagame_saccutscenemgrcpp">plugin_sa\game_sa\CCutsceneMgr.cpp</h3><h4>CCutsceneMgr::AddCutsceneHead</h4>
<p>plugin::CallAndReturn<int, 0x5B0380, CObject*, int>(object, arg1);</p>
<p>0AA7: call_function_return 0x5B0380 num_params 2 pop 2 [object] [arg1] func_ret [int]</p>
<p>define function CCutsceneMgr__AddCutsceneHead&lt;cdecl, 0x5B0380&gt;(object, arg1): int</p>
<h4>CCutsceneMgr::AppendToNextCutscene</h4>
<p>plugin::Call<0x4D5DB0, char const<em>, char const</em>>(objectName, animName);</p>
<p>0AA5: call_function 0x4D5DB0 num_params 2 pop 2 [objectName] [animName]</p>
<p>define function CCutsceneMgr__AppendToNextCutscene&lt;cdecl, 0x4D5DB0&gt;(objectName, animName)</p>
<h4>CCutsceneMgr::AttachObjectToBone</h4>
<p>plugin::Call<0x5B0450, CObject<em>, CObject</em>, int>(attachment, object, boneId);</p>
<p>0AA5: call_function 0x5B0450 num_params 3 pop 3 [attachment] [object] [boneId]</p>
<p>define function CCutsceneMgr__AttachObjectToBone&lt;cdecl, 0x5B0450&gt;(attachment, object, boneId)</p>
<h4>CCutsceneMgr::AttachObjectToFrame</h4>
<p>plugin::Call<0x5B0480, CObject<em>, CEntity</em>, char const*>(attachment, object, frameName);</p>
<p>0AA5: call_function 0x5B0480 num_params 3 pop 3 [attachment] [object] [frameName]</p>
<p>define function CCutsceneMgr__AttachObjectToFrame&lt;cdecl, 0x5B0480&gt;(attachment, object, frameName)</p>
<h4>CCutsceneMgr::AttachObjectToParent</h4>
<p>plugin::Call<0x5B04B0, CObject<em>, CEntity</em>>(attachment, object);</p>
<p>0AA5: call_function 0x5B04B0 num_params 2 pop 2 [attachment] [object]</p>
<p>define function CCutsceneMgr__AttachObjectToParent&lt;cdecl, 0x5B04B0&gt;(attachment, object)</p>
<h4>CCutsceneMgr::BuildCutscenePlayer</h4>
<p>plugin::Call<0x4D5E20>();</p>
<p>0AA5: call_function 0x4D5E20 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__BuildCutscenePlayer&lt;cdecl, 0x4D5E20&gt;()</p>
<h4>CCutsceneMgr::CreateCutsceneObject</h4>
<p>plugin::CallAndReturn<CCutsceneObject*, 0x5B02A0, int>(modelId);</p>
<p>0AA7: call_function_return 0x5B02A0 num_params 1 pop 1 [modelId] func_ret [CCutsceneObject*]</p>
<p>define function CCutsceneMgr__CreateCutsceneObject&lt;cdecl, 0x5B02A0&gt;(modelId): int</p>
<h4>CCutsceneMgr::DeleteCutsceneData</h4>
<p>plugin::Call<0x4D5ED0>();</p>
<p>0AA5: call_function 0x4D5ED0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__DeleteCutsceneData&lt;cdecl, 0x4D5ED0&gt;()</p>
<h4>CCutsceneMgr::DeleteCutsceneData_overlay</h4>
<p>plugin::Call<0x5AFD60>();</p>
<p>0AA5: call_function 0x5AFD60 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__DeleteCutsceneData_overlay&lt;cdecl, 0x5AFD60&gt;()</p>
<h4>CCutsceneMgr::FinishCutscene</h4>
<p>plugin::Call<0x5B04D0>();</p>
<p>0AA5: call_function 0x5B04D0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__FinishCutscene&lt;cdecl, 0x5B04D0&gt;()</p>
<h4>CCutsceneMgr::GetCutsceneTimeInMilleseconds</h4>
<p>plugin::CallAndReturn<long long, 0x5B0550>();</p>
<p>0AA7: call_function_return 0x5B0550 num_params 0 pop 0 func_ret [long long]</p>
<p>define function CCutsceneMgr__GetCutsceneTimeInMilleseconds&lt;cdecl, 0x5B0550&gt;(): int</p>
<h4>CCutsceneMgr::HasCutsceneFinished</h4>
<p>plugin::CallAndReturn<bool, 0x5B0570>();</p>
<p>0AA7: call_function_return 0x5B0570 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCutsceneMgr__HasCutsceneFinished&lt;cdecl, 0x5B0570&gt;(): int</p>
<h4>CCutsceneMgr::HideRequestedObjects</h4>
<p>plugin::Call<0x5AFAD0>();</p>
<p>0AA5: call_function 0x5AFAD0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__HideRequestedObjects&lt;cdecl, 0x5AFAD0&gt;()</p>
<h4>CCutsceneMgr::Initialise</h4>
<p>plugin::Call<0x4D5A20>();</p>
<p>0AA5: call_function 0x4D5A20 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Initialise&lt;cdecl, 0x4D5A20&gt;()</p>
<h4>CCutsceneMgr::IsCutsceneSkipButtonBeingPressed</h4>
<p>plugin::Call<0x4D5D10>();</p>
<p>0AA5: call_function 0x4D5D10 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__IsCutsceneSkipButtonBeingPressed&lt;cdecl, 0x4D5D10&gt;()</p>
<h4>CCutsceneMgr::LoadAnimationUncompressed</h4>
<p>plugin::Call<0x4D5AB0, char const*>(animName);</p>
<p>0AA5: call_function 0x4D5AB0 num_params 1 pop 1 [animName]</p>
<p>define function CCutsceneMgr__LoadAnimationUncompressed&lt;cdecl, 0x4D5AB0&gt;(animName)</p>
<h4>CCutsceneMgr::LoadCutsceneData</h4>
<p>plugin::Call<0x4D5E80, char const*>(cutsceneName);</p>
<p>0AA5: call_function 0x4D5E80 num_params 1 pop 1 [cutsceneName]</p>
<p>define function CCutsceneMgr__LoadCutsceneData&lt;cdecl, 0x4D5E80&gt;(cutsceneName)</p>
<h4>CCutsceneMgr::LoadCutsceneData_loading</h4>
<p>plugin::Call<0x5B11C0>();</p>
<p>0AA5: call_function 0x5B11C0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__LoadCutsceneData_loading&lt;cdecl, 0x5B11C0&gt;()</p>
<h4>CCutsceneMgr::LoadCutsceneData_overlay</h4>
<p>plugin::Call<0x5B13F0, char const*>(cutsceneName);</p>
<p>0AA5: call_function 0x5B13F0 num_params 1 pop 1 [cutsceneName]</p>
<p>define function CCutsceneMgr__LoadCutsceneData_overlay&lt;cdecl, 0x5B13F0&gt;(cutsceneName)</p>
<h4>CCutsceneMgr::LoadCutsceneData_postload</h4>
<p>plugin::Call<0x5AFBC0>();</p>
<p>0AA5: call_function 0x5AFBC0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__LoadCutsceneData_postload&lt;cdecl, 0x5AFBC0&gt;()</p>
<h4>CCutsceneMgr::LoadCutsceneData_preload</h4>
<p>plugin::Call<0x5B05A0>();</p>
<p>0AA5: call_function 0x5B05A0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__LoadCutsceneData_preload&lt;cdecl, 0x5B05A0&gt;()</p>
<h4>CCutsceneMgr::LoadEverythingBecauseCutsceneDeletedAllOfIt</h4>
<p>plugin::Call<0x4D5C10>();</p>
<p>0AA5: call_function 0x4D5C10 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__LoadEverythingBecauseCutsceneDeletedAllOfIt&lt;cdecl, 0x4D5C10&gt;()</p>
<h4>CCutsceneMgr::RemoveCutscenePlayer</h4>
<p>plugin::Call<0x4D5E50>();</p>
<p>0AA5: call_function 0x4D5E50 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__RemoveCutscenePlayer&lt;cdecl, 0x4D5E50&gt;()</p>
<h4>CCutsceneMgr::RemoveEverythingBecauseCutsceneDoesntFitInMemory</h4>
<p>plugin::Call<0x4D5AF0>();</p>
<p>0AA5: call_function 0x4D5AF0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__RemoveEverythingBecauseCutsceneDoesntFitInMemory&lt;cdecl, 0x4D5AF0&gt;()</p>
<h4>CCutsceneMgr::SetCutsceneAnim</h4>
<p>plugin::Call<0x5B0390, char const<em>, CObject</em>>(animName, object);</p>
<p>0AA5: call_function 0x5B0390 num_params 2 pop 2 [animName] [object]</p>
<p>define function CCutsceneMgr__SetCutsceneAnim&lt;cdecl, 0x5B0390&gt;(animName, object)</p>
<h4>CCutsceneMgr::SetCutsceneAnimToLoop</h4>
<p>plugin::Call<0x5B0420, char const*>(animName);</p>
<p>0AA5: call_function 0x5B0420 num_params 1 pop 1 [animName]</p>
<p>define function CCutsceneMgr__SetCutsceneAnimToLoop&lt;cdecl, 0x5B0420&gt;(animName)</p>
<h4>CCutsceneMgr::SetHeadAnim</h4>
<p>plugin::Call<0x5B0440, char const<em>, CObject</em>>(animName, headObject);</p>
<p>0AA5: call_function 0x5B0440 num_params 2 pop 2 [animName] [headObject]</p>
<p>define function CCutsceneMgr__SetHeadAnim&lt;cdecl, 0x5B0440&gt;(animName, headObject)</p>
<h4>CCutsceneMgr::SetupCutsceneToStart</h4>
<p>plugin::Call<0x5B14D0>();</p>
<p>0AA5: call_function 0x5B14D0 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__SetupCutsceneToStart&lt;cdecl, 0x5B14D0&gt;()</p>
<h4>CCutsceneMgr::Shutdown</h4>
<p>plugin::Call<0x4D5E60>();</p>
<p>0AA5: call_function 0x4D5E60 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Shutdown&lt;cdecl, 0x4D5E60&gt;()</p>
<h4>CCutsceneMgr::SkipCutscene</h4>
<p>plugin::Call<0x5B1700>();</p>
<p>0AA5: call_function 0x5B1700 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__SkipCutscene&lt;cdecl, 0x5B1700&gt;()</p>
<h4>CCutsceneMgr::StartCutscene</h4>
<p>plugin::Call<0x5B1460>();</p>
<p>0AA5: call_function 0x5B1460 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__StartCutscene&lt;cdecl, 0x5B1460&gt;()</p>
<h4>CCutsceneMgr::Update</h4>
<p>plugin::Call<0x4D5D00>();</p>
<p>0AA5: call_function 0x4D5D00 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Update&lt;cdecl, 0x4D5D00&gt;()</p>
<h4>CCutsceneMgr::Update_overlay</h4>
<p>plugin::Call<0x5B1720>();</p>
<p>0AA5: call_function 0x5B1720 num_params 0 pop 0</p>
<p>define function CCutsceneMgr__Update_overlay&lt;cdecl, 0x5B1720&gt;()</p>
<h4>FindCutsceneAudioTrackId</h4>
<p>plugin::CallAndReturn<short, 0x5AFA50, char const*>(cutsceneName);</p>
<p>0AA7: call_function_return 0x5AFA50 num_params 1 pop 1 [cutsceneName] func_ret [short]</p>
<p>define function FindCutsceneAudioTrackId&lt;cdecl, 0x5AFA50&gt;(cutsceneName): int</p>
<h4>UpdateCutsceneObjectBoundingBox</h4>
<p>plugin::Call<0x5B01E0, RpClump*, int>(clump, modelId);</p>
<p>0AA5: call_function 0x5B01E0 num_params 2 pop 2 [clump] [modelId]</p>
<p>define function UpdateCutsceneObjectBoundingBox&lt;cdecl, 0x5B01E0&gt;(clump, modelId)</p><h3 id="plugin_sagame_sacdarkelcpp">plugin_sa\game_sa\CDarkel.cpp</h3><h4>CDarkel::Init</h4>
<p>plugin::Call<0x43CEB0>();</p>
<p>0AA5: call_function 0x43CEB0 num_params 0 pop 0</p>
<p>define function CDarkel__Init&lt;cdecl, 0x43CEB0&gt;()</p>
<h4>CDarkel::DrawMessages</h4>
<p>plugin::Call<0x43CEC0>();</p>
<p>0AA5: call_function 0x43CEC0 num_params 0 pop 0</p>
<p>define function CDarkel__DrawMessages&lt;cdecl, 0x43CEC0&gt;()</p>
<h4>CDarkel::ReadStatus</h4>
<p>plugin::CallAndReturn<short, 0x43D1E0>();</p>
<p>0AA7: call_function_return 0x43D1E0 num_params 0 pop 0 func_ret [short]</p>
<p>define function CDarkel__ReadStatus&lt;cdecl, 0x43D1E0&gt;(): int</p>
<h4>CDarkel::RegisterKillNotByPlayer</h4>
<p>plugin::Call<0x43D210, CPed const*>(pKilledPed);</p>
<p>0AA5: call_function 0x43D210 num_params 1 pop 1 [pKilledPed]</p>
<p>define function CDarkel__RegisterKillNotByPlayer&lt;cdecl, 0x43D210&gt;(pKilledPed)</p>
<h4>CDarkel::ThisPedShouldBeKilledForFrenzy</h4>
<p>plugin::CallAndReturn<bool, 0x43D2F0, CPed const*>(pPed);</p>
<p>0AA7: call_function_return 0x43D2F0 num_params 1 pop 1 [pPed] func_ret [bool]</p>
<p>define function CDarkel__ThisPedShouldBeKilledForFrenzy&lt;cdecl, 0x43D2F0&gt;(pPed): int</p>
<h4>CDarkel::ThisVehicleShouldBeKilledForFrenzy</h4>
<p>plugin::CallAndReturn<bool, 0x43D350, CVehicle const*>(pVehicle);</p>
<p>0AA7: call_function_return 0x43D350 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CDarkel__ThisVehicleShouldBeKilledForFrenzy&lt;cdecl, 0x43D350&gt;(pVehicle): int</p>
<h4>CDarkel::StartFrenzy</h4>
<p>plugin::Call<0x43D3B0, eWeaponType, int, unsigned short, int, unsigned short*, int, int, int, bool, bool>(weapontype, Timelimit, KillsNeeded, ModelToKill, pStartMessage, ModelToKill2, ModelToKill3, ModelToKill4, bStandardSoundAndMessages, bNeedHeadShot);</p>
<p>0AA5: call_function 0x43D3B0 num_params 10 pop 10 [weapontype] [Timelimit] [KillsNeeded] [ModelToKill] [pStartMessage] [ModelToKill2] [ModelToKill3] [ModelToKill4] [bStandardSoundAndMessages] [bNeedHeadShot]</p>
<p>define function CDarkel__StartFrenzy&lt;cdecl, 0x43D3B0&gt;(weapontype, Timelimit, KillsNeeded, ModelToKill, pStartMessage, ModelToKill2, ModelToKill3, ModelToKill4, bStandardSoundAndMessages, bNeedHeadShot)</p>
<h4>CDarkel::ResetModelsKilledByPlayer</h4>
<p>plugin::Call<0x43D6A0, int>(playerid);</p>
<p>0AA5: call_function 0x43D6A0 num_params 1 pop 1 [playerid]</p>
<p>define function CDarkel__ResetModelsKilledByPlayer&lt;cdecl, 0x43D6A0&gt;(playerid)</p>
<h4>CDarkel::QueryModelsKilledByPlayer</h4>
<p>plugin::CallAndReturn<int, 0x43D6C0, int, int>(player, modelid);</p>
<p>0AA7: call_function_return 0x43D6C0 num_params 2 pop 2 [player] [modelid] func_ret [int]</p>
<p>define function CDarkel__QueryModelsKilledByPlayer&lt;cdecl, 0x43D6C0&gt;(player, modelid): int</p>
<h4>CDarkel::FindTotalPedsKilledByPlayer</h4>
<p>plugin::CallAndReturn<int, 0x43D6E0, int>(player);</p>
<p>0AA7: call_function_return 0x43D6E0 num_params 1 pop 1 [player] func_ret [int]</p>
<p>define function CDarkel__FindTotalPedsKilledByPlayer&lt;cdecl, 0x43D6E0&gt;(player): int</p>
<h4>CDarkel::DealWithWeaponChangeAtEndOfFrenzy</h4>
<p>plugin::Call<0x43D7A0>();</p>
<p>0AA5: call_function 0x43D7A0 num_params 0 pop 0</p>
<p>define function CDarkel__DealWithWeaponChangeAtEndOfFrenzy&lt;cdecl, 0x43D7A0&gt;()</p>
<h4>CDarkel::CheckDamagedWeaponType</h4>
<p>plugin::CallAndReturn<bool, 0x43D9E0, int, int>(damageWeaponID, expectedDamageWeaponID);</p>
<p>0AA7: call_function_return 0x43D9E0 num_params 2 pop 2 [damageWeaponID] [expectedDamageWeaponID] func_ret [bool]</p>
<p>define function CDarkel__CheckDamagedWeaponType&lt;cdecl, 0x43D9E0&gt;(damageWeaponID, expectedDamageWeaponID): int</p>
<h4>CDarkel::Update</h4>
<p>plugin::Call<0x43DAC0>();</p>
<p>0AA5: call_function 0x43DAC0 num_params 0 pop 0</p>
<p>define function CDarkel__Update&lt;cdecl, 0x43DAC0&gt;()</p>
<h4>CDarkel::ResetOnPlayerDeath</h4>
<p>plugin::Call<0x43DC10>();</p>
<p>0AA5: call_function 0x43DC10 num_params 0 pop 0</p>
<p>define function CDarkel__ResetOnPlayerDeath&lt;cdecl, 0x43DC10&gt;()</p>
<h4>CDarkel::FailKillFrenzy</h4>
<p>plugin::Call<0x43DC60>();</p>
<p>0AA5: call_function 0x43DC60 num_params 0 pop 0</p>
<p>define function CDarkel__FailKillFrenzy&lt;cdecl, 0x43DC60&gt;()</p>
<h4>CDarkel::RegisterKillByPlayer</h4>
<p>plugin::Call<0x43DCD0, CPed const*, eWeaponType, bool, int>(pKilledPed, damageWeaponID, bHeadShotted, arg4);</p>
<p>0AA5: call_function 0x43DCD0 num_params 4 pop 4 [pKilledPed] [damageWeaponID] [bHeadShotted] [arg4]</p>
<p>define function CDarkel__RegisterKillByPlayer&lt;cdecl, 0x43DCD0&gt;(pKilledPed, damageWeaponID, bHeadShotted, arg4)</p>
<h4>CDarkel::RegisterCarBlownUpByPlayer</h4>
<p>plugin::Call<0x43DF20, CVehicle*, int>(pVehicle, arg2);</p>
<p>0AA5: call_function 0x43DF20 num_params 2 pop 2 [pVehicle] [arg2]</p>
<p>define function CDarkel__RegisterCarBlownUpByPlayer&lt;cdecl, 0x43DF20&gt;(pVehicle, arg2)</p><h3 id="plugin_sagame_sacdatecpp">plugin_sa\game_sa\CDate.cpp</h3><h4>CDate::CDate</h4>
<p>plugin::CallMethodDynGlobal<CDate *>(ctor_gaddr(CDate), this);</p>
<h4>CDate::operator&lt;</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator&lt;), this, rhs);</p>
<p>0AA8: call_method_return 0x618D90 struct [CDate] num_params 1 pop 0 [rhs] func_ret [bool]</p>
<h4>CDate::operator==</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator==), this, rhs);</p>
<p>0AA8: call_method_return 0x618DF0 struct [CDate] num_params 1 pop 0 [rhs] func_ret [bool]</p>
<h4>CDate::operator&gt;</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDate *, CDate const &>(gaddrof(CDate::operator&gt;), this, rhs);</p>
<p>0AA8: call_method_return 0x618D30 struct [CDate] num_params 1 pop 0 [rhs] func_ret [bool]</p>
<h4>CDate::PopulateDateFields</h4>
<p>plugin::CallMethodDynGlobal<CDate *, char const &, char const &, char const &, char const &, char const &, short>(gaddrof(CDate::PopulateDateFields), this, seconds, minutes, hours, day, month, year);</p>
<p>0AA6: call_method 0x618E30 struct [CDate] num_params 6 pop 0 [seconds] [minutes] [hours] [day] [month] [year]</p>
<p>define function CDate__PopulateDateFields&lt;thiscall, 0x618E30&gt;(seconds, minutes, hours, day, month, year)</p><h3 id="plugin_sagame_sacdecisionsimplecpp">plugin_sa\game_sa\CDecisionSimple.cpp</h3><h4>CDecisionSimple::Set</h4>
<p>plugin::CallMethod<0x600730, CDecisionSimple <em>, int</em>, unsigned char*, int>(this, taskTypes, chances, count);</p>
<p>0AA6: call_method 0x600730 struct [CDecisionSimple] num_params 3 pop 0 [taskTypes] [chances] [count]</p>
<p>define function CDecisionSimple__Set&lt;thiscall, 0x600730&gt;(taskTypes, chances, count)</p>
<h4>CDecisionSimple::MakeDecision</h4>
<p>plugin::CallMethod<0x6007A0, CDecisionSimple *, int, short&, int&>(this, taskType, outTaskType, outDecisionIndex);</p>
<p>0AA6: call_method 0x6007A0 struct [CDecisionSimple] num_params 3 pop 0 [taskType] [outTaskType] [outDecisionIndex]</p>
<p>define function CDecisionSimple__MakeDecision&lt;thiscall, 0x6007A0&gt;(taskType, outTaskType, outDecisionIndex)</p>
<h4>CDecisionSimple::SetDefault</h4>
<p>plugin::CallMethod<0x604220, CDecisionSimple *>(this);</p>
<p>0AA6: call_method 0x604220 struct [CDecisionSimple] num_params 0 pop 0</p>
<p>define function CDecisionSimple__SetDefault&lt;thiscall, 0x604220&gt;()</p><h3 id="plugin_sagame_sacdirectorycpp">plugin_sa\game_sa\CDirectory.cpp</h3><h4>CDirectory::CDirectory</h4>
<p>plugin::CallMethod<0x532290, CDirectory *>(this);</p>
<p>0AA6: call_method 0x532290 struct [CDirectory] num_params 0 pop 0</p>
<p>define function CDirectory__CDirectory&lt;thiscall, 0x532290&gt;()</p>
<h4>CDirectory::CDirectory</h4>
<p>plugin::CallMethod<0x5322A0, CDirectory *, int>(this, capacity);</p>
<p>0AA6: call_method 0x5322A0 struct [CDirectory] num_params 1 pop 0 [capacity]</p>
<p>define function CDirectory__CDirectory&lt;thiscall, 0x5322A0&gt;(capacity)</p>
<h4>CDirectory::~CDirectory</h4>
<p>plugin::CallMethod<0x5322D0, CDirectory *>(this);</p>
<p>0AA6: call_method 0x5322D0 struct [CDirectory] num_params 0 pop 0</p>
<p>define function CDirectory__~CDirectory&lt;thiscall, 0x5322D0&gt;()</p>
<h4>CDirectory::Init</h4>
<p>plugin::CallMethod<0x5322F0, CDirectory <em>, int, void</em>>(this, capacity, entries);</p>
<p>0AA6: call_method 0x5322F0 struct [CDirectory] num_params 2 pop 0 [capacity] [entries]</p>
<p>define function CDirectory__Init&lt;thiscall, 0x5322F0&gt;(capacity, entries)</p>
<h4>CDirectory::AddItem</h4>
<p>plugin::CallMethod<0x532310, CDirectory *, DirectoryInfo const&>(this, entry);</p>
<p>0AA6: call_method 0x532310 struct [CDirectory] num_params 1 pop 0 [entry]</p>
<p>define function CDirectory__AddItem&lt;thiscall, 0x532310&gt;(entry)</p>
<h4>CDirectory::ReadDirFile</h4>
<p>plugin::CallMethod<0x532350, CDirectory <em>, char const</em>>(this, filename);</p>
<p>0AA6: call_method 0x532350 struct [CDirectory] num_params 1 pop 0 [filename]</p>
<p>define function CDirectory__ReadDirFile&lt;thiscall, 0x532350&gt;(filename)</p>
<h4>CDirectory::WriteDirFile</h4>
<p>plugin::CallMethodAndReturn<bool, 0x532410, CDirectory <em>, char const</em>>(this, filename);</p>
<p>0AA8: call_method_return 0x532410 struct [CDirectory] num_params 1 pop 0 [filename] func_ret [bool]</p>
<p>define function CDirectory__WriteDirFile&lt;thiscall, 0x532410&gt;(filename): int</p>
<h4>CDirectory::DirectoryInfo* CDirectory</h4>
<p>plugin::CallMethodAndReturn<DirectoryInfo*, 0x532450, CDirectory *, char const*>(this, name);</p>
<p>0AA8: call_method_return 0x532450 struct [CDirectory] num_params 1 pop 0 [name] func_ret [DirectoryInfo*]</p>
<p>define function CDirectory__DirectoryInfo* CDirectory&lt;thiscall, 0x532450&gt;(name): int</p>
<h4>CDirectory::DirectoryInfo* CDirectory</h4>
<p>plugin::CallMethodAndReturn<DirectoryInfo*, 0x5324A0, CDirectory *, char const*, unsigned int&, unsigned int&>(this, name, outOffset, outStreamingSize);</p>
<p>0AA8: call_method_return 0x5324A0 struct [CDirectory] num_params 3 pop 0 [name] [outOffset] [outStreamingSize] func_ret [DirectoryInfo*]</p>
<p>define function CDirectory__DirectoryInfo* CDirectory&lt;thiscall, 0x5324A0&gt;(name, outOffset, outStreamingSize): int</p>
<h4>CDirectory::DirectoryInfo* CDirectory</h4>
<p>plugin::CallMethodAndReturn<DirectoryInfo*, 0x5324D0, CDirectory *, unsigned int, unsigned int&, unsigned int&>(this, key, outOffset, outStreamingSize);</p>
<p>0AA8: call_method_return 0x5324D0 struct [CDirectory] num_params 3 pop 0 [key] [outOffset] [outStreamingSize] func_ret [DirectoryInfo*]</p>
<p>define function CDirectory__DirectoryInfo* CDirectory&lt;thiscall, 0x5324D0&gt;(key, outOffset, outStreamingSize): int</p><h3 id="plugin_sagame_sacdoorcpp">plugin_sa\game_sa\CDoor.cpp</h3><h4>CDoor::Process</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6F4040, CDoor <em>, CVehicle</em>, CVector&, CVector&, CVector&>(this, vehicle, arg1, arg2, arg3);</p>
<p>0AA8: call_method_return 0x6F4040 struct [CDoor] num_params 4 pop 0 [vehicle] [arg1] [arg2] [arg3] func_ret [bool]</p>
<p>define function CDoor__Process&lt;thiscall, 0x6F4040&gt;(vehicle, arg1, arg2, arg3): int</p>
<h4>CDoor::ProcessImpact</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6F4540, CDoor <em>, CVehicle</em>, CVector&, CVector&, CVector&>(this, vehicle, arg1, arg2, arg3);</p>
<p>0AA8: call_method_return 0x6F4540 struct [CDoor] num_params 4 pop 0 [vehicle] [arg1] [arg2] [arg3] func_ret [bool]</p>
<p>define function CDoor__ProcessImpact&lt;thiscall, 0x6F4540&gt;(vehicle, arg1, arg2, arg3): int</p>
<h4>CDoor::Open</h4>
<p>plugin::CallMethod<0x6F4790, CDoor *, float>(this, openRatio);</p>
<p>0AA6: call_method 0x6F4790 struct [CDoor] num_params 1 pop 0 [openRatio]</p>
<p>define function CDoor__Open&lt;thiscall, 0x6F4790&gt;(openRatio)</p>
<h4>CDoor::GetAngleOpenRatio</h4>
<p>plugin::CallMethodAndReturn<float, 0x6F47E0, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x6F47E0 struct [CDoor] num_params 0 pop 0 func_ret [float]</p>
<p>define function CDoor__GetAngleOpenRatio&lt;thiscall, 0x6F47E0&gt;(): float</p>
<h4>CDoor::IsClosed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6F4800, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x6F4800 struct [CDoor] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CDoor__IsClosed&lt;thiscall, 0x6F4800&gt;(): int</p>
<h4>CDoor::IsFullyOpen</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6F4820, CDoor *>(this);</p>
<p>0AA8: call_method_return 0x6F4820 struct [CDoor] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CDoor__IsFullyOpen&lt;thiscall, 0x6F4820&gt;(): int</p><h3 id="plugin_sagame_sacdrawcpp">plugin_sa\game_sa\CDraw.cpp</h3><h4>CDraw::SetFOV</h4>
<p>plugin::Call<0x6FF410, float>(fovValue);</p>
<p>0AA5: call_function 0x6FF410 num_params 1 pop 1 [fovValue]</p>
<p>define function CDraw__SetFOV&lt;cdecl, 0x6FF410&gt;(fovValue)</p>
<h4>CDraw::CalculateAspectRatio</h4>
<p>plugin::CallAndReturn<float, 0x6FF420>();</p>
<p>0AA7: call_function_return 0x6FF420 num_params 0 pop 0 func_ret [float]</p>
<p>define function CDraw__CalculateAspectRatio&lt;cdecl, 0x6FF420&gt;(): float</p><h3 id="plugin_sagame_sacentryexitcpp">plugin_sa\game_sa\CEntryExit.cpp</h3><h4>CEntryExit::GenerateAmbientPeds</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *, CVector const &>(gaddrof(CEntryExit::GenerateAmbientPeds), this, position);</p>
<p>0AA6: call_method 0x43E8B0 struct [CEntryExit] num_params 1 pop 0 [position]</p>
<p>define function CEntryExit__GenerateAmbientPeds&lt;thiscall, 0x43E8B0&gt;(position)</p>
<h4>*CEntryExit::GetEntryExitToDisplayNameOf</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char *, CEntryExit *>(gaddrof(CEntryExit::GetEntryExitToDisplayNameOf), this);</p>
<p>0AA8: call_method_return 0x43E650 struct [*CEntryExit] num_params 0 pop 0 func_ret [char *]</p>
<h4>CEntryExit::GetPositionRelativeToOutsideWorld</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *, CVector &>(gaddrof(CEntryExit::GetPositionRelativeToOutsideWorld), this, positionInOut);</p>
<p>0AA6: call_method 0x43EA00 struct [CEntryExit] num_params 1 pop 0 [positionInOut]</p>
<p>define function CEntryExit__GetPositionRelativeToOutsideWorld&lt;thiscall, 0x43EA00&gt;(positionInOut)</p>
<h4>CEntryExit::IsInArea</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CVector const &>(gaddrof(CEntryExit::IsInArea), this, position);</p>
<p>0AA8: call_method_return 0x43E460 struct [CEntryExit] num_params 1 pop 0 [position] func_ret [bool]</p>
<h4>CEntryExit::RequestAmbientPeds</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *>(gaddrof(CEntryExit::RequestAmbientPeds), this);</p>
<p>0AA6: call_method 0x43E6D0 struct [CEntryExit] num_params 0 pop 0</p>
<p>define function CEntryExit__RequestAmbientPeds&lt;thiscall, 0x43E6D0&gt;()</p>
<h4>CEntryExit::RequestObjectsInFrustum</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *>(gaddrof(CEntryExit::RequestObjectsInFrustum), this);</p>
<p>0AA6: call_method 0x43E690 struct [CEntryExit] num_params 0 pop 0</p>
<p>define function CEntryExit__RequestObjectsInFrustum&lt;thiscall, 0x43E690&gt;()</p>
<h4>CEntryExit::TransitionFinished</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CPed *>(gaddrof(CEntryExit::TransitionFinished), this, player);</p>
<p>0AA8: call_method_return 0x4404A0 struct [CEntryExit] num_params 1 pop 0 [player] func_ret [bool]</p>
<h4>CEntryExit::TransitionStarted</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CEntryExit *, CPed *>(gaddrof(CEntryExit::TransitionStarted), this, player);</p>
<p>0AA8: call_method_return 0x43FFD0 struct [CEntryExit] num_params 1 pop 0 [player] func_ret [bool]</p>
<h4>CEntryExit::WarpGangWithPlayer</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *, CPed *>(gaddrof(CEntryExit::WarpGangWithPlayer), this, player);</p>
<p>0AA6: call_method 0x43F1F0 struct [CEntryExit] num_params 1 pop 0 [player]</p>
<p>define function CEntryExit__WarpGangWithPlayer&lt;thiscall, 0x43F1F0&gt;(player)</p><h3 id="plugin_sagame_sacentryexitmanagercpp">plugin_sa\game_sa\CEntryExitManager.cpp</h3><h4>CEntryExitManager::AddEntryExitToStack</h4>
<p>plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::AddEntryExitToStack), a1);</p>
<h4>CEntryExitManager::AddOne</h4>
<p>plugin::CallAndReturnDynGlobal<int, float, float, float, float, float, float, int, float, float, float, float, int, int, int, int, int, int, char const *>(gaddrof(CEntryExitManager::AddOne), entranceX, entranceY, entranceZ, entranceAngle, entranceRangeX, entranceRangeY, unused, exitX, exitY, exitZ, exitAngle, area, flags, skyColor, timeOn, timeOff, numberOfPeds, name);</p>
<p>0AA7: call_function_return 0x43FA00 num_params 18 pop 18 [entranceX] [entranceY] [entranceZ] [entranceAngle] [entranceRangeX] [entranceRangeY] [unused] [exitX] [exitY] [exitZ] [exitAngle] [area] [flags] [skyColor] [timeOn] [timeOff] [numberOfPeds] [name] func_ret [int]</p>
<p>define function CEntryExitManager__AddOne&lt;cdecl, 0x43FA00&gt;(entranceX, entranceY, entranceZ, entranceAngle, entranceRangeX, entranceRangeY, unused, exitX, exitY, exitZ, exitAngle, area, flags, skyColor, timeOn, timeOff, numberOfPeds, name): int</p>
<h4>CEntryExitManager::DeleteOne</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CEntryExitManager::DeleteOne), index);</p>
<h4>CEntryExitManager::EnableBurglaryHouses</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CEntryExitManager::EnableBurglaryHouses), enable);</p>
<h4>*CEntryExitManager::FindNearestDoor</h4>
<p>plugin::CallAndReturnDynGlobal<CEntity *, CEntryExit const &, float>(gaddrof(CEntryExitManager::FindNearestDoor), entryExit, range);</p>
<p>0AA7: call_function_return 0x43F630 num_params 2 pop 2 [entryExit] [range] func_ret [CEntity *]</p>
<p>define function CEntryExitManager__FindNearestDoor&lt;cdecl, 0x43F630&gt;(entryExit, range): int</p>
<h4>CEntryExitManager::FindNearestEntryExit</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVector2D const &, float, int>(gaddrof(CEntryExitManager::FindNearestEntryExit), position, range, ignoreArea);</p>
<p>0AA7: call_function_return 0x43F4B0 num_params 3 pop 3 [position] [range] [ignoreArea] func_ret [int]</p>
<p>define function CEntryExitManager__FindNearestEntryExit&lt;cdecl, 0x43F4B0&gt;(position, range, ignoreArea): int</p>
<h4>*CEntryExitManager::GetEntryExit</h4>
<p>plugin::CallAndReturnDynGlobal<CEntryExit *, int>(gaddrof(CEntryExitManager::GetEntryExit), index);</p>
<p>0AA7: call_function_return 0x43EF00 num_params 1 pop 1 [index] func_ret [CEntryExit *]</p>
<p>define function CEntryExitManager__GetEntryExit&lt;cdecl, 0x43EF00&gt;(index): int</p>
<h4>CEntryExitManager::GetEntryExitIndex</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *, unsigned short, unsigned short>(gaddrof(CEntryExitManager::GetEntryExitIndex), name, enabledFlags, disabledFlags);</p>
<p>0AA7: call_function_return 0x43EFD0 num_params 3 pop 3 [name] [enabledFlags] [disabledFlags] func_ret [int]</p>
<p>define function CEntryExitManager__GetEntryExitIndex&lt;cdecl, 0x43EFD0&gt;(name, enabledFlags, disabledFlags): int</p>
<h4>CEntryExitManager::GetPositionRelativeToOutsideWorld</h4>
<p>plugin::CallDynGlobal<CVector &>(gaddrof(CEntryExitManager::GetPositionRelativeToOutsideWorld), positionInOut);</p>
<h4>CEntryExitManager::GotoEntryExit</h4>
<p>plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::GotoEntryExit), entryExit);</p>
<h4>CEntryExitManager::GotoEntryExitVC</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CEntryExitManager::GotoEntryExitVC), name);</p>
<h4>CEntryExitManager::LinkEntryExit</h4>
<p>plugin::CallDynGlobal<CEntryExit *>(gaddrof(CEntryExitManager::LinkEntryExit), entryExit);</p>
<h4>CEntryExitManager::Load</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::Load));</p>
<p>0AA7: call_function_return 0x5D55C0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CEntryExitManager__Load&lt;cdecl, 0x5D55C0&gt;(): int</p>
<h4>CEntryExitManager::Save</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::Save));</p>
<p>0AA7: call_function_return 0x5D5970 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CEntryExitManager__Save&lt;cdecl, 0x5D5970&gt;(): int</p>
<h4>CEntryExitManager::SetEnabled</h4>
<p>plugin::CallDynGlobal<int, bool>(gaddrof(CEntryExitManager::SetEnabled), index, enable);</p>
<h4>CEntryExitManager::SetEnabledByName</h4>
<p>plugin::CallDynGlobal<char const *, bool>(gaddrof(CEntryExitManager::SetEnabledByName), name, enable);</p>
<h4>CEntryExitManager::SetEntryExitFlag</h4>
<p>plugin::CallDynGlobal<char const *, unsigned int, bool>(gaddrof(CEntryExitManager::SetEntryExitFlag), name, flag, enable);</p>
<h4>CEntryExitManager::SetEntryExitFlagWithIndex</h4>
<p>plugin::CallDynGlobal<int, unsigned int, bool>(gaddrof(CEntryExitManager::SetEntryExitFlagWithIndex), index, flag, enable);</p>
<h4>CEntryExitManager::WeAreInInteriorTransition</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CEntryExitManager::WeAreInInteriorTransition));</p>
<p>0AA7: call_function_return 0x43E400 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CEntryExitManager__WeAreInInteriorTransition&lt;cdecl, 0x43E400&gt;(): int</p><h3 id="plugin_sagame_sacexplosioncpp">plugin_sa\game_sa\CExplosion.cpp</h3><h4>CExplosion::ClearAllExplosions</h4>
<p>plugin::Call<0x736840>();</p>
<p>0AA5: call_function 0x736840 num_params 0 pop 0</p>
<p>define function CExplosion__ClearAllExplosions&lt;cdecl, 0x736840&gt;()</p>
<h4>CExplosion::Shutdown</h4>
<p>plugin::Call<0x7368F0>();</p>
<p>0AA5: call_function 0x7368F0 num_params 0 pop 0</p>
<p>define function CExplosion__Shutdown&lt;cdecl, 0x7368F0&gt;()</p>
<h4>CExplosion::GetExplosionActiveCounter</h4>
<p>plugin::CallAndReturn<unsigned char, 0x736900, unsigned char>(explosionId);</p>
<p>0AA7: call_function_return 0x736900 num_params 1 pop 1 [explosionId] func_ret [unsigned char]</p>
<p>define function CExplosion__GetExplosionActiveCounter&lt;cdecl, 0x736900&gt;(explosionId): int</p>
<h4>CExplosion::ResetExplosionActiveCounter</h4>
<p>plugin::Call<0x736910, unsigned char>(explosionId);</p>
<p>0AA5: call_function 0x736910 num_params 1 pop 1 [explosionId]</p>
<p>define function CExplosion__ResetExplosionActiveCounter&lt;cdecl, 0x736910&gt;(explosionId)</p>
<h4>CExplosion::DoesExplosionMakeSound</h4>
<p>plugin::CallAndReturn<bool, 0x736920, unsigned char>(explosionId);</p>
<p>0AA7: call_function_return 0x736920 num_params 1 pop 1 [explosionId] func_ret [bool]</p>
<p>define function CExplosion__DoesExplosionMakeSound&lt;cdecl, 0x736920&gt;(explosionId): int</p>
<h4>CExplosion::GetExplosionType</h4>
<p>plugin::CallAndReturn<unsigned int, 0x736930, unsigned char>(explosionId);</p>
<p>0AA7: call_function_return 0x736930 num_params 1 pop 1 [explosionId] func_ret [unsigned int]</p>
<p>define function CExplosion__GetExplosionType&lt;cdecl, 0x736930&gt;(explosionId): int</p>
<h4>CExplosion::GetExplosionPosition</h4>
<p>plugin::CallAndReturn<CVector*, 0x736940, unsigned char>(explosionId);</p>
<p>0AA7: call_function_return 0x736940 num_params 1 pop 1 [explosionId] func_ret [CVector*]</p>
<p>define function CExplosion__GetExplosionPosition&lt;cdecl, 0x736940&gt;(explosionId): int</p>
<h4>CExplosion::TestForExplosionInArea</h4>
<p>plugin::CallAndReturn<bool, 0x736950, eExplosionType, float, float, float, float, float, float>(explosionType, x1, y1, z1, x2, y2, z2);</p>
<p>0AA7: call_function_return 0x736950 num_params 7 pop 7 [explosionType] [x1] [y1] [z1] [x2] [y2] [z2] func_ret [bool]</p>
<p>define function CExplosion__TestForExplosionInArea&lt;cdecl, 0x736950&gt;(explosionType, x1, y1, z1, x2, y2, z2): int</p>
<h4>CExplosion::RemoveAllExplosionsInArea</h4>
<p>plugin::Call<0x7369E0, CVector, float>(posn, radius);</p>
<p>0AA5: call_function 0x7369E0 num_params 2 pop 2 [posn] [radius]</p>
<p>define function CExplosion__RemoveAllExplosionsInArea&lt;cdecl, 0x7369E0&gt;(posn, radius)</p>
<h4>CExplosion::Initialise</h4>
<p>plugin::Call<0x736A40>();</p>
<p>0AA5: call_function 0x736A40 num_params 0 pop 0</p>
<p>define function CExplosion__Initialise&lt;cdecl, 0x736A40&gt;()</p>
<h4>CExplosion::AddExplosion</h4>
<p>plugin::CallAndReturn<bool, 0x736A50, CEntity<em>, CEntity</em>, eExplosionType, CVector const&, unsigned int, unsigned char, float, unsigned char>(victim, creator, explosionType, posn, time, makeSound, camShake, visibility);</p>
<p>0AA7: call_function_return 0x736A50 num_params 8 pop 8 [victim] [creator] [explosionType] [posn] [time] [makeSound] [camShake] [visibility] func_ret [bool]</p>
<p>define function CExplosion__AddExplosion&lt;cdecl, 0x736A50&gt;(victim, creator, explosionType, posn, time, makeSound, camShake, visibility): int</p>
<h4>CExplosion::Update</h4>
<p>plugin::Call<0x737620>();</p>
<p>0AA5: call_function 0x737620 num_params 0 pop 0</p>
<p>define function CExplosion__Update&lt;cdecl, 0x737620&gt;()</p><h3 id="plugin_sagame_sacfileloadercpp">plugin_sa\game_sa\CFileLoader.cpp</h3><h4>CFileLoader::AddTexDictionaries</h4>
<p>plugin::CallDynGlobal<RwTexDictionary *, RwTexDictionary *>(gaddrof(CFileLoader::AddTexDictionaries), dictionary, baseDictionary);</p>
<h4>*CFileLoader::FindRelatedModelInfoCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CFileLoader::FindRelatedModelInfoCB), atomic, data);</p>
<p>0AA7: call_function_return 0x5B3930 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CFileLoader__FindRelatedModelInfoCB&lt;cdecl, 0x5B3930&gt;(atomic, data): int</p>
<h4>CFileLoader::FinishLoadClumpFile</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof(CFileLoader::FinishLoadClumpFile), stream, modelIndex);</p>
<p>0AA7: call_function_return 0x537450 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__FinishLoadClumpFile&lt;cdecl, 0x537450&gt;(stream, modelIndex): int</p>
<h4>CFileLoader::LoadAnimatedClumpObject</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadAnimatedClumpObject), line);</p>
<h4>CFileLoader::LoadAtomicFile</h4>
<p>plugin::CallDynGlobal<RwStream *, unsigned int>(gaddrof_o(CFileLoader::LoadAtomicFile, void (*)(RwStream *, unsigned int)), stream, modelIndex);</p>
<h4>CFileLoader::LoadAtomicFile</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof_o(CFileLoader::LoadAtomicFile, void (*)(char const *)), filename);</p>
<h4>*CFileLoader::LoadAtomicFile2Return</h4>
<p>plugin::CallAndReturnDynGlobal<RpClump *, char const *>(gaddrof(CFileLoader::LoadAtomicFile2Return), filename);</p>
<p>0AA7: call_function_return 0x537060 num_params 1 pop 1 [filename] func_ret [RpClump *]</p>
<p>define function CFileLoader__LoadAtomicFile2Return&lt;cdecl, 0x537060&gt;(filename): int</p>
<h4>CFileLoader::LoadAudioZone</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadAudioZone), line);</p>
<h4>CFileLoader::LoadBoundingBox</h4>
<p>plugin::CallDynGlobal<unsigned char *, CBoundingBox &>(gaddrof(CFileLoader::LoadBoundingBox), data, outBoundBox);</p>
<h4>CFileLoader::LoadCarGenerator</h4>
<p>plugin::CallDynGlobal<CFileCarGenerator *, int>(gaddrof_o(CFileLoader::LoadCarGenerator, void (*)(CFileCarGenerator *, int)), carGen, iplId);</p>
<h4>CFileLoader::LoadCarGenerator</h4>
<p>plugin::CallDynGlobal<char const *, int>(gaddrof_o(CFileLoader::LoadCarGenerator, void (*)(char const *, int)), line, iplId);</p>
<h4>CFileLoader::LoadCarPathNode</h4>
<p>plugin::CallDynGlobal<char const *, int, int, bool>(gaddrof(CFileLoader::LoadCarPathNode), line, objModelIndex, pathEntryIndex, a4);</p>
<h4>CFileLoader::LoadClumpFile</h4>
<p>plugin::CallAndReturnDynGlobal&lt;bool, RwStream <em>, unsigned int>(gaddrof_o(CFileLoader::LoadClumpFile, bool (</em>)(RwStream *, unsigned int)), stream, modelIndex);</p>
<p>0AA7: call_function_return 0x5B3A30 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__LoadClumpFile&lt;cdecl, 0x5B3A30&gt;(stream, modelIndex): int</p>
<h4>CFileLoader::LoadClumpFile</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof_o(CFileLoader::LoadClumpFile, void (*)(char const *)), filename);</p>
<h4>CFileLoader::LoadClumpObject</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadClumpObject), line);</p>
<p>0AA7: call_function_return 0x5B4040 num_params 1 pop 1 [line] func_ret [int]</p>
<p>define function CFileLoader__LoadClumpObject&lt;cdecl, 0x5B4040&gt;(line): int</p>
<h4>CFileLoader::LoadCollisionFile</h4>
<p>plugin::CallAndReturnDynGlobal&lt;bool, unsigned char <em>, unsigned int, unsigned char>(gaddrof_o(CFileLoader::LoadCollisionFile, bool (</em>)(unsigned char *, unsigned int, unsigned char)), data, dataSize, colId);</p>
<p>0AA7: call_function_return 0x5B4E60 num_params 3 pop 3 [data] [dataSize] [colId] func_ret [bool]</p>
<p>define function CFileLoader__LoadCollisionFile&lt;cdecl, 0x5B4E60&gt;(data, dataSize, colId): int</p>
<h4>CFileLoader::LoadCollisionFile</h4>
<p>plugin::CallDynGlobal<char const *, unsigned char>(gaddrof_o(CFileLoader::LoadCollisionFile, void (*)(char const *, unsigned char)), filename, colId);</p>
<h4>CFileLoader::LoadCollisionFileFirstTime</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned char *, unsigned int, unsigned char>(gaddrof(CFileLoader::LoadCollisionFileFirstTime), data, dataSize, colId);</p>
<p>0AA7: call_function_return 0x5B5000 num_params 3 pop 3 [data] [dataSize] [colId] func_ret [bool]</p>
<p>define function CFileLoader__LoadCollisionFileFirstTime&lt;cdecl, 0x5B5000&gt;(data, dataSize, colId): int</p>
<h4>CFileLoader::LoadCollisionModel</h4>
<p>plugin::CallDynGlobal<unsigned char *, CColModel &>(gaddrof(CFileLoader::LoadCollisionModel), data, outColModel);</p>
<h4>CFileLoader::LoadCollisionModelVer2</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer2), data, dataSize, outColModel, modelName);</p>
<h4>CFileLoader::LoadCollisionModelVer3</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer3), data, dataSize, outColModel, modelName);</p>
<h4>CFileLoader::LoadCollisionModelVer4</h4>
<p>plugin::CallDynGlobal<void *, unsigned int, CColModel &, char const *>(gaddrof(CFileLoader::LoadCollisionModelVer4), data, dataSize, outColModel, modelName);</p>
<h4>CFileLoader::LoadCullZone</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadCullZone), line);</p>
<h4>CFileLoader::LoadEntryExit</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadEntryExit), line);</p>
<h4>CFileLoader::LoadGarage</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadGarage), line);</p>
<h4>CFileLoader::LoadLevel</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadLevel), filename);</p>
<h4>*CFileLoader::LoadLine</h4>
<p>plugin::CallAndReturnDynGlobal<char *, FILESTREAM>(gaddrof_o(CFileLoader::LoadLine, char <em>(</em>)(FILESTREAM)), file);</p>
<p>0AA7: call_function_return 0x536FE0 num_params 1 pop 1 [file] func_ret [char *]</p>
<p>define function CFileLoader__LoadLine&lt;cdecl, 0x536FE0&gt;(file): int</p>
<h4>*CFileLoader::LoadLine</h4>
<p>plugin::CallAndReturnDynGlobal<char *, char **, int &>(gaddrof_o(CFileLoader::LoadLine, char <em>(</em>)(char **, int &amp;)), outLine, outSize);</p>
<p>0AA7: call_function_return 0x536FE0 num_params 2 pop 2 [outLine] [outSize] func_ret [char *]</p>
<p>define function CFileLoader__LoadLine&lt;cdecl, 0x536FE0&gt;(outLine, outSize): int</p>
<h4>CFileLoader::LoadObject</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadObject), line);</p>
<p>0AA7: call_function_return 0x5B3C60 num_params 1 pop 1 [line] func_ret [int]</p>
<p>define function CFileLoader__LoadObject&lt;cdecl, 0x5B3C60&gt;(line): int</p>
<h4>*CFileLoader::LoadObjectInstance</h4>
<p>plugin::CallAndReturnDynGlobal<CEntity *, CFileObjectInstance *, char const *>(gaddrof_o(CFileLoader::LoadObjectInstance, CEntity <em>(</em>)(CFileObjectInstance *, char const *)), objInstance, modelname);</p>
<p>0AA7: call_function_return 0x538690 num_params 2 pop 2 [objInstance] [modelname] func_ret [CEntity *]</p>
<p>define function CFileLoader__LoadObjectInstance&lt;cdecl, 0x538690&gt;(objInstance, modelname): int</p>
<h4>*CFileLoader::LoadObjectInstance</h4>
<p>plugin::CallAndReturnDynGlobal<CEntity *, char const *>(gaddrof_o(CFileLoader::LoadObjectInstance, CEntity <em>(</em>)(char const *)), line);</p>
<p>0AA7: call_function_return 0x538690 num_params 1 pop 1 [line] func_ret [CEntity *]</p>
<p>define function CFileLoader__LoadObjectInstance&lt;cdecl, 0x538690&gt;(line): int</p>
<h4>CFileLoader::LoadObjectTypes</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadObjectTypes), filename);</p>
<h4>CFileLoader::LoadOcclusionVolume</h4>
<p>plugin::CallDynGlobal<char const *, char const *>(gaddrof(CFileLoader::LoadOcclusionVolume), line, filename);</p>
<h4>CFileLoader::LoadPathHeader</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *, int &>(gaddrof(CFileLoader::LoadPathHeader), line, outPathType);</p>
<p>0AA7: call_function_return 0x5B41C0 num_params 2 pop 2 [line] [outPathType] func_ret [int]</p>
<p>define function CFileLoader__LoadPathHeader&lt;cdecl, 0x5B41C0&gt;(line, outPathType): int</p>
<h4>CFileLoader::LoadPedObject</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadPedObject), line);</p>
<p>0AA7: call_function_return 0x5B7420 num_params 1 pop 1 [line] func_ret [int]</p>
<p>define function CFileLoader__LoadPedObject&lt;cdecl, 0x5B7420&gt;(line): int</p>
<h4>CFileLoader::LoadPedPathNode</h4>
<p>plugin::CallDynGlobal<char const *, int, int>(gaddrof(CFileLoader::LoadPedPathNode), line, objModelIndex, pathEntryIndex);</p>
<h4>CFileLoader::LoadPickup</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadPickup), line);</p>
<h4>CFileLoader::LoadScene</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadScene), filename);</p>
<h4>CFileLoader::LoadStuntJump</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadStuntJump), line);</p>
<h4>CFileLoader::LoadTXDParent</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadTXDParent), line);</p>
<h4>*CFileLoader::LoadTexDictionary</h4>
<p>plugin::CallAndReturnDynGlobal<RwTexDictionary *, char const *>(gaddrof(CFileLoader::LoadTexDictionary), filename);</p>
<p>0AA7: call_function_return 0x5B3860 num_params 1 pop 1 [filename] func_ret [RwTexDictionary *]</p>
<p>define function CFileLoader__LoadTexDictionary&lt;cdecl, 0x5B3860&gt;(filename): int</p>
<h4>CFileLoader::LoadTimeCyclesModifier</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadTimeCyclesModifier), line);</p>
<h4>CFileLoader::LoadTimeObject</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadTimeObject), line);</p>
<p>0AA7: call_function_return 0x5B3DE0 num_params 1 pop 1 [line] func_ret [int]</p>
<p>define function CFileLoader__LoadTimeObject&lt;cdecl, 0x5B3DE0&gt;(line): int</p>
<h4>CFileLoader::LoadVehicleObject</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadVehicleObject), line);</p>
<p>0AA7: call_function_return 0x5B6F30 num_params 1 pop 1 [line] func_ret [int]</p>
<p>define function CFileLoader__LoadVehicleObject&lt;cdecl, 0x5B6F30&gt;(line): int</p>
<h4>CFileLoader::LoadWeaponObject</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *>(gaddrof(CFileLoader::LoadWeaponObject), line);</p>
<p>0AA7: call_function_return 0x5B3FB0 num_params 1 pop 1 [line] func_ret [int]</p>
<p>define function CFileLoader__LoadWeaponObject&lt;cdecl, 0x5B3FB0&gt;(line): int</p>
<h4>CFileLoader::LoadZone</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::LoadZone), line);</p>
<h4>CFileLoader::ReloadObjectTypes</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::ReloadObjectTypes), arg1);</p>
<h4>CFileLoader::ReloadPaths</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(CFileLoader::ReloadPaths), filename);</p>
<h4>CFileLoader::SaveTexDictionary</h4>
<p>plugin::CallDynGlobal<RwTexDictionary *, char const *>(gaddrof(CFileLoader::SaveTexDictionary), dictionary, filename);</p>
<h4>*CFileLoader::SetRelatedModelInfoCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CFileLoader::SetRelatedModelInfoCB), atomic, data);</p>
<p>0AA7: call_function_return 0x537150 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CFileLoader__SetRelatedModelInfoCB&lt;cdecl, 0x537150&gt;(atomic, data): int</p>
<h4>CFileLoader::StartLoadClumpFile</h4>
<p>plugin::CallAndReturnDynGlobal<bool, RwStream *, unsigned int>(gaddrof(CFileLoader::StartLoadClumpFile), stream, modelIndex);</p>
<p>0AA7: call_function_return 0x5373F0 num_params 2 pop 2 [stream] [modelIndex] func_ret [bool]</p>
<p>define function CFileLoader__StartLoadClumpFile&lt;cdecl, 0x5373F0&gt;(stream, modelIndex): int</p>
<h4>GetNameAndDamage</h4>
<p>plugin::CallDynGlobal<char const *, char *, bool &>(gaddrof(GetNameAndDamage), nodeName, outName, outDamage);</p>
<h4>*CloneAtomicToClumpCB</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(CloneAtomicToClumpCB), atomic, data);</p>
<p>0AA7: call_function_return 0x537290 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function CloneAtomicToClumpCB&lt;cdecl, 0x537290&gt;(atomic, data): int</p>
<h4>*GetFilename</h4>
<p>plugin::CallAndReturnDynGlobal<char const *, char const *>(gaddrof(GetFilename), filepath);</p>
<p>0AA7: call_function_return 0x5B3660 num_params 1 pop 1 [filepath] func_ret [char const *]</p>
<p>define function GetFilename&lt;cdecl, 0x5B3660&gt;(filepath): int</p>
<h4>LoadingScreenLoadingFile</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(LoadingScreenLoadingFile), filename);</p>
<h4>*AddTextureCB</h4>
<p>plugin::CallAndReturnDynGlobal<RwTexture *, RwTexture *, void *>(gaddrof(AddTextureCB), texture, data);</p>
<p>0AA7: call_function_return 0x5B38F0 num_params 2 pop 2 [texture] [data] func_ret [RwTexture *]</p>
<p>define function AddTextureCB&lt;cdecl, 0x5B38F0&gt;(texture, data): int</p><h3 id="plugin_sagame_sacformationcpp">plugin_sa\game_sa\CFormation.cpp</h3><h4>CFormation::DistributeDestinations</h4>
<p>plugin::CallDynGlobal<CPedList *>(gaddrof(CFormation::DistributeDestinations), pedlist);</p>
<h4>CFormation::DistributeDestinations_CoverPoints</h4>
<p>plugin::CallDynGlobal<CPedList *, CVector>(gaddrof(CFormation::DistributeDestinations_CoverPoints), pedlist, pos);</p>
<h4>CFormation::DistributeDestinations_PedsToAttack</h4>
<p>plugin::CallDynGlobal<CPedList *>(gaddrof(CFormation::DistributeDestinations_PedsToAttack), pedlist);</p>
<h4>CFormation::FindCoverPoints</h4>
<p>plugin::CallDynGlobal<CVector, float>(gaddrof(CFormation::FindCoverPoints), pos, radius);</p>
<h4>CFormation::FindCoverPointsBehindBox</h4>
<p>plugin::CallDynGlobal<CPointList *, CVector, CMatrix *, CVector const *, CVector const *, CVector const *, float>(gaddrof(CFormation::FindCoverPointsBehindBox), pointlist, Pos, coverEntityMatrix, vecCenter, vecMin, vecMax, radius);</p>
<h4>CFormation::FindNearestAvailableDestination</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, CVector, float *>(gaddrof(CFormation::FindNearestAvailableDestination), pos, pOutDistance);</p>
<p>0AA7: call_function_return 0x69B1B0 num_params 2 pop 2 [pos] [pOutDistance] func_ret [signed int]</p>
<p>define function CFormation__FindNearestAvailableDestination&lt;cdecl, 0x69B1B0&gt;(pos, pOutDistance): int</p>
<h4>CFormation::GenerateGatherDestinations</h4>
<p>plugin::CallDynGlobal<CPedList *, CPed *>(gaddrof(CFormation::GenerateGatherDestinations), pedList, ped);</p>
<h4>CFormation::GenerateGatherDestinations_AroundCar</h4>
<p>plugin::CallDynGlobal<CPedList *, CVehicle *>(gaddrof(CFormation::GenerateGatherDestinations_AroundCar), pedlist, vehicle);</p>
<h4>CFormation::ReturnDestinationForPed</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *, CVector *>(gaddrof(CFormation::ReturnDestinationForPed), ped, pos);</p>
<p>0AA7: call_function_return 0x699FA0 num_params 2 pop 2 [ped] [pos] func_ret [bool]</p>
<p>define function CFormation__ReturnDestinationForPed&lt;cdecl, 0x699FA0&gt;(ped, pos): int</p>
<h4>CFormation::ReturnTargetPedForPed</h4>
<p>plugin::CallAndReturnDynGlobal<int, CPed *, CPed **>(gaddrof(CFormation::ReturnTargetPedForPed), ped, pOutTargetPed);</p>
<p>0AA7: call_function_return 0x699F50 num_params 2 pop 2 [ped] [pOutTargetPed] func_ret [int]</p>
<p>define function CFormation__ReturnTargetPedForPed&lt;cdecl, 0x699F50&gt;(ped, pOutTargetPed): int</p><h3 id="plugin_sagame_sacgamecpp">plugin_sa\game_sa\CGame.cpp</h3><h4>CGame::CanSeeOutSideFromCurrArea</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeOutSideFromCurrArea));</p>
<p>0AA7: call_function_return 0x53C4A0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__CanSeeOutSideFromCurrArea&lt;cdecl, 0x53C4A0&gt;(): int</p>
<h4>CGame::CanSeeWaterFromCurrArea</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeWaterFromCurrArea));</p>
<p>0AA7: call_function_return 0x53C4B0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__CanSeeWaterFromCurrArea&lt;cdecl, 0x53C4B0&gt;(): int</p>
<h4>CGame::DrasticTidyUpMemory</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CGame::DrasticTidyUpMemory), a1);</p>
<h4>CGame::Init1</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init1), datFile);</p>
<p>0AA7: call_function_return 0x5BF840 num_params 1 pop 1 [datFile] func_ret [bool]</p>
<p>define function CGame__Init1&lt;cdecl, 0x5BF840&gt;(datFile): int</p>
<h4>CGame::Init2</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init2), datFile);</p>
<p>0AA7: call_function_return 0x5BA1A0 num_params 1 pop 1 [datFile] func_ret [bool]</p>
<p>define function CGame__Init2&lt;cdecl, 0x5BA1A0&gt;(datFile): int</p>
<h4>CGame::Init3</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Init3), datFile);</p>
<p>0AA7: call_function_return 0x5BA400 num_params 1 pop 1 [datFile] func_ret [bool]</p>
<p>define function CGame__Init3&lt;cdecl, 0x5BA400&gt;(datFile): int</p>
<h4>CGame::Initialise</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);</p>
<p>0AA7: call_function_return 0x53BC80 num_params 1 pop 1 [datFile] func_ret [bool]</p>
<p>define function CGame__Initialise&lt;cdecl, 0x53BC80&gt;(datFile): int</p>
<h4>CGame::InitialiseCoreDataAfterRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseCoreDataAfterRW));</p>
<p>0AA7: call_function_return 0x5BFA90 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseCoreDataAfterRW&lt;cdecl, 0x5BFA90&gt;(): int</p>
<h4>CGame::InitialiseEssentialsAfterRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseEssentialsAfterRW));</p>
<p>0AA7: call_function_return 0x5BA160 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseEssentialsAfterRW&lt;cdecl, 0x5BA160&gt;(): int</p>
<h4>CGame::InitialiseOnceBeforeRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));</p>
<p>0AA7: call_function_return 0x53BB50 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseOnceBeforeRW&lt;cdecl, 0x53BB50&gt;(): int</p>
<h4>CGame::InitialiseRenderWare</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));</p>
<p>0AA7: call_function_return 0x5BD600 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseRenderWare&lt;cdecl, 0x5BD600&gt;(): int</p>
<h4>CGame::Shutdown</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));</p>
<p>0AA7: call_function_return 0x53C900 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__Shutdown&lt;cdecl, 0x53C900&gt;(): int</p>
<h4>CGame::TidyUpMemory</h4>
<p>plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), a1, clearD3Dmem);</p>
<h4>MoveMem</h4>
<p>plugin::CallAndReturnDynGlobal<bool, void **>(gaddrof(MoveMem), pMem);</p>
<p>0AA7: call_function_return 0x53C250 num_params 1 pop 1 [pMem] func_ret [bool]</p>
<p>define function MoveMem&lt;cdecl, 0x53C250&gt;(pMem): int</p>
<h4>MoveColModelMemory</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CColModel &, bool>(gaddrof(MoveColModelMemory), colModel, a2);</p>
<p>0AA7: call_function_return 0x53C290 num_params 2 pop 2 [colModel] [a2] func_ret [bool]</p>
<p>define function MoveColModelMemory&lt;cdecl, 0x53C290&gt;(colModel, a2): int</p>
<h4>*MoveGeometryMemory</h4>
<p>plugin::CallAndReturnDynGlobal<RpGeometry *, RpGeometry *>(gaddrof(MoveGeometryMemory), geometry);</p>
<p>0AA7: call_function_return 0x53C3E0 num_params 1 pop 1 [geometry] func_ret [RpGeometry *]</p>
<p>define function MoveGeometryMemory&lt;cdecl, 0x53C3E0&gt;(geometry): int</p>
<h4>TidyUpModelInfo2</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CEntity *, bool>(gaddrof(TidyUpModelInfo2), entity, a2);</p>
<p>0AA7: call_function_return 0x53C440 num_params 2 pop 2 [entity] [a2] func_ret [bool]</p>
<p>define function TidyUpModelInfo2&lt;cdecl, 0x53C440&gt;(entity, a2): int</p>
<h4>DoHaspChecks</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(DoHaspChecks));</p>
<p>0AA7: call_function_return 0x5BA150 num_params 0 pop 0 func_ret [bool]</p>
<p>define function DoHaspChecks&lt;cdecl, 0x5BA150&gt;(): int</p><h3 id="plugin_sagame_sacgamelogiccpp">plugin_sa\game_sa\CGameLogic.cpp</h3><h4>CGameLogic::InitAtStartOfGame</h4>
<p>plugin::Call<0x441210>();</p>
<p>0AA5: call_function 0x441210 num_params 0 pop 0</p>
<p>define function CGameLogic__InitAtStartOfGame&lt;cdecl, 0x441210&gt;()</p>
<h4>CGameLogic::IsCoopGameGoingOn</h4>
<p>plugin::CallAndReturn<bool, 0x441390>();</p>
<p>0AA7: call_function_return 0x441390 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGameLogic__IsCoopGameGoingOn&lt;cdecl, 0x441390&gt;(): int</p>
<h4>CGameLogic::Remove2ndPlayerIfPresent</h4>
<p>plugin::Call<0x4413C0>();</p>
<p>0AA5: call_function 0x4413C0 num_params 0 pop 0</p>
<p>define function CGameLogic__Remove2ndPlayerIfPresent&lt;cdecl, 0x4413C0&gt;()</p>
<h4>CGameLogic::SortOutStreamingAndMemory</h4>
<p>plugin::Call<0x441440, CVector*, float>(translation, angle);</p>
<p>0AA5: call_function 0x441440 num_params 2 pop 2 [translation] [angle]</p>
<p>define function CGameLogic__SortOutStreamingAndMemory&lt;cdecl, 0x441440&gt;(translation, angle)</p>
<h4>CGameLogic::PassTime</h4>
<p>plugin::Call<0x4414C0, unsigned int>(time);</p>
<p>0AA5: call_function 0x4414C0 num_params 1 pop 1 [time]</p>
<p>define function CGameLogic__PassTime&lt;cdecl, 0x4414C0&gt;(time)</p>
<h4>CGameLogic::ClearSkip</h4>
<p>plugin::Call<0x441560, char>(a1);</p>
<p>0AA5: call_function 0x441560 num_params 1 pop 1 [a1]</p>
<p>define function CGameLogic__ClearSkip&lt;cdecl, 0x441560&gt;(a1)</p>
<h4>CGameLogic::SkipCanBeActivated</h4>
<p>plugin::CallAndReturn<bool, 0x4415C0>();</p>
<p>0AA7: call_function_return 0x4415C0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGameLogic__SkipCanBeActivated&lt;cdecl, 0x4415C0&gt;(): int</p>
<h4>CGameLogic::IsPointWithinLineArea</h4>
<p>plugin::CallAndReturn<int, 0x4416E0, RwV3d*, signed int, float, float>(vectors, sizeofvectors, x, y);</p>
<p>0AA7: call_function_return 0x4416E0 num_params 4 pop 4 [vectors] [sizeofvectors] [x] [y] func_ret [int]</p>
<p>define function CGameLogic__IsPointWithinLineArea&lt;cdecl, 0x4416E0&gt;(vectors, sizeofvectors, x, y): int</p>
<h4>CGameLogic::SetPlayerWantedLevelForForbiddenTerritories</h4>
<p>plugin::Call<0x441770, char>(townNumber);</p>
<p>0AA5: call_function 0x441770 num_params 1 pop 1 [townNumber]</p>
<p>define function CGameLogic__SetPlayerWantedLevelForForbiddenTerritories&lt;cdecl, 0x441770&gt;(townNumber)</p>
<h4>CGameLogic::CalcDistanceToForbiddenTrainCrossing</h4>
<p>plugin::CallAndReturn<long double, 0x4418E0, float, float, float, float, float, float, char, CVector*>(x1, y1, z1, x2, y2, z2, a7, a8);</p>
<p>0AA7: call_function_return 0x4418E0 num_params 8 pop 8 [x1] [y1] [z1] [x2] [y2] [z2] [a7] [a8] func_ret [long double]</p>
<p>define function CGameLogic__CalcDistanceToForbiddenTrainCrossing&lt;cdecl, 0x4418E0&gt;(x1, y1, z1, x2, y2, z2, a7, a8): int</p>
<h4>CGameLogic::LaRiotsActiveHere</h4>
<p>plugin::CallAndReturn<bool, 0x441C10>();</p>
<p>0AA7: call_function_return 0x441C10 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGameLogic__LaRiotsActiveHere&lt;cdecl, 0x441C10&gt;(): int</p>
<h4>CGameLogic::RestorePedsWeapons</h4>
<p>plugin::CallAndReturn<signed int, 0x441D30, int>(a1);</p>
<p>0AA7: call_function_return 0x441D30 num_params 1 pop 1 [a1] func_ret [signed int]</p>
<p>define function CGameLogic__RestorePedsWeapons&lt;cdecl, 0x441D30&gt;(a1): int</p>
<h4>CGameLogic::IsPlayerAllowedToGoInThisDirection</h4>
<p>plugin::CallAndReturn<bool, 0x441E10, CPed*, float, float, float, float>(a1, a2, a3, a4, a5);</p>
<p>0AA7: call_function_return 0x441E10 num_params 5 pop 5 [a1] [a2] [a3] [a4] [a5] func_ret [bool]</p>
<p>define function CGameLogic__IsPlayerAllowedToGoInThisDirection&lt;cdecl, 0x441E10&gt;(a1, a2, a3, a4, a5): int</p>
<h4>CGameLogic::RestorePlayerStuffDuringResurrection</h4>
<p>plugin::Call<0x442060, CPlayerPed*, float, float, float, float>(player, x, y, z, fAngle);</p>
<p>0AA5: call_function 0x442060 num_params 5 pop 5 [player] [x] [y] [z] [fAngle]</p>
<p>define function CGameLogic__RestorePlayerStuffDuringResurrection&lt;cdecl, 0x442060&gt;(player, x, y, z, fAngle)</p>
<h4>CGameLogic::UpdateSkip</h4>
<p>plugin::Call<0x442480>();</p>
<p>0AA5: call_function 0x442480 num_params 0 pop 0</p>
<p>define function CGameLogic__UpdateSkip&lt;cdecl, 0x442480&gt;()</p>
<h4>CGameLogic::ResetStuffUponResurrection</h4>
<p>plugin::Call<0x442980>();</p>
<p>0AA5: call_function 0x442980 num_params 0 pop 0</p>
<p>define function CGameLogic__ResetStuffUponResurrection&lt;cdecl, 0x442980&gt;()</p>
<h4>CGameLogic::Update</h4>
<p>plugin::Call<0x442AD0>();</p>
<p>0AA5: call_function 0x442AD0 num_params 0 pop 0</p>
<p>define function CGameLogic__Update&lt;cdecl, 0x442AD0&gt;()</p>
<h4>CGameLogic::Save</h4>
<p>plugin::Call<0x5D33C0>();</p>
<p>0AA5: call_function 0x5D33C0 num_params 0 pop 0</p>
<p>define function CGameLogic__Save&lt;cdecl, 0x5D33C0&gt;()</p><h3 id="plugin_sagame_sacgangscpp">plugin_sa\game_sa\CGangs.cpp</h3><h4>CGangs::ChooseGangPedModel</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, short>(gaddrof(CGangs::ChooseGangPedModel), gangID);</p>
<p>0AA7: call_function_return 0x5DE5A0 num_params 1 pop 1 [gangID] func_ret [signed int]</p>
<p>define function CGangs__ChooseGangPedModel&lt;cdecl, 0x5DE5A0&gt;(gangID): int</p>
<h4>CGangs::GetWillAttackPlayerWithCops</h4>
<p>plugin::CallAndReturnDynGlobal<bool, ePedType>(gaddrof(CGangs::GetWillAttackPlayerWithCops), gangID);</p>
<p>0AA7: call_function_return 0x5DE500 num_params 1 pop 1 [gangID] func_ret [bool]</p>
<p>define function CGangs__GetWillAttackPlayerWithCops&lt;cdecl, 0x5DE500&gt;(gangID): int</p>
<h4>CGangs::SetGangPedModelOverride</h4>
<p>plugin::CallDynGlobal<short, signed char>(gaddrof(CGangs::SetGangPedModelOverride), gangID, PedModelOverride);</p>
<h4>CGangs::SetGangWeapons</h4>
<p>plugin::CallDynGlobal<short, int, int, int>(gaddrof(CGangs::SetGangWeapons), gangID, weapID1, weapID2, weapID3);</p>
<h4>CGangs::SetWillAttackPlayerWithCops</h4>
<p>plugin::CallDynGlobal<ePedType, bool>(gaddrof(CGangs::SetWillAttackPlayerWithCops), gangID, bAttackPlayerWithCops);</p><h3 id="plugin_sagame_sacgangwarscpp">plugin_sa\game_sa\CGangWars.cpp</h3><h4>CGangWars::AddKillToProvocation</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CGangWars::AddKillToProvocation), Pedtype);</p>
<h4>CGangWars::AttackWaveOvercome</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::AttackWaveOvercome));</p>
<p>0AA7: call_function_return 0x445B30 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGangWars__AttackWaveOvercome&lt;cdecl, 0x445B30&gt;(): int</p>
<h4>CGangWars::CalculateTimeTillNextAttack</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CGangWars::CalculateTimeTillNextAttack));</p>
<p>0AA7: call_function_return 0x443DB0 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CGangWars__CalculateTimeTillNextAttack&lt;cdecl, 0x443DB0&gt;(): int</p>
<h4>CGangWars::CanPlayerStartAGangWarHere</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CZoneInfo *>(gaddrof(CGangWars::CanPlayerStartAGangWarHere), zoneInfo);</p>
<p>0AA7: call_function_return 0x443F80 num_params 1 pop 1 [zoneInfo] func_ret [bool]</p>
<p>define function CGangWars__CanPlayerStartAGangWarHere&lt;cdecl, 0x443F80&gt;(zoneInfo): int</p>
<h4>CGangWars::CreateAttackWave</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, int>(gaddrof(CGangWars::CreateAttackWave), warFerocity, waveID);</p>
<p>0AA7: call_function_return 0x444810 num_params 2 pop 2 [warFerocity] [waveID] func_ret [bool]</p>
<p>define function CGangWars__CreateAttackWave&lt;cdecl, 0x444810&gt;(warFerocity, waveID): int</p>
<h4>CGangWars::CreateDefendingGroup</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGangWars::CreateDefendingGroup), unsued);</p>
<p>0AA7: call_function_return 0x4453D0 num_params 1 pop 1 [unsued] func_ret [bool]</p>
<p>define function CGangWars__CreateDefendingGroup&lt;cdecl, 0x4453D0&gt;(unsued): int</p>
<h4>CGangWars::DoesPlayerControlThisZone</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CZoneInfo *>(gaddrof(CGangWars::DoesPlayerControlThisZone), zoneinfo);</p>
<p>0AA7: call_function_return 0x443AE0 num_params 1 pop 1 [zoneinfo] func_ret [bool]</p>
<p>define function CGangWars__DoesPlayerControlThisZone&lt;cdecl, 0x443AE0&gt;(zoneinfo): int</p>
<h4>CGangWars::DontCreateCivilians</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::DontCreateCivilians));</p>
<p>0AA7: call_function_return 0x4439C0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGangWars__DontCreateCivilians&lt;cdecl, 0x4439C0&gt;(): int</p>
<h4>CGangWars::EndGangWar</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CGangWars::EndGangWar), bEnd);</p>
<h4>CGangWars::GangWarFightingGoingOn</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::GangWarFightingGoingOn));</p>
<p>0AA7: call_function_return 0x443AC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGangWars__GangWarFightingGoingOn&lt;cdecl, 0x443AC0&gt;(): int</p>
<h4>CGangWars::GangWarGoingOn</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::GangWarGoingOn));</p>
<p>0AA7: call_function_return 0x443AA0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGangWars__GangWarGoingOn&lt;cdecl, 0x443AA0&gt;(): int</p>
<h4>CGangWars::MakeEnemyGainInfluenceInZone</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CGangWars::MakeEnemyGainInfluenceInZone), GangID, GangDensityIncreaser);</p>
<h4>CGangWars::MakePlayerGainInfluenceInZone</h4>
<p>plugin::CallAndReturnDynGlobal<bool, float>(gaddrof(CGangWars::MakePlayerGainInfluenceInZone), remove_mult);</p>
<p>0AA7: call_function_return 0x445E80 num_params 1 pop 1 [remove_mult] func_ret [bool]</p>
<p>define function CGangWars__MakePlayerGainInfluenceInZone&lt;cdecl, 0x445E80&gt;(remove_mult): int</p>
<h4>CGangWars::PedStreamedInForThisGang</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGangWars::PedStreamedInForThisGang), gangID);</p>
<p>0AA7: call_function_return 0x4439D0 num_params 1 pop 1 [gangID] func_ret [bool]</p>
<p>define function CGangWars__PedStreamedInForThisGang&lt;cdecl, 0x4439D0&gt;(gangID): int</p>
<h4>CGangWars::PickStreamedInPedForThisGang</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, int *>(gaddrof(CGangWars::PickStreamedInPedForThisGang), gangID, outPedID);</p>
<p>0AA7: call_function_return 0x443A20 num_params 2 pop 2 [gangID] [outPedID] func_ret [bool]</p>
<p>define function CGangWars__PickStreamedInPedForThisGang&lt;cdecl, 0x443A20&gt;(gangID, outPedID): int</p>
<h4>CGangWars::PickZoneToAttack</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGangWars::PickZoneToAttack));</p>
<p>0AA7: call_function_return 0x443B00 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGangWars__PickZoneToAttack&lt;cdecl, 0x443B00&gt;(): int</p>
<h4>CGangWars::ReleasePedsInAttackWave</h4>
<p>plugin::CallAndReturnDynGlobal<int, bool, bool>(gaddrof(CGangWars::ReleasePedsInAttackWave), IsEndOfWar, RestoreGangPedsAcquaintance);</p>
<p>0AA7: call_function_return 0x445C30 num_params 2 pop 2 [IsEndOfWar] [RestoreGangPedsAcquaintance] func_ret [int]</p>
<p>define function CGangWars__ReleasePedsInAttackWave&lt;cdecl, 0x445C30&gt;(IsEndOfWar, RestoreGangPedsAcquaintance): int</p>
<h4>CGangWars::SetGangWarsActive</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CGangWars::SetGangWarsActive), bActive);</p>
<h4>CGangWars::SetSpecificZoneToTriggerGangWar</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CGangWars::SetSpecificZoneToTriggerGangWar), zoneId);</p>
<h4>CGangWars::StrengthenPlayerInfluenceInZone</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CGangWars::StrengthenPlayerInfluenceInZone), GroveDensityIncreaser);</p>
<h4>CGangWars::TellGangMembersTo</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CGangWars::TellGangMembersTo), bIsGangWarEnding);</p>
<h4>CGangWars::TellStreamingWhichGangsAreNeeded</h4>
<p>plugin::CallDynGlobal<int *>(gaddrof(CGangWars::TellStreamingWhichGangsAreNeeded), GangsBitFlags);</p><h3 id="plugin_sagame_sacgangwarssavestructurecpp">plugin_sa\game_sa\CGangWarsSaveStructure.cpp</h3><h4>CGangWarsSaveStructure::Construct</h4>
<p>plugin::CallMethodDynGlobal<CGangWarsSaveStructure *>(gaddrof(CGangWarsSaveStructure::Construct), this);</p>
<p>0AA6: call_method 0x5D2620 struct [CGangWarsSaveStructure] num_params 0 pop 0</p>
<p>define function CGangWarsSaveStructure__Construct&lt;thiscall, 0x5D2620&gt;()</p>
<h4>CGangWarsSaveStructure::Extract</h4>
<p>plugin::CallMethodDynGlobal<CGangWarsSaveStructure *>(gaddrof(CGangWarsSaveStructure::Extract), this);</p>
<p>0AA6: call_method 0x5D2740 struct [CGangWarsSaveStructure] num_params 0 pop 0</p>
<p>define function CGangWarsSaveStructure__Extract&lt;thiscall, 0x5D2740&gt;()</p><h3 id="plugin_sagame_sacgenericgamestoragecpp">plugin_sa\game_sa\CGenericGameStorage.cpp</h3><h4>CGenericGameStorage::CheckDataNotCorrupt</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CGenericGameStorage::CheckDataNotCorrupt), saveID, saveGameFilename);</p>
<p>0AA7: call_function_return 0x5D1170 num_params 2 pop 2 [saveID] [saveGameFilename] func_ret [bool]</p>
<p>define function CGenericGameStorage__CheckDataNotCorrupt&lt;cdecl, 0x5D1170&gt;(saveID, saveGameFilename): int</p>
<h4>CGenericGameStorage::CheckSlotDataValid</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, bool>(gaddrof(CGenericGameStorage::CheckSlotDataValid), saveID, unused);</p>
<p>0AA7: call_function_return 0x5D1380 num_params 2 pop 2 [saveID] [unused] func_ret [bool]</p>
<p>define function CGenericGameStorage__CheckSlotDataValid&lt;cdecl, 0x5D1380&gt;(saveID, unused): int</p>
<h4>CGenericGameStorage::GenericLoad</h4>
<p>plugin::CallAndReturnDynGlobal<bool, bool *>(gaddrof(CGenericGameStorage::GenericLoad), arg1);</p>
<p>0AA7: call_function_return 0x5D17B0 num_params 1 pop 1 [arg1] func_ret [bool]</p>
<p>define function CGenericGameStorage__GenericLoad&lt;cdecl, 0x5D17B0&gt;(arg1): int</p>
<h4>CGenericGameStorage::GenericSave</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CGenericGameStorage::GenericSave), unused);</p>
<p>0AA7: call_function_return 0x5D13E0 num_params 1 pop 1 [unused] func_ret [bool]</p>
<p>define function CGenericGameStorage__GenericSave&lt;cdecl, 0x5D13E0&gt;(unused): int</p>
<h4>CGenericGameStorage::GetCurrentVersionNumber</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CGenericGameStorage::GetCurrentVersionNumber));</p>
<p>0AA7: call_function_return 0x5D0F50 num_params 0 pop 0 func_ret [int]</p>
<p>define function CGenericGameStorage__GetCurrentVersionNumber&lt;cdecl, 0x5D0F50&gt;(): int</p>
<h4>*CGenericGameStorage::GetNameOfSavedGame</h4>
<p>plugin::CallAndReturnDynGlobal<char *, int>(gaddrof(CGenericGameStorage::GetNameOfSavedGame), saveID);</p>
<p>0AA7: call_function_return 0x5D0F40 num_params 1 pop 1 [saveID] func_ret [char *]</p>
<p>define function CGenericGameStorage__GetNameOfSavedGame&lt;cdecl, 0x5D0F40&gt;(saveID): int</p>
<h4>*CGenericGameStorage::GetNameOfSavedGame_Alt</h4>
<p>plugin::CallAndReturnDynGlobal<char *, int>(gaddrof(CGenericGameStorage::GetNameOfSavedGame_Alt), saveID);</p>
<p>0AA7: call_function_return 0x619030 num_params 1 pop 1 [saveID] func_ret [char *]</p>
<p>define function CGenericGameStorage__GetNameOfSavedGame_Alt&lt;cdecl, 0x619030&gt;(saveID): int</p>
<h4>CGenericGameStorage::GetSavedRadioStationPosition</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CGenericGameStorage::GetSavedRadioStationPosition));</p>
<p>0AA7: call_function_return 0x618E80 num_params 0 pop 0 func_ret [int]</p>
<p>define function CGenericGameStorage__GetSavedRadioStationPosition&lt;cdecl, 0x618E80&gt;(): int</p>
<h4>CGenericGameStorage::LoadWorkBuffer</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGenericGameStorage::LoadWorkBuffer));</p>
<p>0AA7: call_function_return 0x5D10B0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGenericGameStorage__LoadWorkBuffer&lt;cdecl, 0x5D10B0&gt;(): int</p>
<h4>CGenericGameStorage::MakeValidSaveName</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CGenericGameStorage::MakeValidSaveName), saveNum);</p>
<h4>CGenericGameStorage::OpenFileForReading</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char *, unsigned int *>(gaddrof(CGenericGameStorage::OpenFileForReading), saveGameFilename, saveID);</p>
<p>0AA7: call_function_return 0x5D0D20 num_params 2 pop 2 [saveGameFilename] [saveID] func_ret [bool]</p>
<p>define function CGenericGameStorage__OpenFileForReading&lt;cdecl, 0x5D0D20&gt;(saveGameFilename, saveID): int</p>
<h4>CGenericGameStorage::OpenFileForWriting</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGenericGameStorage::OpenFileForWriting));</p>
<p>0AA7: call_function_return 0x5D0DD0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGenericGameStorage__OpenFileForWriting&lt;cdecl, 0x5D0DD0&gt;(): int</p>
<h4>CGenericGameStorage::ReportError</h4>
<p>plugin::CallDynGlobal<eSaveLoadBlocks, eSaveLoadError>(gaddrof(CGenericGameStorage::ReportError),block,errorType);</p>
<h4>CGenericGameStorage::RestoreForStartLoad</h4>
<p>plugin::CallAndReturnDynGlobal<char>(gaddrof(CGenericGameStorage::RestoreForStartLoad));</p>
<p>0AA7: call_function_return 0x619000 num_params 0 pop 0 func_ret [char]</p>
<p>define function CGenericGameStorage__RestoreForStartLoad&lt;cdecl, 0x619000&gt;(): int</p>
<h4>CGenericGameStorage::SaveWorkBuffer</h4>
<p>plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CGenericGameStorage::SaveWorkBuffer), a1);</p>
<p>0AA7: call_function_return 0x5D0F80 num_params 1 pop 1 [a1] func_ret [bool]</p>
<p>define function CGenericGameStorage__SaveWorkBuffer&lt;cdecl, 0x5D0F80&gt;(a1): int</p>
<h4>CGenericGameStorage::_LoadDataFromWorkBuffer</h4>
<p>plugin::CallAndReturnDynGlobal<bool, void *, int>(gaddrof(CGenericGameStorage::_LoadDataFromWorkBuffer), pData, size);</p>
<p>0AA7: call_function_return 0x5D1300 num_params 2 pop 2 [pData] [size] func_ret [bool]</p>
<p>define function CGenericGameStorage___LoadDataFromWorkBuffer&lt;cdecl, 0x5D1300&gt;(pData, size): int</p>
<h4>CGenericGameStorage::_SaveDataToWorkBuffer</h4>
<p>plugin::CallAndReturnDynGlobal<bool, void *, int>(gaddrof(CGenericGameStorage::_SaveDataToWorkBuffer), pData, Size);</p>
<p>0AA7: call_function_return 0x5D1270 num_params 2 pop 2 [pData] [Size] func_ret [bool]</p>
<p>define function CGenericGameStorage___SaveDataToWorkBuffer&lt;cdecl, 0x5D1270&gt;(pData, Size): int</p><h3 id="plugin_sagame_sacgridrefcpp">plugin_sa\game_sa\CGridRef.cpp</h3><h4>*CGridRef::GetAreaName</h4>
<p>plugin::CallAndReturnDynGlobal<char *, unsigned char, unsigned char>(gaddrof(CGridRef::GetAreaName), sectorX, sectorY);</p>
<p>0AA7: call_function_return 0x71D650 num_params 2 pop 2 [sectorX] [sectorY] func_ret [char *]</p>
<p>define function CGridRef__GetAreaName&lt;cdecl, 0x71D650&gt;(sectorX, sectorY): int</p>
<h4>CGridRef::GetArtistBugstarID</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, unsigned char, unsigned char>(gaddrof(CGridRef::GetArtistBugstarID), sectorX, sectorY);</p>
<p>0AA7: call_function_return 0x71D670 num_params 2 pop 2 [sectorX] [sectorY] func_ret [unsigned int]</p>
<p>define function CGridRef__GetArtistBugstarID&lt;cdecl, 0x71D670&gt;(sectorX, sectorY): int</p>
<h4>CGridRef::GetGridRefPositions</h4>
<p>plugin::CallDynGlobal<CVector, unsigned char *, unsigned char *>(gaddrof_o(CGridRef::GetGridRefPositions, void (*)(CVector, unsigned char *, unsigned char *)), posn, outSectorX, outSectorY);</p>
<h4>CGridRef::GetGridRefPositions</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned char *>(gaddrof_o(CGridRef::GetGridRefPositions, void (*)(unsigned char *, unsigned char *)), outSectorX, outSectorY);</p><h3 id="plugin_sagame_sachudcpp">plugin_sa\game_sa\CHud.cpp</h3><h4>CHud::Draw</h4>
<p>plugin::Call<0x58FAE0>();</p>
<p>0AA5: call_function 0x58FAE0 num_params 0 pop 0</p>
<p>define function CHud__Draw&lt;cdecl, 0x58FAE0&gt;()</p>
<h4>CHud::DrawAfterFade</h4>
<p>plugin::Call<0x58D490>();</p>
<p>0AA5: call_function 0x58D490 num_params 0 pop 0</p>
<p>define function CHud__DrawAfterFade&lt;cdecl, 0x58D490&gt;()</p>
<h4>CHud::DrawAreaName</h4>
<p>plugin::Call<0x58AA50>();</p>
<p>0AA5: call_function 0x58AA50 num_params 0 pop 0</p>
<p>define function CHud__DrawAreaName&lt;cdecl, 0x58AA50&gt;()</p>
<h4>CHud::DrawBustedWastedMessage</h4>
<p>plugin::Call<0x58CA50>();</p>
<p>0AA5: call_function 0x58CA50 num_params 0 pop 0</p>
<p>define function CHud__DrawBustedWastedMessage&lt;cdecl, 0x58CA50&gt;()</p>
<h4>CHud::DrawCrossHairs</h4>
<p>plugin::Call<0x58E020>();</p>
<p>0AA5: call_function 0x58E020 num_params 0 pop 0</p>
<p>define function CHud__DrawCrossHairs&lt;cdecl, 0x58E020&gt;()</p>
<h4>CHud::DrawFadeState</h4>
<p>plugin::CallAndReturn<float, 0x58D580, DRAW_FADE_STATE, int>(fadeState, arg1);</p>
<p>0AA7: call_function_return 0x58D580 num_params 2 pop 2 [fadeState] [arg1] func_ret [float]</p>
<p>define function CHud__DrawFadeState&lt;cdecl, 0x58D580&gt;(fadeState, arg1): float</p>
<h4>CHud::DrawHelpText</h4>
<p>plugin::Call<0x58B6E0>();</p>
<p>0AA5: call_function 0x58B6E0 num_params 0 pop 0</p>
<p>define function CHud__DrawHelpText&lt;cdecl, 0x58B6E0&gt;()</p>
<h4>CHud::DrawMissionTimers</h4>
<p>plugin::Call<0x58B180>();</p>
<p>0AA5: call_function 0x58B180 num_params 0 pop 0</p>
<p>define function CHud__DrawMissionTimers&lt;cdecl, 0x58B180&gt;()</p>
<h4>CHud::DrawMissionTitle</h4>
<p>plugin::Call<0x58D240>();</p>
<p>0AA5: call_function 0x58D240 num_params 0 pop 0</p>
<p>define function CHud__DrawMissionTitle&lt;cdecl, 0x58D240&gt;()</p>
<h4>CHud::DrawOddJobMessage</h4>
<p>plugin::Call<0x58CC80, unsigned char>(priority);</p>
<p>0AA5: call_function 0x58CC80 num_params 1 pop 1 [priority]</p>
<p>define function CHud__DrawOddJobMessage&lt;cdecl, 0x58CC80&gt;(priority)</p>
<h4>CHud::DrawRadar</h4>
<p>plugin::Call<0x58A330>();</p>
<p>0AA5: call_function 0x58A330 num_params 0 pop 0</p>
<p>define function CHud__DrawRadar&lt;cdecl, 0x58A330&gt;()</p>
<h4>CHud::DrawScriptText</h4>
<p>plugin::Call<0x58C080, unsigned char>(priority);</p>
<p>0AA5: call_function 0x58C080 num_params 1 pop 1 [priority]</p>
<p>define function CHud__DrawScriptText&lt;cdecl, 0x58C080&gt;(priority)</p>
<h4>CHud::DrawSubtitles</h4>
<p>plugin::Call<0x58C250>();</p>
<p>0AA5: call_function 0x58C250 num_params 0 pop 0</p>
<p>define function CHud__DrawSubtitles&lt;cdecl, 0x58C250&gt;()</p>
<h4>CHud::DrawSuccessFailedMessage</h4>
<p>plugin::Call<0x58C6A0>();</p>
<p>0AA5: call_function 0x58C6A0 num_params 0 pop 0</p>
<p>define function CHud__DrawSuccessFailedMessage&lt;cdecl, 0x58C6A0&gt;()</p>
<h4>CHud::DrawVehicleName</h4>
<p>plugin::Call<0x58AEA0>();</p>
<p>0AA5: call_function 0x58AEA0 num_params 0 pop 0</p>
<p>define function CHud__DrawVehicleName&lt;cdecl, 0x58AEA0&gt;()</p>
<h4>CHud::DrawVitalStats</h4>
<p>plugin::Call<0x589650>();</p>
<p>0AA5: call_function 0x589650 num_params 0 pop 0</p>
<p>define function CHud__DrawVitalStats&lt;cdecl, 0x589650&gt;()</p>
<h4>CHud::GetRidOfAllHudMessages</h4>
<p>plugin::Call<0x588A50, unsigned char>(arg0);</p>
<p>0AA5: call_function 0x588A50 num_params 1 pop 1 [arg0]</p>
<p>define function CHud__GetRidOfAllHudMessages&lt;cdecl, 0x588A50&gt;(arg0)</p>
<h4>CHud::GetYPosBasedOnHealth</h4>
<p>plugin::CallAndReturn<float, 0x588B60, unsigned char, float, signed>(playerId, pos, offset);</p>
<p>0AA7: call_function_return 0x588B60 num_params 3 pop 3 [playerId] [pos] [offset] func_ret [float]</p>
<p>define function CHud__GetYPosBasedOnHealth&lt;cdecl, 0x588B60&gt;(playerId, pos, offset): float</p>
<h4>CHud::HelpMessageDisplayed</h4>
<p>plugin::CallAndReturn<bool, 0x588B50>();</p>
<p>0AA7: call_function_return 0x588B50 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CHud__HelpMessageDisplayed&lt;cdecl, 0x588B50&gt;(): int</p>
<h4>CHud::Initialise</h4>
<p>plugin::Call<0x5BA850>();</p>
<p>0AA5: call_function 0x5BA850 num_params 0 pop 0</p>
<p>define function CHud__Initialise&lt;cdecl, 0x5BA850&gt;()</p>
<h4>CHud::ReInitialise</h4>
<p>plugin::Call<0x588880>();</p>
<p>0AA5: call_function 0x588880 num_params 0 pop 0</p>
<p>define function CHud__ReInitialise&lt;cdecl, 0x588880&gt;()</p>
<h4>CHud::ResetWastedText</h4>
<p>plugin::Call<0x589070>();</p>
<p>0AA5: call_function 0x589070 num_params 0 pop 0</p>
<p>define function CHud__ResetWastedText&lt;cdecl, 0x589070&gt;()</p>
<h4>CHud::SetBigMessage</h4>
<p>plugin::Call<0x588FC0, char*, unsigned short>(text, style);</p>
<p>0AA5: call_function 0x588FC0 num_params 2 pop 2 [text] [style]</p>
<p>define function CHud__SetBigMessage&lt;cdecl, 0x588FC0&gt;(text, style)</p>
<h4>CHud::SetHelpMessage</h4>
<p>plugin::Call<0x588BE0, char const*, bool, bool, bool>(text, quickMessage, permanent, addToBrief);</p>
<p>0AA5: call_function 0x588BE0 num_params 4 pop 4 [text] [quickMessage] [permanent] [addToBrief]</p>
<p>define function CHud__SetHelpMessage&lt;cdecl, 0x588BE0&gt;(text, quickMessage, permanent, addToBrief)</p>
<h4>CHud::SetHelpMessageStatUpdate</h4>
<p>plugin::Call<0x588D40, unsigned char, unsigned short, float, float>(state, statId, diff, max);</p>
<p>0AA5: call_function 0x588D40 num_params 4 pop 4 [state] [statId] [diff] [max]</p>
<p>define function CHud__SetHelpMessageStatUpdate&lt;cdecl, 0x588D40&gt;(state, statId, diff, max)</p>
<h4>CHud::SetHelpMessageWithNumber</h4>
<p>plugin::Call<0x588E30, char const*, int, bool, bool>(text, number, quickMessage, permanent);</p>
<p>0AA5: call_function 0x588E30 num_params 4 pop 4 [text] [number] [quickMessage] [permanent]</p>
<p>define function CHud__SetHelpMessageWithNumber&lt;cdecl, 0x588E30&gt;(text, number, quickMessage, permanent)</p>
<h4>CHud::SetMessage</h4>
<p>plugin::Call<0x588F60, char*>(text);</p>
<p>0AA5: call_function 0x588F60 num_params 1 pop 1 [text]</p>
<p>define function CHud__SetMessage&lt;cdecl, 0x588F60&gt;(text)</p>
<h4>CHud::SetVehicleName</h4>
<p>plugin::Call<0x588F50, char*>(name);</p>
<p>0AA5: call_function 0x588F50 num_params 1 pop 1 [name]</p>
<p>define function CHud__SetVehicleName&lt;cdecl, 0x588F50&gt;(name)</p>
<h4>CHud::SetZoneName</h4>
<p>plugin::Call<0x588BB0, char*, unsigned char>(name, displayState);</p>
<p>0AA5: call_function 0x588BB0 num_params 2 pop 2 [name] [displayState]</p>
<p>define function CHud__SetZoneName&lt;cdecl, 0x588BB0&gt;(name, displayState)</p>
<h4>CHud::Shutdown</h4>
<p>plugin::Call<0x588850>();</p>
<p>0AA5: call_function 0x588850 num_params 0 pop 0</p>
<p>define function CHud__Shutdown&lt;cdecl, 0x588850&gt;()</p>
<h4>CHud::DrawAmmo</h4>
<p>plugin::Call<0x5893B0, CPed*, int, int, float>(ped, x, y, alpha);</p>
<p>0AA5: call_function 0x5893B0 num_params 4 pop 4 [ped] [x] [y] [alpha]</p>
<p>define function CHud__DrawAmmo&lt;cdecl, 0x5893B0&gt;(ped, x, y, alpha)</p>
<h4>CHud::DrawPlayerInfo</h4>
<p>plugin::Call<0x58EAF0>();</p>
<p>0AA5: call_function 0x58EAF0 num_params 0 pop 0</p>
<p>define function CHud__DrawPlayerInfo&lt;cdecl, 0x58EAF0&gt;()</p>
<h4>CHud::DrawTripSkip</h4>
<p>plugin::Call<0x58A160>();</p>
<p>0AA5: call_function 0x58A160 num_params 0 pop 0</p>
<p>define function CHud__DrawTripSkip&lt;cdecl, 0x58A160&gt;()</p>
<h4>CHud::DrawWanted</h4>
<p>plugin::Call<0x58D9A0>();</p>
<p>0AA5: call_function 0x58D9A0 num_params 0 pop 0</p>
<p>define function CHud__DrawWanted&lt;cdecl, 0x58D9A0&gt;()</p>
<h4>CHud::DrawWeaponIcon</h4>
<p>plugin::Call<0x58D7D0, CPed*, int, int, float>(ped, x, y, alpha);</p>
<p>0AA5: call_function 0x58D7D0 num_params 4 pop 4 [ped] [x] [y] [alpha]</p>
<p>define function CHud__DrawWeaponIcon&lt;cdecl, 0x58D7D0&gt;(ped, x, y, alpha)</p>
<h4>CHud::RenderArmorBar</h4>
<p>plugin::Call<0x5890A0, int, int, int>(playerId, x, y);</p>
<p>0AA5: call_function 0x5890A0 num_params 3 pop 3 [playerId] [x] [y]</p>
<p>define function CHud__RenderArmorBar&lt;cdecl, 0x5890A0&gt;(playerId, x, y)</p>
<h4>CHud::RenderBreathBar</h4>
<p>plugin::Call<0x589190, int, int, int>(playerId, x, y);</p>
<p>0AA5: call_function 0x589190 num_params 3 pop 3 [playerId] [x] [y]</p>
<p>define function CHud__RenderBreathBar&lt;cdecl, 0x589190&gt;(playerId, x, y)</p>
<h4>CHud::RenderHealthBar</h4>
<p>plugin::Call<0x589270, int, int, int>(playerId, x, y);</p>
<p>0AA5: call_function 0x589270 num_params 3 pop 3 [playerId] [x] [y]</p>
<p>define function CHud__RenderHealthBar&lt;cdecl, 0x589270&gt;(playerId, x, y)</p><h3 id="plugin_sagame_saciplstorecpp">plugin_sa\game_sa\CIplStore.cpp</h3><h4>CIplStore::AddIplSlot</h4>
<p>plugin::CallAndReturn<int, 0x405AC0, char const*>(name);</p>
<p>0AA7: call_function_return 0x405AC0 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CIplStore__AddIplSlot&lt;cdecl, 0x405AC0&gt;(name): int</p>
<h4>CIplStore::AddIplsNeededAtPosn</h4>
<p>plugin::Call<0x4045B0, CVector const&>(posn);</p>
<p>0AA5: call_function 0x4045B0 num_params 1 pop 1 [posn]</p>
<p>define function CIplStore__AddIplsNeededAtPosn&lt;cdecl, 0x4045B0&gt;(posn)</p>
<h4>CIplStore::ClearIplsNeededAtPosn</h4>
<p>plugin::Call<0x4045E0>();</p>
<p>0AA5: call_function 0x4045E0 num_params 0 pop 0</p>
<p>define function CIplStore__ClearIplsNeededAtPosn&lt;cdecl, 0x4045E0&gt;()</p>
<h4>CIplStore::EnableDynamicStreaming</h4>
<p>plugin::Call<0x404D30, int, bool>(iplSlotIndex, enable);</p>
<p>0AA5: call_function 0x404D30 num_params 2 pop 2 [iplSlotIndex] [enable]</p>
<p>define function CIplStore__EnableDynamicStreaming&lt;cdecl, 0x404D30&gt;(iplSlotIndex, enable)</p>
<h4>CIplStore::EnsureIplsAreInMemory</h4>
<p>plugin::Call<0x4053F0, CVector const&>(posn);</p>
<p>0AA5: call_function 0x4053F0 num_params 1 pop 1 [posn]</p>
<p>define function CIplStore__EnsureIplsAreInMemory&lt;cdecl, 0x4053F0&gt;(posn)</p>
<h4>CIplStore::FindIplSlot</h4>
<p>plugin::CallAndReturn<int, 0x404AC0, char const*>(name);</p>
<p>0AA7: call_function_return 0x404AC0 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CIplStore__FindIplSlot&lt;cdecl, 0x404AC0&gt;(name): int</p>
<h4>CIplStore::GetBoundingBox</h4>
<p>plugin::CallAndReturn<CRect*, 0x404C70, int>(iplSlotIndex);</p>
<p>0AA7: call_function_return 0x404C70 num_params 1 pop 1 [iplSlotIndex] func_ret [CRect*]</p>
<p>define function CIplStore__GetBoundingBox&lt;cdecl, 0x404C70&gt;(iplSlotIndex): int</p>
<h4>CIplStore::GetIplEntityIndexArray</h4>
<p>plugin::CallAndReturn<int*, 0x4047B0, int>(arrayIndex);</p>
<p>0AA7: call_function_return 0x4047B0 num_params 1 pop 1 [arrayIndex] func_ret [int*]</p>
<p>define function CIplStore__GetIplEntityIndexArray&lt;cdecl, 0x4047B0&gt;(arrayIndex): int</p>
<h4>CIplStore::GetIplName</h4>
<p>plugin::CallAndReturn<char*, 0x404A60, int>(iplSlotIndex);</p>
<p>0AA7: call_function_return 0x404A60 num_params 1 pop 1 [iplSlotIndex] func_ret [char*]</p>
<p>define function CIplStore__GetIplName&lt;cdecl, 0x404A60&gt;(iplSlotIndex): int</p>
<h4>CIplStore::GetNewIplEntityIndexArray</h4>
<p>plugin::CallAndReturn<int, 0x404780, int>(entitiesCount);</p>
<p>0AA7: call_function_return 0x404780 num_params 1 pop 1 [entitiesCount] func_ret [int]</p>
<p>define function CIplStore__GetNewIplEntityIndexArray&lt;cdecl, 0x404780&gt;(entitiesCount): int</p>
<h4>CIplStore::HaveIplsLoaded</h4>
<p>plugin::CallAndReturn<bool, 0x405600, CVector const&, int>(coords, playerNumber);</p>
<p>0AA7: call_function_return 0x405600 num_params 2 pop 2 [coords] [playerNumber] func_ret [bool]</p>
<p>define function CIplStore__HaveIplsLoaded&lt;cdecl, 0x405600&gt;(coords, playerNumber): int</p>
<h4>CIplStore::IncludeEntity</h4>
<p>plugin::Call<0x404C90, int, CEntity*>(iplSlotIndex, entity);</p>
<p>0AA5: call_function 0x404C90 num_params 2 pop 2 [iplSlotIndex] [entity]</p>
<p>define function CIplStore__IncludeEntity&lt;cdecl, 0x404C90&gt;(iplSlotIndex, entity)</p>
<h4>CIplStore::Initialise</h4>
<p>plugin::Call<0x405EC0>();</p>
<p>0AA5: call_function 0x405EC0 num_params 0 pop 0</p>
<p>define function CIplStore__Initialise&lt;cdecl, 0x405EC0&gt;()</p>
<h4>CIplStore::Load</h4>
<p>plugin::CallAndReturn<bool, 0x5D54A0>();</p>
<p>0AA7: call_function_return 0x5D54A0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CIplStore__Load&lt;cdecl, 0x5D54A0&gt;(): int</p>
<h4>CIplStore::LoadAllRemainingIpls</h4>
<p>plugin::Call<0x405780>();</p>
<p>0AA5: call_function 0x405780 num_params 0 pop 0</p>
<p>define function CIplStore__LoadAllRemainingIpls&lt;cdecl, 0x405780&gt;()</p>
<h4>CIplStore::LoadIpl</h4>
<p>plugin::CallAndReturn<bool, 0x406080, int, unsigned char*, int>(iplSlotIndex, data, dataSize);</p>
<p>0AA7: call_function_return 0x406080 num_params 3 pop 3 [iplSlotIndex] [data] [dataSize] func_ret [bool]</p>
<p>define function CIplStore__LoadIpl&lt;cdecl, 0x406080&gt;(iplSlotIndex, data, dataSize): int</p>
<h4>CIplStore::LoadIplBoundingBox</h4>
<p>plugin::CallAndReturn<bool, 0x405C00, int, unsigned char*, int>(iplSlotIndex, data, dataSize);</p>
<p>0AA7: call_function_return 0x405C00 num_params 3 pop 3 [iplSlotIndex] [data] [dataSize] func_ret [bool]</p>
<p>define function CIplStore__LoadIplBoundingBox&lt;cdecl, 0x405C00&gt;(iplSlotIndex, data, dataSize): int</p>
<h4>CIplStore::LoadIpls</h4>
<p>plugin::Call<0x405170, CVector, bool>(posn, arg1);</p>
<p>0AA5: call_function 0x405170 num_params 2 pop 2 [posn] [arg1]</p>
<p>define function CIplStore__LoadIpls&lt;cdecl, 0x405170&gt;(posn, arg1)</p>
<h4>CIplStore::RemoveAllIpls</h4>
<p>plugin::Call<0x405720>();</p>
<p>0AA5: call_function 0x405720 num_params 0 pop 0</p>
<p>define function CIplStore__RemoveAllIpls&lt;cdecl, 0x405720&gt;()</p>
<h4>CIplStore::RemoveIpl</h4>
<p>plugin::Call<0x404B20, int>(iplSlotIndex);</p>
<p>0AA5: call_function 0x404B20 num_params 1 pop 1 [iplSlotIndex]</p>
<p>define function CIplStore__RemoveIpl&lt;cdecl, 0x404B20&gt;(iplSlotIndex)</p>
<h4>CIplStore::RemoveIplAndIgnore</h4>
<p>plugin::Call<0x405890, int>(iplSlotIndex);</p>
<p>0AA5: call_function 0x405890 num_params 1 pop 1 [iplSlotIndex]</p>
<p>define function CIplStore__RemoveIplAndIgnore&lt;cdecl, 0x405890&gt;(iplSlotIndex)</p>
<h4>CIplStore::RemoveIplSlot</h4>
<p>plugin::Call<0x405B60, int>(iplSlotIndex);</p>
<p>0AA5: call_function 0x405B60 num_params 1 pop 1 [iplSlotIndex]</p>
<p>define function CIplStore__RemoveIplSlot&lt;cdecl, 0x405B60&gt;(iplSlotIndex)</p>
<h4>CIplStore::RemoveIplWhenFarAway</h4>
<p>plugin::Call<0x4058D0, int>(iplSlotIndex);</p>
<p>0AA5: call_function 0x4058D0 num_params 1 pop 1 [iplSlotIndex]</p>
<p>define function CIplStore__RemoveIplWhenFarAway&lt;cdecl, 0x4058D0&gt;(iplSlotIndex)</p>
<h4>CIplStore::RemoveRelatedIpls</h4>
<p>plugin::Call<0x405110, int>(entityArraysIndex);</p>
<p>0AA5: call_function 0x405110 num_params 1 pop 1 [entityArraysIndex]</p>
<p>define function CIplStore__RemoveRelatedIpls&lt;cdecl, 0x405110&gt;(entityArraysIndex)</p>
<h4>CIplStore::RequestIplAndIgnore</h4>
<p>plugin::Call<0x405850, int>(iplSlotIndex);</p>
<p>0AA5: call_function 0x405850 num_params 1 pop 1 [iplSlotIndex]</p>
<p>define function CIplStore__RequestIplAndIgnore&lt;cdecl, 0x405850&gt;(iplSlotIndex)</p>
<h4>CIplStore::RequestIpls</h4>
<p>plugin::Call<0x405520, CVector const&, int>(posn, playerNumber);</p>
<p>0AA5: call_function 0x405520 num_params 2 pop 2 [posn] [playerNumber]</p>
<p>define function CIplStore__RequestIpls&lt;cdecl, 0x405520&gt;(posn, playerNumber)</p>
<h4>CIplStore::Save</h4>
<p>plugin::CallAndReturn<bool, 0x5D5420>();</p>
<p>0AA7: call_function_return 0x5D5420 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CIplStore__Save&lt;cdecl, 0x5D5420&gt;(): int</p>
<h4>CIplStore::SetIplsRequired</h4>
<p>plugin::Call<0x404700, CVector const&, int>(posn, playerNumber);</p>
<p>0AA5: call_function 0x404700 num_params 2 pop 2 [posn] [playerNumber]</p>
<p>define function CIplStore__SetIplsRequired&lt;cdecl, 0x404700&gt;(posn, playerNumber)</p>
<h4>CIplStore::SetIsInterior</h4>
<p>plugin::Call<0x404A90, int, bool>(iplSlotIndex, isInterior);</p>
<p>0AA5: call_function 0x404A90 num_params 2 pop 2 [iplSlotIndex] [isInterior]</p>
<p>define function CIplStore__SetIsInterior&lt;cdecl, 0x404A90&gt;(iplSlotIndex, isInterior)</p>
<h4>CIplStore::SetupRelatedIpls</h4>
<p>plugin::CallAndReturn<int, 0x404DE0, char const<em>, int, CEntity</em>*>(iplName, entityArraysIndex, instances);</p>
<p>0AA7: call_function_return 0x404DE0 num_params 3 pop 3 [iplName] [entityArraysIndex] [instances] func_ret [int]</p>
<p>define function CIplStore__SetupRelatedIpls&lt;cdecl, 0x404DE0&gt;(iplName, entityArraysIndex, instances): int</p>
<h4>CIplStore::Shutdown</h4>
<p>plugin::Call<0x405FA0>();</p>
<p>0AA5: call_function 0x405FA0 num_params 0 pop 0</p>
<p>define function CIplStore__Shutdown&lt;cdecl, 0x405FA0&gt;()</p>
<h4>SetIfInteriorIplIsRequired</h4>
<p>plugin::Call<0x4045F0, CVector2D const&, void*>(posn, data);</p>
<p>0AA5: call_function 0x4045F0 num_params 2 pop 2 [posn] [data]</p>
<p>define function SetIfInteriorIplIsRequired&lt;cdecl, 0x4045F0&gt;(posn, data)</p>
<h4>SetIfIplIsRequired</h4>
<p>plugin::Call<0x404660, CVector2D const&, void*>(posn, data);</p>
<p>0AA5: call_function 0x404660 num_params 2 pop 2 [posn] [data]</p>
<p>define function SetIfIplIsRequired&lt;cdecl, 0x404660&gt;(posn, data)</p>
<h4>SetIfIplIsRequiredReducedBB</h4>
<p>plugin::Call<0x404690, CVector2D const&, void*>(posn, data);</p>
<p>0AA5: call_function 0x404690 num_params 2 pop 2 [posn] [data]</p>
<p>define function SetIfIplIsRequiredReducedBB&lt;cdecl, 0x404690&gt;(posn, data)</p><h3 id="plugin_sagame_sacloadedcargroupcpp">plugin_sa\game_sa\CLoadedCarGroup.cpp</h3><h4>CLoadedCarGroup::SortBasedOnUsage</h4>
<p>plugin::CallMethod<0x611E10, CLoadedCarGroup *>(this);</p>
<p>0AA6: call_method 0x611E10 struct [CLoadedCarGroup] num_params 0 pop 0</p>
<p>define function CLoadedCarGroup__SortBasedOnUsage&lt;thiscall, 0x611E10&gt;()</p>
<h4>CLoadedCarGroup::RemoveMember</h4>
<p>plugin::CallMethodAndReturn<int, 0x611BD0, CLoadedCarGroup *, int>(this, modelindex);</p>
<p>0AA8: call_method_return 0x611BD0 struct [CLoadedCarGroup] num_params 1 pop 0 [modelindex] func_ret [int]</p>
<p>define function CLoadedCarGroup__RemoveMember&lt;thiscall, 0x611BD0&gt;(modelindex): int</p>
<h4>CLoadedCarGroup::PickRandomCar</h4>
<p>plugin::CallMethodAndReturn<int, 0x611C50, CLoadedCarGroup *, bool, bool>(this, arg1, arg2);</p>
<p>0AA8: call_method_return 0x611C50 struct [CLoadedCarGroup] num_params 2 pop 0 [arg1] [arg2] func_ret [int]</p>
<p>define function CLoadedCarGroup__PickRandomCar&lt;thiscall, 0x611C50&gt;(arg1, arg2): int</p>
<h4>CLoadedCarGroup::PickLeastUsedModel</h4>
<p>plugin::CallMethodAndReturn<int, 0x611E90, CLoadedCarGroup *, int>(this, minRefs);</p>
<p>0AA8: call_method_return 0x611E90 struct [CLoadedCarGroup] num_params 1 pop 0 [minRefs] func_ret [int]</p>
<p>define function CLoadedCarGroup__PickLeastUsedModel&lt;thiscall, 0x611E90&gt;(minRefs): int</p>
<h4>CLoadedCarGroup::GetMember</h4>
<p>plugin::CallMethodAndReturn<int, 0x611C20, CLoadedCarGroup *, int>(this, count);</p>
<p>0AA8: call_method_return 0x611C20 struct [CLoadedCarGroup] num_params 1 pop 0 [count] func_ret [int]</p>
<p>define function CLoadedCarGroup__GetMember&lt;thiscall, 0x611C20&gt;(count): int</p>
<h4>CLoadedCarGroup::CountMembers</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x611C30, CLoadedCarGroup *>(this);</p>
<p>0AA8: call_method_return 0x611C30 struct [CLoadedCarGroup] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CLoadedCarGroup__CountMembers&lt;thiscall, 0x611C30&gt;(): int</p>
<h4>CLoadedCarGroup::Clear</h4>
<p>plugin::CallMethod<0x611B90, CLoadedCarGroup *>(this);</p>
<p>0AA6: call_method 0x611B90 struct [CLoadedCarGroup] num_params 0 pop 0</p>
<p>define function CLoadedCarGroup__Clear&lt;thiscall, 0x611B90&gt;()</p>
<h4>CLoadedCarGroup::AddMember</h4>
<p>plugin::CallMethod<0x611BB0, CLoadedCarGroup *, int>(this, member);</p>
<p>0AA6: call_method 0x611BB0 struct [CLoadedCarGroup] num_params 1 pop 0 [member]</p>
<p>define function CLoadedCarGroup__AddMember&lt;thiscall, 0x611BB0&gt;(member)</p><h3 id="plugin_sagame_sacloadingscreencpp">plugin_sa\game_sa\CLoadingScreen.cpp</h3><h4>CLoadingScreen::Shutdown</h4>
<p>plugin::Call<0x58FF10>();</p>
<p>0AA5: call_function 0x58FF10 num_params 0 pop 0</p>
<p>define function CLoadingScreen__Shutdown&lt;cdecl, 0x58FF10&gt;()</p>
<h4>CLoadingScreen::RenderSplash</h4>
<p>plugin::Call<0x58FF60>();</p>
<p>0AA5: call_function 0x58FF60 num_params 0 pop 0</p>
<p>define function CLoadingScreen__RenderSplash&lt;cdecl, 0x58FF60&gt;()</p>
<h4>CLoadingScreen::LoadSplashes</h4>
<p>plugin::Call<0x5900B0, unsigned char, unsigned char>(bStarting, bNvidia);</p>
<p>0AA5: call_function 0x5900B0 num_params 2 pop 2 [bStarting] [bNvidia]</p>
<p>define function CLoadingScreen__LoadSplashes&lt;cdecl, 0x5900B0&gt;(bStarting, bNvidia)</p>
<h4>CLoadingScreen::DisplayMessage</h4>
<p>plugin::Call<0x590220, char const*>(message);</p>
<p>0AA5: call_function 0x590220 num_params 1 pop 1 [message]</p>
<p>define function CLoadingScreen__DisplayMessage&lt;cdecl, 0x590220&gt;(message)</p>
<h4>CLoadingScreen::SetLoadingBarMsg</h4>
<p>plugin::Call<0x590240, char const<em>, char const</em>>(msg1, msg2);</p>
<p>0AA5: call_function 0x590240 num_params 2 pop 2 [msg1] [msg2]</p>
<p>define function CLoadingScreen__SetLoadingBarMsg&lt;cdecl, 0x590240&gt;(msg1, msg2)</p>
<h4>CLoadingScreen::GetClockTime</h4>
<p>plugin::CallAndReturn<double, 0x590280, bool>(bIgnorePauseTime);</p>
<p>0AA7: call_function_return 0x590280 num_params 1 pop 1 [bIgnorePauseTime] func_ret [double]</p>
<p>define function CLoadingScreen__GetClockTime&lt;cdecl, 0x590280&gt;(bIgnorePauseTime): int</p>
<h4>CLoadingScreen::Init</h4>
<p>plugin::Call<0x5902B0, bool, bool>(unusedflag, bLoaded);</p>
<p>0AA5: call_function 0x5902B0 num_params 2 pop 2 [unusedflag] [bLoaded]</p>
<p>define function CLoadingScreen__Init&lt;cdecl, 0x5902B0&gt;(unusedflag, bLoaded)</p>
<h4>CLoadingScreen::Continue</h4>
<p>plugin::Call<0x590320>();</p>
<p>0AA5: call_function 0x590320 num_params 0 pop 0</p>
<p>define function CLoadingScreen__Continue&lt;cdecl, 0x590320&gt;()</p>
<h4>CLoadingScreen::RenderLoadingBar</h4>
<p>plugin::Call<0x590370>();</p>
<p>0AA5: call_function 0x590370 num_params 0 pop 0</p>
<p>define function CLoadingScreen__RenderLoadingBar&lt;cdecl, 0x590370&gt;()</p>
<h4>CLoadingScreen::DisplayNextSplash</h4>
<p>plugin::Call<0x5904D0>();</p>
<p>0AA5: call_function 0x5904D0 num_params 0 pop 0</p>
<p>define function CLoadingScreen__DisplayNextSplash&lt;cdecl, 0x5904D0&gt;()</p>
<h4>CLoadingScreen::StartFading</h4>
<p>plugin::Call<0x590530>();</p>
<p>0AA5: call_function 0x590530 num_params 0 pop 0</p>
<p>define function CLoadingScreen__StartFading&lt;cdecl, 0x590530&gt;()</p>
<h4>CLoadingScreen::DisplayPCScreen</h4>
<p>plugin::Call<0x590570>();</p>
<p>0AA5: call_function 0x590570 num_params 0 pop 0</p>
<p>define function CLoadingScreen__DisplayPCScreen&lt;cdecl, 0x590570&gt;()</p>
<h4>CLoadingScreen::Update</h4>
<p>plugin::Call<0x5905E0>();</p>
<p>0AA5: call_function 0x5905E0 num_params 0 pop 0</p>
<p>define function CLoadingScreen__Update&lt;cdecl, 0x5905E0&gt;()</p>
<h4>CLoadingScreen::DoPCTitleFadeOut</h4>
<p>plugin::Call<0x590990>();</p>
<p>0AA5: call_function 0x590990 num_params 0 pop 0</p>
<p>define function CLoadingScreen__DoPCTitleFadeOut&lt;cdecl, 0x590990&gt;()</p>
<h4>CLoadingScreen::DoPCTitleFadeIn</h4>
<p>plugin::Call<0x590860>();</p>
<p>0AA5: call_function 0x590860 num_params 0 pop 0</p>
<p>define function CLoadingScreen__DoPCTitleFadeIn&lt;cdecl, 0x590860&gt;()</p>
<h4>CLoadingScreen::DoPCScreenChange</h4>
<p>plugin::Call<0x590AC0, unsigned int>(bFinish);</p>
<p>0AA5: call_function 0x590AC0 num_params 1 pop 1 [bFinish]</p>
<p>define function CLoadingScreen__DoPCScreenChange&lt;cdecl, 0x590AC0&gt;(bFinish)</p>
<h4>CLoadingScreen::NewChunkLoaded</h4>
<p>plugin::Call<0x590D00>();</p>
<p>0AA5: call_function 0x590D00 num_params 0 pop 0</p>
<p>define function CLoadingScreen__NewChunkLoaded&lt;cdecl, 0x590D00&gt;()</p><h3 id="plugin_sagame_sacmatrixcpp">plugin_sa\game_sa\CMatrix.cpp</h3><h4>CMatrix::Scale</h4>
<p>plugin::CallMethod<0x459350, CMatrix *, float>(this, scale);</p>
<p>0AA6: call_method 0x459350 struct [CMatrix] num_params 1 pop 0 [scale]</p>
<p>define function CMatrix__Scale&lt;thiscall, 0x459350&gt;(scale)</p>
<h4>CMatrix::Scale</h4>
<p>plugin::CallMethod<0x459350, CMatrix *, float, float, float>(this, x, y, z);</p>
<p>0AA6: call_method 0x459350 struct [CMatrix] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CMatrix__Scale&lt;thiscall, 0x459350&gt;(x, y, z)</p><h3 id="plugin_sagame_sacmatrixlinkcpp">plugin_sa\game_sa\CMatrixLink.cpp</h3><h4>CMatrixLink::Insert</h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *, CMatrixLink *>(gaddrof(CMatrixLink::Insert), this, where);</p>
<p>0AA6: call_method 0x54E8F0 struct [CMatrixLink] num_params 1 pop 0 [where]</p>
<p>define function CMatrixLink__Insert&lt;thiscall, 0x54E8F0&gt;(where)</p>
<h4>CMatrixLink::Remove</h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(gaddrof(CMatrixLink::Remove), this);</p>
<p>0AA6: call_method 0x54E910 struct [CMatrixLink] num_params 0 pop 0</p>
<p>define function CMatrixLink__Remove&lt;thiscall, 0x54E910&gt;()</p><h3 id="plugin_sagame_sacmenumanagercpp">plugin_sa\game_sa\CMenuManager.cpp</h3><h4>CMenuManager::CMenuManager</h4>
<p>plugin::CallMethod<0x574350, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x574350 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__CMenuManager&lt;thiscall, 0x574350&gt;()</p>
<h4>CMenuManager::~CMenuManager</h4>
<p>plugin::CallMethod<0x579440, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x579440 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__~CMenuManager&lt;thiscall, 0x579440&gt;()</p>
<h4>CMenuManager::AdditionalOptionInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x5773D0, CMenuManager*, char, char>(this, input, enter);</p>
<p>0AA8: call_method_return 0x5773D0 struct [CMenuManager] num_params 2 pop 0 [input] [enter] func_ret [char]</p>
<p>define function CMenuManager__AdditionalOptionInput&lt;thiscall, 0x5773D0&gt;(input, enter): int</p>
<h4>CMenuManager::CentreMousePointer</h4>
<p>plugin::CallMethod<0x57C520, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57C520 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__CentreMousePointer&lt;thiscall, 0x57C520&gt;()</p>
<h4>CMenuManager::CheckCodesForControls</h4>
<p>plugin::CallMethodAndReturn<char, 0x57DB20, CMenuManager*, int>(this, code);</p>
<p>0AA8: call_method_return 0x57DB20 struct [CMenuManager] num_params 1 pop 0 [code] func_ret [char]</p>
<p>define function CMenuManager__CheckCodesForControls&lt;thiscall, 0x57DB20&gt;(code): int</p>
<h4>CMenuManager::CheckFrontEndDownInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x5738B0, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x5738B0 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__CheckFrontEndDownInput&lt;thiscall, 0x5738B0&gt;(): int</p>
<h4>CMenuManager::CheckFrontEndLeftInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x573920, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x573920 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__CheckFrontEndLeftInput&lt;thiscall, 0x573920&gt;(): int</p>
<h4>CMenuManager::CheckFrontEndRightInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x573990, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x573990 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__CheckFrontEndRightInput&lt;thiscall, 0x573990&gt;(): int</p>
<h4>CMenuManager::CheckFrontEndUpInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x573840, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x573840 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__CheckFrontEndUpInput&lt;thiscall, 0x573840&gt;(): int</p>
<h4>CMenuManager::CheckHover</h4>
<p>plugin::CallMethodAndReturn<bool, 0x57C4F0, CMenuManager*>(this, x1, x2, y1, y2);</p>
<p>0AA8: call_method_return 0x57C4F0 struct [CMenuManager] num_params 4 pop 0 [x1] [x2] [y1] [y2] func_ret [bool]</p>
<p>define function CMenuManager__CheckHover&lt;thiscall, 0x57C4F0&gt;(x1, x2, y1, y2): int</p>
<h4>CMenuManager::CheckMissionPackValidMenu</h4>
<p>plugin::CallMethodAndReturn<char, 0x57D720, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x57D720 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__CheckMissionPackValidMenu&lt;thiscall, 0x57D720&gt;(): int</p>
<h4>CMenuManager::CheckRedefineControlInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x57E4D0, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x57E4D0 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__CheckRedefineControlInput&lt;thiscall, 0x57E4D0&gt;(): int</p>
<h4>CMenuManager::CheckSliderMovement</h4>
<p>plugin::CallMethod<0x57E4D0, CMenuManager*>(this, input);</p>
<p>0AA6: call_method 0x57E4D0 struct [CMenuManager] num_params 1 pop 0 [input]</p>
<p>define function CMenuManager__CheckSliderMovement&lt;thiscall, 0x57E4D0&gt;(input)</p>
<h4>CMenuManager::DisplayHelperText</h4>
<p>plugin::CallMethod<0x57E4D0, CMenuManager*>(this, text);</p>
<p>0AA6: call_method 0x57E4D0 struct [CMenuManager] num_params 1 pop 0 [text]</p>
<p>define function CMenuManager__DisplayHelperText&lt;thiscall, 0x57E4D0&gt;(text)</p>
<h4>CMenuManager::DisplaySlider</h4>
<p>plugin::CallMethodAndReturn<int, 0x576860, CMenuManager*>(this, posX, posY, beginHeight, endHeight, distBetweenRects, filledAmount, colour);</p>
<p>0AA8: call_method_return 0x576860 struct [CMenuManager] num_params 7 pop 0 [posX] [posY] [beginHeight] [endHeight] [distBetweenRects] [filledAmount] [colour] func_ret [int]</p>
<p>define function CMenuManager__DisplaySlider&lt;thiscall, 0x576860&gt;(posX, posY, beginHeight, endHeight, distBetweenRects, filledAmount, colour): int</p>
<h4>CMenuManager::DoSettingsBeforeStartingAGame</h4>
<p>plugin::CallMethodAndReturn<signed int, 0x573330, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x573330 struct [CMenuManager] num_params 0 pop 0 func_ret [signed int]</p>
<p>define function CMenuManager__DoSettingsBeforeStartingAGame&lt;thiscall, 0x573330&gt;(): int</p>
<h4>CMenuManager::DrawBackground</h4>
<p>plugin::CallMethodAndReturn<char, 0x57B750, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x57B750 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__DrawBackground&lt;thiscall, 0x57B750&gt;(): int</p>
<h4>CMenuManager::DrawControllerScreenExtraText</h4>
<p>plugin::CallMethodAndReturn<char, 0x57D8D0, CMenuManager*>(this, unk);</p>
<p>0AA8: call_method_return 0x57D8D0 struct [CMenuManager] num_params 1 pop 0 [unk] func_ret [char]</p>
<p>define function CMenuManager__DrawControllerScreenExtraText&lt;thiscall, 0x57D8D0&gt;(unk): int</p>
<h4>CMenuManager::DrawControllerSetupScreen</h4>
<p>plugin::CallMethodAndReturn<char, 0x57F300, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x57F300 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__DrawControllerSetupScreen&lt;thiscall, 0x57F300&gt;(): int</p>
<h4>CMenuManager::DrawFrontEnd</h4>
<p>plugin::CallMethod<0x57C290, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57C290 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__DrawFrontEnd&lt;thiscall, 0x57C290&gt;()</p>
<h4>CMenuManager::DrawQuitGameScreen</h4>
<p>plugin::CallMethod<0x57D860, CMenuManager*>(this, unused);</p>
<p>0AA6: call_method 0x57D860 struct [CMenuManager] num_params 1 pop 0 [unused]</p>
<p>define function CMenuManager__DrawQuitGameScreen&lt;thiscall, 0x57D860&gt;(unused)</p>
<h4>CMenuManager::DrawStandardMenu</h4>
<p>plugin::CallMethod<0x5794A0, CMenuManager*>(this, header);</p>
<p>0AA6: call_method 0x5794A0 struct [CMenuManager] num_params 1 pop 0 [header]</p>
<p>define function CMenuManager__DrawStandardMenu&lt;thiscall, 0x5794A0&gt;(header)</p>
<h4>CMenuManager::DrawWindow</h4>
<p>plugin::CallMethod<0x573EE0, CMenuManager*>(this, coords, pKey, nColour, backColor, Unused, bBackground);</p>
<p>0AA6: call_method 0x573EE0 struct [CMenuManager] num_params 6 pop 0 [coords] [pKey] [nColour] [backColor] [Unused] [bBackground]</p>
<p>define function CMenuManager__DrawWindow&lt;thiscall, 0x573EE0&gt;(coords, pKey, nColour, backColor, Unused, bBackground)</p>
<h4>CMenuManager::DrawWindowedText</h4>
<p>plugin::CallMethod<0x578F50, CMenuManager*>(this, x1, y1, x2, y2, gxt, align);</p>
<p>0AA6: call_method 0x578F50 struct [CMenuManager] num_params 6 pop 0 [x1] [y1] [x2] [y2] [gxt] [align]</p>
<p>define function CMenuManager__DrawWindowedText&lt;thiscall, 0x578F50&gt;(x1, y1, x2, y2, gxt, align)</p>
<h4>CMenuManager::GetNumberOfMenuOptions</h4>
<p>plugin::CallMethodAndReturn<unsigned char, 0x573E70, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x573E70 struct [CMenuManager] num_params 0 pop 0 func_ret [unsigned char]</p>
<p>define function CMenuManager__GetNumberOfMenuOptions&lt;thiscall, 0x573E70&gt;(): int</p>
<h4>CMenuManager::HasLanguageChanged</h4>
<p>plugin::CallMethodAndReturn<bool, 0x573CD0, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x573CD0 struct [CMenuManager] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CMenuManager__HasLanguageChanged&lt;thiscall, 0x573CD0&gt;(): int</p>
<h4>CMenuManager::Initialise</h4>
<p>plugin::CallMethod<0x5744D0, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x5744D0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__Initialise&lt;thiscall, 0x5744D0&gt;()</p>
<h4>CMenuManager::InitialiseChangedLanguageSettings</h4>
<p>plugin::CallMethod<0x573260, CMenuManager*>(this, reInitControls);</p>
<p>0AA6: call_method 0x573260 struct [CMenuManager] num_params 1 pop 0 [reInitControls]</p>
<p>define function CMenuManager__InitialiseChangedLanguageSettings&lt;thiscall, 0x573260&gt;(reInitControls)</p>
<h4>CMenuManager::JumpToGenericMessageScreen</h4>
<p>plugin::CallMethodAndReturn<int, 0x576AE0, CMenuManager*>(this, screen, header, action);</p>
<p>0AA8: call_method_return 0x576AE0 struct [CMenuManager] num_params 3 pop 0 [screen] [header] [action] func_ret [int]</p>
<p>define function CMenuManager__JumpToGenericMessageScreen&lt;thiscall, 0x576AE0&gt;(screen, header, action): int</p>
<h4>CMenuManager::LoadAllTextures</h4>
<p>plugin::CallMethod<0x572EC0, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x572EC0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__LoadAllTextures&lt;thiscall, 0x572EC0&gt;()</p>
<h4>CMenuManager::LoadSettings</h4>
<p>plugin::CallMethod<0x57C8F0, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57C8F0 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__LoadSettings&lt;thiscall, 0x57C8F0&gt;()</p>
<h4>CMenuManager::MessageScreen</h4>
<p>plugin::CallMethod<0x579330, CMenuManager*>(this, message, col, frame);</p>
<p>0AA6: call_method 0x579330 struct [CMenuManager] num_params 3 pop 0 [message] [col] [frame]</p>
<p>define function CMenuManager__MessageScreen&lt;thiscall, 0x579330&gt;(message, col, frame)</p>
<h4>CMenuManager::PrintBriefs</h4>
<p>plugin::CallMethodAndReturn<float, 0x576320, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x576320 struct [CMenuManager] num_params 0 pop 0 func_ret [float]</p>
<p>define function CMenuManager__PrintBriefs&lt;thiscall, 0x576320&gt;(): float</p>
<h4>CMenuManager::PrintMap</h4>
<p>plugin::CallMethodAndReturn<char, 0x575130, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x575130 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__PrintMap&lt;thiscall, 0x575130&gt;(): int</p>
<h4>CMenuManager::PrintRadioStationList</h4>
<p>plugin::CallMethodAndReturn<char, 0x5746F0, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x5746F0 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__PrintRadioStationList&lt;thiscall, 0x5746F0&gt;(): int</p>
<h4>CMenuManager::PrintStats</h4>
<p>plugin::CallMethodAndReturn<char, 0x574900, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x574900 struct [CMenuManager] num_params 0 pop 0 func_ret [char]</p>
<p>define function CMenuManager__PrintStats&lt;thiscall, 0x574900&gt;(): int</p>
<h4>CMenuManager::Process</h4>
<p>plugin::CallMethodAndReturn<int, 0x57B440, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x57B440 struct [CMenuManager] num_params 0 pop 0 func_ret [int]</p>
<p>define function CMenuManager__Process&lt;thiscall, 0x57B440&gt;(): int</p>
<h4>CMenuManager::ProcessFileActions</h4>
<p>plugin::CallMethod<0x578D60, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x578D60 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ProcessFileActions&lt;thiscall, 0x578D60&gt;()</p>
<h4>CMenuManager::ProcessMenuOptions</h4>
<p>plugin::CallMethod<0x576FE0, CMenuManager*>(this, input, exit, enter);</p>
<p>0AA6: call_method 0x576FE0 struct [CMenuManager] num_params 3 pop 0 [input] [exit] [enter]</p>
<p>define function CMenuManager__ProcessMenuOptions&lt;thiscall, 0x576FE0&gt;(input, exit, enter)</p>
<h4>CMenuManager::ProcessMissionPackNewGame</h4>
<p>plugin::CallMethod<0x57D520, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57D520 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ProcessMissionPackNewGame&lt;thiscall, 0x57D520&gt;()</p>
<h4>CMenuManager::ProcessPCMenuOptions</h4>
<p>plugin::CallMethodAndReturn<char, 0x57CD50, CMenuManager*>(this, input, enter);</p>
<p>0AA8: call_method_return 0x57CD50 struct [CMenuManager] num_params 2 pop 0 [input] [enter] func_ret [char]</p>
<p>define function CMenuManager__ProcessPCMenuOptions&lt;thiscall, 0x57CD50&gt;(input, enter): int</p>
<h4>CMenuManager::ProcessStreaming</h4>
<p>plugin::CallMethod<0x573CF0, CMenuManager*>(this, all);</p>
<p>0AA6: call_method 0x573CF0 struct [CMenuManager] num_params 1 pop 0 [all]</p>
<p>define function CMenuManager__ProcessStreaming&lt;thiscall, 0x573CF0&gt;(all)</p>
<h4>CMenuManager::ProcessUserInput</h4>
<p>plugin::CallMethod<0x57B480, CMenuManager*>(this, down, up, enter, exit, input);</p>
<p>0AA6: call_method 0x57B480 struct [CMenuManager] num_params 5 pop 0 [down] [up] [enter] [exit] [input]</p>
<p>define function CMenuManager__ProcessUserInput&lt;thiscall, 0x57B480&gt;(down, up, enter, exit, input)</p>
<h4>CMenuManager::RedefineScreenUserInput</h4>
<p>plugin::CallMethodAndReturn<char, 0x57EF50, CMenuManager*>(this, enter, exit);</p>
<p>0AA8: call_method_return 0x57EF50 struct [CMenuManager] num_params 2 pop 0 [enter] [exit] func_ret [char]</p>
<p>define function CMenuManager__RedefineScreenUserInput&lt;thiscall, 0x57EF50&gt;(enter, exit): int</p>
<h4>CMenuManager::ResetHelperText</h4>
<p>plugin::CallMethod<0x57CD30, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57CD30 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__ResetHelperText&lt;thiscall, 0x57CD30&gt;()</p>
<h4>CMenuManager::SaveLoadFileError_SetUpErrorScreen</h4>
<p>plugin::CallMethod<0x57C490, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57C490 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SaveLoadFileError_SetUpErrorScreen&lt;thiscall, 0x57C490&gt;()</p>
<h4>CMenuManager::SaveSettings</h4>
<p>plugin::CallMethod<0x57C660, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57C660 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SaveSettings&lt;thiscall, 0x57C660&gt;()</p>
<h4>CMenuManager::SaveStatsToFile</h4>
<p>plugin::CallMethodAndReturn<int, 0x57DDE0, CMenuManager*>(this);</p>
<p>0AA8: call_method_return 0x57DDE0 struct [CMenuManager] num_params 0 pop 0 func_ret [int]</p>
<p>define function CMenuManager__SaveStatsToFile&lt;thiscall, 0x57DDE0&gt;(): int</p>
<h4>CMenuManager::ScrollRadioStations</h4>
<p>plugin::CallMethod<0x573A00, CMenuManager*>(this, input);</p>
<p>0AA6: call_method 0x573A00 struct [CMenuManager] num_params 1 pop 0 [input]</p>
<p>define function CMenuManager__ScrollRadioStations&lt;thiscall, 0x573A00&gt;(input)</p>
<h4>CMenuManager::SetDefaultPreferences</h4>
<p>plugin::CallMethodAndReturn<char, 0x573AE0, CMenuManager*>(this, page);</p>
<p>0AA8: call_method_return 0x573AE0 struct [CMenuManager] num_params 1 pop 0 [page] func_ret [char]</p>
<p>define function CMenuManager__SetDefaultPreferences&lt;thiscall, 0x573AE0&gt;(page): int</p>
<h4>CMenuManager::SetFrontEndRenderStates</h4>
<p>plugin::CallMethod<0x573A60, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x573A60 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SetFrontEndRenderStates&lt;thiscall, 0x573A60&gt;()</p>
<h4>CMenuManager::SetHelperText</h4>
<p>plugin::CallMethodAndReturn<int, 0x57CD10, CMenuManager*>(this, index);</p>
<p>0AA8: call_method_return 0x57CD10 struct [CMenuManager] num_params 1 pop 0 [index] func_ret [int]</p>
<p>define function CMenuManager__SetHelperText&lt;thiscall, 0x57CD10&gt;(index): int</p>
<h4>CMenuManager::SmallMessageScreen</h4>
<p>plugin::CallMethod<0x574010, CMenuManager*>(this, message);</p>
<p>0AA6: call_method 0x574010 struct [CMenuManager] num_params 1 pop 0 [message]</p>
<p>define function CMenuManager__SmallMessageScreen&lt;thiscall, 0x574010&gt;(message)</p>
<h4>CMenuManager::StretchX</h4>
<p>plugin::CallMethodAndReturn<float, 0x5733E0, CMenuManager*>(this, x);</p>
<p>0AA8: call_method_return 0x5733E0 struct [CMenuManager] num_params 1 pop 0 [x] func_ret [float]</p>
<p>define function CMenuManager__StretchX&lt;thiscall, 0x5733E0&gt;(x): float</p>
<h4>CMenuManager::StretchY</h4>
<p>plugin::CallMethodAndReturn<float, 0x573410, CMenuManager*>(this, y);</p>
<p>0AA8: call_method_return 0x573410 struct [CMenuManager] num_params 1 pop 0 [y] func_ret [float]</p>
<p>define function CMenuManager__StretchY&lt;thiscall, 0x573410&gt;(y): float</p>
<h4>CMenuManager::SwapTexturesRound</h4>
<p>plugin::CallMethod<0x5730A0, CMenuManager*>(this, force);</p>
<p>0AA6: call_method 0x5730A0 struct [CMenuManager] num_params 1 pop 0 [force]</p>
<p>define function CMenuManager__SwapTexturesRound&lt;thiscall, 0x5730A0&gt;(force)</p>
<h4>CMenuManager::SwitchMenuOnAndOff</h4>
<p>plugin::CallMethod<0x576B70, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x576B70 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SwitchMenuOnAndOff&lt;thiscall, 0x576B70&gt;()</p>
<h4>CMenuManager::SwitchToNewScreen</h4>
<p>plugin::CallMethodAndReturn<char, 0x573680, CMenuManager*>(this, page);</p>
<p>0AA8: call_method_return 0x573680 struct [CMenuManager] num_params 1 pop 0 [page] func_ret [char]</p>
<p>define function CMenuManager__SwitchToNewScreen&lt;thiscall, 0x573680&gt;(page): int</p>
<h4>CMenuManager::UnloadTextures</h4>
<p>plugin::CallMethod<0x574630, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x574630 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__UnloadTextures&lt;thiscall, 0x574630&gt;()</p>
<h4>CMenuManager::UserInput</h4>
<p>plugin::CallMethod<0x57FD70, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x57FD70 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__UserInput&lt;thiscall, 0x57FD70&gt;()</p><h3 id="plugin_sagame_sacmirrorscpp">plugin_sa\game_sa\CMirrors.cpp</h3><h4>CMirrors::BeforeConstructRenderList</h4>
<p>plugin::Call<0x726DF0>();</p>
<p>0AA5: call_function 0x726DF0 num_params 0 pop 0</p>
<p>define function CMirrors__BeforeConstructRenderList&lt;cdecl, 0x726DF0&gt;()</p>
<h4>CMirrors::BeforeMainRender</h4>
<p>plugin::Call<0x727140>();</p>
<p>0AA5: call_function 0x727140 num_params 0 pop 0</p>
<p>define function CMirrors__BeforeMainRender&lt;cdecl, 0x727140&gt;()</p>
<h4>CMirrors::BuildCamMatrix</h4>
<p>plugin::Call<0x723150, CMatrix*, CVector, CVector>(mat, pointA, pointB);</p>
<p>0AA5: call_function 0x723150 num_params 3 pop 3 [mat] [pointA] [pointB]</p>
<p>define function CMirrors__BuildCamMatrix&lt;cdecl, 0x723150&gt;(mat, pointA, pointB)</p>
<h4>CMirrors::BuildCameraMatrixForScreens</h4>
<p>plugin::Call<0x7266B0, CMatrix*>(mat);</p>
<p>0AA5: call_function 0x7266B0 num_params 1 pop 1 [mat]</p>
<p>define function CMirrors__BuildCameraMatrixForScreens&lt;cdecl, 0x7266B0&gt;(mat)</p>
<h4>CMirrors::CreateBuffer</h4>
<p>plugin::Call<0x7230A0>();</p>
<p>0AA5: call_function 0x7230A0 num_params 0 pop 0</p>
<p>define function CMirrors__CreateBuffer&lt;cdecl, 0x7230A0&gt;()</p>
<h4>CMirrors::Init</h4>
<p>plugin::Call<0x723000>();</p>
<p>0AA5: call_function 0x723000 num_params 0 pop 0</p>
<p>define function CMirrors__Init&lt;cdecl, 0x723000&gt;()</p>
<h4>CMirrors::RenderMirrorBuffer</h4>
<p>plugin::Call<0x726090>();</p>
<p>0AA5: call_function 0x726090 num_params 0 pop 0</p>
<p>define function CMirrors__RenderMirrorBuffer&lt;cdecl, 0x726090&gt;()</p>
<h4>CMirrors::ShutDown</h4>
<p>plugin::Call<0x723050>();</p>
<p>0AA5: call_function 0x723050 num_params 0 pop 0</p>
<p>define function CMirrors__ShutDown&lt;cdecl, 0x723050&gt;()</p><h3 id="plugin_sagame_sacmodelinfocpp">plugin_sa\game_sa\CModelInfo.cpp</h3><h4>*CModelInfo::GetModelInfo</h4>
<p>plugin::CallAndReturn<CBaseModelInfo *, 0x403DA0, int>(index);</p>
<p>0AA7: call_function_return 0x403DA0 num_params 1 pop 1 [index] func_ret [CBaseModelInfo *]</p>
<p>define function CModelInfo__GetModelInfo&lt;cdecl, 0x403DA0&gt;(index): int</p><h3 id="plugin_sagame_sacmodelinfoacceleratorcpp">plugin_sa\game_sa\CModelInfoAccelerator.cpp</h3><h4>CModelInfoAccelerator::Init</h4>
<p>plugin::CallMethod<0x4C6A80, CModelInfoAccelerator *>(this);</p>
<p>0AA6: call_method 0x4C6A80 struct [CModelInfoAccelerator] num_params 0 pop 0</p>
<p>define function CModelInfoAccelerator__Init&lt;thiscall, 0x4C6A80&gt;()</p>
<h4>CModelInfoAccelerator::AddModelInfoId</h4>
<p>plugin::CallMethod<0x4C6AA0, CModelInfoAccelerator *, unsigned short>(this, modelId);</p>
<p>0AA6: call_method 0x4C6AA0 struct [CModelInfoAccelerator] num_params 1 pop 0 [modelId]</p>
<p>define function CModelInfoAccelerator__AddModelInfoId&lt;thiscall, 0x4C6AA0&gt;(modelId)</p>
<h4>CModelInfoAccelerator::GetNextModelInfoId</h4>
<p>plugin::CallMethodAndReturn<unsigned short, 0x4C6AC0, CModelInfoAccelerator *>(this);</p>
<p>0AA8: call_method_return 0x4C6AC0 struct [CModelInfoAccelerator] num_params 0 pop 0 func_ret [unsigned short]</p>
<p>define function CModelInfoAccelerator__GetNextModelInfoId&lt;thiscall, 0x4C6AC0&gt;(): int</p>
<h4>CModelInfoAccelerator::AllocModelInfoIds</h4>
<p>plugin::CallMethod<0x4C6AE0, CModelInfoAccelerator *>(this);</p>
<p>0AA6: call_method 0x4C6AE0 struct [CModelInfoAccelerator] num_params 0 pop 0</p>
<p>define function CModelInfoAccelerator__AllocModelInfoIds&lt;thiscall, 0x4C6AE0&gt;()</p>
<h4>CModelInfoAccelerator::FreeModelInfoIds</h4>
<p>plugin::CallMethod<0x4C6B10, CModelInfoAccelerator *>(this);</p>
<p>0AA6: call_method 0x4C6B10 struct [CModelInfoAccelerator] num_params 0 pop 0</p>
<p>define function CModelInfoAccelerator__FreeModelInfoIds&lt;thiscall, 0x4C6B10&gt;()</p>
<h4>CModelInfoAccelerator::GetEntry</h4>
<p>plugin::CallMethod<0x4C6B30, CModelInfoAccelerator <em>, CBaseModelInfo</em><em>, int</em>, char*>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x4C6B30 struct [CModelInfoAccelerator] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CModelInfoAccelerator__GetEntry&lt;thiscall, 0x4C6B30&gt;(arg0, arg1, arg2)</p>
<h4>CModelInfoAccelerator::End</h4>
<p>plugin::CallMethod<0x4C6B40, CModelInfoAccelerator <em>, char</em>>(this, arg0);</p>
<p>0AA6: call_method 0x4C6B40 struct [CModelInfoAccelerator] num_params 1 pop 0 [arg0]</p>
<p>define function CModelInfoAccelerator__End&lt;thiscall, 0x4C6B40&gt;(arg0)</p>
<h4>CModelInfoAccelerator::CModelInfoAccelerator</h4>
<p>plugin::CallMethod<0x4C6B50, CModelInfoAccelerator *>(this);</p>
<p>0AA6: call_method 0x4C6B50 struct [CModelInfoAccelerator] num_params 0 pop 0</p>
<p>define function CModelInfoAccelerator__CModelInfoAccelerator&lt;thiscall, 0x4C6B50&gt;()</p>
<h4>CModelInfoAccelerator::GetModelInfoIdFile</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4C6B70, CModelInfoAccelerator *>(this);</p>
<p>0AA8: call_method_return 0x4C6B70 struct [CModelInfoAccelerator] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CModelInfoAccelerator__GetModelInfoIdFile&lt;thiscall, 0x4C6B70&gt;(): int</p>
<h4>CModelInfoAccelerator::EndOfLoadPhase</h4>
<p>plugin::CallMethod<0x4C6BD0, CModelInfoAccelerator *>(this);</p>
<p>0AA6: call_method 0x4C6BD0 struct [CModelInfoAccelerator] num_params 0 pop 0</p>
<p>define function CModelInfoAccelerator__EndOfLoadPhase&lt;thiscall, 0x4C6BD0&gt;()</p>
<h4>CModelInfoAccelerator::Begin</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4C6C20, CModelInfoAccelerator <em>, char</em>>(this, filePath);</p>
<p>0AA8: call_method_return 0x4C6C20 struct [CModelInfoAccelerator] num_params 1 pop 0 [filePath] func_ret [bool]</p>
<p>define function CModelInfoAccelerator__Begin&lt;thiscall, 0x4C6C20&gt;(filePath): int</p><h3 id="plugin_sagame_sacmotionblurstreakscpp">plugin_sa\game_sa\CMotionBlurStreaks.cpp</h3><h4>CMotionBlurStreaks::Update</h4>
<p>plugin::Call<0x7240C0>();</p>
<p>0AA5: call_function 0x7240C0 num_params 0 pop 0</p>
<p>define function CMotionBlurStreaks__Update&lt;cdecl, 0x7240C0&gt;()</p>
<h4>CMotionBlurStreaks::Render</h4>
<p>plugin::Call<0x7240E0>();</p>
<p>0AA5: call_function 0x7240E0 num_params 0 pop 0</p>
<p>define function CMotionBlurStreaks__Render&lt;cdecl, 0x7240E0&gt;()</p>
<h4>CMotionBlurStreaks::RegisterStreak</h4>
<p>plugin::Call<0x721DC0, unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(id, red, green, blue, leftPoint, rightPoint);</p>
<p>0AA5: call_function 0x721DC0 num_params 6 pop 6 [id] [red] [green] [blue] [leftPoint] [rightPoint]</p>
<p>define function CMotionBlurStreaks__RegisterStreak&lt;cdecl, 0x721DC0&gt;(id, red, green, blue, leftPoint, rightPoint)</p>
<h4>CMotionBlurStreaks::Init</h4>
<p>plugin::Call<0x721D90>();</p>
<p>0AA5: call_function 0x721D90 num_params 0 pop 0</p>
<p>define function CMotionBlurStreaks__Init&lt;cdecl, 0x721D90&gt;()</p><h3 id="plugin_sagame_sacocttreecpp">plugin_sa\game_sa\COctTree.cpp</h3><h4>COctTree::InsertTree</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 0, COctTree *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);</p>
<h4>COctTree::FillPalette</h4>
<p>plugin::CallVirtualMethod<1, COctTree <em>, unsigned char</em>>(this, colors);</p>
<h4>COctTree::COctTree</h4>
<p>plugin::CallMethod<0x5A6DB0, COctTree *>(this);</p>
<p>0AA6: call_method 0x5A6DB0 struct [COctTree] num_params 0 pop 0</p>
<p>define function COctTree__COctTree&lt;thiscall, 0x5A6DB0&gt;()</p>
<h4>COctTree::FindNearestColour</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A71E0, COctTree *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);</p>
<p>0AA8: call_method_return 0x5A71E0 struct [COctTree] num_params 3 pop 0 [colorRed] [colorGreen] [colorBlue] func_ret [unsigned int]</p>
<p>define function COctTree__FindNearestColour&lt;thiscall, 0x5A71E0&gt;(colorRed, colorGreen, colorBlue): int</p>
<h4>COctTree::InitPool</h4>
<p>plugin::CallMethod<0x5A7460, COctTree <em>, void</em>, int>(this, data, dataSize);</p>
<p>0AA6: call_method 0x5A7460 struct [COctTree] num_params 2 pop 0 [data] [dataSize]</p>
<p>define function COctTree__InitPool&lt;thiscall, 0x5A7460&gt;(data, dataSize)</p>
<h4>COctTree::NoOfChildren</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A6DE0, COctTree *>(this);</p>
<p>0AA8: call_method_return 0x5A6DE0 struct [COctTree] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function COctTree__NoOfChildren&lt;thiscall, 0x5A6DE0&gt;(): int</p>
<h4>COctTree::ReduceTree</h4>
<p>plugin::CallMethod<0x5A7040, COctTree *>(this);</p>
<p>0AA6: call_method 0x5A7040 struct [COctTree] num_params 0 pop 0</p>
<p>define function COctTree__ReduceTree&lt;thiscall, 0x5A7040&gt;()</p>
<h4>COctTree::RemoveChildren</h4>
<p>plugin::CallMethod<0x5A74F0, COctTree *>(this);</p>
<p>0AA6: call_method 0x5A74F0 struct [COctTree] num_params 0 pop 0</p>
<p>define function COctTree__RemoveChildren&lt;thiscall, 0x5A74F0&gt;()</p>
<h4>COctTree::ShutdownPool</h4>
<p>plugin::CallMethod<0x5A6F70, COctTree *>(this);</p>
<p>0AA6: call_method 0x5A6F70 struct [COctTree] num_params 0 pop 0</p>
<p>define function COctTree__ShutdownPool&lt;thiscall, 0x5A6F70&gt;()</p>
<h4>COctTree::empty</h4>
<p>plugin::CallMethod<0x5A6FC0, COctTree *>(this);</p>
<p>0AA6: call_method 0x5A6FC0 struct [COctTree] num_params 0 pop 0</p>
<p>define function COctTree__empty&lt;thiscall, 0x5A6FC0&gt;()</p>
<h4>COctTree::operator delete</h4>
<p>plugin::Call<0x5A7420, void*>(data);</p>
<p>0AA5: call_function 0x5A7420 num_params 1 pop 1 [data]</p>
<p>define function COctTree__operator delete&lt;cdecl, 0x5A7420&gt;(data)</p>
<h4>COctTree::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x5A7410, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x5A7410 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function COctTree__operator new&lt;cdecl, 0x5A7410&gt;(size): int</p><h3 id="plugin_sagame_sacocttreebasecpp">plugin_sa\game_sa\COctTreeBase.cpp</h3><h4>COctTreeBase::COctTreeBase</h4>
<p>plugin::CallMethod<0x5A7570, COctTreeBase *>(this);</p>
<p>0AA6: call_method 0x5A7570 struct [COctTreeBase] num_params 0 pop 0</p>
<p>define function COctTreeBase__COctTreeBase&lt;thiscall, 0x5A7570&gt;()</p>
<h4>COctTreeBase::Init</h4>
<p>plugin::CallMethod<0x5A7260, COctTreeBase *, int>(this, numBranches);</p>
<p>0AA6: call_method 0x5A7260 struct [COctTreeBase] num_params 1 pop 0 [numBranches]</p>
<p>define function COctTreeBase__Init&lt;thiscall, 0x5A7260&gt;(numBranches)</p>
<h4>COctTreeBase::Insert</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A7750, COctTreeBase *, unsigned char, unsigned char, unsigned char>(this, colorRed, colorGreen, colorBlue);</p>
<p>0AA8: call_method_return 0x5A7750 struct [COctTreeBase] num_params 3 pop 0 [colorRed] [colorGreen] [colorBlue] func_ret [bool]</p>
<p>define function COctTreeBase__Insert&lt;thiscall, 0x5A7750&gt;(colorRed, colorGreen, colorBlue): int</p>
<h4>COctTreeBase::ReduceBranches</h4>
<p>plugin::CallMethod<0x5A7840, COctTreeBase *, int>(this, newBranchesCount);</p>
<p>0AA6: call_method 0x5A7840 struct [COctTreeBase] num_params 1 pop 0 [newBranchesCount]</p>
<p>define function COctTreeBase__ReduceBranches&lt;thiscall, 0x5A7840&gt;(newBranchesCount)</p><h3 id="plugin_sagame_sacommoncpp">plugin_sa\game_sa\common.cpp</h3><h4>RemoveRefsCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x7226D0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x7226D0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function RemoveRefsCB&lt;cdecl, 0x7226D0&gt;(atomic, data): int</p>
<h4>RemoveRefsForAtomic</h4>
<p>plugin::Call<0x7226F0, RpClump*>(clump);</p>
<p>0AA5: call_function 0x7226F0 num_params 1 pop 1 [clump]</p>
<p>define function RemoveRefsForAtomic&lt;cdecl, 0x7226F0&gt;(clump)</p>
<h4>RpAnimBlendAllocateData</h4>
<p>plugin::CallAndReturn<CAnimBlendClumpData<em>, 0x4D5F50, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x4D5F50 num_params 1 pop 1 [clump] func_ret [CAnimBlendClumpData*]</p>
<p>define function RpAnimBlendAllocateData&lt;cdecl, 0x4D5F50&gt;(clump): int</p>
<h4>RpAnimBlendClumpAddAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6790, RpClump</em>, CAnimBlendAssociation*, unsigned int, float, float>(clump, association, flags, startTime, blendAmount);</p>
<p>0AA7: call_function_return 0x4D6790 num_params 5 pop 5 [clump] [association] [flags] [startTime] [blendAmount] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpAddAssociation&lt;cdecl, 0x4D6790&gt;(clump, association, flags, startTime, blendAmount): int</p>
<h4>RpAnimBlendClumpExtractAssociations</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6BE0, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x4D6BE0 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpExtractAssociations&lt;cdecl, 0x4D6BE0&gt;(clump): int</p>
<h4>RpAnimBlendClumpFillFrameArray</h4>
<p>plugin::Call<0x4D64A0, RpClump<em>, AnimBlendFrameData</em>*>(clump, frameData);</p>
<p>0AA5: call_function 0x4D64A0 num_params 2 pop 2 [clump] [frameData]</p>
<p>define function RpAnimBlendClumpFillFrameArray&lt;cdecl, 0x4D64A0&gt;(clump, frameData)</p>
<h4>RpAnimBlendClumpFindBone</h4>
<p>plugin::CallAndReturn<AnimBlendFrameData<em>, 0x4D6400, RpClump</em>, unsigned int>(clump, id);</p>
<p>0AA7: call_function_return 0x4D6400 num_params 2 pop 2 [clump] [id] func_ret [AnimBlendFrameData*]</p>
<p>define function RpAnimBlendClumpFindBone&lt;cdecl, 0x4D6400&gt;(clump, id): int</p>
<h4>RpAnimBlendClumpFindFrame</h4>
<p>plugin::CallAndReturn<AnimBlendFrameData<em>, 0x4D62A0, RpClump</em>, char const*>(clump, name);</p>
<p>0AA7: call_function_return 0x4D62A0 num_params 2 pop 2 [clump] [name] func_ret [AnimBlendFrameData*]</p>
<p>define function RpAnimBlendClumpFindFrame&lt;cdecl, 0x4D62A0&gt;(clump, name): int</p>
<h4>RpAnimBlendClumpFindFrameFromHashKey</h4>
<p>plugin::CallAndReturn<AnimBlendFrameData<em>, 0x4D6370, RpClump</em>, unsigned int>(clump, key);</p>
<p>0AA7: call_function_return 0x4D6370 num_params 2 pop 2 [clump] [key] func_ret [AnimBlendFrameData*]</p>
<p>define function RpAnimBlendClumpFindFrameFromHashKey&lt;cdecl, 0x4D6370&gt;(clump, key): int</p>
<h4>RpAnimBlendClumpGetAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D68E0, RpClump</em>, bool, CAnimBlendHierarchy*>(clump, arg1, hierarchy);</p>
<p>0AA7: call_function_return 0x4D68E0 num_params 3 pop 3 [clump] [arg1] [hierarchy] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetAssociation&lt;cdecl, 0x4D68E0&gt;(clump, arg1, hierarchy): int</p>
<h4>RpAnimBlendClumpGetAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6870, RpClump</em>, char const*>(clump, name);</p>
<p>0AA7: call_function_return 0x4D6870 num_params 2 pop 2 [clump] [name] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetAssociation&lt;cdecl, 0x4D6870&gt;(clump, name): int</p>
<h4>RpAnimBlendClumpGetAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D68B0, RpClump</em>, unsigned int>(clump, animId);</p>
<p>0AA7: call_function_return 0x4D68B0 num_params 2 pop 2 [clump] [animId] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetAssociation&lt;cdecl, 0x4D68B0&gt;(clump, animId): int</p>
<h4>RpAnimBlendClumpGetFirstAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D15E0, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x4D15E0 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetFirstAssociation&lt;cdecl, 0x4D15E0&gt;(clump): int</p>
<h4>RpAnimBlendClumpGetFirstAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6A70, RpClump</em>, unsigned int>(clump, flags);</p>
<p>0AA7: call_function_return 0x4D6A70 num_params 2 pop 2 [clump] [flags] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetFirstAssociation&lt;cdecl, 0x4D6A70&gt;(clump, flags): int</p>
<h4>RpAnimBlendClumpGetMainAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6910, RpClump</em>, CAnimBlendAssociation*<em>, float</em>>(clump, pAssociation, blendAmount);</p>
<p>0AA7: call_function_return 0x4D6910 num_params 3 pop 3 [clump] [pAssociation] [blendAmount] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetMainAssociation&lt;cdecl, 0x4D6910&gt;(clump, pAssociation, blendAmount): int</p>
<h4>RpAnimBlendClumpGetMainAssociation_N</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6A30, RpClump</em>, int>(clump, n);</p>
<p>0AA7: call_function_return 0x4D6A30 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetMainAssociation_N&lt;cdecl, 0x4D6A30&gt;(clump, n): int</p>
<h4>RpAnimBlendClumpGetMainPartialAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D69A0, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x4D69A0 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetMainPartialAssociation&lt;cdecl, 0x4D69A0&gt;(clump): int</p>
<h4>RpAnimBlendClumpGetMainPartialAssociation_N</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D69F0, RpClump</em>, int>(clump, n);</p>
<p>0AA7: call_function_return 0x4D69F0 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetMainPartialAssociation_N&lt;cdecl, 0x4D69F0&gt;(clump, n): int</p>
<h4>RpAnimBlendClumpGetNumAssociations</h4>
<p>plugin::CallAndReturn<unsigned int, 0x4D6B60, RpClump*>(clump);</p>
<p>0AA7: call_function_return 0x4D6B60 num_params 1 pop 1 [clump] func_ret [unsigned int]</p>
<p>define function RpAnimBlendClumpGetNumAssociations&lt;cdecl, 0x4D6B60&gt;(clump): int</p>
<h4>RpAnimBlendClumpGetNumNonPartialAssociations</h4>
<p>plugin::CallAndReturn<unsigned int, 0x4D6BB0, RpClump*>(clump);</p>
<p>0AA7: call_function_return 0x4D6BB0 num_params 1 pop 1 [clump] func_ret [unsigned int]</p>
<p>define function RpAnimBlendClumpGetNumNonPartialAssociations&lt;cdecl, 0x4D6BB0&gt;(clump): int</p>
<h4>RpAnimBlendClumpGetNumPartialAssociations</h4>
<p>plugin::CallAndReturn<unsigned int, 0x4D6B80, RpClump*>(clump);</p>
<p>0AA7: call_function_return 0x4D6B80 num_params 1 pop 1 [clump] func_ret [unsigned int]</p>
<p>define function RpAnimBlendClumpGetNumPartialAssociations&lt;cdecl, 0x4D6B80&gt;(clump): int</p>
<h4>RpAnimBlendClumpGiveAssociations</h4>
<p>plugin::Call<0x4D6C30, RpClump<em>, CAnimBlendAssociation</em>>(clump, association);</p>
<p>0AA5: call_function 0x4D6C30 num_params 2 pop 2 [clump] [association]</p>
<p>define function RpAnimBlendClumpGiveAssociations&lt;cdecl, 0x4D6C30&gt;(clump, association)</p>
<h4>RpAnimBlendClumpInit</h4>
<p>plugin::Call<0x4D6720, RpClump*>(clump);</p>
<p>0AA5: call_function 0x4D6720 num_params 1 pop 1 [clump]</p>
<p>define function RpAnimBlendClumpInit&lt;cdecl, 0x4D6720&gt;(clump)</p>
<h4>RpAnimBlendClumpIsInitialized</h4>
<p>plugin::CallAndReturn<bool, 0x4D6760, RpClump*>(clump);</p>
<p>0AA7: call_function_return 0x4D6760 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function RpAnimBlendClumpIsInitialized&lt;cdecl, 0x4D6760&gt;(clump): int</p>
<h4>RpAnimBlendClumpPauseAllAnimations</h4>
<p>plugin::Call<0x4D6B00, RpClump*>(clump);</p>
<p>0AA5: call_function 0x4D6B00 num_params 1 pop 1 [clump]</p>
<p>define function RpAnimBlendClumpPauseAllAnimations&lt;cdecl, 0x4D6B00&gt;(clump)</p>
<h4>RpAnimBlendClumpRemoveAllAssociations</h4>
<p>plugin::Call<0x4D6C00, RpClump*>(clump);</p>
<p>0AA5: call_function 0x4D6C00 num_params 1 pop 1 [clump]</p>
<p>define function RpAnimBlendClumpRemoveAllAssociations&lt;cdecl, 0x4D6C00&gt;(clump)</p>
<h4>RpAnimBlendClumpRemoveAssociations</h4>
<p>plugin::Call<0x4D6820, RpClump*, unsigned int>(clump, flags);</p>
<p>0AA5: call_function 0x4D6820 num_params 2 pop 2 [clump] [flags]</p>
<p>define function RpAnimBlendClumpRemoveAssociations&lt;cdecl, 0x4D6820&gt;(clump, flags)</p>
<h4>RpAnimBlendClumpSetBlendDeltas</h4>
<p>plugin::Call<0x4D67E0, RpClump*, unsigned int, float>(clump, flags, delta);</p>
<p>0AA5: call_function 0x4D67E0 num_params 3 pop 3 [clump] [flags] [delta]</p>
<p>define function RpAnimBlendClumpSetBlendDeltas&lt;cdecl, 0x4D67E0&gt;(clump, flags, delta)</p>
<h4>RpAnimBlendClumpUnPauseAllAnimations</h4>
<p>plugin::Call<0x4D6B30, RpClump*>(clump);</p>
<p>0AA5: call_function 0x4D6B30 num_params 1 pop 1 [clump]</p>
<p>define function RpAnimBlendClumpUnPauseAllAnimations&lt;cdecl, 0x4D6B30&gt;(clump)</p>
<h4>RpAnimBlendClumpUpdateAnimations</h4>
<p>plugin::Call<0x4D34F0, RpClump*, float, bool>(clump, step, onScreen);</p>
<p>0AA5: call_function 0x4D34F0 num_params 3 pop 3 [clump] [step] [onScreen]</p>
<p>define function RpAnimBlendClumpUpdateAnimations&lt;cdecl, 0x4D34F0&gt;(clump, step, onScreen)</p>
<h4>RpAnimBlendCreateAnimationForHierarchy</h4>
<p>plugin::CallAndReturn<RtAnimAnimation<em>, 0x4D60E0, RpHAnimHierarchy</em>>(hierarchy);</p>
<p>0AA7: call_function_return 0x4D60E0 num_params 1 pop 1 [hierarchy] func_ret [RtAnimAnimation*]</p>
<p>define function RpAnimBlendCreateAnimationForHierarchy&lt;cdecl, 0x4D60E0&gt;(hierarchy): int</p>
<h4>RpAnimBlendFrameGetName</h4>
<p>plugin::CallAndReturn<char<em>, 0x4D5EF0, RwFrame</em>>(frame);</p>
<p>0AA7: call_function_return 0x4D5EF0 num_params 1 pop 1 [frame] func_ret [char*]</p>
<p>define function RpAnimBlendFrameGetName&lt;cdecl, 0x4D5EF0&gt;(frame): int</p>
<h4>RpAnimBlendFrameSetName</h4>
<p>plugin::Call<0x4D5F00, RwFrame<em>, char</em>>(frame, name);</p>
<p>0AA5: call_function 0x4D5F00 num_params 2 pop 2 [frame] [name]</p>
<p>define function RpAnimBlendFrameSetName&lt;cdecl, 0x4D5F00&gt;(frame, name)</p>
<h4>RpAnimBlendGetNextAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6AB0, CAnimBlendAssociation</em>>(association);</p>
<p>0AA7: call_function_return 0x4D6AB0 num_params 1 pop 1 [association] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendGetNextAssociation&lt;cdecl, 0x4D6AB0&gt;(association): int</p>
<h4>RpAnimBlendGetNextAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4D6AD0, CAnimBlendAssociation</em>, unsigned int>(association, flags);</p>
<p>0AA7: call_function_return 0x4D6AD0 num_params 2 pop 2 [association] [flags] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendGetNextAssociation&lt;cdecl, 0x4D6AD0&gt;(association, flags): int</p>
<h4>RpAnimBlendKeyFrameInterpolate</h4>
<p>plugin::Call<0x4D60C0, void<em>, void</em>, void<em>, float, void</em>>(voidOut, voidIn1, voidIn2, time, customData);</p>
<p>0AA5: call_function 0x4D60C0 num_params 5 pop 5 [voidOut] [voidIn1] [voidIn2] [time] [customData]</p>
<p>define function RpAnimBlendKeyFrameInterpolate&lt;cdecl, 0x4D60C0&gt;(voidOut, voidIn1, voidIn2, time, customData)</p>
<h4>RpAnimBlendPluginAttach</h4>
<p>plugin::CallAndReturn<bool, 0x4D6150>();</p>
<p>0AA7: call_function_return 0x4D6150 num_params 0 pop 0 func_ret [bool]</p>
<p>define function RpAnimBlendPluginAttach&lt;cdecl, 0x4D6150&gt;(): int</p>
<h4>AsciiToGxtChar</h4>
<p>plugin::Call<0x718600, char const *, char *>(src, dst);</p>
<p>0AA5: call_function 0x718600 num_params 2 pop 2 [src] [dst]</p>
<p>define function AsciiToGxtChar&lt;cdecl, 0x718600&gt;(src, dst)</p>
<h4>assert</h4>
<p>plugin::Call<0x005A4150>(pRaster, pszPath);</p>
<p>0AA5: call_function 0x005A4150 num_params 2 pop 2 [pRaster] [pszPath]</p>
<p>define function assert&lt;cdecl, 0x005A4150&gt;(pRaster, pszPath)</p>
<h4>DoRWStuffStartOfFrame</h4>
<p>plugin::CallAndReturn<bool, 0x53D690>(topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue, alpha);</p>
<p>0AA7: call_function_return 0x53D690 num_params 7 pop 7 [topRed] [topGreen] [topBlue] [bottomRed] [bottomGreen] [bottomBlue] [alpha] func_ret [bool]</p>
<p>define function DoRWStuffStartOfFrame&lt;cdecl, 0x53D690&gt;(topRed, topGreen, topBlue, bottomRed, bottomGreen, bottomBlue, alpha): int</p>
<h4>DoRWStuffEndOfFrame</h4>
<p>plugin::Call<0x53D840>();</p>
<p>0AA5: call_function 0x53D840 num_params 0 pop 0</p>
<p>define function DoRWStuffEndOfFrame&lt;cdecl, 0x53D840&gt;()</p>
<h4>RsCameraShowRaster</h4>
<p>plugin::Call<0x619440>(camera);</p>
<p>0AA5: call_function 0x619440 num_params 1 pop 1 [camera]</p>
<p>define function RsCameraShowRaster&lt;cdecl, 0x619440&gt;(camera)</p><h3 id="plugin_sagame_saconscreencounterentrycpp">plugin_sa\game_sa\COnscreenCounterEntry.cpp</h3><h4>COnscreenCounterEntry::ProcessForDisplayCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenCounterEntry *, int>(gaddrof(COnscreenCounterEntry::ProcessForDisplayCounter), this, type);</p>
<p>0AA6: call_method 0x44CA90 struct [COnscreenCounterEntry] num_params 1 pop 0 [type]</p>
<p>define function COnscreenCounterEntry__ProcessForDisplayCounter&lt;thiscall, 0x44CA90&gt;(type)</p>
<h4>COnscreenCounterEntry::SetColourID</h4>
<p>plugin::CallMethodDynGlobal<COnscreenCounterEntry *, unsigned char>(gaddrof(COnscreenCounterEntry::SetColourID), this, ColourID);</p>
<p>0AA6: call_method 0x44CB00 struct [COnscreenCounterEntry] num_params 1 pop 0 [ColourID]</p>
<p>define function COnscreenCounterEntry__SetColourID&lt;thiscall, 0x44CB00&gt;(ColourID)</p><h3 id="plugin_sagame_saconscreentimercpp">plugin_sa\game_sa\COnscreenTimer.cpp</h3><h4>COnscreenTimer::AddClock</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, char *, bool>(gaddrof(COnscreenTimer::AddClock), this, varId, gxt, bTimerDirection);</p>
<p>0AA6: call_method 0x44CD50 struct [COnscreenTimer] num_params 3 pop 0 [varId] [gxt] [bTimerDirection]</p>
<p>define function COnscreenTimer__AddClock&lt;thiscall, 0x44CD50&gt;(varId, gxt, bTimerDirection)</p>
<h4>COnscreenTimer::AddCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, int, short, char *, unsigned short>(gaddrof(COnscreenTimer::AddCounter), this, varId, type, gxt, counterIndex);</p>
<p>0AA6: call_method 0x44CDA0 struct [COnscreenTimer] num_params 4 pop 0 [varId] [type] [gxt] [counterIndex]</p>
<p>define function COnscreenTimer__AddCounter&lt;thiscall, 0x44CDA0&gt;(varId, type, gxt, counterIndex)</p>
<h4>COnscreenTimer::AddCounterCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned int, char *, unsigned short>(gaddrof(COnscreenTimer::AddCounterCounter), this, varId, maxValue, gxt, lineId);</p>
<p>0AA6: call_method 0x44CE00 struct [COnscreenTimer] num_params 4 pop 0 [varId] [maxValue] [gxt] [lineId]</p>
<p>define function COnscreenTimer__AddCounterCounter&lt;thiscall, 0x44CE00&gt;(varId, maxValue, gxt, lineId)</p>
<h4>COnscreenTimer::ClearClock</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearClock), this, varId);</p>
<p>0AA8: call_method_return 0x44CE60 struct [COnscreenTimer] num_params 1 pop 0 [varId] func_ret [int]</p>
<h4>COnscreenTimer::ClearCounter</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int>(gaddrof(COnscreenTimer::ClearCounter), this, varId);</p>
<p>0AA6: call_method 0x44CE80 struct [COnscreenTimer] num_params 1 pop 0 [varId]</p>
<p>define function COnscreenTimer__ClearCounter&lt;thiscall, 0x44CE80&gt;(varId)</p>
<h4>COnscreenTimer::Init</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Init), this);</p>
<p>0AA6: call_method 0x44CBC0 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__Init&lt;thiscall, 0x44CBC0&gt;()</p>
<h4>COnscreenTimer::Process</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::Process), this);</p>
<p>0AA6: call_method 0x44CD30 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__Process&lt;thiscall, 0x44CD30&gt;()</p>
<h4>COnscreenTimer::ProcessForDisplay</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *>(gaddrof(COnscreenTimer::ProcessForDisplay), this);</p>
<p>0AA6: call_method 0x44CC20 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__ProcessForDisplay&lt;thiscall, 0x44CC20&gt;()</p>
<h4>COnscreenTimer::SetClockBeepCountdownSecs</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned int>(gaddrof(COnscreenTimer::SetClockBeepCountdownSecs), this, varID, time);</p>
<p>0AA6: call_method 0x44CEE0 struct [COnscreenTimer] num_params 2 pop 0 [varID] [time]</p>
<p>define function COnscreenTimer__SetClockBeepCountdownSecs&lt;thiscall, 0x44CEE0&gt;(varID, time)</p>
<h4>COnscreenTimer::SetCounterColourID</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned char>(gaddrof(COnscreenTimer::SetCounterColourID), this, varID, ColourID);</p>
<p>0AA6: call_method 0x44CF10 struct [COnscreenTimer] num_params 2 pop 0 [varID] [ColourID]</p>
<p>define function COnscreenTimer__SetCounterColourID&lt;thiscall, 0x44CF10&gt;(varID, ColourID)</p>
<h4>COnscreenTimer::SetCounterFlashWhenFirstDisplayed</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimer *, unsigned int, unsigned char>(gaddrof(COnscreenTimer::SetCounterFlashWhenFirstDisplayed), this, varId, bFlashWhenFirstDisplayed);</p>
<p>0AA6: call_method 0x44CEB0 struct [COnscreenTimer] num_params 2 pop 0 [varId] [bFlashWhenFirstDisplayed]</p>
<p>define function COnscreenTimer__SetCounterFlashWhenFirstDisplayed&lt;thiscall, 0x44CEB0&gt;(varId, bFlashWhenFirstDisplayed)</p><h3 id="plugin_sagame_saconscreentimerentrycpp">plugin_sa\game_sa\COnscreenTimerEntry.cpp</h3><h4>COnscreenTimerEntry::Process</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::Process), this);</p>
<p>0AA6: call_method 0x44CB10 struct [COnscreenTimerEntry] num_params 0 pop 0</p>
<p>define function COnscreenTimerEntry__Process&lt;thiscall, 0x44CB10&gt;()</p>
<h4>COnscreenTimerEntry::ProcessForDisplayClock</h4>
<p>plugin::CallMethodDynGlobal<COnscreenTimerEntry *>(gaddrof(COnscreenTimerEntry::ProcessForDisplayClock), this);</p>
<p>0AA6: call_method 0x44CA40 struct [COnscreenTimerEntry] num_params 0 pop 0</p>
<p>define function COnscreenTimerEntry__ProcessForDisplayClock&lt;thiscall, 0x44CA40&gt;()</p><h3 id="plugin_sagame_sacpadcpp">plugin_sa\game_sa\CPad.cpp</h3><h4>CPad::UpdateMouse</h4>
<p>plugin::CallMethod<0x53F3C0, CPad *>(this);</p>
<p>0AA6: call_method 0x53F3C0 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__UpdateMouse&lt;thiscall, 0x53F3C0&gt;()</p>
<h4>CPad::ReconcileTwoControllersInput</h4>
<p>plugin::CallMethod<0x53F530, CPad *, CControllerState const&, CControllerState const&>(this, controllerA, controllerB);</p>
<p>0AA6: call_method 0x53F530 struct [CPad] num_params 2 pop 0 [controllerA] [controllerB]</p>
<p>define function CPad__ReconcileTwoControllersInput&lt;thiscall, 0x53F530&gt;(controllerA, controllerB)</p>
<h4>CPad::SetDrunkInputDelay</h4>
<p>plugin::CallMethod<0x53F910, CPad *, int>(this, delay);</p>
<p>0AA6: call_method 0x53F910 struct [CPad] num_params 1 pop 0 [delay]</p>
<p>define function CPad__SetDrunkInputDelay&lt;thiscall, 0x53F910&gt;(delay)</p>
<h4>CPad::StartShake</h4>
<p>plugin::CallMethod<0x53F920, CPad *, short, unsigned char, unsigned int>(this, time, frequency, arg2);</p>
<p>0AA6: call_method 0x53F920 struct [CPad] num_params 3 pop 0 [time] [frequency] [arg2]</p>
<p>define function CPad__StartShake&lt;thiscall, 0x53F920&gt;(time, frequency, arg2)</p>
<h4>CPad::StartShake_Distance</h4>
<p>plugin::CallMethod<0x53F9A0, CPad *, short, unsigned char, float, float, float>(this, time, frequency, x, y, z);</p>
<p>0AA6: call_method 0x53F9A0 struct [CPad] num_params 5 pop 0 [time] [frequency] [x] [y] [z]</p>
<p>define function CPad__StartShake_Distance&lt;thiscall, 0x53F9A0&gt;(time, frequency, x, y, z)</p>
<h4>CPad::StartShake_Train</h4>
<p>plugin::CallMethod<0x53FA70, CPad *, float, float>(this, x, y);</p>
<p>0AA6: call_method 0x53FA70 struct [CPad] num_params 2 pop 0 [x] [y]</p>
<p>define function CPad__StartShake_Train&lt;thiscall, 0x53FA70&gt;(x, y)</p>
<h4>CPad::ProcessPCSpecificStuff</h4>
<p>plugin::CallMethod<0x53FB40, CPad *>(this);</p>
<p>0AA6: call_method 0x53FB40 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__ProcessPCSpecificStuff&lt;thiscall, 0x53FB40&gt;()</p>
<h4>CPad::StopShaking</h4>
<p>plugin::CallMethod<0x53FB50, CPad *, short>(this, arg0);</p>
<p>0AA6: call_method 0x53FB50 struct [CPad] num_params 1 pop 0 [arg0]</p>
<p>define function CPad__StopShaking&lt;thiscall, 0x53FB50&gt;(arg0)</p>
<h4>CPad::GetPad</h4>
<p>plugin::CallAndReturn<CPad*, 0x53FB70, int>(padNumber);</p>
<p>0AA7: call_function_return 0x53FB70 num_params 1 pop 1 [padNumber] func_ret [CPad*]</p>
<p>define function CPad__GetPad&lt;cdecl, 0x53FB70&gt;(padNumber): int</p>
<h4>CPad::GetSteeringLeftRight</h4>
<p>plugin::CallMethodAndReturn<short, 0x53FB80, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FB80 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetSteeringLeftRight&lt;thiscall, 0x53FB80&gt;(): int</p>
<h4>CPad::GetSteeringUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x53FBD0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FBD0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetSteeringUpDown&lt;thiscall, 0x53FBD0&gt;(): int</p>
<h4>CPad::GetPedWalkLeftRight</h4>
<p>plugin::CallMethodAndReturn<short, 0x53FC90, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FC90 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetPedWalkLeftRight&lt;thiscall, 0x53FC90&gt;(): int</p>
<h4>CPad::GetPedWalkUpDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x53FD30, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FD30 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetPedWalkUpDown&lt;thiscall, 0x53FD30&gt;(): int</p>
<h4>CPad::GetLookLeft</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FDD0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FDD0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookLeft&lt;thiscall, 0x53FDD0&gt;(): int</p>
<h4>CPad::GetLookRight</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FE10, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FE10 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookRight&lt;thiscall, 0x53FE10&gt;(): int</p>
<h4>CPad::GetLookBehindForCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FE70, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FE70 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookBehindForCar&lt;thiscall, 0x53FE70&gt;(): int</p>
<h4>CPad::GetLookBehindForPed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FEC0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FEC0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetLookBehindForPed&lt;thiscall, 0x53FEC0&gt;(): int</p>
<h4>CPad::GetHorn</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FEE0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FEE0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetHorn&lt;thiscall, 0x53FEE0&gt;(): int</p>
<h4>CPad::HornJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FF30, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FF30 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__HornJustDown&lt;thiscall, 0x53FF30&gt;(): int</p>
<h4>CPad::GetHydraulicJump</h4>
<p>plugin::CallMethodAndReturn<bool, 0x53FF70, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FF70 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetHydraulicJump&lt;thiscall, 0x53FF70&gt;(): int</p>
<h4>CPad::GetCarGunFired</h4>
<p>plugin::CallMethodAndReturn<short, 0x53FF90, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FF90 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetCarGunFired&lt;thiscall, 0x53FF90&gt;(): int</p>
<h4>CPad::CarGunJustDown</h4>
<p>plugin::CallMethodAndReturn<short, 0x53FFE0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x53FFE0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__CarGunJustDown&lt;thiscall, 0x53FFE0&gt;(): int</p>
<h4>CPad::GetHandBrake</h4>
<p>plugin::CallMethodAndReturn<short, 0x540040, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540040 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetHandBrake&lt;thiscall, 0x540040&gt;(): int</p>
<h4>CPad::GetBrake</h4>
<p>plugin::CallMethodAndReturn<short, 0x540080, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540080 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetBrake&lt;thiscall, 0x540080&gt;(): int</p>
<h4>CPad::GetExitVehicle</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5400D0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5400D0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetExitVehicle&lt;thiscall, 0x5400D0&gt;(): int</p>
<h4>CPad::ExitVehicleJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540120, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540120 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ExitVehicleJustDown&lt;thiscall, 0x540120&gt;(): int</p>
<h4>CPad::GetMeleeAttack</h4>
<p>plugin::CallMethodAndReturn<unsigned char, 0x540340, CPad *>(this, 0);</p>
<p>0AA8: call_method_return 0x540340 struct [CPad] num_params 1 pop 0 [0] func_ret [unsigned char]</p>
<p>define function CPad__GetMeleeAttack&lt;thiscall, 0x540340&gt;(0): int</p>
<h4>CPad::MeleeAttackJustDown</h4>
<p>plugin::CallMethodAndReturn<unsigned char, 0x540390, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540390 struct [CPad] num_params 0 pop 0 func_ret [unsigned char]</p>
<p>define function CPad__MeleeAttackJustDown&lt;thiscall, 0x540390&gt;(): int</p>
<h4>CPad::GetAccelerate</h4>
<p>plugin::CallMethodAndReturn<short, 0x5403F0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5403F0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPad__GetAccelerate&lt;thiscall, 0x5403F0&gt;(): int</p>
<h4>CPad::GetAccelerateJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540440, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540440 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetAccelerateJustDown&lt;thiscall, 0x540440&gt;(): int</p>
<h4>CPad::NextStationJustUp</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5405B0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5405B0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__NextStationJustUp&lt;thiscall, 0x5405B0&gt;(): int</p>
<h4>CPad::LastStationJustUp</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5405E0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5405E0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__LastStationJustUp&lt;thiscall, 0x5405E0&gt;(): int</p>
<h4>CPad::CycleWeaponLeftJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540610, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540610 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CycleWeaponLeftJustDown&lt;thiscall, 0x540610&gt;(): int</p>
<h4>CPad::CycleWeaponRightJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540640, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540640 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CycleWeaponRightJustDown&lt;thiscall, 0x540640&gt;(): int</p>
<h4>CPad::GetTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540670, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540670 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetTarget&lt;thiscall, 0x540670&gt;(): int</p>
<h4>CPad::GetDuck</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540700, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540700 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetDuck&lt;thiscall, 0x540700&gt;(): int</p>
<h4>CPad::DuckJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540720, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540720 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__DuckJustDown&lt;thiscall, 0x540720&gt;(): int</p>
<h4>CPad::GetJump</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540750, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540750 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetJump&lt;thiscall, 0x540750&gt;(): int</p>
<h4>CPad::JumpJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540770, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540770 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__JumpJustDown&lt;thiscall, 0x540770&gt;(): int</p>
<h4>CPad::GetSprint</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5407A0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5407A0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetSprint&lt;thiscall, 0x5407A0&gt;(): int</p>
<h4>CPad::SprintJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5407F0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5407F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__SprintJustDown&lt;thiscall, 0x5407F0&gt;(): int</p>
<h4>CPad::ShiftTargetLeftJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540850, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540850 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ShiftTargetLeftJustDown&lt;thiscall, 0x540850&gt;(): int</p>
<h4>CPad::ShiftTargetRightJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540880, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540880 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ShiftTargetRightJustDown&lt;thiscall, 0x540880&gt;(): int</p>
<h4>CPad::GetDisplayVitalStats</h4>
<p>plugin::CallMethodAndReturn<short, 0x5408B0, CPad <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x5408B0 struct [CPad] num_params 1 pop 0 [ped] func_ret [short]</p>
<p>define function CPad__GetDisplayVitalStats&lt;thiscall, 0x5408B0&gt;(ped): int</p>
<h4>CPad::CollectPickupJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540A70, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540A70 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__CollectPickupJustDown&lt;thiscall, 0x540A70&gt;(): int</p>
<h4>CPad::GetForceCameraBehindPlayer</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540AE0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540AE0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetForceCameraBehindPlayer&lt;thiscall, 0x540AE0&gt;(): int</p>
<h4>CPad::SniperZoomIn</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540B30, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540B30 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__SniperZoomIn&lt;thiscall, 0x540B30&gt;(): int</p>
<h4>CPad::SniperZoomOut</h4>
<p>plugin::CallMethodAndReturn<bool, 0x540B80, CPad *>(this);</p>
<p>0AA8: call_method_return 0x540B80 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__SniperZoomOut&lt;thiscall, 0x540B80&gt;(): int</p>
<h4>CPad::GetGroupControlForward</h4>
<p>plugin::CallMethodAndReturn<bool, 0x541190, CPad *>(this);</p>
<p>0AA8: call_method_return 0x541190 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetGroupControlForward&lt;thiscall, 0x541190&gt;(): int</p>
<h4>CPad::GetGroupControlBack</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5411B0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5411B0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GetGroupControlBack&lt;thiscall, 0x5411B0&gt;(): int</p>
<h4>CPad::ConversationYesJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5411D0, CPad *>(this);</p>
<p>0AA8: call_method_return 0x5411D0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ConversationYesJustDown&lt;thiscall, 0x5411D0&gt;(): int</p>
<h4>CPad::ConversationNoJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x541200, CPad *>(this);</p>
<p>0AA8: call_method_return 0x541200 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__ConversationNoJustDown&lt;thiscall, 0x541200&gt;(): int</p>
<h4>CPad::GroupControlForwardJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x541230, CPad *>(this);</p>
<p>0AA8: call_method_return 0x541230 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GroupControlForwardJustDown&lt;thiscall, 0x541230&gt;(): int</p>
<h4>CPad::GroupControlBackJustDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x541260, CPad *>(this);</p>
<p>0AA8: call_method_return 0x541260 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPad__GroupControlBackJustDown&lt;thiscall, 0x541260&gt;(): int</p>
<h4>CPad::Clear</h4>
<p>plugin::CallMethod<0x541A70, CPad *, bool, bool>(this, enablePlayerControls, resetPhase);</p>
<p>0AA6: call_method 0x541A70 struct [CPad] num_params 2 pop 0 [enablePlayerControls] [resetPhase]</p>
<p>define function CPad__Clear&lt;thiscall, 0x541A70&gt;(enablePlayerControls, resetPhase)</p>
<h4>CPad::UpdatePads</h4>
<p>plugin::Call<0x541DD0>();</p>
<p>0AA5: call_function 0x541DD0 num_params 0 pop 0</p>
<p>define function CPad__UpdatePads&lt;cdecl, 0x541DD0&gt;()</p>
<h4>CPad::ClearMouseHistory</h4>
<p>plugin::Call<0x541BD0>();</p>
<p>0AA5: call_function 0x541BD0 num_params 0 pop 0</p>
<p>define function CPad__ClearMouseHistory&lt;cdecl, 0x541BD0&gt;()</p><h3 id="plugin_sagame_sacpathnodecpp">plugin_sa\game_sa\CPathNode.cpp</h3><h3 id="plugin_sagame_sacpedclothesdesccpp">plugin_sa\game_sa\CPedClothesDesc.cpp</h3><h4>CPedClothesDesc::Initialise</h4>
<p>plugin::CallMethod<0x5A78F0, CPedClothesDesc *>(this);</p>
<p>0AA6: call_method 0x5A78F0 struct [CPedClothesDesc] num_params 0 pop 0</p>
<p>define function CPedClothesDesc__Initialise&lt;thiscall, 0x5A78F0&gt;()</p>
<h4>CPedClothesDesc::SetModel</h4>
<p>plugin::CallMethod<0x5A7910, CPedClothesDesc *, unsigned int, int>(this, modelid, eClothesModelPart);</p>
<p>0AA6: call_method 0x5A7910 struct [CPedClothesDesc] num_params 2 pop 0 [modelid] [eClothesModelPart]</p>
<p>define function CPedClothesDesc__SetModel&lt;thiscall, 0x5A7910&gt;(modelid, eClothesModelPart)</p>
<h4>CPedClothesDesc::SetModel</h4>
<p>plugin::CallMethod<0x5A7920, CPedClothesDesc <em>, char const</em>, int>(this, model, eClothesModelPart);</p>
<p>0AA6: call_method 0x5A7920 struct [CPedClothesDesc] num_params 2 pop 0 [model] [eClothesModelPart]</p>
<p>define function CPedClothesDesc__SetModel&lt;thiscall, 0x5A7920&gt;(model, eClothesModelPart)</p>
<h4>CPedClothesDesc::GetIsWearingBalaclava</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A7950, CPedClothesDesc *>(this);</p>
<p>0AA8: call_method_return 0x5A7950 struct [CPedClothesDesc] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedClothesDesc__GetIsWearingBalaclava&lt;thiscall, 0x5A7950&gt;(): int</p>
<h4>CPedClothesDesc::HasVisibleNewHairCut</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A7970, CPedClothesDesc *, int>(this, arg1);</p>
<p>0AA8: call_method_return 0x5A7970 struct [CPedClothesDesc] num_params 1 pop 0 [arg1] func_ret [bool]</p>
<p>define function CPedClothesDesc__HasVisibleNewHairCut&lt;thiscall, 0x5A7970&gt;(arg1): int</p>
<h4>CPedClothesDesc::HasVisibleTattoo</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A79D0, CPedClothesDesc *>(this);</p>
<p>0AA8: call_method_return 0x5A79D0 struct [CPedClothesDesc] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedClothesDesc__HasVisibleTattoo&lt;thiscall, 0x5A79D0&gt;(): int</p>
<h4>CPedClothesDesc::CPedClothesDesc</h4>
<p>plugin::CallMethod<0x5A8020, CPedClothesDesc *>(this);</p>
<p>0AA6: call_method 0x5A8020 struct [CPedClothesDesc] num_params 0 pop 0</p>
<p>define function CPedClothesDesc__CPedClothesDesc&lt;thiscall, 0x5A8020&gt;()</p>
<h4>CPedClothesDesc::SetTextureAndModel</h4>
<p>plugin::CallMethod<0x5A8050, CPedClothesDesc *, unsigned int, unsigned int, int>(this, texture, model, eClothesTexturePart);</p>
<p>0AA6: call_method 0x5A8050 struct [CPedClothesDesc] num_params 3 pop 0 [texture] [model] [eClothesTexturePart]</p>
<p>define function CPedClothesDesc__SetTextureAndModel&lt;thiscall, 0x5A8050&gt;(texture, model, eClothesTexturePart)</p>
<h4>CPedClothesDesc::SetTextureAndModel</h4>
<p>plugin::CallMethod<0x5A8080, CPedClothesDesc <em>, char const</em>, char const*, int>(this, texturename, modelname, eClothesTexturePart);</p>
<p>0AA6: call_method 0x5A8080 struct [CPedClothesDesc] num_params 3 pop 0 [texturename] [modelname] [eClothesTexturePart]</p>
<p>define function CPedClothesDesc__SetTextureAndModel&lt;thiscall, 0x5A8080&gt;(texturename, modelname, eClothesTexturePart)</p><h3 id="plugin_sagame_sacpedgroupcpp">plugin_sa\game_sa\CPedGroup.cpp</h3><h4>CPedGroup::FindDistanceToFurthestMember</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CPedGroup *>(gaddrof(CPedGroup::FindDistanceToFurthestMember), this);</p>
<p>0AA8: call_method_return 0x5FB010 struct [CPedGroup] num_params 0 pop 0 func_ret [float]</p>
<h4>CPedGroup::FindDistanceToNearestMember</h4>
<p>plugin::CallMethodAndReturnDynGlobal<float, CPedGroup *, CPed **>(gaddrof(CPedGroup::FindDistanceToNearestMember), this, ppOutNearestMember);</p>
<p>0AA8: call_method_return 0x5FB0A0 struct [CPedGroup] num_params 1 pop 0 [ppOutNearestMember] func_ret [float]</p>
<h4>CPedGroup::Flush</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::Flush), this);</p>
<p>0AA6: call_method 0x5FB790 struct [CPedGroup] num_params 0 pop 0</p>
<p>define function CPedGroup__Flush&lt;thiscall, 0x5FB790&gt;()</p>
<h4>*CPedGroup::GetClosestGroupPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroup *, CPed *, float *>(gaddrof(CPedGroup::GetClosestGroupPed), this, ped, pOutDistance);</p>
<p>0AA8: call_method_return 0x5FACD0 struct [*CPedGroup] num_params 2 pop 0 [ped] [pOutDistance] func_ret [CPed *]</p>
<h4>CPedGroup::IsAnyoneUsingCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroup *, CVehicle const *>(gaddrof(CPedGroup::IsAnyoneUsingCar), this, vehicle);</p>
<p>0AA8: call_method_return 0x5F7DB0 struct [CPedGroup] num_params 1 pop 0 [vehicle] func_ret [bool]</p>
<h4>CPedGroup::PlayerGaveCommand_Attack</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *, CPed *, CPed *>(gaddrof(CPedGroup::PlayerGaveCommand_Attack), this, playerPed, ped);</p>
<p>0AA6: call_method 0x5F7CC0 struct [CPedGroup] num_params 2 pop 0 [playerPed] [ped]</p>
<p>define function CPedGroup__PlayerGaveCommand_Attack&lt;thiscall, 0x5F7CC0&gt;(playerPed, ped)</p>
<h4>CPedGroup::PlayerGaveCommand_Gather</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *, CPed *>(gaddrof(CPedGroup::PlayerGaveCommand_Gather), this, ped);</p>
<p>0AA6: call_method 0x5FAB60 struct [CPedGroup] num_params 1 pop 0 [ped]</p>
<p>define function CPedGroup__PlayerGaveCommand_Gather&lt;thiscall, 0x5FAB60&gt;(ped)</p>
<h4>CPedGroup::Process</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::Process), this);</p>
<p>0AA6: call_method 0x5FC7E0 struct [CPedGroup] num_params 0 pop 0</p>
<p>define function CPedGroup__Process&lt;thiscall, 0x5FC7E0&gt;()</p>
<h4>CPedGroup::RemoveAllFollowers</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(gaddrof(CPedGroup::RemoveAllFollowers), this);</p>
<p>0AA6: call_method 0x5FB7D0 struct [CPedGroup] num_params 0 pop 0</p>
<p>define function CPedGroup__RemoveAllFollowers&lt;thiscall, 0x5FB7D0&gt;()</p>
<h4>CPedGroup::Teleport</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *, CVector const *>(gaddrof(CPedGroup::Teleport), this, Pos);</p>
<p>0AA6: call_method 0x5F7AD0 struct [CPedGroup] num_params 1 pop 0 [Pos]</p>
<p>define function CPedGroup__Teleport&lt;thiscall, 0x5F7AD0&gt;(Pos)</p><h3 id="plugin_sagame_sacpedgroupintelligencecpp">plugin_sa\game_sa\CPedGroupIntelligence.cpp</h3><h4>CPedGroupIntelligence::AddEvent</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CEvent *>(gaddrof(CPedGroupIntelligence::AddEvent), this, event);</p>
<p>0AA8: call_method_return 0x5F7470 struct [CPedGroupIntelligence] num_params 1 pop 0 [event] func_ret [bool]</p>
<h4>CPedGroupIntelligence::ComputeDefaultTasks</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::ComputeDefaultTasks), this, ped);</p>
<p>0AA6: call_method 0x5F88D0 struct [CPedGroupIntelligence] num_params 1 pop 0 [ped]</p>
<p>define function CPedGroupIntelligence__ComputeDefaultTasks&lt;thiscall, 0x5F88D0&gt;(ped)</p>
<h4>*CPedGroupIntelligence::ComputeEventResponseTasks</h4>
<p>plugin::CallMethodAndReturnDynGlobal<void *, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ComputeEventResponseTasks), this);</p>
<p>0AA8: call_method_return 0x5FC440 struct [*CPedGroupIntelligence] num_params 0 pop 0 func_ret [void *]</p>
<h4>CPedGroupIntelligence::ComputeScriptCommandTasks</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ComputeScriptCommandTasks), this);</p>
<p>0AA6: call_method 0x5F7800 struct [CPedGroupIntelligence] num_params 0 pop 0</p>
<p>define function CPedGroupIntelligence__ComputeScriptCommandTasks&lt;thiscall, 0x5F7800&gt;()</p>
<h4>CPedGroupIntelligence::FlushTasks</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedTaskPair *, CPed *>(gaddrof(CPedGroupIntelligence::FlushTasks), this, taskpair, ped);</p>
<p>0AA6: call_method 0x5F79C0 struct [CPedGroupIntelligence] num_params 2 pop 0 [taskpair] [ped]</p>
<p>define function CPedGroupIntelligence__FlushTasks&lt;thiscall, 0x5F79C0&gt;(taskpair, ped)</p>
<h4>*CPedGroupIntelligence::GetTask</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *, CPedTaskPair const *>(gaddrof(CPedGroupIntelligence::GetTask), this, ped, taskpair);</p>
<p>0AA8: call_method_return 0x5F7660 struct [*CPedGroupIntelligence] num_params 2 pop 0 [ped] [taskpair] func_ret [CTask *]</p>
<h4>*CPedGroupIntelligence::GetTaskDefault</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskDefault), this, ped);</p>
<p>0AA8: call_method_return 0x5F86C0 struct [*CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [CTask *]</p>
<h4>*CPedGroupIntelligence::GetTaskScriptCommand</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskScriptCommand), this, ped);</p>
<p>0AA8: call_method_return 0x5F8690 struct [*CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [CTask *]</p>
<h4>*CPedGroupIntelligence::GetTaskSecondary</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CTask *, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskSecondary), this, ped);</p>
<p>0AA8: call_method_return 0x5F8620 struct [*CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [CTask *]</p>
<h4>CPedGroupIntelligence::GetTaskSecondarySlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed int, CPedGroupIntelligence *, CPed *>(gaddrof(CPedGroupIntelligence::GetTaskSecondarySlot), this, ped);</p>
<p>0AA8: call_method_return 0x5F8650 struct [CPedGroupIntelligence] num_params 1 pop 0 [ped] func_ret [signed int]</p>
<h4>CPedGroupIntelligence::IsCurrentEventValid</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::IsCurrentEventValid), this);</p>
<p>0AA8: call_method_return 0x5F77A0 struct [CPedGroupIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPedGroupIntelligence::IsGroupResponding</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::IsGroupResponding), this);</p>
<p>0AA8: call_method_return 0x5F7760 struct [CPedGroupIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPedGroupIntelligence::Process</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::Process), this);</p>
<p>0AA6: call_method 0x5FC4A0 struct [CPedGroupIntelligence] num_params 0 pop 0</p>
<p>define function CPedGroupIntelligence__Process&lt;thiscall, 0x5FC4A0&gt;()</p>
<h4>CPedGroupIntelligence::ProcessIgnorePlayerGroup</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ProcessIgnorePlayerGroup), this);</p>
<p>0AA6: call_method 0x5F87A0 struct [CPedGroupIntelligence] num_params 0 pop 0</p>
<p>define function CPedGroupIntelligence__ProcessIgnorePlayerGroup&lt;thiscall, 0x5F87A0&gt;()</p>
<h4>CPedGroupIntelligence::ReportAllBarScriptTasksFinished</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof(CPedGroupIntelligence::ReportAllBarScriptTasksFinished), this);</p>
<p>0AA6: call_method 0x5F8780 struct [CPedGroupIntelligence] num_params 0 pop 0</p>
<p>define function CPedGroupIntelligence__ReportAllBarScriptTasksFinished&lt;thiscall, 0x5F8780&gt;()</p>
<h4>CPedGroupIntelligence::ReportAllTasksFinished</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedTaskPair *>(gaddrof_o(CPedGroupIntelligence::ReportAllTasksFinished, void (CPedGroupIntelligence::*)(CPedTaskPair *)), this, taskpair);</p>
<p>0AA6: call_method 0x5F8750 struct [CPedGroupIntelligence] num_params 1 pop 0 [taskpair]</p>
<p>define function CPedGroupIntelligence__ReportAllTasksFinished&lt;thiscall, 0x5F8750&gt;(taskpair)</p>
<h4>CPedGroupIntelligence::ReportAllTasksFinished</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(gaddrof_o(CPedGroupIntelligence::ReportAllTasksFinished, void (CPedGroupIntelligence::*)()), this);</p>
<p>0AA6: call_method 0x5F8750 struct [CPedGroupIntelligence] num_params 0 pop 0</p>
<p>define function CPedGroupIntelligence__ReportAllTasksFinished&lt;thiscall, 0x5F8750&gt;()</p>
<h4>CPedGroupIntelligence::ReportFinishedTask</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupIntelligence *, CPed const *, CTask const *, CPedTaskPair *>(gaddrof_o(CPedGroupIntelligence::ReportFinishedTask, bool (CPedGroupIntelligence::*)(CPed const *, CTask const *, CPedTaskPair *)), this, ped, task, taskpair);</p>
<p>0AA8: call_method_return 0x5F86F0 struct [CPedGroupIntelligence] num_params 3 pop 0 [ped] [task] [taskpair] func_ret [bool]</p>
<h4>CPedGroupIntelligence::ReportFinishedTask</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPedGroupIntelligence *, CPed const *, CTask const <em>>(gaddrof_o(CPedGroupIntelligence::ReportFinishedTask, bool (CPedGroupIntelligence::</em>)(CPed const *, CTask const *)), this, ped, task);</p>
<p>0AA8: call_method_return 0x5F86F0 struct [CPedGroupIntelligence] num_params 2 pop 0 [ped] [task] func_ret [bool]</p>
<h4>CPedGroupIntelligence::SetDefaultTask</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *>(gaddrof(CPedGroupIntelligence::SetDefaultTask), this, ped, task);</p>
<p>0AA6: call_method 0x5F8580 struct [CPedGroupIntelligence] num_params 2 pop 0 [ped] [task]</p>
<p>define function CPedGroupIntelligence__SetDefaultTask&lt;thiscall, 0x5F8580&gt;(ped, task)</p>
<h4>CPedGroupIntelligence::SetDefaultTaskAllocator</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPedGroupDefaultTaskAllocator const *>(gaddrof(CPedGroupIntelligence::SetDefaultTaskAllocator), this, PedGroupDefaultTaskAllocator);</p>
<p>0AA6: call_method 0x5FB280 struct [CPedGroupIntelligence] num_params 1 pop 0 [PedGroupDefaultTaskAllocator]</p>
<p>define function CPedGroupIntelligence__SetDefaultTaskAllocator&lt;thiscall, 0x5FB280&gt;(PedGroupDefaultTaskAllocator)</p>
<h4>CPedGroupIntelligence::SetDefaultTaskAllocatorType</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetDefaultTaskAllocatorType), this, nPedGroupTaskAllocator);</p>
<p>0AA6: call_method 0x5FBB70 struct [CPedGroupIntelligence] num_params 1 pop 0 [nPedGroupTaskAllocator]</p>
<p>define function CPedGroupIntelligence__SetDefaultTaskAllocatorType&lt;thiscall, 0x5FBB70&gt;(nPedGroupTaskAllocator)</p>
<h4>CPedGroupIntelligence::SetEventResponseTask</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, bool, CTask const *, bool, CTask const *, int>(gaddrof(CPedGroupIntelligence::SetEventResponseTask), this, ped, arg3, task1, arg5, task2, arg7);</p>
<p>0AA6: call_method 0x5F8510 struct [CPedGroupIntelligence] num_params 6 pop 0 [ped] [arg3] [task1] [arg5] [task2] [arg7]</p>
<p>define function CPedGroupIntelligence__SetEventResponseTask&lt;thiscall, 0x5F8510&gt;(ped, arg3, task1, arg5, task2, arg7)</p>
<h4>CPedGroupIntelligence::SetEventResponseTaskAllocator</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetEventResponseTaskAllocator), this, a2);</p>
<p>0AA8: call_method_return 0x5F7440 struct [CPedGroupIntelligence] num_params 1 pop 0 [a2] func_ret [int]</p>
<h4>CPedGroupIntelligence::SetGroupDecisionMakerType</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPedGroupIntelligence *, int>(gaddrof(CPedGroupIntelligence::SetGroupDecisionMakerType), this, a2);</p>
<p>0AA8: call_method_return 0x5F7340 struct [CPedGroupIntelligence] num_params 1 pop 0 [a2] func_ret [int]</p>
<h4>CPedGroupIntelligence::SetPrimaryTaskAllocator</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CTaskAllocator *>(gaddrof(CPedGroupIntelligence::SetPrimaryTaskAllocator), this, taskAllocator);</p>
<p>0AA6: call_method 0x5F7410 struct [CPedGroupIntelligence] num_params 1 pop 0 [taskAllocator]</p>
<p>define function CPedGroupIntelligence__SetPrimaryTaskAllocator&lt;thiscall, 0x5F7410&gt;(taskAllocator)</p>
<h4>CPedGroupIntelligence::SetScriptCommandTask</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *>(gaddrof(CPedGroupIntelligence::SetScriptCommandTask), this, ped, task);</p>
<p>0AA6: call_method 0x5F8560 struct [CPedGroupIntelligence] num_params 2 pop 0 [ped] [task]</p>
<p>define function CPedGroupIntelligence__SetScriptCommandTask&lt;thiscall, 0x5F8560&gt;(ped, task)</p>
<h4>CPedGroupIntelligence::SetTask</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *, CPed *, CTask const *, CPedTaskPair *, int, bool>(gaddrof(CPedGroupIntelligence::SetTask), this, ped, task, taskpair, arg5, arg6);</p>
<p>0AA6: call_method 0x5F7540 struct [CPedGroupIntelligence] num_params 5 pop 0 [ped] [task] [taskpair] [arg5] [arg6]</p>
<p>define function CPedGroupIntelligence__SetTask&lt;thiscall, 0x5F7540&gt;(ped, task, taskpair, arg5, arg6)</p><h3 id="plugin_sagame_sacpedgroupmembershipcpp">plugin_sa\game_sa\CPedGroupMembership.cpp</h3><h4>CPedGroupMembership::AddFollower</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *>(gaddrof(CPedGroupMembership::AddFollower), this, ped);</p>
<p>0AA6: call_method 0x5F8020 struct [CPedGroupMembership] num_params 1 pop 0 [ped]</p>
<p>define function CPedGroupMembership__AddFollower&lt;thiscall, 0x5F8020&gt;(ped)</p>
<h4>CPedGroupMembership::AddMember</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *, int>(gaddrof(CPedGroupMembership::AddMember), this, member, memberID);</p>
<p>0AA6: call_method 0x5F6AE0 struct [CPedGroupMembership] num_params 2 pop 0 [member] [memberID]</p>
<p>define function CPedGroupMembership__AddMember&lt;thiscall, 0x5F6AE0&gt;(member, memberID)</p>
<h4>CPedGroupMembership::AppointNewLeader</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::AppointNewLeader), this);</p>
<p>0AA6: call_method 0x5FB240 struct [CPedGroupMembership] num_params 0 pop 0</p>
<p>define function CPedGroupMembership__AppointNewLeader&lt;thiscall, 0x5FB240&gt;()</p>
<h4>CPedGroupMembership::CountMembers</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPedGroupMembership *>(gaddrof(CPedGroupMembership::CountMembers), this);</p>
<p>0AA8: call_method_return 0x5F6A50 struct [CPedGroupMembership] num_params 0 pop 0 func_ret [int]</p>
<h4>CPedGroupMembership::CountMembersExcludingLeader</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPedGroupMembership *>(gaddrof(CPedGroupMembership::CountMembersExcludingLeader), this);</p>
<p>0AA8: call_method_return 0x5F6AA0 struct [CPedGroupMembership] num_params 0 pop 0 func_ret [int]</p>
<h4>CPedGroupMembership::Flush</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::Flush), this);</p>
<p>0AA6: call_method 0x5FB160 struct [CPedGroupMembership] num_params 0 pop 0</p>
<p>define function CPedGroupMembership__Flush&lt;thiscall, 0x5FB160&gt;()</p>
<h4>CPedGroupMembership::From</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(gaddrof(CPedGroupMembership::From), this, obj);</p>
<p>0AA6: call_method 0x5F7FE0 struct [CPedGroupMembership] num_params 1 pop 0 [obj]</p>
<p>define function CPedGroupMembership__From&lt;thiscall, 0x5F7FE0&gt;(obj)</p>
<h4>*CPedGroupMembership::GetLeader</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroupMembership *>(gaddrof(CPedGroupMembership::GetLeader), this);</p>
<p>0AA8: call_method_return 0x5F69A0 struct [*CPedGroupMembership] num_params 0 pop 0 func_ret [CPed *]</p>
<h4>*CPedGroupMembership::GetMember</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPed *, CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::GetMember), this, memberId);</p>
<p>0AA8: call_method_return 0x5F69B0 struct [*CPedGroupMembership] num_params 1 pop 0 [memberId] func_ret [CPed *]</p>
<h4>CPedGroupMembership::IsFollower</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsFollower), this, ped);</p>
<p>0AA8: call_method_return 0x5F69E0 struct [CPedGroupMembership] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CPedGroupMembership::IsLeader</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsLeader), this, ped);</p>
<p>0AA8: call_method_return 0x5F69C0 struct [CPedGroupMembership] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CPedGroupMembership::IsMember</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupMembership *, CPed const *>(gaddrof(CPedGroupMembership::IsMember), this, ped);</p>
<p>0AA8: call_method_return 0x5F6A10 struct [CPedGroupMembership] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CPedGroupMembership::Process</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(gaddrof(CPedGroupMembership::Process), this);</p>
<p>0AA6: call_method 0x5FBA60 struct [CPedGroupMembership] num_params 0 pop 0</p>
<p>define function CPedGroupMembership__Process&lt;thiscall, 0x5FBA60&gt;()</p>
<h4>CPedGroupMembership::RemoveAllFollowers</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, bool>(gaddrof(CPedGroupMembership::RemoveAllFollowers), this, bCreatedByGameOnly);</p>
<p>0AA6: call_method 0x5FB190 struct [CPedGroupMembership] num_params 1 pop 0 [bCreatedByGameOnly]</p>
<p>define function CPedGroupMembership__RemoveAllFollowers&lt;thiscall, 0x5FB190&gt;(bCreatedByGameOnly)</p>
<h4>CPedGroupMembership::RemoveMember</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::RemoveMember), this, memberID);</p>
<p>0AA6: call_method 0x5F80D0 struct [CPedGroupMembership] num_params 1 pop 0 [memberID]</p>
<p>define function CPedGroupMembership__RemoveMember&lt;thiscall, 0x5F80D0&gt;(memberID)</p>
<h4>CPedGroupMembership::RemoveNFollowers</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CPedGroupMembership *, int>(gaddrof(CPedGroupMembership::RemoveNFollowers), this, count);</p>
<p>0AA8: call_method_return 0x5FB1D0 struct [CPedGroupMembership] num_params 1 pop 0 [count] func_ret [char]</p>
<h4>CPedGroupMembership::SetLeader</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, CPed *>(gaddrof(CPedGroupMembership::SetLeader), this, ped);</p>
<p>0AA6: call_method 0x5FB9C0 struct [CPedGroupMembership] num_params 1 pop 0 [ped]</p>
<p>define function CPedGroupMembership__SetLeader&lt;thiscall, 0x5FB9C0&gt;(ped)</p>
<h4>CPedGroupMembership::GetObjectForPedToHold</h4>
<p>plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CPedGroupMembership::GetObjectForPedToHold));</p>
<p>0AA7: call_function_return 0x5F6950 num_params 0 pop 0 func_ret [signed int]</p>
<p>define function CPedGroupMembership__GetObjectForPedToHold&lt;cdecl, 0x5F6950&gt;(): int</p><h3 id="plugin_sagame_sacpedgroupplacercpp">plugin_sa\game_sa\CPedGroupPlacer.cpp</h3><h4>CPedGroupPlacer::PlaceChatGroup</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceChatGroup), this, pedtype, numOfPeds, origin, unused);</p>
<p>0AA8: call_method_return 0x5FCE80 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [unused] func_ret [bool]</p>
<h4>CPedGroupPlacer::PlaceFormationGroup</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceFormationGroup), this, pedtype, numOfPeds, origin, unused);</p>
<p>0AA8: call_method_return 0x5FC9B0 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [unused] func_ret [bool]</p>
<h4>CPedGroupPlacer::PlaceGroup</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector const *, int>(gaddrof(CPedGroupPlacer::PlaceGroup), this, pedtype, numOfPeds, origin, nGroupPlacerType);</p>
<p>0AA8: call_method_return 0x5FD810 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [nGroupPlacerType] func_ret [bool]</p>
<h4>CPedGroupPlacer::PlaceRandomGroup</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedGroupPlacer *, ePedType, int, CVector *, int>(gaddrof(CPedGroupPlacer::PlaceRandomGroup), this, pedtype, numOfPeds, origin, unused);</p>
<p>0AA8: call_method_return 0x5FD330 struct [CPedGroupPlacer] num_params 4 pop 0 [pedtype] [numOfPeds] [origin] [unused] func_ret [bool]</p><h3 id="plugin_sagame_sacpedgroupscpp">plugin_sa\game_sa\CPedGroups.cpp</h3><h4>CPedGroups::AddGroup</h4>
<p>plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CPedGroups::AddGroup));</p>
<p>0AA7: call_function_return 0x5FB800 num_params 0 pop 0 func_ret [signed int]</p>
<p>define function CPedGroups__AddGroup&lt;cdecl, 0x5FB800&gt;(): int</p>
<h4>CPedGroups::AreInSameGroup</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *, CPed *>(gaddrof(CPedGroups::AreInSameGroup), ped1, ped2);</p>
<p>0AA7: call_function_return 0x5F7F40 num_params 2 pop 2 [ped1] [ped2] func_ret [bool]</p>
<p>define function CPedGroups__AreInSameGroup&lt;cdecl, 0x5F7F40&gt;(ped1, ped2): int</p>
<h4>CPedGroups::GetGroupId</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, CPedGroup *>(gaddrof(CPedGroups::GetGroupId), pedgrp);</p>
<p>0AA7: call_function_return 0x5F7EE0 num_params 1 pop 1 [pedgrp] func_ret [signed int]</p>
<p>define function CPedGroups__GetGroupId&lt;cdecl, 0x5F7EE0&gt;(pedgrp): int</p>
<h4>*CPedGroups::GetPedsGroup</h4>
<p>plugin::CallAndReturnDynGlobal<char *, CPed *>(gaddrof(CPedGroups::GetPedsGroup), ped);</p>
<p>0AA7: call_function_return 0x5F7E80 num_params 1 pop 1 [ped] func_ret [char *]</p>
<p>define function CPedGroups__GetPedsGroup&lt;cdecl, 0x5F7E80&gt;(ped): int</p>
<h4>CPedGroups::IsGroupLeader</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CPedGroups::IsGroupLeader), ped);</p>
<p>0AA7: call_function_return 0x5F7E40 num_params 1 pop 1 [ped] func_ret [bool]</p>
<p>define function CPedGroups__IsGroupLeader&lt;cdecl, 0x5F7E40&gt;(ped): int</p>
<h4>CPedGroups::IsInPlayersGroup</h4>
<p>plugin::CallAndReturnDynGlobal<char, CPed *>(gaddrof(CPedGroups::IsInPlayersGroup), a1);</p>
<p>0AA7: call_function_return 0x5F7F10 num_params 1 pop 1 [a1] func_ret [char]</p>
<p>define function CPedGroups__IsInPlayersGroup&lt;cdecl, 0x5F7F10&gt;(a1): int</p>
<h4>CPedGroups::RemoveAllFollowersFromGroup</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPedGroups::RemoveAllFollowersFromGroup), groupID);</p>
<h4>CPedGroups::RemoveGroup</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPedGroups::RemoveGroup), groupID);</p><h3 id="plugin_sagame_sacpedikcpp">plugin_sa\game_sa\CPedIK.cpp</h3><h4>CPedIK::RotateTorso</h4>
<p>plugin::CallMethod<0x5FDDB0, CPedIK <em>, AnimBlendFrameData</em>, LimbOrientation&, bool>(this, bone, orientation, flag);</p>
<p>0AA6: call_method 0x5FDDB0 struct [CPedIK] num_params 3 pop 0 [bone] [orientation] [flag]</p>
<p>define function CPedIK__RotateTorso&lt;thiscall, 0x5FDDB0&gt;(bone, orientation, flag)</p>
<h4>CPedIK::PointGunInDirection</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5FDC00, CPedIK *, float, float, bool, float>(this, Z_angle, arg2, flag, arg4);</p>
<p>0AA8: call_method_return 0x5FDC00 struct [CPedIK] num_params 4 pop 0 [Z_angle] [arg2] [flag] [arg4] func_ret [bool]</p>
<p>define function CPedIK__PointGunInDirection&lt;thiscall, 0x5FDC00&gt;(Z_angle, arg2, flag, arg4): int</p>
<h4>CPedIK::PointGunAtPosition</h4>
<p>plugin::CallMethod<0x5FDE20, CPedIK *, CVector const&, float>(this, posn, arg2);</p>
<p>0AA6: call_method 0x5FDE20 struct [CPedIK] num_params 2 pop 0 [posn] [arg2]</p>
<p>define function CPedIK__PointGunAtPosition&lt;thiscall, 0x5FDE20&gt;(posn, arg2)</p>
<h4>CPedIK::GetWorldMatrix</h4>
<p>plugin::CallAndReturn<RwMatrixTag<em>, 0x5FD8F0, RwFrame</em>, RwMatrixTag*>(frame, transformMat);</p>
<p>0AA7: call_function_return 0x5FD8F0 num_params 2 pop 2 [frame] [transformMat] func_ret [RwMatrixTag*]</p>
<p>define function CPedIK__GetWorldMatrix&lt;cdecl, 0x5FD8F0&gt;(frame, transformMat): int</p><h3 id="plugin_sagame_sacpedintelligencecpp">plugin_sa\game_sa\CPedIntelligence.cpp</h3><h4>CPedIntelligence::SetPedDecisionMakerType</h4>
<p>plugin::CallMethod<0x600B50, CPedIntelligence *, int>(this, newtype);</p>
<p>0AA6: call_method 0x600B50 struct [CPedIntelligence] num_params 1 pop 0 [newtype]</p>
<p>define function CPedIntelligence__SetPedDecisionMakerType&lt;thiscall, 0x600B50&gt;(newtype)</p>
<h4>CPedIntelligence::SetPedDecisionMakerTypeInGroup</h4>
<p>plugin::CallMethod<0x600BB0, CPedIntelligence *, int>(this, newtype);</p>
<p>0AA6: call_method 0x600BB0 struct [CPedIntelligence] num_params 1 pop 0 [newtype]</p>
<p>define function CPedIntelligence__SetPedDecisionMakerTypeInGroup&lt;thiscall, 0x600BB0&gt;(newtype)</p>
<h4>CPedIntelligence::RestorePedDecisionMakerType</h4>
<p>plugin::CallMethod<0x600BC0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x600BC0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__RestorePedDecisionMakerType&lt;thiscall, 0x600BC0&gt;()</p>
<h4>CPedIntelligence::SetHearingRange</h4>
<p>plugin::CallMethod<0x600BE0, CPedIntelligence *, float>(this, range);</p>
<p>0AA6: call_method 0x600BE0 struct [CPedIntelligence] num_params 1 pop 0 [range]</p>
<p>define function CPedIntelligence__SetHearingRange&lt;thiscall, 0x600BE0&gt;(range)</p>
<h4>CPedIntelligence::SetSeeingRange</h4>
<p>plugin::CallMethod<0x600BF0, CPedIntelligence *, float>(this, range);</p>
<p>0AA6: call_method 0x600BF0 struct [CPedIntelligence] num_params 1 pop 0 [range]</p>
<p>define function CPedIntelligence__SetSeeingRange&lt;thiscall, 0x600BF0&gt;(range)</p>
<h4>CPedIntelligence::IsInHearingRange</h4>
<p>plugin::CallMethodAndReturn<bool, 0x600C00, CPedIntelligence *, CVector const&>(this, posn);</p>
<p>0AA8: call_method_return 0x600C00 struct [CPedIntelligence] num_params 1 pop 0 [posn] func_ret [bool]</p>
<p>define function CPedIntelligence__IsInHearingRange&lt;thiscall, 0x600C00&gt;(posn): int</p>
<h4>CPedIntelligence::IsInSeeingRange</h4>
<p>plugin::CallMethodAndReturn<bool, 0x600C60, CPedIntelligence *, CVector const&>(this, posn);</p>
<p>0AA8: call_method_return 0x600C60 struct [CPedIntelligence] num_params 1 pop 0 [posn] func_ret [bool]</p>
<p>define function CPedIntelligence__IsInSeeingRange&lt;thiscall, 0x600C60&gt;(posn): int</p>
<h4>CPedIntelligence::FindRespectedFriendInInformRange</h4>
<p>plugin::CallMethodAndReturn<bool, 0x600CF0, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x600CF0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedIntelligence__FindRespectedFriendInInformRange&lt;thiscall, 0x600CF0&gt;(): int</p>
<h4>CPedIntelligence::IsRespondingToEvent</h4>
<p>plugin::CallMethodAndReturn<bool, 0x600DB0, CPedIntelligence *, int>(this, event);</p>
<p>0AA8: call_method_return 0x600DB0 struct [CPedIntelligence] num_params 1 pop 0 [event] func_ret [bool]</p>
<p>define function CPedIntelligence__IsRespondingToEvent&lt;thiscall, 0x600DB0&gt;(event): int</p>
<h4>CPedIntelligence::AddTaskPhysResponse</h4>
<p>plugin::CallMethod<0x600DC0, CPedIntelligence <em>, CTask</em>, bool>(this, task, arg2);</p>
<p>0AA6: call_method 0x600DC0 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]</p>
<p>define function CPedIntelligence__AddTaskPhysResponse&lt;thiscall, 0x600DC0&gt;(task, arg2)</p>
<h4>CPedIntelligence::AddTaskEventResponseTemp</h4>
<p>plugin::CallMethod<0x600DE0, CPedIntelligence <em>, CTask</em>, bool>(this, task, arg2);</p>
<p>0AA6: call_method 0x600DE0 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]</p>
<p>define function CPedIntelligence__AddTaskEventResponseTemp&lt;thiscall, 0x600DE0&gt;(task, arg2)</p>
<h4>CPedIntelligence::AddTaskEventResponseNonTemp</h4>
<p>plugin::CallMethod<0x600E00, CPedIntelligence <em>, CTask</em>, bool>(this, task, arg2);</p>
<p>0AA6: call_method 0x600E00 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]</p>
<p>define function CPedIntelligence__AddTaskEventResponseNonTemp&lt;thiscall, 0x600E00&gt;(task, arg2)</p>
<h4>CPedIntelligence::AddTaskPrimaryMaybeInGroup</h4>
<p>plugin::CallMethod<0x600E20, CPedIntelligence <em>, CTask</em>, bool>(this, task, arg2);</p>
<p>0AA6: call_method 0x600E20 struct [CPedIntelligence] num_params 2 pop 0 [task] [arg2]</p>
<p>define function CPedIntelligence__AddTaskPrimaryMaybeInGroup&lt;thiscall, 0x600E20&gt;(task, arg2)</p>
<h4>CPedIntelligence::FindTaskByType</h4>
<p>plugin::CallMethodAndReturn<CTask*, 0x600EE0, CPedIntelligence *, int>(this, type);</p>
<p>0AA8: call_method_return 0x600EE0 struct [CPedIntelligence] num_params 1 pop 0 [type] func_ret [CTask*]</p>
<p>define function CPedIntelligence__FindTaskByType&lt;thiscall, 0x600EE0&gt;(type): int</p>
<h4>CPedIntelligence::GetTaskFighting</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleFight*, 0x600F30, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x600F30 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleFight*]</p>
<p>define function CPedIntelligence__GetTaskFighting&lt;thiscall, 0x600F30&gt;(): int</p>
<h4>CPedIntelligence::GetTaskUseGun</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleUseGun*, 0x600F70, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x600F70 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleUseGun*]</p>
<p>define function CPedIntelligence__GetTaskUseGun&lt;thiscall, 0x600F70&gt;(): int</p>
<h4>CPedIntelligence::GetTaskThrow</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleThrowProjectile*, 0x600FB0, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x600FB0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleThrowProjectile*]</p>
<p>define function CPedIntelligence__GetTaskThrow&lt;thiscall, 0x600FB0&gt;(): int</p>
<h4>CPedIntelligence::GetTaskHold</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleHoldEntity*, 0x600FF0, CPedIntelligence *, bool>(this, arg1);</p>
<p>0AA8: call_method_return 0x600FF0 struct [CPedIntelligence] num_params 1 pop 0 [arg1] func_ret [CTaskSimpleHoldEntity*]</p>
<p>define function CPedIntelligence__GetTaskHold&lt;thiscall, 0x600FF0&gt;(arg1): int</p>
<h4>CPedIntelligence::GetTaskSwim</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleSwim*, 0x601070, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601070 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleSwim*]</p>
<p>define function CPedIntelligence__GetTaskSwim&lt;thiscall, 0x601070&gt;(): int</p>
<h4>CPedIntelligence::GetTaskDuck</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleDuck*, 0x6010A0, CPedIntelligence *, bool>(this, arg1);</p>
<p>0AA8: call_method_return 0x6010A0 struct [CPedIntelligence] num_params 1 pop 0 [arg1] func_ret [CTaskSimpleDuck*]</p>
<p>define function CPedIntelligence__GetTaskDuck&lt;thiscall, 0x6010A0&gt;(arg1): int</p>
<h4>CPedIntelligence::GetTaskJetPack</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleJetPack*, 0x601110, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601110 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleJetPack*]</p>
<p>define function CPedIntelligence__GetTaskJetPack&lt;thiscall, 0x601110&gt;(): int</p>
<h4>CPedIntelligence::GetTaskInAir</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleInAir*, 0x601150, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601150 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleInAir*]</p>
<p>define function CPedIntelligence__GetTaskInAir&lt;thiscall, 0x601150&gt;(): int</p>
<h4>CPedIntelligence::GetTaskClimb</h4>
<p>plugin::CallMethodAndReturn<CTaskSimpleClimb*, 0x601180, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601180 struct [CPedIntelligence] num_params 0 pop 0 func_ret [CTaskSimpleClimb*]</p>
<p>define function CPedIntelligence__GetTaskClimb&lt;thiscall, 0x601180&gt;(): int</p>
<h4>CPedIntelligence::GetUsingParachute</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6011B0, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x6011B0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedIntelligence__GetUsingParachute&lt;thiscall, 0x6011B0&gt;(): int</p>
<h4>CPedIntelligence::SetTaskDuckSecondary</h4>
<p>plugin::CallMethod<0x601230, CPedIntelligence *, unsigned short>(this, arg1);</p>
<p>0AA6: call_method 0x601230 struct [CPedIntelligence] num_params 1 pop 0 [arg1]</p>
<p>define function CPedIntelligence__SetTaskDuckSecondary&lt;thiscall, 0x601230&gt;(arg1)</p>
<h4>CPedIntelligence::ClearTaskDuckSecondary</h4>
<p>plugin::CallMethod<0x601390, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x601390 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__ClearTaskDuckSecondary&lt;thiscall, 0x601390&gt;()</p>
<h4>CPedIntelligence::ClearTasks</h4>
<p>plugin::CallMethod<0x601420, CPedIntelligence *, bool, bool>(this, arg1, arg2);</p>
<p>0AA6: call_method 0x601420 struct [CPedIntelligence] num_params 2 pop 0 [arg1] [arg2]</p>
<p>define function CPedIntelligence__ClearTasks&lt;thiscall, 0x601420&gt;(arg1, arg2)</p>
<h4>CPedIntelligence::FlushImmediately</h4>
<p>plugin::CallMethod<0x601640, CPedIntelligence *, bool>(this, arg1);</p>
<p>0AA6: call_method 0x601640 struct [CPedIntelligence] num_params 1 pop 0 [arg1]</p>
<p>define function CPedIntelligence__FlushImmediately&lt;thiscall, 0x601640&gt;(arg1)</p>
<h4>CPedIntelligence::GetEffectInUse</h4>
<p>plugin::CallMethodAndReturn<C2dEffect*, 0x6018D0, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x6018D0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [C2dEffect*]</p>
<p>define function CPedIntelligence__GetEffectInUse&lt;thiscall, 0x6018D0&gt;(): int</p>
<h4>CPedIntelligence::SetEffectInUse</h4>
<p>plugin::CallMethod<0x6018E0, CPedIntelligence <em>, C2dEffect</em>>(this, arg1);</p>
<p>0AA6: call_method 0x6018E0 struct [CPedIntelligence] num_params 1 pop 0 [arg1]</p>
<p>define function CPedIntelligence__SetEffectInUse&lt;thiscall, 0x6018E0&gt;(arg1)</p>
<h4>CPedIntelligence::ProcessAfterProcCol</h4>
<p>plugin::CallMethod<0x6018F0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x6018F0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__ProcessAfterProcCol&lt;thiscall, 0x6018F0&gt;()</p>
<h4>CPedIntelligence::ProcessAfterPreRender</h4>
<p>plugin::CallMethod<0x6019B0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x6019B0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__ProcessAfterPreRender&lt;thiscall, 0x6019B0&gt;()</p>
<h4>CPedIntelligence::ProcessEventHandler</h4>
<p>plugin::CallMethod<0x601BB0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x601BB0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__ProcessEventHandler&lt;thiscall, 0x601BB0&gt;()</p>
<h4>CPedIntelligence::IsFriendlyWith</h4>
<p>plugin::CallMethodAndReturn<bool, 0x601BC0, CPedIntelligence *, CPed const&>(this, ped);</p>
<p>0AA8: call_method_return 0x601BC0 struct [CPedIntelligence] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CPedIntelligence__IsFriendlyWith&lt;thiscall, 0x601BC0&gt;(ped): int</p>
<h4>CPedIntelligence::IsThreatenedBy</h4>
<p>plugin::CallMethodAndReturn<bool, 0x601C30, CPedIntelligence *, CPed const&>(this, ped);</p>
<p>0AA8: call_method_return 0x601C30 struct [CPedIntelligence] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CPedIntelligence__IsThreatenedBy&lt;thiscall, 0x601C30&gt;(ped): int</p>
<h4>CPedIntelligence::Respects</h4>
<p>plugin::CallMethodAndReturn<bool, 0x601C90, CPedIntelligence *, CPed const&>(this, ped);</p>
<p>0AA8: call_method_return 0x601C90 struct [CPedIntelligence] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CPedIntelligence__Respects&lt;thiscall, 0x601C90&gt;(ped): int</p>
<h4>CPedIntelligence::IsInACarOrEnteringOne</h4>
<p>plugin::CallMethodAndReturn<bool, 0x601CC0, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601CC0 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedIntelligence__IsInACarOrEnteringOne&lt;thiscall, 0x601CC0&gt;(): int</p>
<h4>CPedIntelligence::AreFriends</h4>
<p>plugin::CallAndReturn<bool, 0x601D10, CPed const&, CPed const&>(ped1, ped2);</p>
<p>0AA7: call_function_return 0x601D10 num_params 2 pop 2 [ped1] [ped2] func_ret [bool]</p>
<p>define function CPedIntelligence__AreFriends&lt;cdecl, 0x601D10&gt;(ped1, ped2): int</p>
<h4>CPedIntelligence::IsPedGoingSomewhereOnFoot</h4>
<p>plugin::CallMethodAndReturn<bool, 0x601D50, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601D50 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedIntelligence__IsPedGoingSomewhereOnFoot&lt;thiscall, 0x601D50&gt;(): int</p>
<h4>CPedIntelligence::GetMoveStateFromGoToTask</h4>
<p>plugin::CallMethodAndReturn<int*, 0x601D70, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x601D70 struct [CPedIntelligence] num_params 0 pop 0 func_ret [int*]</p>
<p>define function CPedIntelligence__GetMoveStateFromGoToTask&lt;thiscall, 0x601D70&gt;(): int</p>
<h4>CPedIntelligence::FlushIntelligence</h4>
<p>plugin::CallMethod<0x601DA0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x601DA0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__FlushIntelligence&lt;thiscall, 0x601DA0&gt;()</p>
<h4>CPedIntelligence::TestForStealthKill</h4>
<p>plugin::CallMethodAndReturn<bool, 0x601E00, CPedIntelligence <em>, CPed</em>, bool>(this, pPed, arg2);</p>
<p>0AA8: call_method_return 0x601E00 struct [CPedIntelligence] num_params 2 pop 0 [pPed] [arg2] func_ret [bool]</p>
<p>define function CPedIntelligence__TestForStealthKill&lt;thiscall, 0x601E00&gt;(pPed, arg2): int</p>
<h4>CPedIntelligence::RecordEventForScript</h4>
<p>plugin::CallMethod<0x602050, CPedIntelligence *, int, int>(this, EventID, EventPriority);</p>
<p>0AA6: call_method 0x602050 struct [CPedIntelligence] num_params 2 pop 0 [EventID] [EventPriority]</p>
<p>define function CPedIntelligence__RecordEventForScript&lt;thiscall, 0x602050&gt;(EventID, EventPriority)</p>
<h4>CPedIntelligence::HasInterestingEntites</h4>
<p>plugin::CallMethodAndReturn<bool, 0x602080, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x602080 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedIntelligence__HasInterestingEntites&lt;thiscall, 0x602080&gt;(): int</p>
<h4>CPedIntelligence::IsInterestingEntity</h4>
<p>plugin::CallMethodAndReturn<bool, 0x6020A0, CPedIntelligence <em>, CEntity</em>>(this, pEntity);</p>
<p>0AA8: call_method_return 0x6020A0 struct [CPedIntelligence] num_params 1 pop 0 [pEntity] func_ret [bool]</p>
<p>define function CPedIntelligence__IsInterestingEntity&lt;thiscall, 0x6020A0&gt;(pEntity): int</p>
<h4>CPedIntelligence::LookAtInterestingEntities</h4>
<p>plugin::CallMethod<0x6020D0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x6020D0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__LookAtInterestingEntities&lt;thiscall, 0x6020D0&gt;()</p>
<h4>CPedIntelligence::RemoveAllInterestingEntities</h4>
<p>plugin::CallMethod<0x602320, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x602320 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__RemoveAllInterestingEntities&lt;thiscall, 0x602320&gt;()</p>
<h4>CPedIntelligence::IsPedGoingForCarDoor</h4>
<p>plugin::CallMethodAndReturn<bool, 0x602350, CPedIntelligence *>(this);</p>
<p>0AA8: call_method_return 0x602350 struct [CPedIntelligence] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPedIntelligence__IsPedGoingForCarDoor&lt;thiscall, 0x602350&gt;(): int</p>
<h4>CPedIntelligence::CanSeeEntityWithLights</h4>
<p>plugin::CallMethodAndReturn<float, 0x605550, CPedIntelligence <em>, CEntity const</em>, bool>(this, pEntity, arg2);</p>
<p>0AA8: call_method_return 0x605550 struct [CPedIntelligence] num_params 2 pop 0 [pEntity] [arg2] func_ret [float]</p>
<p>define function CPedIntelligence__CanSeeEntityWithLights&lt;thiscall, 0x605550&gt;(pEntity, arg2): float</p>
<h4>CPedIntelligence::ProcessStaticCounter</h4>
<p>plugin::CallMethod<0x605650, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x605650 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__ProcessStaticCounter&lt;thiscall, 0x605650&gt;()</p>
<h4>CPedIntelligence::ProcessFirst</h4>
<p>plugin::CallMethod<0x6073A0, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x6073A0 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__ProcessFirst&lt;thiscall, 0x6073A0&gt;()</p>
<h4>CPedIntelligence::Process</h4>
<p>plugin::CallMethod<0x608260, CPedIntelligence *>(this);</p>
<p>0AA6: call_method 0x608260 struct [CPedIntelligence] num_params 0 pop 0</p>
<p>define function CPedIntelligence__Process&lt;thiscall, 0x608260&gt;()</p>
<h4>CPedIntelligence::operator delete</h4>
<p>plugin::Call<0x6074E0, void*>(arg1);</p>
<p>0AA5: call_function 0x6074E0 num_params 1 pop 1 [arg1]</p>
<p>define function CPedIntelligence__operator delete&lt;cdecl, 0x6074E0&gt;(arg1)</p><h3 id="plugin_sagame_sacpedlistcpp">plugin_sa\game_sa\CPedList.cpp</h3><h4>CPedList::BuildListFromGroup_NoLeader</h4>
<p>plugin::CallMethodDynGlobal<CPedList *, CPedGroupMembership *>(gaddrof(CPedList::BuildListFromGroup_NoLeader), this, pedGroupMemberShip);</p>
<p>0AA6: call_method 0x699DD0 struct [CPedList] num_params 1 pop 0 [pedGroupMemberShip]</p>
<p>define function CPedList__BuildListFromGroup_NoLeader&lt;thiscall, 0x699DD0&gt;(pedGroupMemberShip)</p>
<h4>CPedList::BuildListFromGroup_NotInCar_NoLeader</h4>
<p>plugin::CallMethodDynGlobal<CPedList *, CPedGroupMembership *>(gaddrof(CPedList::BuildListFromGroup_NotInCar_NoLeader), this, pedGroupMembership);</p>
<p>0AA6: call_method 0x69A340 struct [CPedList] num_params 1 pop 0 [pedGroupMembership]</p>
<p>define function CPedList__BuildListFromGroup_NotInCar_NoLeader&lt;thiscall, 0x69A340&gt;(pedGroupMembership)</p>
<h4>CPedList::BuildListOfPedsOfPedType</h4>
<p>plugin::CallMethodDynGlobal<CPedList *, int>(gaddrof(CPedList::BuildListOfPedsOfPedType), this, pedtype);</p>
<p>0AA6: call_method 0x69A3B0 struct [CPedList] num_params 1 pop 0 [pedtype]</p>
<p>define function CPedList__BuildListOfPedsOfPedType&lt;thiscall, 0x69A3B0&gt;(pedtype)</p>
<h4>CPedList::Empty</h4>
<p>plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::Empty), this);</p>
<p>0AA6: call_method 0x699DB0 struct [CPedList] num_params 0 pop 0</p>
<p>define function CPedList__Empty&lt;thiscall, 0x699DB0&gt;()</p>
<h4>CPedList::ExtractPedsWithGuns</h4>
<p>plugin::CallMethodDynGlobal<CPedList *, CPedList *>(gaddrof(CPedList::ExtractPedsWithGuns), this, pedlist);</p>
<p>0AA6: call_method 0x69A4C0 struct [CPedList] num_params 1 pop 0 [pedlist]</p>
<p>define function CPedList__ExtractPedsWithGuns&lt;thiscall, 0x69A4C0&gt;(pedlist)</p>
<h4>CPedList::FillUpHoles</h4>
<p>plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::FillUpHoles), this);</p>
<p>0AA6: call_method 0x699E20 struct [CPedList] num_params 0 pop 0</p>
<p>define function CPedList__FillUpHoles&lt;thiscall, 0x699E20&gt;()</p>
<h4>CPedList::RemovePedsAttackingPedType</h4>
<p>plugin::CallMethodDynGlobal<CPedList *, int>(gaddrof(CPedList::RemovePedsAttackingPedType), this, pedtype);</p>
<p>0AA6: call_method 0x69A450 struct [CPedList] num_params 1 pop 0 [pedtype]</p>
<p>define function CPedList__RemovePedsAttackingPedType&lt;thiscall, 0x69A450&gt;(pedtype)</p>
<h4>CPedList::RemovePedsThatDontListenToPlayer</h4>
<p>plugin::CallMethodDynGlobal<CPedList *>(gaddrof(CPedList::RemovePedsThatDontListenToPlayer), this);</p>
<p>0AA6: call_method 0x69A420 struct [CPedList] num_params 0 pop 0</p>
<p>define function CPedList__RemovePedsThatDontListenToPlayer&lt;thiscall, 0x69A420&gt;()</p><h3 id="plugin_sagame_sacpedplacementcpp">plugin_sa\game_sa\CPedPlacement.cpp</h3><h4>CPedPlacement::FindZCoorForPed</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *>(gaddrof(CPedPlacement::FindZCoorForPed), pos);</p>
<p>0AA7: call_function_return 0x616920 num_params 1 pop 1 [pos] func_ret [bool]</p>
<p>define function CPedPlacement__FindZCoorForPed&lt;cdecl, 0x616920&gt;(pos): int</p>
<h4>CPedPlacement::IsPositionClearForPed</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector const *, float, int, CEntity **, unsigned char, unsigned char, unsigned char>(gaddrof(CPedPlacement::IsPositionClearForPed), pos, radius, maxNumObjects, pObjectList, bCheckVehicles, bCheckPeds, bCheckObjects);</p>
<p>0AA7: call_function_return 0x616860 num_params 7 pop 7 [pos] [radius] [maxNumObjects] [pObjectList] [bCheckVehicles] [bCheckPeds] [bCheckObjects] func_ret [bool]</p>
<p>define function CPedPlacement__IsPositionClearForPed&lt;cdecl, 0x616860&gt;(pos, radius, maxNumObjects, pObjectList, bCheckVehicles, bCheckPeds, bCheckObjects): int</p>
<h4>*CPedPlacement::IsPositionClearOfCars</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicle *, CVector const *>(gaddrof_o(CPedPlacement::IsPositionClearOfCars, CVehicle <em>(</em>)(CVector const *)), pos);</p>
<p>0AA7: call_function_return 0x616A40 num_params 1 pop 1 [pos] func_ret [CVehicle *]</p>
<p>define function CPedPlacement__IsPositionClearOfCars&lt;cdecl, 0x616A40&gt;(pos): int</p>
<h4>*CPedPlacement::IsPositionClearOfCars</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicle *, CPed const *>(gaddrof_o(CPedPlacement::IsPositionClearOfCars, CVehicle <em>(</em>)(CPed const *)), ped);</p>
<p>0AA7: call_function_return 0x616A40 num_params 1 pop 1 [ped] func_ret [CVehicle *]</p>
<p>define function CPedPlacement__IsPositionClearOfCars&lt;cdecl, 0x616A40&gt;(ped): int</p><h3 id="plugin_sagame_sacpedtaskpaircpp">plugin_sa\game_sa\CPedTaskPair.cpp</h3><h4>CPedTaskPair::Flush</h4>
<p>plugin::CallMethodDynGlobal<CPedTaskPair *>(gaddrof(CPedTaskPair::Flush), this);</p>
<p>0AA6: call_method 0x5E95B0 struct [CPedTaskPair] num_params 0 pop 0</p>
<p>define function CPedTaskPair__Flush&lt;thiscall, 0x5E95B0&gt;()</p><h3 id="plugin_sagame_sacpickupcpp">plugin_sa\game_sa\CPickup.cpp</h3><h4>CPickup::SetPosn</h4>
<p>plugin::CallMethod<0x454960, CPickup *, float, float, float>(this, x, y, z);</p>
<p>0AA6: call_method 0x454960 struct [CPickup] num_params 3 pop 0 [x] [y] [z]</p>
<p>define function CPickup__SetPosn&lt;thiscall, 0x454960&gt;(x, y, z)</p>
<h4>CPickup::GetXCoord</h4>
<p>plugin::CallMethodAndReturn<float, 0x4549F0, CPickup *>(this);</p>
<p>0AA8: call_method_return 0x4549F0 struct [CPickup] num_params 0 pop 0 func_ret [float]</p>
<p>define function CPickup__GetXCoord&lt;thiscall, 0x4549F0&gt;(): float</p>
<h4>CPickup::GetYCoord</h4>
<p>plugin::CallMethodAndReturn<float, 0x454A10, CPickup *>(this);</p>
<p>0AA8: call_method_return 0x454A10 struct [CPickup] num_params 0 pop 0 func_ret [float]</p>
<p>define function CPickup__GetYCoord&lt;thiscall, 0x454A10&gt;(): float</p>
<h4>CPickup::GetZCoord</h4>
<p>plugin::CallMethodAndReturn<float, 0x454A30, CPickup *>(this);</p>
<p>0AA8: call_method_return 0x454A30 struct [CPickup] num_params 0 pop 0 func_ret [float]</p>
<p>define function CPickup__GetZCoord&lt;thiscall, 0x454A30&gt;(): float</p>
<h4>CPickup::ExtractAmmoFromPickup</h4>
<p>plugin::CallMethod<0x454BE0, CPickup <em>, CPlayerPed</em>>(this, playerPed);</p>
<p>0AA6: call_method 0x454BE0 struct [CPickup] num_params 1 pop 0 [playerPed]</p>
<p>define function CPickup__ExtractAmmoFromPickup&lt;thiscall, 0x454BE0&gt;(playerPed)</p>
<h4>CPickup::IsVisible</h4>
<p>plugin::CallMethodAndReturn<bool, 0x454C70, CPickup *>(this);</p>
<p>0AA8: call_method_return 0x454C70 struct [CPickup] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPickup__IsVisible&lt;thiscall, 0x454C70&gt;(): int</p>
<h4>CPickup::GetRidOfObjects</h4>
<p>plugin::CallMethod<0x454CF0, CPickup *>(this);</p>
<p>0AA6: call_method 0x454CF0 struct [CPickup] num_params 0 pop 0</p>
<p>define function CPickup__GetRidOfObjects&lt;thiscall, 0x454CF0&gt;()</p>
<h4>CPickup::PickUpShouldBeInvisible</h4>
<p>plugin::CallMethodAndReturn<bool, 0x454D20, CPickup *>(this);</p>
<p>0AA8: call_method_return 0x454D20 struct [CPickup] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPickup__PickUpShouldBeInvisible&lt;thiscall, 0x454D20&gt;(): int</p>
<h4>CPickup::FindTextIndexForString</h4>
<p>plugin::Call<0x455500, char*>(message);</p>
<p>0AA5: call_function 0x455500 num_params 1 pop 1 [message]</p>
<p>define function CPickup__FindTextIndexForString&lt;cdecl, 0x455500&gt;(message)</p>
<h4>*CPickup::FindStringForTextIndex</h4>
<p>plugin::CallAndReturn<char const *, 0x455540, int>(index);</p>
<p>0AA7: call_function_return 0x455540 num_params 1 pop 1 [index] func_ret [char const *]</p>
<p>define function CPickup__FindStringForTextIndex&lt;cdecl, 0x455540&gt;(index): int</p>
<h4>CPickup::Remove</h4>
<p>plugin::CallMethod<0x4556C0, CPickup *>(this);</p>
<p>0AA6: call_method 0x4556C0 struct [CPickup] num_params 0 pop 0</p>
<p>define function CPickup__Remove&lt;thiscall, 0x4556C0&gt;()</p>
<h4>CPickup::GiveUsAPickUpObject</h4>
<p>plugin::CallMethod<0x4567E0, CPickup <em>, CObject</em>*, int>(this, pObject, objectPoolSlotIndex);</p>
<p>0AA6: call_method 0x4567E0 struct [CPickup] num_params 2 pop 0 [pObject] [objectPoolSlotIndex]</p>
<p>define function CPickup__GiveUsAPickUpObject&lt;thiscall, 0x4567E0&gt;(pObject, objectPoolSlotIndex)</p>
<h4>CPickup::Update</h4>
<p>plugin::CallMethodAndReturn<bool,0x457410, CPickup <em>, CPlayerPed</em>, CVehicle*, int>(this, playerPed, vehicle, playerId);</p>
<p>0AA8: call_method_return 0x457410 struct [CPickup] num_params 3 pop 0 [playerPed] [vehicle] [playerId] func_ret [bool]</p>
<p>define function CPickup__Update&lt;thiscall, 0x457410&gt;(playerPed, vehicle, playerId): int</p>
<h4>CPickup::ProcessGunShot</h4>
<p>plugin::CallMethod<0x4588B0, CPickup <em>, CVector</em>, CVector*>(this, origin, target);</p>
<p>0AA6: call_method 0x4588B0 struct [CPickup] num_params 2 pop 0 [origin] [target]</p>
<p>define function CPickup__ProcessGunShot&lt;thiscall, 0x4588B0&gt;(origin, target)</p><h3 id="plugin_sagame_sacpickupscpp">plugin_sa\game_sa\CPickups.cpp</h3><h4>CPickups::AddToCollectedPickupsArray</h4>
<p>plugin::Call<0x455240, int>(handle);</p>
<p>0AA5: call_function 0x455240 num_params 1 pop 1 [handle]</p>
<p>define function CPickups__AddToCollectedPickupsArray&lt;cdecl, 0x455240&gt;(handle)</p>
<h4>CPickups::CreatePickupCoorsCloseToCoors</h4>
<p>plugin::Call<0x458A80, float, float, float, float<em>, float</em>, float*>(in_x, in_y, in_z, out_x, out_y, out_z);</p>
<p>0AA5: call_function 0x458A80 num_params 6 pop 6 [in_x] [in_y] [in_z] [out_x] [out_y] [out_z]</p>
<p>define function CPickups__CreatePickupCoorsCloseToCoors&lt;cdecl, 0x458A80&gt;(in_x, in_y, in_z, out_x, out_y, out_z)</p>
<h4>CPickups::CreateSomeMoney</h4>
<p>plugin::Call<0x458970, CVector, int>(coors, amount);</p>
<p>0AA5: call_function 0x458970 num_params 2 pop 2 [coors] [amount]</p>
<p>define function CPickups__CreateSomeMoney&lt;cdecl, 0x458970&gt;(coors, amount)</p>
<h4>CPickups::DetonateMinesHitByGunShot</h4>
<p>plugin::Call<0x4590C0, CVector<em>, CVector</em>>(shotOrigin, shotTarget);</p>
<p>0AA5: call_function 0x4590C0 num_params 2 pop 2 [shotOrigin] [shotTarget]</p>
<p>define function CPickups__DetonateMinesHitByGunShot&lt;cdecl, 0x4590C0&gt;(shotOrigin, shotTarget)</p>
<h4>CPickups::DoCollectableEffects</h4>
<p>plugin::Call<0x455E20, CEntity*>(entity);</p>
<p>0AA5: call_function 0x455E20 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoCollectableEffects&lt;cdecl, 0x455E20&gt;(entity)</p>
<h4>CPickups::DoMineEffects</h4>
<p>plugin::Call<0x4560E0, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4560E0 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoMineEffects&lt;cdecl, 0x4560E0&gt;(entity)</p>
<h4>CPickups::DoMoneyEffects</h4>
<p>plugin::Call<0x454E80, CEntity*>(entity);</p>
<p>0AA5: call_function 0x454E80 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoMoneyEffects&lt;cdecl, 0x454E80&gt;(entity)</p>
<h4>CPickups::DoPickUpEffects</h4>
<p>plugin::Call<0x455720, CEntity*>(entity);</p>
<p>0AA5: call_function 0x455720 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoPickUpEffects&lt;cdecl, 0x455720&gt;(entity)</p>
<h4>CPickups::FindPickUpForThisObject</h4>
<p>plugin::CallAndReturn<CPickup<em>, 0x4551C0, CObject</em>>(object);</p>
<p>0AA7: call_function_return 0x4551C0 num_params 1 pop 1 [object] func_ret [CPickup*]</p>
<p>define function CPickups__FindPickUpForThisObject&lt;cdecl, 0x4551C0&gt;(object): int</p>
<h4>CPickups::GenerateNewOne</h4>
<p>plugin::CallAndReturn<int, 0x456F20, CVector, unsigned int, unsigned char, unsigned int, unsigned int, bool, char*>(coors, modelId, pickupType, ammo, moneyPerDay, isEmpty, message);</p>
<p>0AA7: call_function_return 0x456F20 num_params 7 pop 7 [coors] [modelId] [pickupType] [ammo] [moneyPerDay] [isEmpty] [message] func_ret [int]</p>
<p>define function CPickups__GenerateNewOne&lt;cdecl, 0x456F20&gt;(coors, modelId, pickupType, ammo, moneyPerDay, isEmpty, message): int</p>
<h4>CPickups::GenerateNewOne_WeaponType</h4>
<p>plugin::CallAndReturn<int, 0x457380, CVector, eWeaponType, unsigned char, unsigned int, bool, char*>(coors, weaponType, pickupType, ammo, isEmpty, message);</p>
<p>0AA7: call_function_return 0x457380 num_params 6 pop 6 [coors] [weaponType] [pickupType] [ammo] [isEmpty] [message] func_ret [int]</p>
<p>define function CPickups__GenerateNewOne_WeaponType&lt;cdecl, 0x457380&gt;(coors, weaponType, pickupType, ammo, isEmpty, message): int</p>
<h4>CPickups::GetActualPickupIndex</h4>
<p>plugin::CallAndReturn<int, 0x4552A0, int>(pickupIndex);</p>
<p>0AA7: call_function_return 0x4552A0 num_params 1 pop 1 [pickupIndex] func_ret [int]</p>
<p>define function CPickups__GetActualPickupIndex&lt;cdecl, 0x4552A0&gt;(pickupIndex): int</p>
<h4>CPickups::GetNewUniquePickupIndex</h4>
<p>plugin::CallAndReturn<int, 0x456A30, int>(pickupIndex);</p>
<p>0AA7: call_function_return 0x456A30 num_params 1 pop 1 [pickupIndex] func_ret [int]</p>
<p>define function CPickups__GetNewUniquePickupIndex&lt;cdecl, 0x456A30&gt;(pickupIndex): int</p>
<h4>CPickups::GetUniquePickupIndex</h4>
<p>plugin::CallAndReturn<int, 0x455280, int>(pickupIndex);</p>
<p>0AA7: call_function_return 0x455280 num_params 1 pop 1 [pickupIndex] func_ret [int]</p>
<p>define function CPickups__GetUniquePickupIndex&lt;cdecl, 0x455280&gt;(pickupIndex): int</p>
<h4>CPickups::GivePlayerGoodiesWithPickUpMI</h4>
<p>plugin::CallAndReturn<bool, 0x4564F0, unsigned short, int>(modelId, playerId);</p>
<p>0AA7: call_function_return 0x4564F0 num_params 2 pop 2 [modelId] [playerId] func_ret [bool]</p>
<p>define function CPickups__GivePlayerGoodiesWithPickUpMI&lt;cdecl, 0x4564F0&gt;(modelId, playerId): int</p>
<h4>CPickups::Init</h4>
<p>plugin::Call<0x454A70>();</p>
<p>0AA5: call_function 0x454A70 num_params 0 pop 0</p>
<p>define function CPickups__Init&lt;cdecl, 0x454A70&gt;()</p>
<h4>CPickups::IsPickUpPickedUp</h4>
<p>plugin::CallAndReturn<bool, 0x454B40, int>(pickupHandle);</p>
<p>0AA7: call_function_return 0x454B40 num_params 1 pop 1 [pickupHandle] func_ret [bool]</p>
<p>define function CPickups__IsPickUpPickedUp&lt;cdecl, 0x454B40&gt;(pickupHandle): int</p>
<h4>CPickups::Load</h4>
<p>plugin::CallAndReturn<bool, 0x5D35A0>();</p>
<p>0AA7: call_function_return 0x5D35A0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPickups__Load&lt;cdecl, 0x5D35A0&gt;(): int</p>
<h4>CPickups::ModelForWeapon</h4>
<p>plugin::CallAndReturn<int, 0x454AC0, eWeaponType>(weaponType);</p>
<p>0AA7: call_function_return 0x454AC0 num_params 1 pop 1 [weaponType] func_ret [int]</p>
<p>define function CPickups__ModelForWeapon&lt;cdecl, 0x454AC0&gt;(weaponType): int</p>
<h4>CPickups::PassTime</h4>
<p>plugin::Call<0x455200, unsigned int>(time);</p>
<p>0AA5: call_function 0x455200 num_params 1 pop 1 [time]</p>
<p>define function CPickups__PassTime&lt;cdecl, 0x455200&gt;(time)</p>
<h4>CPickups::PickedUpHorseShoe</h4>
<p>plugin::Call<0x455390>();</p>
<p>0AA5: call_function 0x455390 num_params 0 pop 0</p>
<p>define function CPickups__PickedUpHorseShoe&lt;cdecl, 0x455390&gt;()</p>
<h4>CPickups::PickedUpOyster</h4>
<p>plugin::Call<0x4552D0>();</p>
<p>0AA5: call_function 0x4552D0 num_params 0 pop 0</p>
<p>define function CPickups__PickedUpOyster&lt;cdecl, 0x4552D0&gt;()</p>
<h4>CPickups::PictureTaken</h4>
<p>plugin::Call<0x456A70>();</p>
<p>0AA5: call_function 0x456A70 num_params 0 pop 0</p>
<p>define function CPickups__PictureTaken&lt;cdecl, 0x456A70&gt;()</p>
<h4>CPickups::PlayerCanPickUpThisWeaponTypeAtThisMoment</h4>
<p>plugin::CallAndReturn<bool, 0x4554C0, eWeaponType>(weaponType);</p>
<p>0AA7: call_function_return 0x4554C0 num_params 1 pop 1 [weaponType] func_ret [bool]</p>
<p>define function CPickups__PlayerCanPickUpThisWeaponTypeAtThisMoment&lt;cdecl, 0x4554C0&gt;(weaponType): int</p>
<h4>CPickups::ReInit</h4>
<p>plugin::Call<0x456E60>();</p>
<p>0AA5: call_function 0x456E60 num_params 0 pop 0</p>
<p>define function CPickups__ReInit&lt;cdecl, 0x456E60&gt;()</p>
<h4>CPickups::RemoveMissionPickUps</h4>
<p>plugin::Call<0x456DE0>();</p>
<p>0AA5: call_function 0x456DE0 num_params 0 pop 0</p>
<p>define function CPickups__RemoveMissionPickUps&lt;cdecl, 0x456DE0&gt;()</p>
<h4>CPickups::RemovePickUp</h4>
<p>plugin::Call<0x4573D0, int>(pickupHandle);</p>
<p>0AA5: call_function 0x4573D0 num_params 1 pop 1 [pickupHandle]</p>
<p>define function CPickups__RemovePickUp&lt;cdecl, 0x4573D0&gt;(pickupHandle)</p>
<h4>CPickups::RemovePickUpsInArea</h4>
<p>plugin::Call<0x456D30, float, float, float, float, float, float>(cornerA_x, cornerA_y, cornerA_z, cornerB_x, cornerB_y, cornerB_z);</p>
<p>0AA5: call_function 0x456D30 num_params 6 pop 6 [cornerA_x] [cornerA_y] [cornerA_z] [cornerB_x] [cornerB_y] [cornerB_z]</p>
<p>define function CPickups__RemovePickUpsInArea&lt;cdecl, 0x456D30&gt;(cornerA_x, cornerA_y, cornerA_z, cornerB_x, cornerB_y, cornerB_z)</p>
<h4>CPickups::RemovePickupObjects</h4>
<p>plugin::Call<0x455470>();</p>
<p>0AA5: call_function 0x455470 num_params 0 pop 0</p>
<p>define function CPickups__RemovePickupObjects&lt;cdecl, 0x455470&gt;()</p>
<h4>CPickups::RemoveUnnecessaryPickups</h4>
<p>plugin::Call<0x4563A0, CVector const&, float>(posn, radius);</p>
<p>0AA5: call_function 0x4563A0 num_params 2 pop 2 [posn] [radius]</p>
<p>define function CPickups__RemoveUnnecessaryPickups&lt;cdecl, 0x4563A0&gt;(posn, radius)</p>
<h4>CPickups::RenderPickUpText</h4>
<p>plugin::Call<0x455000>();</p>
<p>0AA5: call_function 0x455000 num_params 0 pop 0</p>
<p>define function CPickups__RenderPickUpText&lt;cdecl, 0x455000&gt;()</p>
<h4>CPickups::Save</h4>
<p>plugin::CallAndReturn<bool, 0x5D3540>();</p>
<p>0AA7: call_function_return 0x5D3540 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPickups__Save&lt;cdecl, 0x5D3540&gt;(): int</p>
<h4>CPickups::TestForPickupsInBubble</h4>
<p>plugin::CallAndReturn<bool, 0x456450, CVector, float>(posn, radius);</p>
<p>0AA7: call_function_return 0x456450 num_params 2 pop 2 [posn] [radius] func_ret [bool]</p>
<p>define function CPickups__TestForPickupsInBubble&lt;cdecl, 0x456450&gt;(posn, radius): int</p>
<h4>CPickups::TryToMerge_WeaponType</h4>
<p>plugin::CallAndReturn<bool, 0x4555A0, CVector, eWeaponType, unsigned char, unsigned int, bool>(posn, weaponType, pickupType, ammo, arg4);</p>
<p>0AA7: call_function_return 0x4555A0 num_params 5 pop 5 [posn] [weaponType] [pickupType] [ammo] [arg4] func_ret [bool]</p>
<p>define function CPickups__TryToMerge_WeaponType&lt;cdecl, 0x4555A0&gt;(posn, weaponType, pickupType, ammo, arg4): int</p>
<h4>CPickups::Update</h4>
<p>plugin::Call<0x458DE0>();</p>
<p>0AA5: call_function 0x458DE0 num_params 0 pop 0</p>
<p>define function CPickups__Update&lt;cdecl, 0x458DE0&gt;()</p>
<h4>CPickups::UpdateMoneyPerDay</h4>
<p>plugin::Call<0x455680, int, unsigned short>(pickupHandle, money);</p>
<p>0AA5: call_function 0x455680 num_params 2 pop 2 [pickupHandle] [money]</p>
<p>define function CPickups__UpdateMoneyPerDay&lt;cdecl, 0x455680&gt;(pickupHandle, money)</p>
<h4>CPickups::WeaponForModel</h4>
<p>plugin::CallAndReturn<int, 0x454AE0, int>(modelId);</p>
<p>0AA7: call_function_return 0x454AE0 num_params 1 pop 1 [modelId] func_ret [int]</p>
<p>define function CPickups__WeaponForModel&lt;cdecl, 0x454AE0&gt;(modelId): int</p>
<h4>ModifyStringLabelForControlSetting</h4>
<p>plugin::Call<0x454B70, char*>(stringLabel);</p>
<p>0AA5: call_function 0x454B70 num_params 1 pop 1 [stringLabel]</p>
<p>define function ModifyStringLabelForControlSetting&lt;cdecl, 0x454B70&gt;(stringLabel)</p><h3 id="plugin_sagame_sacplayerinfocpp">plugin_sa\game_sa\CPlayerInfo.cpp</h3><h3 id="plugin_sagame_sacplayerpedcpp">plugin_sa\game_sa\CPlayerPed.cpp</h3><h4>CPlayerPed::CPlayerPed</h4>
<p>plugin::CallMethod<0x60D5B0, CPlayerPed *, int, bool>(this, playerId, bGroupCreated);</p>
<p>0AA6: call_method 0x60D5B0 struct [CPlayerPed] num_params 2 pop 0 [playerId] [bGroupCreated]</p>
<p>define function CPlayerPed__CPlayerPed&lt;thiscall, 0x60D5B0&gt;(playerId, bGroupCreated)</p>
<h4>CPlayerPed::RemovePlayerPed</h4>
<p>plugin::Call<0x6094A0, int>(playerId);</p>
<p>0AA5: call_function 0x6094A0 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__RemovePlayerPed&lt;cdecl, 0x6094A0&gt;(playerId)</p>
<h4>CPlayerPed::DeactivatePlayerPed</h4>
<p>plugin::Call<0x609520, int>(playerId);</p>
<p>0AA5: call_function 0x609520 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__DeactivatePlayerPed&lt;cdecl, 0x609520&gt;(playerId)</p>
<h4>CPlayerPed::ReactivatePlayerPed</h4>
<p>plugin::Call<0x609540, int>(playerId);</p>
<p>0AA5: call_function 0x609540 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__ReactivatePlayerPed&lt;cdecl, 0x609540&gt;(playerId)</p>
<h4>CPlayerPed::GetPadFromPlayer</h4>
<p>plugin::CallMethodAndReturn<CPad*, 0x609560, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x609560 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPad*]</p>
<p>define function CPlayerPed__GetPadFromPlayer&lt;thiscall, 0x609560&gt;(): int</p>
<h4>CPlayerPed::CanPlayerStartMission</h4>
<p>plugin::CallMethodAndReturn<bool, 0x609590, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x609590 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerPed__CanPlayerStartMission&lt;thiscall, 0x609590&gt;(): int</p>
<h4>CPlayerPed::IsHidden</h4>
<p>plugin::CallMethodAndReturn<bool, 0x609620, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x609620 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerPed__IsHidden&lt;thiscall, 0x609620&gt;(): int</p>
<h4>CPlayerPed::ReApplyMoveAnims</h4>
<p>plugin::CallMethod<0x609650, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x609650 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ReApplyMoveAnims&lt;thiscall, 0x609650&gt;()</p>
<h4>CPlayerPed::DoesPlayerWantNewWeapon</h4>
<p>plugin::CallMethodAndReturn<bool, 0x609710, CPlayerPed *, eWeaponType, bool>(this, weaponType, arg1);</p>
<p>0AA8: call_method_return 0x609710 struct [CPlayerPed] num_params 2 pop 0 [weaponType] [arg1] func_ret [bool]</p>
<p>define function CPlayerPed__DoesPlayerWantNewWeapon&lt;thiscall, 0x609710&gt;(weaponType, arg1): int</p>
<h4>CPlayerPed::ProcessPlayerWeapon</h4>
<p>plugin::CallMethod<0x6097F0, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x6097F0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessPlayerWeapon&lt;thiscall, 0x6097F0&gt;(pad)</p>
<h4>CPlayerPed::PickWeaponAllowedFor2Player</h4>
<p>plugin::CallMethod<0x609800, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x609800 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__PickWeaponAllowedFor2Player&lt;thiscall, 0x609800&gt;()</p>
<h4>CPlayerPed::UpdateCameraWeaponModes</h4>
<p>plugin::CallMethod<0x609830, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x609830 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__UpdateCameraWeaponModes&lt;thiscall, 0x609830&gt;(pad)</p>
<h4>CPlayerPed::ProcessAnimGroups</h4>
<p>plugin::CallMethod<0x6098F0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x6098F0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ProcessAnimGroups&lt;thiscall, 0x6098F0&gt;()</p>
<h4>CPlayerPed::ClearWeaponTarget</h4>
<p>plugin::CallMethod<0x609C80, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x609C80 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ClearWeaponTarget&lt;thiscall, 0x609C80&gt;()</p>
<h4>CPlayerPed::GetWeaponRadiusOnScreen</h4>
<p>plugin::CallMethodAndReturn<float, 0x609CD0, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x609CD0 struct [CPlayerPed] num_params 0 pop 0 func_ret [float]</p>
<p>define function CPlayerPed__GetWeaponRadiusOnScreen&lt;thiscall, 0x609CD0&gt;(): float</p>
<h4>CPlayerPed::PedCanBeTargettedVehicleWise</h4>
<p>plugin::CallAndReturn<bool, 0x609D90, CPed*>(ped);</p>
<p>0AA7: call_function_return 0x609D90 num_params 1 pop 1 [ped] func_ret [bool]</p>
<p>define function CPlayerPed__PedCanBeTargettedVehicleWise&lt;cdecl, 0x609D90&gt;(ped): int</p>
<h4>CPlayerPed::FindTargetPriority</h4>
<p>plugin::CallMethodAndReturn<float, 0x609DE0, CPlayerPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA8: call_method_return 0x609DE0 struct [CPlayerPed] num_params 1 pop 0 [entity] func_ret [float]</p>
<p>define function CPlayerPed__FindTargetPriority&lt;thiscall, 0x609DE0&gt;(entity): float</p>
<h4>CPlayerPed::Clear3rdPersonMouseTarget</h4>
<p>plugin::CallMethod<0x609ED0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x609ED0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__Clear3rdPersonMouseTarget&lt;thiscall, 0x609ED0&gt;()</p>
<h4>CPlayerPed::Busted</h4>
<p>plugin::CallMethod<0x609EF0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x609EF0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__Busted&lt;thiscall, 0x609EF0&gt;()</p>
<h4>CPlayerPed::SetWantedLevel</h4>
<p>plugin::CallMethod<0x609F10, CPlayerPed *, int>(this, level);</p>
<p>0AA6: call_method 0x609F10 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__SetWantedLevel&lt;thiscall, 0x609F10&gt;(level)</p>
<h4>CPlayerPed::SetWantedLevelNoDrop</h4>
<p>plugin::CallMethod<0x609F30, CPlayerPed *, int>(this, level);</p>
<p>0AA6: call_method 0x609F30 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__SetWantedLevelNoDrop&lt;thiscall, 0x609F30&gt;(level)</p>
<h4>CPlayerPed::CheatWantedLevel</h4>
<p>plugin::CallMethod<0x609F50, CPlayerPed *, int>(this, level);</p>
<p>0AA6: call_method 0x609F50 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__CheatWantedLevel&lt;thiscall, 0x609F50&gt;(level)</p>
<h4>CPlayerPed::CanIKReachThisTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x609F80, CPlayerPed <em>, CVector, CWeapon</em>, bool>(this, posn, weapon, arg2);</p>
<p>0AA8: call_method_return 0x609F80 struct [CPlayerPed] num_params 3 pop 0 [posn] [weapon] [arg2] func_ret [bool]</p>
<p>define function CPlayerPed__CanIKReachThisTarget&lt;thiscall, 0x609F80&gt;(posn, weapon, arg2): int</p>
<h4>CPlayerPed::GetPlayerInfoForThisPlayerPed</h4>
<p>plugin::CallMethodAndReturn<CPlayerInfo*, 0x609FF0, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x609FF0 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPlayerInfo*]</p>
<p>define function CPlayerPed__GetPlayerInfoForThisPlayerPed&lt;thiscall, 0x609FF0&gt;(): int</p>
<h4>CPlayerPed::DoStuffToGoOnFire</h4>
<p>plugin::CallMethod<0x60A020, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A020 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__DoStuffToGoOnFire&lt;thiscall, 0x60A020&gt;()</p>
<h4>CPlayerPed::AnnoyPlayerPed</h4>
<p>plugin::CallMethod<0x60A040, CPlayerPed *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x60A040 struct [CPlayerPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPlayerPed__AnnoyPlayerPed&lt;thiscall, 0x60A040&gt;(arg0)</p>
<h4>CPlayerPed::ClearAdrenaline</h4>
<p>plugin::CallMethod<0x60A070, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A070 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ClearAdrenaline&lt;thiscall, 0x60A070&gt;()</p>
<h4>CPlayerPed::DisbandPlayerGroup</h4>
<p>plugin::CallMethod<0x60A0A0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A0A0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__DisbandPlayerGroup&lt;thiscall, 0x60A0A0&gt;()</p>
<h4>CPlayerPed::MakeGroupRespondToPlayerTakingDamage</h4>
<p>plugin::CallMethod<0x60A110, CPlayerPed *, CEventDamage const&>(this, damageEvent);</p>
<p>0AA6: call_method 0x60A110 struct [CPlayerPed] num_params 1 pop 0 [damageEvent]</p>
<p>define function CPlayerPed__MakeGroupRespondToPlayerTakingDamage&lt;thiscall, 0x60A110&gt;(damageEvent)</p>
<h4>CPlayerPed::TellGroupToStartFollowingPlayer</h4>
<p>plugin::CallMethod<0x60A1D0, CPlayerPed *, bool, bool, bool>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x60A1D0 struct [CPlayerPed] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CPlayerPed__TellGroupToStartFollowingPlayer&lt;thiscall, 0x60A1D0&gt;(arg0, arg1, arg2)</p>
<h4>CPlayerPed::MakePlayerGroupDisappear</h4>
<p>plugin::CallMethod<0x60A440, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A440 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__MakePlayerGroupDisappear&lt;thiscall, 0x60A440&gt;()</p>
<h4>CPlayerPed::MakePlayerGroupReappear</h4>
<p>plugin::CallMethod<0x60A4B0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A4B0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__MakePlayerGroupReappear&lt;thiscall, 0x60A4B0&gt;()</p>
<h4>CPlayerPed::ResetSprintEnergy</h4>
<p>plugin::CallMethod<0x60A530, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A530 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ResetSprintEnergy&lt;thiscall, 0x60A530&gt;()</p>
<h4>CPlayerPed::HandleSprintEnergy</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60A550, CPlayerPed *, bool, float>(this, arg0, arg1);</p>
<p>0AA8: call_method_return 0x60A550 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1] func_ret [bool]</p>
<p>define function CPlayerPed__HandleSprintEnergy&lt;thiscall, 0x60A550&gt;(arg0, arg1): int</p>
<h4>CPlayerPed::ControlButtonSprint</h4>
<p>plugin::CallMethodAndReturn<float, 0x60A610, CPlayerPed *, eSprintType>(this, sprintType);</p>
<p>0AA8: call_method_return 0x60A610 struct [CPlayerPed] num_params 1 pop 0 [sprintType] func_ret [float]</p>
<p>define function CPlayerPed__ControlButtonSprint&lt;thiscall, 0x60A610&gt;(sprintType): float</p>
<h4>CPlayerPed::GetButtonSprintResults</h4>
<p>plugin::CallMethodAndReturn<float, 0x60A820, CPlayerPed *, eSprintType>(this, sprintType);</p>
<p>0AA8: call_method_return 0x60A820 struct [CPlayerPed] num_params 1 pop 0 [sprintType] func_ret [float]</p>
<p>define function CPlayerPed__GetButtonSprintResults&lt;thiscall, 0x60A820&gt;(sprintType): float</p>
<h4>CPlayerPed::ResetPlayerBreath</h4>
<p>plugin::CallMethod<0x60A8A0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A8A0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ResetPlayerBreath&lt;thiscall, 0x60A8A0&gt;()</p>
<h4>CPlayerPed::HandlePlayerBreath</h4>
<p>plugin::CallMethod<0x60A8D0, CPlayerPed *, bool, float>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x60A8D0 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPlayerPed__HandlePlayerBreath&lt;thiscall, 0x60A8D0&gt;(arg0, arg1)</p>
<h4>CPlayerPed::SetRealMoveAnim</h4>
<p>plugin::CallMethod<0x60A9C0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60A9C0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__SetRealMoveAnim&lt;thiscall, 0x60A9C0&gt;()</p>
<h4>CPlayerPed::MakeChangesForNewWeapon</h4>
<p>plugin::CallMethod<0x60B460, CPlayerPed *, eWeaponType>(this, weaponType);</p>
<p>0AA6: call_method 0x60B460 struct [CPlayerPed] num_params 1 pop 0 [weaponType]</p>
<p>define function CPlayerPed__MakeChangesForNewWeapon&lt;thiscall, 0x60B460&gt;(weaponType)</p>
<h4>LOSBlockedBetweenPeds</h4>
<p>plugin::CallAndReturn<bool, 0x60B550, CEntity<em>, CEntity</em>>(entity1, entity2);</p>
<p>0AA7: call_function_return 0x60B550 num_params 2 pop 2 [entity1] [entity2] func_ret [bool]</p>
<p>define function LOSBlockedBetweenPeds&lt;cdecl, 0x60B550&gt;(entity1, entity2): int</p>
<h4>CPlayerPed::Compute3rdPersonMouseTarget</h4>
<p>plugin::CallMethod<0x60B650, CPlayerPed *, bool>(this, meleeWeapon);</p>
<p>0AA6: call_method 0x60B650 struct [CPlayerPed] num_params 1 pop 0 [meleeWeapon]</p>
<p>define function CPlayerPed__Compute3rdPersonMouseTarget&lt;thiscall, 0x60B650&gt;(meleeWeapon)</p>
<h4>CPlayerPed::DrawTriangleForMouseRecruitPed</h4>
<p>plugin::CallMethod<0x60BA80, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60BA80 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__DrawTriangleForMouseRecruitPed&lt;thiscall, 0x60BA80&gt;()</p>
<h4>CPlayerPed::DoesTargetHaveToBeBroken</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60C0C0, CPlayerPed <em>, CEntity</em>, CWeapon*>(this, entity, weapon);</p>
<p>0AA8: call_method_return 0x60C0C0 struct [CPlayerPed] num_params 2 pop 0 [entity] [weapon] func_ret [bool]</p>
<p>define function CPlayerPed__DoesTargetHaveToBeBroken&lt;thiscall, 0x60C0C0&gt;(entity, weapon): int</p>
<h4>CPlayerPed::KeepAreaAroundPlayerClear</h4>
<p>plugin::CallMethod<0x60C1E0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x60C1E0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__KeepAreaAroundPlayerClear&lt;thiscall, 0x60C1E0&gt;()</p>
<h4>CPlayerPed::SetPlayerMoveBlendRatio</h4>
<p>plugin::CallMethod<0x60C520, CPlayerPed <em>, CVector</em>>(this, arg0);</p>
<p>0AA6: call_method 0x60C520 struct [CPlayerPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPlayerPed__SetPlayerMoveBlendRatio&lt;thiscall, 0x60C520&gt;(arg0)</p>
<h4>CPlayerPed::FindPedToAttack</h4>
<p>plugin::CallMethodAndReturn<CPed*, 0x60C5F0, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x60C5F0 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPed*]</p>
<p>define function CPlayerPed__FindPedToAttack&lt;thiscall, 0x60C5F0&gt;(): int</p>
<h4>CPlayerPed::ForceGroupToAlwaysFollow</h4>
<p>plugin::CallMethod<0x60C7C0, CPlayerPed *, bool>(this, enable);</p>
<p>0AA6: call_method 0x60C7C0 struct [CPlayerPed] num_params 1 pop 0 [enable]</p>
<p>define function CPlayerPed__ForceGroupToAlwaysFollow&lt;thiscall, 0x60C7C0&gt;(enable)</p>
<h4>CPlayerPed::ForceGroupToNeverFollow</h4>
<p>plugin::CallMethod<0x60C800, CPlayerPed *, bool>(this, enable);</p>
<p>0AA6: call_method 0x60C800 struct [CPlayerPed] num_params 1 pop 0 [enable]</p>
<p>define function CPlayerPed__ForceGroupToNeverFollow&lt;thiscall, 0x60C800&gt;(enable)</p>
<h4>CPlayerPed::MakeThisPedJoinOurGroup</h4>
<p>plugin::CallMethod<0x60C840, CPlayerPed <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x60C840 struct [CPlayerPed] num_params 1 pop 0 [ped]</p>
<p>define function CPlayerPed__MakeThisPedJoinOurGroup&lt;thiscall, 0x60C840&gt;(ped)</p>
<h4>CPlayerPed::PlayerWantsToAttack</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60CC50, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x60CC50 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerPed__PlayerWantsToAttack&lt;thiscall, 0x60CC50&gt;(): int</p>
<h4>CPlayerPed::SetInitialState</h4>
<p>plugin::CallMethod<0x60CD20, CPlayerPed *, bool>(this, bGroupCreated);</p>
<p>0AA6: call_method 0x60CD20 struct [CPlayerPed] num_params 1 pop 0 [bGroupCreated]</p>
<p>define function CPlayerPed__SetInitialState&lt;thiscall, 0x60CD20&gt;(bGroupCreated)</p>
<h4>CPlayerPed::MakeChangesForNewWeapon</h4>
<p>plugin::CallMethod<0x60D000, CPlayerPed *, int>(this, weaponSlot);</p>
<p>0AA6: call_method 0x60D000 struct [CPlayerPed] num_params 1 pop 0 [weaponSlot]</p>
<p>define function CPlayerPed__MakeChangesForNewWeapon&lt;thiscall, 0x60D000&gt;(weaponSlot)</p>
<h4>CPlayerPed::EvaluateTarget</h4>
<p>plugin::CallMethod<0x60D020, CPlayerPed <em>, CEntity</em>, CEntity*<em>, float</em>, float, float, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5);</p>
<p>0AA6: call_method 0x60D020 struct [CPlayerPed] num_params 6 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5]</p>
<p>define function CPlayerPed__EvaluateTarget&lt;thiscall, 0x60D020&gt;(target, outTarget, outTargetPriority, maxDistance, arg4, arg5)</p>
<h4>CPlayerPed::EvaluateNeighbouringTarget</h4>
<p>plugin::CallMethod<0x60D1C0, CPlayerPed <em>, CEntity</em>, CEntity*<em>, float</em>, float, float, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5);</p>
<p>0AA6: call_method 0x60D1C0 struct [CPlayerPed] num_params 6 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5]</p>
<p>define function CPlayerPed__EvaluateNeighbouringTarget&lt;thiscall, 0x60D1C0&gt;(target, outTarget, outTargetPriority, maxDistance, arg4, arg5)</p>
<h4>CPlayerPed::ProcessGroupBehaviour</h4>
<p>plugin::CallMethod<0x60D350, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x60D350 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessGroupBehaviour&lt;thiscall, 0x60D350&gt;(pad)</p>
<h4>CPlayerPed::PlayerHasJustAttackedSomeone</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60D5A0, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x60D5A0 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerPed__PlayerHasJustAttackedSomeone&lt;thiscall, 0x60D5A0&gt;(): int</p>
<h4>CPlayerPed::SetupPlayerPed</h4>
<p>plugin::Call<0x60D790, int>(playerId);</p>
<p>0AA5: call_function 0x60D790 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__SetupPlayerPed&lt;cdecl, 0x60D790&gt;(playerId)</p>
<h4>CPlayerPed::ProcessWeaponSwitch</h4>
<p>plugin::CallMethod<0x60D850, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x60D850 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessWeaponSwitch&lt;thiscall, 0x60D850&gt;(pad)</p>
<h4>CPlayerPed::FindWeaponLockOnTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60DC50, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x60DC50 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerPed__FindWeaponLockOnTarget&lt;thiscall, 0x60DC50&gt;(): int</p>
<h4>CPlayerPed::FindNextWeaponLockOnTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60E530, CPlayerPed <em>, CEntity</em>, bool>(this, arg0, arg1);</p>
<p>0AA8: call_method_return 0x60E530 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1] func_ret [bool]</p>
<p>define function CPlayerPed__FindNextWeaponLockOnTarget&lt;thiscall, 0x60E530&gt;(arg0, arg1): int</p>
<h4>CPlayerPed::GetWantedLevel</h4>
<p>plugin::CallMethodAndReturn<int, 0x41BE60, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x41BE60 struct [CPlayerPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPlayerPed__GetWantedLevel&lt;thiscall, 0x41BE60&gt;(): int</p><h3 id="plugin_sagame_sacpointlightscpp">plugin_sa\game_sa\CPointLights.cpp</h3><h4>CPointLights::Init</h4>
<p>plugin::Call<0x6FFB40>();</p>
<p>0AA5: call_function 0x6FFB40 num_params 0 pop 0</p>
<p>define function CPointLights__Init&lt;cdecl, 0x6FFB40&gt;()</p>
<h4>CPointLights::GenerateLightsAffectingObject</h4>
<p>plugin::CallAndReturn<float, 0x6FFBB0, CVector const<em>, float</em>, CEntity*>(point, totalLighting, entity);</p>
<p>0AA7: call_function_return 0x6FFBB0 num_params 3 pop 3 [point] [totalLighting] [entity] func_ret [float]</p>
<p>define function CPointLights__GenerateLightsAffectingObject&lt;cdecl, 0x6FFBB0&gt;(point, totalLighting, entity): float</p>
<h4>CPointLights::GetLightMultiplier</h4>
<p>plugin::CallAndReturn<float, 0x6FFE70, CVector const*>(point);</p>
<p>0AA7: call_function_return 0x6FFE70 num_params 1 pop 1 [point] func_ret [float]</p>
<p>define function CPointLights__GetLightMultiplier&lt;cdecl, 0x6FFE70&gt;(point): float</p>
<h4>CPointLights::RemoveLightsAffectingObject</h4>
<p>plugin::Call<0x6FFFE0>();</p>
<p>0AA5: call_function 0x6FFFE0 num_params 0 pop 0</p>
<p>define function CPointLights__RemoveLightsAffectingObject&lt;cdecl, 0x6FFFE0&gt;()</p>
<h4>CPointLights::ProcessVerticalLineUsingCache</h4>
<p>plugin::CallAndReturn<bool, 0x6FFFF0, CVector, float*>(point, outZ);</p>
<p>0AA7: call_function_return 0x6FFFF0 num_params 2 pop 2 [point] [outZ] func_ret [bool]</p>
<p>define function CPointLights__ProcessVerticalLineUsingCache&lt;cdecl, 0x6FFFF0&gt;(point, outZ): int</p>
<h4>CPointLights::AddLight</h4>
<p>plugin::Call<0x7000E0, unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool, CEntity*>(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows, entityAffected);</p>
<p>0AA5: call_function 0x7000E0 num_params 10 pop 10 [lightType] [point] [direction] [radius] [red] [green] [blue] [fogType] [generateExtraShadows] [entityAffected]</p>
<p>define function CPointLights__AddLight&lt;cdecl, 0x7000E0&gt;(lightType, point, direction, radius, red, green, blue, fogType, generateExtraShadows, entityAffected)</p>
<h4>CPointLights::RenderFogEffect</h4>
<p>plugin::Call<0x7002D0>();</p>
<p>0AA5: call_function 0x7002D0 num_params 0 pop 0</p>
<p>define function CPointLights__RenderFogEffect&lt;cdecl, 0x7002D0&gt;()</p><h3 id="plugin_sagame_sacpointlistcpp">plugin_sa\game_sa\CPointList.cpp</h3><h4>CPointList::Empty</h4>
<p>plugin::CallMethodDynGlobal<CPointList *>(gaddrof(CPointList::Empty), this);</p>
<p>0AA6: call_method 0x699F00 struct [CPointList] num_params 0 pop 0</p>
<p>define function CPointList__Empty&lt;thiscall, 0x699F00&gt;()</p><h3 id="plugin_sagame_sacpoolscpp">plugin_sa\game_sa\CPools.cpp</h3><h4>CPools::CheckBuildingAtomics</h4>
<p>plugin::CallAndReturn<int, 0x550170>();</p>
<p>0AA7: call_function_return 0x550170 num_params 0 pop 0 func_ret [int]</p>
<p>define function CPools__CheckBuildingAtomics&lt;cdecl, 0x550170&gt;(): int</p>
<h4>CPools::CheckPoolsEmpty</h4>
<p>plugin::Call<0x551950>();</p>
<p>0AA5: call_function 0x551950 num_params 0 pop 0</p>
<p>define function CPools__CheckPoolsEmpty&lt;cdecl, 0x551950&gt;()</p>
<h4>CPools::GetObject</h4>
<p>plugin::CallAndReturn<CObject*, 0x550050, int>(handle);</p>
<p>0AA7: call_function_return 0x550050 num_params 1 pop 1 [handle] func_ret [CObject*]</p>
<p>define function CPools__GetObject&lt;cdecl, 0x550050&gt;(handle): int</p>
<h4>CPools::GetObjectRef</h4>
<p>plugin::CallAndReturn<int, 0x550020, CObject*>(object);</p>
<p>0AA7: call_function_return 0x550020 num_params 1 pop 1 [object] func_ret [int]</p>
<p>define function CPools__GetObjectRef&lt;cdecl, 0x550020&gt;(object): int</p>
<h4>CPools::GetPed</h4>
<p>plugin::CallAndReturn<CPed*, 0x54FF90, int>(handle);</p>
<p>0AA7: call_function_return 0x54FF90 num_params 1 pop 1 [handle] func_ret [CPed*]</p>
<p>define function CPools__GetPed&lt;cdecl, 0x54FF90&gt;(handle): int</p>
<h4>CPools::GetPedRef</h4>
<p>plugin::CallAndReturn<int, 0x54FF60, CPed*>(ped);</p>
<p>0AA7: call_function_return 0x54FF60 num_params 1 pop 1 [ped] func_ret [int]</p>
<p>define function CPools__GetPedRef&lt;cdecl, 0x54FF60&gt;(ped): int</p>
<h4>CPools::GetVehicle</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x54FFF0, int>(handle);</p>
<p>0AA7: call_function_return 0x54FFF0 num_params 1 pop 1 [handle] func_ret [CVehicle*]</p>
<p>define function CPools__GetVehicle&lt;cdecl, 0x54FFF0&gt;(handle): int</p>
<h4>CPools::GetVehicleRef</h4>
<p>plugin::CallAndReturn<int, 0x54FFC0, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x54FFC0 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CPools__GetVehicleRef&lt;cdecl, 0x54FFC0&gt;(vehicle): int</p>
<h4>CPools::Initialise</h4>
<p>plugin::Call<0x550F10>();</p>
<p>0AA5: call_function 0x550F10 num_params 0 pop 0</p>
<p>define function CPools__Initialise&lt;cdecl, 0x550F10&gt;()</p>
<h4>CPools::Load</h4>
<p>plugin::CallAndReturn<bool, 0x5D0890>();</p>
<p>0AA7: call_function_return 0x5D0890 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__Load&lt;cdecl, 0x5D0890&gt;(): int</p>
<h4>CPools::LoadObjectPool</h4>
<p>plugin::CallAndReturn<bool, 0x5D4A40>();</p>
<p>0AA7: call_function_return 0x5D4A40 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__LoadObjectPool&lt;cdecl, 0x5D4A40&gt;(): int</p>
<h4>CPools::LoadPedPool</h4>
<p>plugin::CallAndReturn<bool, 0x5D2D70>();</p>
<p>0AA7: call_function_return 0x5D2D70 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__LoadPedPool&lt;cdecl, 0x5D2D70&gt;(): int</p>
<h4>CPools::LoadVehiclePool</h4>
<p>plugin::CallAndReturn<bool, 0x5D2A20>();</p>
<p>0AA7: call_function_return 0x5D2A20 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__LoadVehiclePool&lt;cdecl, 0x5D2A20&gt;(): int</p>
<h4>CPools::MakeSureSlotInObjectPoolIsEmpty</h4>
<p>plugin::Call<0x550080, int>(slot);</p>
<p>0AA5: call_function 0x550080 num_params 1 pop 1 [slot]</p>
<p>define function CPools__MakeSureSlotInObjectPoolIsEmpty&lt;cdecl, 0x550080&gt;(slot)</p>
<h4>CPools::Save</h4>
<p>plugin::CallAndReturn<bool, 0x5D0880>();</p>
<p>0AA7: call_function_return 0x5D0880 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__Save&lt;cdecl, 0x5D0880&gt;(): int</p>
<h4>CPools::SaveObjectPool</h4>
<p>plugin::CallAndReturn<bool, 0x5D4940>();</p>
<p>0AA7: call_function_return 0x5D4940 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__SaveObjectPool&lt;cdecl, 0x5D4940&gt;(): int</p>
<h4>CPools::SavePedPool</h4>
<p>plugin::CallAndReturn<bool, 0x5D4B40>();</p>
<p>0AA7: call_function_return 0x5D4B40 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__SavePedPool&lt;cdecl, 0x5D4B40&gt;(): int</p>
<h4>CPools::SaveVehiclePool</h4>
<p>plugin::CallAndReturn<bool, 0x5D4800>();</p>
<p>0AA7: call_function_return 0x5D4800 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPools__SaveVehiclePool&lt;cdecl, 0x5D4800&gt;(): int</p>
<h4>CPools::ShutDown</h4>
<p>plugin::Call<0x5519F0>();</p>
<p>0AA5: call_function 0x5519F0 num_params 0 pop 0</p>
<p>define function CPools__ShutDown&lt;cdecl, 0x5519F0&gt;()</p><h3 id="plugin_sagame_sacpopcyclecpp">plugin_sa\game_sa\CPopCycle.cpp</h3><h4>CPopCycle::FindNewPedType</h4>
<p>plugin::CallAndReturn<bool, 0x60FBD0, ePedType<em>, int</em>, bool, bool>(arg1, modelindex, arg3, arg4);</p>
<p>0AA7: call_function_return 0x60FBD0 num_params 4 pop 4 [arg1] [modelindex] [arg3] [arg4] func_ret [bool]</p>
<p>define function CPopCycle__FindNewPedType&lt;cdecl, 0x60FBD0&gt;(arg1, modelindex, arg3, arg4): int</p>
<h4>CPopCycle::GetCurrentPercOther_Peds</h4>
<p>plugin::CallAndReturn<float, 0x610310>();</p>
<p>0AA7: call_function_return 0x610310 num_params 0 pop 0 func_ret [float]</p>
<p>define function CPopCycle__GetCurrentPercOther_Peds&lt;cdecl, 0x610310&gt;(): float</p>
<h4>CPopCycle::Initialise</h4>
<p>plugin::Call<0x5BC090>();</p>
<p>0AA5: call_function 0x5BC090 num_params 0 pop 0</p>
<p>define function CPopCycle__Initialise&lt;cdecl, 0x5BC090&gt;()</p>
<h4>CPopCycle::IsPedAppropriateForCurrentZone</h4>
<p>plugin::CallAndReturn<bool, 0x610150, int>(modelindex);</p>
<p>0AA7: call_function_return 0x610150 num_params 1 pop 1 [modelindex] func_ret [bool]</p>
<p>define function CPopCycle__IsPedAppropriateForCurrentZone&lt;cdecl, 0x610150&gt;(modelindex): int</p>
<h4>CPopCycle::IsPedInGroup</h4>
<p>plugin::CallAndReturn<bool, 0x610210, int, int>(modelIndex, PopCycle_Group);</p>
<p>0AA7: call_function_return 0x610210 num_params 2 pop 2 [modelIndex] [PopCycle_Group] func_ret [bool]</p>
<p>define function CPopCycle__IsPedInGroup&lt;cdecl, 0x610210&gt;(modelIndex, PopCycle_Group): int</p>
<h4>CPopCycle::PedIsAcceptableInCurrentZone</h4>
<p>plugin::CallAndReturn<bool, 0x610720, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x610720 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopCycle__PedIsAcceptableInCurrentZone&lt;cdecl, 0x610720&gt;(modelIndex): int</p>
<h4>CPopCycle::PickARandomGroupOfOtherPeds</h4>
<p>plugin::CallAndReturn<int, 0x610420>();</p>
<p>0AA7: call_function_return 0x610420 num_params 0 pop 0 func_ret [int]</p>
<p>define function CPopCycle__PickARandomGroupOfOtherPeds&lt;cdecl, 0x610420&gt;(): int</p>
<h4>CPopCycle::PlayerKilledADealer</h4>
<p>plugin::Call<0x610490>();</p>
<p>0AA5: call_function 0x610490 num_params 0 pop 0</p>
<p>define function CPopCycle__PlayerKilledADealer&lt;cdecl, 0x610490&gt;()</p>
<h4>CPopCycle::Update</h4>
<p>plugin::Call<0x610BF0>();</p>
<p>0AA5: call_function 0x610BF0 num_params 0 pop 0</p>
<p>define function CPopCycle__Update&lt;cdecl, 0x610BF0&gt;()</p>
<h4>CPopCycle::UpdateAreaDodgyness</h4>
<p>plugin::Call<0x610560>();</p>
<p>0AA5: call_function 0x610560 num_params 0 pop 0</p>
<p>define function CPopCycle__UpdateAreaDodgyness&lt;cdecl, 0x610560&gt;()</p>
<h4>CPopCycle::UpdateDealerStrengths</h4>
<p>plugin::Call<0x6104B0>();</p>
<p>0AA5: call_function 0x6104B0 num_params 0 pop 0</p>
<p>define function CPopCycle__UpdateDealerStrengths&lt;cdecl, 0x6104B0&gt;()</p>
<h4>CPopCycle::UpdatePercentages</h4>
<p>plugin::Call<0x610770>();</p>
<p>0AA5: call_function 0x610770 num_params 0 pop 0</p>
<p>define function CPopCycle__UpdatePercentages&lt;cdecl, 0x610770&gt;()</p><h3 id="plugin_sagame_sacprojectileinfocpp">plugin_sa\game_sa\CProjectileInfo.cpp</h3><h4>CProjectileInfo::Initialise</h4>
<p>plugin::Call<0x737B40>();</p>
<p>0AA5: call_function 0x737B40 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Initialise&lt;cdecl, 0x737B40&gt;()</p>
<h4>CProjectileInfo::RemoveFXSystem</h4>
<p>plugin::Call<0x737B80, unsigned char>(bInstantly);</p>
<p>0AA5: call_function 0x737B80 num_params 1 pop 1 [bInstantly]</p>
<p>define function CProjectileInfo__RemoveFXSystem&lt;cdecl, 0x737B80&gt;(bInstantly)</p>
<h4>CProjectileInfo::Shutdown</h4>
<p>plugin::Call<0x737BC0>();</p>
<p>0AA5: call_function 0x737BC0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Shutdown&lt;cdecl, 0x737BC0&gt;()</p>
<h4>CProjectileInfo::GetProjectileInfo</h4>
<p>plugin::CallAndReturn<CProjectileInfo*, 0x737BF0, int>(infoId);</p>
<p>0AA7: call_function_return 0x737BF0 num_params 1 pop 1 [infoId] func_ret [CProjectileInfo*]</p>
<p>define function CProjectileInfo__GetProjectileInfo&lt;cdecl, 0x737BF0&gt;(infoId): int</p>
<h4>CProjectileInfo::RemoveNotAdd</h4>
<p>plugin::Call<0x737C00, CEntity*, eWeaponType, CVector>(creator, weaponType, posn);</p>
<p>0AA5: call_function 0x737C00 num_params 3 pop 3 [creator] [weaponType] [posn]</p>
<p>define function CProjectileInfo__RemoveNotAdd&lt;cdecl, 0x737C00&gt;(creator, weaponType, posn)</p>
<h4>CProjectileInfo::AddProjectile</h4>
<p>plugin::CallAndReturn<bool, 0x737C80, CEntity<em>, eWeaponType, CVector, float, CVector</em>, CEntity*>(creator, weaponType, posn, force, direction, victim);</p>
<p>0AA7: call_function_return 0x737C80 num_params 6 pop 6 [creator] [weaponType] [posn] [force] [direction] [victim] func_ret [bool]</p>
<p>define function CProjectileInfo__AddProjectile&lt;cdecl, 0x737C80&gt;(creator, weaponType, posn, force, direction, victim): int</p>
<h4>CProjectileInfo::RemoveDetonatorProjectiles</h4>
<p>plugin::Call<0x738860>();</p>
<p>0AA5: call_function 0x738860 num_params 0 pop 0</p>
<p>define function CProjectileInfo__RemoveDetonatorProjectiles&lt;cdecl, 0x738860&gt;()</p>
<h4>CProjectileInfo::RemoveProjectile</h4>
<p>plugin::Call<0x7388F0, CProjectileInfo<em>, CProjectile</em>>(projectileInfo, projectileObject);</p>
<p>0AA5: call_function 0x7388F0 num_params 2 pop 2 [projectileInfo] [projectileObject]</p>
<p>define function CProjectileInfo__RemoveProjectile&lt;cdecl, 0x7388F0&gt;(projectileInfo, projectileObject)</p>
<h4>CProjectileInfo::Update</h4>
<p>plugin::Call<0x738B20>();</p>
<p>0AA5: call_function 0x738B20 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Update&lt;cdecl, 0x738B20&gt;()</p>
<h4>CProjectileInfo::IsProjectileInRange</h4>
<p>plugin::CallAndReturn<bool, 0x739860, float, float, float, float, float, float, bool>(x1, y1, z1, x2, y2, z2, bDestroy);</p>
<p>0AA7: call_function_return 0x739860 num_params 7 pop 7 [x1] [y1] [z1] [x2] [y2] [z2] [bDestroy] func_ret [bool]</p>
<p>define function CProjectileInfo__IsProjectileInRange&lt;cdecl, 0x739860&gt;(x1, y1, z1, x2, y2, z2, bDestroy): int</p>
<h4>CProjectileInfo::RemoveAllProjectiles</h4>
<p>plugin::Call<0x7399B0>();</p>
<p>0AA5: call_function 0x7399B0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__RemoveAllProjectiles&lt;cdecl, 0x7399B0&gt;()</p>
<h4>CProjectileInfo::RemoveIfThisIsAProjectile</h4>
<p>plugin::CallAndReturn<bool, 0x739A40, CObject*>(object);</p>
<p>0AA7: call_function_return 0x739A40 num_params 1 pop 1 [object] func_ret [bool]</p>
<p>define function CProjectileInfo__RemoveIfThisIsAProjectile&lt;cdecl, 0x739A40&gt;(object): int</p><h3 id="plugin_sagame_sacptrlistcpp">plugin_sa\game_sa\CPtrList.cpp</h3><h4>CPtrList::CountElements</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5521B0, CPtrList *>(this);</p>
<p>0AA8: call_method_return 0x5521B0 struct [CPtrList] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CPtrList__CountElements&lt;thiscall, 0x5521B0&gt;(): int</p>
<h4>CPtrList::IsMemberOfList</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5521D0, CPtrList <em>, void</em>>(this, memberNode);</p>
<p>0AA8: call_method_return 0x5521D0 struct [CPtrList] num_params 1 pop 0 [memberNode] func_ret [bool]</p>
<p>define function CPtrList__IsMemberOfList&lt;thiscall, 0x5521D0&gt;(memberNode): int</p><h3 id="plugin_sagame_sacptrlistdoublelinkcpp">plugin_sa\game_sa\CPtrListDoubleLink.cpp</h3><h4>CPtrListDoubleLink::Flush</h4>
<p>plugin::CallMethod<0x552470, CPtrListDoubleLink *>(this);</p>
<p>0AA6: call_method 0x552470 struct [CPtrListDoubleLink] num_params 0 pop 0</p>
<p>define function CPtrListDoubleLink__Flush&lt;thiscall, 0x552470&gt;()</p>
<h4>CPtrListDoubleLink::AddItem</h4>
<p>plugin::CallMethod<0x533670, CPtrListDoubleLink <em>, void</em>>(this, item);</p>
<p>0AA6: call_method 0x533670 struct [CPtrListDoubleLink] num_params 1 pop 0 [item]</p>
<p>define function CPtrListDoubleLink__AddItem&lt;thiscall, 0x533670&gt;(item)</p>
<h4>CPtrListDoubleLink::DeleteItem</h4>
<p>plugin::CallMethod<0x5336B0, CPtrListDoubleLink <em>, void</em>>(this, item);</p>
<p>0AA6: call_method 0x5336B0 struct [CPtrListDoubleLink] num_params 1 pop 0 [item]</p>
<p>define function CPtrListDoubleLink__DeleteItem&lt;thiscall, 0x5336B0&gt;(item)</p><h3 id="plugin_sagame_sacptrlistsinglelinkcpp">plugin_sa\game_sa\CPtrListSingleLink.cpp</h3><h4>CPtrListSingleLink::Flush</h4>
<p>plugin::CallMethod<0x552400, CPtrListSingleLink *>(this);</p>
<p>0AA6: call_method 0x552400 struct [CPtrListSingleLink] num_params 0 pop 0</p>
<p>define function CPtrListSingleLink__Flush&lt;thiscall, 0x552400&gt;()</p>
<h4>CPtrListSingleLink::AddItem</h4>
<p>plugin::CallMethod<0x5335E0, CPtrListSingleLink <em>, void</em>>(this, item);</p>
<p>0AA6: call_method 0x5335E0 struct [CPtrListSingleLink] num_params 1 pop 0 [item]</p>
<p>define function CPtrListSingleLink__AddItem&lt;thiscall, 0x5335E0&gt;(item)</p>
<h4>CPtrListSingleLink::DeleteItem</h4>
<p>plugin::CallMethod<0x533610, CPtrListSingleLink <em>, void</em>>(this, item);</p>
<p>0AA6: call_method 0x533610 struct [CPtrListSingleLink] num_params 1 pop 0 [item]</p>
<p>define function CPtrListSingleLink__DeleteItem&lt;thiscall, 0x533610&gt;(item)</p><h3 id="plugin_sagame_sacptrnodedoublelinkcpp">plugin_sa\game_sa\CPtrNodeDoubleLink.cpp</h3><h4>CPtrNodeDoubleLink::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x5523C0, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x5523C0 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CPtrNodeDoubleLink__operator new&lt;cdecl, 0x5523C0&gt;(size): int</p>
<h4>CPtrNodeDoubleLink::operator delete</h4>
<p>plugin::Call<0x5523D0, void*>(data);</p>
<p>0AA5: call_function 0x5523D0 num_params 1 pop 1 [data]</p>
<p>define function CPtrNodeDoubleLink__operator delete&lt;cdecl, 0x5523D0&gt;(data)</p><h3 id="plugin_sagame_sacptrnodesinglelinkcpp">plugin_sa\game_sa\CPtrNodeSingleLink.cpp</h3><h4>CPtrNodeSingleLink::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x552380, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x552380 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CPtrNodeSingleLink__operator new&lt;cdecl, 0x552380&gt;(size): int</p>
<h4>CPtrNodeSingleLink::operator delete</h4>
<p>plugin::Call<0x552390, void*>(data);</p>
<p>0AA5: call_function 0x552390 num_params 1 pop 1 [data]</p>
<p>define function CPtrNodeSingleLink__operator delete&lt;cdecl, 0x552390&gt;(data)</p><h3 id="plugin_sagame_sacquadtreenodecpp">plugin_sa\game_sa\CQuadTreeNode.cpp</h3><h4>CQuadTreeNode::AddItem</h4>
<p>plugin::CallMethod<0x552CD0, CQuadTreeNode <em>, void</em>, CRect const&>(this, item, rect);</p>
<p>0AA6: call_method 0x552CD0 struct [CQuadTreeNode] num_params 2 pop 0 [item] [rect]</p>
<p>define function CQuadTreeNode__AddItem&lt;thiscall, 0x552CD0&gt;(item, rect)</p>
<h4>CQuadTreeNode::CQuadTreeNode</h4>
<p>plugin::CallMethod<0x552830, CQuadTreeNode *, CRect const&, int>(this, rect, startLevel);</p>
<p>0AA6: call_method 0x552830 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [startLevel]</p>
<p>define function CQuadTreeNode__CQuadTreeNode&lt;thiscall, 0x552830&gt;(rect, startLevel)</p>
<h4>CQuadTreeNode::DeleteItem</h4>
<p>plugin::CallMethod<0x552A40, CQuadTreeNode <em>, void</em>>(this, item);</p>
<p>0AA6: call_method 0x552A40 struct [CQuadTreeNode] num_params 1 pop 0 [item]</p>
<p>define function CQuadTreeNode__DeleteItem&lt;thiscall, 0x552A40&gt;(item)</p>
<h4>CQuadTreeNode::DeleteItem</h4>
<p>plugin::CallMethod<0x552A90, CQuadTreeNode <em>, void</em>, CRect const&>(this, item, rect);</p>
<p>0AA6: call_method 0x552A90 struct [CQuadTreeNode] num_params 2 pop 0 [item] [rect]</p>
<p>define function CQuadTreeNode__DeleteItem&lt;thiscall, 0x552A90&gt;(item, rect)</p>
<h4>CQuadTreeNode::FindSector</h4>
<p>plugin::CallMethodAndReturn<int, 0x5525A0, CQuadTreeNode *, CRect const&>(this, rect);</p>
<p>0AA8: call_method_return 0x5525A0 struct [CQuadTreeNode] num_params 1 pop 0 [rect] func_ret [int]</p>
<p>define function CQuadTreeNode__FindSector&lt;thiscall, 0x5525A0&gt;(rect): int</p>
<h4>CQuadTreeNode::FindSector</h4>
<p>plugin::CallMethodAndReturn<int, 0x552640, CQuadTreeNode *, CVector2D const&>(this, posn);</p>
<p>0AA8: call_method_return 0x552640 struct [CQuadTreeNode] num_params 1 pop 0 [posn] func_ret [int]</p>
<p>define function CQuadTreeNode__FindSector&lt;thiscall, 0x552640&gt;(posn): int</p>
<h4>CQuadTreeNode::ForAllMatching</h4>
<p>plugin::CallMethod<0x552980, CQuadTreeNode <em>, CRect const&, void(</em>)(CRect const&, void *)>(this, rect, callback);</p>
<p>0AA6: call_method 0x552980 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [callback]</p>
<p>define function CQuadTreeNode__ForAllMatching&lt;thiscall, 0x552980&gt;(rect, callback)</p>
<h4>CQuadTreeNode::ForAllMatching</h4>
<p>plugin::CallMethod<0x5529F0, CQuadTreeNode <em>, CVector2D const&, void(</em>)(CVector2D const&, void *)>(this, posn, callback);</p>
<p>0AA6: call_method 0x5529F0 struct [CQuadTreeNode] num_params 2 pop 0 [posn] [callback]</p>
<p>define function CQuadTreeNode__ForAllMatching&lt;thiscall, 0x5529F0&gt;(posn, callback)</p>
<h4>CQuadTreeNode::GetAll</h4>
<p>plugin::CallMethod<0x552870, CQuadTreeNode *, CPtrListSingleLink&>(this, list);</p>
<p>0AA6: call_method 0x552870 struct [CQuadTreeNode] num_params 1 pop 0 [list]</p>
<p>define function CQuadTreeNode__GetAll&lt;thiscall, 0x552870&gt;(list)</p>
<h4>CQuadTreeNode::GetAllMatching</h4>
<p>plugin::CallMethod<0x5528C0, CQuadTreeNode *, CRect const&, CPtrListSingleLink&>(this, rect, list);</p>
<p>0AA6: call_method 0x5528C0 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [list]</p>
<p>define function CQuadTreeNode__GetAllMatching&lt;thiscall, 0x5528C0&gt;(rect, list)</p>
<h4>CQuadTreeNode::GetAllMatching</h4>
<p>plugin::CallMethod<0x552930, CQuadTreeNode *, CVector2D const&, CPtrListSingleLink&>(this, posn, list);</p>
<p>0AA6: call_method 0x552930 struct [CQuadTreeNode] num_params 2 pop 0 [posn] [list]</p>
<p>define function CQuadTreeNode__GetAllMatching&lt;thiscall, 0x552930&gt;(posn, list)</p>
<h4>CQuadTreeNode::InSector</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5526A0, CQuadTreeNode *, CRect const&, int>(this, rect, sector);</p>
<p>0AA8: call_method_return 0x5526A0 struct [CQuadTreeNode] num_params 2 pop 0 [rect] [sector] func_ret [bool]</p>
<p>define function CQuadTreeNode__InSector&lt;thiscall, 0x5526A0&gt;(rect, sector): int</p>
<h4>CQuadTreeNode::InitPool</h4>
<p>plugin::CallMethod<0x552C00, CQuadTreeNode *>(this);</p>
<p>0AA6: call_method 0x552C00 struct [CQuadTreeNode] num_params 0 pop 0</p>
<p>define function CQuadTreeNode__InitPool&lt;thiscall, 0x552C00&gt;()</p>
<h4>CQuadTreeNode::operator delete</h4>
<p>plugin::Call<0x552C90, void*>(data);</p>
<p>0AA5: call_function 0x552C90 num_params 1 pop 1 [data]</p>
<p>define function CQuadTreeNode__operator delete&lt;cdecl, 0x552C90&gt;(data)</p>
<h4>CQuadTreeNode::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x552C80, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x552C80 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CQuadTreeNode__operator new&lt;cdecl, 0x552C80&gt;(size): int</p>
<h4>CQuadTreeNode::~CQuadTreeNode</h4>
<p>plugin::CallMethod<0x552520, CQuadTreeNode *>(this);</p>
<p>0AA6: call_method 0x552520 struct [CQuadTreeNode] num_params 0 pop 0</p>
<p>define function CQuadTreeNode__~CQuadTreeNode&lt;thiscall, 0x552520&gt;()</p><h3 id="plugin_sagame_sacregisteredmotionblurstreakcpp">plugin_sa\game_sa\CRegisteredMotionBlurStreak.cpp</h3><h4>CRegisteredMotionBlurStreak::Update</h4>
<p>plugin::CallMethod<0x721EE0, CRegisteredMotionBlurStreak *>(this);</p>
<p>0AA6: call_method 0x721EE0 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0</p>
<p>define function CRegisteredMotionBlurStreak__Update&lt;thiscall, 0x721EE0&gt;()</p>
<h4>CRegisteredMotionBlurStreak::Render</h4>
<p>plugin::CallMethod<0x721F70, CRegisteredMotionBlurStreak *>(this);</p>
<p>0AA6: call_method 0x721F70 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0</p>
<p>define function CRegisteredMotionBlurStreak__Render&lt;thiscall, 0x721F70&gt;()</p><h3 id="plugin_sagame_sacrenderercpp">plugin_sa\game_sa\CRenderer.cpp</h3><h4>CRenderer::Init</h4>
<p>plugin::Call<0x5531C0>();</p>
<p>0AA5: call_function 0x5531C0 num_params 0 pop 0</p>
<p>define function CRenderer__Init&lt;cdecl, 0x5531C0&gt;()</p>
<h4>CRenderer::Shutdown</h4>
<p>plugin::Call<0x5531D0>();</p>
<p>0AA5: call_function 0x5531D0 num_params 0 pop 0</p>
<p>define function CRenderer__Shutdown&lt;cdecl, 0x5531D0&gt;()</p>
<h4>CRenderer::RenderFadingInEntities</h4>
<p>plugin::Call<0x5531E0>();</p>
<p>0AA5: call_function 0x5531E0 num_params 0 pop 0</p>
<p>define function CRenderer__RenderFadingInEntities&lt;cdecl, 0x5531E0&gt;()</p>
<h4>CRenderer::RenderFadingInUnderwaterEntities</h4>
<p>plugin::Call<0x553220>();</p>
<p>0AA5: call_function 0x553220 num_params 0 pop 0</p>
<p>define function CRenderer__RenderFadingInUnderwaterEntities&lt;cdecl, 0x553220&gt;()</p>
<h4>CRenderer::RenderOneRoad</h4>
<p>plugin::Call<0x553230, CEntity*>(entity);</p>
<p>0AA5: call_function 0x553230 num_params 1 pop 1 [entity]</p>
<p>define function CRenderer__RenderOneRoad&lt;cdecl, 0x553230&gt;(entity)</p>
<h4>CRenderer::RenderOneNonRoad</h4>
<p>plugin::Call<0x553260, CEntity*>(entity);</p>
<p>0AA5: call_function 0x553260 num_params 1 pop 1 [entity]</p>
<p>define function CRenderer__RenderOneNonRoad&lt;cdecl, 0x553260&gt;(entity)</p>
<h4>CRenderer::RemoveVehiclePedLights</h4>
<p>plugin::Call<0x553390, CPhysical*>(entity);</p>
<p>0AA5: call_function 0x553390 num_params 1 pop 1 [entity]</p>
<p>define function CRenderer__RemoveVehiclePedLights&lt;cdecl, 0x553390&gt;(entity)</p>
<h4>CRenderer::AddEntityToRenderList</h4>
<p>plugin::Call<0x5534B0, CEntity*, float>(entity, distance);</p>
<p>0AA5: call_function 0x5534B0 num_params 2 pop 2 [entity] [distance]</p>
<p>define function CRenderer__AddEntityToRenderList&lt;cdecl, 0x5534B0&gt;(entity, distance)</p>
<h4>CRenderer::ScanSectorList_ListModels</h4>
<p>plugin::Call<0x5535D0, int, int>(sector_x, sector_y);</p>
<p>0AA5: call_function 0x5535D0 num_params 2 pop 2 [sector_x] [sector_y]</p>
<p>define function CRenderer__ScanSectorList_ListModels&lt;cdecl, 0x5535D0&gt;(sector_x, sector_y)</p>
<h4>CRenderer::ScanSectorList_ListModelsVisible</h4>
<p>plugin::Call<0x553650, int, int>(sector_x, sector_y);</p>
<p>0AA5: call_function 0x553650 num_params 2 pop 2 [sector_x] [sector_y]</p>
<p>define function CRenderer__ScanSectorList_ListModelsVisible&lt;cdecl, 0x553650&gt;(sector_x, sector_y)</p>
<h4>CRenderer::GetLodRenderListBase</h4>
<p>plugin::CallAndReturn<tRenderListEntry*, 0x5536D0>();</p>
<p>0AA7: call_function_return 0x5536D0 num_params 0 pop 0 func_ret [tRenderListEntry*]</p>
<p>define function CRenderer__GetLodRenderListBase&lt;cdecl, 0x5536D0&gt;(): int</p>
<h4>CRenderer::GetLodDontRenderListBase</h4>
<p>plugin::CallAndReturn<tRenderListEntry*, 0x5536E0>();</p>
<p>0AA7: call_function_return 0x5536E0 num_params 0 pop 0 func_ret [tRenderListEntry*]</p>
<p>define function CRenderer__GetLodDontRenderListBase&lt;cdecl, 0x5536E0&gt;(): int</p>
<h4>CRenderer::ResetLodRenderLists</h4>
<p>plugin::Call<0x5536F0>();</p>
<p>0AA5: call_function 0x5536F0 num_params 0 pop 0</p>
<p>define function CRenderer__ResetLodRenderLists&lt;cdecl, 0x5536F0&gt;()</p>
<h4>CRenderer::AddToLodRenderList</h4>
<p>plugin::Call<0x553710, CEntity*, float>(entity, distance);</p>
<p>0AA5: call_function 0x553710 num_params 2 pop 2 [entity] [distance]</p>
<p>define function CRenderer__AddToLodRenderList&lt;cdecl, 0x553710&gt;(entity, distance)</p>
<h4>CRenderer::AddToLodDontRenderList</h4>
<p>plugin::Call<0x553740, CEntity*, float>(entity, distance);</p>
<p>0AA5: call_function 0x553740 num_params 2 pop 2 [entity] [distance]</p>
<p>define function CRenderer__AddToLodDontRenderList&lt;cdecl, 0x553740&gt;(entity, distance)</p>
<h4>CRenderer::ProcessLodRenderLists</h4>
<p>plugin::Call<0x553770>();</p>
<p>0AA5: call_function 0x553770 num_params 0 pop 0</p>
<p>define function CRenderer__ProcessLodRenderLists&lt;cdecl, 0x553770&gt;()</p>
<h4>CRenderer::PreRender</h4>
<p>plugin::Call<0x553910>();</p>
<p>0AA5: call_function 0x553910 num_params 0 pop 0</p>
<p>define function CRenderer__PreRender&lt;cdecl, 0x553910&gt;()</p>
<h4>CRenderer::RenderRoads</h4>
<p>plugin::Call<0x553A10>();</p>
<p>0AA5: call_function 0x553A10 num_params 0 pop 0</p>
<p>define function CRenderer__RenderRoads&lt;cdecl, 0x553A10&gt;()</p>
<h4>CRenderer::RenderEverythingBarRoads</h4>
<p>plugin::Call<0x553AA0>();</p>
<p>0AA5: call_function 0x553AA0 num_params 0 pop 0</p>
<p>define function CRenderer__RenderEverythingBarRoads&lt;cdecl, 0x553AA0&gt;()</p>
<h4>CRenderer::RenderFirstPersonVehicle</h4>
<p>plugin::Call<0x553D00>();</p>
<p>0AA5: call_function 0x553D00 num_params 0 pop 0</p>
<p>define function CRenderer__RenderFirstPersonVehicle&lt;cdecl, 0x553D00&gt;()</p>
<h4>CRenderer::SetupLightingForEntity</h4>
<p>plugin::CallAndReturn<bool, 0x553E40, CEntity*>(entity);</p>
<p>0AA7: call_function_return 0x553E40 num_params 1 pop 1 [entity] func_ret [bool]</p>
<p>define function CRenderer__SetupLightingForEntity&lt;cdecl, 0x553E40&gt;(entity): int</p>
<h4>CRenderer::SetupMapEntityVisibility</h4>
<p>plugin::CallAndReturn<int, 0x553F60, CEntity<em>, CBaseModelInfo</em>, float, bool>(entity, modelInfo, distance, arg3);</p>
<p>0AA7: call_function_return 0x553F60 num_params 4 pop 4 [entity] [modelInfo] [distance] [arg3] func_ret [int]</p>
<p>define function CRenderer__SetupMapEntityVisibility&lt;cdecl, 0x553F60&gt;(entity, modelInfo, distance, arg3): int</p>
<h4>CRenderer::SetupEntityVisibility</h4>
<p>plugin::CallAndReturn<int, 0x554230, CEntity*, float&>(entity, outDistance);</p>
<p>0AA7: call_function_return 0x554230 num_params 2 pop 2 [entity] [outDistance] func_ret [int]</p>
<p>define function CRenderer__SetupEntityVisibility&lt;cdecl, 0x554230&gt;(entity, outDistance): int</p>
<h4>CRenderer::SetupBigBuildingVisibility</h4>
<p>plugin::CallAndReturn<int, 0x554650, CEntity*, float&>(entity, outDistance);</p>
<p>0AA7: call_function_return 0x554650 num_params 2 pop 2 [entity] [outDistance] func_ret [int]</p>
<p>define function CRenderer__SetupBigBuildingVisibility&lt;cdecl, 0x554650&gt;(entity, outDistance): int</p>
<h4>CRenderer::ScanSectorList</h4>
<p>plugin::Call<0x554840, int, int>(sector_x, sector_y);</p>
<p>0AA5: call_function 0x554840 num_params 2 pop 2 [sector_x] [sector_y]</p>
<p>define function CRenderer__ScanSectorList&lt;cdecl, 0x554840&gt;(sector_x, sector_y)</p>
<h4>CRenderer::ScanBigBuildingList</h4>
<p>plugin::Call<0x554B10, int, int>(sector_x, sector_y);</p>
<p>0AA5: call_function 0x554B10 num_params 2 pop 2 [sector_x] [sector_y]</p>
<p>define function CRenderer__ScanBigBuildingList&lt;cdecl, 0x554B10&gt;(sector_x, sector_y)</p>
<h4>CRenderer::GetObjectsInFrustum</h4>
<p>plugin::CallAndReturn<int, 0x554C60, CEntity*<em>, float, RwMatrixTag</em>>(outEntities, distance, transformMat);</p>
<p>0AA7: call_function_return 0x554C60 num_params 3 pop 3 [outEntities] [distance] [transformMat] func_ret [int]</p>
<p>define function CRenderer__GetObjectsInFrustum&lt;cdecl, 0x554C60&gt;(outEntities, distance, transformMat): int</p>
<h4>CRenderer::ShouldModelBeStreamed</h4>
<p>plugin::CallAndReturn<bool, 0x554EB0, CEntity*, CVector const&, float>(entity, origin, farClip);</p>
<p>0AA7: call_function_return 0x554EB0 num_params 3 pop 3 [entity] [origin] [farClip] func_ret [bool]</p>
<p>define function CRenderer__ShouldModelBeStreamed&lt;cdecl, 0x554EB0&gt;(entity, origin, farClip): int</p>
<h4>CRenderer::ScanWorld</h4>
<p>plugin::Call<0x554FE0>();</p>
<p>0AA5: call_function 0x554FE0 num_params 0 pop 0</p>
<p>define function CRenderer__ScanWorld&lt;cdecl, 0x554FE0&gt;()</p>
<h4>CRenderer::ScanPtrList_RequestModels</h4>
<p>plugin::Call<0x555680, CPtrList&>(ptrList);</p>
<p>0AA5: call_function 0x555680 num_params 1 pop 1 [ptrList]</p>
<p>define function CRenderer__ScanPtrList_RequestModels&lt;cdecl, 0x555680&gt;(ptrList)</p>
<h4>CRenderer::ConstructRenderList</h4>
<p>plugin::Call<0x5556E0>();</p>
<p>0AA5: call_function 0x5556E0 num_params 0 pop 0</p>
<p>define function CRenderer__ConstructRenderList&lt;cdecl, 0x5556E0&gt;()</p>
<h4>CRenderer::ScanSectorList_RequestModels</h4>
<p>plugin::Call<0x555900, int, int>(sector_x, sector_y);</p>
<p>0AA5: call_function 0x555900 num_params 2 pop 2 [sector_x] [sector_y]</p>
<p>define function CRenderer__ScanSectorList_RequestModels&lt;cdecl, 0x555900&gt;(sector_x, sector_y)</p>
<h4>CRenderer::RequestObjectsInFrustum</h4>
<p>plugin::Call<0x555960, RwMatrixTag*, int>(transformMat, modelRequesFlags);</p>
<p>0AA5: call_function 0x555960 num_params 2 pop 2 [transformMat] [modelRequesFlags]</p>
<p>define function CRenderer__RequestObjectsInFrustum&lt;cdecl, 0x555960&gt;(transformMat, modelRequesFlags)</p>
<h4>CRenderer::RequestObjectsInDirection</h4>
<p>plugin::Call<0x555CB0, CVector const&, float, int>(posn, angle, modelRequesFlags);</p>
<p>0AA5: call_function 0x555CB0 num_params 3 pop 3 [posn] [angle] [modelRequesFlags]</p>
<p>define function CRenderer__RequestObjectsInDirection&lt;cdecl, 0x555CB0&gt;(posn, angle, modelRequesFlags)</p>
<h4>CRenderer::SetupScanLists</h4>
<p>plugin::Call<0x553540, int, int>(sector_x, sector_y);</p>
<p>0AA5: call_function 0x553540 num_params 2 pop 2 [sector_x] [sector_y]</p>
<p>define function CRenderer__SetupScanLists&lt;cdecl, 0x553540&gt;(sector_x, sector_y)</p><h3 id="plugin_sagame_sacroadblockscpp">plugin_sa\game_sa\CRoadBlocks.cpp</h3><h4>CRoadBlocks::RegisterScriptRoadBlock</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *, byte>(gaddrof(CRoadBlocks::RegisterScriptRoadBlock), cornerA, cornerB, type);</p>
<h4>CRoadBlocks::ClearScriptRoadBlocks</h4>
<p>plugin::CallDynGlobal&lt;&gt;(gaddrof(CRoadBlocks::ClearScriptRoadBlocks));</p>
<h4>CRoadBlocks::Init</h4>
<p>plugin::CallDynGlobal&lt;&gt;(gaddrof(CRoadBlocks::Init));</p>
<h4>CRoadBlocks::GenerateRoadBlockCopsForCar</h4>
<p>plugin::CallDynGlobal<CVehicle *, int, byte>(gaddrof(CRoadBlocks::GenerateRoadBlockCopsForCar), car, pedsPositionsType, type);</p>
<h4>CRoadBlocks::CreateRoadBlockBetween2Points</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *, byte>(gaddrof(CRoadBlocks::CreateRoadBlockBetween2Points), a, b, type);</p>
<h4>CRoadBlocks::GenerateRoadBlocks</h4>
<p>plugin::CallDynGlobal&lt;&gt;(gaddrof(CRoadBlocks::GenerateRoadBlocks));</p><h3 id="plugin_sagame_sacrunningscriptcpp">plugin_sa\game_sa\CRunningScript.cpp</h3><h4>CRunningScript::AddScriptToList</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript **>(gaddrof(CRunningScript::AddScriptToList), this, queuelist);</p>
<p>0AA6: call_method 0x464C00 struct [CRunningScript] num_params 1 pop 0 [queuelist]</p>
<p>define function CRunningScript__AddScriptToList&lt;thiscall, 0x464C00&gt;(queuelist)</p>
<h4>CRunningScript::CarInAreaCheckCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CarInAreaCheckCommand), this, commandID);</p>
<p>0AA6: call_method 0x488EC0 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__CarInAreaCheckCommand&lt;thiscall, 0x488EC0&gt;(commandID)</p>
<h4>CRunningScript::CharInAngledAreaCheckCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CharInAngledAreaCheckCommand), this, commandID);</p>
<p>0AA6: call_method 0x487F60 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__CharInAngledAreaCheckCommand&lt;thiscall, 0x487F60&gt;(commandID)</p>
<h4>CRunningScript::CharInAreaCheckCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::CharInAreaCheckCommand), this, commandID);</p>
<p>0AA6: call_method 0x488B50 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__CharInAreaCheckCommand&lt;thiscall, 0x488B50&gt;(commandID)</p>
<h4>CRunningScript::CollectNextParameterWithoutIncreasingPC</h4>
<p>plugin::CallMethodAndReturnDynGlobal<tScriptParam, CRunningScript *>(gaddrof(CRunningScript::CollectNextParameterWithoutIncreasingPC), this);</p>
<p>0AA8: call_method_return 0x464250 struct [CRunningScript] num_params 0 pop 0 func_ret [tScriptParam]</p>
<h4>CRunningScript::CollectParameters</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, short>(gaddrof(CRunningScript::CollectParameters), this, count);</p>
<p>0AA6: call_method 0x464080 struct [CRunningScript] num_params 1 pop 0 [count]</p>
<p>define function CRunningScript__CollectParameters&lt;thiscall, 0x464080&gt;(count)</p>
<h4>CRunningScript::DoDeatharrestCheck</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::DoDeatharrestCheck), this);</p>
<p>0AA6: call_method 0x485A50 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__DoDeatharrestCheck&lt;thiscall, 0x485A50&gt;()</p>
<h4>CRunningScript::FlameInAngledAreaCheckCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::FlameInAngledAreaCheckCommand), this, commandID);</p>
<p>0AA6: call_method 0x488780 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__FlameInAngledAreaCheckCommand&lt;thiscall, 0x488780&gt;(commandID)</p>
<h4>CRunningScript::GetCorrectPedModelIndexForEmergencyServiceType</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, ePedType, int *>(gaddrof(CRunningScript::GetCorrectPedModelIndexForEmergencyServiceType), this, pedType, pModelId);</p>
<p>0AA6: call_method 0x464F50 struct [CRunningScript] num_params 2 pop 0 [pedType] [pModelId]</p>
<p>define function CRunningScript__GetCorrectPedModelIndexForEmergencyServiceType&lt;thiscall, 0x464F50&gt;(pedType, pModelId)</p>
<h4>CRunningScript::GetIndexOfGlobalVariable</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CRunningScript *>(gaddrof(CRunningScript::GetIndexOfGlobalVariable), this);</p>
<p>0AA8: call_method_return 0x464700 struct [CRunningScript] num_params 0 pop 0 func_ret [short]</p>
<h4>CRunningScript::GetPadState</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CRunningScript *, unsigned short, unsigned short>(gaddrof(CRunningScript::GetPadState), this, playerIndex, buttonID);</p>
<p>0AA8: call_method_return 0x485B10 struct [CRunningScript] num_params 2 pop 0 [playerIndex] [buttonID] func_ret [short]</p>
<h4>*CRunningScript::GetPointerToLocalArrayElement</h4>
<p>plugin::CallMethodAndReturnDynGlobal<void*,CRunningScript *, int, unsigned short, unsigned char>(gaddrof(CRunningScript::GetPointerToLocalArrayElement), this, off, idx, mul);</p>
<p>0AA8: call_method_return 0x463CC0 struct [<em>CRunningScript] num_params 3 pop 0 [off] [idx] [mul] func_ret [void</em>]</p>
<h4>*CRunningScript::GetPointerToLocalVariable</h4>
<p>plugin::CallMethodAndReturnDynGlobal<void* ,CRunningScript *, int>(gaddrof(CRunningScript::GetPointerToLocalVariable), this, varId);</p>
<p>0AA8: call_method_return 0x463CA0 struct [<em>CRunningScript] num_params 1 pop 0 [varId] func_ret [void</em>]</p>
<h4>*CRunningScript::GetPointerToScriptVariable</h4>
<p>plugin::CallMethodAndReturnDynGlobal<tScriptParam *, CRunningScript *, unsigned char>(gaddrof(CRunningScript::GetPointerToScriptVariable), this, variableType);</p>
<p>0AA8: call_method_return 0x464790 struct [*CRunningScript] num_params 1 pop 0 [variableType] func_ret [tScriptParam *]</p>
<h4>CRunningScript::GivePedScriptedTask</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int, CTask *, int>(gaddrof(CRunningScript::GivePedScriptedTask), this, pedHandle, task, commandID);</p>
<p>0AA6: call_method 0x465C20 struct [CRunningScript] num_params 3 pop 0 [pedHandle] [task] [commandID]</p>
<p>define function CRunningScript__GivePedScriptedTask&lt;thiscall, 0x465C20&gt;(pedHandle, task, commandID)</p>
<h4>CRunningScript::Init</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::Init), this);</p>
<p>0AA6: call_method 0x4648E0 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__Init&lt;thiscall, 0x4648E0&gt;()</p>
<h4>CRunningScript::IsPedDead</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CRunningScript *, CPed *>(gaddrof(CRunningScript::IsPedDead), this, pPed);</p>
<p>0AA8: call_method_return 0x464D70 struct [CRunningScript] num_params 1 pop 0 [pPed] func_ret [bool]</p>
<h4>CRunningScript::LocateCarCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCarCommand), this, commandID);</p>
<p>0AA6: call_method 0x487A20 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__LocateCarCommand&lt;thiscall, 0x487A20&gt;(commandID)</p>
<h4>CRunningScript::LocateCharCarCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCarCommand), this, commandID);</p>
<p>0AA6: call_method 0x487420 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__LocateCharCarCommand&lt;thiscall, 0x487420&gt;(commandID)</p>
<h4>CRunningScript::LocateCharCharCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCharCommand), this, commandID);</p>
<p>0AA6: call_method 0x4870F0 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__LocateCharCharCommand&lt;thiscall, 0x4870F0&gt;(commandID)</p>
<h4>CRunningScript::LocateCharCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharCommand), this, commandID);</p>
<p>0AA6: call_method 0x486D80 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__LocateCharCommand&lt;thiscall, 0x486D80&gt;(commandID)</p>
<h4>CRunningScript::LocateCharObjectCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateCharObjectCommand), this, commandID);</p>
<p>0AA6: call_method 0x487720 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__LocateCharObjectCommand&lt;thiscall, 0x487720&gt;(commandID)</p>
<h4>CRunningScript::LocateObjectCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::LocateObjectCommand), this, commandID);</p>
<p>0AA6: call_method 0x487D10 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__LocateObjectCommand&lt;thiscall, 0x487D10&gt;(commandID)</p>
<h4>CRunningScript::ObjectInAngledAreaCheckCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ObjectInAngledAreaCheckCommand), this, commandID);</p>
<p>0AA6: call_method 0x4883F0 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__ObjectInAngledAreaCheckCommand&lt;thiscall, 0x4883F0&gt;(commandID)</p>
<h4>CRunningScript::ObjectInAreaCheckCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ObjectInAreaCheckCommand), this, commandID);</p>
<p>0AA6: call_method 0x489150 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__ObjectInAreaCheckCommand&lt;thiscall, 0x489150&gt;(commandID)</p>
<h4>CRunningScript::PlayAnimScriptCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::PlayAnimScriptCommand), this, commandID);</p>
<p>0AA6: call_method 0x470150 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__PlayAnimScriptCommand&lt;thiscall, 0x470150&gt;(commandID)</p>
<h4>CRunningScript::Process</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::Process), this);</p>
<p>0AA6: call_method 0x469F00 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__Process&lt;thiscall, 0x469F00&gt;()</p>
<h4>CRunningScript::ProcessCommands0To99</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands0To99), this, commandID);</p>
<p>0AA8: call_method_return 0x465E60 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1000To1099</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1000To1099), this, commandID);</p>
<p>0AA8: call_method_return 0x489500 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands100To199</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands100To199), this, commandID);</p>
<p>0AA8: call_method_return 0x466DE0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1100To1199</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1100To1199), this, commandID);</p>
<p>0AA8: call_method_return 0x48A320 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1200To1299</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1200To1299), this, commandID);</p>
<p>0AA8: call_method_return 0x48B590 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1300To1399</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1300To1399), this, commandID);</p>
<p>0AA8: call_method_return 0x48CDD0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1400To1499</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1400To1499), this, commandID);</p>
<p>0AA8: call_method_return 0x48EAA0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1500To1599</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1500To1599), this, commandID);</p>
<p>0AA8: call_method_return 0x490DB0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1600To1699</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1600To1699), this, commandID);</p>
<p>0AA8: call_method_return 0x493FE0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1700To1799</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1700To1799), this, commandID);</p>
<p>0AA8: call_method_return 0x496E00 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1800To1899</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1800To1899), this, commandID);</p>
<p>0AA8: call_method_return 0x46D050 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands1900To1999</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands1900To1999), this, commandID);</p>
<p>0AA8: call_method_return 0x46B460 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2000To2099</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2000To2099), this, commandID);</p>
<p>0AA8: call_method_return 0x472310 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands200To299</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands200To299), this, commandID);</p>
<p>0AA8: call_method_return 0x469390 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2100To2199</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2100To2199), this, commandID);</p>
<p>0AA8: call_method_return 0x470A90 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2200To2299</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2200To2299), this, commandID);</p>
<p>0AA8: call_method_return 0x474900 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2300To2399</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2300To2399), this, commandID);</p>
<p>0AA8: call_method_return 0x4762D0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2400To2499</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2400To2499), this, commandID);</p>
<p>0AA8: call_method_return 0x478000 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2500To2599</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2500To2599), this, commandID);</p>
<p>0AA8: call_method_return 0x47A760 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands2600To2699</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands2600To2699), this, commandID);</p>
<p>0AA8: call_method_return 0x479DA0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands300To399</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands300To399), this, commandID);</p>
<p>0AA8: call_method_return 0x47C100 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands400To499</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands400To499), this, commandID);</p>
<p>0AA8: call_method_return 0x47D210 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands500To599</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands500To599), this, commandID);</p>
<p>0AA8: call_method_return 0x47E090 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands600To699</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands600To699), this, commandID);</p>
<p>0AA8: call_method_return 0x47F370 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands700To799</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands700To799), this, commandID);</p>
<p>0AA8: call_method_return 0x47FA30 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands800To899</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands800To899), this, commandID);</p>
<p>0AA8: call_method_return 0x481300 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessCommands900To999</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CRunningScript *, int>(gaddrof(CRunningScript::ProcessCommands900To999), this, commandID);</p>
<p>0AA8: call_method_return 0x483BD0 struct [CRunningScript] num_params 1 pop 0 [commandID] func_ret [char]</p>
<h4>CRunningScript::ProcessOneCommand</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::ProcessOneCommand), this);</p>
<p>0AA6: call_method 0x469EB0 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__ProcessOneCommand&lt;thiscall, 0x469EB0&gt;()</p>
<h4>CRunningScript::ReadArrayInformation</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int, unsigned short *, int *>(gaddrof(CRunningScript::ReadArrayInformation), this, move, pOffset, pIdx);</p>
<p>0AA6: call_method 0x463CF0 struct [CRunningScript] num_params 3 pop 0 [move] [pOffset] [pIdx]</p>
<p>define function CRunningScript__ReadArrayInformation&lt;thiscall, 0x463CF0&gt;(move, pOffset, pIdx)</p>
<h4>CRunningScript::ReadParametersForNewlyStartedScript</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript *>(gaddrof(CRunningScript::ReadParametersForNewlyStartedScript), this, pNewScript);</p>
<p>0AA6: call_method 0x464500 struct [CRunningScript] num_params 1 pop 0 [pNewScript]</p>
<p>define function CRunningScript__ReadParametersForNewlyStartedScript&lt;thiscall, 0x464500&gt;(pNewScript)</p>
<h4>CRunningScript::ReadTextLabelFromScript</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, char *, unsigned char>(gaddrof(CRunningScript::ReadTextLabelFromScript), this, pBuffer, nBufferLength);</p>
<p>0AA6: call_method 0x463D50 struct [CRunningScript] num_params 2 pop 0 [pBuffer] [nBufferLength]</p>
<p>define function CRunningScript__ReadTextLabelFromScript&lt;thiscall, 0x463D50&gt;(pBuffer, nBufferLength)</p>
<h4>CRunningScript::RemoveScriptFromList</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, CRunningScript **>(gaddrof(CRunningScript::RemoveScriptFromList), this, queuelist);</p>
<p>0AA6: call_method 0x464BD0 struct [CRunningScript] num_params 1 pop 0 [queuelist]</p>
<p>define function CRunningScript__RemoveScriptFromList&lt;thiscall, 0x464BD0&gt;(queuelist)</p>
<h4>CRunningScript::ScriptTaskPickUpObject</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::ScriptTaskPickUpObject), this, commandID);</p>
<p>0AA6: call_method 0x46AF50 struct [CRunningScript] num_params 1 pop 0 [commandID]</p>
<p>define function CRunningScript__ScriptTaskPickUpObject&lt;thiscall, 0x46AF50&gt;(commandID)</p>
<h4>CRunningScript::SetCharCoordinates</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, CPed *, float, float, float, bool, bool>(gaddrof(CRunningScript::SetCharCoordinates), this, pPed, x_coord, y_coord, z_coord, bWarpGang, bOffset);</p>
<p>0AA6: call_method 0x464DC0 struct [CRunningScript] num_params 6 pop 0 [pPed] [x_coord] [y_coord] [z_coord] [bWarpGang] [bOffset]</p>
<p>define function CRunningScript__SetCharCoordinates&lt;thiscall, 0x464DC0&gt;(pPed, x_coord, y_coord, z_coord, bWarpGang, bOffset)</p>
<h4>CRunningScript::ShutdownThisScript</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *>(gaddrof(CRunningScript::ShutdownThisScript), this);</p>
<p>0AA6: call_method 0x465AA0 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__ShutdownThisScript&lt;thiscall, 0x465AA0&gt;()</p>
<h4>CRunningScript::StoreParameters</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, short>(gaddrof(CRunningScript::StoreParameters), this, count);</p>
<p>0AA6: call_method 0x464370 struct [CRunningScript] num_params 1 pop 0 [count]</p>
<p>define function CRunningScript__StoreParameters&lt;thiscall, 0x464370&gt;(count)</p>
<h4>CRunningScript::ThisIsAValidRandomPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CRunningScript *, ePedType, bool, bool, bool>(gaddrof(CRunningScript::ThisIsAValidRandomPed), this, pedType, civilian, gang, criminal);</p>
<p>0AA8: call_method_return 0x489490 struct [CRunningScript] num_params 4 pop 0 [pedType] [civilian] [gang] [criminal] func_ret [bool]</p>
<h4>CRunningScript::UpdateCompareFlag</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, bool>(gaddrof(CRunningScript::UpdateCompareFlag), this, state);</p>
<p>0AA6: call_method 0x4859D0 struct [CRunningScript] num_params 1 pop 0 [state]</p>
<p>define function CRunningScript__UpdateCompareFlag&lt;thiscall, 0x4859D0&gt;(state)</p>
<h4>CRunningScript::UpdatePC</h4>
<p>plugin::CallMethodDynGlobal<CRunningScript *, int>(gaddrof(CRunningScript::UpdatePC), this, newIP);</p>
<p>0AA6: call_method 0x464DA0 struct [CRunningScript] num_params 1 pop 0 [newIP]</p>
<p>define function CRunningScript__UpdatePC&lt;thiscall, 0x464DA0&gt;(newIP)</p><h3 id="plugin_sagame_sacscriptresourcemanagercpp">plugin_sa\game_sa\CScriptResourceManager.cpp</h3><h4>CScriptResourceManager::AddToResourceManager</h4>
<p>plugin::CallMethodDynGlobal<CScriptResourceManager *, int, unsigned int, CRunningScript *>(gaddrof(CScriptResourceManager::AddToResourceManager), this, modelID, ResourceType, pScript);</p>
<p>0AA6: call_method 0x4704B0 struct [CScriptResourceManager] num_params 3 pop 0 [modelID] [ResourceType] [pScript]</p>
<p>define function CScriptResourceManager__AddToResourceManager&lt;thiscall, 0x4704B0&gt;(modelID, ResourceType, pScript)</p>
<h4>CScriptResourceManager::HasResourceBeenRequested</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CScriptResourceManager *, int, unsigned int>(gaddrof(CScriptResourceManager::HasResourceBeenRequested), this, ModelId, a4);</p>
<p>0AA8: call_method_return 0x470620 struct [CScriptResourceManager] num_params 2 pop 0 [ModelId] [a4] func_ret [bool]</p>
<h4>CScriptResourceManager::RemoveFromResourceManager</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CScriptResourceManager *, int, unsigned int, CRunningScript *>(gaddrof(CScriptResourceManager::RemoveFromResourceManager), this, modelID, ResourceType, pScript);</p>
<p>0AA8: call_method_return 0x470510 struct [CScriptResourceManager] num_params 3 pop 0 [modelID] [ResourceType] [pScript] func_ret [bool]</p><h3 id="plugin_sagame_sacscriptsforbrainscpp">plugin_sa\game_sa\CScriptsForBrains.cpp</h3><h4>CScriptsForBrains::AddNewScriptBrain</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, short, short, unsigned short, signed char, signed char, float>(gaddrof(CScriptsForBrains::AddNewScriptBrain), this, ImgIndex, Model, Priority, attachType, Type, Radius);</p>
<p>0AA6: call_method 0x46A930 struct [CScriptsForBrains] num_params 6 pop 0 [ImgIndex] [Model] [Priority] [attachType] [Type] [Radius]</p>
<p>define function CScriptsForBrains__AddNewScriptBrain&lt;thiscall, 0x46A930&gt;(ImgIndex, Model, Priority, attachType, Type, Radius)</p>
<h4>CScriptsForBrains::AddNewStreamedScriptBrainForCodeUse</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, short, char *, signed char>(gaddrof(CScriptsForBrains::AddNewStreamedScriptBrainForCodeUse), this, a2, a3, attachtype);</p>
<p>0AA6: call_method 0x46A9C0 struct [CScriptsForBrains] num_params 3 pop 0 [a2] [a3] [attachtype]</p>
<p>define function CScriptsForBrains__AddNewStreamedScriptBrainForCodeUse&lt;thiscall, 0x46A9C0&gt;(a2, a3, attachtype)</p>
<h4>CScriptsForBrains::CheckIfNewEntityNeedsScript</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, CEntity *, signed char, void *>(gaddrof(CScriptsForBrains::CheckIfNewEntityNeedsScript), this, pEntity, attachType, unused);</p>
<p>0AA6: call_method 0x46FF20 struct [CScriptsForBrains] num_params 3 pop 0 [pEntity] [attachType] [unused]</p>
<p>define function CScriptsForBrains__CheckIfNewEntityNeedsScript&lt;thiscall, 0x46FF20&gt;(pEntity, attachType, unused)</p>
<h4>CScriptsForBrains::GetIndexOfScriptBrainWithThisName</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed short, CScriptsForBrains *, char const *, signed char>(gaddrof(CScriptsForBrains::GetIndexOfScriptBrainWithThisName), this, name, Attachtype);</p>
<p>0AA8: call_method_return 0x46AA30 struct [CScriptsForBrains] num_params 2 pop 0 [name] [Attachtype] func_ret [signed short]</p>
<h4>CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded), this, name);</p>
<p>0AA8: call_method_return 0x46AB20 struct [CScriptsForBrains] num_params 1 pop 0 [name] func_ret [bool]</p>
<h4>CScriptsForBrains::Init</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *>(gaddrof(CScriptsForBrains::Init), this);</p>
<p>0AA6: call_method 0x46A8C0 struct [CScriptsForBrains] num_params 0 pop 0</p>
<p>define function CScriptsForBrains__Init&lt;thiscall, 0x46A8C0&gt;()</p>
<h4>CScriptsForBrains::IsObjectWithinBrainActivationRange</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CScriptsForBrains *, CObject *, CVector const *>(gaddrof(CScriptsForBrains::IsObjectWithinBrainActivationRange), this, entity, point);</p>
<p>0AA8: call_method_return 0x46B3D0 struct [CScriptsForBrains] num_params 2 pop 0 [entity] [point] func_ret [bool]</p>
<h4>CScriptsForBrains::MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded), this, name);</p>
<p>0AA6: call_method 0x46AAE0 struct [CScriptsForBrains] num_params 1 pop 0 [name]</p>
<p>define function CScriptsForBrains__MarkAttractorScriptBrainWithThisNameAsNoLongerNeeded&lt;thiscall, 0x46AAE0&gt;(name)</p>
<h4>CScriptsForBrains::RequestAttractorScriptBrainWithThisName</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *>(gaddrof(CScriptsForBrains::RequestAttractorScriptBrainWithThisName), this, name);</p>
<p>0AA6: call_method 0x46AA80 struct [CScriptsForBrains] num_params 1 pop 0 [name]</p>
<p>define function CScriptsForBrains__RequestAttractorScriptBrainWithThisName&lt;thiscall, 0x46AA80&gt;(name)</p>
<h4>CScriptsForBrains::StartAttractorScriptBrainWithThisName</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *, CEntity *, unsigned char>(gaddrof(CScriptsForBrains::StartAttractorScriptBrainWithThisName), this, name, pEntity, bHasAScriptBrain);</p>
<p>0AA6: call_method 0x46B390 struct [CScriptsForBrains] num_params 3 pop 0 [name] [pEntity] [bHasAScriptBrain]</p>
<p>define function CScriptsForBrains__StartAttractorScriptBrainWithThisName&lt;thiscall, 0x46B390&gt;(name, pEntity, bHasAScriptBrain)</p>
<h4>CScriptsForBrains::StartNewStreamedScriptBrain</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, unsigned char, CEntity *, unsigned char>(gaddrof(CScriptsForBrains::StartNewStreamedScriptBrain), this, index, pEntity, bHasAScriptBrain);</p>
<p>0AA6: call_method 0x46B270 struct [CScriptsForBrains] num_params 3 pop 0 [index] [pEntity] [bHasAScriptBrain]</p>
<p>define function CScriptsForBrains__StartNewStreamedScriptBrain&lt;thiscall, 0x46B270&gt;(index, pEntity, bHasAScriptBrain)</p>
<h4>CScriptsForBrains::StartOrRequestNewStreamedScriptBrain</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, unsigned char, CEntity *, signed char, unsigned char>(gaddrof(CScriptsForBrains::StartOrRequestNewStreamedScriptBrain), this, index, pEntity, attachType, bAddToWaitingArray);</p>
<p>0AA6: call_method 0x46CD80 struct [CScriptsForBrains] num_params 4 pop 0 [index] [pEntity] [attachType] [bAddToWaitingArray]</p>
<p>define function CScriptsForBrains__StartOrRequestNewStreamedScriptBrain&lt;thiscall, 0x46CD80&gt;(index, pEntity, attachType, bAddToWaitingArray)</p>
<h4>CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, char const *, CEntity *, signed char>(gaddrof(CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName), this, name, pEntity, attachType);</p>
<p>0AA6: call_method 0x46CED0 struct [CScriptsForBrains] num_params 3 pop 0 [name] [pEntity] [attachType]</p>
<p>define function CScriptsForBrains__StartOrRequestNewStreamedScriptBrainWithThisName&lt;thiscall, 0x46CED0&gt;(name, pEntity, attachType)</p>
<h4>CScriptsForBrains::SwitchAllObjectBrainsWithThisID</h4>
<p>plugin::CallMethodDynGlobal<CScriptsForBrains *, signed char, bool>(gaddrof(CScriptsForBrains::SwitchAllObjectBrainsWithThisID), this, ID, bStatus);</p>
<p>0AA6: call_method 0x46A900 struct [CScriptsForBrains] num_params 2 pop 0 [ID] [bStatus]</p>
<p>define function CScriptsForBrains__SwitchAllObjectBrainsWithThisID&lt;thiscall, 0x46A900&gt;(ID, bStatus)</p><h3 id="plugin_sagame_sacsetpiececpp">plugin_sa\game_sa\CSetPiece.cpp</h3><h4>CSetPiece::TryToGenerateCopPed</h4>
<p>plugin::CallMethodAndReturn<CCopPed*, 0x499690, CSetPiece *, CVector2D>(this, posn);</p>
<p>0AA8: call_method_return 0x499690 struct [CSetPiece] num_params 1 pop 0 [posn] func_ret [CCopPed*]</p>
<p>define function CSetPiece__TryToGenerateCopPed&lt;thiscall, 0x499690&gt;(posn): int</p>
<h4>CSetPiece::TryToGenerateCopCar</h4>
<p>plugin::CallMethodAndReturn<CVehicle*, 0x4998A0, CSetPiece *, CVector2D, CVector2D>(this, posn, target);</p>
<p>0AA8: call_method_return 0x4998A0 struct [CSetPiece] num_params 2 pop 0 [posn] [target] func_ret [CVehicle*]</p>
<p>define function CSetPiece__TryToGenerateCopCar&lt;thiscall, 0x4998A0&gt;(posn, target): int</p>
<h4>CSetPiece::Update</h4>
<p>plugin::CallMethod<0x499A80, CSetPiece *>(this);</p>
<p>0AA6: call_method 0x499A80 struct [CSetPiece] num_params 0 pop 0</p>
<p>define function CSetPiece__Update&lt;thiscall, 0x499A80&gt;()</p>
<h4>CSetPiece::SetCornerA</h4>
<p>plugin::CallMethod<0x499120, CSetPiece *, CVector2D>(this, coord);</p>
<p>0AA6: call_method 0x499120 struct [CSetPiece] num_params 1 pop 0 [coord]</p>
<p>define function CSetPiece__SetCornerA&lt;thiscall, 0x499120&gt;(coord)</p>
<h4>CSetPiece::SetCornerB</h4>
<p>plugin::CallMethod<0x499150, CSetPiece *, CVector2D>(this, coord);</p>
<p>0AA6: call_method 0x499150 struct [CSetPiece] num_params 1 pop 0 [coord]</p>
<p>define function CSetPiece__SetCornerB&lt;thiscall, 0x499150&gt;(coord)</p>
<h4>CSetPiece::SetSpawnCoord1</h4>
<p>plugin::CallMethod<0x499180, CSetPiece *, CVector2D>(this, coord);</p>
<p>0AA6: call_method 0x499180 struct [CSetPiece] num_params 1 pop 0 [coord]</p>
<p>define function CSetPiece__SetSpawnCoord1&lt;thiscall, 0x499180&gt;(coord)</p>
<h4>CSetPiece::SetSpawnCoord2</h4>
<p>plugin::CallMethod<0x4991B0, CSetPiece *, CVector2D>(this, coord);</p>
<p>0AA6: call_method 0x4991B0 struct [CSetPiece] num_params 1 pop 0 [coord]</p>
<p>define function CSetPiece__SetSpawnCoord2&lt;thiscall, 0x4991B0&gt;(coord)</p>
<h4>CSetPiece::SetTargetCoord1</h4>
<p>plugin::CallMethod<0x4991E0, CSetPiece *, CVector2D>(this, coord);</p>
<p>0AA6: call_method 0x4991E0 struct [CSetPiece] num_params 1 pop 0 [coord]</p>
<p>define function CSetPiece__SetTargetCoord1&lt;thiscall, 0x4991E0&gt;(coord)</p>
<h4>CSetPiece::SetTargetCoord2</h4>
<p>plugin::CallMethod<0x499210, CSetPiece *, CVector2D>(this, coord);</p>
<p>0AA6: call_method 0x499210 struct [CSetPiece] num_params 1 pop 0 [coord]</p>
<p>define function CSetPiece__SetTargetCoord2&lt;thiscall, 0x499210&gt;(coord)</p>
<h4>CSetPiece::GetCornerAX</h4>
<p>plugin::CallMethodAndReturn<float, 0x499240, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499240 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetCornerAX&lt;thiscall, 0x499240&gt;(): float</p>
<h4>CSetPiece::GetCornerAY</h4>
<p>plugin::CallMethodAndReturn<float, 0x499260, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499260 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetCornerAY&lt;thiscall, 0x499260&gt;(): float</p>
<h4>CSetPiece::GetCornerBX</h4>
<p>plugin::CallMethodAndReturn<float, 0x499280, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499280 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetCornerBX&lt;thiscall, 0x499280&gt;(): float</p>
<h4>CSetPiece::GetCornerBY</h4>
<p>plugin::CallMethodAndReturn<float, 0x4992A0, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x4992A0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetCornerBY&lt;thiscall, 0x4992A0&gt;(): float</p>
<h4>CSetPiece::GetSpawnCoord1X</h4>
<p>plugin::CallMethodAndReturn<float, 0x4992C0, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x4992C0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetSpawnCoord1X&lt;thiscall, 0x4992C0&gt;(): float</p>
<h4>CSetPiece::GetSpawnCoord1Y</h4>
<p>plugin::CallMethodAndReturn<float, 0x4992E0, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x4992E0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetSpawnCoord1Y&lt;thiscall, 0x4992E0&gt;(): float</p>
<h4>CSetPiece::GetSpawnCoord2X</h4>
<p>plugin::CallMethodAndReturn<float, 0x499300, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499300 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetSpawnCoord2X&lt;thiscall, 0x499300&gt;(): float</p>
<h4>CSetPiece::GetSpawnCoord2Y</h4>
<p>plugin::CallMethodAndReturn<float, 0x499320, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499320 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetSpawnCoord2Y&lt;thiscall, 0x499320&gt;(): float</p>
<h4>CSetPiece::GetTargetCoord1X</h4>
<p>plugin::CallMethodAndReturn<float, 0x499340, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499340 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetTargetCoord1X&lt;thiscall, 0x499340&gt;(): float</p>
<h4>CSetPiece::GetTargetCoord1Y</h4>
<p>plugin::CallMethodAndReturn<float, 0x499360, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499360 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetTargetCoord1Y&lt;thiscall, 0x499360&gt;(): float</p>
<h4>CSetPiece::GetTargetCoord2X</h4>
<p>plugin::CallMethodAndReturn<float, 0x499380, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x499380 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetTargetCoord2X&lt;thiscall, 0x499380&gt;(): float</p>
<h4>CSetPiece::GetTargetCoord2Y</h4>
<p>plugin::CallMethodAndReturn<float, 0x4993A0, CSetPiece *>(this);</p>
<p>0AA8: call_method_return 0x4993A0 struct [CSetPiece] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSetPiece__GetTargetCoord2Y&lt;thiscall, 0x4993A0&gt;(): float</p>
<h4>CSetPiece::CSetPiece</h4>
<p>plugin::CallMethod<0x4993C0, CSetPiece *>(this);</p>
<p>0AA6: call_method 0x4993C0 struct [CSetPiece] num_params 0 pop 0</p>
<p>define function CSetPiece__CSetPiece&lt;thiscall, 0x4993C0&gt;()</p><h3 id="plugin_sagame_sacsetpiecescpp">plugin_sa\game_sa\CSetPieces.cpp</h3><h4>CSetPieces::AddOne</h4>
<p>plugin::Call<0x499500, unsigned char, CVector2D, CVector2D, CVector2D, CVector2D, CVector2D, CVector2D>(type, cornerA, cornerB, spawnCoord1, targetCoord1, spawnCoord2, targetCoord2);</p>
<p>0AA5: call_function 0x499500 num_params 7 pop 7 [type] [cornerA] [cornerB] [spawnCoord1] [targetCoord1] [spawnCoord2] [targetCoord2]</p>
<p>define function CSetPieces__AddOne&lt;cdecl, 0x499500&gt;(type, cornerA, cornerB, spawnCoord1, targetCoord1, spawnCoord2, targetCoord2)</p>
<h4>CSetPieces::Init</h4>
<p>plugin::Call<0x4994F0>();</p>
<p>0AA5: call_function 0x4994F0 num_params 0 pop 0</p>
<p>define function CSetPieces__Init&lt;cdecl, 0x4994F0&gt;()</p>
<h4>CSetPieces::Load</h4>
<p>plugin::CallAndReturn<bool, 0x5D3CA0>();</p>
<p>0AA7: call_function_return 0x5D3CA0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSetPieces__Load&lt;cdecl, 0x5D3CA0&gt;(): int</p>
<h4>CSetPieces::Save</h4>
<p>plugin::CallAndReturn<bool, 0x5D3C70>();</p>
<p>0AA7: call_function_return 0x5D3C70 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSetPieces__Save&lt;cdecl, 0x5D3C70&gt;(): int</p>
<h4>CSetPieces::Update</h4>
<p>plugin::Call<0x49AA00>();</p>
<p>0AA5: call_function 0x49AA00 num_params 0 pop 0</p>
<p>define function CSetPieces__Update&lt;cdecl, 0x49AA00&gt;()</p><h3 id="plugin_sagame_sacshinytextscpp">plugin_sa\game_sa\CShinyTexts.cpp</h3><h4>CShinyTexts::Init</h4>
<p>plugin::Call<0x7221B0>();</p>
<p>0AA5: call_function 0x7221B0 num_params 0 pop 0</p>
<p>define function CShinyTexts__Init&lt;cdecl, 0x7221B0&gt;()</p>
<h4>CShinyTexts::RenderOutGeometryBuffer</h4>
<p>plugin::Call<0x7221C0>();</p>
<p>0AA5: call_function 0x7221C0 num_params 0 pop 0</p>
<p>define function CShinyTexts__RenderOutGeometryBuffer&lt;cdecl, 0x7221C0&gt;()</p>
<h4>CShinyTexts::Render</h4>
<p>plugin::Call<0x724890>();</p>
<p>0AA5: call_function 0x724890 num_params 0 pop 0</p>
<p>define function CShinyTexts__Render&lt;cdecl, 0x724890&gt;()</p>
<h4>CShinyTexts::RegisterOne</h4>
<p>plugin::Call<0x724B60, CVector, CVector, CVector, CVector, float, float, float, float, float, float, float, float, unsigned char, unsigned char, unsigned char, unsigned char, float>(cornerAA, cornerBA, cornerBB, cornerAB, u1, v1, u2, v2, u3, v3, u4, v4, red, green, blue, alpha, maxDistance);</p>
<p>0AA5: call_function 0x724B60 num_params 17 pop 17 [cornerAA] [cornerBA] [cornerBB] [cornerAB] [u1] [v1] [u2] [v2] [u3] [v3] [u4] [v4] [red] [green] [blue] [alpha] [maxDistance]</p>
<p>define function CShinyTexts__RegisterOne&lt;cdecl, 0x724B60&gt;(cornerAA, cornerBA, cornerBB, cornerAB, u1, v1, u2, v2, u3, v3, u4, v4, red, green, blue, alpha, maxDistance)</p><h3 id="plugin_sagame_sacshotinfocpp">plugin_sa\game_sa\CShotInfo.cpp</h3><h4>CShotInfo::Initialise</h4>
<p>plugin::Call<0x739B60>();</p>
<p>0AA5: call_function 0x739B60 num_params 0 pop 0</p>
<p>define function CShotInfo__Initialise&lt;cdecl, 0x739B60&gt;()</p>
<h4>CShotInfo::Shutdown</h4>
<p>plugin::Call<0x739C20>();</p>
<p>0AA5: call_function 0x739C20 num_params 0 pop 0</p>
<p>define function CShotInfo__Shutdown&lt;cdecl, 0x739C20&gt;()</p>
<h4>CShotInfo::AddShot</h4>
<p>plugin::CallAndReturn<bool, 0x739C30, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, origin, target);</p>
<p>0AA7: call_function_return 0x739C30 num_params 4 pop 4 [creator] [weaponType] [origin] [target] func_ret [bool]</p>
<p>define function CShotInfo__AddShot&lt;cdecl, 0x739C30&gt;(creator, weaponType, origin, target): int</p>
<h4>CShotInfo::GetFlameThrowerShotPosn</h4>
<p>plugin::CallAndReturn<bool, 0x739DE0, unsigned char, CVector*>(shotId, outPosn);</p>
<p>0AA7: call_function_return 0x739DE0 num_params 2 pop 2 [shotId] [outPosn] func_ret [bool]</p>
<p>define function CShotInfo__GetFlameThrowerShotPosn&lt;cdecl, 0x739DE0&gt;(shotId, outPosn): int</p>
<h4>CShotInfo::Update</h4>
<p>plugin::Call<0x739E60>();</p>
<p>0AA5: call_function 0x739E60 num_params 0 pop 0</p>
<p>define function CShotInfo__Update&lt;cdecl, 0x739E60&gt;()</p><h3 id="plugin_sagame_sacspecialfxcpp">plugin_sa\game_sa\CSpecialFX.cpp</h3><h4>CSpecialFX::AddWeaponStreak</h4>
<p>plugin::Call<0x7233F0, int>(weaponType);</p>
<p>0AA5: call_function 0x7233F0 num_params 1 pop 1 [weaponType]</p>
<p>define function CSpecialFX__AddWeaponStreak&lt;cdecl, 0x7233F0&gt;(weaponType)</p>
<h4>CSpecialFX::Init</h4>
<p>plugin::Call<0x7268F0>();</p>
<p>0AA5: call_function 0x7268F0 num_params 0 pop 0</p>
<p>define function CSpecialFX__Init&lt;cdecl, 0x7268F0&gt;()</p>
<h4>CSpecialFX::Render</h4>
<p>plugin::Call<0x726AD0>();</p>
<p>0AA5: call_function 0x726AD0 num_params 0 pop 0</p>
<p>define function CSpecialFX__Render&lt;cdecl, 0x726AD0&gt;()</p>
<h4>CSpecialFX::Render2DFXs</h4>
<p>plugin::Call<0x721660>();</p>
<p>0AA5: call_function 0x721660 num_params 0 pop 0</p>
<p>define function CSpecialFX__Render2DFXs&lt;cdecl, 0x721660&gt;()</p>
<h4>CSpecialFX::ReplayStarted</h4>
<p>plugin::Call<0x721D30>();</p>
<p>0AA5: call_function 0x721D30 num_params 0 pop 0</p>
<p>define function CSpecialFX__ReplayStarted&lt;cdecl, 0x721D30&gt;()</p>
<h4>CSpecialFX::Shutdown</h4>
<p>plugin::Call<0x723390>();</p>
<p>0AA5: call_function 0x723390 num_params 0 pop 0</p>
<p>define function CSpecialFX__Shutdown&lt;cdecl, 0x723390&gt;()</p>
<h4>CSpecialFX::Update</h4>
<p>plugin::Call<0x726AA0>();</p>
<p>0AA5: call_function 0x726AA0 num_params 0 pop 0</p>
<p>define function CSpecialFX__Update&lt;cdecl, 0x726AA0&gt;()</p><h3 id="plugin_sagame_sacspecialplatehandlercpp">plugin_sa\game_sa\CSpecialPlateHandler.cpp</h3><h4>CSpecialPlateHandler::Init</h4>
<p>plugin::CallMethod<0x6F2D10, CSpecialPlateHandler *>(this);</p>
<p>0AA6: call_method 0x6F2D10 struct [CSpecialPlateHandler] num_params 0 pop 0</p>
<p>define function CSpecialPlateHandler__Init&lt;thiscall, 0x6F2D10&gt;()</p>
<h4>CSpecialPlateHandler::Find</h4>
<p>plugin::CallMethodAndReturn<int, 0x6F2D30, CSpecialPlateHandler <em>, int, char</em>>(this, carGenId, outText);</p>
<p>0AA8: call_method_return 0x6F2D30 struct [CSpecialPlateHandler] num_params 2 pop 0 [carGenId] [outText] func_ret [int]</p>
<p>define function CSpecialPlateHandler__Find&lt;thiscall, 0x6F2D30&gt;(carGenId, outText): int</p>
<h4>CSpecialPlateHandler::Add</h4>
<p>plugin::CallMethod<0x6F2D90, CSpecialPlateHandler <em>, int, char</em>>(this, carGenId, plateText);</p>
<p>0AA6: call_method 0x6F2D90 struct [CSpecialPlateHandler] num_params 2 pop 0 [carGenId] [plateText]</p>
<p>define function CSpecialPlateHandler__Add&lt;thiscall, 0x6F2D90&gt;(carGenId, plateText)</p>
<h4>CSpecialPlateHandler::Remove</h4>
<p>plugin::CallMethod<0x6F2DD0, CSpecialPlateHandler *, int>(this, plateTextId);</p>
<p>0AA6: call_method 0x6F2DD0 struct [CSpecialPlateHandler] num_params 1 pop 0 [plateTextId]</p>
<p>define function CSpecialPlateHandler__Remove&lt;thiscall, 0x6F2DD0&gt;(plateTextId)</p><h3 id="plugin_sagame_sacstatscpp">plugin_sa\game_sa\CStats.cpp</h3><h4>CStats::GetStatID</h4>
<p>plugin::CallAndReturn<char*, 0x558DE0, unsigned short>(stat);</p>
<p>0AA7: call_function_return 0x558DE0 num_params 1 pop 1 [stat] func_ret [char*]</p>
<p>define function CStats__GetStatID&lt;cdecl, 0x558DE0&gt;(stat): int</p>
<h4>CStats::GetStatType</h4>
<p>plugin::CallAndReturn<bool, 0x558E30, unsigned short>(stat);</p>
<p>0AA7: call_function_return 0x558E30 num_params 1 pop 1 [stat] func_ret [bool]</p>
<p>define function CStats__GetStatType&lt;cdecl, 0x558E30&gt;(stat): int</p>
<h4>CStats::GetStatValue</h4>
<p>plugin::CallAndReturn<float, 0x558E40, unsigned short>(stat);</p>
<p>0AA7: call_function_return 0x558E40 num_params 1 pop 1 [stat] func_ret [float]</p>
<p>define function CStats__GetStatValue&lt;cdecl, 0x558E40&gt;(stat): float</p>
<h4>CStats::GetTimesMissionAttempted</h4>
<p>plugin::CallAndReturn<char, 0x558E70, unsigned char>(missionId);</p>
<p>0AA7: call_function_return 0x558E70 num_params 1 pop 1 [missionId] func_ret [char]</p>
<p>define function CStats__GetTimesMissionAttempted&lt;cdecl, 0x558E70&gt;(missionId): int</p>
<h4>CStats::RegisterMissionAttempted</h4>
<p>plugin::Call<0x558E80, unsigned char>(missionId);</p>
<p>0AA5: call_function 0x558E80 num_params 1 pop 1 [missionId]</p>
<p>define function CStats__RegisterMissionAttempted&lt;cdecl, 0x558E80&gt;(missionId)</p>
<h4>CStats::RegisterMissionPassed</h4>
<p>plugin::Call<0x558EA0, unsigned char>(missionId);</p>
<p>0AA5: call_function 0x558EA0 num_params 1 pop 1 [missionId]</p>
<p>define function CStats__RegisterMissionPassed&lt;cdecl, 0x558EA0&gt;(missionId)</p>
<h4>CStats::PopulateFavoriteRadioStationList</h4>
<p>plugin::CallAndReturn<bool, 0x558EC0>();</p>
<p>0AA7: call_function_return 0x558EC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStats__PopulateFavoriteRadioStationList&lt;cdecl, 0x558EC0&gt;(): int</p>
<h4>*CStats::GetFullFavoriteRadioStationList</h4>
<p>plugin::CallAndReturn<int*, 0x558F90>();</p>
<p>0AA7: call_function_return 0x558F90 num_params 0 pop 0 func_ret [int*]</p>
<p>define function CStats__GetFullFavoriteRadioStationList&lt;cdecl, 0x558F90&gt;(): int</p>
<h4>CStats::FindMostFavoriteRadioStation</h4>
<p>plugin::CallAndReturn<int, 0x558FA0>();</p>
<p>0AA7: call_function_return 0x558FA0 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStats__FindMostFavoriteRadioStation&lt;cdecl, 0x558FA0&gt;(): int</p>
<h4>CStats::FindLeastFavoriteRadioStation</h4>
<p>plugin::CallAndReturn<int, 0x559010>();</p>
<p>0AA7: call_function_return 0x559010 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStats__FindLeastFavoriteRadioStation&lt;cdecl, 0x559010&gt;(): int</p>
<h4>CStats::FindCriminalRatingNumber</h4>
<p>plugin::CallAndReturn<int, 0x559080>();</p>
<p>0AA7: call_function_return 0x559080 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStats__FindCriminalRatingNumber&lt;cdecl, 0x559080&gt;(): int</p>
<h4>CStats::GetPercentageProgress</h4>
<p>plugin::CallAndReturn<float, 0x5591E0>();</p>
<p>0AA7: call_function_return 0x5591E0 num_params 0 pop 0 func_ret [float]</p>
<p>define function CStats__GetPercentageProgress&lt;cdecl, 0x5591E0&gt;(): float</p>
<h4>CStats::BuildStatLine</h4>
<p>plugin::Call<0x559230, char<em>, void</em>, int, void*, int>(line, pValue1, metrics, pValue2, type);</p>
<p>0AA5: call_function 0x559230 num_params 5 pop 5 [line] [pValue1] [metrics] [pValue2] [type]</p>
<p>define function CStats__BuildStatLine&lt;cdecl, 0x559230&gt;(line, pValue1, metrics, pValue2, type)</p>
<h4>CStats::ConvertToMins</h4>
<p>plugin::CallAndReturn<int, 0x559540, int>(value);</p>
<p>0AA7: call_function_return 0x559540 num_params 1 pop 1 [value] func_ret [int]</p>
<p>define function CStats__ConvertToMins&lt;cdecl, 0x559540&gt;(value): int</p>
<h4>CStats::ConvertToSecs</h4>
<p>plugin::CallAndReturn<int, 0x559560, int>(value);</p>
<p>0AA7: call_function_return 0x559560 num_params 1 pop 1 [value] func_ret [int]</p>
<p>define function CStats__ConvertToSecs&lt;cdecl, 0x559560&gt;(value): int</p>
<h4>CStats::SafeToShowThisStat</h4>
<p>plugin::CallAndReturn<bool, 0x559590, unsigned char>(stat);</p>
<p>0AA7: call_function_return 0x559590 num_params 1 pop 1 [stat] func_ret [bool]</p>
<p>define function CStats__SafeToShowThisStat&lt;cdecl, 0x559590&gt;(stat): int</p>
<h4>CStats::CheckForThreshold</h4>
<p>plugin::CallAndReturn<bool, 0x5595F0, float*, float>(pValue, range);</p>
<p>0AA7: call_function_return 0x5595F0 num_params 2 pop 2 [pValue] [range] func_ret [bool]</p>
<p>define function CStats__CheckForThreshold&lt;cdecl, 0x5595F0&gt;(pValue, range): int</p>
<h4>CStats::IsStatCapped</h4>
<p>plugin::CallAndReturn<bool, 0x559630, unsigned short>(stat);</p>
<p>0AA7: call_function_return 0x559630 num_params 1 pop 1 [stat] func_ret [bool]</p>
<p>define function CStats__IsStatCapped&lt;cdecl, 0x559630&gt;(stat): int</p>
<h4>CStats::ProcessReactionStatsOnDecrement</h4>
<p>plugin::Call<0x559730, unsigned char>(stat);</p>
<p>0AA5: call_function 0x559730 num_params 1 pop 1 [stat]</p>
<p>define function CStats__ProcessReactionStatsOnDecrement&lt;cdecl, 0x559730&gt;(stat)</p>
<h4>CStats::CheckForStatsMessage</h4>
<p>plugin::Call<0x559760>();</p>
<p>0AA5: call_function 0x559760 num_params 0 pop 0</p>
<p>define function CStats__CheckForStatsMessage&lt;cdecl, 0x559760&gt;()</p>
<h4>CStats::LoadStatUpdateConditions</h4>
<p>plugin::Call<0x559860>();</p>
<p>0AA5: call_function 0x559860 num_params 0 pop 0</p>
<p>define function CStats__LoadStatUpdateConditions&lt;cdecl, 0x559860&gt;()</p>
<h4>CStats::LoadActionReactionStats</h4>
<p>plugin::Call<0x5599B0>();</p>
<p>0AA5: call_function 0x5599B0 num_params 0 pop 0</p>
<p>define function CStats__LoadActionReactionStats&lt;cdecl, 0x5599B0&gt;()</p>
<h4>CStats::FindMaxNumberOfGroupMembers</h4>
<p>plugin::CallAndReturn<int, 0x559A50>();</p>
<p>0AA7: call_function_return 0x559A50 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStats__FindMaxNumberOfGroupMembers&lt;cdecl, 0x559A50&gt;(): int</p>
<h4>CStats::GetFatAndMuscleModifier</h4>
<p>plugin::CallAndReturn<float, 0x559AF0, eStatModAbilities>(statMod);</p>
<p>0AA7: call_function_return 0x559AF0 num_params 1 pop 1 [statMod] func_ret [float]</p>
<p>define function CStats__GetFatAndMuscleModifier&lt;cdecl, 0x559AF0&gt;(statMod): float</p>
<h4>CStats::DecrementStat</h4>
<p>plugin::Call<0x559FA0, unsigned short, float>(stat, value);</p>
<p>0AA5: call_function 0x559FA0 num_params 2 pop 2 [stat] [value]</p>
<p>define function CStats__DecrementStat&lt;cdecl, 0x559FA0&gt;(stat, value)</p>
<h4>CStats::SetStatValue</h4>
<p>plugin::Call<0x55A070, unsigned short, float>(stat, value);</p>
<p>0AA5: call_function 0x55A070 num_params 2 pop 2 [stat] [value]</p>
<p>define function CStats__SetStatValue&lt;cdecl, 0x55A070&gt;(stat, value)</p>
<h4>CStats::RegisterFastestTime</h4>
<p>plugin::Call<0x55A0B0, int, int>(stat, time);</p>
<p>0AA5: call_function 0x55A0B0 num_params 2 pop 2 [stat] [time]</p>
<p>define function CStats__RegisterFastestTime&lt;cdecl, 0x55A0B0&gt;(stat, time)</p>
<h4>CStats::RegisterBestPosition</h4>
<p>plugin::Call<0x55A160, int, int>(stat, position);</p>
<p>0AA5: call_function 0x55A160 num_params 2 pop 2 [stat] [position]</p>
<p>define function CStats__RegisterBestPosition&lt;cdecl, 0x55A160&gt;(stat, position)</p>
<h4>CStats::FindCriminalRatingString</h4>
<p>plugin::CallAndReturn<char*, 0x55A210>();</p>
<p>0AA7: call_function_return 0x55A210 num_params 0 pop 0 func_ret [char*]</p>
<p>define function CStats__FindCriminalRatingString&lt;cdecl, 0x55A210&gt;(): int</p>
<h4>CStats::ConstructStatLine</h4>
<p>plugin::CallAndReturn<int, 0x55A780, int, unsigned char>(arg0, arg1);</p>
<p>0AA7: call_function_return 0x55A780 num_params 2 pop 2 [arg0] [arg1] func_ret [int]</p>
<p>define function CStats__ConstructStatLine&lt;cdecl, 0x55A780&gt;(arg0, arg1): int</p>
<h4>CStats::ProcessReactionStatsOnIncrement</h4>
<p>plugin::Call<0x55B900, unsigned char>(stat);</p>
<p>0AA5: call_function 0x55B900 num_params 1 pop 1 [stat]</p>
<p>define function CStats__ProcessReactionStatsOnIncrement&lt;cdecl, 0x55B900&gt;(stat)</p>
<h4>CStats::DisplayScriptStatUpdateMessage</h4>
<p>plugin::Call<0x55B980, unsigned char, unsigned int, float>(state, stat, value);</p>
<p>0AA5: call_function 0x55B980 num_params 3 pop 3 [state] [stat] [value]</p>
<p>define function CStats__DisplayScriptStatUpdateMessage&lt;cdecl, 0x55B980&gt;(state, stat, value)</p>
<h4>CStats::UpdateRespectStat</h4>
<p>plugin::Call<0x55BC50, unsigned char>(arg0);</p>
<p>0AA5: call_function 0x55BC50 num_params 1 pop 1 [arg0]</p>
<p>define function CStats__UpdateRespectStat&lt;cdecl, 0x55BC50&gt;(arg0)</p>
<h4>CStats::UpdateSexAppealStat</h4>
<p>plugin::Call<0x55BF20>();</p>
<p>0AA5: call_function 0x55BF20 num_params 0 pop 0</p>
<p>define function CStats__UpdateSexAppealStat&lt;cdecl, 0x55BF20&gt;()</p>
<h4>CStats::Init</h4>
<p>plugin::Call<0x55C0C0>();</p>
<p>0AA5: call_function 0x55C0C0 num_params 0 pop 0</p>
<p>define function CStats__Init&lt;cdecl, 0x55C0C0&gt;()</p>
<h4>CStats::IncrementStat</h4>
<p>plugin::Call<0x55C180, unsigned short, float>(stat, value);</p>
<p>0AA5: call_function 0x55C180 num_params 2 pop 2 [stat] [value]</p>
<p>define function CStats__IncrementStat&lt;cdecl, 0x55C180&gt;(stat, value)</p>
<h4>CStats::SetNewRecordStat</h4>
<p>plugin::Call<0x55C410, unsigned short, float>(stat, value);</p>
<p>0AA5: call_function 0x55C410 num_params 2 pop 2 [stat] [value]</p>
<p>define function CStats__SetNewRecordStat&lt;cdecl, 0x55C410&gt;(stat, value)</p>
<h4>CStats::UpdateFatAndMuscleStats</h4>
<p>plugin::Call<0x55C470, unsigned int>(value);</p>
<p>0AA5: call_function 0x55C470 num_params 1 pop 1 [value]</p>
<p>define function CStats__UpdateFatAndMuscleStats&lt;cdecl, 0x55C470&gt;(value)</p>
<h4>CStats::UpdateStatsWhenSprinting</h4>
<p>plugin::Call<0x55C660>();</p>
<p>0AA5: call_function 0x55C660 num_params 0 pop 0</p>
<p>define function CStats__UpdateStatsWhenSprinting&lt;cdecl, 0x55C660&gt;()</p>
<h4>CStats::UpdateStatsWhenRunning</h4>
<p>plugin::Call<0x55C6F0>();</p>
<p>0AA5: call_function 0x55C6F0 num_params 0 pop 0</p>
<p>define function CStats__UpdateStatsWhenRunning&lt;cdecl, 0x55C6F0&gt;()</p>
<h4>CStats::UpdateStatsWhenCycling</h4>
<p>plugin::Call<0x55C780, bool, CBmx*>(arg0, bmx);</p>
<p>0AA5: call_function 0x55C780 num_params 2 pop 2 [arg0] [bmx]</p>
<p>define function CStats__UpdateStatsWhenCycling&lt;cdecl, 0x55C780&gt;(arg0, bmx)</p>
<h4>CStats::UpdateStatsWhenSwimming</h4>
<p>plugin::Call<0x55C990, bool, bool>(arg0, arg1);</p>
<p>0AA5: call_function 0x55C990 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CStats__UpdateStatsWhenSwimming&lt;cdecl, 0x55C990&gt;(arg0, arg1)</p>
<h4>CStats::UpdateStatsWhenDriving</h4>
<p>plugin::Call<0x55CAC0, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x55CAC0 num_params 1 pop 1 [vehicle]</p>
<p>define function CStats__UpdateStatsWhenDriving&lt;cdecl, 0x55CAC0&gt;(vehicle)</p>
<h4>CStats::UpdateStatsWhenFlying</h4>
<p>plugin::Call<0x55CC00, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x55CC00 num_params 1 pop 1 [vehicle]</p>
<p>define function CStats__UpdateStatsWhenFlying&lt;cdecl, 0x55CC00&gt;(vehicle)</p>
<h4>CStats::UpdateStatsWhenOnMotorBike</h4>
<p>plugin::Call<0x55CD60, CBike*>(bike);</p>
<p>0AA5: call_function 0x55CD60 num_params 1 pop 1 [bike]</p>
<p>define function CStats__UpdateStatsWhenOnMotorBike&lt;cdecl, 0x55CD60&gt;(bike)</p>
<h4>CStats::UpdateStatsWhenWeaponHit</h4>
<p>plugin::Call<0x55CEB0, int>(weaponType);</p>
<p>0AA5: call_function 0x55CEB0 num_params 1 pop 1 [weaponType]</p>
<p>define function CStats__UpdateStatsWhenWeaponHit&lt;cdecl, 0x55CEB0&gt;(weaponType)</p>
<h4>CStats::UpdateStatsWhenFighting</h4>
<p>plugin::Call<0x55CFA0>();</p>
<p>0AA5: call_function 0x55CFA0 num_params 0 pop 0</p>
<p>define function CStats__UpdateStatsWhenFighting&lt;cdecl, 0x55CFA0&gt;()</p>
<h4>CStats::UpdateStatsOnRespawn</h4>
<p>plugin::Call<0x55CFC0>();</p>
<p>0AA5: call_function 0x55CFC0 num_params 0 pop 0</p>
<p>define function CStats__UpdateStatsOnRespawn&lt;cdecl, 0x55CFC0&gt;()</p>
<h4>CStats::UpdateStatsAddToHealth</h4>
<p>plugin::Call<0x55D030, unsigned int>(addToHealth);</p>
<p>0AA5: call_function 0x55D030 num_params 1 pop 1 [addToHealth]</p>
<p>define function CStats__UpdateStatsAddToHealth&lt;cdecl, 0x55D030&gt;(addToHealth)</p>
<h4>CStats::ModifyStat</h4>
<p>plugin::Call<0x55D090, unsigned short, float>(stat, value);</p>
<p>0AA5: call_function 0x55D090 num_params 2 pop 2 [stat] [value]</p>
<p>define function CStats__ModifyStat&lt;cdecl, 0x55D090&gt;(stat, value)</p>
<h4>CStats::Save</h4>
<p>plugin::CallAndReturn<bool, 0x5D3B40>();</p>
<p>0AA7: call_function_return 0x5D3B40 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStats__Save&lt;cdecl, 0x5D3B40&gt;(): int</p>
<h4>CStats::Load</h4>
<p>plugin::CallAndReturn<bool, 0x5D3BF0>();</p>
<p>0AA7: call_function_return 0x5D3BF0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStats__Load&lt;cdecl, 0x5D3BF0&gt;(): int</p><h3 id="plugin_sagame_sacstreamedscriptscpp">plugin_sa\game_sa\CStreamedScripts.cpp</h3><h4>CStreamedScripts::FindStreamedScript</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::FindStreamedScript), this, scriptname);</p>
<p>0AA8: call_method_return 0x470740 struct [CStreamedScripts] num_params 1 pop 0 [scriptname] func_ret [signed int]</p>
<h4>CStreamedScripts::FindStreamedScriptQuiet</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::FindStreamedScriptQuiet), this, scriptName);</p>
<p>0AA8: call_method_return 0x4706F0 struct [CStreamedScripts] num_params 1 pop 0 [scriptName] func_ret [signed int]</p>
<h4>CStreamedScripts::GetProperIndexFromIndexUsedByScript</h4>
<p>plugin::CallMethodAndReturnDynGlobal<signed short, CStreamedScripts *, short>(gaddrof(CStreamedScripts::GetProperIndexFromIndexUsedByScript), this, scmIndex);</p>
<p>0AA8: call_method_return 0x470810 struct [CStreamedScripts] num_params 1 pop 0 [scmIndex] func_ret [signed short]</p>
<h4>*CStreamedScripts::GetStreamedScriptFilename</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char const *, CStreamedScripts *, unsigned short>(gaddrof(CStreamedScripts::GetStreamedScriptFilename), this, index);</p>
<p>0AA8: call_method_return 0x470900 struct [*CStreamedScripts] num_params 1 pop 0 [index] func_ret [char const *]</p>
<h4>CStreamedScripts::GetStreamedScriptWithThisStartAddress</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned short, CStreamedScripts *, unsigned char *>(gaddrof(CStreamedScripts::GetStreamedScriptWithThisStartAddress), this, dataPtr);</p>
<p>0AA8: call_method_return 0x470910 struct [CStreamedScripts] num_params 1 pop 0 [dataPtr] func_ret [unsigned short]</p>
<h4>CStreamedScripts::Initialise</h4>
<p>plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::Initialise), this);</p>
<p>0AA6: call_method 0x470660 struct [CStreamedScripts] num_params 0 pop 0</p>
<p>define function CStreamedScripts__Initialise&lt;thiscall, 0x470660&gt;()</p>
<h4>CStreamedScripts::LoadStreamedScript</h4>
<p>plugin::CallMethodDynGlobal<CStreamedScripts *, RwStream *, int>(gaddrof(CStreamedScripts::LoadStreamedScript), this, stream, index);</p>
<p>0AA6: call_method 0x470840 struct [CStreamedScripts] num_params 2 pop 0 [stream] [index]</p>
<p>define function CStreamedScripts__LoadStreamedScript&lt;thiscall, 0x470840&gt;(stream, index)</p>
<h4>CStreamedScripts::ReInitialise</h4>
<p>plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::ReInitialise), this);</p>
<p>0AA6: call_method 0x4706A0 struct [CStreamedScripts] num_params 0 pop 0</p>
<p>define function CStreamedScripts__ReInitialise&lt;thiscall, 0x4706A0&gt;()</p>
<h4>CStreamedScripts::ReadStreamedScriptData</h4>
<p>plugin::CallMethodDynGlobal<CStreamedScripts *>(gaddrof(CStreamedScripts::ReadStreamedScriptData), this);</p>
<p>0AA6: call_method 0x470750 struct [CStreamedScripts] num_params 0 pop 0</p>
<p>define function CStreamedScripts__ReadStreamedScriptData&lt;thiscall, 0x470750&gt;()</p>
<h4>CStreamedScripts::RegisterScript</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CStreamedScripts *, char const *>(gaddrof(CStreamedScripts::RegisterScript), this, scriptName);</p>
<p>0AA8: call_method_return 0x4706C0 struct [CStreamedScripts] num_params 1 pop 0 [scriptName] func_ret [int]</p>
<h4>CStreamedScripts::RemoveStreamedScriptFromMemory</h4>
<p>plugin::CallMethodDynGlobal<CStreamedScripts *, int>(gaddrof(CStreamedScripts::RemoveStreamedScriptFromMemory), this, index);</p>
<p>0AA6: call_method 0x4708E0 struct [CStreamedScripts] num_params 1 pop 0 [index]</p>
<p>define function CStreamedScripts__RemoveStreamedScriptFromMemory&lt;thiscall, 0x4708E0&gt;(index)</p>
<h4>*CStreamedScripts::StartNewStreamedScript</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CRunningScript *, CStreamedScripts *, int>(gaddrof(CStreamedScripts::StartNewStreamedScript), this, index);</p>
<p>0AA8: call_method_return 0x470890 struct [*CStreamedScripts] num_params 1 pop 0 [index] func_ret [CRunningScript *]</p><h3 id="plugin_sagame_sacstreamingcpp">plugin_sa\game_sa\CStreaming.cpp</h3><h4>*CStreaming::AddEntity</h4>
<p>plugin::CallAndReturnDynGlobal<void *, CEntity *>(gaddrof(CStreaming::AddEntity), a2);</p>
<p>0AA7: call_function_return 0x409650 num_params 1 pop 1 [a2] func_ret [void *]</p>
<p>define function CStreaming__AddEntity&lt;cdecl, 0x409650&gt;(a2): int</p>
<h4>CStreaming::AddImageToList</h4>
<p>plugin::CallAndReturnDynGlobal<int, char const *, bool>(gaddrof(CStreaming::AddImageToList), lpFileName, bNotPlayerImg);</p>
<p>0AA7: call_function_return 0x407610 num_params 2 pop 2 [lpFileName] [bNotPlayerImg] func_ret [int]</p>
<p>define function CStreaming__AddImageToList&lt;cdecl, 0x407610&gt;(lpFileName, bNotPlayerImg): int</p>
<h4>CStreaming::AddLodsToRequestList</h4>
<p>plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddLodsToRequestList), Posn, Streamingflags);</p>
<h4>CStreaming::AddModelsToRequestList</h4>
<p>plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddModelsToRequestList), posn, StreamingFlags);</p>
<h4>CStreaming::AddToLoadedVehiclesList</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::AddToLoadedVehiclesList));</p>
<p>0AA7: call_function_return 0x408000 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__AddToLoadedVehiclesList&lt;cdecl, 0x408000&gt;(): int</p>
<h4>CStreaming::AreAnimsUsedByRequestedModels</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreAnimsUsedByRequestedModels), AnimFileIndex);</p>
<p>0AA7: call_function_return 0x407AD0 num_params 1 pop 1 [AnimFileIndex] func_ret [bool]</p>
<p>define function CStreaming__AreAnimsUsedByRequestedModels&lt;cdecl, 0x407AD0&gt;(AnimFileIndex): int</p>
<h4>CStreaming::AreTexturesUsedByRequestedModels</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreTexturesUsedByRequestedModels), txdIndex);</p>
<p>0AA7: call_function_return 0x409A90 num_params 1 pop 1 [txdIndex] func_ret [bool]</p>
<p>define function CStreaming__AreTexturesUsedByRequestedModels&lt;cdecl, 0x409A90&gt;(txdIndex): int</p>
<h4>CStreaming::ClearFlagForAll</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CStreaming::ClearFlagForAll), eStreamingFlag);</p>
<h4>CStreaming::ClearSlots</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::ClearSlots), NumOfSlots);</p>
<h4>CStreaming::ConvertBufferToObject</h4>
<p>plugin::CallAndReturnDynGlobal<char, char *, int, int>(gaddrof(CStreaming::ConvertBufferToObject), pFileContect, index, ChannelIndex);</p>
<p>0AA7: call_function_return 0x40C6B0 num_params 3 pop 3 [pFileContect] [index] [ChannelIndex] func_ret [char]</p>
<p>define function CStreaming__ConvertBufferToObject&lt;cdecl, 0x40C6B0&gt;(pFileContect, index, ChannelIndex): int</p>
<h4>CStreaming::DeleteLeastUsedEntityRwObject</h4>
<p>plugin::CallAndReturnDynGlobal<bool, bool, unsigned int>(gaddrof(CStreaming::DeleteLeastUsedEntityRwObject), bNotOnScreen, StreamingFlags);</p>
<p>0AA7: call_function_return 0x409760 num_params 2 pop 2 [bNotOnScreen] [StreamingFlags] func_ret [bool]</p>
<p>define function CStreaming__DeleteLeastUsedEntityRwObject&lt;cdecl, 0x409760&gt;(bNotOnScreen, StreamingFlags): int</p>
<h4>CStreaming::DeleteRwObjectsAfterDeath</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteRwObjectsAfterDeath), PlayerPosn);</p>
<h4>CStreaming::DeleteRwObjectsBehindCamera</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::DeleteRwObjectsBehindCamera), memoryToCleanInBytes);</p>
<h4>CStreaming::DeleteRwObjectsBehindCameraInSectorList</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsBehindCameraInSectorList), List, memoryToCleanInBytes);</p>
<p>0AA7: call_function_return 0x409940 num_params 2 pop 2 [List] [memoryToCleanInBytes] func_ret [bool]</p>
<p>define function CStreaming__DeleteRwObjectsBehindCameraInSectorList&lt;cdecl, 0x409940&gt;(List, memoryToCleanInBytes): int</p>
<h4>CStreaming::DeleteRwObjectsInSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, int, int>(gaddrof(CStreaming::DeleteRwObjectsInSectorList), PtrList, arg2, arg3);</p>
<h4>CStreaming::DeleteRwObjectsNotInFrustumInSectorList</h4>
<p>plugin::CallAndReturnDynGlobal<char, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsNotInFrustumInSectorList), List, memoryToCleanInBytes);</p>
<p>0AA7: call_function_return 0x4099E0 num_params 2 pop 2 [List] [memoryToCleanInBytes] func_ret [char]</p>
<p>define function CStreaming__DeleteRwObjectsNotInFrustumInSectorList&lt;cdecl, 0x4099E0&gt;(List, memoryToCleanInBytes): int</p>
<h4>CStreaming::DisableCopBikes</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CStreaming::DisableCopBikes), bDisable);</p>
<h4>CStreaming::FindMIPedSlotForInterior</h4>
<p>plugin::CallAndReturnDynGlobal<int, int>(gaddrof(CStreaming::FindMIPedSlotForInterior), RandFactor);</p>
<p>0AA7: call_function_return 0x407FB0 num_params 1 pop 1 [RandFactor] func_ret [int]</p>
<p>define function CStreaming__FindMIPedSlotForInterior&lt;cdecl, 0x407FB0&gt;(RandFactor): int</p>
<h4>CStreaming::FinishLoadingLargeFile</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char *, int>(gaddrof(CStreaming::FinishLoadingLargeFile), FileName, modelIndex);</p>
<p>0AA7: call_function_return 0x408CB0 num_params 2 pop 2 [FileName] [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__FinishLoadingLargeFile&lt;cdecl, 0x408CB0&gt;(FileName, modelIndex): int</p>
<h4>CStreaming::FlushChannels</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::FlushChannels));</p>
<p>0AA7: call_function_return 0x40E460 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__FlushChannels&lt;cdecl, 0x40E460&gt;(): int</p>
<h4>CStreaming::FlushRequestList</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::FlushRequestList));</p>
<p>0AA7: call_function_return 0x40E4E0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__FlushRequestList&lt;cdecl, 0x40E4E0&gt;(): int</p>
<h4>CStreaming::ForceLayerToRead</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::ForceLayerToRead), arg1);</p>
<h4>CStreaming::GetDefaultCabDriverModel</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultCabDriverModel));</p>
<p>0AA7: call_function_return 0x407D50 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStreaming__GetDefaultCabDriverModel&lt;cdecl, 0x407D50&gt;(): int</p>
<h4>CStreaming::GetDefaultCopCarModel</h4>
<p>plugin::CallAndReturnDynGlobal<int, unsigned int>(gaddrof(CStreaming::GetDefaultCopCarModel), bIncludeCopBike);</p>
<p>0AA7: call_function_return 0x407C50 num_params 1 pop 1 [bIncludeCopBike] func_ret [int]</p>
<p>define function CStreaming__GetDefaultCopCarModel&lt;cdecl, 0x407C50&gt;(bIncludeCopBike): int</p>
<h4>CStreaming::GetDefaultCopModel</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultCopModel));</p>
<p>0AA7: call_function_return 0x407C00 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStreaming__GetDefaultCopModel&lt;cdecl, 0x407C00&gt;(): int</p>
<h4>CStreaming::GetDefaultFiremanModel</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultFiremanModel));</p>
<p>0AA7: call_function_return 0x407D40 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStreaming__GetDefaultFiremanModel&lt;cdecl, 0x407D40&gt;(): int</p>
<h4>CStreaming::GetDefaultMedicModel</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CStreaming::GetDefaultMedicModel));</p>
<p>0AA7: call_function_return 0x407D20 num_params 0 pop 0 func_ret [int]</p>
<p>define function CStreaming__GetDefaultMedicModel&lt;cdecl, 0x407D20&gt;(): int</p>
<h4>CStreaming::GetDiscInDrive</h4>
<p>plugin::CallAndReturnDynGlobal<signed int>(gaddrof(CStreaming::GetDiscInDrive));</p>
<p>0AA7: call_function_return 0x40E9B0 num_params 0 pop 0 func_ret [signed int]</p>
<p>define function CStreaming__GetDiscInDrive&lt;cdecl, 0x40E9B0&gt;(): int</p>
<h4>CStreaming::GetNextFileOnCd</h4>
<p>plugin::CallAndReturnDynGlobal<int, int, bool>(gaddrof(CStreaming::GetNextFileOnCd), pos, bNotPriority);</p>
<p>0AA7: call_function_return 0x408E20 num_params 2 pop 2 [pos] [bNotPriority] func_ret [int]</p>
<p>define function CStreaming__GetNextFileOnCd&lt;cdecl, 0x408E20&gt;(pos, bNotPriority): int</p>
<h4>CStreaming::HasSpecialCharLoaded</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasSpecialCharLoaded), slot);</p>
<p>0AA7: call_function_return 0x407F00 num_params 1 pop 1 [slot] func_ret [bool]</p>
<p>define function CStreaming__HasSpecialCharLoaded&lt;cdecl, 0x407F00&gt;(slot): int</p>
<h4>CStreaming::HasVehicleUpgradeLoaded</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasVehicleUpgradeLoaded), ModelIndex);</p>
<p>0AA7: call_function_return 0x407820 num_params 1 pop 1 [ModelIndex] func_ret [bool]</p>
<p>define function CStreaming__HasVehicleUpgradeLoaded&lt;cdecl, 0x407820&gt;(ModelIndex): int</p>
<h4>CStreaming::InstanceLoadedModels</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::InstanceLoadedModels), posn);</p>
<h4>CStreaming::IsCarModelNeededInCurrentZone</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsCarModelNeededInCurrentZone), VehicleModelIndex);</p>
<p>0AA7: call_function_return 0x407DD0 num_params 1 pop 1 [VehicleModelIndex] func_ret [bool]</p>
<p>define function CStreaming__IsCarModelNeededInCurrentZone&lt;cdecl, 0x407DD0&gt;(VehicleModelIndex): int</p>
<h4>CStreaming::IsInitialised</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::IsInitialised));</p>
<p>0AA7: call_function_return 0x407600 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__IsInitialised&lt;cdecl, 0x407600&gt;(): int</p>
<h4>CStreaming::IsObjectInCdImage</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsObjectInCdImage), ModelInex);</p>
<p>0AA7: call_function_return 0x407800 num_params 1 pop 1 [ModelInex] func_ret [bool]</p>
<p>define function CStreaming__IsObjectInCdImage&lt;cdecl, 0x407800&gt;(ModelInex): int</p>
<h4>CStreaming::IsVeryBusy</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::IsVeryBusy));</p>
<p>0AA7: call_function_return 0x4076A0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__IsVeryBusy&lt;cdecl, 0x4076A0&gt;(): int</p>
<h4>CStreaming::LoadAllRequestedModels</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CStreaming::LoadAllRequestedModels), bOnlyPriorityRequests);</p>
<h4>CStreaming::LoadCdDirectory</h4>
<p>plugin::CallDynGlobal<char const *, int>(gaddrof_o(CStreaming::LoadCdDirectory, void (*)(char const *, int)), ArchiveName, archiveID);</p>
<h4>CStreaming::LoadScene</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadScene), Posn);</p>
<h4>CStreaming::LoadSceneCollision</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadSceneCollision), Posn);</p>
<h4>CStreaming::LoadZoneVehicle</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadZoneVehicle), posn);</p>
<h4>CStreaming::MakeSpaceFor</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::MakeSpaceFor), memoryToCleanInBytes);</p>
<h4>CStreaming::PossiblyStreamCarOutAfterCreation</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::PossiblyStreamCarOutAfterCreation), modelId);</p>
<h4>CStreaming::ProcessEntitiesInSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, float, float, float, float, float, float, float, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, float, float, float, float, float, float, float, unsigned int)), list, posn_x, posn_y, min_posn_x, min_posn_y, max_posn_x, max_posn_y, distance, Streamingflags);</p>
<h4>CStreaming::ProcessEntitiesInSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, unsigned int)), list, streamingFlags);</p>
<h4>CStreaming::ProcessLoadingChannel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::ProcessLoadingChannel), channelIndex);</p>
<p>0AA7: call_function_return 0x40E170 num_params 1 pop 1 [channelIndex] func_ret [bool]</p>
<p>define function CStreaming__ProcessLoadingChannel&lt;cdecl, 0x40E170&gt;(channelIndex): int</p>
<h4>CStreaming::ReInit</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CStreaming::ReInit));</p>
<p>0AA7: call_function_return 0x40E560 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CStreaming__ReInit&lt;cdecl, 0x40E560&gt;(): int</p>
<h4>CStreaming::RemoveBuildingsNotInArea</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveBuildingsNotInArea), AreaCode);</p>
<h4>CStreaming::RemoveCarModel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveCarModel), modelIndex);</p>
<h4>CStreaming::RemoveEntity</h4>
<p>plugin::CallDynGlobal<CLink<CEntity*> *&gt;(gaddrof(CStreaming::RemoveEntity), streamingLink);</p>
<h4>CStreaming::RemoveLeastUsedModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned int>(gaddrof(CStreaming::RemoveLeastUsedModel), StreamingFlags);</p>
<p>0AA7: call_function_return 0x40CFD0 num_params 1 pop 1 [StreamingFlags] func_ret [bool]</p>
<p>define function CStreaming__RemoveLeastUsedModel&lt;cdecl, 0x40CFD0&gt;(StreamingFlags): int</p>
<h4>CStreaming::RemoveLoadedVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedVehicle));</p>
<p>0AA7: call_function_return 0x40C020 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__RemoveLoadedVehicle&lt;cdecl, 0x40C020&gt;(): int</p>
<h4>CStreaming::RemoveLoadedZoneModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedZoneModel));</p>
<p>0AA7: call_function_return 0x40B340 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__RemoveLoadedZoneModel&lt;cdecl, 0x40B340&gt;(): int</p>
<h4>CStreaming::RemoveModel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveModel), Modelindex);</p>
<h4>CStreaming::RemoveUnusedModelsInLoadedList</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CStreaming::RemoveUnusedModelsInLoadedList));</p>
<p>0AA7: call_function_return 0x407AC0 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CStreaming__RemoveUnusedModelsInLoadedList&lt;cdecl, 0x407AC0&gt;(): int</p>
<h4>CStreaming::RenderEntity</h4>
<p>plugin::CallDynGlobal<CLink<CEntity*> *&gt;(gaddrof(CStreaming::RenderEntity), streamingLink);</p>
<h4>CStreaming::RequestBigBuildings</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::RequestBigBuildings), posn);</p>
<h4>CStreaming::RequestFile</h4>
<p>plugin::CallDynGlobal<int, int, int, int, int>(gaddrof(CStreaming::RequestFile), index, offset, size, imgId, streamingFlags);</p>
<h4>CStreaming::RequestFilesInChannel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestFilesInChannel), channelId);</p>
<h4>CStreaming::RequestModel</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestModel), dwModelId, Streamingflags);</p>
<h4>CStreaming::RequestModelStream</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestModelStream), streamNum);</p>
<h4>CStreaming::RequestPlayerSection</h4>
<p>plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestPlayerSection), modelIndex, string, streamingFlags);</p>
<h4>CStreaming::RequestSpecialChar</h4>
<p>plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialChar), slot, Name, streamingFlags);</p>
<h4>CStreaming::RequestSpecialModel</h4>
<p>plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialModel), slot, name, StreamingFlags);</p>
<h4>CStreaming::RequestTxdModel</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestTxdModel), TxdModelID, Streamingflags);</p>
<h4>CStreaming::RequestVehicleUpgrade</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestVehicleUpgrade), modelIndex, StreamingFlags);</p>
<h4>CStreaming::RetryLoadFile</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RetryLoadFile), streamNum);</p>
<h4>CStreaming::SetLoadVehiclesInLoadScene</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CStreaming::SetLoadVehiclesInLoadScene), bEnable);</p>
<h4>CStreaming::SetMissionDoesntRequireAnim</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireAnim), slot);</p>
<h4>CStreaming::SetMissionDoesntRequireModel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireModel), modelIndex);</p>
<h4>CStreaming::SetMissionDoesntRequireSpecialChar</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireSpecialChar), slot);</p>
<h4>CStreaming::SetModelIsDeletable</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelIsDeletable), modelIndex);</p>
<h4>CStreaming::SetModelTxdIsDeletable</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelTxdIsDeletable), modelIndex);</p>
<h4>CStreaming::SetSpecialCharIsDeletable</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetSpecialCharIsDeletable), slot);</p>
<h4>CStreaming::StreamAmbulanceAndMedic</h4>
<p>plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CStreaming::StreamAmbulanceAndMedic), bStreamForAccident);</p>
<p>0AA7: call_function_return 0x40A2A0 num_params 1 pop 1 [bStreamForAccident] func_ret [bool]</p>
<p>define function CStreaming__StreamAmbulanceAndMedic&lt;cdecl, 0x40A2A0&gt;(bStreamForAccident): int</p>
<h4>CStreaming::StreamCopModels</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::StreamCopModels), townID);</p>
<h4>CStreaming::StreamFireEngineAndFireman</h4>
<p>plugin::CallAndReturnDynGlobal<bool, bool>(gaddrof(CStreaming::StreamFireEngineAndFireman), bStreamForFire);</p>
<p>0AA7: call_function_return 0x40A400 num_params 1 pop 1 [bStreamForFire] func_ret [bool]</p>
<p>define function CStreaming__StreamFireEngineAndFireman&lt;cdecl, 0x40A400&gt;(bStreamForFire): int</p>
<h4>CStreaming::StreamPedsForInterior</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::StreamPedsForInterior), interiorType);</p>
<h4>CStreaming::StreamPedsIntoRandomSlots</h4>
<p>plugin::CallDynGlobal<int *>(gaddrof(CStreaming::StreamPedsIntoRandomSlots), pModelID);</p>
<h4>CStreaming::StreamVehiclesAndPeds_Always</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamVehiclesAndPeds_Always), posn);</p>
<h4>CStreaming::StreamZoneModels</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels), posn);</p>
<h4>CStreaming::StreamZoneModels_Gangs</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels_Gangs), unused);</p>
<h4>CStreaming::WeAreTryingToPhaseVehicleOut</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::WeAreTryingToPhaseVehicleOut), modelIndex);</p>
<p>0AA7: call_function_return 0x407F80 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__WeAreTryingToPhaseVehicleOut&lt;cdecl, 0x407F80&gt;(modelIndex): int</p><h3 id="plugin_sagame_sacstreaminginfocpp">plugin_sa\game_sa\CStreamingInfo.cpp</h3><h4>CStreamingInfo::AddToList</h4>
<p>plugin::CallMethodDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::AddToList), this, listStart);</p>
<p>0AA6: call_method 0x407480 struct [CStreamingInfo] num_params 1 pop 0 [listStart]</p>
<p>define function CStreamingInfo__AddToList&lt;thiscall, 0x407480&gt;(listStart)</p>
<h4>CStreamingInfo::GetCdPosn</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CStreamingInfo *>(gaddrof(CStreamingInfo::GetCdPosn), this);</p>
<p>0AA8: call_method_return 0x407570 struct [CStreamingInfo] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>CStreamingInfo::GetCdPosnAndSize</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CStreamingInfo *, unsigned int *, unsigned int *>(gaddrof(CStreamingInfo::GetCdPosnAndSize), this, CdPosn, CdSize);</p>
<p>0AA8: call_method_return 0x4075A0 struct [CStreamingInfo] num_params 2 pop 0 [CdPosn] [CdSize] func_ret [bool]</p>
<h4>CStreamingInfo::GetCdSize</h4>
<p>plugin::CallMethodAndReturnDynGlobal<unsigned int, CStreamingInfo *>(gaddrof(CStreamingInfo::GetCdSize), this);</p>
<p>0AA8: call_method_return 0x407590 struct [CStreamingInfo] num_params 0 pop 0 func_ret [unsigned int]</p>
<h4>*CStreamingInfo::GetNext</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::GetNext), this);</p>
<p>0AA8: call_method_return 0x407520 struct [*CStreamingInfo] num_params 0 pop 0 func_ret [CStreamingInfo *]</p>
<h4>*CStreamingInfo::GetPrev</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CStreamingInfo *, CStreamingInfo *>(gaddrof(CStreamingInfo::GetPrev), this);</p>
<p>0AA8: call_method_return 0x407540 struct [*CStreamingInfo] num_params 0 pop 0 func_ret [CStreamingInfo *]</p>
<h4>CStreamingInfo::InList</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CStreamingInfo *>(gaddrof(CStreamingInfo::InList), this);</p>
<p>0AA8: call_method_return 0x407560 struct [CStreamingInfo] num_params 0 pop 0 func_ret [bool]</p>
<h4>CStreamingInfo::Init</h4>
<p>plugin::CallMethodDynGlobal<CStreamingInfo *>(gaddrof(CStreamingInfo::Init), this);</p>
<p>0AA6: call_method 0x407460 struct [CStreamingInfo] num_params 0 pop 0</p>
<p>define function CStreamingInfo__Init&lt;thiscall, 0x407460&gt;()</p>
<h4>CStreamingInfo::RemoveFromList</h4>
<p>plugin::CallMethodDynGlobal<CStreamingInfo *>(gaddrof(CStreamingInfo::RemoveFromList), this);</p>
<p>0AA6: call_method 0x4074E0 struct [CStreamingInfo] num_params 0 pop 0</p>
<p>define function CStreamingInfo__RemoveFromList&lt;thiscall, 0x4074E0&gt;()</p>
<h4>CStreamingInfo::SetCdPosnAndSize</h4>
<p>plugin::CallMethodDynGlobal<CStreamingInfo *, unsigned int, unsigned int>(gaddrof(CStreamingInfo::SetCdPosnAndSize), this, CdPosn, CdSize);</p>
<p>0AA6: call_method 0x4075E0 struct [CStreamingInfo] num_params 2 pop 0 [CdPosn] [CdSize]</p>
<p>define function CStreamingInfo__SetCdPosnAndSize&lt;thiscall, 0x4075E0&gt;(CdPosn, CdSize)</p><h3 id="plugin_sagame_sacstuckcarcheckcpp">plugin_sa\game_sa\CStuckCarCheck.cpp</h3><h4>CStuckCarCheck::AddCarToCheck</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *, int, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, signed char>(gaddrof(CStuckCarCheck::AddCarToCheck), this, carHandle, distance, time, a5, bStuck, bFlipped, bWarp, pathID);</p>
<p>0AA6: call_method 0x465970 struct [CStuckCarCheck] num_params 8 pop 0 [carHandle] [distance] [time] [a5] [bStuck] [bFlipped] [bWarp] [pathID]</p>
<p>define function CStuckCarCheck__AddCarToCheck&lt;thiscall, 0x465970&gt;(carHandle, distance, time, a5, bStuck, bFlipped, bWarp, pathID)</p>
<h4>CStuckCarCheck::AttemptToWarpVehicle</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, CVehicle *, CVector *, float>(gaddrof(CStuckCarCheck::AttemptToWarpVehicle), this, vehicle, origin, orientation);</p>
<p>0AA8: call_method_return 0x463A60 struct [CStuckCarCheck] num_params 3 pop 0 [vehicle] [origin] [orientation] func_ret [bool]</p>
<h4>CStuckCarCheck::ClearStuckFlagForCar</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::ClearStuckFlagForCar), this, carHandle);</p>
<p>0AA6: call_method 0x463C40 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle]</p>
<p>define function CStuckCarCheck__ClearStuckFlagForCar&lt;thiscall, 0x463C40&gt;(carHandle)</p>
<h4>CStuckCarCheck::HasCarBeenStuckForAWhile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::HasCarBeenStuckForAWhile), this, carHandle);</p>
<p>0AA8: call_method_return 0x463C00 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle] func_ret [bool]</p>
<h4>CStuckCarCheck::Init</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Init), this);</p>
<p>0AA6: call_method 0x4639E0 struct [CStuckCarCheck] num_params 0 pop 0</p>
<p>define function CStuckCarCheck__Init&lt;thiscall, 0x4639E0&gt;()</p>
<h4>CStuckCarCheck::IsCarInStuckCarArray</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::IsCarInStuckCarArray), this, carHandle);</p>
<p>0AA8: call_method_return 0x463C70 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle] func_ret [bool]</p>
<h4>CStuckCarCheck::Process</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *>(gaddrof(CStuckCarCheck::Process), this);</p>
<p>0AA6: call_method 0x465680 struct [CStuckCarCheck] num_params 0 pop 0</p>
<p>define function CStuckCarCheck__Process&lt;thiscall, 0x465680&gt;()</p>
<h4>CStuckCarCheck::RemoveCarFromCheck</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *, int>(gaddrof(CStuckCarCheck::RemoveCarFromCheck), this, carHandle);</p>
<p>0AA6: call_method 0x463B80 struct [CStuckCarCheck] num_params 1 pop 0 [carHandle]</p>
<p>define function CStuckCarCheck__RemoveCarFromCheck&lt;thiscall, 0x463B80&gt;(carHandle)</p>
<h4>CStuckCarCheck::ResetArrayElement</h4>
<p>plugin::CallMethodDynGlobal<CStuckCarCheck *, unsigned short>(gaddrof(CStuckCarCheck::ResetArrayElement), this, index);</p>
<p>0AA6: call_method 0x463970 struct [CStuckCarCheck] num_params 1 pop 0 [index]</p>
<p>define function CStuckCarCheck__ResetArrayElement&lt;thiscall, 0x463970&gt;(index)</p><h3 id="plugin_sagame_sactaskcomplexcpp">plugin_sa\game_sa\CTaskComplex.cpp</h3><h3 id="plugin_sagame_sactaskcomplexclimbcpp">plugin_sa\game_sa\CTaskComplexClimb.cpp</h3><h3 id="plugin_sagame_sactaskcomplexdiecpp">plugin_sa\game_sa\CTaskComplexDie.cpp</h3><h3 id="plugin_sagame_sactaskcomplexenterboatasdrivercpp">plugin_sa\game_sa\CTaskComplexEnterBoatAsDriver.cpp</h3><h3 id="plugin_sagame_sactaskcomplexentercarcpp">plugin_sa\game_sa\CTaskComplexEnterCar.cpp</h3><h3 id="plugin_sagame_sactaskcomplexentercarasdrivercpp">plugin_sa\game_sa\CTaskComplexEnterCarAsDriver.cpp</h3><h3 id="plugin_sagame_sactaskcomplexentercaraspassengercpp">plugin_sa\game_sa\CTaskComplexEnterCarAsPassenger.cpp</h3><h3 id="plugin_sagame_sactaskcomplexfacialcpp">plugin_sa\game_sa\CTaskComplexFacial.cpp</h3><h3 id="plugin_sagame_sactaskcomplexjumpcpp">plugin_sa\game_sa\CTaskComplexJump.cpp</h3><h3 id="plugin_sagame_sactaskcomplexleavecarcpp">plugin_sa\game_sa\CTaskComplexLeaveCar.cpp</h3><h3 id="plugin_sagame_sactaskcomplexprostitutesolicitcpp">plugin_sa\game_sa\CTaskComplexProstituteSolicit.cpp</h3><h4>CTaskComplexProstituteSolicit::CTaskComplexProstituteSolicit</h4>
<p>plugin::CallMethod<0x661A60, CTaskComplexProstituteSolicit <em>, CPed</em>>(this, pClient);</p>
<p>0AA6: call_method 0x661A60 struct [CTaskComplexProstituteSolicit] num_params 1 pop 0 [pClient]</p>
<p>define function CTaskComplexProstituteSolicit__CTaskComplexProstituteSolicit&lt;thiscall, 0x661A60&gt;(pClient)</p>
<h4>CTaskComplexProstituteSolicit::CreateSubTask</h4>
<p>plugin::CallMethodAndReturn<CTask*, 0x666360, CTaskComplexProstituteSolicit *, int, CPed*>(this, taskId, pProstitute);</p>
<p>0AA8: call_method_return 0x666360 struct [CTaskComplexProstituteSolicit] num_params 2 pop 0 [taskId] [pProstitute] func_ret [CTask*]</p>
<p>define function CTaskComplexProstituteSolicit__CreateSubTask&lt;thiscall, 0x666360&gt;(taskId, pProstitute): int</p>
<h4>CTaskComplexProstituteSolicit::GetRidOfPlayerProstitute</h4>
<p>plugin::Call<0x661D30>();</p>
<p>0AA5: call_function 0x661D30 num_params 0 pop 0</p>
<p>define function CTaskComplexProstituteSolicit__GetRidOfPlayerProstitute&lt;cdecl, 0x661D30&gt;()</p>
<h4>CTaskComplexProstituteSolicit::IsTaskValid</h4>
<p>plugin::CallAndReturn<bool, 0x661BB0, CPed<em>, CPed</em>>(pProstitute, pClient);</p>
<p>0AA7: call_function_return 0x661BB0 num_params 2 pop 2 [pProstitute] [pClient] func_ret [bool]</p>
<p>define function CTaskComplexProstituteSolicit__IsTaskValid&lt;cdecl, 0x661BB0&gt;(pProstitute, pClient): int</p><h3 id="plugin_sagame_sactaskcomplexsequencecpp">plugin_sa\game_sa\CTaskComplexSequence.cpp</h3><h3 id="plugin_sagame_sactaskcomplexstuckinaircpp">plugin_sa\game_sa\CTaskComplexStuckInAir.cpp</h3><h3 id="plugin_sagame_sactaskcomplexsunbathecpp">plugin_sa\game_sa\CTaskComplexSunbathe.cpp</h3><h3 id="plugin_sagame_sactaskcomplexusemobilephonecpp">plugin_sa\game_sa\CTaskComplexUseMobilePhone.cpp</h3><h3 id="plugin_sagame_sactaskcomplexwandercpp">plugin_sa\game_sa\CTaskComplexWander.cpp</h3><h3 id="plugin_sagame_sactaskcomplexwanderstandardcpp">plugin_sa\game_sa\CTaskComplexWanderStandard.cpp</h3><h3 id="plugin_sagame_sactasksimpleanimcpp">plugin_sa\game_sa\CTaskSimpleAnim.cpp</h3><h3 id="plugin_sagame_sactasksimplecarsetpedinaspassengercpp">plugin_sa\game_sa\CTaskSimpleCarSetPedInAsPassenger.cpp</h3><h3 id="plugin_sagame_sactasksimplecarsetpedoutcpp">plugin_sa\game_sa\CTaskSimpleCarSetPedOut.cpp</h3><h3 id="plugin_sagame_sactasksimplechokingcpp">plugin_sa\game_sa\CTaskSimpleChoking.cpp</h3><h3 id="plugin_sagame_sactasksimpleclimbcpp">plugin_sa\game_sa\CTaskSimpleClimb.cpp</h3><h3 id="plugin_sagame_sactasksimpleduckcpp">plugin_sa\game_sa\CTaskSimpleDuck.cpp</h3><h3 id="plugin_sagame_sactasksimpleducktogglecpp">plugin_sa\game_sa\CTaskSimpleDuckToggle.cpp</h3><h3 id="plugin_sagame_sactasksimplefacialcpp">plugin_sa\game_sa\CTaskSimpleFacial.cpp</h3><h3 id="plugin_sagame_sactasksimplefightcpp">plugin_sa\game_sa\CTaskSimpleFight.cpp</h3><h3 id="plugin_sagame_sactasksimplegangdrivebycpp">plugin_sa\game_sa\CTaskSimpleGangDriveBy.cpp</h3><h3 id="plugin_sagame_sactasksimpleikchaincpp">plugin_sa\game_sa\CTaskSimpleIKChain.cpp</h3><h3 id="plugin_sagame_sactasksimpleiklookatcpp">plugin_sa\game_sa\CTaskSimpleIKLookAt.cpp</h3><h3 id="plugin_sagame_sactasksimpleikmanagercpp">plugin_sa\game_sa\CTaskSimpleIKManager.cpp</h3><h3 id="plugin_sagame_sactasksimpleinaircpp">plugin_sa\game_sa\CTaskSimpleInAir.cpp</h3><h3 id="plugin_sagame_sactasksimplejetpackcpp">plugin_sa\game_sa\CTaskSimpleJetPack.cpp</h3><h3 id="plugin_sagame_sactasksimplejumpcpp">plugin_sa\game_sa\CTaskSimpleJump.cpp</h3><h3 id="plugin_sagame_sactasksimpleplayeronfootcpp">plugin_sa\game_sa\CTaskSimplePlayerOnFoot.cpp</h3><h3 id="plugin_sagame_sactasksimplerunanimcpp">plugin_sa\game_sa\CTaskSimpleRunAnim.cpp</h3><h3 id="plugin_sagame_sactasksimplerunnamedanimcpp">plugin_sa\game_sa\CTaskSimpleRunNamedAnim.cpp</h3><h3 id="plugin_sagame_sactasksimplestandstillcpp">plugin_sa\game_sa\CTaskSimpleStandStill.cpp</h3><h3 id="plugin_sagame_sactasksimplestealthkillcpp">plugin_sa\game_sa\CTaskSimpleStealthKill.cpp</h3><h3 id="plugin_sagame_sactasksimpleswimcpp">plugin_sa\game_sa\CTaskSimpleSwim.cpp</h3><h3 id="plugin_sagame_sactasksimplethrowprojectilecpp">plugin_sa\game_sa\CTaskSimpleThrowProjectile.cpp</h3><h3 id="plugin_sagame_sactasksimpletriggerlookatcpp">plugin_sa\game_sa\CTaskSimpleTriggerLookAt.cpp</h3><h3 id="plugin_sagame_sactasksimpleuseguncpp">plugin_sa\game_sa\CTaskSimpleUseGun.cpp</h3><h3 id="plugin_sagame_sactaskutilitylineuppedwithcarcpp">plugin_sa\game_sa\CTaskUtilityLineUpPedWithCar.cpp</h3><h4>CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor</h4>
<p>plugin::CallMethodAndReturn<CVector*, 0x64FC10, CTaskUtilityLineUpPedWithCar *, int, CVehicle<em>, float, CAnimBlendAssociation</em>>(this, unused, pVehicle, arg3, pAnimBlendAssoc);</p>
<p>0AA8: call_method_return 0x64FC10 struct [CTaskUtilityLineUpPedWithCar] num_params 4 pop 0 [unused] [pVehicle] [arg3] [pAnimBlendAssoc] func_ret [CVector*]</p>
<p>define function CTaskUtilityLineUpPedWithCar__GetLocalPositionToOpenCarDoor&lt;thiscall, 0x64FC10&gt;(unused, pVehicle, arg3, pAnimBlendAssoc): int</p>
<h4>CTaskUtilityLineUpPedWithCar::ProcessPed</h4>
<p>plugin::CallMethod<0x6513A0, CTaskUtilityLineUpPedWithCar <em>, CPed</em>, CVehicle<em>, CAnimBlendAssociation</em>>(this, pPed, pVehicle, pAnimBlendAssoc);</p>
<p>0AA6: call_method 0x6513A0 struct [CTaskUtilityLineUpPedWithCar] num_params 3 pop 0 [pPed] [pVehicle] [pAnimBlendAssoc]</p>
<p>define function CTaskUtilityLineUpPedWithCar__ProcessPed&lt;thiscall, 0x6513A0&gt;(pPed, pVehicle, pAnimBlendAssoc)</p>
<h4>CTaskUtilityLineUpPedWithCar::GetPositionToOpenCarDoor</h4>
<p>plugin::CallMethodAndReturn<RwV3d*, 0x650A80, CTaskUtilityLineUpPedWithCar *, int, CVehicle<em>, float, CAnimBlendAssociation</em>>(this, unused, pVehicle, arg2, pAnimBlendAssoc);</p>
<p>0AA8: call_method_return 0x650A80 struct [CTaskUtilityLineUpPedWithCar] num_params 4 pop 0 [unused] [pVehicle] [arg2] [pAnimBlendAssoc] func_ret [RwV3d*]</p>
<p>define function CTaskUtilityLineUpPedWithCar__GetPositionToOpenCarDoor&lt;thiscall, 0x650A80&gt;(unused, pVehicle, arg2, pAnimBlendAssoc): int</p><h3 id="plugin_sagame_sacthecargeneratorscpp">plugin_sa\game_sa\CTheCarGenerators.cpp</h3><h4>CTheCarGenerators::CreateCarGenerator</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short, unsigned char, unsigned char>(gaddrof(CTheCarGenerators::CreateCarGenerator), x, y, z, angle, modelId, color1, color2, forceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer);</p>
<p>0AA7: call_function_return 0x6F31A0 num_params 14 pop 14 [x] [y] [z] [angle] [modelId] [color1] [color2] [forceSpawn] [alarm_chances] [doorLock_chances] [minDelay] [maxDelay] [iplId] [bOwnedbyplayer] func_ret [signed int]</p>
<p>define function CTheCarGenerators__CreateCarGenerator&lt;cdecl, 0x6F31A0&gt;(x, y, z, angle, modelId, color1, color2, forceSpawn, alarm_chances, doorLock_chances, minDelay, maxDelay, iplId, bOwnedbyplayer): int</p>
<h4>CTheCarGenerators::RemoveCarGenerators</h4>
<p>plugin::CallDynGlobal<unsigned char>(gaddrof(CTheCarGenerators::RemoveCarGenerators), IplID);</p><h3 id="plugin_sagame_sacthescriptscpp">plugin_sa\game_sa\CTheScripts.cpp</h3><h4>CTheScripts::AddScriptCheckpoint</h4>
<p>plugin::CallAndReturnDynGlobal<int, float, float, float, float, float, float, float, int>(gaddrof(CTheScripts::AddScriptCheckpoint), at_X, at_Y, at_Z, PointTo_X, PointTo_Y, PointTo_Z, radius, type);</p>
<p>0AA7: call_function_return 0x4935A0 num_params 8 pop 8 [at_X] [at_Y] [at_Z] [PointTo_X] [PointTo_Y] [PointTo_Z] [radius] [type] func_ret [int]</p>
<p>define function CTheScripts__AddScriptCheckpoint&lt;cdecl, 0x4935A0&gt;(at_X, at_Y, at_Z, PointTo_X, PointTo_Y, PointTo_Z, radius, type): int</p>
<h4>CTheScripts::AddScriptEffectSystem</h4>
<p>plugin::CallAndReturnDynGlobal<int, FxSystem_c *>(gaddrof(CTheScripts::AddScriptEffectSystem), a1);</p>
<p>0AA7: call_function_return 0x492F90 num_params 1 pop 1 [a1] func_ret [int]</p>
<p>define function CTheScripts__AddScriptEffectSystem&lt;cdecl, 0x492F90&gt;(a1): int</p>
<h4>CTheScripts::AddScriptSearchLight</h4>
<p>plugin::CallAndReturnDynGlobal<int, float, float, float, CEntity *, float, float, float, float, float>(gaddrof(CTheScripts::AddScriptSearchLight), startX, startY, startZ, entity, targetX, targetY, targetZ, targetRadius, baseRadius);</p>
<p>0AA7: call_function_return 0x493000 num_params 9 pop 9 [startX] [startY] [startZ] [entity] [targetX] [targetY] [targetZ] [targetRadius] [baseRadius] func_ret [int]</p>
<p>define function CTheScripts__AddScriptSearchLight&lt;cdecl, 0x493000&gt;(startX, startY, startZ, entity, targetX, targetY, targetZ, targetRadius, baseRadius): int</p>
<h4>CTheScripts::AddScriptSphere</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, CVector, float>(gaddrof(CTheScripts::AddScriptSphere), id, posn, radius);</p>
<p>0AA7: call_function_return 0x483B30 num_params 3 pop 3 [id] [posn] [radius] func_ret [unsigned int]</p>
<p>define function CTheScripts__AddScriptSphere&lt;cdecl, 0x483B30&gt;(id, posn, radius): int</p>
<h4>CTheScripts::AddToBuildingSwapArray</h4>
<p>plugin::CallDynGlobal<CBuilding *, int, int>(gaddrof(CTheScripts::AddToBuildingSwapArray), a1, newModelId, oldModelId);</p>
<h4>CTheScripts::AddToInvisibilitySwapArray</h4>
<p>plugin::CallDynGlobal<CEntity *, bool>(gaddrof(CTheScripts::AddToInvisibilitySwapArray), a2, bVisible);</p>
<h4>CTheScripts::AddToListOfConnectedLodObjects</h4>
<p>plugin::CallDynGlobal<CObject *, CObject *>(gaddrof(CTheScripts::AddToListOfConnectedLodObjects), pObject1, pObject2);</p>
<h4>CTheScripts::AddToListOfSpecialAnimGroupsAttachedToCharModels</h4>
<p>plugin::CallDynGlobal<int, char *>(gaddrof(CTheScripts::AddToListOfSpecialAnimGroupsAttachedToCharModels), modelid, ifpName);</p>
<h4>CTheScripts::AddToSwitchJumpTable</h4>
<p>plugin::CallAndReturnDynGlobal<double, int, int>(gaddrof(CTheScripts::AddToSwitchJumpTable), switchValue, switchLabelLocalAddress);</p>
<p>0AA7: call_function_return 0x470390 num_params 2 pop 2 [switchValue] [switchLabelLocalAddress] func_ret [double]</p>
<p>define function CTheScripts__AddToSwitchJumpTable&lt;cdecl, 0x470390&gt;(switchValue, switchLabelLocalAddress): int</p>
<h4>CTheScripts::AddToVehicleModelsBlockedByScript</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CTheScripts::AddToVehicleModelsBlockedByScript), modelindex);</p>
<h4>CTheScripts::AddToWaitingForScriptBrainArray</h4>
<p>plugin::CallDynGlobal<CEntity *, short>(gaddrof(CTheScripts::AddToWaitingForScriptBrainArray), pEntity, arg2);</p>
<h4>CTheScripts::AttachSearchlightToSearchlightObject</h4>
<p>plugin::CallDynGlobal<int, CObject *, CObject *, CObject *, float, float, float>(gaddrof(CTheScripts::AttachSearchlightToSearchlightObject), searchlightid, tower, housing, bulb, offsetX, offsetY, offsetZ);</p>
<h4>CTheScripts::CheckStreamedScriptVersion</h4>
<p>plugin::CallAndReturnDynGlobal<char, RwStream *, char *>(gaddrof(CTheScripts::CheckStreamedScriptVersion), arg1, arg2);</p>
<p>0AA7: call_function_return 0x464FF0 num_params 2 pop 2 [arg1] [arg2] func_ret [char]</p>
<p>define function CTheScripts__CheckStreamedScriptVersion&lt;cdecl, 0x464FF0&gt;(arg1, arg2): int</p>
<h4>CTheScripts::CleanUpThisObject</h4>
<p>plugin::CallDynGlobal<CObject *>(gaddrof(CTheScripts::CleanUpThisObject), pObject);</p>
<h4>CTheScripts::CleanUpThisPed</h4>
<p>plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::CleanUpThisPed), ped);</p>
<h4>CTheScripts::CleanUpThisVehicle</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CTheScripts::CleanUpThisVehicle), pVehicle);</p>
<h4>CTheScripts::ClearSpaceForMissionEntity</h4>
<p>plugin::CallDynGlobal<CVector const &, CEntity *>(gaddrof(CTheScripts::ClearSpaceForMissionEntity), pos, pEntity);</p>
<h4>CTheScripts::DrawDebugAngledSquare</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, float, float, float>(gaddrof(CTheScripts::DrawDebugAngledSquare), x1, y1, x2, y2, x3, y3, x4, y4);</p>
<h4>CTheScripts::DrawDebugCube</h4>
<p>plugin::CallDynGlobal<float, float, float, float>(gaddrof(CTheScripts::DrawDebugCube), x1, y1, x2, y2);</p>
<h4>CTheScripts::DrawScriptSpritesAndRectangles</h4>
<p>plugin::CallDynGlobal<char>(gaddrof(CTheScripts::DrawScriptSpritesAndRectangles), bDrawBeforeFade);</p>
<h4>CTheScripts::GetActualScriptThingIndex</h4>
<p>plugin::CallAndReturnDynGlobal<signed int, int, unsigned char>(gaddrof(CTheScripts::GetActualScriptThingIndex), index, type);</p>
<p>0AA7: call_function_return 0x4839A0 num_params 2 pop 2 [index] [type] func_ret [signed int]</p>
<p>define function CTheScripts__GetActualScriptThingIndex&lt;cdecl, 0x4839A0&gt;(index, type): int</p>
<h4>CTheScripts::GetNewUniqueScriptThingIndex</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, unsigned int, char>(gaddrof(CTheScripts::GetNewUniqueScriptThingIndex), index, type);</p>
<p>0AA7: call_function_return 0x483720 num_params 2 pop 2 [index] [type] func_ret [unsigned int]</p>
<p>define function CTheScripts__GetNewUniqueScriptThingIndex&lt;cdecl, 0x483720&gt;(index, type): int</p>
<h4>CTheScripts::GetScriptIndexFromPointer</h4>
<p>plugin::CallAndReturnDynGlobal<int, CRunningScript *>(gaddrof(CTheScripts::GetScriptIndexFromPointer), thread);</p>
<p>0AA7: call_function_return 0x464D20 num_params 1 pop 1 [thread] func_ret [int]</p>
<p>define function CTheScripts__GetScriptIndexFromPointer&lt;cdecl, 0x464D20&gt;(thread): int</p>
<h4>CTheScripts::GetUniqueScriptThingIndex</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, int, unsigned char>(gaddrof(CTheScripts::GetUniqueScriptThingIndex), playergroup, type);</p>
<p>0AA7: call_function_return 0x4810C0 num_params 2 pop 2 [playergroup] [type] func_ret [unsigned int]</p>
<p>define function CTheScripts__GetUniqueScriptThingIndex&lt;cdecl, 0x4810C0&gt;(playergroup, type): int</p>
<h4>CTheScripts::HasVehicleModelBeenBlockedByScript</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CTheScripts::HasVehicleModelBeenBlockedByScript), modelindex);</p>
<p>0AA7: call_function_return 0x46A890 num_params 1 pop 1 [modelindex] func_ret [bool]</p>
<p>define function CTheScripts__HasVehicleModelBeenBlockedByScript&lt;cdecl, 0x46A890&gt;(modelindex): int</p>
<h4>CTheScripts::HighlightImportantAngledArea</h4>
<p>plugin::CallDynGlobal<unsigned int, float, float, float, float, float, float, float, float, float>(gaddrof(CTheScripts::HighlightImportantAngledArea), markerid, from_X, from_Y, to_X, to_Y, angledTo_X, angledTo_Y, angledFrom_X, angledFrom_Y, height);</p>
<h4>CTheScripts::HighlightImportantArea</h4>
<p>plugin::CallDynGlobal<int, float, float, float, float, float>(gaddrof(CTheScripts::HighlightImportantArea), markerid, from_X, from_Y, to_X, to_Y, height);</p>
<h4>CTheScripts::InitialiseConnectLodObjects</h4>
<p>plugin::CallDynGlobal<unsigned short>(gaddrof(CTheScripts::InitialiseConnectLodObjects), a1);</p>
<h4>CTheScripts::InitialiseSpecialAnimGroup</h4>
<p>plugin::CallDynGlobal<unsigned short>(gaddrof(CTheScripts::InitialiseSpecialAnimGroup), a1);</p>
<h4>CTheScripts::IsEntityWithinAnySearchLight</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CEntity *, int *>(gaddrof(CTheScripts::IsEntityWithinAnySearchLight), pEntity, pIndex);</p>
<p>0AA7: call_function_return 0x493960 num_params 2 pop 2 [pEntity] [pIndex] func_ret [bool]</p>
<p>define function CTheScripts__IsEntityWithinAnySearchLight&lt;cdecl, 0x493960&gt;(pEntity, pIndex): int</p>
<h4>CTheScripts::IsEntityWithinSearchLight</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned int, CEntity *>(gaddrof(CTheScripts::IsEntityWithinSearchLight), index, pEntity);</p>
<p>0AA7: call_function_return 0x493900 num_params 2 pop 2 [index] [pEntity] func_ret [bool]</p>
<p>define function CTheScripts__IsEntityWithinSearchLight&lt;cdecl, 0x493900&gt;(index, pEntity): int</p>
<h4>CTheScripts::IsPedStopped</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *>(gaddrof(CTheScripts::IsPedStopped), ped);</p>
<p>0AA7: call_function_return 0x486110 num_params 1 pop 1 [ped] func_ret [bool]</p>
<p>define function CTheScripts__IsPedStopped&lt;cdecl, 0x486110&gt;(ped): int</p>
<h4>CTheScripts::IsPlayerOnAMission</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTheScripts::IsPlayerOnAMission));</p>
<p>0AA7: call_function_return 0x464D50 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CTheScripts__IsPlayerOnAMission&lt;cdecl, 0x464D50&gt;(): int</p>
<h4>CTheScripts::IsPointWithinSearchLight</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector *, int>(gaddrof(CTheScripts::IsPointWithinSearchLight), pointPosn, index);</p>
<p>0AA7: call_function_return 0x493280 num_params 2 pop 2 [pointPosn] [index] func_ret [bool]</p>
<p>define function CTheScripts__IsPointWithinSearchLight&lt;cdecl, 0x493280&gt;(pointPosn, index): int</p>
<h4>CTheScripts::IsVehicleStopped</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTheScripts::IsVehicleStopped), pVehicle);</p>
<p>0AA7: call_function_return 0x4861F0 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CTheScripts__IsVehicleStopped&lt;cdecl, 0x4861F0&gt;(pVehicle): int</p>
<h4>CTheScripts::MoveSearchLightBetweenTwoPoints</h4>
<p>plugin::CallDynGlobal<int, float, float, float, float, float, float, float>(gaddrof(CTheScripts::MoveSearchLightBetweenTwoPoints), index, x1, y1, z1, x2, y2, z2, pathSpeed);</p>
<h4>CTheScripts::MoveSearchLightToEntity</h4>
<p>plugin::CallDynGlobal<int, CEntity *, float>(gaddrof(CTheScripts::MoveSearchLightToEntity), index, pEntity, pathSpeed);</p>
<h4>CTheScripts::MoveSearchLightToPointAndStop</h4>
<p>plugin::CallDynGlobal<int, float, float, float, float>(gaddrof(CTheScripts::MoveSearchLightToPointAndStop), index, x, y, z, pathSpeed);</p>
<h4>CTheScripts::RemoveFromVehicleModelsBlockedByScript</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveFromVehicleModelsBlockedByScript), modelindex);</p>
<h4>CTheScripts::RemoveFromWaitingForScriptBrainArray</h4>
<p>plugin::CallAndReturnDynGlobal<int, CEntity *, short>(gaddrof(CTheScripts::RemoveFromWaitingForScriptBrainArray), a1, modelIndex);</p>
<p>0AA7: call_function_return 0x46ABC0 num_params 2 pop 2 [a1] [modelIndex] func_ret [int]</p>
<p>define function CTheScripts__RemoveFromWaitingForScriptBrainArray&lt;cdecl, 0x46ABC0&gt;(a1, modelIndex): int</p>
<h4>CTheScripts::RemoveScriptCheckpoint</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptCheckpoint), arg1);</p>
<h4>CTheScripts::RemoveScriptEffectSystem</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptEffectSystem), arg1);</p>
<h4>CTheScripts::RemoveScriptSearchLight</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CTheScripts::RemoveScriptSearchLight), index);</p>
<h4>CTheScripts::RemoveScriptSphere</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CTheScripts::RemoveScriptSphere), index);</p>
<h4>CTheScripts::RemoveThisPed</h4>
<p>plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::RemoveThisPed), ped);</p>
<h4>CTheScripts::ScriptAttachAnimGroupToCharModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int, char *>(gaddrof(CTheScripts::ScriptAttachAnimGroupToCharModel), modelId, ifpName);</p>
<p>0AA7: call_function_return 0x474800 num_params 2 pop 2 [modelId] [ifpName] func_ret [bool]</p>
<p>define function CTheScripts__ScriptAttachAnimGroupToCharModel&lt;cdecl, 0x474800&gt;(modelId, ifpName): int</p>
<h4>CTheScripts::ScriptConnectLodsFunction</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CTheScripts::ScriptConnectLodsFunction), objecthandle1, objecthandle2);</p>
<h4>CTheScripts::ScriptDebugCircle2D</h4>
<p>plugin::CallDynGlobal<float, float, float, float, CRGBA>(gaddrof(CTheScripts::ScriptDebugCircle2D), x, y, width, height, color);</p>
<h4>*CTheScripts::StartNewScript</h4>
<p>plugin::CallAndReturnDynGlobal<CRunningScript *, unsigned char *>(gaddrof_o(CTheScripts::StartNewScript, CRunningScript <em>(</em>)(unsigned char *)), startIP);</p>
<p>0AA7: call_function_return 0x464C90 num_params 1 pop 1 [startIP] func_ret [CRunningScript *]</p>
<p>define function CTheScripts__StartNewScript&lt;cdecl, 0x464C90&gt;(startIP): int</p>
<h4>CTheScripts::StartNewScript</h4>
<p>plugin::CallAndReturnDynGlobal&lt;int, unsigned char <em>, unsigned short>(gaddrof_o(CTheScripts::StartNewScript, int(</em>)(unsigned char *, unsigned short)), startIP, index);</p>
<p>0AA7: call_function_return 0x464C90 num_params 2 pop 2 [startIP] [index] func_ret [int]</p>
<p>define function CTheScripts__StartNewScript&lt;cdecl, 0x464C90&gt;(startIP, index): int</p>
<h4>CTheScripts::UseSwitchJumpTable</h4>
<p>plugin::CallDynGlobal<int *>(gaddrof(CTheScripts::UseSwitchJumpTable), pSwitchLabelAddress);</p><h3 id="plugin_sagame_sactimecyclecpp">plugin_sa\game_sa\CTimeCycle.cpp</h3><h4>CTimeCycle::AddOne</h4>
<p>plugin::Call<0x55FF40, CBox&, short, int, float, float, float>(box, farclip, extracolor, strength, falloff, lodDistMult);</p>
<p>0AA5: call_function 0x55FF40 num_params 6 pop 6 [box] [farclip] [extracolor] [strength] [falloff] [lodDistMult]</p>
<p>define function CTimeCycle__AddOne&lt;cdecl, 0x55FF40&gt;(box, farclip, extracolor, strength, falloff, lodDistMult)</p>
<h4>CTimeCycle::CalcColoursForPoint</h4>
<p>plugin::Call<0x5603D0, CVector, CColourSet*>(point, pCurrentColourSet);</p>
<p>0AA5: call_function 0x5603D0 num_params 2 pop 2 [point] [pCurrentColourSet]</p>
<p>define function CTimeCycle__CalcColoursForPoint&lt;cdecl, 0x5603D0&gt;(point, pCurrentColourSet)</p>
<h4>CTimeCycle::FindFarClipForCoors</h4>
<p>plugin::Call<0x5616E0, CVector>(cam_pos);</p>
<p>0AA5: call_function 0x5616E0 num_params 1 pop 1 [cam_pos]</p>
<p>define function CTimeCycle__FindFarClipForCoors&lt;cdecl, 0x5616E0&gt;(cam_pos)</p>
<h4>CTimeCycle::FindTimeCycleBox</h4>
<p>plugin::Call<0x55FFD0, CVector, CTimeCycleBox*<em>, float</em>, bool, bool, CTimeCycleBox*>(pos, outbox, interpolation, bCheckLod, bCheckFar, exclude);</p>
<p>0AA5: call_function 0x55FFD0 num_params 6 pop 6 [pos] [outbox] [interpolation] [bCheckLod] [bCheckFar] [exclude]</p>
<p>define function CTimeCycle__FindTimeCycleBox&lt;cdecl, 0x55FFD0&gt;(pos, outbox, interpolation, bCheckLod, bCheckFar, exclude)</p>
<h4>CTimeCycle::GetAmbientBlue</h4>
<p>plugin::CallAndReturn<float, 0x560350>();</p>
<p>0AA7: call_function_return 0x560350 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientBlue&lt;cdecl, 0x560350&gt;(): float</p>
<h4>CTimeCycle::GetAmbientBlue_BeforeBrightness</h4>
<p>plugin::CallAndReturn<float, 0x5603B0>();</p>
<p>0AA7: call_function_return 0x5603B0 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientBlue_BeforeBrightness&lt;cdecl, 0x5603B0&gt;(): float</p>
<h4>CTimeCycle::GetAmbientBlue_Obj</h4>
<p>plugin::CallAndReturn<float, 0x560380>();</p>
<p>0AA7: call_function_return 0x560380 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientBlue_Obj&lt;cdecl, 0x560380&gt;(): float</p>
<h4>CTimeCycle::GetAmbientGreen</h4>
<p>plugin::CallAndReturn<float, 0x560340>();</p>
<p>0AA7: call_function_return 0x560340 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientGreen&lt;cdecl, 0x560340&gt;(): float</p>
<h4>CTimeCycle::GetAmbientGreen_BeforeBrightness</h4>
<p>plugin::CallAndReturn<float, 0x5603A0>();</p>
<p>0AA7: call_function_return 0x5603A0 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientGreen_BeforeBrightness&lt;cdecl, 0x5603A0&gt;(): float</p>
<h4>CTimeCycle::GetAmbientGreen_Obj</h4>
<p>plugin::CallAndReturn<float, 0x560370>();</p>
<p>0AA7: call_function_return 0x560370 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientGreen_Obj&lt;cdecl, 0x560370&gt;(): float</p>
<h4>CTimeCycle::GetAmbientRed</h4>
<p>plugin::CallAndReturn<float, 0x560330>();</p>
<p>0AA7: call_function_return 0x560330 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientRed&lt;cdecl, 0x560330&gt;(): float</p>
<h4>CTimeCycle::GetAmbientRed_BeforeBrightness</h4>
<p>plugin::CallAndReturn<float, 0x560390>();</p>
<p>0AA7: call_function_return 0x560390 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientRed_BeforeBrightness&lt;cdecl, 0x560390&gt;(): float</p>
<h4>CTimeCycle::GetAmbientRed_Obj</h4>
<p>plugin::CallAndReturn<float, 0x560360>();</p>
<p>0AA7: call_function_return 0x560360 num_params 0 pop 0 func_ret [float]</p>
<p>define function CTimeCycle__GetAmbientRed_Obj&lt;cdecl, 0x560360&gt;(): float</p>
<h4>CTimeCycle::InitForRestart</h4>
<p>plugin::Call<0x5601F0>();</p>
<p>0AA5: call_function 0x5601F0 num_params 0 pop 0</p>
<p>define function CTimeCycle__InitForRestart&lt;cdecl, 0x5601F0&gt;()</p>
<h4>CTimeCycle::Initialise</h4>
<p>plugin::Call<0x5BBAC0>();</p>
<p>0AA5: call_function 0x5BBAC0 num_params 0 pop 0</p>
<p>define function CTimeCycle__Initialise&lt;cdecl, 0x5BBAC0&gt;()</p>
<h4>CTimeCycle::SetConstantParametersForPostFX</h4>
<p>plugin::Call<0x560210>();</p>
<p>0AA5: call_function 0x560210 num_params 0 pop 0</p>
<p>define function CTimeCycle__SetConstantParametersForPostFX&lt;cdecl, 0x560210&gt;()</p>
<h4>CTimeCycle::Shutdown</h4>
<p>plugin::Call<0x5601E0>();</p>
<p>0AA5: call_function 0x5601E0 num_params 0 pop 0</p>
<p>define function CTimeCycle__Shutdown&lt;cdecl, 0x5601E0&gt;()</p>
<h4>CTimeCycle::StartExtraColour</h4>
<p>plugin::Call<0x55FEC0, int, bool>(colour, bNoExtraColorInterior);</p>
<p>0AA5: call_function 0x55FEC0 num_params 2 pop 2 [colour] [bNoExtraColorInterior]</p>
<p>define function CTimeCycle__StartExtraColour&lt;cdecl, 0x55FEC0&gt;(colour, bNoExtraColorInterior)</p>
<h4>CTimeCycle::StopExtraColour</h4>
<p>plugin::Call<0x55FF20, bool>(bNoExtraColorInterior);</p>
<p>0AA5: call_function 0x55FF20 num_params 1 pop 1 [bNoExtraColorInterior]</p>
<p>define function CTimeCycle__StopExtraColour&lt;cdecl, 0x55FF20&gt;(bNoExtraColorInterior)</p>
<h4>CTimeCycle::Update</h4>
<p>plugin::Call<0x561760>();</p>
<p>0AA5: call_function 0x561760 num_params 0 pop 0</p>
<p>define function CTimeCycle__Update&lt;cdecl, 0x561760&gt;()</p><h3 id="plugin_sagame_sacupsidedowncarcheckcpp">plugin_sa\game_sa\CUpsideDownCarCheck.cpp</h3><h4>CUpsideDownCarCheck::AddCarToCheck</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::AddCarToCheck), this, carHandle);</p>
<p>0AA6: call_method 0x4638D0 struct [CUpsideDownCarCheck] num_params 1 pop 0 [carHandle]</p>
<p>define function CUpsideDownCarCheck__AddCarToCheck&lt;thiscall, 0x4638D0&gt;(carHandle)</p>
<h4>CUpsideDownCarCheck::AreAnyCarsUpsideDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::AreAnyCarsUpsideDown), this);</p>
<p>0AA8: call_method_return 0x4638A0 struct [CUpsideDownCarCheck] num_params 0 pop 0 func_ret [bool]</p>
<h4>CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::HasCarBeenUpsideDownForAWhile), this, carHandle);</p>
<p>0AA8: call_method_return 0x463940 struct [CUpsideDownCarCheck] num_params 1 pop 0 [carHandle] func_ret [char]</p>
<h4>CUpsideDownCarCheck::Init</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::Init), this);</p>
<p>0AA6: call_method 0x463810 struct [CUpsideDownCarCheck] num_params 0 pop 0</p>
<p>define function CUpsideDownCarCheck__Init&lt;thiscall, 0x463810&gt;()</p>
<h4>CUpsideDownCarCheck::RemoveCarFromCheck</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *, int>(gaddrof(CUpsideDownCarCheck::RemoveCarFromCheck), this, carHandle);</p>
<p>0AA6: call_method 0x463910 struct [CUpsideDownCarCheck] num_params 1 pop 0 [carHandle]</p>
<p>define function CUpsideDownCarCheck__RemoveCarFromCheck&lt;thiscall, 0x463910&gt;(carHandle)</p>
<h4>CUpsideDownCarCheck::UpdateTimers</h4>
<p>plugin::CallMethodDynGlobal<CUpsideDownCarCheck *>(gaddrof(CUpsideDownCarCheck::UpdateTimers), this);</p>
<p>0AA6: call_method 0x4655E0 struct [CUpsideDownCarCheck] num_params 0 pop 0</p>
<p>define function CUpsideDownCarCheck__UpdateTimers&lt;thiscall, 0x4655E0&gt;()</p>
<h4>CUpsideDownCarCheck::IsCarUpsideDown</h4>
<p>plugin::CallAndReturnDynGlobal&lt;bool, CVehicle <em>>(gaddrof_o(CUpsideDownCarCheck::IsCarUpsideDown, bool (</em>)(CVehicle *)), pVehicle);</p>
<p>0AA7: call_function_return 0x4655A0 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CUpsideDownCarCheck__IsCarUpsideDown&lt;cdecl, 0x4655A0&gt;(pVehicle): int</p>
<h4>CUpsideDownCarCheck::IsCarUpsideDown</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof_o(CUpsideDownCarCheck::IsCarUpsideDown, bool (*)(int)), carhandle);</p>
<p>0AA7: call_function_return 0x4655A0 num_params 1 pop 1 [carhandle] func_ret [bool]</p>
<p>define function CUpsideDownCarCheck__IsCarUpsideDown&lt;cdecl, 0x4655A0&gt;(carhandle): int</p><h3 id="plugin_sagame_sacvisibilitypluginscpp">plugin_sa\game_sa\CVisibilityPlugins.cpp</h3><h4>CVisibilityPlugins::AtomicConstructor</h4>
<p>plugin::Call<0x732150, void*>(object);</p>
<p>0AA5: call_function 0x732150 num_params 1 pop 1 [object]</p>
<p>define function CVisibilityPlugins__AtomicConstructor&lt;cdecl, 0x732150&gt;(object)</p>
<h4>CVisibilityPlugins::AtomicCopyConstructor</h4>
<p>plugin::Call<0x732170, void<em>, void const</em>>(object, originalObject);</p>
<p>0AA5: call_function 0x732170 num_params 2 pop 2 [object] [originalObject]</p>
<p>define function CVisibilityPlugins__AtomicCopyConstructor&lt;cdecl, 0x732170&gt;(object, originalObject)</p>
<h4>CVisibilityPlugins::AtomicDestructor</h4>
<p>plugin::CallAndReturn<void<em>, 0x7321A0, void</em>>(object);</p>
<p>0AA7: call_function_return 0x7321A0 num_params 1 pop 1 [object] func_ret [void*]</p>
<p>define function CVisibilityPlugins__AtomicDestructor&lt;cdecl, 0x7321A0&gt;(object): int</p>
<h4>CVisibilityPlugins::CalculateFadingAtomicAlpha</h4>
<p>plugin::CallAndReturn<int, 0x732500, CBaseModelInfo<em>, CEntity</em>, float>(pBaseModelInfo, pEntity, arg3);</p>
<p>0AA7: call_function_return 0x732500 num_params 3 pop 3 [pBaseModelInfo] [pEntity] [arg3] func_ret [int]</p>
<p>define function CVisibilityPlugins__CalculateFadingAtomicAlpha&lt;cdecl, 0x732500&gt;(pBaseModelInfo, pEntity, arg3): int</p>
<h4>CVisibilityPlugins::ClearAtomicFlag</h4>
<p>plugin::Call<0x732310, RpAtomic*, int>(pRpAtomic, flag);</p>
<p>0AA5: call_function 0x732310 num_params 2 pop 2 [pRpAtomic] [flag]</p>
<p>define function CVisibilityPlugins__ClearAtomicFlag&lt;cdecl, 0x732310&gt;(pRpAtomic, flag)</p>
<h4>CVisibilityPlugins::ClearAtomicFlag</h4>
<p>plugin::Call<0x732330, RpAtomic*, unsigned short>(pRpAtomic, flag);</p>
<p>0AA5: call_function 0x732330 num_params 2 pop 2 [pRpAtomic] [flag]</p>
<p>define function CVisibilityPlugins__ClearAtomicFlag&lt;cdecl, 0x732330&gt;(pRpAtomic, flag)</p>
<h4>CVisibilityPlugins::ClearClumpForAllAtomicsFlag</h4>
<p>plugin::Call<0x732350, RpClump*, int>(pRpClump, flag);</p>
<p>0AA5: call_function 0x732350 num_params 2 pop 2 [pRpClump] [flag]</p>
<p>define function CVisibilityPlugins__ClearClumpForAllAtomicsFlag&lt;cdecl, 0x732350&gt;(pRpClump, flag)</p>
<h4>CVisibilityPlugins::ClumpConstructor</h4>
<p>plugin::Call<0x732E10, void*>(object);</p>
<p>0AA5: call_function 0x732E10 num_params 1 pop 1 [object]</p>
<p>define function CVisibilityPlugins__ClumpConstructor&lt;cdecl, 0x732E10&gt;(object)</p>
<h4>CVisibilityPlugins::ClumpCopyConstructor</h4>
<p>plugin::Call<0x732200, void<em>, void const</em>>(object, originalObject);</p>
<p>0AA5: call_function 0x732200 num_params 2 pop 2 [object] [originalObject]</p>
<p>define function CVisibilityPlugins__ClumpCopyConstructor&lt;cdecl, 0x732200&gt;(object, originalObject)</p>
<h4>CVisibilityPlugins::ClumpDestructor</h4>
<p>plugin::CallAndReturn<void<em>, 0x732220, void</em>>(object);</p>
<p>0AA7: call_function_return 0x732220 num_params 1 pop 1 [object] func_ret [void*]</p>
<p>define function CVisibilityPlugins__ClumpDestructor&lt;cdecl, 0x732220&gt;(object): int</p>
<h4>CVisibilityPlugins::DefaultVisibilityCB</h4>
<p>plugin::CallAndReturn<int, 0x732A30>();</p>
<p>0AA7: call_function_return 0x732A30 num_params 0 pop 0 func_ret [int]</p>
<p>define function CVisibilityPlugins__DefaultVisibilityCB&lt;cdecl, 0x732A30&gt;(): int</p>
<h4>CVisibilityPlugins::FrameConstructor</h4>
<p>plugin::Call<0x7321B0, void*>(object);</p>
<p>0AA5: call_function 0x7321B0 num_params 1 pop 1 [object]</p>
<p>define function CVisibilityPlugins__FrameConstructor&lt;cdecl, 0x7321B0&gt;(object)</p>
<h4>CVisibilityPlugins::FrameCopyConstructor</h4>
<p>plugin::Call<0x7321D0, void<em>, void const</em>>(object, originalObject);</p>
<p>0AA5: call_function 0x7321D0 num_params 2 pop 2 [object] [originalObject]</p>
<p>define function CVisibilityPlugins__FrameCopyConstructor&lt;cdecl, 0x7321D0&gt;(object, originalObject)</p>
<h4>CVisibilityPlugins::FrameDestructor</h4>
<p>plugin::CallAndReturn<void<em>, 0x7321F0, void</em>, int, int>(arg0, arg1, arg2);</p>
<p>0AA7: call_function_return 0x7321F0 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [void*]</p>
<p>define function CVisibilityPlugins__FrameDestructor&lt;cdecl, 0x7321F0&gt;(arg0, arg1, arg2): int</p>
<h4>CVisibilityPlugins::FrustumSphereCB</h4>
<p>plugin::CallAndReturn<bool, 0x732A40, RpClump*>(pRpClump);</p>
<p>0AA7: call_function_return 0x732A40 num_params 1 pop 1 [pRpClump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__FrustumSphereCB&lt;cdecl, 0x732A40&gt;(pRpClump): int</p>
<h4>CVisibilityPlugins::GetAtomicId</h4>
<p>plugin::CallAndReturn<short, 0x732370, RpAtomic*>(pRpAtomic);</p>
<p>0AA7: call_function_return 0x732370 num_params 1 pop 1 [pRpAtomic] func_ret [short]</p>
<p>define function CVisibilityPlugins__GetAtomicId&lt;cdecl, 0x732370&gt;(pRpAtomic): int</p>
<h4>CVisibilityPlugins::GetAtomicModelInfo</h4>
<p>plugin::CallAndReturn<CAtomicModelInfo<em>, 0x732260, RpAtomic</em>>(pRpAtomic);</p>
<p>0AA7: call_function_return 0x732260 num_params 1 pop 1 [pRpAtomic] func_ret [CAtomicModelInfo*]</p>
<p>define function CVisibilityPlugins__GetAtomicModelInfo&lt;cdecl, 0x732260&gt;(pRpAtomic): int</p>
<h4>CVisibilityPlugins::GetClumpAlpha</h4>
<p>plugin::CallAndReturn<int, 0x732B20, RpClump*>(pRpClump);</p>
<p>0AA7: call_function_return 0x732B20 num_params 1 pop 1 [pRpClump] func_ret [int]</p>
<p>define function CVisibilityPlugins__GetClumpAlpha&lt;cdecl, 0x732B20&gt;(pRpClump): int</p>
<h4>CVisibilityPlugins::GetClumpModelInfo</h4>
<p>plugin::CallAndReturn<CClumpModelInfo<em>, 0x732AC0, RpClump</em>>(pRpClump);</p>
<p>0AA7: call_function_return 0x732AC0 num_params 1 pop 1 [pRpClump] func_ret [CClumpModelInfo*]</p>
<p>define function CVisibilityPlugins__GetClumpModelInfo&lt;cdecl, 0x732AC0&gt;(pRpClump): int</p>
<h4>CVisibilityPlugins::GetDistanceSquaredFromCamera</h4>
<p>plugin::CallAndReturn<float, 0x732C80, RwFrame*>(pRwFrame);</p>
<p>0AA7: call_function_return 0x732C80 num_params 1 pop 1 [pRwFrame] func_ret [float]</p>
<p>define function CVisibilityPlugins__GetDistanceSquaredFromCamera&lt;cdecl, 0x732C80&gt;(pRwFrame): float</p>
<h4>CVisibilityPlugins::GetDistanceSquaredFromCamera</h4>
<p>plugin::CallAndReturn<float, 0x732CC0, RwV3d*>(pRwV3d);</p>
<p>0AA7: call_function_return 0x732CC0 num_params 1 pop 1 [pRwV3d] func_ret [float]</p>
<p>define function CVisibilityPlugins__GetDistanceSquaredFromCamera&lt;cdecl, 0x732CC0&gt;(pRwV3d): float</p>
<h4>CVisibilityPlugins::GetDotProductWithCameraVector</h4>
<p>plugin::CallAndReturn<float, 0x7326D0, RwMatrixTag<em>, RwMatrixTag</em>, unsigned int>(atomicMat, rootMat, flags);</p>
<p>0AA7: call_function_return 0x7326D0 num_params 3 pop 3 [atomicMat] [rootMat] [flags] func_ret [float]</p>
<p>define function CVisibilityPlugins__GetDotProductWithCameraVector&lt;cdecl, 0x7326D0&gt;(atomicMat, rootMat, flags): float</p>
<h4>CVisibilityPlugins::GetFrameHierarchyId</h4>
<p>plugin::CallAndReturn<int, 0x732A20, RwFrame*>(pRwFrame);</p>
<p>0AA7: call_function_return 0x732A20 num_params 1 pop 1 [pRwFrame] func_ret [int]</p>
<p>define function CVisibilityPlugins__GetFrameHierarchyId&lt;cdecl, 0x732A20&gt;(pRwFrame): int</p>
<h4>CVisibilityPlugins::GetModelInfoIndex</h4>
<p>plugin::CallAndReturn<short, 0x732250, RpAtomic*>(pRpAtomic);</p>
<p>0AA7: call_function_return 0x732250 num_params 1 pop 1 [pRpAtomic] func_ret [short]</p>
<p>define function CVisibilityPlugins__GetModelInfoIndex&lt;cdecl, 0x732250&gt;(pRpAtomic): int</p>
<h4>CVisibilityPlugins::GetUserValue</h4>
<p>plugin::CallAndReturn<short, 0x7323A0, RpAtomic*>(pRpAtomic);</p>
<p>0AA7: call_function_return 0x7323A0 num_params 1 pop 1 [pRpAtomic] func_ret [short]</p>
<p>define function CVisibilityPlugins__GetUserValue&lt;cdecl, 0x7323A0&gt;(pRpAtomic): int</p>
<h4>CVisibilityPlugins::InitAlphaAtomicList</h4>
<p>plugin::Call<0x734530>();</p>
<p>0AA5: call_function 0x734530 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__InitAlphaAtomicList&lt;cdecl, 0x734530&gt;()</p>
<h4>CVisibilityPlugins::InitAlphaEntityList</h4>
<p>plugin::Call<0x734540>();</p>
<p>0AA5: call_function 0x734540 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__InitAlphaEntityList&lt;cdecl, 0x734540&gt;()</p>
<h4>CVisibilityPlugins::Initialise</h4>
<p>plugin::Call<0x733A20>();</p>
<p>0AA5: call_function 0x733A20 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__Initialise&lt;cdecl, 0x733A20&gt;()</p>
<h4>CVisibilityPlugins::InsertAtomicIntoReallyDrawLastList</h4>
<p>plugin::CallAndReturn<bool, 0x733E10, RpAtomic*, float>(pRpAtomic, arg2);</p>
<p>0AA7: call_function_return 0x733E10 num_params 2 pop 2 [pRpAtomic] [arg2] func_ret [bool]</p>
<p>define function CVisibilityPlugins__InsertAtomicIntoReallyDrawLastList&lt;cdecl, 0x733E10&gt;(pRpAtomic, arg2): int</p>
<h4>CVisibilityPlugins::InsertEntityIntoReallyDrawLastList</h4>
<p>plugin::CallAndReturn<bool, 0x733E50, CEntity*, float>(pEntity, arg2);</p>
<p>0AA7: call_function_return 0x733E50 num_params 2 pop 2 [pEntity] [arg2] func_ret [bool]</p>
<p>define function CVisibilityPlugins__InsertEntityIntoReallyDrawLastList&lt;cdecl, 0x733E50&gt;(pEntity, arg2): int</p>
<h4>CVisibilityPlugins::InsertEntityIntoSortedList</h4>
<p>plugin::CallAndReturn<bool, 0x734570, CEntity*, float>(pEntity, distance);</p>
<p>0AA7: call_function_return 0x734570 num_params 2 pop 2 [pEntity] [distance] func_ret [bool]</p>
<p>define function CVisibilityPlugins__InsertEntityIntoSortedList&lt;cdecl, 0x734570&gt;(pEntity, distance): int</p>
<h4>CVisibilityPlugins::IsAtomicVisible</h4>
<p>plugin::CallAndReturn<bool, 0x732990, RpAtomic*>(pRpAtomic);</p>
<p>0AA7: call_function_return 0x732990 num_params 1 pop 1 [pRpAtomic] func_ret [bool]</p>
<p>define function CVisibilityPlugins__IsAtomicVisible&lt;cdecl, 0x732990&gt;(pRpAtomic): int</p>
<h4>CVisibilityPlugins::IsClumpVisible</h4>
<p>plugin::CallAndReturn<bool, 0x732AE0, RpClump*>(pRpClump);</p>
<p>0AA7: call_function_return 0x732AE0 num_params 1 pop 1 [pRpClump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__IsClumpVisible&lt;cdecl, 0x732AE0&gt;(pRpClump): int</p>
<h4>CVisibilityPlugins::PluginAttach</h4>
<p>plugin::CallAndReturn<bool, 0x732E30>();</p>
<p>0AA7: call_function_return 0x732E30 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVisibilityPlugins__PluginAttach&lt;cdecl, 0x732E30&gt;(): int</p>
<h4>CVisibilityPlugins::RenderAlphaAtomic</h4>
<p>plugin::Call<0x732480, RpAtomic*, int>(pRpAtomic, dwAlpha);</p>
<p>0AA5: call_function 0x732480 num_params 2 pop 2 [pRpAtomic] [dwAlpha]</p>
<p>define function CVisibilityPlugins__RenderAlphaAtomic&lt;cdecl, 0x732480&gt;(pRpAtomic, dwAlpha)</p>
<h4>CVisibilityPlugins::RenderAlphaAtomics</h4>
<p>plugin::Call<0x733E90>();</p>
<p>0AA5: call_function 0x733E90 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__RenderAlphaAtomics&lt;cdecl, 0x733E90&gt;()</p>
<h4>CVisibilityPlugins::RenderAtomicWithAlphaCB</h4>
<p>plugin::Call<0x732660, RpAtomic<em>, void</em>>(pRpAtomic, pData);</p>
<p>0AA5: call_function 0x732660 num_params 2 pop 2 [pRpAtomic] [pData]</p>
<p>define function CVisibilityPlugins__RenderAtomicWithAlphaCB&lt;cdecl, 0x732660&gt;(pRpAtomic, pData)</p>
<h4>CVisibilityPlugins::RenderBoatAlphaAtomics</h4>
<p>plugin::Call<0x733EC0>();</p>
<p>0AA5: call_function 0x733EC0 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__RenderBoatAlphaAtomics&lt;cdecl, 0x733EC0&gt;()</p>
<h4>CVisibilityPlugins::RenderEntity</h4>
<p>plugin::Call<0x732B40, void*, bool, float>(entity, unused, arg3);</p>
<p>0AA5: call_function 0x732B40 num_params 3 pop 3 [entity] [unused] [arg3]</p>
<p>define function CVisibilityPlugins__RenderEntity&lt;cdecl, 0x732B40&gt;(entity, unused, arg3)</p>
<h4>CVisibilityPlugins::RenderFadingAtomic</h4>
<p>plugin::Call<0x732610, CBaseModelInfo<em>, RpAtomic</em>, int>(pBaseModelInfo, pRpAtomic, dwAlpha);</p>
<p>0AA5: call_function 0x732610 num_params 3 pop 3 [pBaseModelInfo] [pRpAtomic] [dwAlpha]</p>
<p>define function CVisibilityPlugins__RenderFadingAtomic&lt;cdecl, 0x732610&gt;(pBaseModelInfo, pRpAtomic, dwAlpha)</p>
<h4>CVisibilityPlugins::RenderFadingClump</h4>
<p>plugin::Call<0x732680, CBaseModelInfo<em>, RpClump</em>, int>(pBaseModelInfo, pRpClump, dwAlpha);</p>
<p>0AA5: call_function 0x732680 num_params 3 pop 3 [pBaseModelInfo] [pRpClump] [dwAlpha]</p>
<p>define function CVisibilityPlugins__RenderFadingClump&lt;cdecl, 0x732680&gt;(pBaseModelInfo, pRpClump, dwAlpha)</p>
<h4>CVisibilityPlugins::RenderFadingClumpCB</h4>
<p>plugin::Call<0x733630, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733630 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderFadingClumpCB&lt;cdecl, 0x733630&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderFadingEntities</h4>
<p>plugin::Call<0x733F10>();</p>
<p>0AA5: call_function 0x733F10 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__RenderFadingEntities&lt;cdecl, 0x733F10&gt;()</p>
<h4>CVisibilityPlugins::RenderFadingUnderwaterEntities</h4>
<p>plugin::Call<0x7337D0>();</p>
<p>0AA5: call_function 0x7337D0 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__RenderFadingUnderwaterEntities&lt;cdecl, 0x7337D0&gt;()</p>
<h4>CVisibilityPlugins::RenderHeliRotorAlphaCB</h4>
<p>plugin::Call<0x7340B0, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x7340B0 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderHeliRotorAlphaCB&lt;cdecl, 0x7340B0&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderHeliTailRotorAlphaCB</h4>
<p>plugin::Call<0x734170, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x734170 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderHeliTailRotorAlphaCB&lt;cdecl, 0x734170&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderObjNormalAtomic</h4>
<p>plugin::Call<0x7323E0, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x7323E0 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderObjNormalAtomic&lt;cdecl, 0x7323E0&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderOrderedList</h4>
<p>plugin::Call <0x7337A0, CLinkList<CVisibilityPlugins::AlphaObjectInfo>&amp;&gt;(AlphaObjectInfoList);</p>
<h4>CVisibilityPlugins::RenderPedCB</h4>
<p>plugin::Call<0x7335B0, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x7335B0 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderPedCB&lt;cdecl, 0x7335B0&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderPlayerCB</h4>
<p>plugin::Call<0x732870, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x732870 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderPlayerCB&lt;cdecl, 0x732870&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderReallyDrawLastObjects</h4>
<p>plugin::Call<0x733800>();</p>
<p>0AA5: call_function 0x733800 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__RenderReallyDrawLastObjects&lt;cdecl, 0x733800&gt;()</p>
<h4>CVisibilityPlugins::RenderTrainHiDetailAlphaCB</h4>
<p>plugin::Call<0x734240, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x734240 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderTrainHiDetailAlphaCB&lt;cdecl, 0x734240&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderTrainHiDetailCB</h4>
<p>plugin::Call<0x733330, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733330 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderTrainHiDetailCB&lt;cdecl, 0x733330&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleHiDetailAlphaCB</h4>
<p>plugin::Call<0x733F80, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733F80 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailAlphaCB&lt;cdecl, 0x733F80&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle</h4>
<p>plugin::Call<0x734370, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x734370 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailAlphaCB_BigVehicle&lt;cdecl, 0x734370&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_Boat</h4>
<p>plugin::Call<0x7344A0, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x7344A0 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailAlphaCB_Boat&lt;cdecl, 0x7344A0&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleHiDetailCB</h4>
<p>plugin::Call<0x733240, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733240 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailCB&lt;cdecl, 0x733240&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle</h4>
<p>plugin::Call<0x733420, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733420 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailCB_BigVehicle&lt;cdecl, 0x733420&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleHiDetailCB_Boat</h4>
<p>plugin::Call<0x733550, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733550 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleHiDetailCB_Boat&lt;cdecl, 0x733550&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleLoDetailCB_Boat</h4>
<p>plugin::Call<0x7334F0, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x7334F0 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleLoDetailCB_Boat&lt;cdecl, 0x7334F0&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleReallyLowDetailCB</h4>
<p>plugin::Call<0x7331E0, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x7331E0 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleReallyLowDetailCB&lt;cdecl, 0x7331E0&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle</h4>
<p>plugin::Call<0x732820, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x732820 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderVehicleReallyLowDetailCB_BigVehicle&lt;cdecl, 0x732820&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderWeaponCB</h4>
<p>plugin::Call<0x733670, RpAtomic*>(pRpAtomic);</p>
<p>0AA5: call_function 0x733670 num_params 1 pop 1 [pRpAtomic]</p>
<p>define function CVisibilityPlugins__RenderWeaponCB&lt;cdecl, 0x733670&gt;(pRpAtomic)</p>
<h4>CVisibilityPlugins::RenderWeaponPedsForPC</h4>
<p>plugin::Call<0x732F30>();</p>
<p>0AA5: call_function 0x732F30 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__RenderWeaponPedsForPC&lt;cdecl, 0x732F30&gt;()</p>
<h4>CVisibilityPlugins::SetAtomicFlag</h4>
<p>plugin::Call<0x7322D0, RpAtomic*, int>(pRpAtomic, flag);</p>
<p>0AA5: call_function 0x7322D0 num_params 2 pop 2 [pRpAtomic] [flag]</p>
<p>define function CVisibilityPlugins__SetAtomicFlag&lt;cdecl, 0x7322D0&gt;(pRpAtomic, flag)</p>
<h4>CVisibilityPlugins::SetAtomicFlag</h4>
<p>plugin::Call<0x7322B0, RpAtomic*, unsigned short>(pRpAtomic, flag);</p>
<p>0AA5: call_function 0x7322B0 num_params 2 pop 2 [pRpAtomic] [flag]</p>
<p>define function CVisibilityPlugins__SetAtomicFlag&lt;cdecl, 0x7322B0&gt;(pRpAtomic, flag)</p>
<h4>CVisibilityPlugins::SetAtomicId</h4>
<p>plugin::Call<0x732230, RpAtomic*, int>(pRpAtomic, id);</p>
<p>0AA5: call_function 0x732230 num_params 2 pop 2 [pRpAtomic] [id]</p>
<p>define function CVisibilityPlugins__SetAtomicId&lt;cdecl, 0x732230&gt;(pRpAtomic, id)</p>
<h4>CVisibilityPlugins::SetAtomicRenderCallback</h4>
<p>plugin::Call<0x7328A0,RpAtomic*, RpAtomic * (*)(RpAtomic *)>(pRpAtomic,renderCB);</p>
<p>0AA5: call_function 0x7328A0 num_params 2 pop 2 [pRpAtomic] [renderCB]</p>
<p>define function CVisibilityPlugins__SetAtomicRenderCallback&lt;cdecl, 0x7328A0&gt;(pRpAtomic, renderCB)</p>
<h4>CVisibilityPlugins::SetClumpAlpha</h4>
<p>plugin::Call<0x732B00, RpClump*, int>(pRpClump, dwAlpha);</p>
<p>0AA5: call_function 0x732B00 num_params 2 pop 2 [pRpClump] [dwAlpha]</p>
<p>define function CVisibilityPlugins__SetClumpAlpha&lt;cdecl, 0x732B00&gt;(pRpClump, dwAlpha)</p>
<h4>CVisibilityPlugins::SetClumpModelInfo</h4>
<p>plugin::Call<0x733750, RpClump<em>, CClumpModelInfo</em>>(pRpClump, pClumpModelInfo);</p>
<p>0AA5: call_function 0x733750 num_params 2 pop 2 [pRpClump] [pClumpModelInfo]</p>
<p>define function CVisibilityPlugins__SetClumpModelInfo&lt;cdecl, 0x733750&gt;(pRpClump, pClumpModelInfo)</p>
<h4>CVisibilityPlugins::SetFrameHierarchyId</h4>
<p>plugin::Call<0x732A00, RwFrame*, int>(pRwFrame, id);</p>
<p>0AA5: call_function 0x732A00 num_params 2 pop 2 [pRwFrame] [id]</p>
<p>define function CVisibilityPlugins__SetFrameHierarchyId&lt;cdecl, 0x732A00&gt;(pRwFrame, id)</p>
<h4>CVisibilityPlugins::SetRenderWareCamera</h4>
<p>plugin::Call<0x7328C0, RwCamera*>(pRwCamera);</p>
<p>0AA5: call_function 0x7328C0 num_params 1 pop 1 [pRwCamera]</p>
<p>define function CVisibilityPlugins__SetRenderWareCamera&lt;cdecl, 0x7328C0&gt;(pRwCamera)</p>
<h4>CVisibilityPlugins::SetUserValue</h4>
<p>plugin::Call<0x732380, RpAtomic*, unsigned short>(pRpAtomic, value);</p>
<p>0AA5: call_function 0x732380 num_params 2 pop 2 [pRpAtomic] [value]</p>
<p>define function CVisibilityPlugins__SetUserValue&lt;cdecl, 0x732380&gt;(pRpAtomic, value)</p>
<h4>CVisibilityPlugins::SetupVehicleVariables</h4>
<p>plugin::Call<0x733160, RpClump*>(pRpClump);</p>
<p>0AA5: call_function 0x733160 num_params 1 pop 1 [pRpClump]</p>
<p>define function CVisibilityPlugins__SetupVehicleVariables&lt;cdecl, 0x733160&gt;(pRpClump)</p>
<h4>CVisibilityPlugins::Shutdown</h4>
<p>plugin::Call<0x732EB0>();</p>
<p>0AA5: call_function 0x732EB0 num_params 0 pop 0</p>
<p>define function CVisibilityPlugins__Shutdown&lt;cdecl, 0x732EB0&gt;()</p>
<h4>CVisibilityPlugins::VehicleVisibilityCB</h4>
<p>plugin::CallAndReturn<bool, 0x7336F0, RpClump*>(pRpClump);</p>
<p>0AA7: call_function_return 0x7336F0 num_params 1 pop 1 [pRpClump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__VehicleVisibilityCB&lt;cdecl, 0x7336F0&gt;(pRpClump): int</p>
<h4>CVisibilityPlugins::VehicleVisibilityCB_BigVehicle</h4>
<p>plugin::CallAndReturn<bool, 0x732AB0, RpClump*>(pRpClump);</p>
<p>0AA7: call_function_return 0x732AB0 num_params 1 pop 1 [pRpClump] func_ret [bool]</p>
<p>define function CVisibilityPlugins__VehicleVisibilityCB_BigVehicle&lt;cdecl, 0x732AB0&gt;(pRpClump): int</p><h3 id="plugin_sagame_sacwantedcpp">plugin_sa\game_sa\CWanted.cpp</h3><h4>CWanted::InitialiseStaticVariables</h4>
<p>plugin::Call<0x561C70>();</p>
<p>0AA5: call_function 0x561C70 num_params 0 pop 0</p>
<p>define function CWanted__InitialiseStaticVariables&lt;cdecl, 0x561C70&gt;()</p>
<h4>CWanted::UpdateWantedLevel</h4>
<p>plugin::CallMethod<0x561C90, CWanted *>(this);</p>
<p>0AA6: call_method 0x561C90 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__UpdateWantedLevel&lt;thiscall, 0x561C90&gt;()</p>
<h4>CWanted::SetMaximumWantedLevel</h4>
<p>plugin::Call<0x561E70, int>(level);</p>
<p>0AA5: call_function 0x561E70 num_params 1 pop 1 [level]</p>
<p>define function CWanted__SetMaximumWantedLevel&lt;cdecl, 0x561E70&gt;(level)</p>
<h4>CWanted::AreMiamiViceRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x561F30, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x561F30 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreMiamiViceRequired&lt;thiscall, 0x561F30&gt;(): int</p>
<h4>CWanted::AreSwatRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x561F40, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x561F40 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreSwatRequired&lt;thiscall, 0x561F40&gt;(): int</p>
<h4>CWanted::AreFbiRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x561F60, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x561F60 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreFbiRequired&lt;thiscall, 0x561F60&gt;(): int</p>
<h4>CWanted::AreArmyRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x561F80, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x561F80 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreArmyRequired&lt;thiscall, 0x561F80&gt;(): int</p>
<h4>CWanted::NumOfHelisRequired</h4>
<p>plugin::CallMethodAndReturn<int, 0x561FA0, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x561FA0 struct [CWanted] num_params 0 pop 0 func_ret [int]</p>
<p>define function CWanted__NumOfHelisRequired&lt;thiscall, 0x561FA0&gt;(): int</p>
<h4>CWanted::ResetPolicePursuit</h4>
<p>plugin::Call<0x561FD0>();</p>
<p>0AA5: call_function 0x561FD0 num_params 0 pop 0</p>
<p>define function CWanted__ResetPolicePursuit&lt;cdecl, 0x561FD0&gt;()</p>
<h4>CWanted::ClearQdCrimes</h4>
<p>plugin::CallMethod<0x561FE0, CWanted *>(this);</p>
<p>0AA6: call_method 0x561FE0 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__ClearQdCrimes&lt;thiscall, 0x561FE0&gt;()</p>
<h4>CWanted::AddCrimeToQ</h4>
<p>plugin::CallMethodAndReturn<bool, 0x562000, CWanted *, eCrimeType, int, CVector const&, bool, bool>(this, crimeType, crimeId, posn, bAlreadyReported, bPoliceDontReallyCare);</p>
<p>0AA8: call_method_return 0x562000 struct [CWanted] num_params 5 pop 0 [crimeType] [crimeId] [posn] [bAlreadyReported] [bPoliceDontReallyCare] func_ret [bool]</p>
<p>define function CWanted__AddCrimeToQ&lt;thiscall, 0x562000&gt;(crimeType, crimeId, posn, bAlreadyReported, bPoliceDontReallyCare): int</p>
<h4>CWanted::ReportCrimeNow</h4>
<p>plugin::CallMethod<0x562120, CWanted *, eCrimeType, CVector const&, bool>(this, crimeType, posn, bPoliceDontReallyCare);</p>
<p>0AA6: call_method 0x562120 struct [CWanted] num_params 3 pop 0 [crimeType] [posn] [bPoliceDontReallyCare]</p>
<p>define function CWanted__ReportCrimeNow&lt;thiscall, 0x562120&gt;(crimeType, posn, bPoliceDontReallyCare)</p>
<h4>CWanted::RemovePursuitCop</h4>
<p>plugin::Call<0x562300, CCopPed<em>, CCopPed</em>*, unsigned char&>(cop, copsArray, copsCounter);</p>
<p>0AA5: call_function 0x562300 num_params 3 pop 3 [cop] [copsArray] [copsCounter]</p>
<p>define function CWanted__RemovePursuitCop&lt;cdecl, 0x562300&gt;(cop, copsArray, copsCounter)</p>
<h4>CWanted::IsInPursuit</h4>
<p>plugin::CallMethodAndReturn<bool, 0x562330, CWanted <em>, CCopPed</em>>(this, cop);</p>
<p>0AA8: call_method_return 0x562330 struct [CWanted] num_params 1 pop 0 [cop] func_ret [bool]</p>
<p>define function CWanted__IsInPursuit&lt;thiscall, 0x562330&gt;(cop): int</p>
<h4>CWanted::UpdateEachFrame</h4>
<p>plugin::Call<0x562360>();</p>
<p>0AA5: call_function 0x562360 num_params 0 pop 0</p>
<p>define function CWanted__UpdateEachFrame&lt;cdecl, 0x562360&gt;()</p>
<h4>CWanted::Initialise</h4>
<p>plugin::CallMethod<0x562390, CWanted *>(this);</p>
<p>0AA6: call_method 0x562390 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Initialise&lt;thiscall, 0x562390&gt;()</p>
<h4>CWanted::Reset</h4>
<p>plugin::CallMethod<0x562400, CWanted *>(this);</p>
<p>0AA6: call_method 0x562400 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Reset&lt;thiscall, 0x562400&gt;()</p>
<h4>CWanted::RegisterCrime</h4>
<p>plugin::CallMethod<0x562410, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, posn, crimeId, bPoliceDontReallyCare);</p>
<p>0AA6: call_method 0x562410 struct [CWanted] num_params 4 pop 0 [crimeType] [posn] [crimeId] [bPoliceDontReallyCare]</p>
<p>define function CWanted__RegisterCrime&lt;thiscall, 0x562410&gt;(crimeType, posn, crimeId, bPoliceDontReallyCare)</p>
<h4>CWanted::RegisterCrime_Immediately</h4>
<p>plugin::CallMethod<0x562430, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, posn, crimeId, bPoliceDontReallyCare);</p>
<p>0AA6: call_method 0x562430 struct [CWanted] num_params 4 pop 0 [crimeType] [posn] [crimeId] [bPoliceDontReallyCare]</p>
<p>define function CWanted__RegisterCrime_Immediately&lt;thiscall, 0x562430&gt;(crimeType, posn, crimeId, bPoliceDontReallyCare)</p>
<h4>CWanted::SetWantedLevel</h4>
<p>plugin::CallMethod<0x562470, CWanted *, int>(this, level);</p>
<p>0AA6: call_method 0x562470 struct [CWanted] num_params 1 pop 0 [level]</p>
<p>define function CWanted__SetWantedLevel&lt;thiscall, 0x562470&gt;(level)</p>
<h4>CWanted::CheatWantedLevel</h4>
<p>plugin::CallMethod<0x562540, CWanted *, int>(this, level);</p>
<p>0AA6: call_method 0x562540 struct [CWanted] num_params 1 pop 0 [level]</p>
<p>define function CWanted__CheatWantedLevel&lt;thiscall, 0x562540&gt;(level)</p>
<h4>CWanted::SetWantedLevelNoDrop</h4>
<p>plugin::CallMethod<0x562570, CWanted *, int>(this, level);</p>
<p>0AA6: call_method 0x562570 struct [CWanted] num_params 1 pop 0 [level]</p>
<p>define function CWanted__SetWantedLevelNoDrop&lt;thiscall, 0x562570&gt;(level)</p>
<h4>CWanted::ClearWantedLevelAndGoOnParole</h4>
<p>plugin::CallMethod<0x5625A0, CWanted *>(this);</p>
<p>0AA6: call_method 0x5625A0 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__ClearWantedLevelAndGoOnParole&lt;thiscall, 0x5625A0&gt;()</p>
<h4>CWanted::WorkOutPolicePresence</h4>
<p>plugin::CallAndReturn<int, 0x5625F0, CVector, float>(posn, radius);</p>
<p>0AA7: call_function_return 0x5625F0 num_params 2 pop 2 [posn] [radius] func_ret [int]</p>
<p>define function CWanted__WorkOutPolicePresence&lt;cdecl, 0x5625F0&gt;(posn, radius): int</p>
<h4>CWanted::UpdateCrimesQ</h4>
<p>plugin::CallMethod<0x562760, CWanted *>(this);</p>
<p>0AA6: call_method 0x562760 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__UpdateCrimesQ&lt;thiscall, 0x562760&gt;()</p>
<h4>CWanted::IsClosestCop</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5627D0, CWanted <em>, CPed</em>, int>(this, ped, numCopsToCheck);</p>
<p>0AA8: call_method_return 0x5627D0 struct [CWanted] num_params 2 pop 0 [ped] [numCopsToCheck] func_ret [bool]</p>
<p>define function CWanted__IsClosestCop&lt;thiscall, 0x5627D0&gt;(ped, numCopsToCheck): int</p>
<h4>CWanted::ComputePursuitCopToDisplace</h4>
<p>plugin::CallAndReturn<CCopPed<em>, 0x562B00, CCopPed</em>, CCopPed**>(cop, copsArray);</p>
<p>0AA7: call_function_return 0x562B00 num_params 2 pop 2 [cop] [copsArray] func_ret [CCopPed*]</p>
<p>define function CWanted__ComputePursuitCopToDisplace&lt;cdecl, 0x562B00&gt;(cop, copsArray): int</p>
<h4>CWanted::RemovePursuitCop</h4>
<p>plugin::CallMethod<0x562C10, CWanted <em>, CCopPed</em>>(this, cop);</p>
<p>0AA6: call_method 0x562C10 struct [CWanted] num_params 1 pop 0 [cop]</p>
<p>define function CWanted__RemovePursuitCop&lt;thiscall, 0x562C10&gt;(cop)</p>
<h4>CWanted::RemoveExcessPursuitCops</h4>
<p>plugin::CallMethod<0x562C40, CWanted *>(this);</p>
<p>0AA6: call_method 0x562C40 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__RemoveExcessPursuitCops&lt;thiscall, 0x562C40&gt;()</p>
<h4>CWanted::Update</h4>
<p>plugin::CallMethod<0x562C90, CWanted *>(this);</p>
<p>0AA6: call_method 0x562C90 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Update&lt;thiscall, 0x562C90&gt;()</p>
<h4>CWanted::CanCopJoinPursuit</h4>
<p>plugin::CallAndReturn<bool, 0x562F60, CCopPed<em>, unsigned char, CCopPed</em>*, unsigned char&>(cop, maxCopsCount, copsArray, copsCounter);</p>
<p>0AA7: call_function_return 0x562F60 num_params 4 pop 4 [cop] [maxCopsCount] [copsArray] [copsCounter] func_ret [bool]</p>
<p>define function CWanted__CanCopJoinPursuit&lt;cdecl, 0x562F60&gt;(cop, maxCopsCount, copsArray, copsCounter): int</p>
<h4>CWanted::CanCopJoinPursuit</h4>
<p>plugin::CallMethodAndReturn<bool, 0x562FB0, CWanted <em>, CCopPed</em>>(this, cop);</p>
<p>0AA8: call_method_return 0x562FB0 struct [CWanted] num_params 1 pop 0 [cop] func_ret [bool]</p>
<p>define function CWanted__CanCopJoinPursuit&lt;thiscall, 0x562FB0&gt;(cop): int</p>
<h4>CWanted::SetPursuitCop</h4>
<p>plugin::CallMethodAndReturn<bool, 0x563060, CWanted <em>, CCopPed</em>>(this, cop);</p>
<p>0AA8: call_method_return 0x563060 struct [CWanted] num_params 1 pop 0 [cop] func_ret [bool]</p>
<p>define function CWanted__SetPursuitCop&lt;thiscall, 0x563060&gt;(cop): int</p><h3 id="plugin_sagame_sacweaponcpp">plugin_sa\game_sa\CWeapon.cpp</h3><h4>CWeapon::InitialiseWeapons</h4>
<p>plugin::Call<0x73A300>();</p>
<p>0AA5: call_function 0x73A300 num_params 0 pop 0</p>
<p>define function CWeapon__InitialiseWeapons&lt;cdecl, 0x73A300&gt;()</p>
<h4>CWeapon::ShutdownWeapons</h4>
<p>plugin::Call<0x73A330>();</p>
<p>0AA5: call_function 0x73A330 num_params 0 pop 0</p>
<p>define function CWeapon__ShutdownWeapons&lt;cdecl, 0x73A330&gt;()</p>
<h4>CWeapon::UpdateWeapons</h4>
<p>plugin::Call<0x73A360>();</p>
<p>0AA5: call_function 0x73A360 num_params 0 pop 0</p>
<p>define function CWeapon__UpdateWeapons&lt;cdecl, 0x73A360&gt;()</p>
<h4>CWeapon::Shutdown</h4>
<p>plugin::CallMethod<0x73A380, CWeapon *>(this);</p>
<p>0AA6: call_method 0x73A380 struct [CWeapon] num_params 0 pop 0</p>
<p>define function CWeapon__Shutdown&lt;thiscall, 0x73A380&gt;()</p>
<h4>CWeapon::AddGunshell</h4>
<p>plugin::CallMethod<0x73A3E0, CWeapon <em>, CEntity</em>, CVector const&, CVector2D const&, float>(this, creator, position, direction, size);</p>
<p>0AA6: call_method 0x73A3E0 struct [CWeapon] num_params 4 pop 0 [creator] [position] [direction] [size]</p>
<p>define function CWeapon__AddGunshell&lt;thiscall, 0x73A3E0&gt;(creator, position, direction, size)</p>
<h4>CWeapon::GenerateDamageEvent</h4>
<p>plugin::Call<0x73A530, CPed<em>, CEntity</em>, eWeaponType, int, ePedPieceTypes, int>(victim, creator, weaponType, damageFactor, pedPiece, direction);</p>
<p>0AA5: call_function 0x73A530 num_params 6 pop 6 [victim] [creator] [weaponType] [damageFactor] [pedPiece] [direction]</p>
<p>define function CWeapon__GenerateDamageEvent&lt;cdecl, 0x73A530&gt;(victim, creator, weaponType, damageFactor, pedPiece, direction)</p>
<h4>CWeapon::LaserScopeDot</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73A8D0, CWeapon <em>, CVector</em>, float*>(this, outCoord, outSize);</p>
<p>0AA8: call_method_return 0x73A8D0 struct [CWeapon] num_params 2 pop 0 [outCoord] [outSize] func_ret [bool]</p>
<p>define function CWeapon__LaserScopeDot&lt;thiscall, 0x73A8D0&gt;(outCoord, outSize): int</p>
<h4>CWeapon::FireSniper</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73AAC0, CWeapon <em>, CPed</em>, CEntity<em>, CVector</em>>(this, creator, victim, target);</p>
<p>0AA8: call_method_return 0x73AAC0 struct [CWeapon] num_params 3 pop 0 [creator] [victim] [target] func_ret [bool]</p>
<p>define function CWeapon__FireSniper&lt;thiscall, 0x73AAC0&gt;(creator, victim, target): int</p>
<h4>CWeapon::Reload</h4>
<p>plugin::CallMethod<0x73AEB0, CWeapon <em>, CPed</em>>(this, owner);</p>
<p>0AA6: call_method 0x73AEB0 struct [CWeapon] num_params 1 pop 0 [owner]</p>
<p>define function CWeapon__Reload&lt;thiscall, 0x73AEB0&gt;(owner)</p>
<h4>FireOneInstantHitRound</h4>
<p>plugin::Call<0x73AF00, CVector<em>, CVector</em>, int>(startPoint, endPoint, intensity);</p>
<p>0AA5: call_function 0x73AF00 num_params 3 pop 3 [startPoint] [endPoint] [intensity]</p>
<p>define function FireOneInstantHitRound&lt;cdecl, 0x73AF00&gt;(startPoint, endPoint, intensity)</p>
<h4>CWeapon::IsTypeMelee</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73B1C0, CWeapon *>(this);</p>
<p>0AA8: call_method_return 0x73B1C0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWeapon__IsTypeMelee&lt;thiscall, 0x73B1C0&gt;(): int</p>
<h4>CWeapon::IsType2Handed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73B1E0, CWeapon *>(this);</p>
<p>0AA8: call_method_return 0x73B1E0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWeapon__IsType2Handed&lt;thiscall, 0x73B1E0&gt;(): int</p>
<h4>CWeapon::IsTypeProjectile</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73B210, CWeapon *>(this);</p>
<p>0AA8: call_method_return 0x73B210 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWeapon__IsTypeProjectile&lt;thiscall, 0x73B210&gt;(): int</p>
<h4>CWeapon::CanBeUsedFor2Player</h4>
<p>plugin::CallAndReturn<bool, 0x73B240, eWeaponType>(weaponType);</p>
<p>0AA7: call_function_return 0x73B240 num_params 1 pop 1 [weaponType] func_ret [bool]</p>
<p>define function CWeapon__CanBeUsedFor2Player&lt;cdecl, 0x73B240&gt;(weaponType): int</p>
<h4>CWeapon::HasWeaponAmmoToBeUsed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73B2A0, CWeapon *>(this);</p>
<p>0AA8: call_method_return 0x73B2A0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWeapon__HasWeaponAmmoToBeUsed&lt;thiscall, 0x73B2A0&gt;(): int</p>
<h4>CWeapon::ProcessLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x73B300, CVector const&, CVector const&, CColPoint&, CEntity<em>&, eWeaponType, CEntity</em>, bool, bool, bool, bool, bool, bool, bool>(startPoint, endPoint, outColPoint, outEntity, weaponType, arg5, buildings, vehicles, peds, objects, dummies, arg11, doIgnoreCameraCheck);</p>
<p>0AA7: call_function_return 0x73B300 num_params 13 pop 13 [startPoint] [endPoint] [outColPoint] [outEntity] [weaponType] [arg5] [buildings] [vehicles] [peds] [objects] [dummies] [arg11] [doIgnoreCameraCheck] func_ret [bool]</p>
<p>define function CWeapon__ProcessLineOfSight&lt;cdecl, 0x73B300&gt;(startPoint, endPoint, outColPoint, outEntity, weaponType, arg5, buildings, vehicles, peds, objects, dummies, arg11, doIgnoreCameraCheck): int</p>
<h4>CWeapon::StopWeaponEffect</h4>
<p>plugin::CallMethod<0x73B360, CWeapon *>(this);</p>
<p>0AA6: call_method 0x73B360 struct [CWeapon] num_params 0 pop 0</p>
<p>define function CWeapon__StopWeaponEffect&lt;thiscall, 0x73B360&gt;()</p>
<h4>CWeapon::TargetWeaponRangeMultiplier</h4>
<p>plugin::CallAndReturn<float, 0x73B380, CEntity<em>, CEntity</em>>(victim, weaponOwner);</p>
<p>0AA7: call_function_return 0x73B380 num_params 2 pop 2 [victim] [weaponOwner] func_ret [float]</p>
<p>define function CWeapon__TargetWeaponRangeMultiplier&lt;cdecl, 0x73B380&gt;(victim, weaponOwner): float</p>
<h4>CWeapon::CWeapon</h4>
<p>plugin::CallMethod<0x73B430, CWeapon *, eWeaponType, int>(this, weaponType, ammo);</p>
<p>0AA6: call_method 0x73B430 struct [CWeapon] num_params 2 pop 0 [weaponType] [ammo]</p>
<p>define function CWeapon__CWeapon&lt;thiscall, 0x73B430&gt;(weaponType, ammo)</p>
<h4>CWeapon::Initialise</h4>
<p>plugin::CallMethod<0x73B4A0, CWeapon <em>, eWeaponType, int, CPed</em>>(this, weaponType, ammo, owner);</p>
<p>0AA6: call_method 0x73B4A0 struct [CWeapon] num_params 3 pop 0 [weaponType] [ammo] [owner]</p>
<p>define function CWeapon__Initialise&lt;thiscall, 0x73B4A0&gt;(weaponType, ammo, owner)</p>
<h4>CWeapon::DoBulletImpact</h4>
<p>plugin::CallMethod<0x73B550, CWeapon <em>, CEntity</em>, CEntity<em>, CVector</em>, CVector<em>, CColPoint</em>, int>(this, owner, victim, startPoint, endPoint, colPoint, arg5);</p>
<p>0AA6: call_method 0x73B550 struct [CWeapon] num_params 6 pop 0 [owner] [victim] [startPoint] [endPoint] [colPoint] [arg5]</p>
<p>define function CWeapon__DoBulletImpact&lt;thiscall, 0x73B550&gt;(owner, victim, startPoint, endPoint, colPoint, arg5)</p>
<h4>CWeapon::TakePhotograph</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73C1F0, CWeapon <em>, CEntity</em>, CVector*>(this, owner, point);</p>
<p>0AA8: call_method_return 0x73C1F0 struct [CWeapon] num_params 2 pop 0 [owner] [point] func_ret [bool]</p>
<p>define function CWeapon__TakePhotograph&lt;thiscall, 0x73C1F0&gt;(owner, point): int</p>
<h4>CWeapon::SetUpPelletCol</h4>
<p>plugin::CallMethod<0x73C710, CWeapon <em>, int, CEntity</em>, CEntity*, CVector&, CColPoint&, CMatrix&>(this, numPellets, owner, victim, point, colPoint, outMatrix);</p>
<p>0AA6: call_method 0x73C710 struct [CWeapon] num_params 6 pop 0 [numPellets] [owner] [victim] [point] [colPoint] [outMatrix]</p>
<p>define function CWeapon__SetUpPelletCol&lt;thiscall, 0x73C710&gt;(numPellets, owner, victim, point, colPoint, outMatrix)</p>
<h4>CWeapon::FireInstantHitFromCar2</h4>
<p>plugin::CallMethod<0x73CBA0, CWeapon <em>, CVector, CVector, CVehicle</em>, CEntity*>(this, startPoint, endPoint, vehicle, owner);</p>
<p>0AA6: call_method 0x73CBA0 struct [CWeapon] num_params 4 pop 0 [startPoint] [endPoint] [vehicle] [owner]</p>
<p>define function CWeapon__FireInstantHitFromCar2&lt;thiscall, 0x73CBA0&gt;(startPoint, endPoint, vehicle, owner)</p>
<h4>CWeapon::DoDoomAiming</h4>
<p>plugin::Call<0x73CDC0, CEntity<em>, CVector</em>, CVector*>(owner, start, end);</p>
<p>0AA5: call_function 0x73CDC0 num_params 3 pop 3 [owner] [start] [end]</p>
<p>define function CWeapon__DoDoomAiming&lt;cdecl, 0x73CDC0&gt;(owner, start, end)</p>
<h4>CWeapon::DoTankDoomAiming</h4>
<p>plugin::Call<0x73D1E0, CEntity<em>, CEntity</em>, CVector<em>, CVector</em>>(vehicle, owner, startPoint, endPoint);</p>
<p>0AA5: call_function 0x73D1E0 num_params 4 pop 4 [vehicle] [owner] [startPoint] [endPoint]</p>
<p>define function CWeapon__DoTankDoomAiming&lt;cdecl, 0x73D1E0&gt;(vehicle, owner, startPoint, endPoint)</p>
<h4>CWeapon::DoDriveByAutoAiming</h4>
<p>plugin::Call<0x73D720, CEntity<em>, CVehicle</em>, CVector<em>, CVector</em>, bool>(owner, vehicle, startPoint, endPoint, canAimVehicles);</p>
<p>0AA5: call_function 0x73D720 num_params 5 pop 5 [owner] [vehicle] [startPoint] [endPoint] [canAimVehicles]</p>
<p>define function CWeapon__DoDriveByAutoAiming&lt;cdecl, 0x73D720&gt;(owner, vehicle, startPoint, endPoint, canAimVehicles)</p>
<h4>CWeapon::Update</h4>
<p>plugin::CallMethod<0x73DB40, CWeapon <em>, CPed</em>>(this, owner);</p>
<p>0AA6: call_method 0x73DB40 struct [CWeapon] num_params 1 pop 0 [owner]</p>
<p>define function CWeapon__Update&lt;thiscall, 0x73DB40&gt;(owner)</p>
<h4>CWeapon::CanBeUsedFor2Player</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73DEF0, CWeapon *>(this);</p>
<p>0AA8: call_method_return 0x73DEF0 struct [CWeapon] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWeapon__CanBeUsedFor2Player&lt;thiscall, 0x73DEF0&gt;(): int</p>
<h4>CWeapon::FindNearestTargetEntityWithScreenCoors</h4>
<p>plugin::Call<0x73E240, float, float, float, CVector, float<em>, float</em>>(screenX, screenY, range, point, outX, outY);</p>
<p>0AA5: call_function 0x73E240 num_params 6 pop 6 [screenX] [screenY] [range] [point] [outX] [outY]</p>
<p>define function CWeapon__FindNearestTargetEntityWithScreenCoors&lt;cdecl, 0x73E240&gt;(screenX, screenY, range, point, outX, outY)</p>
<h4>CWeapon::EvaluateTargetForHeatSeekingMissile</h4>
<p>plugin::CallAndReturn<float, 0x73E560, CEntity<em>, CVector&, CVector&, float, bool, CEntity</em>>(entity, posn, direction, distanceMultiplier, fromVehicle, lastEntity);</p>
<p>0AA7: call_function_return 0x73E560 num_params 6 pop 6 [entity] [posn] [direction] [distanceMultiplier] [fromVehicle] [lastEntity] func_ret [float]</p>
<p>define function CWeapon__EvaluateTargetForHeatSeekingMissile&lt;cdecl, 0x73E560&gt;(entity, posn, direction, distanceMultiplier, fromVehicle, lastEntity): float</p>
<h4>CWeapon::DoWeaponEffect</h4>
<p>plugin::CallMethod<0x73E690, CWeapon *, CVector, CVector>(this, origin, target);</p>
<p>0AA6: call_method 0x73E690 struct [CWeapon] num_params 2 pop 0 [origin] [target]</p>
<p>define function CWeapon__DoWeaponEffect&lt;thiscall, 0x73E690&gt;(origin, target)</p>
<h4>CWeapon::FireAreaEffect</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73E800, CWeapon <em>, CEntity</em>, CVector<em>, CEntity</em>, CVector*>(this, firingEntity, origin, targetEntity, target);</p>
<p>0AA8: call_method_return 0x73E800 struct [CWeapon] num_params 4 pop 0 [firingEntity] [origin] [targetEntity] [target] func_ret [bool]</p>
<p>define function CWeapon__FireAreaEffect&lt;thiscall, 0x73E800&gt;(firingEntity, origin, targetEntity, target): int</p>
<h4>CWeapon::FireInstantHitFromCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73EC40, CWeapon <em>, CVehicle</em>, bool, bool>(this, vehicle, leftSide, rightSide);</p>
<p>0AA8: call_method_return 0x73EC40 struct [CWeapon] num_params 3 pop 0 [vehicle] [leftSide] [rightSide] func_ret [bool]</p>
<p>define function CWeapon__FireInstantHitFromCar&lt;thiscall, 0x73EC40&gt;(vehicle, leftSide, rightSide): int</p>
<h4>CWeapon::CheckForShootingVehicleOccupant</h4>
<p>plugin::CallAndReturn<bool, 0x73F480, CEntity*<em>, CColPoint</em>, eWeaponType, CVector const&, CVector const&>(pCarEntity, colPoint, weaponType, origin, target);</p>
<p>0AA7: call_function_return 0x73F480 num_params 5 pop 5 [pCarEntity] [colPoint] [weaponType] [origin] [target] func_ret [bool]</p>
<p>define function CWeapon__CheckForShootingVehicleOccupant&lt;cdecl, 0x73F480&gt;(pCarEntity, colPoint, weaponType, origin, target): int</p>
<h4>CWeapon::PickTargetForHeatSeekingMissile</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x73F910, CVector, CVector, float, CEntity</em>, bool, CEntity*>(origin, direction, distanceMultiplier, ignoreEntity, fromVehicle, lastEntity);</p>
<p>0AA7: call_function_return 0x73F910 num_params 6 pop 6 [origin] [direction] [distanceMultiplier] [ignoreEntity] [fromVehicle] [lastEntity] func_ret [CEntity*]</p>
<p>define function CWeapon__PickTargetForHeatSeekingMissile&lt;cdecl, 0x73F910&gt;(origin, direction, distanceMultiplier, ignoreEntity, fromVehicle, lastEntity): int</p>
<h4>CWeapon::FireFromCar</h4>
<p>plugin::CallMethod<0x73FA20, CWeapon <em>, CVehicle</em>, bool, bool>(this, vehicle, leftSide, rightSide);</p>
<p>0AA6: call_method 0x73FA20 struct [CWeapon] num_params 3 pop 0 [vehicle] [leftSide] [rightSide]</p>
<p>define function CWeapon__FireFromCar&lt;thiscall, 0x73FA20&gt;(vehicle, leftSide, rightSide)</p>
<h4>CWeapon::FireInstantHit</h4>
<p>plugin::CallMethodAndReturn<bool, 0x73FB10, CWeapon <em>, CEntity</em>, CVector<em>, CVector</em>, CEntity<em>, CVector</em>, CVector*, bool, bool>(this, firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy, arg6, muzzle);</p>
<p>0AA8: call_method_return 0x73FB10 struct [CWeapon] num_params 8 pop 0 [firingEntity] [origin] [muzzlePosn] [targetEntity] [target] [originForDriveBy] [arg6] [muzzle] func_ret [bool]</p>
<p>define function CWeapon__FireInstantHit&lt;thiscall, 0x73FB10&gt;(firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy, arg6, muzzle): int</p>
<h4>CWeapon::FireProjectile</h4>
<p>plugin::CallMethodAndReturn<bool, 0x741360, CWeapon <em>, CEntity</em>, CVector<em>, CEntity</em>, CVector*, float>(this, firingEntity, origin, targetEntity, target, force);</p>
<p>0AA8: call_method_return 0x741360 struct [CWeapon] num_params 5 pop 0 [firingEntity] [origin] [targetEntity] [target] [force] func_ret [bool]</p>
<p>define function CWeapon__FireProjectile&lt;thiscall, 0x741360&gt;(firingEntity, origin, targetEntity, target, force): int</p>
<h4>CWeapon::FireM16_1stPerson</h4>
<p>plugin::CallMethodAndReturn<bool, 0x741C00, CWeapon <em>, CEntity</em>>(this, owner);</p>
<p>0AA8: call_method_return 0x741C00 struct [CWeapon] num_params 1 pop 0 [owner] func_ret [bool]</p>
<p>define function CWeapon__FireM16_1stPerson&lt;thiscall, 0x741C00&gt;(owner): int</p>
<h4>CWeapon::Fire</h4>
<p>plugin::CallMethodAndReturn<bool, 0x742300, CWeapon <em>, CEntity</em>, CVector<em>, CVector</em>, CEntity<em>, CVector</em>, CVector*>(this, firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy);</p>
<p>0AA8: call_method_return 0x742300 struct [CWeapon] num_params 6 pop 0 [firingEntity] [origin] [muzzlePosn] [targetEntity] [target] [originForDriveBy] func_ret [bool]</p>
<p>define function CWeapon__Fire&lt;thiscall, 0x742300&gt;(firingEntity, origin, muzzlePosn, targetEntity, target, originForDriveBy): int</p><h3 id="plugin_sagame_sacweaponeffectscpp">plugin_sa\game_sa\CWeaponEffects.cpp</h3><h4>CWeaponEffects::CWeaponEffects</h4>
<p>plugin::CallMethod<0x742A90, CWeaponEffects *>(this);</p>
<p>0AA6: call_method 0x742A90 struct [CWeaponEffects] num_params 0 pop 0</p>
<p>define function CWeaponEffects__CWeaponEffects&lt;thiscall, 0x742A90&gt;()</p>
<h4>CWeaponEffects::~CWeaponEffects</h4>
<p>plugin::CallMethod<0x742AA0, CWeaponEffects *>(this);</p>
<p>0AA6: call_method 0x742AA0 struct [CWeaponEffects] num_params 0 pop 0</p>
<p>define function CWeaponEffects__~CWeaponEffects&lt;thiscall, 0x742AA0&gt;()</p>
<h4>CWeaponEffects::Init</h4>
<p>plugin::Call<0x742AB0>();</p>
<p>0AA5: call_function 0x742AB0 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Init&lt;cdecl, 0x742AB0&gt;()</p>
<h4>CWeaponEffects::Shutdown</h4>
<p>plugin::Call<0x742B80>();</p>
<p>0AA5: call_function 0x742B80 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Shutdown&lt;cdecl, 0x742B80&gt;()</p>
<h4>CWeaponEffects::IsLockedOn</h4>
<p>plugin::CallAndReturn<bool, 0x742BD0, int>(crosshairId);</p>
<p>0AA7: call_function_return 0x742BD0 num_params 1 pop 1 [crosshairId] func_ret [bool]</p>
<p>define function CWeaponEffects__IsLockedOn&lt;cdecl, 0x742BD0&gt;(crosshairId): int</p>
<h4>CWeaponEffects::MarkTarget</h4>
<p>plugin::Call<0x742BF0, int, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float, unsigned char>(crosshairId, posn, red, green, blue, alpha, size, arg7);</p>
<p>0AA5: call_function 0x742BF0 num_params 8 pop 8 [crosshairId] [posn] [red] [green] [blue] [alpha] [size] [arg7]</p>
<p>define function CWeaponEffects__MarkTarget&lt;cdecl, 0x742BF0&gt;(crosshairId, posn, red, green, blue, alpha, size, arg7)</p>
<h4>CWeaponEffects::ClearCrossHair</h4>
<p>plugin::Call<0x742C60, int>(crosshairId);</p>
<p>0AA5: call_function 0x742C60 num_params 1 pop 1 [crosshairId]</p>
<p>define function CWeaponEffects__ClearCrossHair&lt;cdecl, 0x742C60&gt;(crosshairId)</p>
<h4>CWeaponEffects::ClearCrossHairs</h4>
<p>plugin::Call<0x742C80>();</p>
<p>0AA5: call_function 0x742C80 num_params 0 pop 0</p>
<p>define function CWeaponEffects__ClearCrossHairs&lt;cdecl, 0x742C80&gt;()</p>
<h4>CWeaponEffects::ClearCrossHairImmediately</h4>
<p>plugin::Call<0x742CA0, int>(crosshairId);</p>
<p>0AA5: call_function 0x742CA0 num_params 1 pop 1 [crosshairId]</p>
<p>define function CWeaponEffects__ClearCrossHairImmediately&lt;cdecl, 0x742CA0&gt;(crosshairId)</p>
<h4>CWeaponEffects::ClearCrossHairsImmediately</h4>
<p>plugin::Call<0x742CC0>();</p>
<p>0AA5: call_function 0x742CC0 num_params 0 pop 0</p>
<p>define function CWeaponEffects__ClearCrossHairsImmediately&lt;cdecl, 0x742CC0&gt;()</p>
<h4>CWeaponEffects::Render</h4>
<p>plugin::Call<0x742CF0>();</p>
<p>0AA5: call_function 0x742CF0 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Render&lt;cdecl, 0x742CF0&gt;()</p><h3 id="plugin_sagame_sacweathercpp">plugin_sa\game_sa\CWeather.cpp</h3><h4>CWeather::AddRain</h4>
<p>plugin::Call<0x72A9A0>();</p>
<p>0AA5: call_function 0x72A9A0 num_params 0 pop 0</p>
<p>define function CWeather__AddRain&lt;cdecl, 0x72A9A0&gt;()</p>
<h4>CWeather::AddSandStormParticles</h4>
<p>plugin::Call<0x72A820>();</p>
<p>0AA5: call_function 0x72A820 num_params 0 pop 0</p>
<p>define function CWeather__AddSandStormParticles&lt;cdecl, 0x72A820&gt;()</p>
<h4>CWeather::FindWeatherTypesList</h4>
<p>plugin::CallAndReturn<unsigned char*, 0x72A520>();</p>
<p>0AA7: call_function_return 0x72A520 num_params 0 pop 0 func_ret [unsigned char*]</p>
<p>define function CWeather__FindWeatherTypesList&lt;cdecl, 0x72A520&gt;(): int</p>
<h4>CWeather::ForceWeather</h4>
<p>plugin::Call<0x72A4E0, short>(weatherType);</p>
<p>0AA5: call_function 0x72A4E0 num_params 1 pop 1 [weatherType]</p>
<p>define function CWeather__ForceWeather&lt;cdecl, 0x72A4E0&gt;(weatherType)</p>
<h4>CWeather::ForceWeatherNow</h4>
<p>plugin::Call<0x72A4F0, short>(weatherType);</p>
<p>0AA5: call_function 0x72A4F0 num_params 1 pop 1 [weatherType]</p>
<p>define function CWeather__ForceWeatherNow&lt;cdecl, 0x72A4F0&gt;(weatherType)</p>
<h4>CWeather::ForecastWeather</h4>
<p>plugin::CallAndReturn<bool, 0x72A590, int, int>(weatherType, numSteps);</p>
<p>0AA7: call_function_return 0x72A590 num_params 2 pop 2 [weatherType] [numSteps] func_ret [bool]</p>
<p>define function CWeather__ForecastWeather&lt;cdecl, 0x72A590&gt;(weatherType, numSteps): int</p>
<h4>CWeather::Init</h4>
<p>plugin::Call<0x72A480>();</p>
<p>0AA5: call_function 0x72A480 num_params 0 pop 0</p>
<p>define function CWeather__Init&lt;cdecl, 0x72A480&gt;()</p>
<h4>CWeather::ReleaseWeather</h4>
<p>plugin::Call<0x72A510>();</p>
<p>0AA5: call_function 0x72A510 num_params 0 pop 0</p>
<p>define function CWeather__ReleaseWeather&lt;cdecl, 0x72A510&gt;()</p>
<h4>CWeather::RenderRainStreaks</h4>
<p>plugin::Call<0x72AF70>();</p>
<p>0AA5: call_function 0x72AF70 num_params 0 pop 0</p>
<p>define function CWeather__RenderRainStreaks&lt;cdecl, 0x72AF70&gt;()</p>
<h4>CWeather::SetWeatherToAppropriateTypeNow</h4>
<p>plugin::Call<0x72A790>();</p>
<p>0AA5: call_function 0x72A790 num_params 0 pop 0</p>
<p>define function CWeather__SetWeatherToAppropriateTypeNow&lt;cdecl, 0x72A790&gt;()</p>
<h4>CWeather::Update</h4>
<p>plugin::Call<0x72B850>();</p>
<p>0AA5: call_function 0x72B850 num_params 0 pop 0</p>
<p>define function CWeather__Update&lt;cdecl, 0x72B850&gt;()</p>
<h4>CWeather::UpdateInTunnelness</h4>
<p>plugin::Call<0x72B630>();</p>
<p>0AA5: call_function 0x72B630 num_params 0 pop 0</p>
<p>define function CWeather__UpdateInTunnelness&lt;cdecl, 0x72B630&gt;()</p>
<h4>CWeather::UpdateWeatherRegion</h4>
<p>plugin::Call<0x72A640, CVector*>(posn);</p>
<p>0AA5: call_function 0x72A640 num_params 1 pop 1 [posn]</p>
<p>define function CWeather__UpdateWeatherRegion&lt;cdecl, 0x72A640&gt;(posn)</p><h3 id="plugin_sagame_sacworldcpp">plugin_sa\game_sa\CWorld.cpp</h3><h4>CWorld::ResetLineTestOptions</h4>
<p>plugin::Call<0x5631C0>();</p>
<p>0AA5: call_function 0x5631C0 num_params 0 pop 0</p>
<p>define function CWorld__ResetLineTestOptions&lt;cdecl, 0x5631C0&gt;()</p>
<h4>CWorld::Initialise</h4>
<p>plugin::Call<0x5631E0>();</p>
<p>0AA5: call_function 0x5631E0 num_params 0 pop 0</p>
<p>define function CWorld__Initialise&lt;cdecl, 0x5631E0&gt;()</p>
<h4>CWorld::Add</h4>
<p>plugin::Call<0x563220, CEntity*>(entity);</p>
<p>0AA5: call_function 0x563220 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__Add&lt;cdecl, 0x563220&gt;(entity)</p>
<h4>CWorld::Remove</h4>
<p>plugin::Call<0x563280, CEntity*>(entity);</p>
<p>0AA5: call_function 0x563280 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__Remove&lt;cdecl, 0x563280&gt;(entity)</p>
<h4>CWorld::ProcessVerticalLineSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x5632B0, CPtrList&, CColLine const&, CColPoint&, float&, CEntity<em>&, bool, CStoredCollPoly</em>>(ptrList, colLine, colPoint, maxTouchDistance, outEntity, doSeeThroughCheck, collPoly);</p>
<p>0AA7: call_function_return 0x5632B0 num_params 7 pop 7 [ptrList] [colLine] [colPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [collPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSectorList&lt;cdecl, 0x5632B0&gt;(ptrList, colLine, colPoint, maxTouchDistance, outEntity, doSeeThroughCheck, collPoly): int</p>
<h4>CWorld::CastShadowSectorList</h4>
<p>plugin::Call<0x563390, CPtrList&, float, float, float, float>(ptrList, arg1, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x563390 num_params 5 pop 5 [ptrList] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CWorld__CastShadowSectorList&lt;cdecl, 0x563390&gt;(ptrList, arg1, arg2, arg3, arg4)</p>
<h4>CWorld::ProcessForAnimViewer</h4>
<p>plugin::Call<0x5633D0>();</p>
<p>0AA5: call_function 0x5633D0 num_params 0 pop 0</p>
<p>define function CWorld__ProcessForAnimViewer&lt;cdecl, 0x5633D0&gt;()</p>
<h4>CWorld::ProcessPedsAfterPreRender</h4>
<p>plugin::Call<0x563430>();</p>
<p>0AA5: call_function 0x563430 num_params 0 pop 0</p>
<p>define function CWorld__ProcessPedsAfterPreRender&lt;cdecl, 0x563430&gt;()</p>
<h4>CWorld::ClearScanCodes</h4>
<p>plugin::Call<0x563470>();</p>
<p>0AA5: call_function 0x563470 num_params 0 pop 0</p>
<p>define function CWorld__ClearScanCodes&lt;cdecl, 0x563470&gt;()</p>
<h4>CWorld::FindObjectsInRangeSectorList</h4>
<p>plugin::Call<0x563500, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(arg0, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x563500 num_params 7 pop 7 [arg0] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsInRangeSectorList&lt;cdecl, 0x563500&gt;(arg0, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsOfTypeInRangeSectorList</h4>
<p>plugin::Call<0x5635C0, unsigned int, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(modelId, ptrList, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x5635C0 num_params 8 pop 8 [modelId] [ptrList] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsOfTypeInRangeSectorList&lt;cdecl, 0x5635C0&gt;(modelId, ptrList, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints</h4>
<p>plugin::CallAndReturn<bool, 0x5636A0, CPtrList&, CColLine const&, CEntity<em>&, bool, CStoredCollPoly</em>>(ptrList, colLine, outEntity, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x5636A0 num_params 5 pop 5 [ptrList] [colLine] [outEntity] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSectorList_FillGlobeColPoints&lt;cdecl, 0x5636A0&gt;(ptrList, colLine, outEntity, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::RemoveStaticObjects</h4>
<p>plugin::Call<0x563840>();</p>
<p>0AA5: call_function 0x563840 num_params 0 pop 0</p>
<p>define function CWorld__RemoveStaticObjects&lt;cdecl, 0x563840&gt;()</p>
<h4>CWorld::TestForBuildingsOnTopOfEachOther</h4>
<p>plugin::Call<0x563950, CPtrList&>(ptrList);</p>
<p>0AA5: call_function 0x563950 num_params 1 pop 1 [ptrList]</p>
<p>define function CWorld__TestForBuildingsOnTopOfEachOther&lt;cdecl, 0x563950&gt;(ptrList)</p>
<h4>CWorld::TestForUnusedModels</h4>
<p>plugin::Call<0x5639D0, CPtrList&, int*>(ptrList, models);</p>
<p>0AA5: call_function 0x5639D0 num_params 2 pop 2 [ptrList] [models]</p>
<p>define function CWorld__TestForUnusedModels&lt;cdecl, 0x5639D0&gt;(ptrList, models)</p>
<h4>CWorld::RemoveEntityInsteadOfProcessingIt</h4>
<p>plugin::Call<0x563A10, CEntity*>(entity);</p>
<p>0AA5: call_function 0x563A10 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RemoveEntityInsteadOfProcessingIt&lt;cdecl, 0x563A10&gt;(entity)</p>
<h4>CWorld::CallOffChaseForAreaSectorListVehicles</h4>
<p>plugin::Call<0x563A80, CPtrList&, float, float, float, float, float, float, float, float>(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x563A80 num_params 9 pop 9 [ptrList] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CWorld__CallOffChaseForAreaSectorListVehicles&lt;cdecl, 0x563A80&gt;(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8)</p>
<h4>CWorld::CallOffChaseForAreaSectorListPeds</h4>
<p>plugin::Call<0x563D00, CPtrList&, float, float, float, float, float, float, float, float>(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x563D00 num_params 9 pop 9 [ptrList] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CWorld__CallOffChaseForAreaSectorListPeds&lt;cdecl, 0x563D00&gt;(ptrList, x1, y1, x2, y2, arg5, arg6, arg7, arg8)</p>
<h4>CWorld::CameraToIgnoreThisObject</h4>
<p>plugin::CallAndReturn<bool, 0x563F40, CEntity*>(entity);</p>
<p>0AA7: call_function_return 0x563F40 num_params 1 pop 1 [entity] func_ret [bool]</p>
<p>define function CWorld__CameraToIgnoreThisObject&lt;cdecl, 0x563F40&gt;(entity): int</p>
<h4>CWorld::FindPlayerSlotWithPedPointer</h4>
<p>plugin::CallAndReturn<int, 0x563FA0, void*>(ptr);</p>
<p>0AA7: call_function_return 0x563FA0 num_params 1 pop 1 [ptr] func_ret [int]</p>
<p>define function CWorld__FindPlayerSlotWithPedPointer&lt;cdecl, 0x563FA0&gt;(ptr): int</p>
<h4>CWorld::FindPlayerSlotWithRemoteVehiclePointer</h4>
<p>plugin::CallAndReturn<int, 0x563FD0, void*>(ptr);</p>
<p>0AA7: call_function_return 0x563FD0 num_params 1 pop 1 [ptr] func_ret [int]</p>
<p>define function CWorld__FindPlayerSlotWithRemoteVehiclePointer&lt;cdecl, 0x563FD0&gt;(ptr): int</p>
<h4>CWorld::FindPlayerSlotWithVehiclePointer</h4>
<p>plugin::Call<0x564000, CEntity*>(vehiclePtr);</p>
<p>0AA5: call_function 0x564000 num_params 1 pop 1 [vehiclePtr]</p>
<p>define function CWorld__FindPlayerSlotWithVehiclePointer&lt;cdecl, 0x564000&gt;(vehiclePtr)</p>
<h4>CWorld::ShutDown</h4>
<p>plugin::Call<0x564050>();</p>
<p>0AA5: call_function 0x564050 num_params 0 pop 0</p>
<p>define function CWorld__ShutDown&lt;cdecl, 0x564050&gt;()</p>
<h4>CWorld::ClearForRestart</h4>
<p>plugin::Call<0x564360>();</p>
<p>0AA5: call_function 0x564360 num_params 0 pop 0</p>
<p>define function CWorld__ClearForRestart&lt;cdecl, 0x564360&gt;()</p>
<h4>CWorld::ProcessVerticalLineSector_FillGlobeColPoints</h4>
<p>plugin::CallAndReturn<bool, 0x564420, CSector&, CRepeatSector&, CColLine const&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(sector, repeatSector, colLine, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x564420 num_params 11 pop 11 [sector] [repeatSector] [colLine] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSector_FillGlobeColPoints&lt;cdecl, 0x564420&gt;(sector, repeatSector, colLine, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::ProcessVerticalLineSector</h4>
<p>plugin::CallAndReturn<bool, 0x564500, CSector&, CRepeatSector&, CColLine const&, CColPoint&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(sector, repeatSector, colLine, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x564500 num_params 12 pop 12 [sector] [repeatSector] [colLine] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSector&lt;cdecl, 0x564500&gt;(sector, repeatSector, colLine, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::CastShadow</h4>
<p>plugin::Call<0x564600, float, float, float, float>(x1, y1, x2, y2);</p>
<p>0AA5: call_function 0x564600 num_params 4 pop 4 [x1] [y1] [x2] [y2]</p>
<p>define function CWorld__CastShadow&lt;cdecl, 0x564600&gt;(x1, y1, x2, y2)</p>
<h4>CWorld::ProcessAttachedEntities</h4>
<p>plugin::Call<0x5647F0>();</p>
<p>0AA5: call_function 0x5647F0 num_params 0 pop 0</p>
<p>define function CWorld__ProcessAttachedEntities&lt;cdecl, 0x5647F0&gt;()</p>
<h4>CWorld::GetIsLineOfSightSectorListClear</h4>
<p>plugin::CallAndReturn<bool, 0x564970, CPtrList&, CColLine const&, bool, bool>(ptrList, colLine, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x564970 num_params 4 pop 4 [ptrList] [colLine] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightSectorListClear&lt;cdecl, 0x564970&gt;(ptrList, colLine, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::FindObjectsInRange</h4>
<p>plugin::Call<0x564A20, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x564A20 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsInRange&lt;cdecl, 0x564A20&gt;(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsOfTypeInRange</h4>
<p>plugin::Call<0x564C70, unsigned int, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x564C70 num_params 12 pop 12 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsOfTypeInRange&lt;cdecl, 0x564C70&gt;(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindLodOfTypeInRange</h4>
<p>plugin::Call<0x564ED0, unsigned int, CVector const&, float, bool, short<em>, short, CEntity</em>*>(modelId, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x564ED0 num_params 7 pop 7 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindLodOfTypeInRange&lt;cdecl, 0x564ED0&gt;(modelId, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsKindaCollidingSectorList</h4>
<p>plugin::Call<0x565000, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(ptrList, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x565000 num_params 7 pop 7 [ptrList] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsKindaCollidingSectorList&lt;cdecl, 0x565000&gt;(ptrList, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsIntersectingCubeSectorList</h4>
<p>plugin::Call<0x5650E0, CPtrList&, CVector const&, CVector const&, short<em>, short, CEntity</em>*>(ptrList, cornerA, cornerB, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x5650E0 num_params 6 pop 6 [ptrList] [cornerA] [cornerB] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsIntersectingCubeSectorList&lt;cdecl, 0x5650E0&gt;(ptrList, cornerA, cornerB, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList</h4>
<p>plugin::Call<0x565200, CPtrList&, CBox const&, CMatrix const&, CVector const&, short<em>, short, CEntity</em>*>(ptrList, box, transform, point, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x565200 num_params 7 pop 7 [ptrList] [box] [transform] [point] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsIntersectingAngledCollisionBoxSectorList&lt;cdecl, 0x565200&gt;(ptrList, box, transform, point, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindMissionEntitiesIntersectingCubeSectorList</h4>
<p>plugin::Call<0x565300, CPtrList&, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool>(ptrList, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);</p>
<p>0AA5: call_function 0x565300 num_params 9 pop 9 [ptrList] [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehiclesList] [pedsList] [objectsList]</p>
<p>define function CWorld__FindMissionEntitiesIntersectingCubeSectorList&lt;cdecl, 0x565300&gt;(ptrList, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList)</p>
<h4>CWorld::FindNearestObjectOfTypeSectorList</h4>
<p>plugin::Call<0x565450, int, CPtrList&, CVector const&, float, bool, CEntity*<em>, float</em>>(modelId, ptrList, point, radius, b2D, outEntities, outDistance);</p>
<p>0AA5: call_function 0x565450 num_params 7 pop 7 [modelId] [ptrList] [point] [radius] [b2D] [outEntities] [outDistance]</p>
<p>define function CWorld__FindNearestObjectOfTypeSectorList&lt;cdecl, 0x565450&gt;(modelId, ptrList, point, radius, b2D, outEntities, outDistance)</p>
<h4>CWorld::RemoveReferencesToDeletedObject</h4>
<p>plugin::Call<0x565510, CEntity*>(entity);</p>
<p>0AA5: call_function 0x565510 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RemoveReferencesToDeletedObject&lt;cdecl, 0x565510&gt;(entity)</p>
<h4>CWorld::SetPedsOnFire</h4>
<p>plugin::Call<0x565610, float, float, float, float, CEntity*>(x1, y1, x2, y2, fireCreator);</p>
<p>0AA5: call_function 0x565610 num_params 5 pop 5 [x1] [y1] [x2] [y2] [fireCreator]</p>
<p>define function CWorld__SetPedsOnFire&lt;cdecl, 0x565610&gt;(x1, y1, x2, y2, fireCreator)</p>
<h4>CWorld::SetPedsChoking</h4>
<p>plugin::Call<0x565800, float, float, float, float, CEntity*>(x1, y1, x2, y2, gasCreator);</p>
<p>0AA5: call_function 0x565800 num_params 5 pop 5 [x1] [y1] [x2] [y2] [gasCreator]</p>
<p>define function CWorld__SetPedsChoking&lt;cdecl, 0x565800&gt;(x1, y1, x2, y2, gasCreator)</p>
<h4>CWorld::SetCarsOnFire</h4>
<p>plugin::Call<0x5659F0, float, float, float, float, CEntity*>(x1, y1, x2, y2, fireCreator);</p>
<p>0AA5: call_function 0x5659F0 num_params 5 pop 5 [x1] [y1] [x2] [y2] [fireCreator]</p>
<p>define function CWorld__SetCarsOnFire&lt;cdecl, 0x5659F0&gt;(x1, y1, x2, y2, fireCreator)</p>
<h4>CWorld::SprayPaintWorld</h4>
<p>plugin::CallAndReturn<bool, 0x565B70, CVector&, CVector&, float, bool>(posn, outDir, radius, processTagAlphaState);</p>
<p>0AA7: call_function_return 0x565B70 num_params 4 pop 4 [posn] [outDir] [radius] [processTagAlphaState] func_ret [bool]</p>
<p>define function CWorld__SprayPaintWorld&lt;cdecl, 0x565B70&gt;(posn, outDir, radius, processTagAlphaState): int</p>
<h4>CWorld::RemoveFallenPeds</h4>
<p>plugin::Call<0x565CB0>();</p>
<p>0AA5: call_function 0x565CB0 num_params 0 pop 0</p>
<p>define function CWorld__RemoveFallenPeds&lt;cdecl, 0x565CB0&gt;()</p>
<h4>CWorld::RemoveFallenCars</h4>
<p>plugin::Call<0x565E80>();</p>
<p>0AA5: call_function 0x565E80 num_params 0 pop 0</p>
<p>define function CWorld__RemoveFallenCars&lt;cdecl, 0x565E80&gt;()</p>
<h4>CWorld::UseDetonator</h4>
<p>plugin::Call<0x5660B0, CEntity*>(creator);</p>
<p>0AA5: call_function 0x5660B0 num_params 1 pop 1 [creator]</p>
<p>define function CWorld__UseDetonator&lt;cdecl, 0x5660B0&gt;(creator)</p>
<h4>CWorld::TestSphereAgainstSectorList</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x566140, CPtrList&, CVector, float, CEntity</em>, bool>(ptrList, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x566140 num_params 5 pop 5 [ptrList] [sphereCenter] [sphereRadius] [ignoreEntity] [doCameraIgnoreCheck] func_ret [CEntity*]</p>
<p>define function CWorld__TestSphereAgainstSectorList&lt;cdecl, 0x566140&gt;(ptrList, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck): int</p>
<h4>CWorld::PrintCarChanges</h4>
<p>plugin::Call<0x566420>();</p>
<p>0AA5: call_function 0x566420 num_params 0 pop 0</p>
<p>define function CWorld__PrintCarChanges&lt;cdecl, 0x566420&gt;()</p>
<h4>CWorld::TestForBuildingsOnTopOfEachOther</h4>
<p>plugin::Call<0x5664A0>();</p>
<p>0AA5: call_function 0x5664A0 num_params 0 pop 0</p>
<p>define function CWorld__TestForBuildingsOnTopOfEachOther&lt;cdecl, 0x5664A0&gt;()</p>
<h4>CWorld::TestForUnusedModels</h4>
<p>plugin::Call<0x566510>();</p>
<p>0AA5: call_function 0x566510 num_params 0 pop 0</p>
<p>define function CWorld__TestForUnusedModels&lt;cdecl, 0x566510&gt;()</p>
<h4>CWorld::ClearCarsFromArea</h4>
<p>plugin::Call<0x566610, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x566610 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CWorld__ClearCarsFromArea&lt;cdecl, 0x566610&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CWorld::ClearPedsFromArea</h4>
<p>plugin::Call<0x5667F0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x5667F0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CWorld__ClearPedsFromArea&lt;cdecl, 0x5667F0&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CWorld::SetAllCarsCanBeDamaged</h4>
<p>plugin::Call<0x5668F0, bool>(enable);</p>
<p>0AA5: call_function 0x5668F0 num_params 1 pop 1 [enable]</p>
<p>define function CWorld__SetAllCarsCanBeDamaged&lt;cdecl, 0x5668F0&gt;(enable)</p>
<h4>CWorld::ExtinguishAllCarFiresInArea</h4>
<p>plugin::Call<0x566950, CVector, float>(point, radius);</p>
<p>0AA5: call_function 0x566950 num_params 2 pop 2 [point] [radius]</p>
<p>define function CWorld__ExtinguishAllCarFiresInArea&lt;cdecl, 0x566950&gt;(point, radius)</p>
<h4>CWorld::CallOffChaseForArea</h4>
<p>plugin::Call<0x566A60, float, float, float, float>(x1, y1, x2, y2);</p>
<p>0AA5: call_function 0x566A60 num_params 4 pop 4 [x1] [y1] [x2] [y2]</p>
<p>define function CWorld__CallOffChaseForArea&lt;cdecl, 0x566A60&gt;(x1, y1, x2, y2)</p>
<h4>CWorld::StopAllLawEnforcersInTheirTracks</h4>
<p>plugin::Call<0x566C10>();</p>
<p>0AA5: call_function 0x566C10 num_params 0 pop 0</p>
<p>define function CWorld__StopAllLawEnforcersInTheirTracks&lt;cdecl, 0x566C10&gt;()</p>
<h4>CWorld::FindUnsuspectingTargetCar</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x566C90, CVector, CVector>(point, playerPosn);</p>
<p>0AA7: call_function_return 0x566C90 num_params 2 pop 2 [point] [playerPosn] func_ret [CVehicle*]</p>
<p>define function CWorld__FindUnsuspectingTargetCar&lt;cdecl, 0x566C90&gt;(point, playerPosn): int</p>
<h4>CWorld::FindUnsuspectingTargetPed</h4>
<p>plugin::CallAndReturn<CPed*, 0x566DA0, CVector, CVector>(point, playerPosn);</p>
<p>0AA7: call_function_return 0x566DA0 num_params 2 pop 2 [point] [playerPosn] func_ret [CPed*]</p>
<p>define function CWorld__FindUnsuspectingTargetPed&lt;cdecl, 0x566DA0&gt;(point, playerPosn): int</p>
<h4>CWorld::ProcessLineOfSightSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x566EE0, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool>(ptrList, colLine, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doIgnoreCameraCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x566EE0 num_params 8 pop 8 [ptrList] [colLine] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [doIgnoreCameraCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSightSectorList&lt;cdecl, 0x566EE0&gt;(ptrList, colLine, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doIgnoreCameraCheck, doShootThroughCheck): int</p>
<h4>CWorld::ProcessVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x5674E0, CVector const&, float, CColPoint&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x5674E0 num_params 11 pop 11 [origin] [distance] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLine&lt;cdecl, 0x5674E0&gt;(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::ProcessVerticalLine_FillGlobeColPoints</h4>
<p>plugin::CallAndReturn<bool, 0x567620, CVector const&, float, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(origin, distance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x567620 num_params 10 pop 10 [origin] [distance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLine_FillGlobeColPoints&lt;cdecl, 0x567620&gt;(origin, distance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::TriggerExplosionSectorList</h4>
<p>plugin::Call<0x567750, CPtrList&, CVector const&, float, float, CEntity<em>, CEntity</em>, bool, float>(ptrList, point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage);</p>
<p>0AA5: call_function 0x567750 num_params 8 pop 8 [ptrList] [point] [radius] [visibleDistance] [victim] [creator] [processVehicleBombTimer] [damage]</p>
<p>define function CWorld__TriggerExplosionSectorList&lt;cdecl, 0x567750&gt;(ptrList, point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage)</p>
<h4>CWorld::Process</h4>
<p>plugin::Call<0x5684A0>();</p>
<p>0AA5: call_function 0x5684A0 num_params 0 pop 0</p>
<p>define function CWorld__Process&lt;cdecl, 0x5684A0&gt;()</p>
<h4>CWorld::GetIsLineOfSightSectorClear</h4>
<p>plugin::CallAndReturn<bool, 0x568AD0, CSector&, CRepeatSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, repeatSector, colLine, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doIgnoreCameraCheck);</p>
<p>0AA7: call_function_return 0x568AD0 num_params 10 pop 10 [sector] [repeatSector] [colLine] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doIgnoreCameraCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightSectorClear&lt;cdecl, 0x568AD0&gt;(sector, repeatSector, colLine, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doIgnoreCameraCheck): int</p>
<h4>CWorld::FindObjectsKindaColliding</h4>
<p>plugin::Call<0x568B80, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x568B80 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsKindaColliding&lt;cdecl, 0x568B80&gt;(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsIntersectingCube</h4>
<p>plugin::Call<0x568DD0, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x568DD0 num_params 10 pop 10 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsIntersectingCube&lt;cdecl, 0x568DD0&gt;(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsIntersectingAngledCollisionBox</h4>
<p>plugin::Call<0x568FF0, CBox const&, CMatrix const&, CVector const&, float, float, float, float, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x568FF0 num_params 15 pop 15 [box] [transform] [point] [x1] [y1] [x2] [y2] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsIntersectingAngledCollisionBox&lt;cdecl, 0x568FF0&gt;(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindMissionEntitiesIntersectingCube</h4>
<p>plugin::Call<0x569240, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);</p>
<p>0AA5: call_function 0x569240 num_params 8 pop 8 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehicles] [peds] [objects]</p>
<p>define function CWorld__FindMissionEntitiesIntersectingCube&lt;cdecl, 0x569240&gt;(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects)</p>
<h4>CWorld::FindNearestObjectOfType</h4>
<p>plugin::Call<0x5693F0, int, CVector const&, float, bool, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x5693F0 num_params 9 pop 9 [modelId] [point] [radius] [b2D] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindNearestObjectOfType&lt;cdecl, 0x5693F0&gt;(modelId, point, radius, b2D, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindGroundZForCoord</h4>
<p>plugin::CallAndReturn<float, 0x569660, float, float>(x, y);</p>
<p>0AA7: call_function_return 0x569660 num_params 2 pop 2 [x] [y] func_ret [float]</p>
<p>define function CWorld__FindGroundZForCoord&lt;cdecl, 0x569660&gt;(x, y): float</p>
<h4>CWorld::FindGroundZFor3DCoord</h4>
<p>plugin::CallAndReturn<float, 0x5696C0, float, float, float, bool<em>, CEntity</em>*>(x, y, z, outResult, outEntity);</p>
<p>0AA7: call_function_return 0x5696C0 num_params 5 pop 5 [x] [y] [z] [outResult] [outEntity] func_ret [float]</p>
<p>define function CWorld__FindGroundZFor3DCoord&lt;cdecl, 0x5696C0&gt;(x, y, z, outResult, outEntity): float</p>
<h4>CWorld::FindRoofZFor3DCoord</h4>
<p>plugin::CallAndReturn<float, 0x569750, float, float, float, bool*>(x, y, z, outResult);</p>
<p>0AA7: call_function_return 0x569750 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]</p>
<p>define function CWorld__FindRoofZFor3DCoord&lt;cdecl, 0x569750&gt;(x, y, z, outResult): float</p>
<h4>CWorld::FindLowestZForCoord</h4>
<p>plugin::CallAndReturn<float, 0x5697F0, float, float>(x, y);</p>
<p>0AA7: call_function_return 0x5697F0 num_params 2 pop 2 [x] [y] func_ret [float]</p>
<p>define function CWorld__FindLowestZForCoord&lt;cdecl, 0x5697F0&gt;(x, y): float</p>
<h4>CWorld::RepositionOneObject</h4>
<p>plugin::Call<0x569850, CEntity*>(object);</p>
<p>0AA5: call_function 0x569850 num_params 1 pop 1 [object]</p>
<p>define function CWorld__RepositionOneObject&lt;cdecl, 0x569850&gt;(object)</p>
<h4>CWorld::TestSphereAgainstWorld</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x569E20, CVector, float, CEntity</em>, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, arg2, buildings, vehicles, peds, objects, dummies, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x569E20 num_params 9 pop 9 [sphereCenter] [sphereRadius] [arg2] [buildings] [vehicles] [peds] [objects] [dummies] [doCameraIgnoreCheck] func_ret [CEntity*]</p>
<p>define function CWorld__TestSphereAgainstWorld&lt;cdecl, 0x569E20&gt;(sphereCenter, sphereRadius, arg2, buildings, vehicles, peds, objects, dummies, doCameraIgnoreCheck): int</p>
<h4>CWorld::ClearExcitingStuffFromArea</h4>
<p>plugin::Call<0x56A0D0, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);</p>
<p>0AA5: call_function 0x56A0D0 num_params 3 pop 3 [point] [radius] [bRemoveProjectilesAndShadows]</p>
<p>define function CWorld__ClearExcitingStuffFromArea&lt;cdecl, 0x56A0D0&gt;(point, radius, bRemoveProjectilesAndShadows)</p>
<h4>CWorld::GetIsLineOfSightClear</h4>
<p>plugin::CallAndReturn<bool, 0x56A490, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x56A490 num_params 9 pop 9 [origin] [target] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightClear&lt;cdecl, 0x56A490&gt;(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::ProcessLineOfSightSector</h4>
<p>plugin::CallAndReturn<bool, 0x56B5E0, CSector&, CRepeatSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(sector, repeatSector, colLine, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x56B5E0 num_params 14 pop 14 [sector] [repeatSector] [colLine] [outColPoint] [maxTouchDistance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSightSector&lt;cdecl, 0x56B5E0&gt;(sector, repeatSector, colLine, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck): int</p>
<h4>CWorld::TriggerExplosion</h4>
<p>plugin::Call<0x56B790, CVector const&, float, float, CEntity<em>, CEntity</em>, bool, float>(point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage);</p>
<p>0AA5: call_function 0x56B790 num_params 7 pop 7 [point] [radius] [visibleDistance] [victim] [creator] [processVehicleBombTimer] [damage]</p>
<p>define function CWorld__TriggerExplosion&lt;cdecl, 0x56B790&gt;(point, radius, visibleDistance, victim, creator, processVehicleBombTimer, damage)</p>
<h4>CWorld::SetWorldOnFire</h4>
<p>plugin::Call<0x56B910, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);</p>
<p>0AA5: call_function 0x56B910 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]</p>
<p>define function CWorld__SetWorldOnFire&lt;cdecl, 0x56B910&gt;(x, y, z, radius, fireCreator)</p>
<h4>CWorld::RepositionCertainDynamicObjects</h4>
<p>plugin::Call<0x56B9C0>();</p>
<p>0AA5: call_function 0x56B9C0 num_params 0 pop 0</p>
<p>define function CWorld__RepositionCertainDynamicObjects&lt;cdecl, 0x56B9C0&gt;()</p>
<h4>CWorld::ProcessLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x56BA00, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x56BA00 num_params 12 pop 12 [origin] [target] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSight&lt;cdecl, 0x56BA00&gt;(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck): int</p>
<h4>GetCurrentScanCode</h4>
<p>plugin::CallAndReturn<short, 0x407250>();</p>
<p>0AA7: call_function_return 0x407250 num_params 0 pop 0 func_ret [short]</p>
<p>define function GetCurrentScanCode&lt;cdecl, 0x407250&gt;(): int</p>
<h4>GetSector</h4>
<p>plugin::CallAndReturn<CSector*, 0x407260, int, int>(x, y);</p>
<p>0AA7: call_function_return 0x407260 num_params 2 pop 2 [x] [y] func_ret [CSector*]</p>
<p>define function GetSector&lt;cdecl, 0x407260&gt;(x, y): int</p>
<h4>GetRepeatSector</h4>
<p>plugin::CallAndReturn<CRepeatSector*, 0x4072A0, int, int>(x, y);</p>
<p>0AA7: call_function_return 0x4072A0 num_params 2 pop 2 [x] [y] func_ret [CRepeatSector*]</p>
<p>define function GetRepeatSector&lt;cdecl, 0x4072A0&gt;(x, y): int</p>
<h4>GetLodPtrList</h4>
<p>plugin::CallAndReturn<CPtrListSingleLink*, 0x4072C0, int, int>(x, y);</p>
<p>0AA7: call_function_return 0x4072C0 num_params 2 pop 2 [x] [y] func_ret [CPtrListSingleLink*]</p>
<p>define function GetLodPtrList&lt;cdecl, 0x4072C0&gt;(x, y): int</p>
<h4>SetNextScanCode</h4>
<p>plugin::Call<0x4072E0>();</p>
<p>0AA5: call_function 0x4072E0 num_params 0 pop 0</p>
<p>define function SetNextScanCode&lt;cdecl, 0x4072E0&gt;()</p><h3 id="plugin_sagame_sad3dindexdatabuffercpp">plugin_sa\game_sa\D3DIndexDataBuffer.cpp</h3><h4>D3DIndexDataBuffer::Clear</h4>
<p>plugin::CallMethod<0x7301D0, D3DIndexDataBuffer *>(this);</p>
<p>0AA6: call_method 0x7301D0 struct [D3DIndexDataBuffer] num_params 0 pop 0</p>
<p>define function D3DIndexDataBuffer__Clear&lt;thiscall, 0x7301D0&gt;()</p>
<h4>D3DIndexDataBuffer::Destroy</h4>
<p>plugin::CallMethod<0x730200, D3DIndexDataBuffer *>(this);</p>
<p>0AA6: call_method 0x730200 struct [D3DIndexDataBuffer] num_params 0 pop 0</p>
<p>define function D3DIndexDataBuffer__Destroy&lt;thiscall, 0x730200&gt;()</p>
<h4>D3DIndexDataBuffer::GetTotalDataSize</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x7303B0, D3DIndexDataBuffer *>(this);</p>
<p>0AA8: call_method_return 0x7303B0 struct [D3DIndexDataBuffer] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function D3DIndexDataBuffer__GetTotalDataSize&lt;thiscall, 0x7303B0&gt;(): int</p>
<h4>D3DIndexDataBuffer::Resize</h4>
<p>plugin::CallMethod<0x730330, D3DIndexDataBuffer *, unsigned int>(this, newCapacity);</p>
<p>0AA6: call_method 0x730330 struct [D3DIndexDataBuffer] num_params 1 pop 0 [newCapacity]</p>
<p>define function D3DIndexDataBuffer__Resize&lt;thiscall, 0x730330&gt;(newCapacity)</p>
<h4>D3DIndexDataBuffer::Setup</h4>
<p>plugin::CallMethod<0x730190, D3DIndexDataBuffer *, unsigned int, int, unsigned int>(this, format, _f4, capacity);</p>
<p>0AA6: call_method 0x730190 struct [D3DIndexDataBuffer] num_params 3 pop 0 [format] [_f4] [capacity]</p>
<p>define function D3DIndexDataBuffer__Setup&lt;thiscall, 0x730190&gt;(format, _f4, capacity)</p>
<h4>D3DIndexDataBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<IDirect3DIndexBuffer9*, 0x730250, D3DIndexDataBuffer *>(this);</p>
<p>0AA8: call_method_return 0x730250 struct [D3DIndexDataBuffer] num_params 0 pop 0 func_ret [IDirect3DIndexBuffer9*]</p>
<p>define function D3DIndexDataBuffer__Pop&lt;thiscall, 0x730250&gt;(): int</p>
<h4>D3DIndexDataBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<IDirect3DIndexBuffer9*, 0x730270, D3DIndexDataBuffer *, unsigned int>(this, indexCount);</p>
<p>0AA8: call_method_return 0x730270 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexCount] func_ret [IDirect3DIndexBuffer9*]</p>
<p>define function D3DIndexDataBuffer__Pop&lt;thiscall, 0x730270&gt;(indexCount): int</p>
<h4>D3DIndexDataBuffer::Push</h4>
<p>plugin::CallMethodAndReturn<bool, 0x730300, D3DIndexDataBuffer <em>, IDirect3DIndexBuffer9</em>>(this, indexBuffer);</p>
<p>0AA8: call_method_return 0x730300 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]</p>
<p>define function D3DIndexDataBuffer__Push&lt;thiscall, 0x730300&gt;(indexBuffer): int</p>
<h4>D3DIndexDataBuffer::PushWithoutIncreasingCounter</h4>
<p>plugin::CallMethodAndReturn<bool, 0x730B00, D3DIndexDataBuffer <em>, IDirect3DIndexBuffer9</em>>(this, indexBuffer);</p>
<p>0AA8: call_method_return 0x730B00 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]</p>
<p>define function D3DIndexDataBuffer__PushWithoutIncreasingCounter&lt;thiscall, 0x730B00&gt;(indexBuffer): int</p>
<h4>D3DIndexDataBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<void*, 0x730250, D3DIndexDataBuffer *>(this);</p>
<p>0AA8: call_method_return 0x730250 struct [D3DIndexDataBuffer] num_params 0 pop 0 func_ret [void*]</p>
<p>define function D3DIndexDataBuffer__Pop&lt;thiscall, 0x730250&gt;(): int</p>
<h4>D3DIndexDataBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<void*, 0x730270, D3DIndexDataBuffer *, unsigned int>(this, indexCount);</p>
<p>0AA8: call_method_return 0x730270 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexCount] func_ret [void*]</p>
<p>define function D3DIndexDataBuffer__Pop&lt;thiscall, 0x730270&gt;(indexCount): int</p>
<h4>D3DIndexDataBuffer::Push</h4>
<p>plugin::CallMethodAndReturn<bool, 0x730300, D3DIndexDataBuffer <em>, void</em>>(this, indexBuffer);</p>
<p>0AA8: call_method_return 0x730300 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]</p>
<p>define function D3DIndexDataBuffer__Push&lt;thiscall, 0x730300&gt;(indexBuffer): int</p>
<h4>D3DIndexDataBuffer::PushWithoutIncreasingCounter</h4>
<p>plugin::CallMethodAndReturn<bool, 0x730B00, D3DIndexDataBuffer <em>, void</em>>(this, indexBuffer);</p>
<p>0AA8: call_method_return 0x730B00 struct [D3DIndexDataBuffer] num_params 1 pop 0 [indexBuffer] func_ret [bool]</p>
<p>define function D3DIndexDataBuffer__PushWithoutIncreasingCounter&lt;thiscall, 0x730B00&gt;(indexBuffer): int</p><h3 id="plugin_sagame_sad3dresourcesystemcpp">plugin_sa\game_sa\D3DResourceSystem.cpp</h3><h4>D3DResourceSystem::CancelBuffering</h4>
<p>plugin::Call<0x730900>();</p>
<p>0AA5: call_function 0x730900 num_params 0 pop 0</p>
<p>define function D3DResourceSystem__CancelBuffering&lt;cdecl, 0x730900&gt;()</p>
<h4>D3DResourceSystem::GetTotalIndexDataSize</h4>
<p>plugin::CallAndReturn<unsigned int, 0x7307F0>();</p>
<p>0AA7: call_function_return 0x7307F0 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function D3DResourceSystem__GetTotalIndexDataSize&lt;cdecl, 0x7307F0&gt;(): int</p>
<h4>D3DResourceSystem::GetTotalPixelsSize</h4>
<p>plugin::CallAndReturn<unsigned int, 0x730660>();</p>
<p>0AA7: call_function_return 0x730660 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function D3DResourceSystem__GetTotalPixelsSize&lt;cdecl, 0x730660&gt;(): int</p>
<h4>D3DResourceSystem::Init</h4>
<p>plugin::Call<0x730830>();</p>
<p>0AA5: call_function 0x730830 num_params 0 pop 0</p>
<p>define function D3DResourceSystem__Init&lt;cdecl, 0x730830&gt;()</p>
<h4>D3DResourceSystem::SetUseD3DResourceBuffering</h4>
<p>plugin::Call<0x730AC0, bool>(bUse);</p>
<p>0AA5: call_function 0x730AC0 num_params 1 pop 1 [bUse]</p>
<p>define function D3DResourceSystem__SetUseD3DResourceBuffering&lt;cdecl, 0x730AC0&gt;(bUse)</p>
<h4>D3DResourceSystem::Shutdown</h4>
<p>plugin::Call<0x730A00>();</p>
<p>0AA5: call_function 0x730A00 num_params 0 pop 0</p>
<p>define function D3DResourceSystem__Shutdown&lt;cdecl, 0x730A00&gt;()</p>
<h4>D3DResourceSystem::TidyUpD3DIndexBuffers</h4>
<p>plugin::Call<0x730740, unsigned int>(count);</p>
<p>0AA5: call_function 0x730740 num_params 1 pop 1 [count]</p>
<p>define function D3DResourceSystem__TidyUpD3DIndexBuffers&lt;cdecl, 0x730740&gt;(count)</p>
<h4>D3DResourceSystem::TidyUpD3DTextures</h4>
<p>plugin::Call<0x7305E0, unsigned int>(count);</p>
<p>0AA5: call_function 0x7305E0 num_params 1 pop 1 [count]</p>
<p>define function D3DResourceSystem__TidyUpD3DTextures&lt;cdecl, 0x7305E0&gt;(count)</p>
<h4>D3DResourceSystem::CreateIndexBuffer</h4>
<p>plugin::CallAndReturn<HRESULT, 0x7306A0, unsigned int, unsigned int, IDirect3DIndexBuffer9**>(numIndices, format, ppIndexBuffer);</p>
<p>0AA7: call_function_return 0x7306A0 num_params 3 pop 3 [numIndices] [format] [ppIndexBuffer] func_ret [HRESULT]</p>
<p>define function D3DResourceSystem__CreateIndexBuffer&lt;cdecl, 0x7306A0&gt;(numIndices, format, ppIndexBuffer): int</p>
<h4>D3DResourceSystem::CreateTexture</h4>
<p>plugin::CallAndReturn<HRESULT, 0x730510, int, int, unsigned int, IDirect3DTexture9**>(width, height, format, ppTexture);</p>
<p>0AA7: call_function_return 0x730510 num_params 4 pop 4 [width] [height] [format] [ppTexture] func_ret [HRESULT]</p>
<p>define function D3DResourceSystem__CreateTexture&lt;cdecl, 0x730510&gt;(width, height, format, ppTexture): int</p>
<h4>D3DResourceSystem::DestroyIndexBuffer</h4>
<p>plugin::Call<0x730D30, IDirect3DIndexBuffer9*>(pIndexBuffer);</p>
<p>0AA5: call_function 0x730D30 num_params 1 pop 1 [pIndexBuffer]</p>
<p>define function D3DResourceSystem__DestroyIndexBuffer&lt;cdecl, 0x730D30&gt;(pIndexBuffer)</p>
<h4>D3DResourceSystem::DestroyTexture</h4>
<p>plugin::Call<0x730B70, IDirect3DTexture9*>(pTexture);</p>
<p>0AA5: call_function 0x730B70 num_params 1 pop 1 [pTexture]</p>
<p>define function D3DResourceSystem__DestroyTexture&lt;cdecl, 0x730B70&gt;(pTexture)</p>
<h4>D3DResourceSystem::CreateIndexBuffer</h4>
<p>plugin::CallAndReturn<int, 0x7306A0, unsigned int, unsigned int, void**>(numIndices, format, ppIndexBuffer);</p>
<p>0AA7: call_function_return 0x7306A0 num_params 3 pop 3 [numIndices] [format] [ppIndexBuffer] func_ret [int]</p>
<p>define function D3DResourceSystem__CreateIndexBuffer&lt;cdecl, 0x7306A0&gt;(numIndices, format, ppIndexBuffer): int</p>
<h4>D3DResourceSystem::CreateTexture</h4>
<p>plugin::CallAndReturn<int, 0x730510, int, int, unsigned int, void**>(width, height, format, ppTexture);</p>
<p>0AA7: call_function_return 0x730510 num_params 4 pop 4 [width] [height] [format] [ppTexture] func_ret [int]</p>
<p>define function D3DResourceSystem__CreateTexture&lt;cdecl, 0x730510&gt;(width, height, format, ppTexture): int</p>
<h4>D3DResourceSystem::DestroyIndexBuffer</h4>
<p>plugin::Call<0x730D30, void*>(pIndexBuffer);</p>
<p>0AA5: call_function 0x730D30 num_params 1 pop 1 [pIndexBuffer]</p>
<p>define function D3DResourceSystem__DestroyIndexBuffer&lt;cdecl, 0x730D30&gt;(pIndexBuffer)</p>
<h4>D3DResourceSystem::DestroyTexture</h4>
<p>plugin::Call<0x730B70, void*>(pTexture);</p>
<p>0AA5: call_function 0x730B70 num_params 1 pop 1 [pTexture]</p>
<p>define function D3DResourceSystem__DestroyTexture&lt;cdecl, 0x730B70&gt;(pTexture)</p><h3 id="plugin_sagame_sad3dtexturebuffercpp">plugin_sa\game_sa\D3DTextureBuffer.cpp</h3><h4>D3DTextureBuffer::Clear</h4>
<p>plugin::CallMethod<0x72FEC0, D3DTextureBuffer *>(this);</p>
<p>0AA6: call_method 0x72FEC0 struct [D3DTextureBuffer] num_params 0 pop 0</p>
<p>define function D3DTextureBuffer__Clear&lt;thiscall, 0x72FEC0&gt;()</p>
<h4>D3DTextureBuffer::Destroy</h4>
<p>plugin::CallMethod<0x72FEF0, D3DTextureBuffer *>(this);</p>
<p>0AA6: call_method 0x72FEF0 struct [D3DTextureBuffer] num_params 0 pop 0</p>
<p>define function D3DTextureBuffer__Destroy&lt;thiscall, 0x72FEF0&gt;()</p>
<h4>D3DTextureBuffer::GetTotalDataSize</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x7300A0, D3DTextureBuffer *>(this);</p>
<p>0AA8: call_method_return 0x7300A0 struct [D3DTextureBuffer] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function D3DTextureBuffer__GetTotalDataSize&lt;thiscall, 0x7300A0&gt;(): int</p>
<h4>D3DTextureBuffer::Resize</h4>
<p>plugin::CallMethod<0x730020, D3DTextureBuffer *, unsigned int>(this, newCapacity);</p>
<p>0AA6: call_method 0x730020 struct [D3DTextureBuffer] num_params 1 pop 0 [newCapacity]</p>
<p>define function D3DTextureBuffer__Resize&lt;thiscall, 0x730020&gt;(newCapacity)</p>
<h4>D3DTextureBuffer::Setup</h4>
<p>plugin::CallMethod<0x72FE80, D3DTextureBuffer *, unsigned int, int, int, unsigned int>(this, format, width, bOneLevel, capacity);</p>
<p>0AA6: call_method 0x72FE80 struct [D3DTextureBuffer] num_params 4 pop 0 [format] [width] [bOneLevel] [capacity]</p>
<p>define function D3DTextureBuffer__Setup&lt;thiscall, 0x72FE80&gt;(format, width, bOneLevel, capacity)</p>
<h4>D3DTextureBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<IDirect3DTexture9*, 0x72FF40, D3DTextureBuffer *>(this);</p>
<p>0AA8: call_method_return 0x72FF40 struct [D3DTextureBuffer] num_params 0 pop 0 func_ret [IDirect3DTexture9*]</p>
<p>define function D3DTextureBuffer__Pop&lt;thiscall, 0x72FF40&gt;(): int</p>
<h4>D3DTextureBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<IDirect3DTexture9*, 0x72FF60, D3DTextureBuffer *, unsigned int, int, int, int>(this, format, width, height, bOneLevel);</p>
<p>0AA8: call_method_return 0x72FF60 struct [D3DTextureBuffer] num_params 4 pop 0 [format] [width] [height] [bOneLevel] func_ret [IDirect3DTexture9*]</p>
<p>define function D3DTextureBuffer__Pop&lt;thiscall, 0x72FF60&gt;(format, width, height, bOneLevel): int</p>
<h4>D3DTextureBuffer::Push</h4>
<p>plugin::CallMethodAndReturn<bool, 0x72FFF0, D3DTextureBuffer <em>, IDirect3DTexture9</em>>(this, texture);</p>
<p>0AA8: call_method_return 0x72FFF0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]</p>
<p>define function D3DTextureBuffer__Push&lt;thiscall, 0x72FFF0&gt;(texture): int</p>
<h4>D3DTextureBuffer::PushWithoutIncreasingCounter</h4>
<p>plugin::CallMethodAndReturn<bool, 0x730AD0, D3DTextureBuffer <em>, IDirect3DTexture9</em>>(this, texture);</p>
<p>0AA8: call_method_return 0x730AD0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]</p>
<p>define function D3DTextureBuffer__PushWithoutIncreasingCounter&lt;thiscall, 0x730AD0&gt;(texture): int</p>
<h4>D3DTextureBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<void*, 0x72FF40, D3DTextureBuffer *>(this);</p>
<p>0AA8: call_method_return 0x72FF40 struct [D3DTextureBuffer] num_params 0 pop 0 func_ret [void*]</p>
<p>define function D3DTextureBuffer__Pop&lt;thiscall, 0x72FF40&gt;(): int</p>
<h4>D3DTextureBuffer::Pop</h4>
<p>plugin::CallMethodAndReturn<void*, 0x72FF60, D3DTextureBuffer *, unsigned int, int, int, int>(this, format, width, height, bOneLevel);</p>
<p>0AA8: call_method_return 0x72FF60 struct [D3DTextureBuffer] num_params 4 pop 0 [format] [width] [height] [bOneLevel] func_ret [void*]</p>
<p>define function D3DTextureBuffer__Pop&lt;thiscall, 0x72FF60&gt;(format, width, height, bOneLevel): int</p>
<h4>D3DTextureBuffer::Push</h4>
<p>plugin::CallMethodAndReturn<bool, 0x72FFF0, D3DTextureBuffer <em>, void</em>>(this, texture);</p>
<p>0AA8: call_method_return 0x72FFF0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]</p>
<p>define function D3DTextureBuffer__Push&lt;thiscall, 0x72FFF0&gt;(texture): int</p>
<h4>D3DTextureBuffer::PushWithoutIncreasingCounter</h4>
<p>plugin::CallMethodAndReturn<bool, 0x730AD0, D3DTextureBuffer <em>, void</em>>(this, texture);</p>
<p>0AA8: call_method_return 0x730AD0 struct [D3DTextureBuffer] num_params 1 pop 0 [texture] func_ret [bool]</p>
<p>define function D3DTextureBuffer__PushWithoutIncreasingCounter&lt;thiscall, 0x730AD0&gt;(texture): int</p><h3 id="plugin_sagame_sajpegcompresscpp">plugin_sa\game_sa\JPegCompress.cpp</h3><h4>assert</h4>
<p>plugin::Call<0x005D0820>(pCamera, pszPath);</p>
<p>0AA5: call_function 0x005D0820 num_params 2 pop 2 [pCamera] [pszPath]</p>
<p>define function assert&lt;cdecl, 0x005D0820&gt;(pCamera, pszPath)</p>
<h4>assert</h4>
<p>plugin::Call<0x005D0740>(pCamera, pBuffer, pSize);</p>
<p>0AA5: call_function 0x005D0740 num_params 3 pop 3 [pCamera] [pBuffer] [pSize]</p>
<p>define function assert&lt;cdecl, 0x005D0740&gt;(pCamera, pBuffer, pSize)</p>
<h4>assert</h4>
<p>plugin::CallAndReturn<RwBool, 0x005D07A0>(pRaster, pBuffer);</p>
<p>0AA7: call_function_return 0x005D07A0 num_params 2 pop 2 [pRaster] [pBuffer] func_ret [RwBool]</p>
<p>define function assert&lt;cdecl, 0x005D07A0&gt;(pRaster, pBuffer): int</p><h3 id="plugin_sagame_salist_ccpp">plugin_sa\game_sa\List_c.cpp</h3><h4>List_c::List_c</h4>
<p>plugin::CallMethod<0x004A8DD0>(this);</p>
<p>0AA6: call_method 0x004A8DD0 struct [List_c] num_params 0 pop 0</p>
<p>define function List_c__List_c&lt;thiscall, 0x004A8DD0&gt;()</p>
<h4>List_c::~List_c</h4>
<p>plugin::CallMethod<0x004A8DE0>(this);</p>
<p>0AA6: call_method 0x004A8DE0 struct [List_c] num_params 0 pop 0</p>
<p>define function List_c__~List_c&lt;thiscall, 0x004A8DE0&gt;()</p>
<h4>assert</h4>
<p>plugin::CallMethod<0x004A8DF0, List_c *, ListItem_c *>(this, pItem);</p>
<h4>assert</h4>
<p>plugin::CallMethod<0x004A8E30, List_c *, ListItem_c *>(this, pItem);</p>
<h4>List_c::RemoveHead</h4>
<p>plugin::CallMethodAndReturn<ListItem_c *, 0x004A8E70, List_c *>(this);</p>
<p>0AA8: call_method_return 0x004A8E70 struct [List_c] num_params 0 pop 0 func_ret [ListItem_c *]</p>
<p>define function List_c__RemoveHead&lt;thiscall, 0x004A8E70&gt;(): int</p>
<h4>assert</h4>
<p>plugin::CallMethodAndReturn<ListItem_c *, 0x004A9000, List_c *, ListItem_c *>(this, pItem);</p>
<h4>List_c::GetItemOffset</h4>
<p>plugin::CallMethodAndReturn<ListItem_c *, 0x004A9010, List_c *, bool, int>(this, bFromHead, iOffset);</p>
<p>0AA8: call_method_return 0x004A9010 struct [List_c] num_params 2 pop 0 [bFromHead] [iOffset] func_ret [ListItem_c *]</p>
<p>define function List_c__GetItemOffset&lt;thiscall, 0x004A9010&gt;(bFromHead, iOffset): int</p><h3 id="plugin_sagame_salistitem_ccpp">plugin_sa\game_sa\ListItem_c.cpp</h3><h4>ListItem_c::ListItem_c</h4>
<p>plugin::CallMethod<0x004A8DB0>(this);</p>
<p>0AA6: call_method 0x004A8DB0 struct [ListItem_c] num_params 0 pop 0</p>
<p>define function ListItem_c__ListItem_c&lt;thiscall, 0x004A8DB0&gt;()</p>
<h4>ListItem_c::~ListItem_c</h4>
<p>plugin::CallMethod<0x004A8DC0>(this);</p>
<p>0AA6: call_method 0x004A8DC0 struct [ListItem_c] num_params 0 pop 0</p>
<p>define function ListItem_c__~ListItem_c&lt;thiscall, 0x004A8DC0&gt;()</p><h3 id="plugin_sagame_sapipelineplugincpp">plugin_sa\game_sa\PipelinePlugin.cpp</h3><h4>PipelinePluginAttach</h4>
<p>plugin::CallAndReturn<RwBool, 0x0072FBD0>();</p>
<p>0AA7: call_function_return 0x0072FBD0 num_params 0 pop 0 func_ret [RwBool]</p>
<p>define function PipelinePluginAttach&lt;cdecl, 0x0072FBD0&gt;(): int</p>
<h4>assert</h4>
<p>plugin::CallAndReturn<RwUInt32, 0x0072FC40>(pAtomic);</p>
<p>0AA7: call_function_return 0x0072FC40 num_params 1 pop 1 [pAtomic] func_ret [RwUInt32]</p>
<p>define function assert&lt;cdecl, 0x0072FC40&gt;(pAtomic): int</p>
<h4>assert</h4>
<p>plugin::Call<0x0072FC50>(pAtomic, uPipelineID);</p>
<p>0AA5: call_function 0x0072FC50 num_params 2 pop 2 [pAtomic] [uPipelineID]</p>
<p>define function assert&lt;cdecl, 0x0072FC50&gt;(pAtomic, uPipelineID)</p><h3 id="plugin_sagame_sarenderwarecpp">plugin_sa\game_sa\RenderWare.cpp</h3><h4>RsEventHandler</h4>
<p>plugin::CallAndReturn<RsEventStatus, 0x619B60, RsEvent, void*>(e, param);</p>
<p>0AA7: call_function_return 0x619B60 num_params 2 pop 2 [e] [param] func_ret [RsEventStatus]</p>
<p>define function RsEventHandler&lt;cdecl, 0x619B60&gt;(e, param): int</p>
<h4>_rwObjectHasFrameSetFrame</h4>
<p>plugin::Call<0x804EF0, void *, RwFrame *>(object, frame);</p>
<p>0AA5: call_function 0x804EF0 num_params 2 pop 2 [object] [frame]</p>
<p>define function _rwObjectHasFrameSetFrame&lt;cdecl, 0x804EF0&gt;(object, frame)</p>
<h4>_rwObjectHasFrameReleaseFrame</h4>
<p>plugin::Call<0x804F40, void *>(object);</p>
<p>0AA5: call_function 0x804F40 num_params 1 pop 1 [object]</p>
<p>define function _rwObjectHasFrameReleaseFrame&lt;cdecl, 0x804F40&gt;(object)</p>
<h4>*_rpD3D9SkinVertexShaderMatrixUpdate</h4>
<p>plugin::CallAndReturn<RpAtomic *, 0x7C78A0, RwMatrix *, RpAtomic *, RpSkin *>(matrices, atomic, skin);</p>
<p>0AA7: call_function_return 0x7C78A0 num_params 3 pop 3 [matrices] [atomic] [skin] func_ret [RpAtomic *]</p>
<p>define function _rpD3D9SkinVertexShaderMatrixUpdate&lt;cdecl, 0x7C78A0&gt;(matrices, atomic, skin): int</p>
<h4>_rwD3D9SetStreams</h4>
<p>plugin::Call<0x7FA090, RxD3D9VertexStream *, RwBool>(streams, useOffsets);</p>
<p>0AA5: call_function 0x7FA090 num_params 2 pop 2 [streams] [useOffsets]</p>
<p>define function _rwD3D9SetStreams&lt;cdecl, 0x7FA090&gt;(streams, useOffsets)</p>
<h4>_rwD3D9RenderStateVertexAlphaEnable</h4>
<p>plugin::CallAndReturn<RwBool, 0x7FE0A0, RwBool>(enable);</p>
<p>0AA7: call_function_return 0x7FE0A0 num_params 1 pop 1 [enable] func_ret [RwBool]</p>
<p>define function _rwD3D9RenderStateVertexAlphaEnable&lt;cdecl, 0x7FE0A0&gt;(enable): int</p>
<h4>_rwD3D9RenderStateIsVertexAlphaEnable</h4>
<p>plugin::CallAndReturn<RwBool, 0x7FE190>();</p>
<p>0AA7: call_function_return 0x7FE190 num_params 0 pop 0 func_ret [RwBool]</p>
<p>define function _rwD3D9RenderStateIsVertexAlphaEnable&lt;cdecl, 0x7FE190&gt;(): int</p>
<h4>_rwD3D9CheckValidCameraTextureFormat</h4>
<p>plugin::CallAndReturn<RwBool, 0x4CBE20, RwUInt32>(format);</p>
<p>0AA7: call_function_return 0x4CBE20 num_params 1 pop 1 [format] func_ret [RwBool]</p>
<p>define function _rwD3D9CheckValidCameraTextureFormat&lt;cdecl, 0x4CBE20&gt;(format): int</p>
<h4>_rwD3D9SetVertexDeclaration</h4>
<p>plugin::Call<0x7F9F70, void *>(vertexDeclaration);</p>
<p>0AA5: call_function 0x7F9F70 num_params 1 pop 1 [vertexDeclaration]</p>
<p>define function _rwD3D9SetVertexDeclaration&lt;cdecl, 0x7F9F70&gt;(vertexDeclaration)</p>
<h4>_rwD3D9SetIndices</h4>
<p>plugin::Call<0x7FA1C0, void *>(indices);</p>
<p>0AA5: call_function 0x7FA1C0 num_params 1 pop 1 [indices]</p>
<p>define function _rwD3D9SetIndices&lt;cdecl, 0x7FA1C0&gt;(indices)</p>
<h4>_rwD3D9DrawPrimitive</h4>
<p>plugin::Call<0x7FA360, RwUInt32, RwUInt32, RwUInt32>(primitiveType, startIndex, primitiveCount);</p>
<p>0AA5: call_function 0x7FA360 num_params 3 pop 3 [primitiveType] [startIndex] [primitiveCount]</p>
<p>define function _rwD3D9DrawPrimitive&lt;cdecl, 0x7FA360&gt;(primitiveType, startIndex, primitiveCount)</p>
<h4>_rwStreamReadChunkHeader</h4>
<p>plugin::CallAndReturn<RwBool, 0x7ED0F0, RwStream *, RwUInt32 *, RwUInt32 *, RwUInt32 *, RwUInt32 *>(stream, pType, pLength, pVersion, pBuild);</p>
<p>0AA7: call_function_return 0x7ED0F0 num_params 5 pop 5 [stream] [pType] [pLength] [pVersion] [pBuild] func_ret [RwBool]</p>
<p>define function _rwStreamReadChunkHeader&lt;cdecl, 0x7ED0F0&gt;(stream, pType, pLength, pVersion, pBuild): int</p><h3 id="plugin_sagame_sametametacanimblendassociationh">plugin_sa\game_sa\meta\meta.CAnimBlendAssociation.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendHierarchy &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendHierarchy &amp;)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), rhs);</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendAssociation, void(RpClump *, CAnimBlendHierarchy *)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), clump, hier);</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &amp;)), reinterpret_cast<CAnimBlendAssociation *>(objBuff), rhs);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(dtor_gaddr(CAnimBlendAssociation), reinterpret_cast<CAnimBlendAssociation *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *>(ctor_gaddr(CAnimBlendAssociation), &amp;objArray[i]);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendHierarchy &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendHierarchy &amp;)), obj, rhs);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendAssociation, void(RpClump *, CAnimBlendHierarchy *)), obj, clump, hier);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendAssociation *, CAnimBlendAssociation &>(ctor_gaddr_o(CAnimBlendAssociation, void(CAnimBlendAssociation &amp;)), obj, rhs);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendAssociation *, unsigned char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendAssociation *, unsigned char>(&amp;objArray[i], 1);</p><h3 id="plugin_sagame_sametametacanimblendstaticassociationh">plugin_sa\game_sa\meta\meta.CAnimBlendStaticAssociation.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff));</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendStaticAssociation, void(RpClump *, CAnimBlendHierarchy *)), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff), clump, hierarchy);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(dtor_gaddr(CAnimBlendStaticAssociation), reinterpret_cast<CAnimBlendStaticAssociation *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *>(ctor_gaddr(CAnimBlendStaticAssociation), &amp;objArray[i]);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CAnimBlendStaticAssociation *, RpClump *, CAnimBlendHierarchy *>(ctor_gaddr_o(CAnimBlendStaticAssociation, void(RpClump *, CAnimBlendHierarchy *)), obj, clump, hierarchy);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendStaticAssociation *, unsigned char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendStaticAssociation *, unsigned char>(objArray, 3);</p><h3 id="plugin_sagame_sametametaccamerah">plugin_sa\game_sa\meta\meta.CCamera.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(dtor_gaddr(CCamera), reinterpret_cast<CCamera *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCamera *>(ctor_gaddr(CCamera), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CCamera *, char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<0, CCamera *, char>(&amp;objArray[i], 1);</p><h3 id="plugin_sagame_sametametacentryexith">plugin_sa\game_sa\meta\meta.CEntryExit.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), reinterpret_cast<CEntryExit *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CEntryExit *>(ctor_gaddr(CEntryExit), &amp;objArray[i]);</p><h3 id="plugin_sagame_sametametacganginfoh">plugin_sa\game_sa\meta\meta.CGangInfo.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), reinterpret_cast<CGangInfo *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(ctor_gaddr(CGangInfo), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CGangInfo *>(dtor_gaddr(CGangInfo), &amp;objArray[i]);</p><h3 id="plugin_sagame_sametametacmatrixlinkh">plugin_sa\game_sa\meta\meta.CMatrixLink.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), reinterpret_cast<CMatrixLink *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), reinterpret_cast<CMatrixLink *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(ctor_gaddr(CMatrixLink), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CMatrixLink *>(dtor_gaddr(CMatrixLink), &amp;objArray[i]);</p><h3 id="plugin_sagame_sametametacpedgrouph">plugin_sa\game_sa\meta\meta.CPedGroup.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), reinterpret_cast<CPedGroup *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), reinterpret_cast<CPedGroup *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(ctor_gaddr(CPedGroup), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroup *>(dtor_gaddr(CPedGroup), &amp;objArray[i]);</p><h3 id="plugin_sagame_sametametacpedgroupintelligenceh">plugin_sa\game_sa\meta\meta.CPedGroupIntelligence.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), reinterpret_cast<CPedGroupIntelligence *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), reinterpret_cast<CPedGroupIntelligence *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(ctor_gaddr(CPedGroupIntelligence), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroupIntelligence *>(dtor_gaddr(CPedGroupIntelligence), &amp;objArray[i]);</p><h3 id="plugin_sagame_sametametacpedgroupmembershiph">plugin_sa\game_sa\meta\meta.CPedGroupMembership.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), reinterpret_cast<CPedGroupMembership *>(objBuff));</p>
<h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(ctor_gaddr_o(CPedGroupMembership, void(CPedGroupMembership const *)), reinterpret_cast<CPedGroupMembership *>(objBuff), Obj);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), reinterpret_cast<CPedGroupMembership *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(ctor_gaddr(CPedGroupMembership), &amp;objArray[i]);</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *, CPedGroupMembership const *>(ctor_gaddr_o(CPedGroupMembership, void(CPedGroupMembership const *)), obj, Obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPedGroupMembership *>(dtor_gaddr(CPedGroupMembership), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcc_pcsavecpp">plugin_vc\game_vc\C_PcSave.cpp</h3><h4>C_PcSave::DeleteSlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int>(gaddrof(C_PcSave::DeleteSlot), this, slot);</p>
<p>0AA8: call_method_return 0x61D430 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [bool]</p>
<h4>C_PcSave::PcClassSaveRoutine</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, C_PcSave *, int, unsigned char *, unsigned int>(gaddrof(C_PcSave::PcClassSaveRoutine), this, file, data, size);</p>
<p>0AA8: call_method_return 0x61D7A0 struct [C_PcSave] num_params 3 pop 0 [file] [data] [size] func_ret [bool]</p>
<h4>C_PcSave::PopulateSlotInfo</h4>
<p>plugin::CallMethodDynGlobal<C_PcSave *>(gaddrof(C_PcSave::PopulateSlotInfo), this);</p>
<p>0AA6: call_method 0x61D4A0 struct [C_PcSave] num_params 0 pop 0</p>
<p>define function C_PcSave__PopulateSlotInfo&lt;thiscall, 0x61D4A0&gt;()</p>
<h4>C_PcSave::SaveSlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<char, C_PcSave *, int>(gaddrof(C_PcSave::SaveSlot), this, slot);</p>
<p>0AA8: call_method_return 0x61D8B0 struct [C_PcSave] num_params 1 pop 0 [slot] func_ret [char]</p>
<h4>C_PcSave::SetSaveDirectory</h4>
<p>plugin::CallDynGlobal<char const *>(gaddrof(C_PcSave::SetSaveDirectory), path);</p><h3 id="plugin_vcgame_vcc3dmarkercpp">plugin_vc\game_vc\C3dMarker.cpp</h3><h4>C3dMarker::AddMarker</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *, unsigned int, unsigned short, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned int, float, unsigned short>(gaddrof(C3dMarker::AddMarker), this, nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate);</p>
<p>0AA6: call_method 0x570E90 struct [C3dMarker] num_params 10 pop 0 [nId] [nType] [fSize] [bRed] [bGreen] [bBlue] [bAlpha] [nPulsePeriod] [fPulseFraction] [nRotateRate]</p>
<p>define function C3dMarker__AddMarker&lt;thiscall, 0x570E90&gt;(nId, nType, fSize, bRed, bGreen, bBlue, bAlpha, nPulsePeriod, fPulseFraction, nRotateRate)</p>
<h4>C3dMarker::Render</h4>
<p>plugin::CallMethodDynGlobal<C3dMarker *>(gaddrof(C3dMarker::Render), this);</p>
<p>0AA6: call_method 0x570DA0 struct [C3dMarker] num_params 0 pop 0</p>
<p>define function C3dMarker__Render&lt;thiscall, 0x570DA0&gt;()</p><h3 id="plugin_vcgame_vcc3dmarkerscpp">plugin_vc\game_vc\C3dMarkers.cpp</h3><h4>C3dMarkers::PlaceMarkerSet</h4>
<p>plugin::Call<0x570270, unsigned int, unsigned short, CVector&, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned short, float, short>(id, type, pos, size, r, g, b, a, pulsePeriod, pulseFraction, rotateRate);</p>
<p>0AA5: call_function 0x570270 num_params 11 pop 11 [id] [type] [pos] [size] [r] [g] [b] [a] [pulsePeriod] [pulseFraction] [rotateRate]</p>
<p>define function C3dMarkers__PlaceMarkerSet&lt;cdecl, 0x570270&gt;(id, type, pos, size, r, g, b, a, pulsePeriod, pulseFraction, rotateRate)</p><h3 id="plugin_vcgame_vccanimblendassociationcpp">plugin_vc\game_vc\CAnimBlendAssociation.cpp</h3><h4>CAnimBlendAssociation::~CAnimBlendAssociation</h4>
<p>plugin::CallVirtualMethod<0, CAnimBlendAssociation *>(this, 1);</p><h3 id="plugin_vcgame_vccanimmanagercpp">plugin_vc\game_vc\CAnimManager.cpp</h3><h4>CAnimManager::GetAnimationBlockIndex</h4>
<p>plugin::CallAndReturn<int, 0x4059E0, char const*>(name);</p>
<p>0AA7: call_function_return 0x4059E0 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CAnimManager__GetAnimationBlockIndex&lt;cdecl, 0x4059E0&gt;(name): int</p>
<h4>*CAnimManager::GetAnimationBlock</h4>
<p>plugin::CallAndReturn<CAnimBlock<em>, 0x405A50, char const</em>>(name);</p>
<p>0AA7: call_function_return 0x405A50 num_params 1 pop 1 [name] func_ret [CAnimBlock*]</p>
<p>define function CAnimManager__GetAnimationBlock&lt;cdecl, 0x405A50&gt;(name): int</p>
<h4>*CAnimManager::BlendAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x405640, RpClump</em>, int, int, float>(clump, assocGroupId, animationId, clumpAssocBlendData);</p>
<p>0AA7: call_function_return 0x405640 num_params 4 pop 4 [clump] [assocGroupId] [animationId] [clumpAssocBlendData] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__BlendAnimation&lt;cdecl, 0x405640&gt;(clump, assocGroupId, animationId, clumpAssocBlendData): int</p>
<h4>CAnimManager::AddAnimation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4058B0, RpClump</em>, int, int>(clump, assocGroupId, animationId);</p>
<p>0AA7: call_function_return 0x4058B0 num_params 3 pop 3 [clump] [assocGroupId] [animationId] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__AddAnimation&lt;cdecl, 0x4058B0&gt;(clump, assocGroupId, animationId): int</p>
<h4>CAnimManager::GetAnimAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x405940, int, const char</em>>(assocGroupId, name);</p>
<p>0AA7: call_function_return 0x405940 num_params 2 pop 2 [assocGroupId] [name] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__GetAnimAssociation&lt;cdecl, 0x405940&gt;(assocGroupId, name): int</p>
<h4>CAnimManager::GetAnimAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation*, 0x405960, int, int>(assocGroupId, animationId);</p>
<p>0AA7: call_function_return 0x405960 num_params 2 pop 2 [assocGroupId] [animationId] func_ret [CAnimBlendAssociation*]</p>
<p>define function CAnimManager__GetAnimAssociation&lt;cdecl, 0x405960&gt;(assocGroupId, animationId): int</p><h3 id="plugin_vcgame_vccaudiomanagercpp">plugin_vc\game_vc\cAudioManager.cpp</h3><h4>cAudioManager::FindVehicleOfPlayer</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x5F5A60>();</p>
<p>0AA7: call_function_return 0x5F5A60 num_params 0 pop 0 func_ret [CVehicle*]</p>
<p>define function cAudioManager__FindVehicleOfPlayer&lt;cdecl, 0x5F5A60&gt;(): int</p><h3 id="plugin_vcgame_vccaudioscriptobjectcpp">plugin_vc\game_vc\cAudioScriptObject.cpp</h3><h4>cAudioScriptObject::LoadAllAudioScriptObjects</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(cAudioScriptObject::LoadAllAudioScriptObjects), buffer, size);</p>
<h4>cAudioScriptObject::SaveAllAudioScriptObjects</h4>
<p>plugin::CallDynGlobal<unsigned char *, int *>(gaddrof(cAudioScriptObject::SaveAllAudioScriptObjects), buffer, outSize);</p><h3 id="plugin_vcgame_vccautomobilecpp">plugin_vc\game_vc\CAutomobile.cpp</h3><h4>CAutomobile::AddDamagedVehicleParticles</h4>
<p>plugin::CallMethod<0x5920A0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x5920A0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__AddDamagedVehicleParticles&lt;thiscall, 0x5920A0&gt;()</p>
<h4>CAutomobile::AddWheelDirtAndWater</h4>
<p>plugin::CallMethodAndReturn<bool, 0x591B90, CAutomobile *, CColPoint&, unsigned int>(this, colPoint, arg1);</p>
<p>0AA8: call_method_return 0x591B90 struct [CAutomobile] num_params 2 pop 0 [colPoint] [arg1] func_ret [bool]</p>
<p>define function CAutomobile__AddWheelDirtAndWater&lt;thiscall, 0x591B90&gt;(colPoint, arg1): int</p>
<h4>CAutomobile::BlowUpCarsInPath</h4>
<p>plugin::CallMethod<0x5863D0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x5863D0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__BlowUpCarsInPath&lt;thiscall, 0x5863D0&gt;()</p>
<h4>CAutomobile::CAutomobile</h4>
<p>plugin::CallMethod<0x59E620, CAutomobile *, int, unsigned char>(this, modelIndex, createdBy);</p>
<p>0AA6: call_method 0x59E620 struct [CAutomobile] num_params 2 pop 0 [modelIndex] [createdBy]</p>
<p>define function CAutomobile__CAutomobile&lt;thiscall, 0x59E620&gt;(modelIndex, createdBy)</p>
<h4>CAutomobile::ClearHeliOrientation</h4>
<p>plugin::CallMethod<0x59B490, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x59B490 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ClearHeliOrientation&lt;thiscall, 0x59B490&gt;()</p>
<h4>CAutomobile::CloseBoot</h4>
<p>plugin::CallMethod<0x585D80, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x585D80 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__CloseBoot&lt;thiscall, 0x585D80&gt;()</p>
<h4>CAutomobile::DoDriveByShootings</h4>
<p>plugin::CallMethod<0x5C97B0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x5C97B0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__DoDriveByShootings&lt;thiscall, 0x5C97B0&gt;()</p>
<h4>CAutomobile::DoHoverSuspensionRatios</h4>
<p>plugin::CallMethod<0x585B60, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x585B60 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__DoHoverSuspensionRatios&lt;thiscall, 0x585B60&gt;()</p>
<h4>CAutomobile::FireTruckControl</h4>
<p>plugin::CallMethod<0x57AB30, CAutomobile *, float>(this, arg0);</p>
<p>0AA6: call_method 0x57AB30 struct [CAutomobile] num_params 1 pop 0 [arg0]</p>
<p>define function CAutomobile__FireTruckControl&lt;thiscall, 0x57AB30&gt;(arg0)</p>
<h4>CAutomobile::Fix</h4>
<p>plugin::CallMethod<0x588530, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x588530 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__Fix&lt;thiscall, 0x588530&gt;()</p>
<h4>CAutomobile::HasCarStoppedBecauseOfLight</h4>
<p>plugin::CallMethodAndReturn<bool, 0x435570, CAutomobile *>(this);</p>
<p>0AA8: call_method_return 0x435570 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAutomobile__HasCarStoppedBecauseOfLight&lt;thiscall, 0x435570&gt;(): int</p>
<h4>CAutomobile::HydraulicControl</h4>
<p>plugin::CallMethod<0x59D260, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x59D260 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__HydraulicControl&lt;thiscall, 0x59D260&gt;()</p>
<h4>CAutomobile::KnockPedOutCar</h4>
<p>plugin::CallMethodAndReturn<CPed*, 0x585F20, CAutomobile *, eWeaponType, unsigned short, CPed*>(this, weapon, arg1, ped);</p>
<p>0AA8: call_method_return 0x585F20 struct [CAutomobile] num_params 3 pop 0 [weapon] [arg1] [ped] func_ret [CPed*]</p>
<p>define function CAutomobile__KnockPedOutCar&lt;thiscall, 0x585F20&gt;(weapon, arg1, ped): int</p>
<h4>CAutomobile::PlaceOnRoadProperly</h4>
<p>plugin::CallMethod<0x586110, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x586110 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__PlaceOnRoadProperly&lt;thiscall, 0x586110&gt;()</p>
<h4>CAutomobile::PlayHornIfNecessary</h4>
<p>plugin::CallMethod<0x5881F0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x5881F0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__PlayHornIfNecessary&lt;thiscall, 0x5881F0&gt;()</p>
<h4>CAutomobile::PopBoot</h4>
<p>plugin::CallMethod<0x585E60, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x585E60 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__PopBoot&lt;thiscall, 0x585E60&gt;()</p>
<h4>CAutomobile::PopBootUsingPhysics</h4>
<p>plugin::CallMethod<0x585E20, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x585E20 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__PopBootUsingPhysics&lt;thiscall, 0x585E20&gt;()</p>
<h4>CAutomobile::ProcessAutoBusDoors</h4>
<p>plugin::CallMethod<0x586EC0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x586EC0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ProcessAutoBusDoors&lt;thiscall, 0x586EC0&gt;()</p>
<h4>CAutomobile::ProcessBuoyancy</h4>
<p>plugin::CallMethod<0x599B30, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x599B30 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ProcessBuoyancy&lt;thiscall, 0x599B30&gt;()</p>
<h4>CAutomobile::ProcessSwingingDoor</h4>
<p>plugin::CallMethod<0x592C40, CAutomobile *, int, eDoors>(this, nodeIndex, door);</p>
<p>0AA6: call_method 0x592C40 struct [CAutomobile] num_params 2 pop 0 [nodeIndex] [door]</p>
<p>define function CAutomobile__ProcessSwingingDoor&lt;thiscall, 0x592C40&gt;(nodeIndex, door)</p>
<h4>CAutomobile::RcbanditCheck1CarWheels</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5878E0, CAutomobile *, CPtrList&>(this, ptrlist);</p>
<p>0AA8: call_method_return 0x5878E0 struct [CAutomobile] num_params 1 pop 0 [ptrlist] func_ret [bool]</p>
<p>define function CAutomobile__RcbanditCheck1CarWheels&lt;thiscall, 0x5878E0&gt;(ptrlist): int</p>
<h4>CAutomobile::RcbanditCheckHitWheels</h4>
<p>plugin::CallMethodAndReturn<bool, 0x587B40, CAutomobile *>(this);</p>
<p>0AA8: call_method_return 0x587B40 struct [CAutomobile] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CAutomobile__RcbanditCheckHitWheels&lt;thiscall, 0x587B40&gt;(): int</p>
<h4>CAutomobile::ReduceHornCounter</h4>
<p>plugin::CallMethod<0x59AA90, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x59AA90 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ReduceHornCounter&lt;thiscall, 0x59AA90&gt;()</p>
<h4>CAutomobile::RemoveBonnetInPedCollision</h4>
<p>plugin::CallMethodAndReturn<CObject*, 0x592BA0, CAutomobile *>(this);</p>
<p>0AA8: call_method_return 0x592BA0 struct [CAutomobile] num_params 0 pop 0 func_ret [CObject*]</p>
<p>define function CAutomobile__RemoveBonnetInPedCollision&lt;thiscall, 0x592BA0&gt;(): int</p>
<h4>CAutomobile::ScanForCrimes</h4>
<p>plugin::CallMethod<0x588120, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x588120 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__ScanForCrimes&lt;thiscall, 0x588120&gt;()</p>
<h4>CAutomobile::SetBumperDamage</h4>
<p>plugin::CallMethod<0x59B370, CAutomobile *, int, ePanels, bool>(this, arg0, panel, withoutVisualEffect);</p>
<p>0AA6: call_method 0x59B370 struct [CAutomobile] num_params 3 pop 0 [arg0] [panel] [withoutVisualEffect]</p>
<p>define function CAutomobile__SetBumperDamage&lt;thiscall, 0x59B370&gt;(arg0, panel, withoutVisualEffect)</p>
<h4>CAutomobile::SetBusDoorTimer</h4>
<p>plugin::CallMethod<0x587080, CAutomobile *, unsigned int, unsigned char>(this, time, arg1);</p>
<p>0AA6: call_method 0x587080 struct [CAutomobile] num_params 2 pop 0 [time] [arg1]</p>
<p>define function CAutomobile__SetBusDoorTimer&lt;thiscall, 0x587080&gt;(time, arg1)</p>
<h4>CAutomobile::SetDoorDamage</h4>
<p>plugin::CallMethod<0x59B150, CAutomobile *, int, eDoors, bool>(this, nodeIndex, door, withoutVisualEffect);</p>
<p>0AA6: call_method 0x59B150 struct [CAutomobile] num_params 3 pop 0 [nodeIndex] [door] [withoutVisualEffect]</p>
<p>define function CAutomobile__SetDoorDamage&lt;thiscall, 0x59B150&gt;(nodeIndex, door, withoutVisualEffect)</p>
<h4>CAutomobile::SetHeliOrientation</h4>
<p>plugin::CallMethod<0x59B4A0, CAutomobile *, float>(this, angle);</p>
<p>0AA6: call_method 0x59B4A0 struct [CAutomobile] num_params 1 pop 0 [angle]</p>
<p>define function CAutomobile__SetHeliOrientation&lt;thiscall, 0x59B4A0&gt;(angle)</p>
<h4>CAutomobile::SetPanelDamage</h4>
<p>plugin::CallMethod<0x59B2A0, CAutomobile *, int, ePanels, bool>(this, nodeIndex, panel, createWindowGlass);</p>
<p>0AA6: call_method 0x59B2A0 struct [CAutomobile] num_params 3 pop 0 [nodeIndex] [panel] [createWindowGlass]</p>
<p>define function CAutomobile__SetPanelDamage&lt;thiscall, 0x59B2A0&gt;(nodeIndex, panel, createWindowGlass)</p>
<h4>CAutomobile::SetTaxiLight</h4>
<p>plugin::CallMethod<0x5882F0, CAutomobile *, bool>(this, enable);</p>
<p>0AA6: call_method 0x5882F0 struct [CAutomobile] num_params 1 pop 0 [enable]</p>
<p>define function CAutomobile__SetTaxiLight&lt;thiscall, 0x5882F0&gt;(enable)</p>
<h4>CAutomobile::SetupDamageAfterLoad</h4>
<p>plugin::CallMethod<0x588310, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x588310 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__SetupDamageAfterLoad&lt;thiscall, 0x588310&gt;()</p>
<h4>CAutomobile::SetupSuspensionLines</h4>
<p>plugin::CallMethod<0x59E2B0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x59E2B0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__SetupSuspensionLines&lt;thiscall, 0x59E2B0&gt;()</p>
<h4>CAutomobile::SpawnFlyingComponent</h4>
<p>plugin::CallMethodAndReturn<CObject*, 0x59AAA0, CAutomobile *, int, unsigned int>(this, nodeIndex, collisionType);</p>
<p>0AA8: call_method_return 0x59AAA0 struct [CAutomobile] num_params 2 pop 0 [nodeIndex] [collisionType] func_ret [CObject*]</p>
<p>define function CAutomobile__SpawnFlyingComponent&lt;thiscall, 0x59AAA0&gt;(nodeIndex, collisionType): int</p>
<h4>CAutomobile::TankControl</h4>
<p>plugin::CallMethod<0x5864C0, CAutomobile *>(this);</p>
<p>0AA6: call_method 0x5864C0 struct [CAutomobile] num_params 0 pop 0</p>
<p>define function CAutomobile__TankControl&lt;thiscall, 0x5864C0&gt;()</p>
<h4>CAutomobile::TellHeliToGoToCoors</h4>
<p>plugin::CallMethod<0x59B4B0, CAutomobile *, float, float, float, unsigned char>(this, x, y, z, arg3);</p>
<p>0AA6: call_method 0x59B4B0 struct [CAutomobile] num_params 4 pop 0 [x] [y] [z] [arg3]</p>
<p>define function CAutomobile__TellHeliToGoToCoors&lt;thiscall, 0x59B4B0&gt;(x, y, z, arg3)</p>
<h4>CAutomobile::TellPlaneToGoToCoors</h4>
<p>plugin::CallMethod<0x59B420, CAutomobile *, float, float, float, unsigned char>(this, x, y, z, arg3);</p>
<p>0AA6: call_method 0x59B420 struct [CAutomobile] num_params 4 pop 0 [x] [y] [z] [arg3]</p>
<p>define function CAutomobile__TellPlaneToGoToCoors&lt;thiscall, 0x59B420&gt;(x, y, z, arg3)</p>
<h4>CAutomobile::VehicleDamage</h4>
<p>plugin::CallMethod<0x59B550, CAutomobile *, float, int>(this, damageIntensity, arg1);</p>
<p>0AA6: call_method 0x59B550 struct [CAutomobile] num_params 2 pop 0 [damageIntensity] [arg1]</p>
<p>define function CAutomobile__VehicleDamage&lt;thiscall, 0x59B550&gt;(damageIntensity, arg1)</p>
<h4>CAutomobile::dmgDrawCarCollidingParticles</h4>
<p>plugin::CallMethod<0x59C480, CAutomobile *, CVector const&, float>(this, position, force);</p>
<p>0AA6: call_method 0x59C480 struct [CAutomobile] num_params 2 pop 0 [position] [force]</p>
<p>define function CAutomobile__dmgDrawCarCollidingParticles&lt;thiscall, 0x59C480&gt;(position, force)</p><h3 id="plugin_vcgame_vccbasemodelinfocpp">plugin_vc\game_vc\CBaseModelInfo.cpp</h3><h4>CBaseModelInfo::Shutdown</h4>
<p>plugin::CallVirtualMethod<1, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::DeleteRwObject</h4>
<p>plugin::CallVirtualMethod<2, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject*, 3, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::CreateInstance</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject*, 4, CBaseModelInfo *, RwMatrixTag*>(this, tranform);</p>
<h4>CBaseModelInfo::GetRwObject</h4>
<p>plugin::CallVirtualMethodAndReturn<RwObject*, 5, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::SetAnimFile</h4>
<p>plugin::CallVirtualMethod<6, CBaseModelInfo <em>, char const</em>>(this, filename);</p>
<h4>CBaseModelInfo::ConvertAnimFileIndex</h4>
<p>plugin::CallVirtualMethod<7, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::GetAnimFileIndex</h4>
<p>plugin::CallVirtualMethodAndReturn<int, 8, CBaseModelInfo *>(this);</p>
<h4>CBaseModelInfo::RemoveRef</h4>
<p>plugin::CallMethod<0x53F1A0, CBaseModelInfo *>(this);</p>
<p>0AA6: call_method 0x53F1A0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__RemoveRef&lt;thiscall, 0x53F1A0&gt;()</p>
<h4>CBaseModelInfo::AddRef</h4>
<p>plugin::CallMethod<0x53F1B0, CBaseModelInfo *>(this);</p>
<p>0AA6: call_method 0x53F1B0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__AddRef&lt;thiscall, 0x53F1B0&gt;()</p>
<h4>CBaseModelInfo::RemoveTexDictionaryRef</h4>
<p>plugin::CallMethod<0x53F1C0, CBaseModelInfo *>(this);</p>
<p>0AA6: call_method 0x53F1C0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__RemoveTexDictionaryRef&lt;thiscall, 0x53F1C0&gt;()</p>
<h4>CBaseModelInfo::AddTexDictionaryRef</h4>
<p>plugin::CallMethod<0x53F1D0, CBaseModelInfo *>(this);</p>
<p>0AA6: call_method 0x53F1D0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__AddTexDictionaryRef&lt;thiscall, 0x53F1D0&gt;()</p>
<h4>CBaseModelInfo::ClearTexDictionary</h4>
<p>plugin::CallMethod<0x53F1E0, CBaseModelInfo *>(this);</p>
<p>0AA6: call_method 0x53F1E0 struct [CBaseModelInfo] num_params 0 pop 0</p>
<p>define function CBaseModelInfo__ClearTexDictionary&lt;thiscall, 0x53F1E0&gt;()</p>
<h4>CBaseModelInfo::SetTexDictionary</h4>
<p>plugin::CallMethod<0x53F1F0, CBaseModelInfo <em>, char</em>>(this, txdName);</p>
<p>0AA6: call_method 0x53F1F0 struct [CBaseModelInfo] num_params 1 pop 0 [txdName]</p>
<p>define function CBaseModelInfo__SetTexDictionary&lt;thiscall, 0x53F1F0&gt;(txdName)</p>
<h4>CBaseModelInfo::Add2dEffect</h4>
<p>plugin::CallMethod<0x53F220, CBaseModelInfo <em>, C2dEffect</em>>(this, effect);</p>
<p>0AA6: call_method 0x53F220 struct [CBaseModelInfo] num_params 1 pop 0 [effect]</p>
<p>define function CBaseModelInfo__Add2dEffect&lt;thiscall, 0x53F220&gt;(effect)</p>
<h4>CBaseModelInfo::Get2dEffect</h4>
<p>plugin::CallMethodAndReturn<C2dEffect*, 0x53F260, CBaseModelInfo *, int>(this, effectNumber);</p>
<p>0AA8: call_method_return 0x53F260 struct [CBaseModelInfo] num_params 1 pop 0 [effectNumber] func_ret [C2dEffect*]</p>
<p>define function CBaseModelInfo__Get2dEffect&lt;thiscall, 0x53F260&gt;(effectNumber): int</p>
<h4>CBaseModelInfo::GetColModel</h4>
<p>plugin::CallMethodAndReturn<CColModel *, 0x4739B2, CBaseModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x4739B2 struct [CBaseModelInfo] num_params 0 pop 0 func_ret [CColModel *]</p>
<p>define function CBaseModelInfo__GetColModel&lt;thiscall, 0x4739B2&gt;(): int</p><h3 id="plugin_vcgame_vccbikecpp">plugin_vc\game_vc\CBike.cpp</h3><h4>CBike::AddDamagedVehicleParticles</h4>
<p>plugin::CallMethod<0x60DD20, CBike *>(this);</p>
<p>0AA6: call_method 0x60DD20 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__AddDamagedVehicleParticles&lt;thiscall, 0x60DD20&gt;()</p>
<h4>CBike::AddWheelDirtAndWater</h4>
<p>plugin::CallMethodAndReturn<bool, 0x60D7F0, CBike *, CColPoint&, unsigned int>(this, colPoint, arg1);</p>
<p>0AA8: call_method_return 0x60D7F0 struct [CBike] num_params 2 pop 0 [colPoint] [arg1] func_ret [bool]</p>
<p>define function CBike__AddWheelDirtAndWater&lt;thiscall, 0x60D7F0&gt;(colPoint, arg1): int</p>
<h4>CBike::CBike</h4>
<p>plugin::CallMethod<0x615740, CBike *, int, unsigned char>(this, modelIndex, createdBy);</p>
<p>0AA6: call_method 0x615740 struct [CBike] num_params 2 pop 0 [modelIndex] [createdBy]</p>
<p>define function CBike__CBike&lt;thiscall, 0x615740&gt;(modelIndex, createdBy)</p>
<h4>CBike::CalculateLeanMatrix</h4>
<p>plugin::CallMethod<0x609C90, CBike *>(this);</p>
<p>0AA6: call_method 0x609C90 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__CalculateLeanMatrix&lt;thiscall, 0x609C90&gt;()</p>
<h4>CBike::DoDriveByShootings</h4>
<p>plugin::CallMethod<0x5C91E0, CBike *>(this);</p>
<p>0AA6: call_method 0x5C91E0 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__DoDriveByShootings&lt;thiscall, 0x5C91E0&gt;()</p>
<h4>CBike::Fix</h4>
<p>plugin::CallMethod<0x609F00, CBike *>(this);</p>
<p>0AA6: call_method 0x609F00 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__Fix&lt;thiscall, 0x609F00&gt;()</p>
<h4>CBike::GetCorrectedWorldDoorPosition</h4>
<p>plugin::CallMethod<0x609720, CBike *, CVector&, CVector, CVector>(this, out, arg1, arg2);</p>
<p>0AA6: call_method 0x609720 struct [CBike] num_params 3 pop 0 [out] [arg1] [arg2]</p>
<p>define function CBike__GetCorrectedWorldDoorPosition&lt;thiscall, 0x609720&gt;(out, arg1, arg2)</p>
<h4>CBike::KnockOffRider</h4>
<p>plugin::CallMethodAndReturn<CPed*, 0x613920, CBike *, eWeaponType, unsigned char, CPed*, bool>(this, arg0, arg1, arg2, arg3);</p>
<p>0AA8: call_method_return 0x613920 struct [CBike] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3] func_ret [CPed*]</p>
<p>define function CBike__KnockOffRider&lt;thiscall, 0x613920&gt;(arg0, arg1, arg2, arg3): int</p>
<h4>CBike::PlayHornIfNecessary</h4>
<p>plugin::CallMethod<0x609E10, CBike *>(this);</p>
<p>0AA6: call_method 0x609E10 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__PlayHornIfNecessary&lt;thiscall, 0x609E10&gt;()</p>
<h4>CBike::ProcessBuoyancy</h4>
<p>plugin::CallMethod<0x613540, CBike *>(this);</p>
<p>0AA6: call_method 0x613540 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__ProcessBuoyancy&lt;thiscall, 0x613540&gt;()</p>
<h4>CBike::ReduceHornCounter</h4>
<p>plugin::CallMethod<0x613910, CBike *>(this);</p>
<p>0AA6: call_method 0x613910 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__ReduceHornCounter&lt;thiscall, 0x613910&gt;()</p>
<h4>CBike::SetupSuspensionLines</h4>
<p>plugin::CallMethod<0x615080, CBike *>(this);</p>
<p>0AA6: call_method 0x615080 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__SetupSuspensionLines&lt;thiscall, 0x615080&gt;()</p>
<h4>CBike::VehicleDamage</h4>
<p>plugin::CallMethod<0x614860, CBike *>(this);</p>
<p>0AA6: call_method 0x614860 struct [CBike] num_params 0 pop 0</p>
<p>define function CBike__VehicleDamage&lt;thiscall, 0x614860&gt;()</p><h3 id="plugin_vcgame_vccboatcpp">plugin_vc\game_vc\CBoat.cpp</h3><h4>CBoat::AddWakePoint</h4>
<p>plugin::CallMethod<0x59F580, CBoat *, CVector>(this, posn);</p>
<p>0AA6: call_method 0x59F580 struct [CBoat] num_params 1 pop 0 [posn]</p>
<p>define function CBoat__AddWakePoint&lt;thiscall, 0x59F580&gt;(posn)</p>
<h4>CBoat::ApplyWaterResistance</h4>
<p>plugin::CallMethod<0x59FB30, CBoat *>(this);</p>
<p>0AA6: call_method 0x59FB30 struct [CBoat] num_params 0 pop 0</p>
<p>define function CBoat__ApplyWaterResistance&lt;thiscall, 0x59FB30&gt;()</p>
<h4>CBoat::CBoat</h4>
<p>plugin::CallMethod<0x5A6470, CBoat *, int, unsigned char>(this, modelIndex, createdBy);</p>
<p>0AA6: call_method 0x5A6470 struct [CBoat] num_params 2 pop 0 [modelIndex] [createdBy]</p>
<p>define function CBoat__CBoat&lt;thiscall, 0x5A6470&gt;(modelIndex, createdBy)</p>
<h4>CBoat::DoDriveByShootings</h4>
<p>plugin::CallMethod<0x5C9540, CBoat *>(this);</p>
<p>0AA6: call_method 0x5C9540 struct [CBoat] num_params 0 pop 0</p>
<p>define function CBoat__DoDriveByShootings&lt;thiscall, 0x5C9540&gt;()</p>
<h4>CBoat::FillBoatList</h4>
<p>plugin::Call<0x59F360>();</p>
<p>0AA5: call_function 0x59F360 num_params 0 pop 0</p>
<p>define function CBoat__FillBoatList&lt;cdecl, 0x59F360&gt;()</p>
<h4>CBoat::PruneWakeTrail</h4>
<p>plugin::CallMethod<0x59F6F0, CBoat *>(this);</p>
<p>0AA6: call_method 0x59F6F0 struct [CBoat] num_params 0 pop 0</p>
<p>define function CBoat__PruneWakeTrail&lt;thiscall, 0x59F6F0&gt;()</p><h3 id="plugin_vcgame_vccboxcpp">plugin_vc\game_vc\CBox.cpp</h3><h4>CBox::Set</h4>
<p>plugin::Call<0x410910, CVector const&, CVector const&>(vecMin, vecMax);</p>
<p>0AA5: call_function 0x410910 num_params 2 pop 2 [vecMin] [vecMax]</p>
<p>define function CBox__Set&lt;cdecl, 0x410910&gt;(vecMin, vecMax)</p><h3 id="plugin_vcgame_vccbrightlightscpp">plugin_vc\game_vc\CBrightLights.cpp</h3><h4>CBrightLight::CBrightLight</h4>
<p>plugin::CallMethod<0x575140, CBrightLight *>(this);</p>
<p>0AA6: call_method 0x575140 struct [CBrightLight] num_params 0 pop 0</p>
<p>define function CBrightLight__CBrightLight&lt;thiscall, 0x575140&gt;()</p>
<h4>CBrightLights::RegisterOne</h4>
<p>plugin::Call<0x571820, CVector, CVector, CVector, CVector, unsigned char, unsigned char, unsigned char, unsigned char>(posn, right, up, at, red, green, blue, alpha);</p>
<p>0AA5: call_function 0x571820 num_params 8 pop 8 [posn] [right] [up] [at] [red] [green] [blue] [alpha]</p>
<p>define function CBrightLights__RegisterOne&lt;cdecl, 0x571820&gt;(posn, right, up, at, red, green, blue, alpha)</p>
<h4>CBrightLights::Render</h4>
<p>plugin::Call<0x5719B0>();</p>
<p>0AA5: call_function 0x5719B0 num_params 0 pop 0</p>
<p>define function CBrightLights__Render&lt;cdecl, 0x5719B0&gt;()</p><h3 id="plugin_vcgame_vccbulletinfocpp">plugin_vc\game_vc\CBulletInfo.cpp</h3><h4>CBulletInfo::AddBullet</h4>
<p>plugin::Call<0x5C47C0, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, position, velocity);</p>
<p>0AA5: call_function 0x5C47C0 num_params 4 pop 4 [creator] [weaponType] [position] [velocity]</p>
<p>define function CBulletInfo__AddBullet&lt;cdecl, 0x5C47C0&gt;(creator, weaponType, position, velocity)</p>
<h4>CBulletInfo::CBulletInfo</h4>
<p>plugin::CallMethod<0x5C4B10, CBulletInfo *>(this);</p>
<p>0AA6: call_method 0x5C4B10 struct [CBulletInfo] num_params 0 pop 0</p>
<p>define function CBulletInfo__CBulletInfo&lt;thiscall, 0x5C4B10&gt;()</p>
<h4>CBulletInfo::Initialise</h4>
<p>plugin::Call<0x5C48C0>();</p>
<p>0AA5: call_function 0x5C48C0 num_params 0 pop 0</p>
<p>define function CBulletInfo__Initialise&lt;cdecl, 0x5C48C0&gt;()</p>
<h4>CBulletInfo::Shutdown</h4>
<p>plugin::Call<0x5C48A0>();</p>
<p>0AA5: call_function 0x5C48A0 num_params 0 pop 0</p>
<p>define function CBulletInfo__Shutdown&lt;cdecl, 0x5C48A0&gt;()</p>
<h4>CBulletInfo::TestForSniperBullet</h4>
<p>plugin::Call<0x5C3B20, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x5C3B20 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CBulletInfo__TestForSniperBullet&lt;cdecl, 0x5C3B20&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CBulletInfo::Update</h4>
<p>plugin::Call<0x5C3DE0>();</p>
<p>0AA5: call_function 0x5C3DE0 num_params 0 pop 0</p>
<p>define function CBulletInfo__Update&lt;cdecl, 0x5C3DE0&gt;()</p><h3 id="plugin_vcgame_vccbullettracescpp">plugin_vc\game_vc\CBulletTraces.cpp</h3><h4>CBulletTraces::AddTrace</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *, float, unsigned int, unsigned char>(gaddrof_o(CBulletTraces::AddTrace, void (*)(CVector *, CVector *, float, unsigned int, unsigned char)), origin, target, radius, time, transparency);</p>
<h4>CBulletTraces::AddTrace</h4>
<p>plugin::CallDynGlobal<CVector *, CVector *, int, CEntity *>(gaddrof_o(CBulletTraces::AddTrace, void (*)(CVector *, CVector *, int, CEntity *)), origin, target, weaponType, entity);</p><h3 id="plugin_vcgame_vccbuoyancycpp">plugin_vc\game_vc\cBuoyancy.cpp</h3><h4>cBuoyancy::ProcessBuoyancy</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5AAC90, cBuoyancy*, CPhysical *, float, CVector<em>, CVector</em>>(this, phys, buoyancy, point, impulse);</p>
<p>0AA8: call_method_return 0x5AAC90 struct [cBuoyancy] num_params 4 pop 0 [phys] [buoyancy] [point] [impulse] func_ret [bool]</p>
<p>define function cBuoyancy__ProcessBuoyancy&lt;thiscall, 0x5AAC90&gt;(phys, buoyancy, point, impulse): int</p><h3 id="plugin_vcgame_vcccameracpp">plugin_vc\game_vc\CCamera.cpp</h3><h4>CCamera::AvoidTheGeometry</h4>
<p>plugin::CallMethod<0x473AA4, CCamera *, CVector const&, CVector const&, CVector&, float>(this, Vector1, Vector2, Vector3, arg4);</p>
<p>0AA6: call_method 0x473AA4 struct [CCamera] num_params 4 pop 0 [Vector1] [Vector2] [Vector3] [arg4]</p>
<p>define function CCamera__AvoidTheGeometry&lt;thiscall, 0x473AA4&gt;(Vector1, Vector2, Vector3, arg4)</p>
<h4>CCamera::CalculateDerivedValues</h4>
<p>plugin::CallMethod<0x46C3B6, CCamera *>(this);</p>
<p>0AA6: call_method 0x46C3B6 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__CalculateDerivedValues&lt;thiscall, 0x46C3B6&gt;()</p>
<h4>CCamera::CamControl</h4>
<p>plugin::CallMethod<0x4700E7, CCamera *>(this);</p>
<p>0AA6: call_method 0x4700E7 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__CamControl&lt;thiscall, 0x4700E7&gt;()</p>
<h4>CCamera::CamShake</h4>
<p>plugin::CallMethod<0x46FF21, CCamera *, float, float, float, float>(this, arg1, x_coord, y_coord, z_coord);</p>
<p>0AA6: call_method 0x46FF21 struct [CCamera] num_params 4 pop 0 [arg1] [x_coord] [y_coord] [z_coord]</p>
<p>define function CCamera__CamShake&lt;thiscall, 0x46FF21&gt;(arg1, x_coord, y_coord, z_coord)</p>
<h4>CCamera::ClearPlayerWeaponMode</h4>
<p>plugin::CallMethod<0x46FE51, CCamera *>(this);</p>
<p>0AA6: call_method 0x46FE51 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ClearPlayerWeaponMode&lt;thiscall, 0x46FE51&gt;()</p>
<h4>CCamera::DeleteCutSceneCamDataMemory</h4>
<p>plugin::CallMethod<0x46FE25, CCamera *>(this);</p>
<p>0AA6: call_method 0x46FE25 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__DeleteCutSceneCamDataMemory&lt;thiscall, 0x46FE25&gt;()</p>
<h4>CCamera::DontProcessObbeCinemaCamera</h4>
<p>plugin::Call<0x46FE13>();</p>
<p>0AA5: call_function 0x46FE13 num_params 0 pop 0</p>
<p>define function CCamera__DontProcessObbeCinemaCamera&lt;cdecl, 0x46FE13&gt;()</p>
<h4>CCamera::DrawBordersForWideScreen</h4>
<p>plugin::CallMethod<0x46FC1C, CCamera *>(this);</p>
<p>0AA6: call_method 0x46FC1C struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__DrawBordersForWideScreen&lt;thiscall, 0x46FC1C&gt;()</p>
<h4>CCamera::Fade</h4>
<p>plugin::CallMethod<0x46FBCB, CCamera *, float, short>(this, timeToFade, FadingDirection);</p>
<p>0AA6: call_method 0x46FBCB struct [CCamera] num_params 2 pop 0 [timeToFade] [FadingDirection]</p>
<p>define function CCamera__Fade&lt;thiscall, 0x46FBCB&gt;(timeToFade, FadingDirection)</p>
<h4>CCamera::Find3rdPersonCamTargetVector</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46F890, CCamera *, float, CVector, CVector&, CVector&>(this, arg1, vector1, vector2, vector3);</p>
<p>0AA8: call_method_return 0x46F890 struct [CCamera] num_params 4 pop 0 [arg1] [vector1] [vector2] [vector3] func_ret [bool]</p>
<p>define function CCamera__Find3rdPersonCamTargetVector&lt;thiscall, 0x46F890&gt;(arg1, vector1, vector2, vector3): int</p>
<h4>CCamera::Find3rdPersonQuickAimPitch</h4>
<p>plugin::CallMethodAndReturn<float, 0x46F7C6, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F7C6 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<p>define function CCamera__Find3rdPersonQuickAimPitch&lt;thiscall, 0x46F7C6&gt;(): float</p>
<h4>CCamera::FinishCutscene</h4>
<p>plugin::CallMethod<0x46FB3C, CCamera *>(this);</p>
<p>0AA6: call_method 0x46FB3C struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__FinishCutscene&lt;thiscall, 0x46FB3C&gt;()</p>
<h4>CCamera::GetArrPosForVehicleType</h4>
<p>plugin::CallAndReturn<bool, 0x46F659, int, int&>(vehicleType, ArrPos);</p>
<p>0AA7: call_function_return 0x46F659 num_params 2 pop 2 [vehicleType] [ArrPos] func_ret [bool]</p>
<p>define function CCamera__GetArrPosForVehicleType&lt;cdecl, 0x46F659&gt;(vehicleType, ArrPos): int</p>
<h4>CCamera::GetCutSceneFinishTime</h4>
<p>plugin::CallMethodAndReturn<int, 0x46F77E, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F77E struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<p>define function CCamera__GetCutSceneFinishTime&lt;thiscall, 0x46F77E&gt;(): int</p>
<h4>CCamera::GetFading</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46F777, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F777 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCamera__GetFading&lt;thiscall, 0x46F777&gt;(): int</p>
<h4>CCamera::GetGameCamPosition</h4>
<p>plugin::CallMethodAndReturn<CVector*, 0x46F730, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F730 struct [CCamera] num_params 0 pop 0 func_ret [CVector*]</p>
<p>define function CCamera__GetGameCamPosition&lt;thiscall, 0x46F730&gt;(): int</p>
<h4>CCamera::GetLookDirection</h4>
<p>plugin::CallMethodAndReturn<int, 0x46F6CE, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F6CE struct [CCamera] num_params 0 pop 0 func_ret [int]</p>
<p>define function CCamera__GetLookDirection&lt;thiscall, 0x46F6CE&gt;(): int</p>
<h4>CCamera::GetLookingForwardFirstPerson</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46F6A9, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F6A9 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCamera__GetLookingForwardFirstPerson&lt;thiscall, 0x46F6A9&gt;(): int</p>
<h4>CCamera::GetLookingLRBFirstPerson</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46F70B, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F70B struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCamera__GetLookingLRBFirstPerson&lt;thiscall, 0x46F70B&gt;(): int</p>
<h4>CCamera::GetPositionAlongSpline</h4>
<p>plugin::CallMethodAndReturn<float, 0x46F652, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F652 struct [CCamera] num_params 0 pop 0 func_ret [float]</p>
<p>define function CCamera__GetPositionAlongSpline&lt;thiscall, 0x46F652&gt;(): float</p>
<h4>CCamera::GetScreenFadeStatus</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46F737, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F737 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCamera__GetScreenFadeStatus&lt;thiscall, 0x46F737&gt;(): int</p>
<h4>CCamera::GetScreenRect</h4>
<p>plugin::CallMethod<0x46FD5D, CCamera *, CRect&>(this, Rect);</p>
<p>0AA6: call_method 0x46FD5D struct [CCamera] num_params 1 pop 0 [Rect]</p>
<p>define function CCamera__GetScreenRect&lt;thiscall, 0x46FD5D&gt;(Rect)</p>
<h4>CCamera::Get_Just_Switched_Status</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46F773, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46F773 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCamera__Get_Just_Switched_Status&lt;thiscall, 0x46F773&gt;(): int</p>
<h4>CCamera::Init</h4>
<p>plugin::CallMethod<0x46F108, CCamera *>(this);</p>
<p>0AA6: call_method 0x46F108 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Init&lt;thiscall, 0x46F108&gt;()</p>
<h4>CCamera::IsItTimeForNewcam</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46E2C4, CCamera *, int, int>(this, arg1, timer);</p>
<p>0AA8: call_method_return 0x46E2C4 struct [CCamera] num_params 2 pop 0 [arg1] [timer] func_ret [bool]</p>
<p>define function CCamera__IsItTimeForNewcam&lt;thiscall, 0x46E2C4&gt;(arg1, timer): int</p>
<h4>CCamera::LoadPathSplines</h4>
<p>plugin::Call<0x46E140, int>(FilePtr);</p>
<p>0AA5: call_function 0x46E140 num_params 1 pop 1 [FilePtr]</p>
<p>define function CCamera__LoadPathSplines&lt;cdecl, 0x46E140&gt;(FilePtr)</p>
<h4>CCamera::Process</h4>
<p>plugin::CallMethod<0x46C58C, CCamera *>(this);</p>
<p>0AA6: call_method 0x46C58C struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Process&lt;thiscall, 0x46C58C&gt;()</p>
<h4>CCamera::ProcessFade</h4>
<p>plugin::CallMethod<0x46C278, CCamera *>(this);</p>
<p>0AA6: call_method 0x46C278 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessFade&lt;thiscall, 0x46C278&gt;()</p>
<h4>CCamera::ProcessMusicFade</h4>
<p>plugin::CallMethod<0x46C10D, CCamera *>(this);</p>
<p>0AA6: call_method 0x46C10D struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessMusicFade&lt;thiscall, 0x46C10D&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraCar</h4>
<p>plugin::CallMethod<0x46BFEE, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BFEE struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraCar&lt;thiscall, 0x46BFEE&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraHeli</h4>
<p>plugin::CallMethod<0x46BEE6, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BEE6 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraHeli&lt;thiscall, 0x46BEE6&gt;()</p>
<h4>CCamera::ProcessObbeCinemaCameraPed</h4>
<p>plugin::CallMethod<0x46BE18, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BE18 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__ProcessObbeCinemaCameraPed&lt;thiscall, 0x46BE18&gt;()</p>
<h4>CCamera::RenderMotionBlur</h4>
<p>plugin::CallMethod<0x46BDE0, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BDE0 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RenderMotionBlur&lt;thiscall, 0x46BDE0&gt;()</p>
<h4>CCamera::Restore</h4>
<p>plugin::CallMethod<0x46BC7D, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BC7D struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__Restore&lt;thiscall, 0x46BC7D&gt;()</p>
<h4>CCamera::RestoreWithJumpCut</h4>
<p>plugin::CallMethod<0x46BB24, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BB24 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__RestoreWithJumpCut&lt;thiscall, 0x46BB24&gt;()</p>
<h4>CCamera::SetCamCutSceneOffSet</h4>
<p>plugin::CallMethod<0x46BB03, CCamera *, CVector const&>(this, vecCutSceneOffset);</p>
<p>0AA6: call_method 0x46BB03 struct [CCamera] num_params 1 pop 0 [vecCutSceneOffset]</p>
<p>define function CCamera__SetCamCutSceneOffSet&lt;thiscall, 0x46BB03&gt;(vecCutSceneOffset)</p>
<h4>CCamera::SetCamPositionForFixedMode</h4>
<p>plugin::CallMethod<0x46BA72, CCamera *, CVector const&, CVector const&>(this, vecFixedModeSource, vecFixedModeUpOffSet);</p>
<p>0AA6: call_method 0x46BA72 struct [CCamera] num_params 2 pop 0 [vecFixedModeSource] [vecFixedModeUpOffSet]</p>
<p>define function CCamera__SetCamPositionForFixedMode&lt;thiscall, 0x46BA72&gt;(vecFixedModeSource, vecFixedModeUpOffSet)</p>
<h4>CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString</h4>
<p>plugin::CallMethod<0x46BADE, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BADE struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetCameraDirectlyBehindForFollowPed_CamOnAString&lt;thiscall, 0x46BADE&gt;()</p>
<h4>CCamera::SetCameraDirectlyInFrontForFollowPed_CamOnAString</h4>
<p>plugin::CallMethod<0x46BAB9, CCamera *>(this);</p>
<p>0AA6: call_method 0x46BAB9 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetCameraDirectlyInFrontForFollowPed_CamOnAString&lt;thiscall, 0x46BAB9&gt;()</p>
<h4>CCamera::SetFadeColour</h4>
<p>plugin::CallMethod<0x46BA35, CCamera *, unsigned char, unsigned char, unsigned char>(this, red, green, blue);</p>
<p>0AA6: call_method 0x46BA35 struct [CCamera] num_params 3 pop 0 [red] [green] [blue]</p>
<p>define function CCamera__SetFadeColour&lt;thiscall, 0x46BA35&gt;(red, green, blue)</p>
<h4>CCamera::SetMotionBlur</h4>
<p>plugin::CallMethod<0x46BA00, CCamera *, int, int, int, int, int>(this, red, green, blue, motionblur, blurtype);</p>
<p>0AA6: call_method 0x46BA00 struct [CCamera] num_params 5 pop 0 [red] [green] [blue] [motionblur] [blurtype]</p>
<p>define function CCamera__SetMotionBlur&lt;thiscall, 0x46BA00&gt;(red, green, blue, motionblur, blurtype)</p>
<h4>CCamera::SetMotionBlurAlpha</h4>
<p>plugin::CallMethod<0x46B9F3, CCamera *, int>(this, alpha);</p>
<p>0AA6: call_method 0x46B9F3 struct [CCamera] num_params 1 pop 0 [alpha]</p>
<p>define function CCamera__SetMotionBlurAlpha&lt;thiscall, 0x46B9F3&gt;(alpha)</p>
<h4>CCamera::SetNearClipScript</h4>
<p>plugin::CallMethod<0x46B9E2, CCamera *, float>(this, fNearClipScript);</p>
<p>0AA6: call_method 0x46B9E2 struct [CCamera] num_params 1 pop 0 [fNearClipScript]</p>
<p>define function CCamera__SetNearClipScript&lt;thiscall, 0x46B9E2&gt;(fNearClipScript)</p>
<h4>CCamera::SetNewPlayerWeaponMode</h4>
<p>plugin::CallMethod<0x46B90D, CCamera *, short, short, short>(this, Mode, MinZoom, MaxZoom);</p>
<p>0AA6: call_method 0x46B90D struct [CCamera] num_params 3 pop 0 [Mode] [MinZoom] [MaxZoom]</p>
<p>define function CCamera__SetNewPlayerWeaponMode&lt;thiscall, 0x46B90D&gt;(Mode, MinZoom, MaxZoom)</p>
<h4>CCamera::SetParametersForScriptInterpolation</h4>
<p>plugin::CallMethod<0x46B8AE, CCamera *, float, float, unsigned int>(this, fScriptInterToStopMoving, fScriptInterToCatchUp, fScriptTimeForInterPolation);</p>
<p>0AA6: call_method 0x46B8AE struct [CCamera] num_params 3 pop 0 [fScriptInterToStopMoving] [fScriptInterToCatchUp] [fScriptTimeForInterPolation]</p>
<p>define function CCamera__SetParametersForScriptInterpolation&lt;thiscall, 0x46B8AE&gt;(fScriptInterToStopMoving, fScriptInterToCatchUp, fScriptTimeForInterPolation)</p>
<h4>CCamera::SetRwCamera</h4>
<p>plugin::CallMethod<0x46B87A, CCamera <em>, RwCamera</em>>(this, pRwCam);</p>
<p>0AA6: call_method 0x46B87A struct [CCamera] num_params 1 pop 0 [pRwCam]</p>
<p>define function CCamera__SetRwCamera&lt;thiscall, 0x46B87A&gt;(pRwCam)</p>
<h4>CCamera::SetWideScreenOff</h4>
<p>plugin::CallMethod<0x46B863, CCamera *>(this);</p>
<p>0AA6: call_method 0x46B863 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetWideScreenOff&lt;thiscall, 0x46B863&gt;()</p>
<h4>CCamera::SetWideScreenOn</h4>
<p>plugin::CallMethod<0x46B875, CCamera *>(this);</p>
<p>0AA6: call_method 0x46B875 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__SetWideScreenOn&lt;thiscall, 0x46B875&gt;()</p>
<h4>CCamera::SetZoomValueCamStringScript</h4>
<p>plugin::CallMethod<0x46B743, CCamera *, short>(this, mode);</p>
<p>0AA6: call_method 0x46B743 struct [CCamera] num_params 1 pop 0 [mode]</p>
<p>define function CCamera__SetZoomValueCamStringScript&lt;thiscall, 0x46B743&gt;(mode)</p>
<h4>CCamera::SetZoomValueFollowPedScript</h4>
<p>plugin::CallMethod<0x46B817, CCamera *, short>(this, mode);</p>
<p>0AA6: call_method 0x46B817 struct [CCamera] num_params 1 pop 0 [mode]</p>
<p>define function CCamera__SetZoomValueFollowPedScript&lt;thiscall, 0x46B817&gt;(mode)</p>
<h4>CCamera::StartTransition</h4>
<p>plugin::CallMethod<0x46AB08, CCamera *, short>(this, mode);</p>
<p>0AA6: call_method 0x46AB08 struct [CCamera] num_params 1 pop 0 [mode]</p>
<p>define function CCamera__StartTransition&lt;thiscall, 0x46AB08&gt;(mode)</p>
<h4>CCamera::StartTransitionWhenNotFinishedInter</h4>
<p>plugin::CallMethod<0x46AAF5, CCamera *, short>(this, mode);</p>
<p>0AA6: call_method 0x46AAF5 struct [CCamera] num_params 1 pop 0 [mode]</p>
<p>define function CCamera__StartTransitionWhenNotFinishedInter&lt;thiscall, 0x46AAF5&gt;(mode)</p>
<h4>CCamera::StoreValuesDuringInterPol</h4>
<p>plugin::CallMethod<0x46AA01, CCamera *, CVector&, CVector&, CVector&, float&>(this, _SourceDuringInter, _TargetDuringInter, _UpDuringInter, _FOVDuringInter);</p>
<p>0AA6: call_method 0x46AA01 struct [CCamera] num_params 4 pop 0 [_SourceDuringInter] [_TargetDuringInter] [_UpDuringInter] [_FOVDuringInter]</p>
<p>define function CCamera__StoreValuesDuringInterPol&lt;thiscall, 0x46AA01&gt;(_SourceDuringInter, _TargetDuringInter, _UpDuringInter, _FOVDuringInter)</p>
<h4>CCamera::TakeControl</h4>
<p>plugin::CallMethod<0x46A4F8, CCamera <em>, CEntity</em>, short, short, int>(this, pEntity, mode, _TypeOfSwitch, _WhoIsInControlOfTheCamera);</p>
<p>0AA6: call_method 0x46A4F8 struct [CCamera] num_params 4 pop 0 [pEntity] [mode] [_TypeOfSwitch] [_WhoIsInControlOfTheCamera]</p>
<p>define function CCamera__TakeControl&lt;thiscall, 0x46A4F8&gt;(pEntity, mode, _TypeOfSwitch, _WhoIsInControlOfTheCamera)</p>
<h4>CCamera::TakeControlNoEntity</h4>
<p>plugin::CallMethod<0x46A494, CCamera *, CVector const&, short, int>(this, vecFixedModeVector, _TypeOfSwitch, _WhoIsInControlOfTheCamera);</p>
<p>0AA6: call_method 0x46A494 struct [CCamera] num_params 3 pop 0 [vecFixedModeVector] [_TypeOfSwitch] [_WhoIsInControlOfTheCamera]</p>
<p>define function CCamera__TakeControlNoEntity&lt;thiscall, 0x46A494&gt;(vecFixedModeVector, _TypeOfSwitch, _WhoIsInControlOfTheCamera)</p>
<h4>CCamera::TakeControlWithSpline</h4>
<p>plugin::CallMethod<0x46A46A, CCamera *, short>(this, TypeOfSwitch);</p>
<p>0AA6: call_method 0x46A46A struct [CCamera] num_params 1 pop 0 [TypeOfSwitch]</p>
<p>define function CCamera__TakeControlWithSpline&lt;thiscall, 0x46A46A&gt;(TypeOfSwitch)</p>
<h4>CCamera::TryToStartNewCamMode</h4>
<p>plugin::CallMethodAndReturn<bool, 0x467AAD, CCamera *, int>(this, mode);</p>
<p>0AA8: call_method_return 0x467AAD struct [CCamera] num_params 1 pop 0 [mode] func_ret [bool]</p>
<p>define function CCamera__TryToStartNewCamMode&lt;thiscall, 0x467AAD&gt;(mode): int</p>
<h4>CCamera::UpdateAimingCoors</h4>
<p>plugin::CallMethod<0x467A8C, CCamera *, CVector const&>(this, vecAimingTarget);</p>
<p>0AA6: call_method 0x467A8C struct [CCamera] num_params 1 pop 0 [vecAimingTarget]</p>
<p>define function CCamera__UpdateAimingCoors&lt;thiscall, 0x467A8C&gt;(vecAimingTarget)</p>
<h4>CCamera::UpdateSoundDistances</h4>
<p>plugin::CallMethod<0x46A885, CCamera *>(this);</p>
<p>0AA6: call_method 0x46A885 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__UpdateSoundDistances&lt;thiscall, 0x46A885&gt;()</p>
<h4>CCamera::UpdateTargetEntity</h4>
<p>plugin::CallMethod<0x46A5A3, CCamera *>(this);</p>
<p>0AA6: call_method 0x46A5A3 struct [CCamera] num_params 0 pop 0</p>
<p>define function CCamera__UpdateTargetEntity&lt;thiscall, 0x46A5A3&gt;()</p>
<h4>CCamera::Using1stPersonWeaponMode</h4>
<p>plugin::CallMethodAndReturn<bool, 0x46B8E2, CCamera *>(this);</p>
<p>0AA8: call_method_return 0x46B8E2 struct [CCamera] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCamera__Using1stPersonWeaponMode&lt;thiscall, 0x46B8E2&gt;(): int</p><h3 id="plugin_vcgame_vcccaraicpp">plugin_vc\game_vc\CCarAI.cpp</h3><h4>CCarAI::AddAmbulanceOccupants</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddAmbulanceOccupants), vehicle);</p>
<h4>CCarAI::AddFiretruckOccupants</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddFiretruckOccupants), vehicle);</p>
<h4>CCarAI::AddPoliceCarOccupants</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::AddPoliceCarOccupants), vehicle);</p>
<h4>CCarAI::CarHasReasonToStop</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::CarHasReasonToStop), vehicle);</p>
<h4>CCarAI::FindPoliceBoatMissionForWantedLevel</h4>
<p>plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceBoatMissionForWantedLevel));</p>
<p>0AA7: call_function_return 0x419880 num_params 0 pop 0 func_ret [eCarMission]</p>
<p>define function CCarAI__FindPoliceBoatMissionForWantedLevel&lt;cdecl, 0x419880&gt;(): int</p>
<h4>CCarAI::FindPoliceCarMissionForWantedLevel</h4>
<p>plugin::CallAndReturnDynGlobal<eCarMission>(gaddrof(CCarAI::FindPoliceCarMissionForWantedLevel));</p>
<p>0AA7: call_function_return 0x4198C0 num_params 0 pop 0 func_ret [eCarMission]</p>
<p>define function CCarAI__FindPoliceCarMissionForWantedLevel&lt;cdecl, 0x4198C0&gt;(): int</p>
<h4>CCarAI::FindPoliceCarSpeedForWantedLevel</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CCarAI::FindPoliceCarSpeedForWantedLevel), vehicle);</p>
<p>0AA7: call_function_return 0x4196E0 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CCarAI__FindPoliceCarSpeedForWantedLevel&lt;cdecl, 0x4196E0&gt;(vehicle): int</p>
<h4>CCarAI::GetCarToGoToCoors</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToGoToCoors), vehicle, coors);</p>
<p>0AA7: call_function_return 0x419D20 num_params 2 pop 2 [vehicle] [coors] func_ret [float]</p>
<p>define function CCarAI__GetCarToGoToCoors&lt;cdecl, 0x419D20&gt;(vehicle, coors): float</p>
<h4>CCarAI::GetCarToParkAtCoors</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVehicle *, CVector *>(gaddrof(CCarAI::GetCarToParkAtCoors), vehicle, coors);</p>
<p>0AA7: call_function_return 0x419CC0 num_params 2 pop 2 [vehicle] [coors] func_ret [float]</p>
<p>define function CCarAI__GetCarToParkAtCoors&lt;cdecl, 0x419CC0&gt;(vehicle, coors): float</p>
<h4>CCarAI::MakeWayForCarWithSiren</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MakeWayForCarWithSiren), vehicle);</p>
<h4>CCarAI::MellowOutChaseSpeed</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeed), vehicle);</p>
<h4>CCarAI::MellowOutChaseSpeedBoat</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::MellowOutChaseSpeedBoat), vehicle);</p>
<h4>CCarAI::TellCarToRamOtherCar</h4>
<p>plugin::CallDynGlobal<CVehicle *, CVehicle *>(gaddrof(CCarAI::TellCarToRamOtherCar), vehicle, ramVehicle);</p>
<h4>CCarAI::TellOccupantsToFleeCar</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToFleeCar), vehicle);</p>
<h4>CCarAI::TellOccupantsToLeaveCar</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::TellOccupantsToLeaveCar), vehicle);</p>
<h4>CCarAI::UpdateCarAI</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CCarAI::UpdateCarAI), vehicle);</p><h3 id="plugin_vcgame_vcccarctrlcpp">plugin_vc\game_vc\CCarCtrl.cpp</h3><h4>CCarCtrl::AddToLoadedVehicleArray</h4>
<p>plugin::CallAndReturn<int, 0x4267D0, int, int, int>(arg0, arg1, arg2);</p>
<p>0AA7: call_function_return 0x4267D0 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [int]</p>
<p>define function CCarCtrl__AddToLoadedVehicleArray&lt;cdecl, 0x4267D0&gt;(arg0, arg1, arg2): int</p>
<h4>CCarCtrl::AddToVehicleArray</h4>
<p>plugin::CallAndReturn<int, 0x426820, int, int>(arg0, arg1);</p>
<p>0AA7: call_function_return 0x426820 num_params 2 pop 2 [arg0] [arg1] func_ret [int]</p>
<p>define function CCarCtrl__AddToVehicleArray&lt;cdecl, 0x426820&gt;(arg0, arg1): int</p>
<h4>CCarCtrl::ChooseCarModel</h4>
<p>plugin::CallAndReturn<int, 0x426AA0, int>(arg0);</p>
<p>0AA7: call_function_return 0x426AA0 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CCarCtrl__ChooseCarModel&lt;cdecl, 0x426AA0&gt;(arg0): int</p>
<h4>CCarCtrl::ChooseCarModelToLoad</h4>
<p>plugin::CallAndReturn<int, 0x426A30, int>(arg0);</p>
<p>0AA7: call_function_return 0x426A30 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CCarCtrl__ChooseCarModelToLoad&lt;cdecl, 0x426A30&gt;(arg0): int</p>
<h4>CCarCtrl::ChooseCarRating</h4>
<p>plugin::CallAndReturn<int, 0x426D40, CZoneInfo*>(arg0);</p>
<p>0AA7: call_function_return 0x426D40 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CCarCtrl__ChooseCarRating&lt;cdecl, 0x426D40&gt;(arg0): int</p>
<h4>CCarCtrl::ChooseModel</h4>
<p>plugin::CallAndReturn<int, 0x426B40, CZoneInfo<em>, int</em>>(arg0, arg1);</p>
<p>0AA7: call_function_return 0x426B40 num_params 2 pop 2 [arg0] [arg1] func_ret [int]</p>
<p>define function CCarCtrl__ChooseModel&lt;cdecl, 0x426B40&gt;(arg0, arg1): int</p>
<h4>CCarCtrl::ChoosePoliceCarModel</h4>
<p>plugin::CallAndReturn<int, 0x426850>();</p>
<p>0AA7: call_function_return 0x426850 num_params 0 pop 0 func_ret [int]</p>
<p>define function CCarCtrl__ChoosePoliceCarModel&lt;cdecl, 0x426850&gt;(): int</p>
<h4>CCarCtrl::ClearInterestingVehicleList</h4>
<p>plugin::Call<0x41D300>();</p>
<p>0AA5: call_function 0x41D300 num_params 0 pop 0</p>
<p>define function CCarCtrl__ClearInterestingVehicleList&lt;cdecl, 0x41D300&gt;()</p>
<h4>CCarCtrl::DragCarToPoint</h4>
<p>plugin::Call<0x4208B0, CVehicle<em>, CVector</em>>(vehicle, coords);</p>
<p>0AA5: call_function 0x4208B0 num_params 2 pop 2 [vehicle] [coords]</p>
<p>define function CCarCtrl__DragCarToPoint&lt;cdecl, 0x4208B0&gt;(vehicle, coords)</p>
<h4>CCarCtrl::FindAngleToWeaveThroughTraffic</h4>
<p>plugin::CallAndReturn<float, 0x423C00, CVehicle<em>, CPhysical</em>, float, float>(vehicle, physical, arg2, arg3);</p>
<p>0AA7: call_function_return 0x423C00 num_params 4 pop 4 [vehicle] [physical] [arg2] [arg3] func_ret [float]</p>
<p>define function CCarCtrl__FindAngleToWeaveThroughTraffic&lt;cdecl, 0x423C00&gt;(vehicle, physical, arg2, arg3): float</p>
<h4>CCarCtrl::FindLinksToGoWithTheseNodes</h4>
<p>plugin::CallAndReturn<int, 0x41CC20, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x41CC20 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CCarCtrl__FindLinksToGoWithTheseNodes&lt;cdecl, 0x41CC20&gt;(vehicle): int</p>
<h4>CCarCtrl::FindMaximumSpeedForThisCarInTraffic</h4>
<p>plugin::CallAndReturn<float, 0x425880, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x425880 num_params 1 pop 1 [vehicle] func_ret [float]</p>
<p>define function CCarCtrl__FindMaximumSpeedForThisCarInTraffic&lt;cdecl, 0x425880&gt;(vehicle): float</p>
<h4>CCarCtrl::FindPathDirection</h4>
<p>plugin::CallAndReturn<char, 0x421DC0, int, int, int>(arg0, arg1, arg2);</p>
<p>0AA7: call_function_return 0x421DC0 num_params 3 pop 3 [arg0] [arg1] [arg2] func_ret [char]</p>
<p>define function CCarCtrl__FindPathDirection&lt;cdecl, 0x421DC0&gt;(arg0, arg1, arg2): int</p>
<h4>CCarCtrl::GenerateEmergencyServicesCar</h4>
<p>plugin::Call<0x41C940>();</p>
<p>0AA5: call_function 0x41C940 num_params 0 pop 0</p>
<p>define function CCarCtrl__GenerateEmergencyServicesCar&lt;cdecl, 0x41C940&gt;()</p>
<h4>CCarCtrl::GenerateOneEmergencyServicesCar</h4>
<p>plugin::CallAndReturn<bool, 0x41C460, unsigned int, CVector>(model, driveToCoord);</p>
<p>0AA7: call_function_return 0x41C460 num_params 2 pop 2 [model] [driveToCoord] func_ret [bool]</p>
<p>define function CCarCtrl__GenerateOneEmergencyServicesCar&lt;cdecl, 0x41C460&gt;(model, driveToCoord): int</p>
<h4>CCarCtrl::GenerateOneRandomCar</h4>
<p>plugin::Call<0x426DB0>();</p>
<p>0AA5: call_function 0x426DB0 num_params 0 pop 0</p>
<p>define function CCarCtrl__GenerateOneRandomCar&lt;cdecl, 0x426DB0&gt;()</p>
<h4>CCarCtrl::GenerateRandomCars</h4>
<p>plugin::Call<0x4292A0>();</p>
<p>0AA5: call_function 0x4292A0 num_params 0 pop 0</p>
<p>define function CCarCtrl__GenerateRandomCars&lt;cdecl, 0x4292A0&gt;()</p>
<h4>CCarCtrl::Init</h4>
<p>plugin::Call<0x4293D0>();</p>
<p>0AA5: call_function 0x4293D0 num_params 0 pop 0</p>
<p>define function CCarCtrl__Init&lt;cdecl, 0x4293D0&gt;()</p>
<h4>CCarCtrl::IsThisVehicleInteresting</h4>
<p>plugin::CallAndReturn<bool, 0x41D350, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x41D350 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarCtrl__IsThisVehicleInteresting&lt;cdecl, 0x41D350&gt;(vehicle): int</p>
<h4>CCarCtrl::JoinCarWithRoadSystem</h4>
<p>plugin::Call<0x41D000, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x41D000 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__JoinCarWithRoadSystem&lt;cdecl, 0x41D000&gt;(vehicle)</p>
<h4>CCarCtrl::JoinCarWithRoadSystemGotoCoors</h4>
<p>plugin::CallAndReturn<bool, 0x41CEB0, CVehicle*, CVector, bool>(vehicle, arg1, arg2);</p>
<p>0AA7: call_function_return 0x41CEB0 num_params 3 pop 3 [vehicle] [arg1] [arg2] func_ret [bool]</p>
<p>define function CCarCtrl__JoinCarWithRoadSystemGotoCoors&lt;cdecl, 0x41CEB0&gt;(vehicle, arg1, arg2): int</p>
<h4>CCarCtrl::MapCouldMoveInThisArea</h4>
<p>plugin::CallAndReturn<bool, 0x41C2F0, float, float>(arg0, arg1);</p>
<p>0AA7: call_function_return 0x41C2F0 num_params 2 pop 2 [arg0] [arg1] func_ret [bool]</p>
<p>define function CCarCtrl__MapCouldMoveInThisArea&lt;cdecl, 0x41C2F0&gt;(arg0, arg1): int</p>
<h4>CCarCtrl::PickNextNodeAccordingStrategy</h4>
<p>plugin::CallAndReturn<char, 0x422A10, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x422A10 num_params 1 pop 1 [vehicle] func_ret [char]</p>
<p>define function CCarCtrl__PickNextNodeAccordingStrategy&lt;cdecl, 0x422A10&gt;(vehicle): int</p>
<h4>CCarCtrl::PickNextNodeRandomly</h4>
<p>plugin::CallAndReturn<int, 0x421F70, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x421F70 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CCarCtrl__PickNextNodeRandomly&lt;cdecl, 0x421F70&gt;(vehicle): int</p>
<h4>CCarCtrl::PickNextNodeToChaseCar</h4>
<p>plugin::CallAndReturn<int, 0x4213A0, CVehicle<em>, float, float, CVehicle</em>>(vehicle, arg1, arg2, arg3);</p>
<p>0AA7: call_function_return 0x4213A0 num_params 4 pop 4 [vehicle] [arg1] [arg2] [arg3] func_ret [int]</p>
<p>define function CCarCtrl__PickNextNodeToChaseCar&lt;cdecl, 0x4213A0&gt;(vehicle, arg1, arg2, arg3): int</p>
<h4>CCarCtrl::PickNextNodeToFollowPath</h4>
<p>plugin::CallAndReturn<bool, 0x420D50, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x420D50 num_params 1 pop 1 [vehicle] func_ret [bool]</p>
<p>define function CCarCtrl__PickNextNodeToFollowPath&lt;cdecl, 0x420D50&gt;(vehicle): int</p>
<h4>CCarCtrl::PossiblyRemoveVehicle</h4>
<p>plugin::Call<0x426030, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x426030 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__PossiblyRemoveVehicle&lt;cdecl, 0x426030&gt;(vehicle)</p>
<h4>CCarCtrl::ReInit</h4>
<p>plugin::Call<0x429320>();</p>
<p>0AA5: call_function 0x429320 num_params 0 pop 0</p>
<p>define function CCarCtrl__ReInit&lt;cdecl, 0x429320&gt;()</p>
<h4>CCarCtrl::RegisterVehicleOfInterest</h4>
<p>plugin::Call<0x41D370, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x41D370 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__RegisterVehicleOfInterest&lt;cdecl, 0x41D370&gt;(vehicle)</p>
<h4>CCarCtrl::RemoveCarsIfThePoolGetsFull</h4>
<p>plugin::Call<0x4264C0>();</p>
<p>0AA5: call_function 0x4264C0 num_params 0 pop 0</p>
<p>define function CCarCtrl__RemoveCarsIfThePoolGetsFull&lt;cdecl, 0x4264C0&gt;()</p>
<h4>CCarCtrl::RemoveDistantCars</h4>
<p>plugin::Call<0x426640>();</p>
<p>0AA5: call_function 0x426640 num_params 0 pop 0</p>
<p>define function CCarCtrl__RemoveDistantCars&lt;cdecl, 0x426640&gt;()</p>
<h4>CCarCtrl::RemoveFromInterestingVehicleList</h4>
<p>plugin::Call<0x41D320, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x41D320 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__RemoveFromInterestingVehicleList&lt;cdecl, 0x41D320&gt;(vehicle)</p>
<h4>CCarCtrl::RemoveFromLoadedVehicleArray</h4>
<p>plugin::Call<0x426740, int, int>(arg0, arg1);</p>
<p>0AA5: call_function 0x426740 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CCarCtrl__RemoveFromLoadedVehicleArray&lt;cdecl, 0x426740&gt;(arg0, arg1)</p>
<h4>CCarCtrl::ScanForPedDanger</h4>
<p>plugin::Call<0x4255E0, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x4255E0 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__ScanForPedDanger&lt;cdecl, 0x4255E0&gt;(vehicle)</p>
<h4>CCarCtrl::SlowCarDownForCarsSectorList</h4>
<p>plugin::Call<0x424B50, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA5: call_function 0x424B50 num_params 8 pop 8 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]</p>
<p>define function CCarCtrl__SlowCarDownForCarsSectorList&lt;cdecl, 0x424B50&gt;(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7)</p>
<h4>CCarCtrl::SlowCarDownForOtherCar</h4>
<p>plugin::Call<0x424780, CEntity<em>, CVehicle</em>, float*, float>(entity, vehicle, arg2, arg3);</p>
<p>0AA5: call_function 0x424780 num_params 4 pop 4 [entity] [vehicle] [arg2] [arg3]</p>
<p>define function CCarCtrl__SlowCarDownForOtherCar&lt;cdecl, 0x424780&gt;(entity, vehicle, arg2, arg3)</p>
<h4>CCarCtrl::SlowCarDownForPedsSectorList</h4>
<p>plugin::Call<0x424C70, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA5: call_function 0x424C70 num_params 8 pop 8 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]</p>
<p>define function CCarCtrl__SlowCarDownForPedsSectorList&lt;cdecl, 0x424C70&gt;(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7)</p>
<h4>CCarCtrl::SlowCarOnRailsDownForTrafficAndLights</h4>
<p>plugin::Call<0x4254C0, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x4254C0 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__SlowCarOnRailsDownForTrafficAndLights&lt;cdecl, 0x4254C0&gt;(vehicle)</p>
<h4>CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer</h4>
<p>plugin::Call<0x41DFA0, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(vehicle, arg1, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x41DFA0 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CCarCtrl__SteerAIBoatWithPhysicsAttackingPlayer&lt;cdecl, 0x41DFA0&gt;(vehicle, arg1, arg2, arg3, arg4)</p>
<h4>CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget</h4>
<p>plugin::Call<0x41E2D0, CVehicle<em>, float, float, float</em>, float<em>, float</em>>(vehicle, arg1, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x41E2D0 num_params 6 pop 6 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CCarCtrl__SteerAIBoatWithPhysicsHeadingForTarget&lt;cdecl, 0x41E2D0&gt;(vehicle, arg1, arg2, arg3, arg4, arg5)</p>
<h4>CCarCtrl::SteerAICarBlockingPlayerForwardAndBack</h4>
<p>plugin::Call<0x41E520, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(vehicle, arg1, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x41E520 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CCarCtrl__SteerAICarBlockingPlayerForwardAndBack&lt;cdecl, 0x41E520&gt;(vehicle, arg1, arg2, arg3, arg4)</p>
<h4>CCarCtrl::SteerAICarWithPhysics</h4>
<p>plugin::Call<0x420580, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x420580 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__SteerAICarWithPhysics&lt;cdecl, 0x420580&gt;(vehicle)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsFollowPath</h4>
<p>plugin::Call<0x41EEE0, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(vehicle, arg1, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x41EEE0 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsFollowPath&lt;cdecl, 0x41EEE0&gt;(vehicle, arg1, arg2, arg3, arg4)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsHeadingForTarget</h4>
<p>plugin::Call<0x41EAB0, CVehicle<em>, CPhysical</em>, float, float, float<em>, float</em>, float<em>, bool</em>>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA5: call_function 0x41EAB0 num_params 8 pop 8 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsHeadingForTarget&lt;cdecl, 0x41EAB0&gt;(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7)</p>
<h4>CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop</h4>
<p>plugin::Call<0x41E830, CVehicle<em>, float, float, float, float, float</em>, float<em>, float</em>, bool*>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x41E830 num_params 9 pop 9 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__SteerAICarWithPhysicsTryingToBlockTarget_Stop&lt;cdecl, 0x41E830&gt;(vehicle, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::SteerAICarWithPhysics_OnlyMission</h4>
<p>plugin::Call<0x41FD10, CVehicle<em>, float</em>, float<em>, float</em>, bool*>(vehicle, arg1, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x41FD10 num_params 5 pop 5 [vehicle] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CCarCtrl__SteerAICarWithPhysics_OnlyMission&lt;cdecl, 0x41FD10&gt;(vehicle, arg1, arg2, arg3, arg4)</p>
<h4>CCarCtrl::SteerAIHeliTowardsTargetCoors</h4>
<p>plugin::Call<0x41D900, CAutomobile*>(automobile);</p>
<p>0AA5: call_function 0x41D900 num_params 1 pop 1 [automobile]</p>
<p>define function CCarCtrl__SteerAIHeliTowardsTargetCoors&lt;cdecl, 0x41D900&gt;(automobile)</p>
<h4>CCarCtrl::SteerAIPlaneTowardsTargetCoors</h4>
<p>plugin::Call<0x41D410, CAutomobile*>(automobile);</p>
<p>0AA5: call_function 0x41D410 num_params 1 pop 1 [automobile]</p>
<p>define function CCarCtrl__SteerAIPlaneTowardsTargetCoors&lt;cdecl, 0x41D410&gt;(automobile)</p>
<h4>CCarCtrl::SwitchVehicleToRealPhysics</h4>
<p>plugin::Call<0x41D2D0, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x41D2D0 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__SwitchVehicleToRealPhysics&lt;cdecl, 0x41D2D0&gt;(vehicle)</p>
<h4>CCarCtrl::TestCollisionBetween2MovingRects</h4>
<p>plugin::CallAndReturn<float, 0x424210, CVehicle<em>, CVehicle</em>, float, float, CVector<em>, CVector</em>, unsigned char>(vehicle, arg1, arg2, arg3, arg4, arg5, arg6);</p>
<p>0AA7: call_function_return 0x424210 num_params 7 pop 7 [vehicle] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] func_ret [float]</p>
<p>define function CCarCtrl__TestCollisionBetween2MovingRects&lt;cdecl, 0x424210&gt;(vehicle, arg1, arg2, arg3, arg4, arg5, arg6): float</p>
<h4>CCarCtrl::UpdateCarCount</h4>
<p>plugin::Call<0x41C350, CVehicle*, unsigned char>(vehicle, arg1);</p>
<p>0AA5: call_function 0x41C350 num_params 2 pop 2 [vehicle] [arg1]</p>
<p>define function CCarCtrl__UpdateCarCount&lt;cdecl, 0x41C350&gt;(vehicle, arg1)</p>
<h4>CCarCtrl::UpdateCarOnRails</h4>
<p>plugin::Call<0x425BF0, CVehicle*>(vehicle);</p>
<p>0AA5: call_function 0x425BF0 num_params 1 pop 1 [vehicle]</p>
<p>define function CCarCtrl__UpdateCarOnRails&lt;cdecl, 0x425BF0&gt;(vehicle)</p>
<h4>CCarCtrl::WeaveThroughCarsSectorList</h4>
<p>plugin::Call<0x423490, CPtrList&, CVehicle<em>, CPhysical</em>, float, float, float, float, float<em>, float</em>>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x423490 num_params 9 pop 9 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__WeaveThroughCarsSectorList&lt;cdecl, 0x423490&gt;(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CCarCtrl::WeaveThroughObjectsSectorList</h4>
<p>plugin::Call<0x422B00, CPtrList&, CVehicle<em>, float, float, float, float, float</em>, float*>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA5: call_function 0x422B00 num_params 8 pop 8 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7]</p>
<p>define function CCarCtrl__WeaveThroughObjectsSectorList&lt;cdecl, 0x422B00&gt;(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7)</p>
<h4>CCarCtrl::WeaveThroughPedsSectorList</h4>
<p>plugin::Call<0x4230F0, CPtrList&, CVehicle<em>, CPhysical</em>, float, float, float, float, float<em>, float</em>>(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x4230F0 num_params 9 pop 9 [ptrlist] [vehicle] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CCarCtrl__WeaveThroughPedsSectorList&lt;cdecl, 0x4230F0&gt;(ptrlist, vehicle, arg2, arg3, arg4, arg5, arg6, arg7, arg8)</p><h3 id="plugin_vcgame_vcccargeneratorcpp">plugin_vc\game_vc\CCarGenerator.cpp</h3><h4>CCarGenerator::CheckForBlockage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A6FC0, CCarGenerator *, int>(this, modelId);</p>
<p>0AA8: call_method_return 0x5A6FC0 struct [CCarGenerator] num_params 1 pop 0 [modelId] func_ret [bool]</p>
<p>define function CCarGenerator__CheckForBlockage&lt;thiscall, 0x5A6FC0&gt;(modelId): int</p>
<h4>CCarGenerator::CheckIfWithinRangeOfAnyPlayers</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A6D00, CCarGenerator *>(this);</p>
<p>0AA8: call_method_return 0x5A6D00 struct [CCarGenerator] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CCarGenerator__CheckIfWithinRangeOfAnyPlayers&lt;thiscall, 0x5A6D00&gt;(): int</p>
<h4>CCarGenerator::DoInternalProcessing</h4>
<p>plugin::CallMethod<0x5A71C0, CCarGenerator *>(this);</p>
<p>0AA6: call_method 0x5A71C0 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__DoInternalProcessing&lt;thiscall, 0x5A71C0&gt;()</p>
<h4>CCarGenerator::Process</h4>
<p>plugin::CallMethod<0x5A7130, CCarGenerator *>(this);</p>
<p>0AA6: call_method 0x5A7130 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__Process&lt;thiscall, 0x5A7130&gt;()</p>
<h4>CCarGenerator::Setup</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A70B0, CCarGenerator *, float, float, float, float, int, short, short, unsigned char, unsigned char, unsigned char, unsigned short, unsigned short>(this, x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay);</p>
<p>0AA8: call_method_return 0x5A70B0 struct [CCarGenerator] num_params 12 pop 0 [x] [y] [z] [angle] [modelId] [primaryColor] [secondaryColor] [forceSpawn] [alarm] [doorLock] [minDelay] [maxDelay] func_ret [unsigned int]</p>
<p>define function CCarGenerator__Setup&lt;thiscall, 0x5A70B0&gt;(x, y, z, angle, modelId, primaryColor, secondaryColor, forceSpawn, alarm, doorLock, minDelay, maxDelay): int</p>
<h4>CCarGenerator::SwitchOff</h4>
<p>plugin::CallMethod<0x5A7670, CCarGenerator *>(this);</p>
<p>0AA6: call_method 0x5A7670 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__SwitchOff&lt;thiscall, 0x5A7670&gt;()</p>
<h4>CCarGenerator::SwitchOn</h4>
<p>plugin::CallMethod<0x5A7650, CCarGenerator *>(this);</p>
<p>0AA6: call_method 0x5A7650 struct [CCarGenerator] num_params 0 pop 0</p>
<p>define function CCarGenerator__SwitchOn&lt;thiscall, 0x5A7650&gt;()</p><h3 id="plugin_vcgame_vcccivilianpedcpp">plugin_vc\game_vc\CCivilianPed.cpp</h3><h4>CCivilianPed::CCivilianPed</h4>
<p>plugin::CallMethod<0x4EAE00, CCivilianPed *, ePedType, unsigned int>(this, pedType, modelIndex);</p>
<p>0AA6: call_method 0x4EAE00 struct [CCivilianPed] num_params 2 pop 0 [pedType] [modelIndex]</p>
<p>define function CCivilianPed__CCivilianPed&lt;thiscall, 0x4EAE00&gt;(pedType, modelIndex)</p>
<h4>CCivilianPed::CivilianAI</h4>
<p>plugin::CallMethod<0x4E8E20, CCivilianPed *>(this);</p>
<p>0AA6: call_method 0x4E8E20 struct [CCivilianPed] num_params 0 pop 0</p>
<p>define function CCivilianPed__CivilianAI&lt;thiscall, 0x4E8E20&gt;()</p>
<h4>CCivilianPed::EnterVacantNearbyCars</h4>
<p>plugin::CallMethod<0x4E99C0, CCivilianPed *>(this);</p>
<p>0AA6: call_method 0x4E99C0 struct [CCivilianPed] num_params 0 pop 0</p>
<p>define function CCivilianPed__EnterVacantNearbyCars&lt;thiscall, 0x4E99C0&gt;()</p>
<h4>CCivilianPed::UseNearbyAttractors</h4>
<p>plugin::CallMethod<0x4E9E90, CCivilianPed *>(this);</p>
<p>0AA6: call_method 0x4E9E90 struct [CCivilianPed] num_params 0 pop 0</p>
<p>define function CCivilianPed__UseNearbyAttractors&lt;thiscall, 0x4E9E90&gt;()</p><h3 id="plugin_vcgame_vccclockcpp">plugin_vc\game_vc\CClock.cpp</h3><h4>CClock::GetGameClockMinutesUntil</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, unsigned char, unsigned char>(gaddrof(CClock::GetGameClockMinutesUntil), hours, minutes);</p>
<p>0AA7: call_function_return 0x487130 num_params 2 pop 2 [hours] [minutes] func_ret [unsigned int]</p>
<p>define function CClock__GetGameClockMinutesUntil&lt;cdecl, 0x487130&gt;(hours, minutes): int</p>
<h4>CClock::GetIsTimeInRange</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned char, unsigned char>(gaddrof(CClock::GetIsTimeInRange), hourA, hourB);</p>
<p>0AA7: call_function_return 0x4870F0 num_params 2 pop 2 [hourA] [hourB] func_ret [bool]</p>
<p>define function CClock__GetIsTimeInRange&lt;cdecl, 0x4870F0&gt;(hourA, hourB): int</p>
<h4>CClock::Initialise</h4>
<p>plugin::CallDynGlobal<unsigned int>(gaddrof(CClock::Initialise), milisecondsPerGameMinute);</p>
<h4>CClock::SetGameClock</h4>
<p>plugin::CallDynGlobal<unsigned char, unsigned char>(gaddrof(CClock::SetGameClock), hours, minutes);</p><h3 id="plugin_vcgame_vcccloudscpp">plugin_vc\game_vc\CClouds.cpp</h3><h4>CClouds::Init</h4>
<p>plugin::Call<0x540FB0>();</p>
<p>0AA5: call_function 0x540FB0 num_params 0 pop 0</p>
<p>define function CClouds__Init&lt;cdecl, 0x540FB0&gt;()</p>
<h4>CClouds::Render</h4>
<p>plugin::Call<0x53FC50>();</p>
<p>0AA5: call_function 0x53FC50 num_params 0 pop 0</p>
<p>define function CClouds__Render&lt;cdecl, 0x53FC50&gt;()</p>
<h4>CClouds::RenderBackground</h4>
<p>plugin::Call<0x53F650, short, short, short, short, short, short, short>(arg0, arg1, arg2, arg3, arg4, arg5, arg6);</p>
<p>0AA5: call_function 0x53F650 num_params 7 pop 7 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6]</p>
<p>define function CClouds__RenderBackground&lt;cdecl, 0x53F650&gt;(arg0, arg1, arg2, arg3, arg4, arg5, arg6)</p>
<h4>CClouds::RenderHorizon</h4>
<p>plugin::Call<0x53F380>();</p>
<p>0AA5: call_function 0x53F380 num_params 0 pop 0</p>
<p>define function CClouds__RenderHorizon&lt;cdecl, 0x53F380&gt;()</p>
<h4>CClouds::Shutdown</h4>
<p>plugin::Call<0x540F40>();</p>
<p>0AA5: call_function 0x540F40 num_params 0 pop 0</p>
<p>define function CClouds__Shutdown&lt;cdecl, 0x540F40&gt;()</p>
<h4>CClouds::Update</h4>
<p>plugin::Call<0x540E90>();</p>
<p>0AA5: call_function 0x540E90 num_params 0 pop 0</p>
<p>define function CClouds__Update&lt;cdecl, 0x540E90&gt;()</p><h3 id="plugin_vcgame_vccclumpmodelinfocpp">plugin_vc\game_vc\CClumpModelInfo.cpp</h3><h4>CClumpModelInfo::SetClump</h4>
<p>plugin::CallVirtualMethod<9, CClumpModelInfo <em>, RpClump</em>>(this, clump);</p>
<h4>CClumpModelInfo::CClumpModelInfo</h4>
<p>plugin::CallMethod<0x5601C0, CClumpModelInfo *>(this);</p>
<p>0AA6: call_method 0x5601C0 struct [CClumpModelInfo] num_params 0 pop 0</p>
<p>define function CClumpModelInfo__CClumpModelInfo&lt;thiscall, 0x5601C0&gt;()</p>
<h4>CClumpModelInfo::FillFrameArray</h4>
<p>plugin::Call<0x541100, RpClump<em>, RwFrame</em>*>(clump, frames);</p>
<p>0AA5: call_function 0x541100 num_params 2 pop 2 [clump] [frames]</p>
<p>define function CClumpModelInfo__FillFrameArray&lt;cdecl, 0x541100&gt;(clump, frames)</p>
<h4>CClumpModelInfo::FindFrameFromIdCB</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x541160, RwFrame</em>, void*>(frame, searchData);</p>
<p>0AA7: call_function_return 0x541160 num_params 2 pop 2 [frame] [searchData] func_ret [RwFrame*]</p>
<p>define function CClumpModelInfo__FindFrameFromIdCB&lt;cdecl, 0x541160&gt;(frame, searchData): int</p>
<h4>CClumpModelInfo::FindFrameFromNameCB</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x5411E0, RwFrame</em>, void*>(frame, searchData);</p>
<p>0AA7: call_function_return 0x5411E0 num_params 2 pop 2 [frame] [searchData] func_ret [RwFrame*]</p>
<p>define function CClumpModelInfo__FindFrameFromNameCB&lt;cdecl, 0x5411E0&gt;(frame, searchData): int</p>
<h4>CClumpModelInfo::FindFrameFromNameWithoutIdCB</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x541190, RwFrame</em>, void*>(frame, searchData);</p>
<p>0AA7: call_function_return 0x541190 num_params 2 pop 2 [frame] [searchData] func_ret [RwFrame*]</p>
<p>define function CClumpModelInfo__FindFrameFromNameWithoutIdCB&lt;cdecl, 0x541190&gt;(frame, searchData): int</p>
<h4>CClumpModelInfo::GetFrameFromId</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x541120, RpClump</em>, int>(clump, id);</p>
<p>0AA7: call_function_return 0x541120 num_params 2 pop 2 [clump] [id] func_ret [RwFrame*]</p>
<p>define function CClumpModelInfo__GetFrameFromId&lt;cdecl, 0x541120&gt;(clump, id): int</p>
<h4>CClumpModelInfo::SetAtomicRendererCB</h4>
<p>plugin::Call<0x5412A0, RpAtomic<em>, void</em>>(atomic, renderFunc);</p>
<p>0AA5: call_function 0x5412A0 num_params 2 pop 2 [atomic] [renderFunc]</p>
<p>define function CClumpModelInfo__SetAtomicRendererCB&lt;cdecl, 0x5412A0&gt;(atomic, renderFunc)</p>
<h4>CClumpModelInfo::SetFrameIds</h4>
<p>plugin::CallMethod<0x541090, CClumpModelInfo <em>, RwObjectNameIdAssocation</em>>(this, data);</p>
<p>0AA6: call_method 0x541090 struct [CClumpModelInfo] num_params 1 pop 0 [data]</p>
<p>define function CClumpModelInfo__SetFrameIds&lt;thiscall, 0x541090&gt;(data)</p>
<h4>ClumpModelStore::~ClumpModelStore</h4>
<p>plugin::CallMethod<0x560190, ClumpModelStore *>(this);</p>
<p>0AA6: call_method 0x560190 struct [ClumpModelStore] num_params 0 pop 0</p>
<p>define function ClumpModelStore__~ClumpModelStore&lt;thiscall, 0x560190&gt;()</p><h3 id="plugin_vcgame_vcccolboxcpp">plugin_vc\game_vc\CColBox.cpp</h3><h4>CColBox::Set</h4>
<p>plugin::CallMethod<0x4108D0, CColBox *, CVector const&, CVector const&, unsigned char, unsigned char>(this, sup, inf, material, flags);</p>
<p>0AA6: call_method 0x4108D0 struct [CColBox] num_params 4 pop 0 [sup] [inf] [material] [flags]</p>
<p>define function CColBox__Set&lt;thiscall, 0x4108D0&gt;(sup, inf, material, flags)</p>
<h4>CColBox::operator=</h4>
<p>plugin::CallMethod<0x410890, CColBox *, CColBox const&>(this, right);</p>
<p>0AA6: call_method 0x410890 struct [CColBox] num_params 1 pop 0 [right]</p>
<p>define function CColBox__operator=&lt;thiscall, 0x410890&gt;(right)</p><h3 id="plugin_vcgame_vcccollinecpp">plugin_vc\game_vc\CColLine.cpp</h3><h4>CColLine::CColLine</h4>
<p>plugin::CallMethod<0x410940, CColLine *, CVector const&, CVector const&>(this, start, end);</p>
<p>0AA6: call_method 0x410940 struct [CColLine] num_params 2 pop 0 [start] [end]</p>
<p>define function CColLine__CColLine&lt;thiscall, 0x410940&gt;(start, end)</p><h3 id="plugin_vcgame_vcccolmodelcpp">plugin_vc\game_vc\CColModel.cpp</h3><h4>CColModel::CColModel</h4>
<p>plugin::CallMethod<0x417120, CColModel *>(this);</p>
<p>0AA6: call_method 0x417120 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__CColModel&lt;thiscall, 0x417120&gt;()</p>
<h4>CColModel::CalculateTrianglePlanes</h4>
<p>plugin::CallMethod<0x416AE0, CColModel *>(this);</p>
<p>0AA6: call_method 0x416AE0 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__CalculateTrianglePlanes&lt;thiscall, 0x416AE0&gt;()</p>
<h4>CColModel::GetLinkPtr</h4>
<p>plugin::CallMethodAndReturn<int, 0x416A70, CColModel *>(this);</p>
<p>0AA8: call_method_return 0x416A70 struct [CColModel] num_params 0 pop 0 func_ret [int]</p>
<p>define function CColModel__GetLinkPtr&lt;thiscall, 0x416A70&gt;(): int</p>
<h4>CColModel::GetTrianglePoint</h4>
<p>plugin::CallMethodAndReturn<int, 0x416B40, CColModel *, CVector&, int>(this, arg0, arg1);</p>
<p>0AA8: call_method_return 0x416B40 struct [CColModel] num_params 2 pop 0 [arg0] [arg1] func_ret [int]</p>
<p>define function CColModel__GetTrianglePoint&lt;thiscall, 0x416B40&gt;(arg0, arg1): int</p>
<h4>CColModel::RemoveCollisionVolumes</h4>
<p>plugin::CallMethod<0x4169B0, CColModel *>(this);</p>
<p>0AA6: call_method 0x4169B0 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__RemoveCollisionVolumes&lt;thiscall, 0x4169B0&gt;()</p>
<h4>CColModel::RemoveTrianglePlanes</h4>
<p>plugin::CallMethod<0x416AB0, CColModel *>(this);</p>
<p>0AA6: call_method 0x416AB0 struct [CColModel] num_params 0 pop 0</p>
<p>define function CColModel__RemoveTrianglePlanes&lt;thiscall, 0x416AB0&gt;()</p>
<h4>CColModel::operator delete</h4>
<p>plugin::Call<0x4170E0, void*>(data);</p>
<p>0AA5: call_function 0x4170E0 num_params 1 pop 1 [data]</p>
<p>define function CColModel__operator delete&lt;cdecl, 0x4170E0&gt;(data)</p>
<h4>CColModel::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x417100, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x417100 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CColModel__operator new&lt;cdecl, 0x417100&gt;(size): int</p>
<h4>CColModel::operator=</h4>
<p>plugin::CallMethod<0x416B80, CColModel *, CColModel const&>(this, arg0);</p>
<p>0AA6: call_method 0x416B80 struct [CColModel] num_params 1 pop 0 [arg0]</p>
<p>define function CColModel__operator=&lt;thiscall, 0x416B80&gt;(arg0)</p><h3 id="plugin_vcgame_vcccolspherecpp">plugin_vc\game_vc\CColSphere.cpp</h3><h4>CColSphere::IntersectRay</h4>
<p>plugin::CallMethodAndReturn<bool, 0x417260, CColSphere *, CVector const&, CVector const&, CVector&, CVector&>(this, rayStart, rayEnd, intPoint1, intPoint2);</p>
<p>0AA8: call_method_return 0x417260 struct [CColSphere] num_params 4 pop 0 [rayStart] [rayEnd] [intPoint1] [intPoint2] func_ret [bool]</p>
<p>define function CColSphere__IntersectRay&lt;thiscall, 0x417260&gt;(rayStart, rayEnd, intPoint1, intPoint2): int</p>
<h4>CColSphere::Set</h4>
<p>plugin::CallMethod<0x4173A0, CColSphere *, float, CVector const&, unsigned char, unsigned char>(this, radius, center, material, flags);</p>
<p>0AA6: call_method 0x4173A0 struct [CColSphere] num_params 4 pop 0 [radius] [center] [material] [flags]</p>
<p>define function CColSphere__Set&lt;thiscall, 0x4173A0&gt;(radius, center, material, flags)</p><h3 id="plugin_vcgame_vcccontrollerstatecpp">plugin_vc\game_vc\CControllerState.cpp</h3><h4>CControllerState::CheckForInput</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CControllerState *>(gaddrof(CControllerState::CheckForInput), this);</p>
<p>0AA8: call_method_return 0x4AE470 struct [CControllerState] num_params 0 pop 0 func_ret [bool]</p><h3 id="plugin_vcgame_vcccoppedcpp">plugin_vc\game_vc\CCopPed.cpp</h3><h4>CCopPed::ArrestPlayer</h4>
<p>plugin::CallMethod<0x4EB470, CCopPed *>(this);</p>
<p>0AA6: call_method 0x4EB470 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ArrestPlayer&lt;thiscall, 0x4EB470&gt;()</p>
<h4>CCopPed::CCopPed</h4>
<p>plugin::CallMethod<0x4ED720, CCopPed *, eCopType, int>(this, copType, arg1);</p>
<p>0AA6: call_method 0x4ED720 struct [CCopPed] num_params 2 pop 0 [copType] [arg1]</p>
<p>define function CCopPed__CCopPed&lt;thiscall, 0x4ED720&gt;(copType, arg1)</p>
<h4>CCopPed::ClearPursuit</h4>
<p>plugin::CallMethod<0x4EB770, CCopPed *>(this);</p>
<p>0AA6: call_method 0x4EB770 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ClearPursuit&lt;thiscall, 0x4EB770&gt;()</p>
<h4>CCopPed::CopAI</h4>
<p>plugin::CallMethod<0x4EBC10, CCopPed *>(this);</p>
<p>0AA6: call_method 0x4EBC10 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__CopAI&lt;thiscall, 0x4EBC10&gt;()</p>
<h4>CCopPed::ProcessHeliSwat</h4>
<p>plugin::CallMethod<0x4EB280, CCopPed *>(this);</p>
<p>0AA6: call_method 0x4EB280 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ProcessHeliSwat&lt;thiscall, 0x4EB280&gt;()</p>
<h4>CCopPed::ProcessStingerCop</h4>
<p>plugin::CallMethod<0x4EB010, CCopPed *>(this);</p>
<p>0AA6: call_method 0x4EB010 struct [CCopPed] num_params 0 pop 0</p>
<p>define function CCopPed__ProcessStingerCop&lt;thiscall, 0x4EB010&gt;()</p>
<h4>CCopPed::ScanForCrimes</h4>
<p>plugin::CallMethodAndReturn<int, 0x4EBAD0, CCopPed *>(this);</p>
<p>0AA8: call_method_return 0x4EBAD0 struct [CCopPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CCopPed__ScanForCrimes&lt;thiscall, 0x4EBAD0&gt;(): int</p>
<h4>CCopPed::SetArrestPlayer</h4>
<p>plugin::CallMethod<0x4EB5F0, CCopPed <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x4EB5F0 struct [CCopPed] num_params 1 pop 0 [ped]</p>
<p>define function CCopPed__SetArrestPlayer&lt;thiscall, 0x4EB5F0&gt;(ped)</p>
<h4>CCopPed::SetPursuit</h4>
<p>plugin::CallMethod<0x4EB9C0, CCopPed *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x4EB9C0 struct [CCopPed] num_params 1 pop 0 [arg0]</p>
<p>define function CCopPed__SetPursuit&lt;thiscall, 0x4EB9C0&gt;(arg0)</p><h3 id="plugin_vcgame_vcccoronascpp">plugin_vc\game_vc\CCoronas.cpp</h3><h4>CCoronas::DoSunAndMoon</h4>
<p>plugin::Call<0x542210>();</p>
<p>0AA5: call_function 0x542210 num_params 0 pop 0</p>
<p>define function CCoronas__DoSunAndMoon&lt;cdecl, 0x542210&gt;()</p>
<h4>CCoronas::UpdateCoronaCoors</h4>
<p>plugin::Call<0x5423E0, unsigned int, CVector const&, float, float>(id, posn, farClip, angle);</p>
<p>0AA5: call_function 0x5423E0 num_params 4 pop 4 [id] [posn] [farClip] [angle]</p>
<p>define function CCoronas__UpdateCoronaCoors&lt;cdecl, 0x5423E0&gt;(id, posn, farClip, angle)</p>
<h4>CCoronas::RegisterCorona</h4>
<p>plugin::Call<0x542490, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, RwTexture*, unsigned char, unsigned char, unsigned char, unsigned char, float, bool, float>(coronaId, red, green, blue, alpha, pos, radius, farClip, texture, flare, reflection, arg11, arg12, normalAngle, arg14, arg15);</p>
<p>0AA5: call_function 0x542490 num_params 16 pop 16 [coronaId] [red] [green] [blue] [alpha] [pos] [radius] [farClip] [texture] [flare] [reflection] [arg11] [arg12] [normalAngle] [arg14] [arg15]</p>
<p>define function CCoronas__RegisterCorona&lt;cdecl, 0x542490&gt;(coronaId, red, green, blue, alpha, pos, radius, farClip, texture, flare, reflection, arg11, arg12, normalAngle, arg14, arg15)</p>
<h4>CCoronas::RegisterCorona</h4>
<p>plugin::Call<0x5427A0, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, float, bool, float>(coronaId, red, green, blue, alpha, pos, radius, farClip, arg8, flare, reflection, arg11, arg12, normalAngle, arg14, arg15);</p>
<p>0AA5: call_function 0x5427A0 num_params 16 pop 16 [coronaId] [red] [green] [blue] [alpha] [pos] [radius] [farClip] [arg8] [flare] [reflection] [arg11] [arg12] [normalAngle] [arg14] [arg15]</p>
<p>define function CCoronas__RegisterCorona&lt;cdecl, 0x5427A0&gt;(coronaId, red, green, blue, alpha, pos, radius, farClip, arg8, flare, reflection, arg11, arg12, normalAngle, arg14, arg15)</p>
<h4>CCoronas::Shutdown</h4>
<p>plugin::Call<0x542800>();</p>
<p>0AA5: call_function 0x542800 num_params 0 pop 0</p>
<p>define function CCoronas__Shutdown&lt;cdecl, 0x542800&gt;()</p>
<h4>CCoronas::Init</h4>
<p>plugin::Call<0x542830>();</p>
<p>0AA5: call_function 0x542830 num_params 0 pop 0</p>
<p>define function CCoronas__Init&lt;cdecl, 0x542830&gt;()</p>
<h4>CCoronas::RenderSunReflection</h4>
<p>plugin::Call<0x542970>();</p>
<p>0AA5: call_function 0x542970 num_params 0 pop 0</p>
<p>define function CCoronas__RenderSunReflection&lt;cdecl, 0x542970&gt;()</p>
<h4>CCoronas::RenderReflections</h4>
<p>plugin::Call<0x542FF0>();</p>
<p>0AA5: call_function 0x542FF0 num_params 0 pop 0</p>
<p>define function CCoronas__RenderReflections&lt;cdecl, 0x542FF0&gt;()</p>
<h4>CCoronas::Render</h4>
<p>plugin::Call<0x543500>();</p>
<p>0AA5: call_function 0x543500 num_params 0 pop 0</p>
<p>define function CCoronas__Render&lt;cdecl, 0x543500&gt;()</p>
<h4>CCoronas::Update</h4>
<p>plugin::Call<0x544130>();</p>
<p>0AA5: call_function 0x544130 num_params 0 pop 0</p>
<p>define function CCoronas__Update&lt;cdecl, 0x544130&gt;()</p><h3 id="plugin_vcgame_vcccranescpp">plugin_vc\game_vc\CCranes.cpp</h3><h4>CCranes::AddThisOneCrane</h4>
<p>plugin::CallAndReturnDynGlobal<int, CEntity *>(gaddrof(CCranes::AddThisOneCrane), pEnity);</p>
<p>0AA7: call_function_return 0x5A93C0 num_params 1 pop 1 [pEnity] func_ret [int]</p>
<p>define function CCranes__AddThisOneCrane&lt;cdecl, 0x5A93C0&gt;(pEnity): int</p>
<h4>CCranes::DoesMilitaryCraneHaveThisOneAlready</h4>
<p>plugin::CallAndReturnDynGlobal<bool, unsigned short>(gaddrof(CCranes::DoesMilitaryCraneHaveThisOneAlready), arg1);</p>
<p>0AA7: call_function_return 0x5A7F90 num_params 1 pop 1 [arg1] func_ret [bool]</p>
<p>define function CCranes__DoesMilitaryCraneHaveThisOneAlready&lt;cdecl, 0x5A7F90&gt;(arg1): int</p>
<h4>CCranes::IsThisCarBeingCarriedByAnyCrane</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingCarriedByAnyCrane), pVehicle);</p>
<p>0AA7: call_function_return 0x5A7AB0 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCranes__IsThisCarBeingCarriedByAnyCrane&lt;cdecl, 0x5A7AB0&gt;(pVehicle): int</p>
<h4>CCranes::IsThisCarBeingTargettedByAnyCrane</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CCranes::IsThisCarBeingTargettedByAnyCrane), pVehicle);</p>
<p>0AA7: call_function_return 0x5A7A80 num_params 1 pop 1 [pVehicle] func_ret [bool]</p>
<p>define function CCranes__IsThisCarBeingTargettedByAnyCrane&lt;cdecl, 0x5A7A80&gt;(pVehicle): int</p>
<h4>CCranes::RegisterCarForMilitaryCrane</h4>
<p>plugin::CallDynGlobal<unsigned short>(gaddrof(CCranes::RegisterCarForMilitaryCrane), arg1);</p><h3 id="plugin_vcgame_vcccutsceneobjectcpp">plugin_vc\game_vc\CCutsceneObject.cpp</h3><h4>CCutsceneObject::CCutsceneObject</h4>
<p>plugin::CallMethod<0x4E04D0, CCutsceneObject *>(this);</p>
<p>0AA6: call_method 0x4E04D0 struct [CCutsceneObject] num_params 0 pop 0</p>
<p>define function CCutsceneObject__CCutsceneObject&lt;thiscall, 0x4E04D0&gt;()</p>
<h4>CCutsceneObject::CreateShadow</h4>
<p>plugin::CallMethod<0x4E03E0, CCutsceneObject *>(this);</p>
<p>0AA6: call_method 0x4E03E0 struct [CCutsceneObject] num_params 0 pop 0</p>
<p>define function CCutsceneObject__CreateShadow&lt;thiscall, 0x4E03E0&gt;()</p><h3 id="plugin_vcgame_vcccutsceneshadowcpp">plugin_vc\game_vc\CCutsceneShadow.cpp</h3><h4>CCutsceneShadow::Create</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCutsceneShadow *, RwObject *, int, bool, int, bool>(gaddrof(CCutsceneShadow::Create), this, object, rasterSize, resample, blurPasses, gradient);</p>
<p>0AA8: call_method_return 0x625E60 struct [CCutsceneShadow] num_params 5 pop 0 [object] [rasterSize] [resample] [blurPasses] [gradient] func_ret [bool]</p>
<h4>CCutsceneShadow::DrawBorderAroundTexture</h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *, RwRGBA const &>(gaddrof(CCutsceneShadow::DrawBorderAroundTexture), this, color);</p>
<p>0AA6: call_method 0x625B60 struct [CCutsceneShadow] num_params 1 pop 0 [color]</p>
<p>define function CCutsceneShadow__DrawBorderAroundTexture&lt;thiscall, 0x625B60&gt;(color)</p>
<h4>*CCutsceneShadow::GetShadowCamera</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CShadowCamera *, CCutsceneShadow *, int>(gaddrof(CCutsceneShadow::GetShadowCamera), this, camType);</p>
<p>0AA8: call_method_return 0x625D50 struct [*CCutsceneShadow] num_params 1 pop 0 [camType] func_ret [CShadowCamera *]</p>
<h4>*CCutsceneShadow::GetShadowRwTexture</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwTexture *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::GetShadowRwTexture), this);</p>
<p>0AA8: call_method_return 0x625B80 struct [*CCutsceneShadow] num_params 0 pop 0 func_ret [RwTexture *]</p>
<h4>CCutsceneShadow::IsInitialized</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CCutsceneShadow *>(gaddrof(CCutsceneShadow::IsInitialized), this);</p>
<p>0AA8: call_method_return 0x625D80 struct [CCutsceneShadow] num_params 0 pop 0 func_ret [bool]</p>
<h4>*CCutsceneShadow::SetLightProperties</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwFrame *, CCutsceneShadow *, float, float, bool>(gaddrof(CCutsceneShadow::SetLightProperties), this, angleY, angleX, setLight);</p>
<p>0AA8: call_method_return 0x625D90 struct [*CCutsceneShadow] num_params 3 pop 0 [angleY] [angleX] [setLight] func_ret [RwFrame *]</p>
<h4>*CCutsceneShadow::Update</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwRaster *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::Update), this);</p>
<p>0AA8: call_method_return 0x625BC0 struct [*CCutsceneShadow] num_params 0 pop 0 func_ret [RwRaster *]</p>
<h4>*CCutsceneShadow::UpdateForCutscene</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwTexture *, CCutsceneShadow *>(gaddrof(CCutsceneShadow::UpdateForCutscene), this);</p>
<p>0AA8: call_method_return 0x625BA0 struct [*CCutsceneShadow] num_params 0 pop 0 func_ret [RwTexture *]</p><h3 id="plugin_vcgame_vccdamagemanagercpp">plugin_vc\game_vc\CDamageManager.cpp</h3><h4>CDamageManager::ApplyDamage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A9650, CDamageManager *, tComponent, float, float>(this, component, intensity, arg2);</p>
<p>0AA8: call_method_return 0x5A9650 struct [CDamageManager] num_params 3 pop 0 [component] [intensity] [arg2] func_ret [bool]</p>
<p>define function CDamageManager__ApplyDamage&lt;thiscall, 0x5A9650&gt;(component, intensity, arg2): int</p>
<h4>CDamageManager::FuckCarCompletely</h4>
<p>plugin::CallMethod<0x5A9600, CDamageManager *>(this);</p>
<p>0AA6: call_method 0x5A9600 struct [CDamageManager] num_params 0 pop 0</p>
<p>define function CDamageManager__FuckCarCompletely&lt;thiscall, 0x5A9600&gt;()</p>
<h4>CDamageManager::GetComponentGroup</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A98D0, CDamageManager <em>, tComponent, tComponentGroup</em>, unsigned char*>(this, component, group, damageCompId);</p>
<p>0AA8: call_method_return 0x5A98D0 struct [CDamageManager] num_params 3 pop 0 [component] [group] [damageCompId] func_ret [bool]</p>
<p>define function CDamageManager__GetComponentGroup&lt;thiscall, 0x5A98D0&gt;(component, group, damageCompId): int</p>
<h4>CDamageManager::GetDoorStatus</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A9810, CDamageManager *, eDoors>(this, door);</p>
<p>0AA8: call_method_return 0x5A9810 struct [CDamageManager] num_params 1 pop 0 [door] func_ret [unsigned int]</p>
<p>define function CDamageManager__GetDoorStatus&lt;thiscall, 0x5A9810&gt;(door): int</p>
<h4>CDamageManager::GetEngineStatus</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A97E0, CDamageManager *>(this);</p>
<p>0AA8: call_method_return 0x5A97E0 struct [CDamageManager] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CDamageManager__GetEngineStatus&lt;thiscall, 0x5A97E0&gt;(): int</p>
<h4>CDamageManager::GetLightStatus</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A9870, CDamageManager *, eLights>(this, light);</p>
<p>0AA8: call_method_return 0x5A9870 struct [CDamageManager] num_params 1 pop 0 [light] func_ret [unsigned int]</p>
<p>define function CDamageManager__GetLightStatus&lt;thiscall, 0x5A9870&gt;(light): int</p>
<h4>CDamageManager::GetPanelStatus</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A9850, CDamageManager *, ePanels>(this, panel);</p>
<p>0AA8: call_method_return 0x5A9850 struct [CDamageManager] num_params 1 pop 0 [panel] func_ret [unsigned int]</p>
<p>define function CDamageManager__GetPanelStatus&lt;thiscall, 0x5A9850&gt;(panel): int</p>
<h4>CDamageManager::GetWheelStatus</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x5A9830, CDamageManager *, int>(this, wheel);</p>
<p>0AA8: call_method_return 0x5A9830 struct [CDamageManager] num_params 1 pop 0 [wheel] func_ret [unsigned int]</p>
<p>define function CDamageManager__GetWheelStatus&lt;thiscall, 0x5A9830&gt;(wheel): int</p>
<h4>CDamageManager::ProgressPanelDamage</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5A9790, CDamageManager *, unsigned char>(this, panel);</p>
<p>0AA8: call_method_return 0x5A9790 struct [CDamageManager] num_params 1 pop 0 [panel] func_ret [bool]</p>
<p>define function CDamageManager__ProgressPanelDamage&lt;thiscall, 0x5A9790&gt;(panel): int</p>
<h4>CDamageManager::ResetDamageStatus</h4>
<p>plugin::CallMethod<0x5A9890, CDamageManager *>(this);</p>
<p>0AA6: call_method 0x5A9890 struct [CDamageManager] num_params 0 pop 0</p>
<p>define function CDamageManager__ResetDamageStatus&lt;thiscall, 0x5A9890&gt;()</p>
<h4>CDamageManager::SetDoorStatus</h4>
<p>plugin::CallMethod<0x5A9820, CDamageManager *, eDoors, unsigned int>(this, door, status);</p>
<p>0AA6: call_method 0x5A9820 struct [CDamageManager] num_params 2 pop 0 [door] [status]</p>
<p>define function CDamageManager__SetDoorStatus&lt;thiscall, 0x5A9820&gt;(door, status)</p>
<h4>CDamageManager::SetEngineStatus</h4>
<p>plugin::CallMethod<0x5A97F0, CDamageManager *, unsigned int>(this, status);</p>
<p>0AA6: call_method 0x5A97F0 struct [CDamageManager] num_params 1 pop 0 [status]</p>
<p>define function CDamageManager__SetEngineStatus&lt;thiscall, 0x5A97F0&gt;(status)</p>
<h4>CDamageManager::SetWheelStatus</h4>
<p>plugin::CallMethod<0x5A9840, CDamageManager *, int, unsigned int>(this, wheel, status);</p>
<p>0AA6: call_method 0x5A9840 struct [CDamageManager] num_params 2 pop 0 [wheel] [status]</p>
<p>define function CDamageManager__SetWheelStatus&lt;thiscall, 0x5A9840&gt;(wheel, status)</p><h3 id="plugin_vcgame_vccdarkelcpp">plugin_vc\game_vc\CDarkel.cpp</h3><h4>CDarkel::DealWithWeaponChangeAtEndOfFrenzy</h4>
<p>plugin::Call<0x429910>();</p>
<p>0AA5: call_function 0x429910 num_params 0 pop 0</p>
<p>define function CDarkel__DealWithWeaponChangeAtEndOfFrenzy&lt;cdecl, 0x429910&gt;()</p>
<h4>CDarkel::DrawMessages</h4>
<p>plugin::Call<0x429FE0>();</p>
<p>0AA5: call_function 0x429FE0 num_params 0 pop 0</p>
<p>define function CDarkel__DrawMessages&lt;cdecl, 0x429FE0&gt;()</p>
<h4>CDarkel::FrenzyOnGoing</h4>
<p>plugin::CallAndReturn<bool, 0x429FC0>();</p>
<p>0AA7: call_function_return 0x429FC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CDarkel__FrenzyOnGoing&lt;cdecl, 0x429FC0&gt;(): int</p>
<h4>CDarkel::Init</h4>
<p>plugin::Call<0x42A7A0>();</p>
<p>0AA5: call_function 0x42A7A0 num_params 0 pop 0</p>
<p>define function CDarkel__Init&lt;cdecl, 0x42A7A0&gt;()</p>
<h4>CDarkel::QueryModelsKilledByPlayer</h4>
<p>plugin::CallAndReturn<short, 0x429AF0, int>(arg0);</p>
<p>0AA7: call_function_return 0x429AF0 num_params 1 pop 1 [arg0] func_ret [short]</p>
<p>define function CDarkel__QueryModelsKilledByPlayer&lt;cdecl, 0x429AF0&gt;(arg0): int</p>
<h4>CDarkel::ReadStatus</h4>
<p>plugin::CallAndReturn<short, 0x429FD0>();</p>
<p>0AA7: call_function_return 0x429FD0 num_params 0 pop 0 func_ret [short]</p>
<p>define function CDarkel__ReadStatus&lt;cdecl, 0x429FD0&gt;(): int</p>
<h4>CDarkel::RegisterCarBlownUpByPlayer</h4>
<p>plugin::CallAndReturn<int, 0x429DF0, CVehicle*>(vehicle);</p>
<p>0AA7: call_function_return 0x429DF0 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CDarkel__RegisterCarBlownUpByPlayer&lt;cdecl, 0x429DF0&gt;(vehicle): int</p>
<h4>CDarkel::RegisterKillByPlayer</h4>
<p>plugin::Call<0x429E90, CPed*, eWeaponType, bool>(ped, weaponType, arg2);</p>
<p>0AA5: call_function 0x429E90 num_params 3 pop 3 [ped] [weaponType] [arg2]</p>
<p>define function CDarkel__RegisterKillByPlayer&lt;cdecl, 0x429E90&gt;(ped, weaponType, arg2)</p>
<h4>CDarkel::RegisterKillNotByPlayer</h4>
<p>plugin::Call<0x429E80, CPed*, eWeaponType>(arg0, weaponType);</p>
<p>0AA5: call_function 0x429E80 num_params 2 pop 2 [arg0] [weaponType]</p>
<p>define function CDarkel__RegisterKillNotByPlayer&lt;cdecl, 0x429E80&gt;(arg0, weaponType)</p>
<h4>CDarkel::ResetModelsKilledByPlayer</h4>
<p>plugin::Call<0x429B00>();</p>
<p>0AA5: call_function 0x429B00 num_params 0 pop 0</p>
<p>define function CDarkel__ResetModelsKilledByPlayer&lt;cdecl, 0x429B00&gt;()</p>
<h4>CDarkel::ResetOnPlayerDeath</h4>
<p>plugin::Call<0x429F90>();</p>
<p>0AA5: call_function 0x429F90 num_params 0 pop 0</p>
<p>define function CDarkel__ResetOnPlayerDeath&lt;cdecl, 0x429F90&gt;()</p>
<h4>CDarkel::StartFrenzy</h4>
<p>plugin::Call<0x429B60, eWeaponType, int, unsigned short, int, unsigned short*, int, int, int, bool, bool>(weaponType, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);</p>
<p>0AA5: call_function 0x429B60 num_params 10 pop 10 [weaponType] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9]</p>
<p>define function CDarkel__StartFrenzy&lt;cdecl, 0x429B60&gt;(weaponType, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)</p>
<h4>CDarkel::Update</h4>
<p>plugin::Call<0x42A650>();</p>
<p>0AA5: call_function 0x42A650 num_params 0 pop 0</p>
<p>define function CDarkel__Update&lt;cdecl, 0x42A650&gt;()</p><h3 id="plugin_vcgame_vccdirectorycpp">plugin_vc\game_vc\CDirectory.cpp</h3><h4>CDirectory::AddItem</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, const CDirectory::DirectoryInfo *>(gaddrof(CDirectory::AddItem), this, entry);</p>
<p>0AA6: call_method 0x4873F0 struct [CDirectory] num_params 1 pop 0 [entry]</p>
<p>define function CDirectory__AddItem&lt;thiscall, 0x4873F0&gt;(entry)</p>
<h4>CDirectory::FindItem</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *, unsigned int *, unsigned int *>(gaddrof(CDirectory::FindItem), this, name, outOffset, outSize);</p>
<p>0AA8: call_method_return 0x487220 struct [CDirectory] num_params 3 pop 0 [name] [outOffset] [outSize] func_ret [bool]</p>
<h4>CDirectory::ReadDirFile</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, char const *>(gaddrof(CDirectory::ReadDirFile), this, filename);</p>
<p>0AA6: call_method 0x487370 struct [CDirectory] num_params 1 pop 0 [filename]</p>
<p>define function CDirectory__ReadDirFile&lt;thiscall, 0x487370&gt;(filename)</p>
<h4>CDirectory::WriteDirFile</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CDirectory *, char const *>(gaddrof(CDirectory::WriteDirFile), this, filename);</p>
<p>0AA8: call_method_return 0x487320 struct [CDirectory] num_params 1 pop 0 [filename] func_ret [bool]</p><h3 id="plugin_vcgame_vccdmaudiocpp">plugin_vc\game_vc\cDMAudio.cpp</h3><h4>cDMAudio::PlayFrontEndSound</h4>
<p>plugin::CallMethod<0x5F9960, cDMAudio*, unsigned short, unsigned int>(this, frontend, volume);</p>
<p>0AA6: call_method 0x5F9960 struct [cDMAudio] num_params 2 pop 0 [frontend] [volume]</p>
<p>define function cDMAudio__PlayFrontEndSound&lt;thiscall, 0x5F9960&gt;(frontend, volume)</p>
<h4>cDMAudio::PlayLoadedMissionAudio</h4>
<p>plugin::CallMethod<0x5F97B0, cDMAudio*, unsigned char>(this, slot);</p>
<p>0AA6: call_method 0x5F97B0 struct [cDMAudio] num_params 1 pop 0 [slot]</p>
<p>define function cDMAudio__PlayLoadedMissionAudio&lt;thiscall, 0x5F97B0&gt;(slot)</p>
<h4>cDMAudio::ClearMissionAudio</h4>
<p>plugin::CallMethod<0x5F9770, cDMAudio*, unsigned char>(this, slot);</p>
<p>0AA6: call_method 0x5F9770 struct [cDMAudio] num_params 1 pop 0 [slot]</p>
<p>define function cDMAudio__ClearMissionAudio&lt;thiscall, 0x5F9770&gt;(slot)</p>
<h4>cDMAudio::PreloadMissionAudio</h4>
<p>plugin::CallMethod<0x5F9820, cDMAudio<em>, unsigned char, const char</em>>(this, slot, missionAudio);</p>
<p>0AA6: call_method 0x5F9820 struct [cDMAudio] num_params 2 pop 0 [slot] [missionAudio]</p>
<p>define function cDMAudio__PreloadMissionAudio&lt;thiscall, 0x5F9820&gt;(slot, missionAudio)</p>
<h4>cDMAudio::PlayOneShot</h4>
<p>plugin::CallMethod<0x5F9DA0, cDMAudio*, int, unsigned short, float>(this, audioEntity, shot, volume);</p>
<p>0AA6: call_method 0x5F9DA0 struct [cDMAudio] num_params 3 pop 0 [audioEntity] [shot] [volume]</p>
<p>define function cDMAudio__PlayOneShot&lt;thiscall, 0x5F9DA0&gt;(audioEntity, shot, volume)</p>
<h4>cDMAudio::SetRadioInCar</h4>
<p>plugin::CallMethod<0x5F9730, cDMAudio*, unsigned int>(this, radio);</p>
<p>0AA6: call_method 0x5F9730 struct [cDMAudio] num_params 1 pop 0 [radio]</p>
<p>define function cDMAudio__SetRadioInCar&lt;thiscall, 0x5F9730&gt;(radio)</p>
<h4>cDMAudio::PlayFrontEndTrack</h4>
<p>plugin::CallMethod<0x5F9910, cDMAudio*, unsigned int, char>(this, track, flag);</p>
<p>0AA6: call_method 0x5F9910 struct [cDMAudio] num_params 2 pop 0 [track] [flag]</p>
<p>define function cDMAudio__PlayFrontEndTrack&lt;thiscall, 0x5F9910&gt;(track, flag)</p>
<h4>cDMAudio::StopFrontEndTrack</h4>
<p>plugin::CallMethod<0x5F98F0, cDMAudio*>(this);</p>
<p>0AA6: call_method 0x5F98F0 struct [cDMAudio] num_params 0 pop 0</p>
<p>define function cDMAudio__StopFrontEndTrack&lt;thiscall, 0x5F98F0&gt;()</p>
<h4>cDMAudio::IsMP3RadioChannelAvailable</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5F9BB0, cDMAudio*>(this);</p>
<p>0AA8: call_method_return 0x5F9BB0 struct [cDMAudio] num_params 0 pop 0 func_ret [bool]</p>
<p>define function cDMAudio__IsMP3RadioChannelAvailable&lt;thiscall, 0x5F9BB0&gt;(): int</p><h3 id="plugin_vcgame_vccdrawcpp">plugin_vc\game_vc\CDraw.cpp</h3><h4>CDraw::CalculateAspectRatio</h4>
<p>plugin::Call<0x54A270>();</p>
<p>0AA5: call_function 0x54A270 num_params 0 pop 0</p>
<p>define function CDraw__CalculateAspectRatio&lt;cdecl, 0x54A270&gt;()</p>
<h4>CDraw::SetFOV</h4>
<p>plugin::Call<0x54A2E0, float>(fov);</p>
<p>0AA5: call_function 0x54A2E0 num_params 1 pop 1 [fov]</p>
<p>define function CDraw__SetFOV&lt;cdecl, 0x54A2E0&gt;(fov)</p><h3 id="plugin_vcgame_vccemergencypedcpp">plugin_vc\game_vc\CEmergencyPed.cpp</h3><h4>CEmergencyPed::CEmergencyPed</h4>
<p>plugin::CallMethod<0x4EEB40, CEmergencyPed *, unsigned int>(this, emergencyType);</p>
<p>0AA6: call_method 0x4EEB40 struct [CEmergencyPed] num_params 1 pop 0 [emergencyType]</p>
<p>define function CEmergencyPed__CEmergencyPed&lt;thiscall, 0x4EEB40&gt;(emergencyType)</p>
<h4>CEmergencyPed::FiremanAI</h4>
<p>plugin::CallMethod<0x4EDA80, CEmergencyPed *>(this);</p>
<p>0AA6: call_method 0x4EDA80 struct [CEmergencyPed] num_params 0 pop 0</p>
<p>define function CEmergencyPed__FiremanAI&lt;thiscall, 0x4EDA80&gt;()</p>
<h4>CEmergencyPed::MedicAI</h4>
<p>plugin::CallMethod<0x4EDC90, CEmergencyPed *>(this);</p>
<p>0AA6: call_method 0x4EDC90 struct [CEmergencyPed] num_params 0 pop 0</p>
<p>define function CEmergencyPed__MedicAI&lt;thiscall, 0x4EDC90&gt;()</p><h3 id="plugin_vcgame_vccescalatorscpp">plugin_vc\game_vc\CEscalators.cpp</h3><h4>CEscalators::AddOne</h4>
<p>plugin::CallMethod<0x54B0A0, CEscalators *, CVector const&, CVector const&, CVector const&, CVector const&, bool>(this, arg0, arg1, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x54B0A0 struct [CEscalators] num_params 5 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CEscalators__AddOne&lt;thiscall, 0x54B0A0&gt;(arg0, arg1, arg2, arg3, arg4)</p>
<h4>CEscalators::Init</h4>
<p>plugin::Call<0x54B460>();</p>
<p>0AA5: call_function 0x54B460 num_params 0 pop 0</p>
<p>define function CEscalators__Init&lt;cdecl, 0x54B460&gt;()</p>
<h4>CEscalators::Shutdown</h4>
<p>plugin::Call<0x54B3A0>();</p>
<p>0AA5: call_function 0x54B3A0 num_params 0 pop 0</p>
<p>define function CEscalators__Shutdown&lt;cdecl, 0x54B3A0&gt;()</p>
<h4>CEscalators::Update</h4>
<p>plugin::CallMethod<0x54A9B0, CEscalators *>(this);</p>
<p>0AA6: call_method 0x54A9B0 struct [CEscalators] num_params 0 pop 0</p>
<p>define function CEscalators__Update&lt;thiscall, 0x54A9B0&gt;()</p><h3 id="plugin_vcgame_vccfileloadercpp">plugin_vc\game_vc\CFileLoader.cpp</h3><h4>CFileLoader::LoadAtomicFile2Return</h4>
<p>plugin::CallAndReturn<RpClump<em>, 0x48D7C0, const char</em>>(file);</p>
<p>0AA7: call_function_return 0x48D7C0 num_params 1 pop 1 [file] func_ret [RpClump*]</p>
<p>define function CFileLoader__LoadAtomicFile2Return&lt;cdecl, 0x48D7C0&gt;(file): int</p><h3 id="plugin_vcgame_vccfilemgrcpp">plugin_vc\game_vc\CFileMgr.cpp</h3><h4>CFileMgr::GetErrorReadWrite</h4>
<p>plugin::CallAndReturn<int, 0x48DE90, int>(fileHandle);</p>
<p>0AA7: call_function_return 0x48DE90 num_params 1 pop 1 [fileHandle] func_ret [int]</p>
<p>define function CFileMgr__GetErrorReadWrite&lt;cdecl, 0x48DE90&gt;(fileHandle): int</p>
<h4>CFileMgr::CloseFile</h4>
<p>plugin::CallAndReturn<int, 0x48DEA0, int>(fileHandle);</p>
<p>0AA7: call_function_return 0x48DEA0 num_params 1 pop 1 [fileHandle] func_ret [int]</p>
<p>define function CFileMgr__CloseFile&lt;cdecl, 0x48DEA0&gt;(fileHandle): int</p>
<h4>CFileMgr::ReadLine</h4>
<p>plugin::CallAndReturn<bool, 0x48DEB0, int, char*, int>(fileHandle, buffer, maxSize);</p>
<p>0AA7: call_function_return 0x48DEB0 num_params 3 pop 3 [fileHandle] [buffer] [maxSize] func_ret [bool]</p>
<p>define function CFileMgr__ReadLine&lt;cdecl, 0x48DEB0&gt;(fileHandle, buffer, maxSize): int</p>
<h4>CFileMgr::Seek</h4>
<p>plugin::CallAndReturn<bool, 0x48DEE0, int, int, int>(fileHandle, offset, origin);</p>
<p>0AA7: call_function_return 0x48DEE0 num_params 3 pop 3 [fileHandle] [offset] [origin] func_ret [bool]</p>
<p>define function CFileMgr__Seek&lt;cdecl, 0x48DEE0&gt;(fileHandle, offset, origin): int</p>
<h4>CFileMgr::Write</h4>
<p>plugin::CallAndReturn<int, 0x48DF30, int, char*, int>(fileHandle, buffer, size);</p>
<p>0AA7: call_function_return 0x48DF30 num_params 3 pop 3 [fileHandle] [buffer] [size] func_ret [int]</p>
<p>define function CFileMgr__Write&lt;cdecl, 0x48DF30&gt;(fileHandle, buffer, size): int</p>
<h4>CFileMgr::Read</h4>
<p>plugin::CallAndReturn<int, 0x48DF50, int, char*, int>(fileHandle, buffer, size);</p>
<p>0AA7: call_function_return 0x48DF50 num_params 3 pop 3 [fileHandle] [buffer] [size] func_ret [int]</p>
<p>define function CFileMgr__Read&lt;cdecl, 0x48DF50&gt;(fileHandle, buffer, size): int</p>
<h4>CFileMgr::OpenFileForWriting</h4>
<p>plugin::CallAndReturn<int, 0x48DF70, char const*>(filepath);</p>
<p>0AA7: call_function_return 0x48DF70 num_params 1 pop 1 [filepath] func_ret [int]</p>
<p>define function CFileMgr__OpenFileForWriting&lt;cdecl, 0x48DF70&gt;(filepath): int</p>
<h4>CFileMgr::OpenFile</h4>
<p>plugin::CallAndReturn<int, 0x48DF90, char const<em>, char const</em>>(filepath, mode);</p>
<p>0AA7: call_function_return 0x48DF90 num_params 2 pop 2 [filepath] [mode] func_ret [int]</p>
<p>define function CFileMgr__OpenFile&lt;cdecl, 0x48DF90&gt;(filepath, mode): int</p>
<h4>CFileMgr::LoadFile</h4>
<p>plugin::CallAndReturn<int, 0x48DFB0, char const<em>, unsigned char</em>, int, char const*>(filepath, buffer, size, mode);</p>
<p>0AA7: call_function_return 0x48DFB0 num_params 4 pop 4 [filepath] [buffer] [size] [mode] func_ret [int]</p>
<p>define function CFileMgr__LoadFile&lt;cdecl, 0x48DFB0&gt;(filepath, buffer, size, mode): int</p>
<h4>CFileMgr::SetDirMyDocuments</h4>
<p>plugin::Call<0x48E020>();</p>
<p>0AA5: call_function 0x48E020 num_params 0 pop 0</p>
<p>define function CFileMgr__SetDirMyDocuments&lt;cdecl, 0x48E020&gt;()</p>
<h4>CFileMgr::SetDir</h4>
<p>plugin::Call<0x48E030, char const*>(dir);</p>
<p>0AA5: call_function 0x48E030 num_params 1 pop 1 [dir]</p>
<p>define function CFileMgr__SetDir&lt;cdecl, 0x48E030&gt;(dir)</p>
<h4>CFileMgr::ChangeDir</h4>
<p>plugin::Call<0x48E090, char const*>(dir);</p>
<p>0AA5: call_function 0x48E090 num_params 1 pop 1 [dir]</p>
<p>define function CFileMgr__ChangeDir&lt;cdecl, 0x48E090&gt;(dir)</p>
<h4>CFileMgr::Initialise</h4>
<p>plugin::Call<0x48E100>();</p>
<p>0AA5: call_function 0x48E100 num_params 0 pop 0</p>
<p>define function CFileMgr__Initialise&lt;cdecl, 0x48E100&gt;()</p><h3 id="plugin_vcgame_vccfontcpp">plugin_vc\game_vc\CFont.cpp</h3><h4>CFont::character_code</h4>
<p>plugin::CallAndReturn<short, 0x54FE50, unsigned char>(character);</p>
<p>0AA7: call_function_return 0x54FE50 num_params 1 pop 1 [character] func_ret [short]</p>
<p>define function CFont__character_code&lt;cdecl, 0x54FE50&gt;(character): int</p>
<h4>CFont::FindNewCharacter</h4>
<p>plugin::CallAndReturn<int, 0x54FE70, short>(character);</p>
<p>0AA7: call_function_return 0x54FE70 num_params 1 pop 1 [character] func_ret [int]</p>
<p>define function CFont__FindNewCharacter&lt;cdecl, 0x54FE70&gt;(character): int</p>
<h4>CFont::SetDropShadowPosition</h4>
<p>plugin::Call<0x54FF20, short>(position);</p>
<p>0AA5: call_function 0x54FF20 num_params 1 pop 1 [position]</p>
<p>define function CFont__SetDropShadowPosition&lt;cdecl, 0x54FF20&gt;(position)</p>
<h4>CFont::SetDropColor</h4>
<p>plugin::Call<0x54FF30, CRGBA *>(&amp;color);</p>
<p>0AA5: call_function 0x54FF30 num_params 1 pop 1 [&amp;color]</p>
<p>define function CFont__SetDropColor&lt;cdecl, 0x54FF30&gt;(&amp;color)</p>
<h4>CFont::SetAlphaFade</h4>
<p>plugin::Call<0x54FFC0, float>(fade);</p>
<p>0AA5: call_function 0x54FFC0 num_params 1 pop 1 [fade]</p>
<p>define function CFont__SetAlphaFade&lt;cdecl, 0x54FFC0&gt;(fade)</p>
<h4>CFont::SetRightJustifyWrap</h4>
<p>plugin::Call<0x54FFD0, float>(wrap);</p>
<p>0AA5: call_function 0x54FFD0 num_params 1 pop 1 [wrap]</p>
<p>define function CFont__SetRightJustifyWrap&lt;cdecl, 0x54FFD0&gt;(wrap)</p>
<h4>CFont::SetFontStyle</h4>
<p>plugin::Call<0x54FFE0, short>(style);</p>
<p>0AA5: call_function 0x54FFE0 num_params 1 pop 1 [style]</p>
<p>define function CFont__SetFontStyle&lt;cdecl, 0x54FFE0&gt;(style)</p>
<h4>CFont::SetPropOn</h4>
<p>plugin::Call<0x550020>();</p>
<p>0AA5: call_function 0x550020 num_params 0 pop 0</p>
<p>define function CFont__SetPropOn&lt;cdecl, 0x550020&gt;()</p>
<h4>CFont::SetPropOff</h4>
<p>plugin::Call<0x550030>();</p>
<p>0AA5: call_function 0x550030 num_params 0 pop 0</p>
<p>define function CFont__SetPropOff&lt;cdecl, 0x550030&gt;()</p>
<h4>CFont::SetRightJustifyOff</h4>
<p>plugin::Call<0x550040>();</p>
<p>0AA5: call_function 0x550040 num_params 0 pop 0</p>
<p>define function CFont__SetRightJustifyOff&lt;cdecl, 0x550040&gt;()</p>
<h4>CFont::SetRightJustifyOn</h4>
<p>plugin::Call<0x550060>();</p>
<p>0AA5: call_function 0x550060 num_params 0 pop 0</p>
<p>define function CFont__SetRightJustifyOn&lt;cdecl, 0x550060&gt;()</p>
<h4>CFont::SetBackGroundOnlyTextOff</h4>
<p>plugin::Call<0x550080>();</p>
<p>0AA5: call_function 0x550080 num_params 0 pop 0</p>
<p>define function CFont__SetBackGroundOnlyTextOff&lt;cdecl, 0x550080&gt;()</p>
<h4>CFont::SetBackGroundOnlyTextOn</h4>
<p>plugin::Call<0x550090>();</p>
<p>0AA5: call_function 0x550090 num_params 0 pop 0</p>
<p>define function CFont__SetBackGroundOnlyTextOn&lt;cdecl, 0x550090&gt;()</p>
<h4>CFont::SetBackgroundColor</h4>
<p>plugin::Call<0x5500A0, CRGBA *>(&amp;color);</p>
<p>0AA5: call_function 0x5500A0 num_params 1 pop 1 [&amp;color]</p>
<p>define function CFont__SetBackgroundColor&lt;cdecl, 0x5500A0&gt;(&amp;color)</p>
<h4>CFont::SetBackgroundOff</h4>
<p>plugin::Call<0x5500D0>();</p>
<p>0AA5: call_function 0x5500D0 num_params 0 pop 0</p>
<p>define function CFont__SetBackgroundOff&lt;cdecl, 0x5500D0&gt;()</p>
<h4>CFont::SetBackgroundOn</h4>
<p>plugin::Call<0x5500E0>();</p>
<p>0AA5: call_function 0x5500E0 num_params 0 pop 0</p>
<p>define function CFont__SetBackgroundOn&lt;cdecl, 0x5500E0&gt;()</p>
<h4>CFont::SetCentreSize</h4>
<p>plugin::Call<0x5500F0, float>(size);</p>
<p>0AA5: call_function 0x5500F0 num_params 1 pop 1 [size]</p>
<p>define function CFont__SetCentreSize&lt;cdecl, 0x5500F0&gt;(size)</p>
<h4>CFont::SetWrapx</h4>
<p>plugin::Call<0x550100, float>(wrap);</p>
<p>0AA5: call_function 0x550100 num_params 1 pop 1 [wrap]</p>
<p>define function CFont__SetWrapx&lt;cdecl, 0x550100&gt;(wrap)</p>
<h4>CFont::SetCentreOff</h4>
<p>plugin::Call<0x550110>();</p>
<p>0AA5: call_function 0x550110 num_params 0 pop 0</p>
<p>define function CFont__SetCentreOff&lt;cdecl, 0x550110&gt;()</p>
<h4>CFont::SetCentreOn</h4>
<p>plugin::Call<0x550120>();</p>
<p>0AA5: call_function 0x550120 num_params 0 pop 0</p>
<p>define function CFont__SetCentreOn&lt;cdecl, 0x550120&gt;()</p>
<h4>CFont::SetJustifyOff</h4>
<p>plugin::Call<0x550140>();</p>
<p>0AA5: call_function 0x550140 num_params 0 pop 0</p>
<p>define function CFont__SetJustifyOff&lt;cdecl, 0x550140&gt;()</p>
<h4>CFont::SetJustifyOn</h4>
<p>plugin::Call<0x550150>();</p>
<p>0AA5: call_function 0x550150 num_params 0 pop 0</p>
<p>define function CFont__SetJustifyOn&lt;cdecl, 0x550150&gt;()</p>
<h4>CFont::SetColor</h4>
<p>plugin::Call<0x550170, CRGBA *>(&amp;color);</p>
<p>0AA5: call_function 0x550170 num_params 1 pop 1 [&amp;color]</p>
<p>define function CFont__SetColor&lt;cdecl, 0x550170&gt;(&amp;color)</p>
<h4>CFont::SetSlant</h4>
<p>plugin::Call<0x550200, float>(slant);</p>
<p>0AA5: call_function 0x550200 num_params 1 pop 1 [slant]</p>
<p>define function CFont__SetSlant&lt;cdecl, 0x550200&gt;(slant)</p>
<h4>CFont::SetSlantRefPoint</h4>
<p>plugin::Call<0x550210, float, float>(x, y);</p>
<p>0AA5: call_function 0x550210 num_params 2 pop 2 [x] [y]</p>
<p>define function CFont__SetSlantRefPoint&lt;cdecl, 0x550210&gt;(x, y)</p>
<h4>CFont::SetScale</h4>
<p>plugin::Call<0x550230, float, float>(width, height);</p>
<p>0AA5: call_function 0x550230 num_params 2 pop 2 [width] [height]</p>
<p>define function CFont__SetScale&lt;cdecl, 0x550230&gt;(width, height)</p>
<h4>CFont::DrawFonts</h4>
<p>plugin::Call<0x550250>();</p>
<p>0AA5: call_function 0x550250 num_params 0 pop 0</p>
<p>define function CFont__DrawFonts&lt;cdecl, 0x550250&gt;()</p>
<h4>CFont::FilterOutTokensFromString</h4>
<p>plugin::Call<0x550260, const wchar_t*>(str);</p>
<p>0AA5: call_function 0x550260 num_params 1 pop 1 [str]</p>
<p>define function CFont__FilterOutTokensFromString&lt;cdecl, 0x550260&gt;(str)</p>
<h4>CFont::ParseToken</h4>
<p>plugin::CallAndReturn<wchar_t<em>, 0x5502D0, wchar_t</em>>(str);</p>
<p>0AA7: call_function_return 0x5502D0 num_params 1 pop 1 [str] func_ret [wchar_t*]</p>
<p>define function CFont__ParseToken&lt;cdecl, 0x5502D0&gt;(str): int</p>
<h4>CFont::ParseToken</h4>
<p>plugin::CallAndReturn<wchar_t<em>, 0x550510, wchar_t</em>, CRGBA&, bool&, bool&>(str, color, flashing, bold);</p>
<p>0AA7: call_function_return 0x550510 num_params 4 pop 4 [str] [color] [flashing] [bold] func_ret [wchar_t*]</p>
<p>define function CFont__ParseToken&lt;cdecl, 0x550510&gt;(str, color, flashing, bold): int</p>
<h4>CFont::GetStringWidth</h4>
<p>plugin::CallAndReturn<float, 0x550650, const wchar_t*, bool>(str, sentence);</p>
<p>0AA7: call_function_return 0x550650 num_params 2 pop 2 [str] [sentence] func_ret [float]</p>
<p>define function CFont__GetStringWidth&lt;cdecl, 0x550650&gt;(str, sentence): float</p>
<h4>CFont::GetTextRect</h4>
<p>plugin::Call<0x550720, CRect<em>, float, float, const wchar_t</em>>(rect_out, x, y, text);</p>
<p>0AA5: call_function 0x550720 num_params 4 pop 4 [rect_out] [x] [y] [text]</p>
<p>define function CFont__GetTextRect&lt;cdecl, 0x550720&gt;(rect_out, x, y, text)</p>
<h4>CFont::GetNumberLines</h4>
<p>plugin::CallAndReturn<int, 0x550C70, float, float, const wchar_t*>(x, y, text);</p>
<p>0AA7: call_function_return 0x550C70 num_params 3 pop 3 [x] [y] [text] func_ret [int]</p>
<p>define function CFont__GetNumberLines&lt;cdecl, 0x550C70&gt;(x, y, text): int</p>
<h4>CFont::PrintString</h4>
<p>plugin::Call<0x551040, float, float, const wchar_t*>(x, y, text);</p>
<p>0AA5: call_function 0x551040 num_params 3 pop 3 [x] [y] [text]</p>
<p>define function CFont__PrintString&lt;cdecl, 0x551040&gt;(x, y, text)</p>
<h4>CFont::PrintStringFromBottom</h4>
<p>plugin::Call<0x551620, float, float, const wchar_t*>(x, y, text);</p>
<p>0AA5: call_function 0x551620 num_params 3 pop 3 [x] [y] [text]</p>
<p>define function CFont__PrintStringFromBottom&lt;cdecl, 0x551620&gt;(x, y, text)</p>
<h4>CFont::PrintString</h4>
<p>plugin::Call<0x5516C0, float, float, unsigned int, const wchar_t<em>, const wchar_t</em>, float>(x, y, arg2, arg3, arg4, arg5);</p>
<p>0AA5: call_function 0x5516C0 num_params 6 pop 6 [x] [y] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CFont__PrintString&lt;cdecl, 0x5516C0&gt;(x, y, arg2, arg3, arg4, arg5)</p>
<h4>CFont::RenderFontBuffer</h4>
<p>plugin::Call<0x551A30>();</p>
<p>0AA5: call_function 0x551A30 num_params 0 pop 0</p>
<p>define function CFont__RenderFontBuffer&lt;cdecl, 0x551A30&gt;()</p>
<h4>CFont::PrintChar</h4>
<p>plugin::Call<0x551E70, float, float, short>(x, y, character);</p>
<p>0AA5: call_function 0x551E70 num_params 3 pop 3 [x] [y] [character]</p>
<p>define function CFont__PrintChar&lt;cdecl, 0x551E70&gt;(x, y, character)</p>
<h4>CFont::InitPerFrame</h4>
<p>plugin::Call<0x5522B0>();</p>
<p>0AA5: call_function 0x5522B0 num_params 0 pop 0</p>
<p>define function CFont__InitPerFrame&lt;cdecl, 0x5522B0&gt;()</p>
<h4>CFont::Shutdown</h4>
<p>plugin::Call<0x5522E0>();</p>
<p>0AA5: call_function 0x5522E0 num_params 0 pop 0</p>
<p>define function CFont__Shutdown&lt;cdecl, 0x5522E0&gt;()</p>
<h4>CFont::Initialise</h4>
<p>plugin::Call<0x552310>();</p>
<p>0AA5: call_function 0x552310 num_params 0 pop 0</p>
<p>define function CFont__Initialise&lt;cdecl, 0x552310&gt;()</p>
<h4>UnicodeMakeUpperCase</h4>
<p>plugin::Call<0x552470, wchar_t<em>, wchar_t const</em>>(str_out, str_in);</p>
<p>0AA5: call_function 0x552470 num_params 2 pop 2 [str_out] [str_in]</p>
<p>define function UnicodeMakeUpperCase&lt;cdecl, 0x552470&gt;(str_out, str_in)</p>
<h4>UnicodeStrlen</h4>
<p>plugin::CallAndReturn<int, 0x5524B0, wchar_t const*>(str);</p>
<p>0AA7: call_function_return 0x5524B0 num_params 1 pop 1 [str] func_ret [int]</p>
<p>define function UnicodeStrlen&lt;cdecl, 0x5524B0&gt;(str): int</p>
<h4>AsciiToUnicode</h4>
<p>plugin::Call<0x552500, char const<em>, wchar_t</em>>(str_ascii, str_unicode);</p>
<p>0AA5: call_function 0x552500 num_params 2 pop 2 [str_ascii] [str_unicode]</p>
<p>define function AsciiToUnicode&lt;cdecl, 0x552500&gt;(str_ascii, str_unicode)</p><h3 id="plugin_vcgame_vccgamecpp">plugin_vc\game_vc\CGame.cpp</h3><h4>CGame::CanSeeOutSideFromCurrArea</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeOutSideFromCurrArea));</p>
<p>0AA7: call_function_return 0x4A4390 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__CanSeeOutSideFromCurrArea&lt;cdecl, 0x4A4390&gt;(): int</p>
<h4>CGame::CanSeeWaterFromCurrArea</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::CanSeeWaterFromCurrArea));</p>
<p>0AA7: call_function_return 0x4A4360 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__CanSeeWaterFromCurrArea&lt;cdecl, 0x4A4360&gt;(): int</p>
<h4>CGame::Initialise</h4>
<p>plugin::CallAndReturnDynGlobal<bool, char const *>(gaddrof(CGame::Initialise), datFile);</p>
<p>0AA7: call_function_return 0x4A4B10 num_params 1 pop 1 [datFile] func_ret [bool]</p>
<p>define function CGame__Initialise&lt;cdecl, 0x4A4B10&gt;(datFile): int</p>
<h4>CGame::InitialiseOnceAfterRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceAfterRW));</p>
<p>0AA7: call_function_return 0x4A5020 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseOnceAfterRW&lt;cdecl, 0x4A5020&gt;(): int</p>
<h4>CGame::InitialiseOnceBeforeRW</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseOnceBeforeRW));</p>
<p>0AA7: call_function_return 0x4A52C0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseOnceBeforeRW&lt;cdecl, 0x4A52C0&gt;(): int</p>
<h4>CGame::InitialiseRenderWare</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::InitialiseRenderWare));</p>
<p>0AA7: call_function_return 0x4A51A0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__InitialiseRenderWare&lt;cdecl, 0x4A51A0&gt;(): int</p>
<h4>CGame::Shutdown</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CGame::Shutdown));</p>
<p>0AA7: call_function_return 0x4A49E0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CGame__Shutdown&lt;cdecl, 0x4A49E0&gt;(): int</p>
<h4>CGame::TidyUpMemory</h4>
<p>plugin::CallDynGlobal<bool, bool>(gaddrof(CGame::TidyUpMemory), a1, clearD3Dmem);</p>
<h4>AppEventHandler</h4>
<p>plugin::CallAndReturnDynGlobal<RsEventStatus, RsEvent, void *>(gaddrof(AppEventHandler), event, param);</p>
<p>0AA7: call_function_return 0x4A5AD0 num_params 2 pop 2 [event] [param] func_ret [RsEventStatus]</p>
<p>define function AppEventHandler&lt;cdecl, 0x4A5AD0&gt;(event, param): int</p>
<h4>InitialiseGame</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(InitialiseGame));</p>
<p>0AA7: call_function_return 0x4A5C40 num_params 0 pop 0 func_ret [bool]</p>
<p>define function InitialiseGame&lt;cdecl, 0x4A5C40&gt;(): int</p>
<h4>Idle</h4>
<p>plugin::CallDynGlobal<void *>(gaddrof(Idle), param);</p>
<h4>LoadingScreen</h4>
<p>plugin::CallDynGlobal<char const *, char const *, char const *>(gaddrof(LoadingScreen), title, message, screenName);</p>
<h4>*GetLevelSplashScreen</h4>
<p>plugin::CallAndReturnDynGlobal<char const *, int>(gaddrof(GetLevelSplashScreen), screenId);</p>
<p>0AA7: call_function_return 0x4A6D90 num_params 1 pop 1 [screenId] func_ret [char const *]</p>
<p>define function GetLevelSplashScreen&lt;cdecl, 0x4A6D90&gt;(screenId): int</p>
<h4>*GetRandomSplashScreen</h4>
<p>plugin::CallAndReturnDynGlobal<char const *>(gaddrof(GetRandomSplashScreen));</p>
<p>0AA7: call_function_return 0x4A6DA0 num_params 0 pop 0 func_ret [char const *]</p>
<p>define function GetRandomSplashScreen&lt;cdecl, 0x4A6DA0&gt;(): int</p>
<h4>*LoadSplash</h4>
<p>plugin::CallAndReturnDynGlobal<CSprite2d *, char const *>(gaddrof(LoadSplash), splashName);</p>
<p>0AA7: call_function_return 0x4A6E80 num_params 1 pop 1 [splashName] func_ret [CSprite2d *]</p>
<p>define function LoadSplash&lt;cdecl, 0x4A6E80&gt;(splashName): int</p>
<h4>PluginAttach</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(PluginAttach));</p>
<p>0AA7: call_function_return 0x4A6FA0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function PluginAttach&lt;cdecl, 0x4A6FA0&gt;(): int</p>
<h4>DoRWStuffStartOfFrame</h4>
<p>plugin::CallAndReturnDynGlobal<bool, short, short, short, short, short, short, short>(gaddrof(DoRWStuffStartOfFrame), topR, topG, topB, bottomR, bottomG, bottomB, alpha);</p>
<p>0AA7: call_function_return 0x4A72C0 num_params 7 pop 7 [topR] [topG] [topB] [bottomR] [bottomG] [bottomB] [alpha] func_ret [bool]</p>
<p>define function DoRWStuffStartOfFrame&lt;cdecl, 0x4A72C0&gt;(topR, topG, topB, bottomR, bottomG, bottomB, alpha): int</p>
<h4>MatchModelString</h4>
<p>plugin::CallDynGlobal<char *, int>(gaddrof(MatchModelString), modelName, modelIndex);</p><h3 id="plugin_vcgame_vccgamelogiccpp">plugin_vc\game_vc\CGameLogic.cpp</h3><h4>CGameLogic::InitAtStartOfGame</h4>
<p>plugin::Call<0x42C480>();</p>
<p>0AA5: call_function 0x42C480 num_params 0 pop 0</p>
<p>define function CGameLogic__InitAtStartOfGame&lt;cdecl, 0x42C480&gt;()</p>
<h4>CGameLogic::Update</h4>
<p>plugin::Call<0x42BB70>();</p>
<p>0AA5: call_function 0x42BB70 num_params 0 pop 0</p>
<p>define function CGameLogic__Update&lt;cdecl, 0x42BB70&gt;()</p>
<h4>CGameLogic::RestorePlayerStuffDuringResurrection</h4>
<p>plugin::Call<0x42B900, CPlayerPed*, CVector, float>(arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x42B900 num_params 3 pop 3 [arg1] [arg2] [arg3]</p>
<p>define function CGameLogic__RestorePlayerStuffDuringResurrection&lt;cdecl, 0x42B900&gt;(arg1, arg2, arg3)</p>
<h4>CGameLogic::ClearShortCut</h4>
<p>plugin::Call<0x42B730>();</p>
<p>0AA5: call_function 0x42B730 num_params 0 pop 0</p>
<p>define function CGameLogic__ClearShortCut&lt;cdecl, 0x42B730&gt;()</p>
<h4>CGameLogic::UpdateShortCut</h4>
<p>plugin::Call<0x42AE70>();</p>
<p>0AA5: call_function 0x42AE70 num_params 0 pop 0</p>
<p>define function CGameLogic__UpdateShortCut&lt;cdecl, 0x42AE70&gt;()</p>
<h4>CGameLogic::AfterDeathArrestSetUpShortCutTaxi</h4>
<p>plugin::Call<0x42AC10>();</p>
<p>0AA5: call_function 0x42AC10 num_params 0 pop 0</p>
<p>define function CGameLogic__AfterDeathArrestSetUpShortCutTaxi&lt;cdecl, 0x42AC10&gt;()</p>
<h4>CGameLogic::RemoveShortCutDropOffPointForMission</h4>
<p>plugin::Call<0x42ADE0>();</p>
<p>0AA5: call_function 0x42ADE0 num_params 0 pop 0</p>
<p>define function CGameLogic__RemoveShortCutDropOffPointForMission&lt;cdecl, 0x42ADE0&gt;()</p><h3 id="plugin_vcgame_vccgangscpp">plugin_vc\game_vc\CGangs.cpp</h3><h4>CGangs::SetWillAttackPlayerWithCops</h4>
<p>plugin::Call<0x4EEF30, ePedType, bool>(pedtype, bAttackPlayerWithCops);</p>
<p>0AA5: call_function 0x4EEF30 num_params 2 pop 2 [pedtype] [bAttackPlayerWithCops]</p>
<p>define function CGangs__SetWillAttackPlayerWithCops&lt;cdecl, 0x4EEF30&gt;(pedtype, bAttackPlayerWithCops)</p>
<h4>CGangs::SetGangWeapons</h4>
<p>plugin::Call<0x4EED70, short, int, int>(gangId, weapon1_Id, weapon2_Id);</p>
<p>0AA5: call_function 0x4EED70 num_params 3 pop 3 [gangId] [weapon1_Id] [weapon2_Id]</p>
<p>define function CGangs__SetGangWeapons&lt;cdecl, 0x4EED70&gt;(gangId, weapon1_Id, weapon2_Id)</p>
<h4>CGangs::SetGangVehicleModel</h4>
<p>plugin::Call<0x4EEDD0, short, int>(gangId, vehicleModelId);</p>
<p>0AA5: call_function 0x4EEDD0 num_params 2 pop 2 [gangId] [vehicleModelId]</p>
<p>define function CGangs__SetGangVehicleModel&lt;cdecl, 0x4EEDD0&gt;(gangId, vehicleModelId)</p>
<h4>CGangs::SetGangPedModels</h4>
<p>plugin::Call<0x4EEDA0, short, int, int>(gangId, pedModel1_Id, pedModel2_Id);</p>
<p>0AA5: call_function 0x4EEDA0 num_params 3 pop 3 [gangId] [pedModel1_Id] [pedModel2_Id]</p>
<p>define function CGangs__SetGangPedModels&lt;cdecl, 0x4EEDA0&gt;(gangId, pedModel1_Id, pedModel2_Id)</p>
<h4>CGangs::SaveAllGangData</h4>
<p>plugin::Call<0x4EECA0, unsigned char<em>, unsigned int</em>>(arg0, arg1);</p>
<p>0AA5: call_function 0x4EECA0 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CGangs__SaveAllGangData&lt;cdecl, 0x4EECA0&gt;(arg0, arg1)</p>
<h4>CGangs::Initialise</h4>
<p>plugin::Call<0x4EEDF0>();</p>
<p>0AA5: call_function 0x4EEDF0 num_params 0 pop 0</p>
<p>define function CGangs__Initialise&lt;cdecl, 0x4EEDF0&gt;()</p>
<h4>CGangs::ChooseGangPedModel</h4>
<p>plugin::CallAndReturn<int, 0x4EED20, short>(gangId);</p>
<p>0AA7: call_function_return 0x4EED20 num_params 1 pop 1 [gangId] func_ret [int]</p>
<p>define function CGangs__ChooseGangPedModel&lt;cdecl, 0x4EED20&gt;(gangId): int</p>
<h4>CGangs::GetWillAttackPlayerWithCops</h4>
<p>plugin::CallAndReturn<bool, 0x18BB48, ePedType>(pedtype);</p>
<p>0AA7: call_function_return 0x18BB48 num_params 1 pop 1 [pedtype] func_ret [bool]</p>
<p>define function CGangs__GetWillAttackPlayerWithCops&lt;cdecl, 0x18BB48&gt;(pedtype): int</p><h3 id="plugin_vcgame_vccgeneralcpp">plugin_vc\game_vc\CGeneral.cpp</h3><h4>CGeneral::GetATanOfXY</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float>(gaddrof(CGeneral::GetATanOfXY), x, y);</p>
<p>0AA7: call_function_return 0x4A55E0 num_params 2 pop 2 [x] [y] func_ret [float]</p>
<p>define function CGeneral__GetATanOfXY&lt;cdecl, 0x4A55E0&gt;(x, y): float</p>
<h4>CGeneral::GetAngleBetweenPoints</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetAngleBetweenPoints), x1, y1, x2, y2);</p>
<p>0AA7: call_function_return 0x4A59D0 num_params 4 pop 4 [x1] [y1] [x2] [y2] func_ret [float]</p>
<p>define function CGeneral__GetAngleBetweenPoints&lt;cdecl, 0x4A59D0&gt;(x1, y1, x2, y2): float</p>
<h4>CGeneral::GetNodeHeadingFromVector</h4>
<p>plugin::CallAndReturnDynGlobal<int, float, float>(gaddrof(CGeneral::GetNodeHeadingFromVector), x, y);</p>
<p>0AA7: call_function_return 0x4A5450 num_params 2 pop 2 [x] [y] func_ret [int]</p>
<p>define function CGeneral__GetNodeHeadingFromVector&lt;cdecl, 0x4A5450&gt;(x, y): int</p>
<h4>CGeneral::GetRadianAngleBetweenPoints</h4>
<p>plugin::CallAndReturnDynGlobal<float, float, float, float, float>(gaddrof(CGeneral::GetRadianAngleBetweenPoints), x1, y1, x2, y2);</p>
<p>0AA7: call_function_return 0x4A58E0 num_params 4 pop 4 [x1] [y1] [x2] [y2] func_ret [float]</p>
<p>define function CGeneral__GetRadianAngleBetweenPoints&lt;cdecl, 0x4A58E0&gt;(x1, y1, x2, y2): float</p>
<h4>CGeneral::LimitAngle</h4>
<p>plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitAngle), angle);</p>
<p>0AA7: call_function_return 0x4A5890 num_params 1 pop 1 [angle] func_ret [float]</p>
<p>define function CGeneral__LimitAngle&lt;cdecl, 0x4A5890&gt;(angle): float</p>
<h4>CGeneral::LimitRadianAngle</h4>
<p>plugin::CallAndReturnDynGlobal<float, float>(gaddrof(CGeneral::LimitRadianAngle), angle);</p>
<p>0AA7: call_function_return 0x4A57F0 num_params 1 pop 1 [angle] func_ret [float]</p>
<p>define function CGeneral__LimitRadianAngle&lt;cdecl, 0x4A57F0&gt;(angle): float</p>
<h4>CGeneral::SolveQuadratic</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned char, float, float, float, float &, float &>(gaddrof(CGeneral::SolveQuadratic), a, b, c, x1, x2);</p>
<p>0AA7: call_function_return 0x4A53D0 num_params 5 pop 5 [a] [b] [c] [x1] [x2] func_ret [unsigned char]</p>
<p>define function CGeneral__SolveQuadratic&lt;cdecl, 0x4A53D0&gt;(a, b, c, x1, x2): int</p><h3 id="plugin_vcgame_vcchandlingdatamgrcpp">plugin_vc\game_vc\cHandlingDataMgr.cpp</h3><h4>cHandlingDataMgr::cHandlingDataMgr</h4>
<p>plugin::CallMethod<0x5ABDC0, cHandlingDataMgr *>(this);</p>
<p>0AA6: call_method 0x5ABDC0 struct [cHandlingDataMgr] num_params 0 pop 0</p>
<p>define function cHandlingDataMgr__cHandlingDataMgr&lt;thiscall, 0x5ABDC0&gt;()</p>
<h4>cHandlingDataMgr::ConvertDataToGameUnits</h4>
<p>plugin::CallMethod<0x5ABAA0, cHandlingDataMgr <em>, tHandlingData</em>>(this, handling);</p>
<p>0AA6: call_method 0x5ABAA0 struct [cHandlingDataMgr] num_params 1 pop 0 [handling]</p>
<p>define function cHandlingDataMgr__ConvertDataToGameUnits&lt;thiscall, 0x5ABAA0&gt;(handling)</p>
<h4>cHandlingDataMgr::FindExactWord</h4>
<p>plugin::CallMethodAndReturn<int, 0x5ABD30, cHandlingDataMgr <em>, char</em>, char*, int, int>(this, line, nameTable, entrySize, entryCount);</p>
<p>0AA8: call_method_return 0x5ABD30 struct [cHandlingDataMgr] num_params 4 pop 0 [line] [nameTable] [entrySize] [entryCount] func_ret [int]</p>
<p>define function cHandlingDataMgr__FindExactWord&lt;thiscall, 0x5ABD30&gt;(line, nameTable, entrySize, entryCount): int</p>
<h4>cHandlingDataMgr::GetBoatPointer</h4>
<p>plugin::CallMethodAndReturn<tBoatHandlingData*, 0x5ABA40, cHandlingDataMgr *, unsigned char>(this, handlingId);</p>
<p>0AA8: call_method_return 0x5ABA40 struct [cHandlingDataMgr] num_params 1 pop 0 [handlingId] func_ret [tBoatHandlingData*]</p>
<p>define function cHandlingDataMgr__GetBoatPointer&lt;thiscall, 0x5ABA40&gt;(handlingId): int</p>
<h4>cHandlingDataMgr::GetFlyingPointer</h4>
<p>plugin::CallMethodAndReturn<tFlyingHandlingData*, 0x5ABA70, cHandlingDataMgr *, unsigned char>(this, handlingId);</p>
<p>0AA8: call_method_return 0x5ABA70 struct [cHandlingDataMgr] num_params 1 pop 0 [handlingId] func_ret [tFlyingHandlingData*]</p>
<p>define function cHandlingDataMgr__GetFlyingPointer&lt;thiscall, 0x5ABA70&gt;(handlingId): int</p>
<h4>cHandlingDataMgr::GetHandlingId</h4>
<p>plugin::CallMethodAndReturn<int, 0x5ABCC0, cHandlingDataMgr <em>, char const</em>>(this, name);</p>
<p>0AA8: call_method_return 0x5ABCC0 struct [cHandlingDataMgr] num_params 1 pop 0 [name] func_ret [int]</p>
<p>define function cHandlingDataMgr__GetHandlingId&lt;thiscall, 0x5ABCC0&gt;(name): int</p>
<h4>cHandlingDataMgr::Initialise</h4>
<p>plugin::CallMethod<0x5ABA10, cHandlingDataMgr *>(this);</p>
<p>0AA6: call_method 0x5ABA10 struct [cHandlingDataMgr] num_params 0 pop 0</p>
<p>define function cHandlingDataMgr__Initialise&lt;thiscall, 0x5ABA10&gt;()</p>
<h4>cHandlingDataMgr::LoadHandlingData</h4>
<p>plugin::CallMethod<0x5AAE20, cHandlingDataMgr *>(this);</p>
<p>0AA6: call_method 0x5AAE20 struct [cHandlingDataMgr] num_params 0 pop 0</p>
<p>define function cHandlingDataMgr__LoadHandlingData&lt;thiscall, 0x5AAE20&gt;()</p><h3 id="plugin_vcgame_vcchelicpp">plugin_vc\game_vc\CHeli.cpp</h3><h4>CHeli::CHeli</h4>
<p>plugin::CallMethod<0x5AF7F0, CHeli *, int, unsigned char>(this, modelIndex, createdBy);</p>
<p>0AA6: call_method 0x5AF7F0 struct [CHeli] num_params 2 pop 0 [modelIndex] [createdBy]</p>
<p>define function CHeli__CHeli&lt;thiscall, 0x5AF7F0&gt;(modelIndex, createdBy)</p>
<h4>CHeli::InitHelis</h4>
<p>plugin::Call<0x5AD4A0>();</p>
<p>0AA5: call_function 0x5AD4A0 num_params 0 pop 0</p>
<p>define function CHeli__InitHelis&lt;cdecl, 0x5AD4A0&gt;()</p>
<h4>CHeli::PreRenderAlways</h4>
<p>plugin::CallMethod<0x5AF2E0, CHeli *>(this);</p>
<p>0AA6: call_method 0x5AF2E0 struct [CHeli] num_params 0 pop 0</p>
<p>define function CHeli__PreRenderAlways&lt;thiscall, 0x5AF2E0&gt;()</p>
<h4>CHeli::SendDownSwat</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5ABE20, CHeli *>(this);</p>
<p>0AA8: call_method_return 0x5ABE20 struct [CHeli] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CHeli__SendDownSwat&lt;thiscall, 0x5ABE20&gt;(): int</p>
<h4>CHeli::SpawnFlyingComponent</h4>
<p>plugin::CallMethodAndReturn<CObject*, 0x5AC1E0, CHeli *, int>(this, nodeIndex);</p>
<p>0AA8: call_method_return 0x5AC1E0 struct [CHeli] num_params 1 pop 0 [nodeIndex] func_ret [CObject*]</p>
<p>define function CHeli__SpawnFlyingComponent&lt;thiscall, 0x5AC1E0&gt;(nodeIndex): int</p>
<h4>CHeli::SpecialHeliPreRender</h4>
<p>plugin::CallAndReturn<bool, 0x5AC500>();</p>
<p>0AA7: call_function_return 0x5AC500 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CHeli__SpecialHeliPreRender&lt;cdecl, 0x5AC500&gt;(): int</p>
<h4>CHeli::TestBulletCollision</h4>
<p>plugin::CallAndReturn<bool, 0x5AC6C0, CVector<em>, CVector</em>, CVector*, int>(arg0, arg1, arg2, arg3);</p>
<p>0AA7: call_function_return 0x5AC6C0 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3] func_ret [bool]</p>
<p>define function CHeli__TestBulletCollision&lt;cdecl, 0x5AC6C0&gt;(arg0, arg1, arg2, arg3): int</p>
<h4>CHeli::TestRocketCollision</h4>
<p>plugin::CallAndReturn<bool, 0x5AC9A0, CVector*>(arg0);</p>
<p>0AA7: call_function_return 0x5AC9A0 num_params 1 pop 1 [arg0] func_ret [bool]</p>
<p>define function CHeli__TestRocketCollision&lt;cdecl, 0x5AC9A0&gt;(arg0): int</p>
<h4>CHeli::TestSniperCollision</h4>
<p>plugin::CallAndReturn<bool, 0x5AC520, CVector<em>, CVector</em>>(origin, target);</p>
<p>0AA7: call_function_return 0x5AC520 num_params 2 pop 2 [origin] [target] func_ret [bool]</p>
<p>define function CHeli__TestSniperCollision&lt;cdecl, 0x5AC520&gt;(origin, target): int</p>
<h4>CHeli::UpdateHelis</h4>
<p>plugin::Call<0x5ACDA0>();</p>
<p>0AA5: call_function 0x5ACDA0 num_params 0 pop 0</p>
<p>define function CHeli__UpdateHelis&lt;cdecl, 0x5ACDA0&gt;()</p>
<h4>GenerateHeli</h4>
<p>plugin::Call<0x5ACB30, bool>(enable);</p>
<p>0AA5: call_function 0x5ACB30 num_params 1 pop 1 [enable]</p>
<p>define function GenerateHeli&lt;cdecl, 0x5ACB30&gt;(enable)</p>
<h4>StartCatalinaFlyBy</h4>
<p>plugin::Call<0x5ACAF0>();</p>
<p>0AA5: call_function 0x5ACAF0 num_params 0 pop 0</p>
<p>define function StartCatalinaFlyBy&lt;cdecl, 0x5ACAF0&gt;()</p>
<h4>GetHeliAtomicObjectCB</h4>
<p>plugin::CallAndReturn<RwObject<em>, 0x5AC4E0, RwObject</em>, void*>(object, data);</p>
<p>0AA7: call_function_return 0x5AC4E0 num_params 2 pop 2 [object] [data] func_ret [RwObject*]</p>
<p>define function GetHeliAtomicObjectCB&lt;cdecl, 0x5AC4E0&gt;(object, data): int</p><h3 id="plugin_vcgame_vcchudcpp">plugin_vc\game_vc\CHud.cpp</h3><h4>CHud::DrawFadeState</h4>
<p>plugin::CallDynGlobal<DRAW_FADE_STATE, int>(gaddrof(CHud::DrawFadeState), fadeState, a2);</p>
<h4>CHud::IsHelpMessageBeingDisplayed</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CHud::IsHelpMessageBeingDisplayed));</p>
<p>0AA7: call_function_return 0x55BFB0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CHud__IsHelpMessageBeingDisplayed&lt;cdecl, 0x55BFB0&gt;(): int</p>
<h4>CHud::SetBigMessage</h4>
<p>plugin::CallDynGlobal<wchar_t const *, unsigned short>(gaddrof_o(CHud::SetBigMessage, void (*)(wchar_t const *, unsigned short)), message, style);</p>
<h4>CHud::SetHelpMessage</h4>
<p>plugin::CallDynGlobal<wchar_t const *, bool, bool>(gaddrof_o(CHud::SetHelpMessage, void (*)(wchar_t const *, bool, bool)), message, quickMessage, permanent);</p>
<h4>CHud::SetMessage</h4>
<p>plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetMessage, void (*)(wchar_t const *)), message);</p>
<h4>CHud::SetPagerMessage</h4>
<p>plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetPagerMessage, void (*)(wchar_t const *)), message);</p>
<h4>CHud::SetVehicleName</h4>
<p>plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetVehicleName, void (*)(wchar_t const *)), name);</p>
<h4>CHud::SetZoneName</h4>
<p>plugin::CallDynGlobal<wchar_t const *>(gaddrof_o(CHud::SetZoneName, void (*)(wchar_t const *)), name);</p><h3 id="plugin_vcgame_vcckeyboardstatecpp">plugin_vc\game_vc\CKeyboardState.cpp</h3><h4>CKeyboardState::Clear</h4>
<p>plugin::CallMethodDynGlobal<CKeyboardState *>(gaddrof(CKeyboardState::Clear), this);</p>
<p>0AA6: call_method 0x4AE1C0 struct [CKeyboardState] num_params 0 pop 0</p>
<p>define function CKeyboardState__Clear&lt;thiscall, 0x4AE1C0&gt;()</p><h3 id="plugin_vcgame_vccmenumanagercpp">plugin_vc\game_vc\CMenuManager.cpp</h3><h4>CMenuManager::MessageScreen</h4>
<p>plugin::CallMethod<0x498943, CMenuManager<em>, const char</em>, bool>(this, pText, bFullscreen);</p>
<p>0AA6: call_method 0x498943 struct [CMenuManager] num_params 2 pop 0 [pText] [bFullscreen]</p>
<p>define function CMenuManager__MessageScreen&lt;thiscall, 0x498943&gt;(pText, bFullscreen)</p>
<h4>CMenuManager::DisplayHelperText</h4>
<p>plugin::CallMethod<0x48F429, CMenuManager*>(this, text);</p>
<p>0AA6: call_method 0x48F429 struct [CMenuManager] num_params 1 pop 0 [text]</p>
<p>define function CMenuManager__DisplayHelperText&lt;thiscall, 0x48F429&gt;(text)</p>
<h4>CMenuManager::SwitchToNewScreen</h4>
<p>plugin::CallMethod<0x4983EF, CMenuManager*, int>(this, screen);</p>
<p>0AA6: call_method 0x4983EF struct [CMenuManager] num_params 1 pop 0 [screen]</p>
<p>define function CMenuManager__SwitchToNewScreen&lt;thiscall, 0x4983EF&gt;(screen)</p>
<h4>CMenuManager::SwitchMenuOnAndOff</h4>
<p>plugin::CallMethod<0x498E5F, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x498E5F struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__SwitchMenuOnAndOff&lt;thiscall, 0x498E5F&gt;()</p>
<h4>CMenuManager::CheckSliderMovement</h4>
<p>plugin::CallMethod<0x4982D3, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x4982D3 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__CheckSliderMovement&lt;thiscall, 0x4982D3&gt;()</p>
<h4>CMenuManager::Draw</h4>
<p>plugin::CallMethod<0x49DF40, CMenuManager*>(this, unk);</p>
<p>0AA6: call_method 0x49DF40 struct [CMenuManager] num_params 1 pop 0 [unk]</p>
<p>define function CMenuManager__Draw&lt;thiscall, 0x49DF40&gt;(unk)</p>
<h4>CMenuManager::UserInput</h4>
<p>plugin::CallMethod<0x4965BA, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x4965BA struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__UserInput&lt;thiscall, 0x4965BA&gt;()</p>
<h4>CMenuManager::PrintMap</h4>
<p>plugin::CallMethod<0x49A5B7, CMenuManager*>(this);</p>
<p>0AA6: call_method 0x49A5B7 struct [CMenuManager] num_params 0 pop 0</p>
<p>define function CMenuManager__PrintMap&lt;thiscall, 0x49A5B7&gt;()</p><h3 id="plugin_vcgame_vccmessagescpp">plugin_vc\game_vc\CMessages.cpp</h3><h4>CMessages::AddBigMessage</h4>
<p>plugin::Call<0x584050, wchar_t*, unsigned int, unsigned short>(pString, time, style);</p>
<p>0AA5: call_function 0x584050 num_params 3 pop 3 [pString] [time] [style]</p>
<p>define function CMessages__AddBigMessage&lt;cdecl, 0x584050&gt;(pString, time, style)</p>
<h4>CMessages::AddBigMessageQ</h4>
<p>plugin::Call<0x583F40, wchar_t*, unsigned int, unsigned short>(pString, time, style);</p>
<p>0AA5: call_function 0x583F40 num_params 3 pop 3 [pString] [time] [style]</p>
<p>define function CMessages__AddBigMessageQ&lt;cdecl, 0x583F40&gt;(pString, time, style)</p>
<h4>CMessages::AddBigMessageWithNumber</h4>
<p>plugin::Call<0x583350, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, style, number, number2, number3, number4, number5, number6);</p>
<p>0AA5: call_function 0x583350 num_params 9 pop 9 [pString] [time] [style] [number] [number2] [number3] [number4] [number5] [number6]</p>
<p>define function CMessages__AddBigMessageWithNumber&lt;cdecl, 0x583350&gt;(pString, time, style, number, number2, number3, number4, number5, number6)</p>
<h4>CMessages::AddMessage</h4>
<p>plugin::Call<0x584410, wchar_t*, unsigned int, unsigned short>(pString, time, flag);</p>
<p>0AA5: call_function 0x584410 num_params 3 pop 3 [pString] [time] [flag]</p>
<p>define function CMessages__AddMessage&lt;cdecl, 0x584410&gt;(pString, time, flag)</p>
<h4>CMessages::AddMessageJumpQ</h4>
<p>plugin::Call<0x584300, wchar_t*, unsigned int, unsigned short>(pString, time, flag);</p>
<p>0AA5: call_function 0x584300 num_params 3 pop 3 [pString] [time] [flag]</p>
<p>define function CMessages__AddMessageJumpQ&lt;cdecl, 0x584300&gt;(pString, time, flag)</p>
<h4>CMessages::AddMessageJumpQWithNumber</h4>
<p>plugin::Call<0x583440, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, flag, number, number2, number3, number4, number5, number6);</p>
<p>0AA5: call_function 0x583440 num_params 9 pop 9 [pString] [time] [flag] [number] [number2] [number3] [number4] [number5] [number6]</p>
<p>define function CMessages__AddMessageJumpQWithNumber&lt;cdecl, 0x583440&gt;(pString, time, flag, number, number2, number3, number4, number5, number6)</p>
<h4>CMessages::AddMessageJumpQWithString</h4>
<p>plugin::Call<0x583220, wchar_t<em>, unsigned int, unsigned short, wchar_t</em>>(pString1, time, flag, pString2);</p>
<p>0AA5: call_function 0x583220 num_params 4 pop 4 [pString1] [time] [flag] [pString2]</p>
<p>define function CMessages__AddMessageJumpQWithString&lt;cdecl, 0x583220&gt;(pString1, time, flag, pString2)</p>
<h4>CMessages::AddMessageWithNumber</h4>
<p>plugin::Call<0x583560, wchar_t*, unsigned int, unsigned short, int, int, int, int, int, int>(pString, time, flag, number, number1, number2, number3, number4, number5);</p>
<p>0AA5: call_function 0x583560 num_params 9 pop 9 [pString] [time] [flag] [number] [number1] [number2] [number3] [number4] [number5]</p>
<p>define function CMessages__AddMessageWithNumber&lt;cdecl, 0x583560&gt;(pString, time, flag, number, number1, number2, number3, number4, number5)</p>
<h4>CMessages::AddToPreviousBriefArray</h4>
<p>plugin::Call<0x583DE0, wchar_t<em>, int, int, int, int, int, int, wchar_t</em>>(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x583DE0 num_params 8 pop 8 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CMessages__AddToPreviousBriefArray&lt;cdecl, 0x583DE0&gt;(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)</p>
<h4>CMessages::ClearAllMessagesDisplayedByGame</h4>
<p>plugin::Call<0x582C70>();</p>
<p>0AA5: call_function 0x582C70 num_params 0 pop 0</p>
<p>define function CMessages__ClearAllMessagesDisplayedByGame&lt;cdecl, 0x582C70&gt;()</p>
<h4>CMessages::ClearMessages</h4>
<p>plugin::Call<0x5841E0>();</p>
<p>0AA5: call_function 0x5841E0 num_params 0 pop 0</p>
<p>define function CMessages__ClearMessages&lt;cdecl, 0x5841E0&gt;()</p>
<h4>CMessages::ClearSmallMessagesOnly</h4>
<p>plugin::Call<0x584130>();</p>
<p>0AA5: call_function 0x584130 num_params 0 pop 0</p>
<p>define function CMessages__ClearSmallMessagesOnly&lt;cdecl, 0x584130&gt;()</p>
<h4>CMessages::ClearThisBigPrint</h4>
<p>plugin::Call<0x582CF0, wchar_t*>(pString);</p>
<p>0AA5: call_function 0x582CF0 num_params 1 pop 1 [pString]</p>
<p>define function CMessages__ClearThisBigPrint&lt;cdecl, 0x582CF0&gt;(pString)</p>
<h4>CMessages::ClearThisPrint</h4>
<p>plugin::Call<0x582FA0, wchar_t*>(pString);</p>
<p>0AA5: call_function 0x582FA0 num_params 1 pop 1 [pString]</p>
<p>define function CMessages__ClearThisPrint&lt;cdecl, 0x582FA0&gt;(pString)</p>
<h4>CMessages::Display</h4>
<p>plugin::Call<0x584550>();</p>
<p>0AA5: call_function 0x584550 num_params 0 pop 0</p>
<p>define function CMessages__Display&lt;cdecl, 0x584550&gt;()</p>
<h4>CMessages::GetWideStringLength</h4>
<p>plugin::CallAndReturn<unsigned short, 0x5849A0, wchar_t*>(pString);</p>
<p>0AA7: call_function_return 0x5849A0 num_params 1 pop 1 [pString] func_ret [unsigned short]</p>
<p>define function CMessages__GetWideStringLength&lt;cdecl, 0x5849A0&gt;(pString): int</p>
<h4>CMessages::Init</h4>
<p>plugin::Call<0x5849C0>();</p>
<p>0AA5: call_function 0x5849C0 num_params 0 pop 0</p>
<p>define function CMessages__Init&lt;cdecl, 0x5849C0&gt;()</p>
<h4>CMessages::InsertNumberInString</h4>
<p>plugin::Call<0x583C80, wchar_t<em>, int, int, int, int, int, int, wchar_t</em>>(pString, number, number1, number2, number3, number4, number5, arg8);</p>
<p>0AA5: call_function 0x583C80 num_params 8 pop 8 [pString] [number] [number1] [number2] [number3] [number4] [number5] [arg8]</p>
<p>define function CMessages__InsertNumberInString&lt;cdecl, 0x583C80&gt;(pString, number, number1, number2, number3, number4, number5, arg8)</p>
<h4>CMessages::InsertPlayerControlKeysInString</h4>
<p>plugin::Call<0x5836B0, wchar_t*>(pString);</p>
<p>0AA5: call_function 0x5836B0 num_params 1 pop 1 [pString]</p>
<p>define function CMessages__InsertPlayerControlKeysInString&lt;cdecl, 0x5836B0&gt;(pString)</p>
<h4>CMessages::InsertStringInString</h4>
<p>plugin::Call<0x583AF0, wchar_t<em>, wchar_t</em>>(pString1, pString2);</p>
<p>0AA5: call_function 0x583AF0 num_params 2 pop 2 [pString1] [pString2]</p>
<p>define function CMessages__InsertStringInString&lt;cdecl, 0x583AF0&gt;(pString1, pString2)</p>
<h4>CMessages::Process</h4>
<p>plugin::Call<0x584650>();</p>
<p>0AA5: call_function 0x584650 num_params 0 pop 0</p>
<p>define function CMessages__Process&lt;cdecl, 0x584650&gt;()</p>
<h4>CMessages::WideStringCompare</h4>
<p>plugin::CallAndReturn<bool, 0x5848D0, wchar_t<em>, wchar_t</em>, unsigned short>(pString1, pString2, lengthToCompare);</p>
<p>0AA7: call_function_return 0x5848D0 num_params 3 pop 3 [pString1] [pString2] [lengthToCompare] func_ret [bool]</p>
<p>define function CMessages__WideStringCompare&lt;cdecl, 0x5848D0&gt;(pString1, pString2, lengthToCompare): int</p>
<h4>CMessages::WideStringCopy</h4>
<p>plugin::Call<0x584940, wchar_t<em>, wchar_t</em>, unsigned short>(pString1, pString2, lengthToCopy);</p>
<p>0AA5: call_function 0x584940 num_params 3 pop 3 [pString1] [pString2] [lengthToCopy]</p>
<p>define function CMessages__WideStringCopy&lt;cdecl, 0x584940&gt;(pString1, pString2, lengthToCopy)</p><h3 id="plugin_vcgame_vccmodelinfocpp">plugin_vc\game_vc\CModelInfo.cpp</h3><h4>CModelInfo::AddClumpModel</h4>
<p>plugin::CallAndReturn<CClumpModelInfo*, 0x55F640, int>(index);</p>
<p>0AA7: call_function_return 0x55F640 num_params 1 pop 1 [index] func_ret [CClumpModelInfo*]</p>
<p>define function CModelInfo__AddClumpModel&lt;cdecl, 0x55F640&gt;(index): int</p>
<h4>CModelInfo::AddPedModel</h4>
<p>plugin::CallAndReturn<CPedModelInfo*, 0x55F580, int>(index);</p>
<p>0AA7: call_function_return 0x55F580 num_params 1 pop 1 [index] func_ret [CPedModelInfo*]</p>
<p>define function CModelInfo__AddPedModel&lt;cdecl, 0x55F580&gt;(index): int</p>
<h4>CModelInfo::AddSimpleModel</h4>
<p>plugin::CallAndReturn<CSimpleModelInfo*, 0x55F730, int>(index);</p>
<p>0AA7: call_function_return 0x55F730 num_params 1 pop 1 [index] func_ret [CSimpleModelInfo*]</p>
<p>define function CModelInfo__AddSimpleModel&lt;cdecl, 0x55F730&gt;(index): int</p>
<h4>CModelInfo::AddTimeModel</h4>
<p>plugin::CallAndReturn<CTimeModelInfo*, 0x55F6E0, int>(index);</p>
<p>0AA7: call_function_return 0x55F6E0 num_params 1 pop 1 [index] func_ret [CTimeModelInfo*]</p>
<p>define function CModelInfo__AddTimeModel&lt;cdecl, 0x55F6E0&gt;(index): int</p>
<h4>CModelInfo::AddVehicleModel</h4>
<p>plugin::CallAndReturn<CVehicleModelInfo*, 0x55F5D0, int>(index);</p>
<p>0AA7: call_function_return 0x55F5D0 num_params 1 pop 1 [index] func_ret [CVehicleModelInfo*]</p>
<p>define function CModelInfo__AddVehicleModel&lt;cdecl, 0x55F5D0&gt;(index): int</p>
<h4>CModelInfo::AddWeaponModel</h4>
<p>plugin::CallAndReturn<CWeaponModelInfo*, 0x55F690, int>(index);</p>
<p>0AA7: call_function_return 0x55F690 num_params 1 pop 1 [index] func_ret [CWeaponModelInfo*]</p>
<p>define function CModelInfo__AddWeaponModel&lt;cdecl, 0x55F690&gt;(index): int</p>
<h4>CModelInfo::Get2dEffectStore</h4>
<p>plugin::CallAndReturn<void*, 0x55F570>();</p>
<p>0AA7: call_function_return 0x55F570 num_params 0 pop 0 func_ret [void*]</p>
<p>define function CModelInfo__Get2dEffectStore&lt;cdecl, 0x55F570&gt;(): int</p>
<h4>CModelInfo::GetModelInfo</h4>
<p>plugin::CallAndReturn<CBaseModelInfo<em>, 0x55F7D0, char const</em>, int*>(name, index);</p>
<p>0AA7: call_function_return 0x55F7D0 num_params 2 pop 2 [name] [index] func_ret [CBaseModelInfo*]</p>
<p>define function CModelInfo__GetModelInfo&lt;cdecl, 0x55F7D0&gt;(name, index): int</p>
<h4>CModelInfo::GetModelInfo</h4>
<p>plugin::CallAndReturn<CBaseModelInfo<em>, 0x55F780, char const</em>, int, int>(name, minIndex, maxInedx);</p>
<p>0AA7: call_function_return 0x55F780 num_params 3 pop 3 [name] [minIndex] [maxInedx] func_ret [CBaseModelInfo*]</p>
<p>define function CModelInfo__GetModelInfo&lt;cdecl, 0x55F780&gt;(name, minIndex, maxInedx): int</p>
<h4>CModelInfo::Initialise</h4>
<p>plugin::Call<0x55FA40>();</p>
<p>0AA5: call_function 0x55FA40 num_params 0 pop 0</p>
<p>define function CModelInfo__Initialise&lt;cdecl, 0x55FA40&gt;()</p>
<h4>CModelInfo::IsBikeModel</h4>
<p>plugin::CallAndReturn<bool, 0x55F4E0, int>(index);</p>
<p>0AA7: call_function_return 0x55F4E0 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CModelInfo__IsBikeModel&lt;cdecl, 0x55F4E0&gt;(index): int</p>
<h4>CModelInfo::IsBoatModel</h4>
<p>plugin::CallAndReturn<bool, 0x55F540, int>(index);</p>
<p>0AA7: call_function_return 0x55F540 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CModelInfo__IsBoatModel&lt;cdecl, 0x55F540&gt;(index): int</p>
<h4>CModelInfo::IsCarModel</h4>
<p>plugin::CallAndReturn<bool, 0x55F510, int>(index);</p>
<p>0AA7: call_function_return 0x55F510 num_params 1 pop 1 [index] func_ret [bool]</p>
<p>define function CModelInfo__IsCarModel&lt;cdecl, 0x55F510&gt;(index): int</p>
<h4>CModelInfo::ShutDown</h4>
<p>plugin::Call<0x55F820>();</p>
<p>0AA5: call_function 0x55F820 num_params 0 pop 0</p>
<p>define function CModelInfo__ShutDown&lt;cdecl, 0x55F820&gt;()</p><h3 id="plugin_vcgame_vccmotionblurstreakscpp">plugin_vc\game_vc\CMotionBlurStreaks.cpp</h3><h4>CMotionBlurStreaks::RegisterStreak</h4>
<p>plugin::Call<0x572800, unsigned int, unsigned char, unsigned char, unsigned char, CVector, CVector>(id, red, green, blue, leftPoint, rightPoint);</p>
<p>0AA5: call_function 0x572800 num_params 6 pop 6 [id] [red] [green] [blue] [leftPoint] [rightPoint]</p>
<p>define function CMotionBlurStreaks__RegisterStreak&lt;cdecl, 0x572800&gt;(id, red, green, blue, leftPoint, rightPoint)</p>
<h4>CMotionBlurStreaks::Render</h4>
<p>plugin::Call<0x572920>();</p>
<p>0AA5: call_function 0x572920 num_params 0 pop 0</p>
<p>define function CMotionBlurStreaks__Render&lt;cdecl, 0x572920&gt;()</p><h3 id="plugin_vcgame_vccmousepointerstatehelpercpp">plugin_vc\game_vc\CMousePointerStateHelper.cpp</h3><h3 id="plugin_vcgame_vccmoviecpp">plugin_vc\game_vc\CMovie.cpp</h3><h4>CMovie::CMovie</h4>
<p>plugin::CallMethod<0x606720, CMovie *>(this);</p>
<p>0AA6: call_method 0x606720 struct [CMovie] num_params 0 pop 0</p>
<p>define function CMovie__CMovie&lt;thiscall, 0x606720&gt;()</p><h3 id="plugin_vcgame_vccobjectcpp">plugin_vc\game_vc\CObject.cpp</h3><h4>CObject::CObject</h4>
<p>plugin::CallMethod<0x4E40F0, CObject <em>, CDummyObject</em>>(this, dummyObject);</p>
<p>0AA6: call_method 0x4E40F0 struct [CObject] num_params 1 pop 0 [dummyObject]</p>
<p>define function CObject__CObject&lt;thiscall, 0x4E40F0&gt;(dummyObject)</p>
<h4>CObject::CObject</h4>
<p>plugin::CallMethod<0x4E41B0, CObject *, int, bool>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4E41B0 struct [CObject] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CObject__CObject&lt;thiscall, 0x4E41B0&gt;(arg0, arg1)</p>
<h4>CObject::CObject</h4>
<p>plugin::CallMethod<0x4E4220, CObject *>(this);</p>
<p>0AA6: call_method 0x4E4220 struct [CObject] num_params 0 pop 0</p>
<p>define function CObject__CObject&lt;thiscall, 0x4E4220&gt;()</p>
<h4>CObject::CanBeDeleted</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4E3E20, CObject *>(this);</p>
<p>0AA8: call_method_return 0x4E3E20 struct [CObject] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CObject__CanBeDeleted&lt;thiscall, 0x4E3E20&gt;(): int</p>
<h4>CObject::DeleteAllMissionObjects</h4>
<p>plugin::Call<0x4E0820>();</p>
<p>0AA5: call_function 0x4E0820 num_params 0 pop 0</p>
<p>define function CObject__DeleteAllMissionObjects&lt;cdecl, 0x4E0820&gt;()</p>
<h4>CObject::DeleteAllTempObjects</h4>
<p>plugin::Call<0x4E08A0>();</p>
<p>0AA5: call_function 0x4E08A0 num_params 0 pop 0</p>
<p>define function CObject__DeleteAllTempObjects&lt;cdecl, 0x4E08A0&gt;()</p>
<h4>CObject::DeleteAllTempObjectsInArea</h4>
<p>plugin::Call<0x4E0720, CVector, float>(point, radius);</p>
<p>0AA5: call_function 0x4E0720 num_params 2 pop 2 [point] [radius]</p>
<p>define function CObject__DeleteAllTempObjectsInArea&lt;cdecl, 0x4E0720&gt;(point, radius)</p>
<h4>CObject::Init</h4>
<p>plugin::CallMethod<0x4E3E50, CObject *>(this);</p>
<p>0AA6: call_method 0x4E3E50 struct [CObject] num_params 0 pop 0</p>
<p>define function CObject__Init&lt;thiscall, 0x4E3E50&gt;()</p>
<h4>CObject::ObjectDamage</h4>
<p>plugin::CallMethod<0x4E0990, CObject *, float>(this, damage);</p>
<p>0AA6: call_method 0x4E0990 struct [CObject] num_params 1 pop 0 [damage]</p>
<p>define function CObject__ObjectDamage&lt;thiscall, 0x4E0990&gt;(damage)</p>
<h4>CObject::RefModelInfo</h4>
<p>plugin::CallMethod<0x4E0970, CObject *, int>(this, modelIndex);</p>
<p>0AA6: call_method 0x4E0970 struct [CObject] num_params 1 pop 0 [modelIndex]</p>
<p>define function CObject__RefModelInfo&lt;thiscall, 0x4E0970&gt;(modelIndex)</p>
<h4>CObject::operator delete</h4>
<p>plugin::Call<0x4E4030, void*>(data);</p>
<p>0AA5: call_function 0x4E4030 num_params 1 pop 1 [data]</p>
<p>define function CObject__operator delete&lt;cdecl, 0x4E4030&gt;(data)</p>
<h4>CObject::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x4E4070, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x4E4070 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CObject__operator new&lt;cdecl, 0x4E4070&gt;(size): int</p>
<h4>CObject::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x4E4050, unsigned int, int>(size, arg1);</p>
<p>0AA7: call_function_return 0x4E4050 num_params 2 pop 2 [size] [arg1] func_ret [void*]</p>
<p>define function CObject__operator new&lt;cdecl, 0x4E4050&gt;(size, arg1): int</p><h3 id="plugin_vcgame_vccocclusioncpp">plugin_vc\game_vc\COcclusion.cpp</h3><h4>COcclusion::AddOne</h4>
<p>plugin::CallDynGlobal<float, float, float, float, float, float, float>(gaddrof(COcclusion::AddOne), x, y, z, width, length, height, angle);</p>
<h4>COcclusion::IsAABoxOccluded</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector, float, float, float>(gaddrof(COcclusion::IsAABoxOccluded), pos, width, length, height);</p>
<p>0AA7: call_function_return 0x634150 num_params 4 pop 4 [pos] [width] [length] [height] func_ret [bool]</p>
<p>define function COcclusion__IsAABoxOccluded&lt;cdecl, 0x634150&gt;(pos, width, length, height): int</p>
<h4>COcclusion::IsPositionOccluded</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector, float>(gaddrof(COcclusion::IsPositionOccluded), pos, side);</p>
<p>0AA7: call_function_return 0x634930 num_params 2 pop 2 [pos] [side] func_ret [bool]</p>
<p>define function COcclusion__IsPositionOccluded&lt;cdecl, 0x634930&gt;(pos, side): int</p>
<h4>COccluder::ProcessLineSegment</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, COccluder *, int, int, CActiveOccluder *>(gaddrof(COccluder::ProcessLineSegment), this, corner1, corner2, occl);</p>
<p>0AA8: call_method_return 0x635270 struct [COccluder] num_params 3 pop 0 [corner1] [corner2] [occl] func_ret [bool]</p>
<h4>COccluder::ProcessOneOccluder</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, COccluder *, CActiveOccluder *>(gaddrof(COccluder::ProcessOneOccluder), this, occl);</p>
<p>0AA8: call_method_return 0x6358D0 struct [COccluder] num_params 1 pop 0 [occl] func_ret [bool]</p>
<h4>DoesInfiniteLineTouchScreen</h4>
<p>plugin::CallAndReturnDynGlobal<bool, float, float, float, float>(gaddrof(DoesInfiniteLineTouchScreen), lineX, lineY, lineDX, lineDY);</p>
<p>0AA7: call_function_return 0x636B60 num_params 4 pop 4 [lineX] [lineY] [lineDX] [lineDY] func_ret [bool]</p>
<p>define function DoesInfiniteLineTouchScreen&lt;cdecl, 0x636B60&gt;(lineX, lineY, lineDX, lineDY): int</p><h3 id="plugin_vcgame_vccommoncpp">plugin_vc\game_vc\common.cpp</h3><h4>FindPlayerHeading</h4>
<p>plugin::CallAndReturn<float, 0x4BBF70>();</p>
<p>0AA7: call_function_return 0x4BBF70 num_params 0 pop 0 func_ret [float]</p>
<p>define function FindPlayerHeading&lt;cdecl, 0x4BBF70&gt;(): float</p>
<h4>FindPlayerCentreOfWorld_NoSniperShift</h4>
<p>plugin::CallAndReturn<CVector&, 0x4BC020>();</p>
<p>0AA7: call_function_return 0x4BC020 num_params 0 pop 0 func_ret [CVector&amp;]</p>
<p>define function FindPlayerCentreOfWorld_NoSniperShift&lt;cdecl, 0x4BC020&gt;(): int</p>
<h4>FindPlayerCentreOfWorld</h4>
<p>plugin::CallAndReturn<CVector&, 0x4BC0A0, int>(playerId);</p>
<p>0AA7: call_function_return 0x4BC0A0 num_params 1 pop 1 [playerId] func_ret [CVector&amp;]</p>
<p>define function FindPlayerCentreOfWorld&lt;cdecl, 0x4BC0A0&gt;(playerId): int</p>
<h4>FindPlayerPed</h4>
<p>plugin::CallAndReturn<CPlayerPed*, 0x4BC120>();</p>
<p>0AA7: call_function_return 0x4BC120 num_params 0 pop 0 func_ret [CPlayerPed*]</p>
<p>define function FindPlayerPed&lt;cdecl, 0x4BC120&gt;(): int</p>
<h4>FindPlayerTrain</h4>
<p>plugin::CallAndReturn<CTrain*, 0x4BC140>();</p>
<p>0AA7: call_function_return 0x4BC140 num_params 0 pop 0 func_ret [CTrain*]</p>
<p>define function FindPlayerTrain&lt;cdecl, 0x4BC140&gt;(): int</p>
<h4>FindPlayerEntity</h4>
<p>plugin::CallAndReturn<CEntity*, 0x4BC1B0>();</p>
<p>0AA7: call_function_return 0x4BC1B0 num_params 0 pop 0 func_ret [CEntity*]</p>
<p>define function FindPlayerEntity&lt;cdecl, 0x4BC1B0&gt;(): int</p>
<h4>FindPlayerVehicle</h4>
<p>plugin::CallAndReturn<CVehicle*, 0x4BC1E0>();</p>
<p>0AA7: call_function_return 0x4BC1E0 num_params 0 pop 0 func_ret [CVehicle*]</p>
<p>define function FindPlayerVehicle&lt;cdecl, 0x4BC1E0&gt;(): int</p>
<h4>FindPlayerSpeed</h4>
<p>plugin::CallAndReturn<CVector&, 0x4BC210>();</p>
<p>0AA7: call_function_return 0x4BC210 num_params 0 pop 0 func_ret [CVector&amp;]</p>
<p>define function FindPlayerSpeed&lt;cdecl, 0x4BC210&gt;(): int</p>
<h4>GetFirstTexture</h4>
<p>plugin::CallAndReturn<RwTexture<em>, 0x57F900, RwTexDictionary</em>>(texDictionary);</p>
<p>0AA7: call_function_return 0x57F900 num_params 1 pop 1 [texDictionary] func_ret [RwTexture*]</p>
<p>define function GetFirstTexture&lt;cdecl, 0x57F900&gt;(texDictionary): int</p>
<h4>GetFirstObject</h4>
<p>plugin::CallAndReturn<RwObject<em>, 0x57F940, RwFrame</em>>(frame);</p>
<p>0AA7: call_function_return 0x57F940 num_params 1 pop 1 [frame] func_ret [RwObject*]</p>
<p>define function GetFirstObject&lt;cdecl, 0x57F940&gt;(frame): int</p>
<h4>GetFirstAtomic</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57F980, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x57F980 num_params 1 pop 1 [clump] func_ret [RpAtomic*]</p>
<p>define function GetFirstAtomic&lt;cdecl, 0x57F980&gt;(clump): int</p>
<h4>SetAmbientColours</h4>
<p>plugin::Call<0x57FAD0, RwRGBAReal*>(colours);</p>
<p>0AA5: call_function 0x57FAD0 num_params 1 pop 1 [colours]</p>
<p>define function SetAmbientColours&lt;cdecl, 0x57FAD0&gt;(colours)</p>
<h4>SetAmbientColoursForPedsCarsAndObjects</h4>
<p>plugin::Call<0x57FAF0>();</p>
<p>0AA5: call_function 0x57FAF0 num_params 0 pop 0</p>
<p>define function SetAmbientColoursForPedsCarsAndObjects&lt;cdecl, 0x57FAF0&gt;()</p>
<h4>SetAmbientColours</h4>
<p>plugin::Call<0x57FB10>();</p>
<p>0AA5: call_function 0x57FB10 num_params 0 pop 0</p>
<p>define function SetAmbientColours&lt;cdecl, 0x57FB10&gt;()</p>
<h4>SetFullAmbient</h4>
<p>plugin::Call<0x57FB30>();</p>
<p>0AA5: call_function 0x57FB30 num_params 0 pop 0</p>
<p>define function SetFullAmbient&lt;cdecl, 0x57FB30&gt;()</p>
<h4>ActivateDirectional</h4>
<p>plugin::Call<0x57FB50>();</p>
<p>0AA5: call_function 0x57FB50 num_params 0 pop 0</p>
<p>define function ActivateDirectional&lt;cdecl, 0x57FB50&gt;()</p>
<h4>DeActivateDirectional</h4>
<p>plugin::Call<0x57FB60>();</p>
<p>0AA5: call_function 0x57FB60 num_params 0 pop 0</p>
<p>define function DeActivateDirectional&lt;cdecl, 0x57FB60&gt;()</p>
<h4>ReSetAmbientAndDirectionalColours</h4>
<p>plugin::Call<0x57FB70>();</p>
<p>0AA5: call_function 0x57FB70 num_params 0 pop 0</p>
<p>define function ReSetAmbientAndDirectionalColours&lt;cdecl, 0x57FB70&gt;()</p>
<h4>SetBrightMarkerColours</h4>
<p>plugin::Call<0x57FBA0, float>(power);</p>
<p>0AA5: call_function 0x57FBA0 num_params 1 pop 1 [power]</p>
<p>define function SetBrightMarkerColours&lt;cdecl, 0x57FBA0&gt;(power)</p>
<h4>SetAmbientAndDirectionalColours</h4>
<p>plugin::Call<0x57FC50, float>(power);</p>
<p>0AA5: call_function 0x57FC50 num_params 1 pop 1 [power]</p>
<p>define function SetAmbientAndDirectionalColours&lt;cdecl, 0x57FC50&gt;(power)</p>
<h4>RemoveExtraDirectionalLights</h4>
<p>plugin::Call<0x57FCD0, RpWorld*>(world);</p>
<p>0AA5: call_function 0x57FCD0 num_params 1 pop 1 [world]</p>
<p>define function RemoveExtraDirectionalLights&lt;cdecl, 0x57FCD0&gt;(world)</p>
<h4>AddAnExtraDirectionalLight</h4>
<p>plugin::Call<0x57FD00, RpWorld*, float, float, float, float, float, float>(world, x, y, z, red, green, blue);</p>
<p>0AA5: call_function 0x57FD00 num_params 7 pop 7 [world] [x] [y] [z] [red] [green] [blue]</p>
<p>define function AddAnExtraDirectionalLight&lt;cdecl, 0x57FD00&gt;(world, x, y, z, red, green, blue)</p>
<h4>WorldReplaceNormalLightsWithScorched</h4>
<p>plugin::Call<0x57FE40, RpWorld*, float>(world, intensity);</p>
<p>0AA5: call_function 0x57FE40 num_params 2 pop 2 [world] [intensity]</p>
<p>define function WorldReplaceNormalLightsWithScorched&lt;cdecl, 0x57FE40&gt;(world, intensity)</p>
<h4>LightsDestroy</h4>
<p>plugin::CallAndReturn<RpWorld<em>, 0x57FE80, RpWorld</em>>(world);</p>
<p>0AA7: call_function_return 0x57FE80 num_params 1 pop 1 [world] func_ret [RpWorld*]</p>
<p>define function LightsDestroy&lt;cdecl, 0x57FE80&gt;(world): int</p>
<h4>LightsCreate</h4>
<p>plugin::CallAndReturn<RpWorld<em>, 0x57FF50, RpWorld</em>>(world);</p>
<p>0AA7: call_function_return 0x57FF50 num_params 1 pop 1 [world] func_ret [RpWorld*]</p>
<p>define function LightsCreate&lt;cdecl, 0x57FF50&gt;(world): int</p>
<h4>SetLightsWithTimeOfDayColour</h4>
<p>plugin::Call<0x5800F0, RpWorld*>(world);</p>
<p>0AA5: call_function 0x5800F0 num_params 1 pop 1 [world]</p>
<p>define function SetLightsWithTimeOfDayColour&lt;cdecl, 0x5800F0&gt;(world)</p>
<h4>RpAnimBlendAllocateData</h4>
<p>plugin::CallAndReturn<CAnimBlendClumpData<em>, 0x407520, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x407520 num_params 1 pop 1 [clump] func_ret [CAnimBlendClumpData*]</p>
<p>define function RpAnimBlendAllocateData&lt;cdecl, 0x407520&gt;(clump): int</p>
<h4>RpAnimBlendClumpFillFrameArray</h4>
<p>plugin::Call<0x407AC0, RpClump<em>, AnimBlendFrameData</em>*>(clump, frameData);</p>
<p>0AA5: call_function 0x407AC0 num_params 2 pop 2 [clump] [frameData]</p>
<p>define function RpAnimBlendClumpFillFrameArray&lt;cdecl, 0x407AC0&gt;(clump, frameData)</p>
<h4>RpAnimBlendClumpGetAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x407780, RpClump</em>, unsigned int>(clump, animId);</p>
<p>0AA7: call_function_return 0x407780 num_params 2 pop 2 [clump] [animId] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetAssociation&lt;cdecl, 0x407780&gt;(clump, animId): int</p>
<h4>RpAnimBlendClumpGetFirstAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x402E20, RpClump</em>>(clump);</p>
<p>0AA7: call_function_return 0x402E20 num_params 1 pop 1 [clump] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetFirstAssociation&lt;cdecl, 0x402E20&gt;(clump): int</p>
<h4>RpAnimBlendClumpGetFirstAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4075F0, RpClump</em>, unsigned int>(clump, flags);</p>
<p>0AA7: call_function_return 0x4075F0 num_params 2 pop 2 [clump] [flags] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetFirstAssociation&lt;cdecl, 0x4075F0&gt;(clump, flags): int</p>
<h4>RpAnimBlendClumpGetMainAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x407660, RpClump</em>, int>(clump, n);</p>
<p>0AA7: call_function_return 0x407660 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetMainAssociation&lt;cdecl, 0x407660&gt;(clump, n): int</p>
<h4>RpAnimBlendClumpGetMainPartialAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x407620, RpClump</em>, int>(clump, n);</p>
<p>0AA7: call_function_return 0x407620 num_params 2 pop 2 [clump] [n] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendClumpGetMainPartialAssociation&lt;cdecl, 0x407620&gt;(clump, n): int</p>
<h4>RpAnimBlendClumpInit</h4>
<p>plugin::Call<0x407890, RpClump*>(clump);</p>
<p>0AA5: call_function 0x407890 num_params 1 pop 1 [clump]</p>
<p>define function RpAnimBlendClumpInit&lt;cdecl, 0x407890&gt;(clump)</p>
<h4>RpAnimBlendClumpIsInitialized</h4>
<p>plugin::CallAndReturn<bool, 0x407870, RpClump*>(clump);</p>
<p>0AA7: call_function_return 0x407870 num_params 1 pop 1 [clump] func_ret [bool]</p>
<p>define function RpAnimBlendClumpIsInitialized&lt;cdecl, 0x407870&gt;(clump): int</p>
<h4>RpAnimBlendClumpRemoveAllAssociations</h4>
<p>plugin::Call<0x407800, RpClump*>(clump);</p>
<p>0AA5: call_function 0x407800 num_params 1 pop 1 [clump]</p>
<p>define function RpAnimBlendClumpRemoveAllAssociations&lt;cdecl, 0x407800&gt;(clump)</p>
<h4>RpAnimBlendClumpRemoveAssociations</h4>
<p>plugin::Call<0x4077B0, RpClump*, unsigned int>(clump, flags);</p>
<p>0AA5: call_function 0x4077B0 num_params 2 pop 2 [clump] [flags]</p>
<p>define function RpAnimBlendClumpRemoveAssociations&lt;cdecl, 0x4077B0&gt;(clump, flags)</p>
<h4>RpAnimBlendClumpSetBlendDeltas</h4>
<p>plugin::Call<0x407830, RpClump*, unsigned int, float>(clump, flags, delta);</p>
<p>0AA5: call_function 0x407830 num_params 3 pop 3 [clump] [flags] [delta]</p>
<p>define function RpAnimBlendClumpSetBlendDeltas&lt;cdecl, 0x407830&gt;(clump, flags, delta)</p>
<h4>RpAnimBlendClumpUpdateAnimations</h4>
<p>plugin::Call<0x404690, RpClump*, float, bool>(clump, step, onScreen);</p>
<p>0AA5: call_function 0x404690 num_params 3 pop 3 [clump] [step] [onScreen]</p>
<p>define function RpAnimBlendClumpUpdateAnimations&lt;cdecl, 0x404690&gt;(clump, step, onScreen)</p>
<h4>RpAnimBlendGetNextAssociation</h4>
<p>plugin::CallAndReturn<CAnimBlendAssociation<em>, 0x4075D0, CAnimBlendAssociation</em>>(association);</p>
<p>0AA7: call_function_return 0x4075D0 num_params 1 pop 1 [association] func_ret [CAnimBlendAssociation*]</p>
<p>define function RpAnimBlendGetNextAssociation&lt;cdecl, 0x4075D0&gt;(association): int</p>
<h4>RpAnimBlendPluginAttach</h4>
<p>plugin::CallAndReturn<bool, 0x4074D0>();</p>
<p>0AA7: call_function_return 0x4074D0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function RpAnimBlendPluginAttach&lt;cdecl, 0x4074D0&gt;(): int</p><h3 id="plugin_vcgame_vcconscreentimercpp">plugin_vc\game_vc\COnscreenTimer.cpp</h3><h4>COnscreenTimer::AddClock</h4>
<p>plugin::CallMethod<0x434B30, COnscreenTimer <em>, unsigned int, char</em>, bool>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x434B30 struct [COnscreenTimer] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function COnscreenTimer__AddClock&lt;thiscall, 0x434B30&gt;(arg0, arg1, arg2)</p>
<h4>COnscreenTimer::AddCounter</h4>
<p>plugin::CallMethod<0x434AE0, COnscreenTimer <em>, unsigned int, unsigned short, char</em>, unsigned short>(this, arg0, arg1, arg2, arg3);</p>
<p>0AA6: call_method 0x434AE0 struct [COnscreenTimer] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function COnscreenTimer__AddCounter&lt;thiscall, 0x434AE0&gt;(arg0, arg1, arg2, arg3)</p>
<h4>COnscreenTimer::ClearClock</h4>
<p>plugin::CallMethod<0x434AA0, COnscreenTimer *, unsigned int>(this, arg0);</p>
<p>0AA6: call_method 0x434AA0 struct [COnscreenTimer] num_params 1 pop 0 [arg0]</p>
<p>define function COnscreenTimer__ClearClock&lt;thiscall, 0x434AA0&gt;(arg0)</p>
<h4>COnscreenTimer::ClearCounter</h4>
<p>plugin::CallMethod<0x434A60, COnscreenTimer *, unsigned int>(this, arg0);</p>
<p>0AA6: call_method 0x434A60 struct [COnscreenTimer] num_params 1 pop 0 [arg0]</p>
<p>define function COnscreenTimer__ClearCounter&lt;thiscall, 0x434A60&gt;(arg0)</p>
<h4>COnscreenTimer::Init</h4>
<p>plugin::CallMethod<0x434CE0, COnscreenTimer *>(this);</p>
<p>0AA6: call_method 0x434CE0 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__Init&lt;thiscall, 0x434CE0&gt;()</p>
<h4>COnscreenTimer::Process</h4>
<p>plugin::CallMethod<0x434B90, COnscreenTimer *>(this);</p>
<p>0AA6: call_method 0x434B90 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__Process&lt;thiscall, 0x434B90&gt;()</p>
<h4>COnscreenTimer::ProcessForDisplay</h4>
<p>plugin::CallMethod<0x434BD0, COnscreenTimer *>(this);</p>
<p>0AA6: call_method 0x434BD0 struct [COnscreenTimer] num_params 0 pop 0</p>
<p>define function COnscreenTimer__ProcessForDisplay&lt;thiscall, 0x434BD0&gt;()</p>
<h4>COnscreenTimerEntry::Process</h4>
<p>plugin::CallMethod<0x434DE0, COnscreenTimerEntry *>(this);</p>
<p>0AA6: call_method 0x434DE0 struct [COnscreenTimerEntry] num_params 0 pop 0</p>
<p>define function COnscreenTimerEntry__Process&lt;thiscall, 0x434DE0&gt;()</p><h3 id="plugin_vcgame_vccpadcpp">plugin_vc\game_vc\CPad.cpp</h3><h4>CPad::AddToPCCheatString</h4>
<p>plugin::CallMethodDynGlobal<CPad *, char>(gaddrof(CPad::AddToPCCheatString), this, character);</p>
<p>0AA6: call_method 0x4ABD20 struct [CPad] num_params 1 pop 0 [character]</p>
<p>define function CPad__AddToPCCheatString&lt;thiscall, 0x4ABD20&gt;(character)</p>
<h4>CPad::CarGunJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CarGunJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA9F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::ChangeStationJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ChangeStationJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA590 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::Clear</h4>
<p>plugin::CallMethodDynGlobal<CPad *, char>(gaddrof(CPad::Clear), this, bDisablePlayerControls);</p>
<p>0AA6: call_method 0x4ADBE0 struct [CPad] num_params 1 pop 0 [bDisablePlayerControls]</p>
<p>define function CPad__Clear&lt;thiscall, 0x4ADBE0&gt;(bDisablePlayerControls)</p>
<h4>CPad::CollectPickupJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CollectPickupJustDown), this);</p>
<p>0AA8: call_method_return 0x4A9F80 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::CycleCameraModeDownJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeDownJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA6C0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::CycleCameraModeJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA630 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::CycleCameraModeUpJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleCameraModeUpJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA700 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::CycleWeaponLeftJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleWeaponLeftJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA560 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::CycleWeaponRightJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::CycleWeaponRightJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA530 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::DuckJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::DuckJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA430 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::ExitVehicleJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ExitVehicleJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA870 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::ForceCameraBehindPlayer</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ForceCameraBehindPlayer), this);</p>
<p>0AA8: call_method_return 0x4A9F00 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAccelerate</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAccelerate), this);</p>
<p>0AA8: call_method_return 0x4AA760 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetAnalogueLeftRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAnalogueLeftRight), this);</p>
<p>0AA8: call_method_return 0x4AADC0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetAnaloguePadDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadDown), this);</p>
<p>0AA8: call_method_return 0x4AA260 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAnaloguePadLeft</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadLeft), this);</p>
<p>0AA8: call_method_return 0x4AA200 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAnaloguePadLeftJustUp</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadLeftJustUp), this);</p>
<p>0AA8: call_method_return 0x4AA0D0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAnaloguePadRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadRight), this);</p>
<p>0AA8: call_method_return 0x4AA1A0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAnaloguePadRightJustUp</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadRightJustUp), this);</p>
<p>0AA8: call_method_return 0x4AA000 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAnaloguePadUp</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetAnaloguePadUp), this);</p>
<p>0AA8: call_method_return 0x4AA2B0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetAnalogueUpDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetAnalogueUpDown), this);</p>
<p>0AA8: call_method_return 0x4AACC0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetBrake</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetBrake), this);</p>
<p>0AA8: call_method_return 0x4AA960 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetCarGunFired</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetCarGunFired), this);</p>
<p>0AA8: call_method_return 0x4AAA60 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetCarGunLeftRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetCarGunLeftRight), this);</p>
<p>0AA8: call_method_return 0x4AAEB0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetCarGunUpDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetCarGunUpDown), this);</p>
<p>0AA8: call_method_return 0x4AAF00 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetExitVehicle</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetExitVehicle), this);</p>
<p>0AA8: call_method_return 0x4AA8F0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetHandBrake</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetHandBrake), this);</p>
<p>0AA8: call_method_return 0x4AA9B0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetHorn</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetHorn), this);</p>
<p>0AA8: call_method_return 0x4AAB60 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetLookBehindForCar</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookBehindForCar), this);</p>
<p>0AA8: call_method_return 0x4AAC30 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetLookBehindForPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookBehindForPed), this);</p>
<p>0AA8: call_method_return 0x4AAC00 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetLookLeft</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookLeft), this);</p>
<p>0AA8: call_method_return 0x4AAC90 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetLookRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetLookRight), this);</p>
<p>0AA8: call_method_return 0x4AAC60 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetPedWalkLeftRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetPedWalkLeftRight), this);</p>
<p>0AA8: call_method_return 0x4AAE30 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetPedWalkUpDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetPedWalkUpDown), this);</p>
<p>0AA8: call_method_return 0x4AAD40 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetSprint</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetSprint), this);</p>
<p>0AA8: call_method_return 0x4AA390 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetSteeringLeftRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetSteeringLeftRight), this);</p>
<p>0AA8: call_method_return 0x4AAFD0 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetSteeringUpDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetSteeringUpDown), this);</p>
<p>0AA8: call_method_return 0x4AAF50 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::GetTarget</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::GetTarget), this);</p>
<p>0AA8: call_method_return 0x4AA4D0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::GetWeapon</h4>
<p>plugin::CallMethodAndReturnDynGlobal<short, CPad *>(gaddrof(CPad::GetWeapon), this);</p>
<p>0AA8: call_method_return 0x4AA830 struct [CPad] num_params 0 pop 0 func_ret [short]</p>
<h4>CPad::HornJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::HornJustDown), this);</p>
<p>0AA8: call_method_return 0x4AAAC0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::InputHowLongAgo</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::InputHowLongAgo), this);</p>
<p>0AA8: call_method_return 0x4ADBD0 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<h4>CPad::JumpJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::JumpJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA400 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::LookAroundLeftRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::LookAroundLeftRight), this);</p>
<p>0AA8: call_method_return 0x4A9A80 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<h4>CPad::LookAroundUpDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::LookAroundUpDown), this);</p>
<p>0AA8: call_method_return 0x4A98F0 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<h4>CPad::ResetAverageWeapon</h4>
<p>plugin::CallMethodDynGlobal<CPad *>(gaddrof(CPad::ResetAverageWeapon), this);</p>
<p>0AA6: call_method 0x4A98A0 struct [CPad] num_params 0 pop 0</p>
<p>define function CPad__ResetAverageWeapon&lt;thiscall, 0x4A98A0&gt;()</p>
<h4>CPad::SetDrunkInputDelay</h4>
<p>plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::SetDrunkInputDelay), this, bEnable);</p>
<p>0AA6: call_method 0x4AD340 struct [CPad] num_params 1 pop 0 [bEnable]</p>
<p>define function CPad__SetDrunkInputDelay&lt;thiscall, 0x4AD340&gt;(bEnable)</p>
<h4>CPad::ShiftTargetLeftJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ShiftTargetLeftJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA360 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::ShiftTargetRightJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::ShiftTargetRightJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA300 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::SniperModeLookLeftRight</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::SniperModeLookLeftRight), this);</p>
<p>0AA8: call_method_return 0x4A9D40 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<h4>CPad::SniperModeLookUpDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPad *>(gaddrof(CPad::SniperModeLookUpDown), this);</p>
<p>0AA8: call_method_return 0x4A9C40 struct [CPad] num_params 0 pop 0 func_ret [int]</p>
<h4>CPad::SniperZoomIn</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::SniperZoomIn), this);</p>
<p>0AA8: call_method_return 0x4A9E90 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::SniperZoomOut</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::SniperZoomOut), this);</p>
<p>0AA8: call_method_return 0x4A9E20 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::StartShake</h4>
<p>plugin::CallMethodDynGlobal<CPad *, short, unsigned char>(gaddrof(CPad::StartShake), this, duration, frequency);</p>
<p>0AA6: call_method 0x4AD2E0 struct [CPad] num_params 2 pop 0 [duration] [frequency]</p>
<p>define function CPad__StartShake&lt;thiscall, 0x4AD2E0&gt;(duration, frequency)</p>
<h4>CPad::StopShaking</h4>
<p>plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::StopShaking), this, a1);</p>
<p>0AA6: call_method 0x4AB070 struct [CPad] num_params 1 pop 0 [a1]</p>
<p>define function CPad__StopShaking&lt;thiscall, 0x4AB070&gt;(a1)</p>
<h4>CPad::TargetJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::TargetJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA460 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::Update</h4>
<p>plugin::CallMethodDynGlobal<CPad *, int>(gaddrof(CPad::Update), this, a2);</p>
<p>0AA6: call_method 0x4AB0C0 struct [CPad] num_params 1 pop 0 [a2]</p>
<p>define function CPad__Update&lt;thiscall, 0x4AB0C0&gt;(a2)</p>
<h4>CPad::WeaponJustDown</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPad *>(gaddrof(CPad::WeaponJustDown), this);</p>
<p>0AA8: call_method_return 0x4AA7B0 struct [CPad] num_params 0 pop 0 func_ret [bool]</p>
<h4>CPad::EditCodesForControls</h4>
<p>plugin::CallDynGlobal<int *, int>(gaddrof(CPad::EditCodesForControls), outKeyCode, a2);</p>
<h4>*CPad::GetPad</h4>
<p>plugin::CallAndReturnDynGlobal<CPad *, int>(gaddrof(CPad::GetPad), padNumber);</p>
<p>0AA7: call_function_return 0x4AB060 num_params 1 pop 1 [padNumber] func_ret [CPad *]</p>
<p>define function CPad__GetPad&lt;cdecl, 0x4AB060&gt;(padNumber): int</p><h3 id="plugin_vcgame_vccparticlecpp">plugin_vc\game_vc\CParticle.cpp</h3><h4>CParticle::AddJetExplosion</h4>
<p>plugin::CallDynGlobal<CVector const &, float, float>(gaddrof(CParticle::AddJetExplosion), posn, power, size);</p>
<h4>*CParticle::AddParticle</h4>
<p>plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, RwRGBA const *, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle <em>(</em>)(tParticleType, CVector const &amp;, CVector const &amp;, CEntity *, float, RwRGBA const *, int, int, int, int)), particleType, posn, direction, entity, size, color, rotationSpeed, rotation, startFrame, lifeSpan);</p>
<p>0AA7: call_function_return 0x5648F0 num_params 10 pop 10 [particleType] [posn] [direction] [entity] [size] [color] [rotationSpeed] [rotation] [startFrame] [lifeSpan] func_ret [CParticle *]</p>
<p>define function CParticle__AddParticle&lt;cdecl, 0x5648F0&gt;(particleType, posn, direction, entity, size, color, rotationSpeed, rotation, startFrame, lifeSpan): int</p>
<h4>*CParticle::AddParticle</h4>
<p>plugin::CallAndReturnDynGlobal<CParticle *, tParticleType, CVector const &, CVector const &, CEntity *, float, int, int, int, int>(gaddrof_o(CParticle::AddParticle, CParticle <em>(</em>)(tParticleType, CVector const &amp;, CVector const &amp;, CEntity *, float, int, int, int, int)), particleType, posn, direction, entity, size, rotationSpeed, rotation, startFrame, lifeSpan);</p>
<p>0AA7: call_function_return 0x5648F0 num_params 9 pop 9 [particleType] [posn] [direction] [entity] [size] [rotationSpeed] [rotation] [startFrame] [lifeSpan] func_ret [CParticle *]</p>
<p>define function CParticle__AddParticle&lt;cdecl, 0x5648F0&gt;(particleType, posn, direction, entity, size, rotationSpeed, rotation, startFrame, lifeSpan): int</p>
<h4>CParticle::AddParticlesAlongLine</h4>
<p>plugin::CallDynGlobal<tParticleType, CVector const *, CVector const *, CVector const &, float, CEntity *, float, int, int, int, int>(gaddrof(CParticle::AddParticlesAlongLine), particleType, lineStart, lineEnd, direction, step, entity, size, rotationSpeed, rotation, startFrame, lifeSpan);</p>
<h4>CParticle::HandleShootableBirdsStuff</h4>
<p>plugin::CallDynGlobal<CEntity *, CVector const &>(gaddrof(CParticle::HandleShootableBirdsStuff), entity, posn);</p>
<h4>CParticle::RemovePSystem</h4>
<p>plugin::CallDynGlobal<tParticleType>(gaddrof(CParticle::RemovePSystem), particleType);</p>
<h4>CParticle::RemoveParticle</h4>
<p>plugin::CallDynGlobal<CParticle *, CParticle *, tParticleSystemData *>(gaddrof(CParticle::RemoveParticle), particle, previousParticle, particleSystsem);</p><h3 id="plugin_vcgame_vccparticlesystemmgrcpp">plugin_vc\game_vc\cParticleSystemMgr.cpp</h3><h4>cParticleSystemMgr::Initialise</h4>
<p>plugin::CallMethodDynGlobal<cParticleSystemMgr *>(gaddrof(cParticleSystemMgr::Initialise), this);</p>
<p>0AA6: call_method 0x565F60 struct [cParticleSystemMgr] num_params 0 pop 0</p>
<p>define function cParticleSystemMgr__Initialise&lt;thiscall, 0x565F60&gt;()</p>
<h4>cParticleSystemMgr::LoadParticleData</h4>
<p>plugin::CallMethodDynGlobal<cParticleSystemMgr *>(gaddrof(cParticleSystemMgr::LoadParticleData), this);</p>
<p>0AA6: call_method 0x565B00 struct [cParticleSystemMgr] num_params 0 pop 0</p>
<p>define function cParticleSystemMgr__LoadParticleData&lt;thiscall, 0x565B00&gt;()</p><h3 id="plugin_vcgame_vccpathfindcpp">plugin_vc\game_vc\CPathFind.cpp</h3><h4>CPathFind::GeneratePedCreationCoors</h4>
<p>plugin::CallMethodAndReturn<bool, 0x437B10, CPathFind <em>, float, float, float, float, float, float, CVector</em>, int<em>, int</em>, float<em>, CMatrix</em>>(this, arg1, arg2, arg3, arg4, arg5, arg6, ar7, arg8, arg9, arg10, arg11);</p>
<p>0AA8: call_method_return 0x437B10 struct [CPathFind] num_params 11 pop 0 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [ar7] [arg8] [arg9] [arg10] [arg11] func_ret [bool]</p>
<p>define function CPathFind__GeneratePedCreationCoors&lt;thiscall, 0x437B10&gt;(arg1, arg2, arg3, arg4, arg5, arg6, ar7, arg8, arg9, arg10, arg11): int</p>
<h4>CPathFind::GenerateCarCreationCoors</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4382B0, CPathFind <em>, float, float, float, float, float, float, bool, CVector</em>, int<em>, int</em>, float*, bool>(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);</p>
<p>0AA8: call_method_return 0x4382B0 struct [CPathFind] num_params 12 pop 0 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12] func_ret [bool]</p>
<p>define function CPathFind__GenerateCarCreationCoors&lt;thiscall, 0x4382B0&gt;(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12): int</p>
<h4>CPathFind::FindNodeClosestToCoors</h4>
<p>plugin::CallMethodAndReturn<int, 0x437150, CPathFind *, CVector, unsigned char, float, bool, bool, bool, bool>(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7);</p>
<p>0AA8: call_method_return 0x437150 struct [CPathFind] num_params 7 pop 0 [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] func_ret [int]</p>
<p>define function CPathFind__FindNodeClosestToCoors&lt;thiscall, 0x437150&gt;(arg1, arg2, arg3, arg4, arg5, arg6, arg7): int</p><h3 id="plugin_vcgame_vccpedcpp">plugin_vc\game_vc\CPed.cpp</h3><h4>CPed::SetMoveAnim</h4>
<p>plugin::CallVirtualMethod<18, CPed *>(this);</p>
<h4>CPed::AddInCarAnims</h4>
<p>plugin::CallMethodAndReturn<int, 0x512520, CPed <em>, CVehicle</em>, bool>(this, vehicle, arg1);</p>
<p>0AA8: call_method_return 0x512520 struct [CPed] num_params 2 pop 0 [vehicle] [arg1] func_ret [int]</p>
<p>define function CPed__AddInCarAnims&lt;thiscall, 0x512520&gt;(vehicle, arg1): int</p>
<h4>CPed::AddWeaponModel</h4>
<p>plugin::CallMethod<0x4FFE40, CPed *, int>(this, modelIndex);</p>
<p>0AA6: call_method 0x4FFE40 struct [CPed] num_params 1 pop 0 [modelIndex]</p>
<p>define function CPed__AddWeaponModel&lt;thiscall, 0x4FFE40&gt;(modelIndex)</p>
<h4>CPed::AimGun</h4>
<p>plugin::CallMethodAndReturn<char, 0x50B2C0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x50B2C0 struct [CPed] num_params 0 pop 0 func_ret [char]</p>
<p>define function CPed__AimGun&lt;thiscall, 0x50B2C0&gt;(): int</p>
<h4>CPed::AnswerMobile</h4>
<p>plugin::CallMethod<0x4F5710, CPed *>(this);</p>
<p>0AA6: call_method 0x4F5710 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__AnswerMobile&lt;thiscall, 0x4F5710&gt;()</p>
<h4>CPed::AttachPedToEntity</h4>
<p>plugin::CallMethodAndReturn<CEntity*, 0x4EF490, CPed *, CEntity*, float, float, float, unsigned short, float, eWeaponType>(this, entity, offsetX, offsetY, offsetZ, position, angle, weaponType);</p>
<p>0AA8: call_method_return 0x4EF490 struct [CPed] num_params 7 pop 0 [entity] [offsetX] [offsetY] [offsetZ] [position] [angle] [weaponType] func_ret [CEntity*]</p>
<p>define function CPed__AttachPedToEntity&lt;thiscall, 0x4EF490&gt;(entity, offsetX, offsetY, offsetZ, position, angle, weaponType): int</p>
<h4>CPed::Attack</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x52B070, CPed *>(this);</p>
<p>0AA8: call_method_return 0x52B070 struct [CPed] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CPed__Attack&lt;thiscall, 0x52B070&gt;(): int</p>
<h4>CPed::Avoid</h4>
<p>plugin::CallMethod<0x4FA2E0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FA2E0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Avoid&lt;thiscall, 0x4FA2E0&gt;()</p>
<h4>CPed::BeingDraggedFromCar</h4>
<p>plugin::CallMethodAndReturn<int, 0x518250, CPed *>(this);</p>
<p>0AA8: call_method_return 0x518250 struct [CPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPed__BeingDraggedFromCar&lt;thiscall, 0x518250&gt;(): int</p>
<h4>CPed::BuildPedLists</h4>
<p>plugin::CallMethod<0x50D4B0, CPed *>(this);</p>
<p>0AA6: call_method 0x50D4B0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__BuildPedLists&lt;thiscall, 0x50D4B0&gt;()</p>
<h4>CPed::BuyIceCream</h4>
<p>plugin::CallMethod<0x4F10D0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F10D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__BuyIceCream&lt;thiscall, 0x4F10D0&gt;()</p>
<h4>CPed::CalculateNewOrientation</h4>
<p>plugin::CallMethod<0x509F80, CPed *>(this);</p>
<p>0AA6: call_method 0x509F80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CalculateNewOrientation&lt;thiscall, 0x509F80&gt;()</p>
<h4>CPed::CalculateNewVelocity</h4>
<p>plugin::CallMethod<0x50A640, CPed *>(this);</p>
<p>0AA6: call_method 0x50A640 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CalculateNewVelocity&lt;thiscall, 0x50A640&gt;()</p>
<h4>CPed::CanBeDamagedByThisGangMember</h4>
<p>plugin::CallMethodAndReturn<bool, 0x50F130, CPed <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x50F130 struct [CPed] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CPed__CanBeDamagedByThisGangMember&lt;thiscall, 0x50F130&gt;(ped): int</p>
<h4>CPed::CanBeDeleted</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4FFEF0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4FFEF0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CanBeDeleted&lt;thiscall, 0x4FFEF0&gt;(): int</p>
<h4>CPed::CanBeDeletedEvenInVehicle</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4FFEC0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4FFEC0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CanBeDeletedEvenInVehicle&lt;thiscall, 0x4FFEC0&gt;(): int</p>
<h4>CPed::CanPedDriveOff</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4EFC90, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4EFC90 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CanPedDriveOff&lt;thiscall, 0x4EFC90&gt;(): int</p>
<h4>CPed::CanPedJumpThis</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F0590, CPed <em>, CEntity</em>, CVector*>(this, entity, arg1);</p>
<p>0AA8: call_method_return 0x4F0590 struct [CPed] num_params 2 pop 0 [entity] [arg1] func_ret [bool]</p>
<p>define function CPed__CanPedJumpThis&lt;thiscall, 0x4F0590&gt;(entity, arg1): int</p>
<h4>CPed::CanSeeEntity</h4>
<p>plugin::CallMethodAndReturn<bool, 0x51C870, CPed <em>, CEntity</em>, float>(this, entity, limitAngle);</p>
<p>0AA8: call_method_return 0x51C870 struct [CPed] num_params 2 pop 0 [entity] [limitAngle] func_ret [bool]</p>
<p>define function CPed__CanSeeEntity&lt;thiscall, 0x51C870&gt;(entity, limitAngle): int</p>
<h4>CPed::CanSetPedState</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5018D0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x5018D0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CanSetPedState&lt;thiscall, 0x5018D0&gt;(): int</p>
<h4>CPed::CanStrafeOrMouseControl</h4>
<p>plugin::CallMethodAndReturn<bool, 0x501890, CPed *>(this);</p>
<p>0AA8: call_method_return 0x501890 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CanStrafeOrMouseControl&lt;thiscall, 0x501890&gt;(): int</p>
<h4>CPed::CanWeRunAndFireWithWeapon</h4>
<p>plugin::CallMethodAndReturn<bool, 0x50B220, CPed *>(this);</p>
<p>0AA8: call_method_return 0x50B220 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CanWeRunAndFireWithWeapon&lt;thiscall, 0x50B220&gt;(): int</p>
<h4>CPed::Chat</h4>
<p>plugin::CallMethodAndReturn<unsigned int, 0x4F6050, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F6050 struct [CPed] num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CPed__Chat&lt;thiscall, 0x4F6050&gt;(): int</p>
<h4>CPed::CheckForExplosions</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F4950, CPed *, CVector2D&>(this, arg0);</p>
<p>0AA8: call_method_return 0x4F4950 struct [CPed] num_params 1 pop 0 [arg0] func_ret [bool]</p>
<p>define function CPed__CheckForExplosions&lt;thiscall, 0x4F4950&gt;(arg0): int</p>
<h4>CPed::CheckForPointBlankPeds</h4>
<p>plugin::CallMethodAndReturn<char, 0x52C670, CPed <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x52C670 struct [CPed] num_params 1 pop 0 [ped] func_ret [char]</p>
<p>define function CPed__CheckForPointBlankPeds&lt;thiscall, 0x52C670&gt;(ped): int</p>
<h4>CPed::CheckIfInTheAir</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4FD680, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4FD680 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__CheckIfInTheAir&lt;thiscall, 0x4FD680&gt;(): int</p>
<h4>CPed::CheckThreatValidity</h4>
<p>plugin::CallMethodAndReturn<int, 0x50BD00, CPed *>(this);</p>
<p>0AA8: call_method_return 0x50BD00 struct [CPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPed__CheckThreatValidity&lt;thiscall, 0x50BD00&gt;(): int</p>
<h4>CPed::ChooseAttackAI</h4>
<p>plugin::CallMethodAndReturn<int, 0x529460, CPed *, unsigned char, bool>(this, arg0, arg1);</p>
<p>0AA8: call_method_return 0x529460 struct [CPed] num_params 2 pop 0 [arg0] [arg1] func_ret [int]</p>
<p>define function CPed__ChooseAttackAI&lt;thiscall, 0x529460&gt;(arg0, arg1): int</p>
<h4>CPed::ChooseAttackPlayer</h4>
<p>plugin::CallMethodAndReturn<int, 0x528AA0, CPed *, unsigned char, bool>(this, arg0, arg1);</p>
<p>0AA8: call_method_return 0x528AA0 struct [CPed] num_params 2 pop 0 [arg0] [arg1] func_ret [int]</p>
<p>define function CPed__ChooseAttackPlayer&lt;thiscall, 0x528AA0&gt;(arg0, arg1): int</p>
<h4>CPed::ClearAimFlag</h4>
<p>plugin::CallMethod<0x50B4A0, CPed *>(this);</p>
<p>0AA6: call_method 0x50B4A0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAimFlag&lt;thiscall, 0x50B4A0&gt;()</p>
<h4>CPed::ClearAll</h4>
<p>plugin::CallMethod<0x509DF0, CPed *>(this);</p>
<p>0AA6: call_method 0x509DF0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAll&lt;thiscall, 0x509DF0&gt;()</p>
<h4>CPed::ClearAnswerMobile</h4>
<p>plugin::CallMethod<0x4F58C0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F58C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAnswerMobile&lt;thiscall, 0x4F58C0&gt;()</p>
<h4>CPed::ClearAttack</h4>
<p>plugin::CallMethod<0x52D120, CPed *>(this);</p>
<p>0AA6: call_method 0x52D120 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAttack&lt;thiscall, 0x52D120&gt;()</p>
<h4>CPed::ClearAttackByRemovingAnim</h4>
<p>plugin::CallMethod<0x52CF70, CPed *>(this);</p>
<p>0AA6: call_method 0x52CF70 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearAttackByRemovingAnim&lt;thiscall, 0x52CF70&gt;()</p>
<h4>CPed::ClearChat</h4>
<p>plugin::CallMethod<0x4F5FA0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F5FA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearChat&lt;thiscall, 0x4F5FA0&gt;()</p>
<h4>CPed::ClearDuck</h4>
<p>plugin::CallMethod<0x512A20, CPed *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x512A20 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__ClearDuck&lt;thiscall, 0x512A20&gt;(arg0)</p>
<h4>CPed::ClearFollowPath</h4>
<p>plugin::CallMethod<0x4F7920, CPed *>(this);</p>
<p>0AA6: call_method 0x4F7920 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearFollowPath&lt;thiscall, 0x4F7920&gt;()</p>
<h4>CPed::ClearInvestigateEvent</h4>
<p>plugin::CallMethod<0x526BA0, CPed *>(this);</p>
<p>0AA6: call_method 0x526BA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearInvestigateEvent&lt;thiscall, 0x526BA0&gt;()</p>
<h4>CPed::ClearLeader</h4>
<p>plugin::CallMethod<0x521670, CPed *>(this);</p>
<p>0AA6: call_method 0x521670 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearLeader&lt;thiscall, 0x521670&gt;()</p>
<h4>CPed::ClearLookFlag</h4>
<p>plugin::CallMethod<0x50B9C0, CPed *>(this);</p>
<p>0AA6: call_method 0x50B9C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearLookFlag&lt;thiscall, 0x50B9C0&gt;()</p>
<h4>CPed::ClearObjective</h4>
<p>plugin::CallMethod<0x521720, CPed *>(this);</p>
<p>0AA6: call_method 0x521720 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearObjective&lt;thiscall, 0x521720&gt;()</p>
<h4>CPed::ClearPointGunAt</h4>
<p>plugin::CallMethod<0x52DBE0, CPed *>(this);</p>
<p>0AA6: call_method 0x52DBE0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearPointGunAt&lt;thiscall, 0x52DBE0&gt;()</p>
<h4>CPed::ClearSeek</h4>
<p>plugin::CallMethod<0x4FC450, CPed *>(this);</p>
<p>0AA6: call_method 0x4FC450 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearSeek&lt;thiscall, 0x4FC450&gt;()</p>
<h4>CPed::ClearWaitState</h4>
<p>plugin::CallMethod<0x4F3130, CPed *>(this);</p>
<p>0AA6: call_method 0x4F3130 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearWaitState&lt;thiscall, 0x4F3130&gt;()</p>
<h4>CPed::ClearWeapons</h4>
<p>plugin::CallMethod<0x4FF740, CPed *>(this);</p>
<p>0AA6: call_method 0x4FF740 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ClearWeapons&lt;thiscall, 0x4FF740&gt;()</p>
<h4>CPed::CollideWithPed</h4>
<p>plugin::CallMethod<0x524920, CPed <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x524920 struct [CPed] num_params 1 pop 0 [ped]</p>
<p>define function CPed__CollideWithPed&lt;thiscall, 0x524920&gt;(ped)</p>
<h4>CPed::CreateDeadPedMoney</h4>
<p>plugin::CallMethod<0x43E2C0, CPed *>(this);</p>
<p>0AA6: call_method 0x43E2C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CreateDeadPedMoney&lt;thiscall, 0x43E2C0&gt;()</p>
<h4>CPed::CreateDeadPedPickupCoors</h4>
<p>plugin::CallMethod<0x43DAC0, CPed <em>, float</em>, float<em>, float</em>>(this, pX, pY, pZ);</p>
<p>0AA6: call_method 0x43DAC0 struct [CPed] num_params 3 pop 0 [pX] [pY] [pZ]</p>
<p>define function CPed__CreateDeadPedPickupCoors&lt;thiscall, 0x43DAC0&gt;(pX, pY, pZ)</p>
<h4>CPed::CreateDeadPedWeaponPickups</h4>
<p>plugin::CallMethod<0x43DF30, CPed *>(this);</p>
<p>0AA6: call_method 0x43DF30 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__CreateDeadPedWeaponPickups&lt;thiscall, 0x43DF30&gt;()</p>
<h4>CPed::DeadPedMakesTyresBloody</h4>
<p>plugin::CallMethod<0x587700, CPed *>(this);</p>
<p>0AA6: call_method 0x587700 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__DeadPedMakesTyresBloody&lt;thiscall, 0x587700&gt;()</p>
<h4>CPed::DettachPedFromEntity</h4>
<p>plugin::CallMethod<0x4EF370, CPed *>(this);</p>
<p>0AA6: call_method 0x4EF370 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__DettachPedFromEntity&lt;thiscall, 0x4EF370&gt;()</p>
<h4>CPed::Dress</h4>
<p>plugin::CallMethod<0x4EEFD0, CPed *>(this);</p>
<p>0AA6: call_method 0x4EEFD0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Dress&lt;thiscall, 0x4EEFD0&gt;()</p>
<h4>CPed::DriveVehicle</h4>
<p>plugin::CallMethod<0x522AA0, CPed *>(this);</p>
<p>0AA6: call_method 0x522AA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__DriveVehicle&lt;thiscall, 0x522AA0&gt;()</p>
<h4>CPed::Duck</h4>
<p>plugin::CallMethod<0x512A90, CPed *>(this);</p>
<p>0AA6: call_method 0x512A90 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Duck&lt;thiscall, 0x512A90&gt;()</p>
<h4>CPed::DuckAndCover</h4>
<p>plugin::CallMethod<0x513340, CPed *>(this);</p>
<p>0AA6: call_method 0x513340 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__DuckAndCover&lt;thiscall, 0x513340&gt;()</p>
<h4>CPed::EndFight</h4>
<p>plugin::CallMethod<0x5289A0, CPed *, unsigned char>(this, arg0);</p>
<p>0AA6: call_method 0x5289A0 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__EndFight&lt;thiscall, 0x5289A0&gt;(arg0)</p>
<h4>CPed::EnterCar</h4>
<p>plugin::CallMethod<0x517BA0, CPed *>(this);</p>
<p>0AA6: call_method 0x517BA0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__EnterCar&lt;thiscall, 0x517BA0&gt;()</p>
<h4>CPed::ExitCar</h4>
<p>plugin::CallMethod<0x516960, CPed *>(this);</p>
<p>0AA6: call_method 0x516960 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ExitCar&lt;thiscall, 0x516960&gt;()</p>
<h4>CPed::FacePhone</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F5CA0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F5CA0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__FacePhone&lt;thiscall, 0x4F5CA0&gt;(): int</p>
<h4>CPed::Fall</h4>
<p>plugin::CallMethod<0x4FD740, CPed *>(this);</p>
<p>0AA6: call_method 0x4FD740 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Fall&lt;thiscall, 0x4FD740&gt;()</p>
<h4>CPed::Fight</h4>
<p>plugin::CallMethod<0x529A00, CPed *>(this);</p>
<p>0AA6: call_method 0x529A00 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Fight&lt;thiscall, 0x529A00&gt;()</p>
<h4>CPed::FightHitPed</h4>
<p>plugin::CallMethod<0x527800, CPed <em>, CPed</em>, CVector&, CVector&, short>(this, ped, arg1, arg2, arg3);</p>
<p>0AA6: call_method 0x527800 struct [CPed] num_params 4 pop 0 [ped] [arg1] [arg2] [arg3]</p>
<p>define function CPed__FightHitPed&lt;thiscall, 0x527800&gt;(ped, arg1, arg2, arg3)</p>
<h4>CPed::FightStrike</h4>
<p>plugin::CallMethod<0x5282E0, CPed *, CVector&, bool>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x5282E0 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__FightStrike&lt;thiscall, 0x5282E0&gt;(arg0, arg1)</p>
<h4>CPed::FindBestCoordsFromNodes</h4>
<p>plugin::CallMethodAndReturn<bool, 0x513DF0, CPed <em>, CVector, CVector</em>>(this, arg0, arg1);</p>
<p>0AA8: call_method_return 0x513DF0 struct [CPed] num_params 2 pop 0 [arg0] [arg1] func_ret [bool]</p>
<p>define function CPed__FindBestCoordsFromNodes&lt;thiscall, 0x513DF0&gt;(arg0, arg1): int</p>
<h4>CPed::Flee</h4>
<p>plugin::CallMethod<0x4FB130, CPed *>(this);</p>
<p>0AA6: call_method 0x4FB130 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Flee&lt;thiscall, 0x4FB130&gt;()</p>
<h4>CPed::FollowPath</h4>
<p>plugin::CallMethodAndReturn<short, 0x4F76C0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F76C0 struct [CPed] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPed__FollowPath&lt;thiscall, 0x4F76C0&gt;(): int</p>
<h4>CPed::GetFormationPosition</h4>
<p>plugin::CallMethodAndReturn<int, 0x519E30, CPed *>(this);</p>
<p>0AA8: call_method_return 0x519E30 struct [CPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPed__GetFormationPosition&lt;thiscall, 0x519E30&gt;(): int</p>
<h4>CPed::GetLocalDirection</h4>
<p>plugin::CallMethodAndReturn<int, 0x5035F0, CPed *, CVector2D const&>(this, arg0);</p>
<p>0AA8: call_method_return 0x5035F0 struct [CPed] num_params 1 pop 0 [arg0] func_ret [int]</p>
<p>define function CPed__GetLocalDirection&lt;thiscall, 0x5035F0&gt;(arg0): int</p>
<h4>CPed::GetLocalPositionToOpenCarDoor</h4>
<p>plugin::CallAndReturn<int, 0x512D10, CVehicle*, unsigned int, float>(vehicle, arg1, arg2);</p>
<p>0AA7: call_function_return 0x512D10 num_params 3 pop 3 [vehicle] [arg1] [arg2] func_ret [int]</p>
<p>define function CPed__GetLocalPositionToOpenCarDoor&lt;cdecl, 0x512D10&gt;(vehicle, arg1, arg2): int</p>
<h4>CPed::GetNearestDoor</h4>
<p>plugin::CallMethodAndReturn<int, 0x5160E0, CPed <em>, CVehicle</em>, CVector&>(this, vehicle, position);</p>
<p>0AA8: call_method_return 0x5160E0 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [int]</p>
<p>define function CPed__GetNearestDoor&lt;thiscall, 0x5160E0&gt;(vehicle, position): int</p>
<h4>CPed::GetNearestPassengerDoor</h4>
<p>plugin::CallMethodAndReturn<bool, 0x515CE0, CPed <em>, CVehicle</em>, CVector&>(this, vehicle, position);</p>
<p>0AA8: call_method_return 0x515CE0 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [bool]</p>
<p>define function CPed__GetNearestPassengerDoor&lt;thiscall, 0x515CE0&gt;(vehicle, position): int</p>
<h4>CPed::GetNearestTrainDoor</h4>
<p>plugin::CallMethodAndReturn<bool, 0x514A70, CPed <em>, CVehicle</em>, CVector&>(this, vehicle, position);</p>
<p>0AA8: call_method_return 0x514A70 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [bool]</p>
<p>define function CPed__GetNearestTrainDoor&lt;thiscall, 0x514A70&gt;(vehicle, position): int</p>
<h4>CPed::GetNearestTrainPedPosition</h4>
<p>plugin::CallMethodAndReturn<bool, 0x514650, CPed <em>, CVehicle</em>, CVector&>(this, vehicle, position);</p>
<p>0AA8: call_method_return 0x514650 struct [CPed] num_params 2 pop 0 [vehicle] [position] func_ret [bool]</p>
<p>define function CPed__GetNearestTrainPedPosition&lt;thiscall, 0x514650&gt;(vehicle, position): int</p>
<h4>CPed::GetNextPointOnRoute</h4>
<p>plugin::CallMethodAndReturn<int, 0x51C9E0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x51C9E0 struct [CPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPed__GetNextPointOnRoute&lt;thiscall, 0x51C9E0&gt;(): int</p>
<h4>CPed::GetPositionToOpenCarDoor</h4>
<p>plugin::CallAndReturn<int, 0x5164D0, CVehicle*, unsigned int>(vehicle, arg1);</p>
<p>0AA7: call_function_return 0x5164D0 num_params 2 pop 2 [vehicle] [arg1] func_ret [int]</p>
<p>define function CPed__GetPositionToOpenCarDoor&lt;cdecl, 0x5164D0&gt;(vehicle, arg1): int</p>
<h4>CPed::GetPositionToOpenCarDoor</h4>
<p>plugin::CallAndReturn<int, 0x513080, CVehicle*, unsigned int, float>(vehicle, arg1, arg2);</p>
<p>0AA7: call_function_return 0x513080 num_params 3 pop 3 [vehicle] [arg1] [arg2] func_ret [int]</p>
<p>define function CPed__GetPositionToOpenCarDoor&lt;cdecl, 0x513080&gt;(vehicle, arg1, arg2): int</p>
<h4>CPed::GetWeaponSlot</h4>
<p>plugin::CallMethodAndReturn<int, 0x4FFA10, CPed *, eWeaponType>(this, weaponType);</p>
<p>0AA8: call_method_return 0x4FFA10 struct [CPed] num_params 1 pop 0 [weaponType] func_ret [int]</p>
<p>define function CPed__GetWeaponSlot&lt;thiscall, 0x4FFA10&gt;(weaponType): int</p>
<h4>CPed::GiveDelayedWeapon</h4>
<p>plugin::CallMethod<0x4FFC30, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);</p>
<p>0AA6: call_method 0x4FFC30 struct [CPed] num_params 2 pop 0 [weaponType] [ammo]</p>
<p>define function CPed__GiveDelayedWeapon&lt;thiscall, 0x4FFC30&gt;(weaponType, ammo)</p>
<h4>CPed::GiveWeapon</h4>
<p>plugin::CallMethod<0x4FFA30, CPed *, eWeaponType, unsigned int, bool>(this, weaponType, ammo, likeUnused);</p>
<p>0AA6: call_method 0x4FFA30 struct [CPed] num_params 3 pop 0 [weaponType] [ammo] [likeUnused]</p>
<p>define function CPed__GiveWeapon&lt;thiscall, 0x4FFA30&gt;(weaponType, ammo, likeUnused)</p>
<h4>CPed::GrantAmmo</h4>
<p>plugin::CallMethod<0x4FF840, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);</p>
<p>0AA6: call_method 0x4FF840 struct [CPed] num_params 2 pop 0 [weaponType] [ammo]</p>
<p>define function CPed__GrantAmmo&lt;thiscall, 0x4FF840&gt;(weaponType, ammo)</p>
<h4>CPed::HasAttractor</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4EF8A0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4EF8A0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__HasAttractor&lt;thiscall, 0x4EF8A0&gt;(): int</p>
<h4>CPed::HaveReachedNextPointOnRoute</h4>
<p>plugin::CallMethodAndReturn<bool, 0x51C970, CPed *, float>(this, arg0);</p>
<p>0AA8: call_method_return 0x51C970 struct [CPed] num_params 1 pop 0 [arg0] func_ret [bool]</p>
<p>define function CPed__HaveReachedNextPointOnRoute&lt;thiscall, 0x51C970&gt;(arg0): int</p>
<h4>CPed::Idle</h4>
<p>plugin::CallMethod<0x4FDEB0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FDEB0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Idle&lt;thiscall, 0x4FDEB0&gt;()</p>
<h4>CPed::InTheAir</h4>
<p>plugin::CallMethod<0x4FD4D0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FD4D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__InTheAir&lt;thiscall, 0x4FD4D0&gt;()</p>
<h4>CPed::InflictDamage</h4>
<p>plugin::CallMethod<0x525B20, CPed <em>, void</em>, eWeaponType, float, ePedPieceTypes, unsigned char>(this, arg0, weaponType, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x525B20 struct [CPed] num_params 5 pop 0 [arg0] [weaponType] [arg2] [arg3] [arg4]</p>
<p>define function CPed__InflictDamage&lt;thiscall, 0x525B20&gt;(arg0, weaponType, arg2, arg3, arg4)</p>
<h4>CPed::InformMyGangOfAttack</h4>
<p>plugin::CallMethod<0x512950, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x512950 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__InformMyGangOfAttack&lt;thiscall, 0x512950&gt;(entity)</p>
<h4>CPed::Initialise</h4>
<p>plugin::Call<0x50D9F0>();</p>
<p>0AA5: call_function 0x50D9F0 num_params 0 pop 0</p>
<p>define function CPed__Initialise&lt;cdecl, 0x50D9F0&gt;()</p>
<h4>CPed::InvestigateEvent</h4>
<p>plugin::CallMethod<0x526C60, CPed *>(this);</p>
<p>0AA6: call_method 0x526C60 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__InvestigateEvent&lt;thiscall, 0x526C60&gt;()</p>
<h4>CPed::IsGangMember</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F4910, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F4910 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsGangMember&lt;thiscall, 0x4F4910&gt;(): int</p>
<h4>CPed::IsPedDoingDriveByShooting</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5C84D0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x5C84D0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsPedDoingDriveByShooting&lt;thiscall, 0x5C84D0&gt;(): int</p>
<h4>CPed::IsPedHeadAbovePos</h4>
<p>plugin::CallMethodAndReturn<bool, 0x525960, CPed *, float>(this, zPos);</p>
<p>0AA8: call_method_return 0x525960 struct [CPed] num_params 1 pop 0 [zPos] func_ret [bool]</p>
<p>define function CPed__IsPedHeadAbovePos&lt;thiscall, 0x525960&gt;(zPos): int</p>
<h4>CPed::IsPedInControl</h4>
<p>plugin::CallMethodAndReturn<bool, 0x501950, CPed *>(this);</p>
<p>0AA8: call_method_return 0x501950 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsPedInControl&lt;thiscall, 0x501950&gt;(): int</p>
<h4>CPed::IsPedShootable</h4>
<p>plugin::CallMethodAndReturn<bool, 0x501930, CPed *>(this);</p>
<p>0AA8: call_method_return 0x501930 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsPedShootable&lt;thiscall, 0x501930&gt;(): int</p>
<h4>CPed::IsPlayer</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F4930, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F4930 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsPlayer&lt;thiscall, 0x4F4930&gt;(): int</p>
<h4>CPed::IsPointerValid</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F4860, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F4860 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsPointerValid&lt;thiscall, 0x4F4860&gt;(): int</p>
<h4>CPed::IsRoomToBeCarJacked</h4>
<p>plugin::CallMethodAndReturn<bool, 0x512670, CPed *>(this);</p>
<p>0AA8: call_method_return 0x512670 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__IsRoomToBeCarJacked&lt;thiscall, 0x512670&gt;(): int</p>
<h4>CPed::KillCharOnFootArmed</h4>
<p>plugin::CallMethod<0x50FFC0, CPed *, CVector&, CVector&, CVector&>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x50FFC0 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CPed__KillCharOnFootArmed&lt;thiscall, 0x50FFC0&gt;(arg0, arg1, arg2)</p>
<h4>CPed::KillCharOnFootMelee</h4>
<p>plugin::CallMethod<0x50F170, CPed *, CVector&, CVector&, CVector&>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x50F170 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CPed__KillCharOnFootMelee&lt;thiscall, 0x50F170&gt;(arg0, arg1, arg2)</p>
<h4>CPed::KillPedWithCar</h4>
<p>plugin::CallMethod<0x523CD0, CPed <em>, CVehicle</em>, float>(this, vehicle, arg1);</p>
<p>0AA6: call_method 0x523CD0 struct [CPed] num_params 2 pop 0 [vehicle] [arg1]</p>
<p>define function CPed__KillPedWithCar&lt;thiscall, 0x523CD0&gt;(vehicle, arg1)</p>
<h4>CPed::LineUpPedWithCar</h4>
<p>plugin::CallMethod<0x518AD0, CPed *, unsigned int>(this, arg0);</p>
<p>0AA6: call_method 0x518AD0 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__LineUpPedWithCar&lt;thiscall, 0x518AD0&gt;(arg0)</p>
<h4>CPed::LoadFightData</h4>
<p>plugin::Call<0x527570>();</p>
<p>0AA5: call_function 0x527570 num_params 0 pop 0</p>
<p>define function CPed__LoadFightData&lt;cdecl, 0x527570&gt;()</p>
<h4>CPed::LookForInterestingNodes</h4>
<p>plugin::CallMethod<0x4F3540, CPed *>(this);</p>
<p>0AA6: call_method 0x4F3540 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__LookForInterestingNodes&lt;thiscall, 0x4F3540&gt;()</p>
<h4>CPed::LookForSexyCars</h4>
<p>plugin::CallMethod<0x4F3EB0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F3EB0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__LookForSexyCars&lt;thiscall, 0x4F3EB0&gt;()</p>
<h4>CPed::LookForSexyPeds</h4>
<p>plugin::CallMethod<0x4F4090, CPed *>(this);</p>
<p>0AA6: call_method 0x4F4090 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__LookForSexyPeds&lt;thiscall, 0x4F4090&gt;()</p>
<h4>CPed::MakePhonecall</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F5B40, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F5B40 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__MakePhonecall&lt;thiscall, 0x4F5B40&gt;(): int</p>
<h4>CPed::MakeTyresMuddySectorList</h4>
<p>plugin::CallMethod<0x5870D0, CPed *, CPtrList&>(this, ptrList);</p>
<p>0AA6: call_method 0x5870D0 struct [CPed] num_params 1 pop 0 [ptrList]</p>
<p>define function CPed__MakeTyresMuddySectorList&lt;thiscall, 0x5870D0&gt;(ptrList)</p>
<h4>CPed::MoveHeadToLook</h4>
<p>plugin::CallMethod<0x50B700, CPed *>(this);</p>
<p>0AA6: call_method 0x50B700 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__MoveHeadToLook&lt;thiscall, 0x50B700&gt;()</p>
<h4>CPed::Mug</h4>
<p>plugin::CallMethod<0x4FCD30, CPed *>(this);</p>
<p>0AA6: call_method 0x4FCD30 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Mug&lt;thiscall, 0x4FCD30&gt;()</p>
<h4>CPed::OurPedCanSeeThisOne</h4>
<p>plugin::CallMethodAndReturn<bool, 0x50D360, CPed <em>, CEntity</em>, bool>(this, entity, arg1);</p>
<p>0AA8: call_method_return 0x50D360 struct [CPed] num_params 2 pop 0 [entity] [arg1] func_ret [bool]</p>
<p>define function CPed__OurPedCanSeeThisOne&lt;thiscall, 0x50D360&gt;(entity, arg1): int</p>
<h4>CPed::Pause</h4>
<p>plugin::CallMethod<0x4FDE80, CPed *>(this);</p>
<p>0AA6: call_method 0x4FDE80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Pause&lt;thiscall, 0x4FDE80&gt;()</p>
<h4>CPed::PedShuffle</h4>
<p>plugin::CallMethod<0x51A2F0, CPed *>(this);</p>
<p>0AA6: call_method 0x51A2F0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__PedShuffle&lt;thiscall, 0x51A2F0&gt;()</p>
<h4>CPed::PlacePedOnDryLand</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5256A0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x5256A0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__PlacePedOnDryLand&lt;thiscall, 0x5256A0&gt;(): int</p>
<h4>CPed::PlayFootSteps</h4>
<p>plugin::CallMethod<0x503680, CPed *>(this);</p>
<p>0AA6: call_method 0x503680 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__PlayFootSteps&lt;thiscall, 0x503680&gt;()</p>
<h4>CPed::PlayHitSound</h4>
<p>plugin::CallMethod<0x528850, CPed <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x528850 struct [CPed] num_params 1 pop 0 [ped]</p>
<p>define function CPed__PlayHitSound&lt;thiscall, 0x528850&gt;(ped)</p>
<h4>CPed::PointGunAt</h4>
<p>plugin::CallMethodAndReturn<short, 0x52DCD0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x52DCD0 struct [CPed] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPed__PointGunAt&lt;thiscall, 0x52DCD0&gt;(): int</p>
<h4>CPed::PositionAnyPedOutOfCollision</h4>
<p>plugin::CallMethodAndReturn<bool, 0x511840, CPed *>(this);</p>
<p>0AA8: call_method_return 0x511840 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__PositionAnyPedOutOfCollision&lt;thiscall, 0x511840&gt;(): int</p>
<h4>CPed::PositionAttachedPed</h4>
<p>plugin::CallMethod<0x4EF0A0, CPed *>(this);</p>
<p>0AA6: call_method 0x4EF0A0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__PositionAttachedPed&lt;thiscall, 0x4EF0A0&gt;()</p>
<h4>CPed::PositionPedOutOfCollision</h4>
<p>plugin::CallMethodAndReturn<bool, 0x511B10, CPed *>(this);</p>
<p>0AA8: call_method_return 0x511B10 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__PositionPedOutOfCollision&lt;thiscall, 0x511B10&gt;(): int</p>
<h4>CPed::PossiblyFindBetterPosToSeekCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F0810, CPed <em>, CVector</em>, CVehicle*>(this, arg0, vehicle);</p>
<p>0AA8: call_method_return 0x4F0810 struct [CPed] num_params 2 pop 0 [arg0] [vehicle] func_ret [bool]</p>
<p>define function CPed__PossiblyFindBetterPosToSeekCar&lt;thiscall, 0x4F0810&gt;(arg0, vehicle): int</p>
<h4>CPed::ProcessBuoyancy</h4>
<p>plugin::CallMethod<0x509460, CPed *>(this);</p>
<p>0AA6: call_method 0x509460 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ProcessBuoyancy&lt;thiscall, 0x509460&gt;()</p>
<h4>CPed::ProcessObjective</h4>
<p>plugin::CallMethod<0x51CA70, CPed *>(this);</p>
<p>0AA6: call_method 0x51CA70 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ProcessObjective&lt;thiscall, 0x51CA70&gt;()</p>
<h4>CPed::QuitEnteringCar</h4>
<p>plugin::CallMethod<0x5179D0, CPed *>(this);</p>
<p>0AA6: call_method 0x5179D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__QuitEnteringCar&lt;thiscall, 0x5179D0&gt;()</p>
<h4>CPed::ReactToAttack</h4>
<p>plugin::CallMethod<0x51BDA0, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x51BDA0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__ReactToAttack&lt;thiscall, 0x51BDA0&gt;(entity)</p>
<h4>CPed::ReactToPointGun</h4>
<p>plugin::CallMethod<0x51C1E0, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x51C1E0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__ReactToPointGun&lt;thiscall, 0x51C1E0&gt;(entity)</p>
<h4>CPed::RegisterThreatWithGangPeds</h4>
<p>plugin::CallMethod<0x514360, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x514360 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__RegisterThreatWithGangPeds&lt;thiscall, 0x514360&gt;(entity)</p>
<h4>CPed::RemoveDrivebyAnims</h4>
<p>plugin::CallMethod<0x512480, CPed *>(this);</p>
<p>0AA6: call_method 0x512480 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RemoveDrivebyAnims&lt;thiscall, 0x512480&gt;()</p>
<h4>CPed::RemoveInCarAnims</h4>
<p>plugin::CallMethod<0x512440, CPed *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x512440 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__RemoveInCarAnims&lt;thiscall, 0x512440&gt;(arg0)</p>
<h4>CPed::RemoveWeaponAnims</h4>
<p>plugin::CallMethod<0x5229B0, CPed *, int, float>(this, likeUnused, blendDelta);</p>
<p>0AA6: call_method 0x5229B0 struct [CPed] num_params 2 pop 0 [likeUnused] [blendDelta]</p>
<p>define function CPed__RemoveWeaponAnims&lt;thiscall, 0x5229B0&gt;(likeUnused, blendDelta)</p>
<h4>CPed::RemoveWeaponModel</h4>
<p>plugin::CallMethod<0x4FFD80, CPed *, int>(this, modelIndex);</p>
<p>0AA6: call_method 0x4FFD80 struct [CPed] num_params 1 pop 0 [modelIndex]</p>
<p>define function CPed__RemoveWeaponModel&lt;thiscall, 0x4FFD80&gt;(modelIndex)</p>
<h4>CPed::RemoveWeaponWhenEnteringVehicle</h4>
<p>plugin::CallMethod<0x4FF6A0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FF6A0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RemoveWeaponWhenEnteringVehicle&lt;thiscall, 0x4FF6A0&gt;()</p>
<h4>CPed::ReplaceWeaponWhenExitingVehicle</h4>
<p>plugin::CallMethod<0x4FF5A0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FF5A0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ReplaceWeaponWhenExitingVehicle&lt;thiscall, 0x4FF5A0&gt;()</p>
<h4>CPed::RequestDelayedWeapon</h4>
<p>plugin::CallMethod<0x4FFCE0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FFCE0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RequestDelayedWeapon&lt;thiscall, 0x4FFCE0&gt;()</p>
<h4>CPed::RestartNonPartialAnims</h4>
<p>plugin::CallMethod<0x50CCF0, CPed *>(this);</p>
<p>0AA6: call_method 0x50CCF0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestartNonPartialAnims&lt;thiscall, 0x50CCF0&gt;()</p>
<h4>CPed::RestoreGunPosition</h4>
<p>plugin::CallMethod<0x50B250, CPed *>(this);</p>
<p>0AA6: call_method 0x50B250 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestoreGunPosition&lt;thiscall, 0x50B250&gt;()</p>
<h4>CPed::RestoreHeadPosition</h4>
<p>plugin::CallMethod<0x50B650, CPed *>(this);</p>
<p>0AA6: call_method 0x50B650 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestoreHeadPosition&lt;thiscall, 0x50B650&gt;()</p>
<h4>CPed::RestoreHeadingRate</h4>
<p>plugin::CallMethod<0x4F17D0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F17D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestoreHeadingRate&lt;thiscall, 0x4F17D0&gt;()</p>
<h4>CPed::RestorePreviousObjective</h4>
<p>plugin::CallMethod<0x520FE0, CPed *>(this);</p>
<p>0AA6: call_method 0x520FE0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestorePreviousObjective&lt;thiscall, 0x520FE0&gt;()</p>
<h4>CPed::RestorePreviousState</h4>
<p>plugin::CallMethod<0x50C600, CPed *>(this);</p>
<p>0AA6: call_method 0x50C600 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__RestorePreviousState&lt;thiscall, 0x50C600&gt;()</p>
<h4>CPed::Say</h4>
<p>plugin::CallMethod<0x5226B0, CPed *, unsigned short>(this, arg0);</p>
<p>0AA6: call_method 0x5226B0 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__Say&lt;thiscall, 0x5226B0&gt;(arg0)</p>
<h4>CPed::Say</h4>
<p>plugin::CallMethod<0x4EEFA0, CPed *, unsigned short, int>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4EEFA0 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__Say&lt;thiscall, 0x4EEFA0&gt;(arg0, arg1)</p>
<h4>CPed::ScanForDelayedResponseThreats</h4>
<p>plugin::CallMethod<0x50BD80, CPed *>(this);</p>
<p>0AA6: call_method 0x50BD80 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ScanForDelayedResponseThreats&lt;thiscall, 0x50BD80&gt;()</p>
<h4>CPed::ScanForInterestingStuff</h4>
<p>plugin::CallMethod<0x50AD50, CPed *>(this);</p>
<p>0AA6: call_method 0x50AD50 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ScanForInterestingStuff&lt;thiscall, 0x50AD50&gt;()</p>
<h4>CPed::ScanForThreats</h4>
<p>plugin::CallMethod<0x50BE00, CPed *>(this);</p>
<p>0AA6: call_method 0x50BE00 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ScanForThreats&lt;thiscall, 0x50BE00&gt;()</p>
<h4>CPed::Seek</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4FBD00, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4FBD00 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__Seek&lt;thiscall, 0x4FBD00&gt;(): int</p>
<h4>CPed::SeekBoatPosition</h4>
<p>plugin::CallMethod<0x512740, CPed *>(this);</p>
<p>0AA6: call_method 0x512740 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SeekBoatPosition&lt;thiscall, 0x512740&gt;()</p>
<h4>CPed::SeekCar</h4>
<p>plugin::CallMethod<0x4F4AD0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F4AD0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SeekCar&lt;thiscall, 0x4F4AD0&gt;()</p>
<h4>CPed::SeekFollowingPath</h4>
<p>plugin::CallMethod<0x4FA1C0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FA1C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SeekFollowingPath&lt;thiscall, 0x4FA1C0&gt;()</p>
<h4>CPed::SelectGunIfArmed</h4>
<p>plugin::CallMethodAndReturn<bool, 0x51C800, CPed *>(this);</p>
<p>0AA8: call_method_return 0x51C800 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__SelectGunIfArmed&lt;thiscall, 0x51C800&gt;(): int</p>
<h4>CPed::ServiceTalking</h4>
<p>plugin::CallMethod<0x522850, CPed *>(this);</p>
<p>0AA6: call_method 0x522850 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__ServiceTalking&lt;thiscall, 0x522850&gt;()</p>
<h4>CPed::ServiceTalkingWhenDead</h4>
<p>plugin::CallMethodAndReturn<bool, 0x522990, CPed *>(this);</p>
<p>0AA8: call_method_return 0x522990 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__ServiceTalkingWhenDead&lt;thiscall, 0x522990&gt;(): int</p>
<h4>CPed::SetAimFlag</h4>
<p>plugin::CallMethod<0x50B510, CPed <em>, CEntity</em>>(this, aimingTo);</p>
<p>0AA6: call_method 0x50B510 struct [CPed] num_params 1 pop 0 [aimingTo]</p>
<p>define function CPed__SetAimFlag&lt;thiscall, 0x50B510&gt;(aimingTo)</p>
<h4>CPed::SetAimFlag</h4>
<p>plugin::CallMethod<0x50B5B0, CPed *, float>(this, heading);</p>
<p>0AA6: call_method 0x50B5B0 struct [CPed] num_params 1 pop 0 [heading]</p>
<p>define function CPed__SetAimFlag&lt;thiscall, 0x50B5B0&gt;(heading)</p>
<h4>CPed::SetAmmo</h4>
<p>plugin::CallMethod<0x4FF780, CPed *, eWeaponType, unsigned int>(this, weaponType, ammo);</p>
<p>0AA6: call_method 0x4FF780 struct [CPed] num_params 2 pop 0 [weaponType] [ammo]</p>
<p>define function CPed__SetAmmo&lt;thiscall, 0x4FF780&gt;(weaponType, ammo)</p>
<h4>CPed::SetAnimOffsetForEnterOrExitVehicle</h4>
<p>plugin::Call<0x5155E0>();</p>
<p>0AA5: call_function 0x5155E0 num_params 0 pop 0</p>
<p>define function CPed__SetAnimOffsetForEnterOrExitVehicle&lt;cdecl, 0x5155E0&gt;()</p>
<h4>CPed::SetAnswerMobile</h4>
<p>plugin::CallMethod<0x4F59C0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F59C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetAnswerMobile&lt;thiscall, 0x4F59C0&gt;()</p>
<h4>CPed::SetAttack</h4>
<p>plugin::CallMethod<0x52D1C0, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x52D1C0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetAttack&lt;thiscall, 0x52D1C0&gt;(entity)</p>
<h4>CPed::SetAttackTimer</h4>
<p>plugin::CallMethod<0x4FCAB0, CPed *, unsigned int>(this, time);</p>
<p>0AA6: call_method 0x4FCAB0 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetAttackTimer&lt;thiscall, 0x4FCAB0&gt;(time)</p>
<h4>CPed::SetBeingDraggedFromCar</h4>
<p>plugin::CallMethod<0x518430, CPed <em>, CVehicle</em>, unsigned int, bool>(this, vehicle, arg1, arg2);</p>
<p>0AA6: call_method 0x518430 struct [CPed] num_params 3 pop 0 [vehicle] [arg1] [arg2]</p>
<p>define function CPed__SetBeingDraggedFromCar&lt;thiscall, 0x518430&gt;(vehicle, arg1, arg2)</p>
<h4>CPed::SetCarJack</h4>
<p>plugin::CallMethod<0x5188A0, CPed <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA6: call_method 0x5188A0 struct [CPed] num_params 1 pop 0 [vehicle]</p>
<p>define function CPed__SetCarJack&lt;thiscall, 0x5188A0&gt;(vehicle)</p>
<h4>CPed::SetCarJack_AllClear</h4>
<p>plugin::CallMethod<0x518690, CPed <em>, CVehicle</em>, unsigned int, unsigned int>(this, vehicle, arg1, arg2);</p>
<p>0AA6: call_method 0x518690 struct [CPed] num_params 3 pop 0 [vehicle] [arg1] [arg2]</p>
<p>define function CPed__SetCarJack_AllClear&lt;thiscall, 0x518690&gt;(vehicle, arg1, arg2)</p>
<h4>CPed::SetChat</h4>
<p>plugin::CallMethod<0x4F6220, CPed <em>, CEntity</em>, unsigned int>(this, entity, arg1);</p>
<p>0AA6: call_method 0x4F6220 struct [CPed] num_params 2 pop 0 [entity] [arg1]</p>
<p>define function CPed__SetChat&lt;thiscall, 0x4F6220&gt;(entity, arg1)</p>
<h4>CPed::SetCurrentWeapon</h4>
<p>plugin::CallMethod<0x4FF8E0, CPed *, eWeaponType>(this, weaponType);</p>
<p>0AA6: call_method 0x4FF8E0 struct [CPed] num_params 1 pop 0 [weaponType]</p>
<p>define function CPed__SetCurrentWeapon&lt;thiscall, 0x4FF8E0&gt;(weaponType)</p>
<h4>CPed::SetCurrentWeapon</h4>
<p>plugin::CallMethod<0x4FF900, CPed *, int>(this, slot);</p>
<p>0AA6: call_method 0x4FF900 struct [CPed] num_params 1 pop 0 [slot]</p>
<p>define function CPed__SetCurrentWeapon&lt;thiscall, 0x4FF900&gt;(slot)</p>
<h4>CPed::SetDead</h4>
<p>plugin::CallMethod<0x4F6430, CPed *>(this);</p>
<p>0AA6: call_method 0x4F6430 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetDead&lt;thiscall, 0x4F6430&gt;()</p>
<h4>CPed::SetDie</h4>
<p>plugin::CallMethod<0x4F65C0, CPed *, AnimationId, float, float>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x4F65C0 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CPed__SetDie&lt;thiscall, 0x4F65C0&gt;(arg0, arg1, arg2)</p>
<h4>CPed::SetDirectionToWalkAroundObject</h4>
<p>plugin::CallMethod<0x5019A0, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x5019A0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetDirectionToWalkAroundObject&lt;thiscall, 0x5019A0&gt;(entity)</p>
<h4>CPed::SetDirectionToWalkAroundVehicle</h4>
<p>plugin::CallMethod<0x5035B0, CPed <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA6: call_method 0x5035B0 struct [CPed] num_params 1 pop 0 [vehicle]</p>
<p>define function CPed__SetDirectionToWalkAroundVehicle&lt;thiscall, 0x5035B0&gt;(vehicle)</p>
<h4>CPed::SetDuck</h4>
<p>plugin::CallMethod<0x512C10, CPed *, unsigned int, bool>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x512C10 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetDuck&lt;thiscall, 0x512C10&gt;(arg0, arg1)</p>
<h4>CPed::SetEnterCar</h4>
<p>plugin::CallMethod<0x518080, CPed <em>, CVehicle</em>, unsigned int>(this, vehicle, arg1);</p>
<p>0AA6: call_method 0x518080 struct [CPed] num_params 2 pop 0 [vehicle] [arg1]</p>
<p>define function CPed__SetEnterCar&lt;thiscall, 0x518080&gt;(vehicle, arg1)</p>
<h4>CPed::SetEnterCar_AllClear</h4>
<p>plugin::CallMethod<0x517DE0, CPed <em>, CVehicle</em>, unsigned int, unsigned int>(this, vehicle, arg1, arg2);</p>
<p>0AA6: call_method 0x517DE0 struct [CPed] num_params 3 pop 0 [vehicle] [arg1] [arg2]</p>
<p>define function CPed__SetEnterCar_AllClear&lt;thiscall, 0x517DE0&gt;(vehicle, arg1, arg2)</p>
<h4>CPed::SetEvasiveDive</h4>
<p>plugin::CallMethod<0x4F6A20, CPed <em>, CPhysical</em>, unsigned char>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4F6A20 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetEvasiveDive&lt;thiscall, 0x4F6A20&gt;(arg0, arg1)</p>
<h4>CPed::SetEvasiveStep</h4>
<p>plugin::CallMethod<0x4F7170, CPed <em>, CPhysical</em>, unsigned char>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4F7170 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetEvasiveStep&lt;thiscall, 0x4F7170&gt;(arg0, arg1)</p>
<h4>CPed::SetExitBoat</h4>
<p>plugin::CallMethod<0x517670, CPed <em>, CVehicle</em>>(this, boat);</p>
<p>0AA6: call_method 0x517670 struct [CPed] num_params 1 pop 0 [boat]</p>
<p>define function CPed__SetExitBoat&lt;thiscall, 0x517670&gt;(boat)</p>
<h4>CPed::SetExitCar</h4>
<p>plugin::CallMethod<0x516C60, CPed <em>, CVehicle</em>, unsigned int>(this, vehicle, arg1);</p>
<p>0AA6: call_method 0x516C60 struct [CPed] num_params 2 pop 0 [vehicle] [arg1]</p>
<p>define function CPed__SetExitCar&lt;thiscall, 0x516C60&gt;(vehicle, arg1)</p>
<h4>CPed::SetFall</h4>
<p>plugin::CallMethod<0x4FD9F0, CPed *, int, AnimationId, unsigned char>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x4FD9F0 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CPed__SetFall&lt;thiscall, 0x4FD9F0&gt;(arg0, arg1, arg2)</p>
<h4>CPed::SetFlee</h4>
<p>plugin::CallMethod<0x4FB820, CPed <em>, CEntity</em>, int>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4FB820 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetFlee&lt;thiscall, 0x4FB820&gt;(arg0, arg1)</p>
<h4>CPed::SetFlee</h4>
<p>plugin::CallMethod<0x4FBA90, CPed *, CVector2D const&, int>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4FBA90 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetFlee&lt;thiscall, 0x4FBA90&gt;(arg0, arg1)</p>
<h4>CPed::SetFollowPath</h4>
<p>plugin::CallMethod<0x4F9F60, CPed <em>, CVector const&, float, eMoveState, CEntity</em>, CEntity*, int>(this, arg0, arg1, arg2, arg3, arg4, arg5);</p>
<p>0AA6: call_method 0x4F9F60 struct [CPed] num_params 6 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5]</p>
<p>define function CPed__SetFollowPath&lt;thiscall, 0x4F9F60&gt;(arg0, arg1, arg2, arg3, arg4, arg5)</p>
<h4>CPed::SetFollowPathDynamic</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F7990, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F7990 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__SetFollowPathDynamic&lt;thiscall, 0x4F7990&gt;(): int</p>
<h4>CPed::SetFollowPathStatic</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4F99F0, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4F99F0 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__SetFollowPathStatic&lt;thiscall, 0x4F99F0&gt;(): int</p>
<h4>CPed::SetFormation</h4>
<p>plugin::CallMethod<0x51A020, CPed *, eFormation>(this, arg0);</p>
<p>0AA6: call_method 0x51A020 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__SetFormation&lt;thiscall, 0x51A020&gt;(arg0)</p>
<h4>CPed::SetGetUp</h4>
<p>plugin::CallMethod<0x4FCF60, CPed *>(this);</p>
<p>0AA6: call_method 0x4FCF60 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetGetUp&lt;thiscall, 0x4FCF60&gt;()</p>
<h4>CPed::SetIdle</h4>
<p>plugin::CallMethod<0x4FDFD0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FDFD0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetIdle&lt;thiscall, 0x4FDFD0&gt;()</p>
<h4>CPed::SetInTheAir</h4>
<p>plugin::CallMethod<0x4FD610, CPed *>(this);</p>
<p>0AA6: call_method 0x4FD610 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetInTheAir&lt;thiscall, 0x4FD610&gt;()</p>
<h4>CPed::SetInvestigateEvent</h4>
<p>plugin::CallMethod<0x527490, CPed *, eEventType, CVector2D, float, unsigned short, float>(this, eventType, arg1, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x527490 struct [CPed] num_params 5 pop 0 [eventType] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CPed__SetInvestigateEvent&lt;thiscall, 0x527490&gt;(eventType, arg1, arg2, arg3, arg4)</p>
<h4>CPed::SetJump</h4>
<p>plugin::CallMethod<0x4F03C0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F03C0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetJump&lt;thiscall, 0x4F03C0&gt;()</p>
<h4>CPed::SetLanding</h4>
<p>plugin::CallMethod<0x4FD3A0, CPed *>(this);</p>
<p>0AA6: call_method 0x4FD3A0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetLanding&lt;thiscall, 0x4FD3A0&gt;()</p>
<h4>CPed::SetLeader</h4>
<p>plugin::CallMethod<0x4F07D0, CPed <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x4F07D0 struct [CPed] num_params 1 pop 0 [ped]</p>
<p>define function CPed__SetLeader&lt;thiscall, 0x4F07D0&gt;(ped)</p>
<h4>CPed::SetLook</h4>
<p>plugin::CallMethod<0x4FCB10, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x4FCB10 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetLook&lt;thiscall, 0x4FCB10&gt;(entity)</p>
<h4>CPed::SetLookFlag</h4>
<p>plugin::CallMethod<0x50BB70, CPed <em>, CEntity</em>, bool, bool>(this, lookingTo, likeUnused, arg2);</p>
<p>0AA6: call_method 0x50BB70 struct [CPed] num_params 3 pop 0 [lookingTo] [likeUnused] [arg2]</p>
<p>define function CPed__SetLookFlag&lt;thiscall, 0x50BB70&gt;(lookingTo, likeUnused, arg2)</p>
<h4>CPed::SetLookFlag</h4>
<p>plugin::CallMethod<0x50BC40, CPed *, float, bool, bool>(this, lookHeading, likeUnused, arg2);</p>
<p>0AA6: call_method 0x50BC40 struct [CPed] num_params 3 pop 0 [lookHeading] [likeUnused] [arg2]</p>
<p>define function CPed__SetLookFlag&lt;thiscall, 0x50BC40&gt;(lookHeading, likeUnused, arg2)</p>
<h4>CPed::SetLookTimer</h4>
<p>plugin::CallMethod<0x4FCAF0, CPed *, unsigned int>(this, time);</p>
<p>0AA6: call_method 0x4FCAF0 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetLookTimer&lt;thiscall, 0x4FCAF0&gt;(time)</p>
<h4>CPed::SetMoveState</h4>
<p>plugin::CallMethod<0x50D110, CPed *, eMoveState>(this, moveState);</p>
<p>0AA6: call_method 0x50D110 struct [CPed] num_params 1 pop 0 [moveState]</p>
<p>define function CPed__SetMoveState&lt;thiscall, 0x50D110&gt;(moveState)</p>
<h4>CPed::SetNewAttraction</h4>
<p>plugin::CallMethod<0x4EF7C0, CPed <em>, CPedAttractor</em>, CVector const&, float, float, int>(this, arg0, arg1, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x4EF7C0 struct [CPed] num_params 5 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CPed__SetNewAttraction&lt;thiscall, 0x4EF7C0&gt;(arg0, arg1, arg2, arg3, arg4)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethod<0x5224B0, CPed *, eObjective>(this, objective);</p>
<p>0AA6: call_method 0x5224B0 struct [CPed] num_params 1 pop 0 [objective]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x5224B0&gt;(objective)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethod<0x521840, CPed *, eObjective, CVector>(this, objective, arg1);</p>
<p>0AA6: call_method 0x521840 struct [CPed] num_params 2 pop 0 [objective] [arg1]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x521840&gt;(objective, arg1)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethod<0x5217E0, CPed *, eObjective, float, CVector const&>(this, objective, arg1, arg2);</p>
<p>0AA6: call_method 0x5217E0 struct [CPed] num_params 3 pop 0 [objective] [arg1] [arg2]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x5217E0&gt;(objective, arg1, arg2)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethod<0x521D10, CPed *, eObjective, short, short>(this, objective, arg1, arg2);</p>
<p>0AA6: call_method 0x521D10 struct [CPed] num_params 3 pop 0 [objective] [arg1] [arg2]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x521D10&gt;(objective, arg1, arg2)</p>
<h4>CPed::SetObjective</h4>
<p>plugin::CallMethod<0x521F10, CPed <em>, eObjective, void</em>>(this, objective, arg1);</p>
<p>0AA6: call_method 0x521F10 struct [CPed] num_params 2 pop 0 [objective] [arg1]</p>
<p>define function CPed__SetObjective&lt;thiscall, 0x521F10&gt;(objective, arg1)</p>
<h4>CPed::SetObjectiveTimer</h4>
<p>plugin::CallMethod<0x522660, CPed *, unsigned int>(this, time);</p>
<p>0AA6: call_method 0x522660 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetObjectiveTimer&lt;thiscall, 0x522660&gt;(time)</p>
<h4>CPed::SetPedPositionInCar</h4>
<p>plugin::CallMethod<0x4F42F0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F42F0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetPedPositionInCar&lt;thiscall, 0x4F42F0&gt;()</p>
<h4>CPed::SetPedStats</h4>
<p>plugin::CallMethod<0x50D8E0, CPed *, ePedStats>(this, statsType);</p>
<p>0AA6: call_method 0x50D8E0 struct [CPed] num_params 1 pop 0 [statsType]</p>
<p>define function CPed__SetPedStats&lt;thiscall, 0x50D8E0&gt;(statsType)</p>
<h4>CPed::SetPointGunAt</h4>
<p>plugin::CallMethod<0x52DDF0, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x52DDF0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__SetPointGunAt&lt;thiscall, 0x52DDF0&gt;(entity)</p>
<h4>CPed::SetRadioStation</h4>
<p>plugin::CallMethod<0x4EFBD0, CPed *>(this);</p>
<p>0AA6: call_method 0x4EFBD0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetRadioStation&lt;thiscall, 0x4EFBD0&gt;()</p>
<h4>CPed::SetSeek</h4>
<p>plugin::CallMethod<0x4FC570, CPed <em>, CEntity</em>, float>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4FC570 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetSeek&lt;thiscall, 0x4FC570&gt;(arg0, arg1)</p>
<h4>CPed::SetSeek</h4>
<p>plugin::CallMethod<0x4FC740, CPed *, CVector, float>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x4FC740 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SetSeek&lt;thiscall, 0x4FC740&gt;(arg0, arg1)</p>
<h4>CPed::SetSeekBoatPosition</h4>
<p>plugin::CallMethod<0x512850, CPed <em>, CVehicle</em>>(this, boat);</p>
<p>0AA6: call_method 0x512850 struct [CPed] num_params 1 pop 0 [boat]</p>
<p>define function CPed__SetSeekBoatPosition&lt;thiscall, 0x512850&gt;(boat)</p>
<h4>CPed::SetSeekCar</h4>
<p>plugin::CallMethod<0x4F54D0, CPed <em>, CVehicle</em>, unsigned int>(this, car, arg1);</p>
<p>0AA6: call_method 0x4F54D0 struct [CPed] num_params 2 pop 0 [car] [arg1]</p>
<p>define function CPed__SetSeekCar&lt;thiscall, 0x4F54D0&gt;(car, arg1)</p>
<h4>CPed::SetShootTimer</h4>
<p>plugin::CallMethod<0x4FCA90, CPed *, unsigned int>(this, time);</p>
<p>0AA6: call_method 0x4FCA90 struct [CPed] num_params 1 pop 0 [time]</p>
<p>define function CPed__SetShootTimer&lt;thiscall, 0x4FCA90&gt;(time)</p>
<h4>CPed::SetSolicit</h4>
<p>plugin::CallMethod<0x4F1400, CPed *, unsigned int>(this, arg0);</p>
<p>0AA6: call_method 0x4F1400 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__SetSolicit&lt;thiscall, 0x4F1400&gt;(arg0)</p>
<h4>CPed::SetStoredObjective</h4>
<p>plugin::CallMethod<0x522620, CPed *>(this);</p>
<p>0AA6: call_method 0x522620 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetStoredObjective&lt;thiscall, 0x522620&gt;()</p>
<h4>CPed::SetStoredState</h4>
<p>plugin::CallMethod<0x50CC40, CPed *>(this);</p>
<p>0AA6: call_method 0x50CC40 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__SetStoredState&lt;thiscall, 0x50CC40&gt;()</p>
<h4>CPed::SetWaitState</h4>
<p>plugin::CallMethod<0x4F28A0, CPed <em>, eWaitState, void</em>>(this, waitState, arg1);</p>
<p>0AA6: call_method 0x4F28A0 struct [CPed] num_params 2 pop 0 [waitState] [arg1]</p>
<p>define function CPed__SetWaitState&lt;thiscall, 0x4F28A0&gt;(waitState, arg1)</p>
<h4>CPed::SetWanderPath</h4>
<p>plugin::CallMethod<0x4FACC0, CPed *, signed>(this, arg0);</p>
<p>0AA6: call_method 0x4FACC0 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__SetWanderPath&lt;thiscall, 0x4FACC0&gt;(arg0)</p>
<h4>CPed::Solicit</h4>
<p>plugin::CallMethod<0x4F11D0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F11D0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Solicit&lt;thiscall, 0x4F11D0&gt;()</p>
<h4>CPed::SortPeds</h4>
<p>plugin::CallMethod<0x50D120, CPed <em>, CPed</em>*, int, int>(this, pedList, arg1, arg2);</p>
<p>0AA6: call_method 0x50D120 struct [CPed] num_params 3 pop 0 [pedList] [arg1] [arg2]</p>
<p>define function CPed__SortPeds&lt;thiscall, 0x50D120&gt;(pedList, arg1, arg2)</p>
<h4>CPed::SpawnFlyingComponent</h4>
<p>plugin::CallMethod<0x5259F0, CPed *, int, char>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x5259F0 struct [CPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPed__SpawnFlyingComponent&lt;thiscall, 0x5259F0&gt;(arg0, arg1)</p>
<h4>CPed::StartFightAttack</h4>
<p>plugin::CallMethod<0x52AD70, CPed *, unsigned char>(this, arg0);</p>
<p>0AA6: call_method 0x52AD70 struct [CPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPed__StartFightAttack&lt;thiscall, 0x52AD70&gt;(arg0)</p>
<h4>CPed::StartFightDefend</h4>
<p>plugin::CallMethod<0x52A340, CPed *, unsigned char, unsigned char, unsigned char>(this, arg0, arg1, arg2);</p>
<p>0AA6: call_method 0x52A340 struct [CPed] num_params 3 pop 0 [arg0] [arg1] [arg2]</p>
<p>define function CPed__StartFightDefend&lt;thiscall, 0x52A340&gt;(arg0, arg1, arg2)</p>
<h4>CPed::StopNonPartialAnims</h4>
<p>plugin::CallMethod<0x50CD20, CPed *>(this);</p>
<p>0AA6: call_method 0x50CD20 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__StopNonPartialAnims&lt;thiscall, 0x50CD20&gt;()</p>
<h4>CPed::TurnBody</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4FC970, CPed *>(this);</p>
<p>0AA8: call_method_return 0x4FC970 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__TurnBody&lt;thiscall, 0x4FC970&gt;(): int</p>
<h4>CPed::Undress</h4>
<p>plugin::CallMethod<0x4EF030, CPed <em>, char const</em>>(this, modelName);</p>
<p>0AA6: call_method 0x4EF030 struct [CPed] num_params 1 pop 0 [modelName]</p>
<p>define function CPed__Undress&lt;thiscall, 0x4EF030&gt;(modelName)</p>
<h4>CPed::UpdateFromLeader</h4>
<p>plugin::CallMethod<0x521070, CPed *>(this);</p>
<p>0AA6: call_method 0x521070 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__UpdateFromLeader&lt;thiscall, 0x521070&gt;()</p>
<h4>CPed::UpdatePosition</h4>
<p>plugin::CallMethod<0x50A040, CPed *>(this);</p>
<p>0AA6: call_method 0x50A040 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__UpdatePosition&lt;thiscall, 0x50A040&gt;()</p>
<h4>CPed::UseGroundColModel</h4>
<p>plugin::CallMethodAndReturn<bool, 0x501900, CPed *>(this);</p>
<p>0AA8: call_method_return 0x501900 struct [CPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPed__UseGroundColModel&lt;thiscall, 0x501900&gt;(): int</p>
<h4>CPed::Wait</h4>
<p>plugin::CallMethod<0x4F18A0, CPed *>(this);</p>
<p>0AA6: call_method 0x4F18A0 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__Wait&lt;thiscall, 0x4F18A0&gt;()</p>
<h4>CPed::WanderPath</h4>
<p>plugin::CallMethod<0x4FA680, CPed *>(this);</p>
<p>0AA6: call_method 0x4FA680 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__WanderPath&lt;thiscall, 0x4FA680&gt;()</p>
<h4>CPed::WarpPedIntoCar</h4>
<p>plugin::CallMethod<0x4EF8B0, CPed <em>, CVehicle</em>>(this, vehicle);</p>
<p>0AA6: call_method 0x4EF8B0 struct [CPed] num_params 1 pop 0 [vehicle]</p>
<p>define function CPed__WarpPedIntoCar&lt;thiscall, 0x4EF8B0&gt;(vehicle)</p>
<h4>CPed::WarpPedToNearEntityOffScreen</h4>
<p>plugin::CallMethod<0x5110C0, CPed <em>, CEntity</em>>(this, entity);</p>
<p>0AA6: call_method 0x5110C0 struct [CPed] num_params 1 pop 0 [entity]</p>
<p>define function CPed__WarpPedToNearEntityOffScreen&lt;thiscall, 0x5110C0&gt;(entity)</p>
<h4>CPed::WarpPedToNearLeaderOffScreen</h4>
<p>plugin::CallMethod<0x511480, CPed *>(this);</p>
<p>0AA6: call_method 0x511480 struct [CPed] num_params 0 pop 0</p>
<p>define function CPed__WarpPedToNearLeaderOffScreen&lt;thiscall, 0x511480&gt;()</p>
<h4>CPed::WillChat</h4>
<p>plugin::CallMethodAndReturn<bool, 0x50AC70, CPed <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x50AC70 struct [CPed] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CPed__WillChat&lt;thiscall, 0x50AC70&gt;(ped): int</p>
<h4>CPed::WorkOutHeadingForMovingFirstPerson</h4>
<p>plugin::CallMethodAndReturn<float, 0x50A530, CPed *, float>(this, heading);</p>
<p>0AA8: call_method_return 0x50A530 struct [CPed] num_params 1 pop 0 [heading] func_ret [float]</p>
<p>define function CPed__WorkOutHeadingForMovingFirstPerson&lt;thiscall, 0x50A530&gt;(heading): float</p>
<h4>CPed::operator delete</h4>
<p>plugin::Call<0x50DA20, void*>(data);</p>
<p>0AA5: call_function 0x50DA20 num_params 1 pop 1 [data]</p>
<p>define function CPed__operator delete&lt;cdecl, 0x50DA20&gt;(data)</p>
<h4>CPed::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x50DA60, unsigned int>(size);</p>
<p>0AA7: call_function_return 0x50DA60 num_params 1 pop 1 [size] func_ret [void*]</p>
<p>define function CPed__operator new&lt;cdecl, 0x50DA60&gt;(size): int</p>
<h4>CPed::operator new</h4>
<p>plugin::CallAndReturn<void*, 0x50DA40, unsigned int, int>(size, arg1);</p>
<p>0AA7: call_function_return 0x50DA40 num_params 2 pop 2 [size] [arg1] func_ret [void*]</p>
<p>define function CPed__operator new&lt;cdecl, 0x50DA40&gt;(size, arg1): int</p>
<h4>plugin::dummy, plugin</h4>
<p>plugin::CallMethod<0x50DC20, CPed *, ePedType>(this, pedType);</p>
<p>0AA6: call_method 0x50DC20 struct [plugin] num_params 1 pop 0 [pedType]</p>
<p>define function plugin__dummy, plugin&lt;thiscall, 0x50DC20&gt;(pedType)</p><h3 id="plugin_vcgame_vccpedatmattractorcpp">plugin_vc\game_vc\CPedAtmAttractor.cpp</h3><h4>CPedAtmAttractor::GetType</h4>
<p>plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedAtmAttractor *>(this);</p>
<h4>CPedAtmAttractor::UpdatePedStateOnDeparture</h4>
<p>plugin::CallVirtualMethod<3, CPedAtmAttractor *, CPed *>(this, ped);</p><h3 id="plugin_vcgame_vccpedattractorcpp">plugin_vc\game_vc\CPedAttractor.cpp</h3><h4>CPedAttractor::GetHeadOfQueueWaitTime</h4>
<p>plugin::CallVirtualMethodAndReturn<float, 0, CPedAttractor *>(this);</p>
<h4>CPedAttractor::IsAtHeadOfQueue</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 4, CPedAttractor *, CPed *>(this, ped);</p>
<h4>CPedAttractor::ComputeAttractPos</h4>
<p>plugin::CallVirtualMethod<5, CPedAttractor *, int, CVector &>(this, qid, pos);</p>
<h4>CPedAttractor::ComputeAttractHeading</h4>
<p>plugin::CallVirtualMethod<6, CPedAttractor *, int, float &>(this, qid, heading);</p>
<h4>CPedAttractor::BroadcastDeparture</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 7, CPedAttractor *, CPed *>(this, ped);</p>
<h4>CPedAttractor::BroadcastArrival</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::BroadcastArrival), this, ped);</p>
<p>0AA8: call_method_return 0x62C940 struct [CPedAttractor] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CPedAttractor::DeRegisterPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::DeRegisterPed), this, ped);</p>
<p>0AA8: call_method_return 0x62CA40 struct [CPedAttractor] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>CPedAttractor::GetNoOfRegisteredPeds</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPedAttractor *>(gaddrof(CPedAttractor::GetNoOfRegisteredPeds), this);</p>
<p>0AA8: call_method_return 0x62DD60 struct [CPedAttractor] num_params 0 pop 0 func_ret [int]</p>
<h4>CPedAttractor::RegisterPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractor *, CPed *>(gaddrof(CPedAttractor::RegisterPed), this, ped);</p>
<p>0AA8: call_method_return 0x62CB80 struct [CPedAttractor] num_params 1 pop 0 [ped] func_ret [bool]</p><h3 id="plugin_vcgame_vccpedattractormanagercpp">plugin_vc\game_vc\CPedAttractorManager.cpp</h3><h4>CPedAttractorManager::BroadcastArrival</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPedAttractorManager *, CPed *, CPedAttractor <em>>(gaddrof_o(CPedAttractorManager::BroadcastArrival, bool (CPedAttractorManager::</em>)(CPed *, CPedAttractor *)), this, ped, attr);</p>
<p>0AA8: call_method_return 0x62B370 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]</p>
<h4>CPedAttractorManager::BroadcastDeparture</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPedAttractorManager *, CPed *, CPedAttractor <em>>(gaddrof_o(CPedAttractorManager::BroadcastDeparture, bool (CPedAttractorManager::</em>)(CPed *, CPedAttractor *)), this, ped, attr);</p>
<p>0AA8: call_method_return 0x62B240 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]</p>
<h4>CPedAttractorManager::DeRegisterPed</h4>
<p>plugin::CallMethodAndReturnDynGlobal&lt;bool, CPedAttractorManager *, CPed *, CPedAttractor <em>>(gaddrof_o(CPedAttractorManager::DeRegisterPed, bool (CPedAttractorManager::</em>)(CPed *, CPedAttractor *)), this, ped, attr);</p>
<p>0AA8: call_method_return 0x62B3D0 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]</p>
<h4>CPedAttractorManager::HasEmptySlot</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, C2dEffect const *>(gaddrof(CPedAttractorManager::HasEmptySlot), this, effect);</p>
<p>0AA8: call_method_return 0x62B0F0 struct [CPedAttractorManager] num_params 1 pop 0 [effect] func_ret [bool]</p>
<h4>CPedAttractorManager::IsAtHeadOfQueue</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof(CPedAttractorManager::IsAtHeadOfQueue), this, ped, attr);</p>
<p>0AA8: call_method_return 0x62BEF0 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]</p>
<h4>CPedAttractorManager::IsInQueue</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *, CPedAttractor *>(gaddrof(CPedAttractorManager::IsInQueue), this, ped, attr);</p>
<p>0AA8: call_method_return 0x62BC40 struct [CPedAttractorManager] num_params 2 pop 0 [ped] [attr] func_ret [bool]</p>
<h4>CPedAttractorManager::IsPedRegisteredWithEffect</h4>
<p>plugin::CallMethodAndReturnDynGlobal<bool, CPedAttractorManager *, CPed *>(gaddrof(CPedAttractorManager::IsPedRegisteredWithEffect), this, ped);</p>
<p>0AA8: call_method_return 0x62B860 struct [CPedAttractorManager] num_params 1 pop 0 [ped] func_ret [bool]</p>
<h4>*CPedAttractorManager::RegisterPedWithAttractor</h4>
<p>plugin::CallMethodAndReturnDynGlobal<CPedAttractor *, CPedAttractorManager *, CPed *, C2dEffect *, CMatrix const &>(gaddrof(CPedAttractorManager::RegisterPedWithAttractor), this, ped, effect, matrix);</p>
<p>0AA8: call_method_return 0x62C3A0 struct [*CPedAttractorManager] num_params 3 pop 0 [ped] [effect] [matrix] func_ret [CPedAttractor *]</p>
<h4>CPedAttractorManager::BroadcastArrival</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &amp;&gt;(gaddrof_o(CPedAttractorManager::BroadcastArrival, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &amp;)), ped, attr, vecAttractors);</p>
<p>0AA7: call_function_return 0x62B370 num_params 3 pop 3 [ped] [attr] [vecAttractors] func_ret [bool]</p>
<p>define function CPedAttractorManager__BroadcastArrival&lt;cdecl, 0x62B370&gt;(ped, attr, vecAttractors): int</p>
<h4>CPedAttractorManager::BroadcastDeparture</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &amp;&gt;(gaddrof_o(CPedAttractorManager::BroadcastDeparture, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &amp;)), ped, attr, vecAttractors);</p>
<p>0AA7: call_function_return 0x62B240 num_params 3 pop 3 [ped] [attr] [vecAttractors] func_ret [bool]</p>
<p>define function CPedAttractorManager__BroadcastDeparture&lt;cdecl, 0x62B240&gt;(ped, attr, vecAttractors): int</p>
<h4>CPedAttractorManager::ComputeEffectPos</h4>
<p>plugin::CallDynGlobal<C2dEffect const *, CMatrix const &, CVector &>(gaddrof(CPedAttractorManager::ComputeEffectPos), effect, matrix, pos);</p>
<h4>CPedAttractorManager::DeRegisterPed</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPed *, CPedAttractor *, std::vector<CPedAttractor *> &amp;&gt;(gaddrof_o(CPedAttractorManager::DeRegisterPed, bool (*)(CPed *, CPedAttractor *, std::vector<CPedAttractor *> &amp;)), ped, attr, vecAttractors);</p>
<p>0AA7: call_function_return 0x62B3D0 num_params 3 pop 3 [ped] [attr] [vecAttractors] func_ret [bool]</p>
<p>define function CPedAttractorManager__DeRegisterPed&lt;cdecl, 0x62B3D0&gt;(ped, attr, vecAttractors): int</p>
<h4>CPedAttractorManager::IsApproachable</h4>
<p>plugin::CallAndReturnDynGlobal<bool, C2dEffect *, CMatrix const &, int, CPed *>(gaddrof(CPedAttractorManager::IsApproachable), effect, matrix, unk, ped);</p>
<p>0AA7: call_function_return 0x62AE80 num_params 4 pop 4 [effect] [matrix] [unk] [ped] func_ret [bool]</p>
<p>define function CPedAttractorManager__IsApproachable&lt;cdecl, 0x62AE80&gt;(effect, matrix, unk, ped): int</p>
<h4>*CPedAttractorManager::RegisterPed</h4>
<p>plugin::CallAndReturnDynGlobal<CPedAttractor *, CPed *, C2dEffect *, CMatrix const &, std::vector<CPedAttractor *> &amp;&gt;(gaddrof(CPedAttractorManager::RegisterPed), ped, effect, matrix, vecAttractors);</p>
<p>0AA7: call_function_return 0x62B470 num_params 4 pop 4 [ped] [effect] [matrix] [vecAttractors] func_ret [CPedAttractor *]</p>
<p>define function CPedAttractorManager__RegisterPed&lt;cdecl, 0x62B470&gt;(ped, effect, matrix, vecAttractors): int</p>
<h4>*GetPedAttractorManager</h4>
<p>plugin::CallAndReturnDynGlobal<CPedAttractorManager *>(gaddrof(GetPedAttractorManager));</p>
<p>0AA7: call_function_return 0x62D030 num_params 0 pop 0 func_ret [CPedAttractorManager *]</p>
<p>define function GetPedAttractorManager&lt;cdecl, 0x62D030&gt;(): int</p><h3 id="plugin_vcgame_vccpedicecreamvanattractorcpp">plugin_vc\game_vc\CPedIceCreamVanAttractor.cpp</h3><h4>CPedIceCreamVanAttractor::GetType</h4>
<p>plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedIceCreamVanAttractor *>(this);</p>
<h4>CPedIceCreamVanAttractor::UpdatePedStateOnDeparture</h4>
<p>plugin::CallVirtualMethod<3, CPedIceCreamVanAttractor *, CPed *>(this, ped);</p><h3 id="plugin_vcgame_vccpedikcpp">plugin_vc\game_vc\CPedIK.cpp</h3><h4>CPedIK::MoveLimb</h4>
<p>plugin::CallMethodAndReturn<MoveLimbResult, 0x52F6E0, CPedIK*, LimbOrientation&, float, float, LimbMovementInfo&>(this, limb, yaw, pitch, moveInfo);</p>
<p>0AA8: call_method_return 0x52F6E0 struct [CPedIK] num_params 4 pop 0 [limb] [yaw] [pitch] [moveInfo] func_ret [MoveLimbResult]</p>
<p>define function CPedIK__MoveLimb&lt;thiscall, 0x52F6E0&gt;(limb, yaw, pitch, moveInfo): int</p>
<h4>CPedIK::GetComponentPosition</h4>
<p>plugin::CallMethod<0x52F9B0, CPedIK*, RwV3d&, unsigned int>(this, returnedPos, boneIndex);</p>
<p>0AA6: call_method 0x52F9B0 struct [CPedIK] num_params 2 pop 0 [returnedPos] [boneIndex]</p>
<p>define function CPedIK__GetComponentPosition&lt;thiscall, 0x52F9B0&gt;(returnedPos, boneIndex)</p>
<h4>CPedIK::ExtractYawAndPitchWorld</h4>
<p>plugin::CallMethod<0x52F830, CPedIK<em>, RwMatrix</em>, float<em>, float</em>>(this, matrix, yaw, pitch);</p>
<p>0AA6: call_method 0x52F830 struct [CPedIK] num_params 3 pop 0 [matrix] [yaw] [pitch]</p>
<p>define function CPedIK__ExtractYawAndPitchWorld&lt;thiscall, 0x52F830&gt;(matrix, yaw, pitch)</p><h3 id="plugin_vcgame_vccpedmodelinfocpp">plugin_vc\game_vc\CPedModelInfo.cpp</h3><h4>CPedModelInfo::AnimatePedColModelSkinned</h4>
<p>plugin::CallMethod<0x566150, CPedModelInfo <em>, RpClump</em>>(this, clump);</p>
<p>0AA6: call_method 0x566150 struct [CPedModelInfo] num_params 1 pop 0 [clump]</p>
<p>define function CPedModelInfo__AnimatePedColModelSkinned&lt;thiscall, 0x566150&gt;(clump)</p>
<h4>CPedModelInfo::AnimatePedColModelSkinnedWorld</h4>
<p>plugin::CallMethod<0x566060, CPedModelInfo <em>, RpClump</em>>(this, clump);</p>
<p>0AA6: call_method 0x566060 struct [CPedModelInfo] num_params 1 pop 0 [clump]</p>
<p>define function CPedModelInfo__AnimatePedColModelSkinnedWorld&lt;thiscall, 0x566060&gt;(clump)</p>
<h4>CPedModelInfo::CreateHitColModelSkinned</h4>
<p>plugin::CallMethod<0x566300, CPedModelInfo <em>, RpClump</em>>(this, clump);</p>
<p>0AA6: call_method 0x566300 struct [CPedModelInfo] num_params 1 pop 0 [clump]</p>
<p>define function CPedModelInfo__CreateHitColModelSkinned&lt;thiscall, 0x566300&gt;(clump)</p>
<h4>CPedModelInfo::CPedModelInfo</h4>
<p>plugin::CallMethod<0x560120, CPedModelInfo *>(this);</p>
<p>0AA6: call_method 0x560120 struct [CPedModelInfo] num_params 0 pop 0</p>
<p>define function CPedModelInfo__CPedModelInfo&lt;thiscall, 0x560120&gt;()</p>
<h4>CPedModelInfo::~CPedModelInfo</h4>
<p>plugin::CallMethod<0x5600E0, CPedModelInfo *>(this);</p>
<p>0AA6: call_method 0x5600E0 struct [CPedModelInfo] num_params 0 pop 0</p>
<p>define function CPedModelInfo__~CPedModelInfo&lt;thiscall, 0x5600E0&gt;()</p>
<h4>PedModelStore::~PedModelStore</h4>
<p>plugin::CallMethod<0x5600C0, PedModelStore *>(this);</p>
<p>0AA6: call_method 0x5600C0 struct [PedModelStore] num_params 0 pop 0</p>
<p>define function PedModelStore__~PedModelStore&lt;thiscall, 0x5600C0&gt;()</p><h3 id="plugin_vcgame_vccpedpizzaattractorcpp">plugin_vc\game_vc\CPedPizzaAttractor.cpp</h3><h4>CPedPizzaAttractor::GetHeadOfQueueWaitTime</h4>
<p>plugin::CallVirtualMethodAndReturn<float, 0, CPedPizzaAttractor *>(this);</p>
<h4>CPedPizzaAttractor::GetType</h4>
<p>plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedPizzaAttractor *>(this);</p>
<h4>CPedPizzaAttractor::UpdatePedStateOnDeparture</h4>
<p>plugin::CallVirtualMethod<3, CPedPizzaAttractor *, CPed *>(this, ped);</p><h3 id="plugin_vcgame_vccpedplacementcpp">plugin_vc\game_vc\CPedPlacement.cpp</h3><h4>CPedPlacement::FindZCoorForPed</h4>
<p>plugin::CallAndReturn<bool, 0x52FA60, CVector*>(posn);</p>
<p>0AA7: call_function_return 0x52FA60 num_params 1 pop 1 [posn] func_ret [bool]</p>
<p>define function CPedPlacement__FindZCoorForPed&lt;cdecl, 0x52FA60&gt;(posn): int</p>
<h4>CPedPlacement::IsPositionClearForPed</h4>
<p>plugin::CallAndReturn<bool, 0x52FBD0, CVector const&, float, int, CEntity**>(posn, arg1, arg2, entity);</p>
<p>0AA7: call_function_return 0x52FBD0 num_params 4 pop 4 [posn] [arg1] [arg2] [entity] func_ret [bool]</p>
<p>define function CPedPlacement__IsPositionClearForPed&lt;cdecl, 0x52FBD0&gt;(posn, arg1, arg2, entity): int</p>
<h4>CPedPlacement::IsPositionClearOfCars</h4>
<p>plugin::CallAndReturn<bool, 0x52FBA0, CVector*>(posn);</p>
<p>0AA7: call_function_return 0x52FBA0 num_params 1 pop 1 [posn] func_ret [bool]</p>
<p>define function CPedPlacement__IsPositionClearOfCars&lt;cdecl, 0x52FBA0&gt;(posn): int</p><h3 id="plugin_vcgame_vccpedseatattractorcpp">plugin_vc\game_vc\CPedSeatAttractor.cpp</h3><h4>CPedSeatAttractor::GetType</h4>
<p>plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedSeatAttractor *>(this);</p>
<h4>CPedSeatAttractor::UpdatePedStateOnDeparture</h4>
<p>plugin::CallVirtualMethod<3, CPedSeatAttractor *, CPed *>(this, ped);</p><h3 id="plugin_vcgame_vccpedshelterattractorcpp">plugin_vc\game_vc\CPedShelterAttractor.cpp</h3><h4>CPedShelterAttractor::GetType</h4>
<p>plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedShelterAttractor *>(this);</p>
<h4>CPedShelterAttractor::UpdatePedStateOnDeparture</h4>
<p>plugin::CallVirtualMethod<3, CPedShelterAttractor *, CPed *>(this, ped);</p>
<h4>CPedShelterAttractor::IsAtHeadOfQueue</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 4, CPedShelterAttractor *, CPed *>(this, ped);</p>
<h4>CPedShelterAttractor::ComputeAttractPos</h4>
<p>plugin::CallVirtualMethod<5, CPedShelterAttractor *, int, CVector &>(this, qid, pos);</p>
<h4>CPedShelterAttractor::ComputeAttractHeading</h4>
<p>plugin::CallVirtualMethod<6, CPedShelterAttractor *, int, float &>(this, qid, heading);</p>
<h4>CPedShelterAttractor::BroadcastDeparture</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 7, CPedShelterAttractor *, CPed *>(this, ped);</p><h3 id="plugin_vcgame_vccpedstatscpp">plugin_vc\game_vc\CPedStats.cpp</h3><h4>CPedStats::Initialise</h4>
<p>plugin::Call<0x530260>();</p>
<p>0AA5: call_function 0x530260 num_params 0 pop 0</p>
<p>define function CPedStats__Initialise&lt;cdecl, 0x530260&gt;()</p>
<h4>CPedStats::Shutdown</h4>
<p>plugin::Call<0x530220>();</p>
<p>0AA5: call_function 0x530220 num_params 0 pop 0</p>
<p>define function CPedStats__Shutdown&lt;cdecl, 0x530220&gt;()</p>
<h4>CPedStats::LoadPedStats</h4>
<p>plugin::Call<0x530020>();</p>
<p>0AA5: call_function 0x530020 num_params 0 pop 0</p>
<p>define function CPedStats__LoadPedStats&lt;cdecl, 0x530020&gt;()</p>
<h4>CPedStats::GetPedStatType</h4>
<p>plugin::CallAndReturn<unsigned int, 0x52FFC0, char*>(pedStatName);</p>
<p>0AA7: call_function_return 0x52FFC0 num_params 1 pop 1 [pedStatName] func_ret [unsigned int]</p>
<p>define function CPedStats__GetPedStatType&lt;cdecl, 0x52FFC0&gt;(pedStatName): int</p><h3 id="plugin_vcgame_vccpedstopattractorcpp">plugin_vc\game_vc\CPedStopAttractor.cpp</h3><h4>CPedStopAttractor::GetType</h4>
<p>plugin::CallVirtualMethodAndReturn<ePedAttractorType, 2, CPedStopAttractor *>(this);</p>
<h4>CPedStopAttractor::UpdatePedStateOnDeparture</h4>
<p>plugin::CallVirtualMethod<3, CPedStopAttractor *, CPed *>(this, ped);</p><h3 id="plugin_vcgame_vccpedtypecpp">plugin_vc\game_vc\CPedType.cpp</h3><h4>CPedType::Initialise</h4>
<p>plugin::Call<0x530F00>();</p>
<p>0AA5: call_function 0x530F00 num_params 0 pop 0</p>
<p>define function CPedType__Initialise&lt;cdecl, 0x530F00&gt;()</p>
<h4>CPedType::Shutdown</h4>
<p>plugin::Call<0x530EC0>();</p>
<p>0AA5: call_function 0x530EC0 num_params 0 pop 0</p>
<p>define function CPedType__Shutdown&lt;cdecl, 0x530EC0&gt;()</p>
<h4>CPedType::LoadPedData</h4>
<p>plugin::Call<0x530B90>();</p>
<p>0AA5: call_function 0x530B90 num_params 0 pop 0</p>
<p>define function CPedType__LoadPedData&lt;cdecl, 0x530B90&gt;()</p>
<h4>CPedType::FindPedType</h4>
<p>plugin::CallAndReturn<unsigned int, 0x530860, char*>(pedName);</p>
<p>0AA7: call_function_return 0x530860 num_params 1 pop 1 [pedName] func_ret [unsigned int]</p>
<p>define function CPedType__FindPedType&lt;cdecl, 0x530860&gt;(pedName): int</p>
<h4>CPedType::FindPedFlag</h4>
<p>plugin::CallAndReturn<unsigned int, 0x530480, char*>(flagName);</p>
<p>0AA7: call_function_return 0x530480 num_params 1 pop 1 [flagName] func_ret [unsigned int]</p>
<p>define function CPedType__FindPedFlag&lt;cdecl, 0x530480&gt;(flagName): int</p>
<h4>CPedType::Save</h4>
<p>plugin::Call<0x5303D0, unsigned char<em>, unsigned int</em>>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x5303D0 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CPedType__Save&lt;cdecl, 0x5303D0&gt;(bufferPointer, structSize)</p>
<h4>CPedType::Load</h4>
<p>plugin::Call<0x530340, unsigned char*, unsigned int>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x530340 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CPedType__Load&lt;cdecl, 0x530340&gt;(bufferPointer, structSize)</p><h3 id="plugin_vcgame_vccphoneinfocpp">plugin_vc\game_vc\CPhoneInfo.cpp</h3><h4>CPhoneInfo::FindNearestFreePhone</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, CVector *>(gaddrof(CPhoneInfo::FindNearestFreePhone), this, point);</p>
<p>0AA8: call_method_return 0x43CBD0 struct [CPhoneInfo] num_params 1 pop 0 [point] func_ret [int]</p>
<h4>CPhoneInfo::GrabPhone</h4>
<p>plugin::CallMethodAndReturnDynGlobal<int, CPhoneInfo *, float, float>(gaddrof(CPhoneInfo::GrabPhone), this, x, y);</p>
<p>0AA8: call_method_return 0x43C490 struct [CPhoneInfo] num_params 2 pop 0 [x] [y] func_ret [int]</p>
<h4>CPhoneInfo::Initialise</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Initialise), this);</p>
<p>0AA6: call_method 0x43CC60 struct [CPhoneInfo] num_params 0 pop 0</p>
<p>define function CPhoneInfo__Initialise&lt;thiscall, 0x43CC60&gt;()</p>
<h4>CPhoneInfo::Load</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int>(gaddrof(CPhoneInfo::Load), this, bufferPointer, structSize);</p>
<p>0AA6: call_method 0x43C2B0 struct [CPhoneInfo] num_params 2 pop 0 [bufferPointer] [structSize]</p>
<p>define function CPhoneInfo__Load&lt;thiscall, 0x43C2B0&gt;(bufferPointer, structSize)</p>
<h4>CPhoneInfo::Save</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, unsigned char *, unsigned int *>(gaddrof(CPhoneInfo::Save), this, bufferPointer, structSize);</p>
<p>0AA6: call_method 0x43C370 struct [CPhoneInfo] num_params 2 pop 0 [bufferPointer] [structSize]</p>
<p>define function CPhoneInfo__Save&lt;thiscall, 0x43C370&gt;(bufferPointer, structSize)</p>
<h4>CPhoneInfo::SetPhoneMessage_JustOnce</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *, int, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *>(gaddrof(CPhoneInfo::SetPhoneMessage_JustOnce), this, index, text_1, text_2, text_3, text_4, text_5, text_6);</p>
<p>0AA6: call_method 0x43C430 struct [CPhoneInfo] num_params 7 pop 0 [index] [text_1] [text_2] [text_3] [text_4] [text_5] [text_6]</p>
<p>define function CPhoneInfo__SetPhoneMessage_JustOnce&lt;thiscall, 0x43C430&gt;(index, text_1, text_2, text_3, text_4, text_5, text_6)</p>
<h4>CPhoneInfo::Shutdown</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Shutdown), this);</p>
<p>0AA6: call_method 0x43CC50 struct [CPhoneInfo] num_params 0 pop 0</p>
<p>define function CPhoneInfo__Shutdown&lt;thiscall, 0x43CC50&gt;()</p>
<h4>CPhoneInfo::Update</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(gaddrof(CPhoneInfo::Update), this);</p>
<p>0AA6: call_method 0x43C600 struct [CPhoneInfo] num_params 0 pop 0</p>
<p>define function CPhoneInfo__Update&lt;thiscall, 0x43C600&gt;()</p>
<h4>PhonePutDownCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, CPed *>(gaddrof(PhonePutDownCB), association, ped);</p>
<h4>PhonePickUpCB</h4>
<p>plugin::CallDynGlobal<CAnimBlendAssociation *, CPhone *>(gaddrof(PhonePickUpCB), association, phone);</p><h3 id="plugin_vcgame_vccpickupscpp">plugin_vc\game_vc\CPickups.cpp</h3><h4>CPickup::GiveUsAPickUpObject</h4>
<p>plugin::CallMethodAndReturn<int, 0x43D3B0, CPickup *, CObject<strong>, CObject</strong>, int, int>(this, arg0, arg1, arg2, arg3);</p>
<p>0AA8: call_method_return 0x43D3B0 struct [CPickup] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3] func_ret [int]</p>
<p>define function CPickup__GiveUsAPickUpObject&lt;thiscall, 0x43D3B0&gt;(arg0, arg1, arg2, arg3): int</p>
<h4>CPickup::Update</h4>
<p>plugin::CallMethod<0x440030, CPickup <em>, CPlayerPed</em>, CVehicle*, int>(this, arg0, vehicle, arg2);</p>
<p>0AA6: call_method 0x440030 struct [CPickup] num_params 3 pop 0 [arg0] [vehicle] [arg2]</p>
<p>define function CPickup__Update&lt;thiscall, 0x440030&gt;(arg0, vehicle, arg2)</p>
<h4>CPickup::CPickup</h4>
<p>plugin::CallMethod<0x441F30, CPickup *>(this);</p>
<p>0AA6: call_method 0x441F30 struct [CPickup] num_params 0 pop 0</p>
<p>define function CPickup__CPickup&lt;thiscall, 0x441F30&gt;()</p>
<h4>CPickups::CreateSomeMoney</h4>
<p>plugin::Call<0x43E180, CVector, int>(posn, arg1);</p>
<p>0AA5: call_function 0x43E180 num_params 2 pop 2 [posn] [arg1]</p>
<p>define function CPickups__CreateSomeMoney&lt;cdecl, 0x43E180&gt;(posn, arg1)</p>
<h4>CPickups::DoCollectableEffects</h4>
<p>plugin::Call<0x43ED40, CEntity*>(entity);</p>
<p>0AA5: call_function 0x43ED40 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoCollectableEffects&lt;cdecl, 0x43ED40&gt;(entity)</p>
<h4>CPickups::DoMineEffects</h4>
<p>plugin::Call<0x43E840, CEntity*>(entity);</p>
<p>0AA5: call_function 0x43E840 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoMineEffects&lt;cdecl, 0x43E840&gt;(entity)</p>
<h4>CPickups::DoMoneyEffects</h4>
<p>plugin::Call<0x43EAC0, CEntity*>(entity);</p>
<p>0AA5: call_function 0x43EAC0 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoMoneyEffects&lt;cdecl, 0x43EAC0&gt;(entity)</p>
<h4>CPickups::DoPickUpEffects</h4>
<p>plugin::Call<0x43F050, CEntity*>(entity);</p>
<p>0AA5: call_function 0x43F050 num_params 1 pop 1 [entity]</p>
<p>define function CPickups__DoPickUpEffects&lt;cdecl, 0x43F050&gt;(entity)</p>
<h4>CPickups::GenerateNewOne</h4>
<p>plugin::CallAndReturn<int, 0x4418C0, CVector, unsigned int, unsigned char, unsigned int, unsigned int, bool, char*>(posn, arg1, arg2, arg3, arg4, arg5, msg);</p>
<p>0AA7: call_function_return 0x4418C0 num_params 7 pop 7 [posn] [arg1] [arg2] [arg3] [arg4] [arg5] [msg] func_ret [int]</p>
<p>define function CPickups__GenerateNewOne&lt;cdecl, 0x4418C0&gt;(posn, arg1, arg2, arg3, arg4, arg5, msg): int</p>
<h4>CPickups::GetActualPickupIndex</h4>
<p>plugin::CallAndReturn<int, 0x43D360, int>(handle);</p>
<p>0AA7: call_function_return 0x43D360 num_params 1 pop 1 [handle] func_ret [int]</p>
<p>define function CPickups__GetActualPickupIndex&lt;cdecl, 0x43D360&gt;(handle): int</p>
<h4>CPickups::GivePlayerGoodiesWithPickUpMI</h4>
<p>plugin::CallAndReturn<bool, 0x43D910, unsigned short, int>(model, plrIndex);</p>
<p>0AA7: call_function_return 0x43D910 num_params 2 pop 2 [model] [plrIndex] func_ret [bool]</p>
<p>define function CPickups__GivePlayerGoodiesWithPickUpMI&lt;cdecl, 0x43D910&gt;(model, plrIndex): int</p>
<h4>CPickups::Init</h4>
<p>plugin::Call<0x441D30>();</p>
<p>0AA5: call_function 0x441D30 num_params 0 pop 0</p>
<p>define function CPickups__Init&lt;cdecl, 0x441D30&gt;()</p>
<h4>CPickups::IsPickUpPickedUp</h4>
<p>plugin::CallAndReturn<bool, 0x441880, int>(handle);</p>
<p>0AA7: call_function_return 0x441880 num_params 1 pop 1 [handle] func_ret [bool]</p>
<p>define function CPickups__IsPickUpPickedUp&lt;cdecl, 0x441880&gt;(handle): int</p>
<h4>CPickups::Load</h4>
<p>plugin::Call<0x43CF40, unsigned char*, unsigned int>(arg0, arg1);</p>
<p>0AA5: call_function 0x43CF40 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CPickups__Load&lt;cdecl, 0x43CF40&gt;(arg0, arg1)</p>
<h4>CPickups::ModelForWeapon</h4>
<p>plugin::CallAndReturn<int, 0x4418B0, eWeaponType>(weaponType);</p>
<p>0AA7: call_function_return 0x4418B0 num_params 1 pop 1 [weaponType] func_ret [int]</p>
<p>define function CPickups__ModelForWeapon&lt;cdecl, 0x4418B0&gt;(weaponType): int</p>
<h4>CPickups::PassTime</h4>
<p>plugin::Call<0x43D8C0, unsigned int>(time);</p>
<p>0AA5: call_function 0x43D8C0 num_params 1 pop 1 [time]</p>
<p>define function CPickups__PassTime&lt;cdecl, 0x43D8C0&gt;(time)</p>
<h4>CPickups::RemoveAllPickupsOfACertainWeaponGroupWithNoAmmo</h4>
<p>plugin::Call<0x43D240, eWeaponType>(weaponType);</p>
<p>0AA5: call_function 0x43D240 num_params 1 pop 1 [weaponType]</p>
<p>define function CPickups__RemoveAllPickupsOfACertainWeaponGroupWithNoAmmo&lt;cdecl, 0x43D240&gt;(weaponType)</p>
<h4>CPickups::RemovePickUp</h4>
<p>plugin::Call<0x4417D0, int>(handle);</p>
<p>0AA5: call_function 0x4417D0 num_params 1 pop 1 [handle]</p>
<p>define function CPickups__RemovePickUp&lt;cdecl, 0x4417D0&gt;(handle)</p>
<h4>CPickups::RemoveUnnecessaryPickups</h4>
<p>plugin::Call<0x43E4C0, CVector const&, float>(posn, radius);</p>
<p>0AA5: call_function 0x43E4C0 num_params 2 pop 2 [posn] [radius]</p>
<p>define function CPickups__RemoveUnnecessaryPickups&lt;cdecl, 0x43E4C0&gt;(posn, radius)</p>
<h4>CPickups::RenderPickUpText</h4>
<p>plugin::Call<0x43E5E0>();</p>
<p>0AA5: call_function 0x43E5E0 num_params 0 pop 0</p>
<p>define function CPickups__RenderPickUpText&lt;cdecl, 0x43E5E0&gt;()</p>
<h4>CPickups::Save</h4>
<p>plugin::Call<0x43D0D0, unsigned char<em>, unsigned int</em>>(arg0, arg1);</p>
<p>0AA5: call_function 0x43D0D0 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CPickups__Save&lt;cdecl, 0x43D0D0&gt;(arg0, arg1)</p>
<h4>CPickups::Update</h4>
<p>plugin::Call<0x441BB0>();</p>
<p>0AA5: call_function 0x441BB0 num_params 0 pop 0</p>
<p>define function CPickups__Update&lt;cdecl, 0x441BB0&gt;()</p><h3 id="plugin_vcgame_vccplanecpp">plugin_vc\game_vc\CPlane.cpp</h3><h4>CPlane::CPlane</h4>
<p>plugin::CallMethod<0x5B2B50, CPlane *, int, unsigned char>(this, modelIndex, createdBy);</p>
<p>0AA6: call_method 0x5B2B50 struct [CPlane] num_params 2 pop 0 [modelIndex] [createdBy]</p>
<p>define function CPlane__CPlane&lt;thiscall, 0x5B2B50&gt;(modelIndex, createdBy)</p>
<h4>CPlane::InitPlanes</h4>
<p>plugin::Call<0x5B21E0>();</p>
<p>0AA5: call_function 0x5B21E0 num_params 0 pop 0</p>
<p>define function CPlane__InitPlanes&lt;cdecl, 0x5B21E0&gt;()</p>
<h4>CPlane::Load</h4>
<p>plugin::CallAndReturn<bool, 0x5AFAD0>();</p>
<p>0AA7: call_function_return 0x5AFAD0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlane__Load&lt;cdecl, 0x5AFAD0&gt;(): int</p>
<h4>CPlane::LoadPath</h4>
<p>plugin::Call<0x5B1FF0, char const*, int&, float&, bool>(arg0, arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x5B1FF0 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CPlane__LoadPath&lt;cdecl, 0x5B1FF0&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CPlane::Save</h4>
<p>plugin::CallAndReturn<bool, 0x5AFB80>();</p>
<p>0AA7: call_function_return 0x5AFB80 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlane__Save&lt;cdecl, 0x5AFB80&gt;(): int</p>
<h4>CPlane::Shutdown</h4>
<p>plugin::Call<0x5B2160>();</p>
<p>0AA5: call_function 0x5B2160 num_params 0 pop 0</p>
<p>define function CPlane__Shutdown&lt;cdecl, 0x5B2160&gt;()</p>
<h4>CPlane::TestRocketCollision</h4>
<p>plugin::CallAndReturn<bool, 0x5AFC90, CVector*>(arg0);</p>
<p>0AA7: call_function_return 0x5AFC90 num_params 1 pop 1 [arg0] func_ret [bool]</p>
<p>define function CPlane__TestRocketCollision&lt;cdecl, 0x5AFC90&gt;(arg0): int</p>
<h4>CPlane::UpdatePlanes</h4>
<p>plugin::Call<0x5B19D0>();</p>
<p>0AA5: call_function 0x5B19D0 num_params 0 pop 0</p>
<p>define function CPlane__UpdatePlanes&lt;cdecl, 0x5B19D0&gt;()</p><h3 id="plugin_vcgame_vccplayerpedcpp">plugin_vc\game_vc\CPlayerPed.cpp</h3><h4>CPlayerPed::AnnoyPlayerPed</h4>
<p>plugin::CallMethod<0x531CF0, CPlayerPed *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x531CF0 struct [CPlayerPed] num_params 1 pop 0 [arg0]</p>
<p>define function CPlayerPed__AnnoyPlayerPed&lt;thiscall, 0x531CF0&gt;(arg0)</p>
<h4>CPlayerPed::CPlayerPed</h4>
<p>plugin::CallMethod<0x5384B0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x5384B0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__CPlayerPed&lt;thiscall, 0x5384B0&gt;()</p>
<h4>CPlayerPed::ClearAdrenaline</h4>
<p>plugin::CallMethod<0x531CC0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x531CC0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ClearAdrenaline&lt;thiscall, 0x531CC0&gt;()</p>
<h4>CPlayerPed::ClearWeaponTarget</h4>
<p>plugin::CallMethod<0x533B30, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x533B30 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ClearWeaponTarget&lt;thiscall, 0x533B30&gt;()</p>
<h4>CPlayerPed::DeactivatePlayerPed</h4>
<p>plugin::Call<0x5383C0, int>(playerId);</p>
<p>0AA5: call_function 0x5383C0 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__DeactivatePlayerPed&lt;cdecl, 0x5383C0&gt;(playerId)</p>
<h4>CPlayerPed::DoStuffToGoOnFire</h4>
<p>plugin::CallMethod<0x531D20, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x531D20 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__DoStuffToGoOnFire&lt;thiscall, 0x531D20&gt;()</p>
<h4>CPlayerPed::DoWeaponSmoothSpray</h4>
<p>plugin::CallMethodAndReturn<float, 0x536410, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x536410 struct [CPlayerPed] num_params 0 pop 0 func_ret [float]</p>
<p>define function CPlayerPed__DoWeaponSmoothSpray&lt;thiscall, 0x536410&gt;(): float</p>
<h4>CPlayerPed::DoesPlayerWantNewWeapon</h4>
<p>plugin::CallMethodAndReturn<bool, 0x535240, CPlayerPed *, eWeaponType, bool>(this, weaponType, enable);</p>
<p>0AA8: call_method_return 0x535240 struct [CPlayerPed] num_params 2 pop 0 [weaponType] [enable] func_ret [bool]</p>
<p>define function CPlayerPed__DoesPlayerWantNewWeapon&lt;thiscall, 0x535240&gt;(weaponType, enable): int</p>
<h4>CPlayerPed::EvaluateNeighbouringTarget</h4>
<p>plugin::CallMethod<0x5320B0, CPlayerPed <em>, CEntity</em>, CEntity*<em>, float</em>, float, float, bool, bool, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6, arg7);</p>
<p>0AA6: call_method 0x5320B0 struct [CPlayerPed] num_params 8 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5] [arg6] [arg7]</p>
<p>define function CPlayerPed__EvaluateNeighbouringTarget&lt;thiscall, 0x5320B0&gt;(target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6, arg7)</p>
<h4>CPlayerPed::EvaluateTarget</h4>
<p>plugin::CallMethod<0x532360, CPlayerPed <em>, CEntity</em>, CEntity*<em>, float</em>, float, float, bool, bool>(this, target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6);</p>
<p>0AA6: call_method 0x532360 struct [CPlayerPed] num_params 7 pop 0 [target] [outTarget] [outTargetPriority] [maxDistance] [arg4] [arg5] [arg6]</p>
<p>define function CPlayerPed__EvaluateTarget&lt;thiscall, 0x532360&gt;(target, outTarget, outTargetPriority, maxDistance, arg4, arg5, arg6)</p>
<h4>CPlayerPed::FindMeleeAttackPoint</h4>
<p>plugin::CallMethodAndReturn<int, 0x531390, CPlayerPed <em>, CPed</em>, CVector&, unsigned int&>(this, arg0, arg1, arg2);</p>
<p>0AA8: call_method_return 0x531390 struct [CPlayerPed] num_params 3 pop 0 [arg0] [arg1] [arg2] func_ret [int]</p>
<p>define function CPlayerPed__FindMeleeAttackPoint&lt;thiscall, 0x531390&gt;(arg0, arg1, arg2): int</p>
<h4>CPlayerPed::FindNewAttackPoints</h4>
<p>plugin::CallMethodAndReturn<short, 0x531810, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x531810 struct [CPlayerPed] num_params 0 pop 0 func_ret [short]</p>
<p>define function CPlayerPed__FindNewAttackPoints&lt;thiscall, 0x531810&gt;(): int</p>
<h4>CPlayerPed::FindNextWeaponLockOnTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x532590, CPlayerPed <em>, CEntity</em>, bool>(this, target, arg1);</p>
<p>0AA8: call_method_return 0x532590 struct [CPlayerPed] num_params 2 pop 0 [target] [arg1] func_ret [bool]</p>
<p>define function CPlayerPed__FindNextWeaponLockOnTarget&lt;thiscall, 0x532590&gt;(target, arg1): int</p>
<h4>CPlayerPed::FindWeaponLockOnTarget</h4>
<p>plugin::CallMethodAndReturn<bool, 0x533030, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x533030 struct [CPlayerPed] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CPlayerPed__FindWeaponLockOnTarget&lt;thiscall, 0x533030&gt;(): int</p>
<h4>CPlayerPed::GetPlayerInfoForThisPlayerPed</h4>
<p>plugin::CallMethodAndReturn<CPlayerInfo*, 0x531D40, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x531D40 struct [CPlayerPed] num_params 0 pop 0 func_ret [CPlayerInfo*]</p>
<p>define function CPlayerPed__GetPlayerInfoForThisPlayerPed&lt;thiscall, 0x531D40&gt;(): int</p>
<h4>CPlayerPed::KeepAreaAroundPlayerClear</h4>
<p>plugin::CallMethod<0x531D60, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x531D60 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__KeepAreaAroundPlayerClear&lt;thiscall, 0x531D60&gt;()</p>
<h4>CPlayerPed::MakeChangesForNewWeapon</h4>
<p>plugin::CallMethod<0x534450, CPlayerPed *, eWeaponType>(this, weaponType);</p>
<p>0AA6: call_method 0x534450 struct [CPlayerPed] num_params 1 pop 0 [weaponType]</p>
<p>define function CPlayerPed__MakeChangesForNewWeapon&lt;thiscall, 0x534450&gt;(weaponType)</p>
<h4>CPlayerPed::MakeChangesForNewWeapon</h4>
<p>plugin::CallMethod<0x534580, CPlayerPed *, int>(this, weaponSlot);</p>
<p>0AA6: call_method 0x534580 struct [CPlayerPed] num_params 1 pop 0 [weaponSlot]</p>
<p>define function CPlayerPed__MakeChangesForNewWeapon&lt;thiscall, 0x534580&gt;(weaponSlot)</p>
<h4>CPlayerPed::MakeObjectTargettable</h4>
<p>plugin::CallMethod<0x531FD0, CPlayerPed *, int, bool>(this, arg0, arg1);</p>
<p>0AA6: call_method 0x531FD0 struct [CPlayerPed] num_params 2 pop 0 [arg0] [arg1]</p>
<p>define function CPlayerPed__MakeObjectTargettable&lt;thiscall, 0x531FD0&gt;(arg0, arg1)</p>
<h4>CPlayerPed::PlayIdleAnimations</h4>
<p>plugin::CallMethod<0x535D10, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x535D10 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayIdleAnimations&lt;thiscall, 0x535D10&gt;(pad)</p>
<h4>CPlayerPed::PlayerControl1stPersonRunAround</h4>
<p>plugin::CallMethod<0x5357D0, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x5357D0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControl1stPersonRunAround&lt;thiscall, 0x5357D0&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlFighter</h4>
<p>plugin::CallMethod<0x535BB0, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x535BB0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlFighter&lt;thiscall, 0x535BB0&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlM16</h4>
<p>plugin::CallMethod<0x5352B0, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x5352B0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlM16&lt;thiscall, 0x5352B0&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlSniper</h4>
<p>plugin::CallMethod<0x535550, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x535550 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlSniper&lt;thiscall, 0x535550&gt;(pad)</p>
<h4>CPlayerPed::PlayerControlZelda</h4>
<p>plugin::CallMethod<0x535F40, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x535F40 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__PlayerControlZelda&lt;thiscall, 0x535F40&gt;(pad)</p>
<h4>CPlayerPed::ProcessAnimGroups</h4>
<p>plugin::CallMethod<0x533B80, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x533B80 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ProcessAnimGroups&lt;thiscall, 0x533B80&gt;()</p>
<h4>CPlayerPed::ProcessPlayerWeapon</h4>
<p>plugin::CallMethod<0x534890, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x534890 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessPlayerWeapon&lt;thiscall, 0x534890&gt;(pad)</p>
<h4>CPlayerPed::ProcessWeaponSwitch</h4>
<p>plugin::CallMethod<0x5345A0, CPlayerPed <em>, CPad</em>>(this, pad);</p>
<p>0AA6: call_method 0x5345A0 struct [CPlayerPed] num_params 1 pop 0 [pad]</p>
<p>define function CPlayerPed__ProcessWeaponSwitch&lt;thiscall, 0x5345A0&gt;(pad)</p>
<h4>CPlayerPed::ReApplyMoveAnims</h4>
<p>plugin::CallMethod<0x5371B0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x5371B0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__ReApplyMoveAnims&lt;thiscall, 0x5371B0&gt;()</p>
<h4>CPlayerPed::ReactivatePlayerPed</h4>
<p>plugin::Call<0x5383A0, int>(playerId);</p>
<p>0AA5: call_function 0x5383A0 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__ReactivatePlayerPed&lt;cdecl, 0x5383A0&gt;(playerId)</p>
<h4>CPlayerPed::RemovePedFromMeleeList</h4>
<p>plugin::CallMethod<0x5312A0, CPlayerPed <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x5312A0 struct [CPlayerPed] num_params 1 pop 0 [ped]</p>
<p>define function CPlayerPed__RemovePedFromMeleeList&lt;thiscall, 0x5312A0&gt;(ped)</p>
<h4>CPlayerPed::SetInitialState</h4>
<p>plugin::CallMethod<0x5381F0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x5381F0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__SetInitialState&lt;thiscall, 0x5381F0&gt;()</p>
<h4>CPlayerPed::SetNearbyPedsToInteractWithPlayer</h4>
<p>plugin::CallMethod<0x530FB0, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x530FB0 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__SetNearbyPedsToInteractWithPlayer&lt;thiscall, 0x530FB0&gt;()</p>
<h4>CPlayerPed::SetRealMoveAnim</h4>
<p>plugin::CallMethod<0x536620, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x536620 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__SetRealMoveAnim&lt;thiscall, 0x536620&gt;()</p>
<h4>CPlayerPed::SetWantedLevel</h4>
<p>plugin::CallMethod<0x532090, CPlayerPed *, int>(this, level);</p>
<p>0AA6: call_method 0x532090 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__SetWantedLevel&lt;thiscall, 0x532090&gt;(level)</p>
<h4>CPlayerPed::SetWantedLevelNoDrop</h4>
<p>plugin::CallMethod<0x532070, CPlayerPed *, int>(this, level);</p>
<p>0AA6: call_method 0x532070 struct [CPlayerPed] num_params 1 pop 0 [level]</p>
<p>define function CPlayerPed__SetWantedLevelNoDrop&lt;thiscall, 0x532070&gt;(level)</p>
<h4>CPlayerPed::SetupPlayerPed</h4>
<p>plugin::Call<0x5383E0, int>(playerId);</p>
<p>0AA5: call_function 0x5383E0 num_params 1 pop 1 [playerId]</p>
<p>define function CPlayerPed__SetupPlayerPed&lt;cdecl, 0x5383E0&gt;(playerId)</p>
<h4>CPlayerPed::UpdateMeleeAttackers</h4>
<p>plugin::CallMethod<0x531600, CPlayerPed *>(this);</p>
<p>0AA6: call_method 0x531600 struct [CPlayerPed] num_params 0 pop 0</p>
<p>define function CPlayerPed__UpdateMeleeAttackers&lt;thiscall, 0x531600&gt;()</p>
<h4>CPlayerPed::GetWantedLevel</h4>
<p>plugin::CallMethodAndReturn<int, 0x599B20, CPlayerPed *>(this);</p>
<p>0AA8: call_method_return 0x599B20 struct [CPlayerPed] num_params 0 pop 0 func_ret [int]</p>
<p>define function CPlayerPed__GetWantedLevel&lt;thiscall, 0x599B20&gt;(): int</p><h3 id="plugin_vcgame_vccplayerskincpp">plugin_vc\game_vc\CPlayerSkin.cpp</h3><h4>CPlayerSkin::BeginFrontendSkinEdit</h4>
<p>plugin::Call<0x627D10>();</p>
<p>0AA5: call_function 0x627D10 num_params 0 pop 0</p>
<p>define function CPlayerSkin__BeginFrontendSkinEdit&lt;cdecl, 0x627D10&gt;()</p>
<h4>CPlayerSkin::EndFrontendSkinEdit</h4>
<p>plugin::Call<0x627CE0>();</p>
<p>0AA5: call_function 0x627CE0 num_params 0 pop 0</p>
<p>define function CPlayerSkin__EndFrontendSkinEdit&lt;cdecl, 0x627CE0&gt;()</p>
<h4>CPlayerSkin::GetSkinTexture</h4>
<p>plugin::CallAndReturn<int, 0x627E60, char const*>(arg0);</p>
<p>0AA7: call_function_return 0x627E60 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CPlayerSkin__GetSkinTexture&lt;cdecl, 0x627E60&gt;(arg0): int</p>
<h4>CPlayerSkin::Initialise</h4>
<p>plugin::Call<0x627FB0>();</p>
<p>0AA5: call_function 0x627FB0 num_params 0 pop 0</p>
<p>define function CPlayerSkin__Initialise&lt;cdecl, 0x627FB0&gt;()</p>
<h4>CPlayerSkin::RenderFrontendSkinEdit</h4>
<p>plugin::Call<0x627BC0>();</p>
<p>0AA5: call_function 0x627BC0 num_params 0 pop 0</p>
<p>define function CPlayerSkin__RenderFrontendSkinEdit&lt;cdecl, 0x627BC0&gt;()</p>
<h4>CPlayerSkin::Shutdown</h4>
<p>plugin::Call<0x627FA0>();</p>
<p>0AA5: call_function 0x627FA0 num_params 0 pop 0</p>
<p>define function CPlayerSkin__Shutdown&lt;cdecl, 0x627FA0&gt;()</p><h3 id="plugin_vcgame_vccpointlightscpp">plugin_vc\game_vc\CPointLights.cpp</h3><h4>CPointLights::AddLight</h4>
<p>plugin::CallDynGlobal<unsigned char, CVector, CVector, float, float, float, float, unsigned char, bool>(gaddrof(CPointLights::AddLight), lightType, point, direction, range, red, green, blue, fogType, generateExtraShadows);</p>
<h4>CPointLights::GenerateLightsAffectingObject</h4>
<p>plugin::CallAndReturnDynGlobal<float, CVector *>(gaddrof(CPointLights::GenerateLightsAffectingObject), point);</p>
<p>0AA7: call_function_return 0x567440 num_params 1 pop 1 [point] func_ret [float]</p>
<p>define function CPointLights__GenerateLightsAffectingObject&lt;cdecl, 0x567440&gt;(point): float</p><h3 id="plugin_vcgame_vccpoolscpp">plugin_vc\game_vc\CPools.cpp</h3><h4>*CPools::GetObject</h4>
<p>plugin::CallAndReturnDynGlobal<CObject *, int>(gaddrof(CPools::GetObject), handle);</p>
<p>0AA7: call_function_return 0x4BFF80 num_params 1 pop 1 [handle] func_ret [CObject *]</p>
<p>define function CPools__GetObject&lt;cdecl, 0x4BFF80&gt;(handle): int</p>
<h4>CPools::GetObjectRef</h4>
<p>plugin::CallAndReturnDynGlobal<int, CObject *>(gaddrof(CPools::GetObjectRef), object);</p>
<p>0AA7: call_function_return 0x4BFFA0 num_params 1 pop 1 [object] func_ret [int]</p>
<p>define function CPools__GetObjectRef&lt;cdecl, 0x4BFFA0&gt;(object): int</p>
<h4>*CPools::GetPed</h4>
<p>plugin::CallAndReturnDynGlobal<CPed *, int>(gaddrof(CPools::GetPed), handle);</p>
<p>0AA7: call_function_return 0x4C0000 num_params 1 pop 1 [handle] func_ret [CPed *]</p>
<p>define function CPools__GetPed&lt;cdecl, 0x4C0000&gt;(handle): int</p>
<h4>CPools::GetPedRef</h4>
<p>plugin::CallAndReturnDynGlobal<int, CPed *>(gaddrof(CPools::GetPedRef), ped);</p>
<p>0AA7: call_function_return 0x4C0020 num_params 1 pop 1 [ped] func_ret [int]</p>
<p>define function CPools__GetPedRef&lt;cdecl, 0x4C0020&gt;(ped): int</p>
<h4>*CPools::GetVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<CVehicle *, int>(gaddrof(CPools::GetVehicle), handle);</p>
<p>0AA7: call_function_return 0x4BFFC0 num_params 1 pop 1 [handle] func_ret [CVehicle *]</p>
<p>define function CPools__GetVehicle&lt;cdecl, 0x4BFFC0&gt;(handle): int</p>
<h4>CPools::GetVehicleRef</h4>
<p>plugin::CallAndReturnDynGlobal<int, CVehicle *>(gaddrof(CPools::GetVehicleRef), vehicle);</p>
<p>0AA7: call_function_return 0x4BFFE0 num_params 1 pop 1 [vehicle] func_ret [int]</p>
<p>define function CPools__GetVehicleRef&lt;cdecl, 0x4BFFE0&gt;(vehicle): int</p>
<h4>CPools::LoadObjectPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadObjectPool), buffer, size);</p>
<h4>CPools::LoadPedPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadPedPool), buffer, size);</p>
<h4>CPools::LoadVehiclePool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CPools::LoadVehiclePool), buffer, size);</p>
<h4>CPools::MakeSureSlotInObjectPoolIsEmpty</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CPools::MakeSureSlotInObjectPoolIsEmpty), slot);</p>
<h4>CPools::SaveObjectPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveObjectPool), buffer, outSize);</p>
<h4>CPools::SavePedPool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SavePedPool), buffer, outSize);</p>
<h4>CPools::SaveVehiclePool</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CPools::SaveVehiclePool), buffer, outSize);</p><h3 id="plugin_vcgame_vccpopulationcpp">plugin_vc\game_vc\CPopulation.cpp</h3><h4>CPopulation::AddDeadPedInFrontOfCar</h4>
<p>plugin::CallAndReturn<CPed<em>, 0x53B180, CVector const&, CVehicle</em>>(posn, vehicle);</p>
<p>0AA7: call_function_return 0x53B180 num_params 2 pop 2 [posn] [vehicle] func_ret [CPed*]</p>
<p>define function CPopulation__AddDeadPedInFrontOfCar&lt;cdecl, 0x53B180&gt;(posn, vehicle): int</p>
<h4>CPopulation::AddPed</h4>
<p>plugin::CallAndReturn<CPed*, 0x53B600, ePedType, unsigned int, CVector const&, int>(pedType, modelIndex, posn, arg3);</p>
<p>0AA7: call_function_return 0x53B600 num_params 4 pop 4 [pedType] [modelIndex] [posn] [arg3] func_ret [CPed*]</p>
<p>define function CPopulation__AddPed&lt;cdecl, 0x53B600&gt;(pedType, modelIndex, posn, arg3): int</p>
<h4>CPopulation::AddPedInCar</h4>
<p>plugin::CallAndReturn<CPed<em>, 0x53A8A0, CVehicle</em>, bool>(vehicle, driver);</p>
<p>0AA7: call_function_return 0x53A8A0 num_params 2 pop 2 [vehicle] [driver] func_ret [CPed*]</p>
<p>define function CPopulation__AddPedInCar&lt;cdecl, 0x53A8A0&gt;(vehicle, driver): int</p>
<h4>CPopulation::AddToPopulation</h4>
<p>plugin::Call<0x53BA80, float, float, float, float>(arg0, arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x53BA80 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CPopulation__AddToPopulation&lt;cdecl, 0x53BA80&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CPopulation::CanJeerAtStripper</h4>
<p>plugin::CallAndReturn<bool, 0x53A670, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x53A670 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopulation__CanJeerAtStripper&lt;cdecl, 0x53A670&gt;(modelIndex): int</p>
<h4>CPopulation::CanSolicitPlayerInCar</h4>
<p>plugin::CallAndReturn<bool, 0x53A6A0, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x53A6A0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopulation__CanSolicitPlayerInCar&lt;cdecl, 0x53A6A0&gt;(modelIndex): int</p>
<h4>CPopulation::CanSolicitPlayerOnFoot</h4>
<p>plugin::CallAndReturn<bool, 0x53A6C0, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x53A6C0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopulation__CanSolicitPlayerOnFoot&lt;cdecl, 0x53A6C0&gt;(modelIndex): int</p>
<h4>CPopulation::ChooseCivilianCoupleOccupations</h4>
<p>plugin::Call<0x53AE90, int, int&, int&>(arg0, arg1, arg2);</p>
<p>0AA5: call_function 0x53AE90 num_params 3 pop 3 [arg0] [arg1] [arg2]</p>
<p>define function CPopulation__ChooseCivilianCoupleOccupations&lt;cdecl, 0x53AE90&gt;(arg0, arg1, arg2)</p>
<h4>CPopulation::ChooseCivilianOccupation</h4>
<p>plugin::CallAndReturn<int, 0x53B070, int>(arg0);</p>
<p>0AA7: call_function_return 0x53B070 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CPopulation__ChooseCivilianOccupation&lt;cdecl, 0x53B070&gt;(arg0): int</p>
<h4>CPopulation::ChooseNextCivilianOccupation</h4>
<p>plugin::CallAndReturn<int, 0x53AFD0, int>(arg0);</p>
<p>0AA7: call_function_return 0x53AFD0 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CPopulation__ChooseNextCivilianOccupation&lt;cdecl, 0x53AFD0&gt;(arg0): int</p>
<h4>CPopulation::ConvertAllObjectsToDummyObjects</h4>
<p>plugin::Call<0x53D430>();</p>
<p>0AA5: call_function 0x53D430 num_params 0 pop 0</p>
<p>define function CPopulation__ConvertAllObjectsToDummyObjects&lt;cdecl, 0x53D430&gt;()</p>
<h4>CPopulation::ConvertToDummyObject</h4>
<p>plugin::Call<0x53D290, CObject*>(object);</p>
<p>0AA5: call_function 0x53D290 num_params 1 pop 1 [object]</p>
<p>define function CPopulation__ConvertToDummyObject&lt;cdecl, 0x53D290&gt;(object)</p>
<h4>CPopulation::ConvertToRealObject</h4>
<p>plugin::Call<0x53D340, CDummyObject*>(dummyObject);</p>
<p>0AA5: call_function 0x53D340 num_params 1 pop 1 [dummyObject]</p>
<p>define function CPopulation__ConvertToRealObject&lt;cdecl, 0x53D340&gt;(dummyObject)</p>
<h4>CPopulation::GeneratePedsAtStartOfGame</h4>
<p>plugin::Call<0x53E3E0>();</p>
<p>0AA5: call_function 0x53E3E0 num_params 0 pop 0</p>
<p>define function CPopulation__GeneratePedsAtStartOfGame&lt;cdecl, 0x53E3E0&gt;()</p>
<h4>CPopulation::Initialise</h4>
<p>plugin::Call<0x53EAF0>();</p>
<p>0AA5: call_function 0x53EAF0 num_params 0 pop 0</p>
<p>define function CPopulation__Initialise&lt;cdecl, 0x53EAF0&gt;()</p>
<h4>CPopulation::IsFemale</h4>
<p>plugin::CallAndReturn<bool, 0x53AD50, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x53AD50 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopulation__IsFemale&lt;cdecl, 0x53AD50&gt;(modelIndex): int</p>
<h4>CPopulation::IsMale</h4>
<p>plugin::CallAndReturn<bool, 0x53ADF0, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x53ADF0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopulation__IsMale&lt;cdecl, 0x53ADF0&gt;(modelIndex): int</p>
<h4>CPopulation::IsSkateable</h4>
<p>plugin::CallAndReturn<bool, 0x53ACA0, CVector const&>(point);</p>
<p>0AA7: call_function_return 0x53ACA0 num_params 1 pop 1 [point] func_ret [bool]</p>
<p>define function CPopulation__IsSkateable&lt;cdecl, 0x53ACA0&gt;(point): int</p>
<h4>CPopulation::IsSunbather</h4>
<p>plugin::CallAndReturn<bool, 0x53A6F0, int>(modelIndex);</p>
<p>0AA7: call_function_return 0x53A6F0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CPopulation__IsSunbather&lt;cdecl, 0x53A6F0&gt;(modelIndex): int</p>
<h4>CPopulation::LoadPedGroups</h4>
<p>plugin::Call<0x53E9C0>();</p>
<p>0AA5: call_function 0x53E9C0 num_params 0 pop 0</p>
<p>define function CPopulation__LoadPedGroups&lt;cdecl, 0x53E9C0&gt;()</p>
<h4>CPopulation::ManagePopulation</h4>
<p>plugin::Call<0x53D690>();</p>
<p>0AA5: call_function 0x53D690 num_params 0 pop 0</p>
<p>define function CPopulation__ManagePopulation&lt;cdecl, 0x53D690&gt;()</p>
<h4>CPopulation::PlaceCouple</h4>
<p>plugin::Call<0x5388F0, ePedType, int, ePedType, int, CVector>(pedType1, modelIndex1, pedType2, modelIndex2, posn);</p>
<p>0AA5: call_function 0x5388F0 num_params 5 pop 5 [pedType1] [modelIndex1] [pedType2] [modelIndex2] [posn]</p>
<p>define function CPopulation__PlaceCouple&lt;cdecl, 0x5388F0&gt;(pedType1, modelIndex1, pedType2, modelIndex2, posn)</p>
<h4>CPopulation::PlaceGangMembersInCircle</h4>
<p>plugin::Call<0x5397F0, ePedType, int, CVector const&>(pedType, modelIndex, posn);</p>
<p>0AA5: call_function 0x5397F0 num_params 3 pop 3 [pedType] [modelIndex] [posn]</p>
<p>define function CPopulation__PlaceGangMembersInCircle&lt;cdecl, 0x5397F0&gt;(pedType, modelIndex, posn)</p>
<h4>CPopulation::PlaceGangMembersInFormation</h4>
<p>plugin::Call<0x539FC0, ePedType, int, CVector const&>(pedType, modelIndex, posn);</p>
<p>0AA5: call_function 0x539FC0 num_params 3 pop 3 [pedType] [modelIndex] [posn]</p>
<p>define function CPopulation__PlaceGangMembersInFormation&lt;cdecl, 0x539FC0&gt;(pedType, modelIndex, posn)</p>
<h4>CPopulation::PlaceMallPedsAsStationaryGroup</h4>
<p>plugin::Call<0x538E90, CVector const&, int>(posn, modelIndex);</p>
<p>0AA5: call_function 0x538E90 num_params 2 pop 2 [posn] [modelIndex]</p>
<p>define function CPopulation__PlaceMallPedsAsStationaryGroup&lt;cdecl, 0x538E90&gt;(posn, modelIndex)</p>
<h4>CPopulation::RemovePed</h4>
<p>plugin::Call<0x53B160, CPed*>(ped);</p>
<p>0AA5: call_function 0x53B160 num_params 1 pop 1 [ped]</p>
<p>define function CPopulation__RemovePed&lt;cdecl, 0x53B160&gt;(ped)</p>
<h4>CPopulation::RemovePedsIfThePoolGetsFull</h4>
<p>plugin::Call<0x53D560>();</p>
<p>0AA5: call_function 0x53D560 num_params 0 pop 0</p>
<p>define function CPopulation__RemovePedsIfThePoolGetsFull&lt;cdecl, 0x53D560&gt;()</p>
<h4>CPopulation::TestSafeForRealObject</h4>
<p>plugin::CallAndReturn<bool, 0x53CF80, CDummyObject*>(dummyObject);</p>
<p>0AA7: call_function_return 0x53CF80 num_params 1 pop 1 [dummyObject] func_ret [bool]</p>
<p>define function CPopulation__TestSafeForRealObject&lt;cdecl, 0x53CF80&gt;(dummyObject): int</p>
<h4>CPopulation::Update</h4>
<p>plugin::Call<0x53E5F0, bool>(generatePeds);</p>
<p>0AA5: call_function 0x53E5F0 num_params 1 pop 1 [generatePeds]</p>
<p>define function CPopulation__Update&lt;cdecl, 0x53E5F0&gt;(generatePeds)</p>
<h4>CPopulation::UpdatePedCount</h4>
<p>plugin::Call<0x53A720, ePedType, unsigned char>(pedType, updateState);</p>
<p>0AA5: call_function 0x53A720 num_params 2 pop 2 [pedType] [updateState]</p>
<p>define function CPopulation__UpdatePedCount&lt;cdecl, 0x53A720&gt;(pedType, updateState)</p><h3 id="plugin_vcgame_vccprojectilecpp">plugin_vc\game_vc\CProjectile.cpp</h3><h4>CProjectile::CProjectile</h4>
<p>plugin::CallMethod<0x4E8D30, CProjectile *, int>(this, arg0);</p>
<p>0AA6: call_method 0x4E8D30 struct [CProjectile] num_params 1 pop 0 [arg0]</p>
<p>define function CProjectile__CProjectile&lt;thiscall, 0x4E8D30&gt;(arg0)</p><h3 id="plugin_vcgame_vccprojectileinfocpp">plugin_vc\game_vc\CProjectileInfo.cpp</h3><h4>CProjectileInfo::Shutdown</h4>
<p>plugin::Call<0x5C7C10>();</p>
<p>0AA5: call_function 0x5C7C10 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Shutdown&lt;cdecl, 0x5C7C10&gt;()</p>
<h4>CProjectileInfo::Update</h4>
<p>plugin::Call<0x5C6A20>();</p>
<p>0AA5: call_function 0x5C6A20 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Update&lt;cdecl, 0x5C6A20&gt;()</p>
<h4>CProjectileInfo::RemoveNotAdd</h4>
<p>plugin::Call<0x5C7180, CEntity*, eWeaponType, CVector>(pEntity, weapontype, posn);</p>
<p>0AA5: call_function 0x5C7180 num_params 3 pop 3 [pEntity] [weapontype] [posn]</p>
<p>define function CProjectileInfo__RemoveNotAdd&lt;cdecl, 0x5C7180&gt;(pEntity, weapontype, posn)</p>
<h4>CProjectileInfo::RemoveIfThisIsAProjectile</h4>
<p>plugin::CallAndReturn<bool, 0x5C6970, CObject*>(pObject);</p>
<p>0AA7: call_function_return 0x5C6970 num_params 1 pop 1 [pObject] func_ret [bool]</p>
<p>define function CProjectileInfo__RemoveIfThisIsAProjectile&lt;cdecl, 0x5C6970&gt;(pObject): int</p>
<h4>CProjectileInfo::RemoveDetonatorProjectiles</h4>
<p>plugin::Call<0x5C71D0>();</p>
<p>0AA5: call_function 0x5C71D0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__RemoveDetonatorProjectiles&lt;cdecl, 0x5C71D0&gt;()</p>
<h4>CProjectileInfo::RemoveAllProjectiles</h4>
<p>plugin::Call<0x5C69D0>();</p>
<p>0AA5: call_function 0x5C69D0 num_params 0 pop 0</p>
<p>define function CProjectileInfo__RemoveAllProjectiles&lt;cdecl, 0x5C69D0&gt;()</p>
<h4>CProjectileInfo::Initialise</h4>
<p>plugin::Call<0x5C7C30>();</p>
<p>0AA5: call_function 0x5C7C30 num_params 0 pop 0</p>
<p>define function CProjectileInfo__Initialise&lt;cdecl, 0x5C7C30&gt;()</p>
<h4>CProjectileInfo::GetProjectileInfo</h4>
<p>plugin::CallAndReturn<CProjectileInfo*, 0x5C7BF0, int>(ProjIndex);</p>
<p>0AA7: call_function_return 0x5C7BF0 num_params 1 pop 1 [ProjIndex] func_ret [CProjectileInfo*]</p>
<p>define function CProjectileInfo__GetProjectileInfo&lt;cdecl, 0x5C7BF0&gt;(ProjIndex): int</p>
<h4>CProjectileInfo::AddProjectile</h4>
<p>plugin::CallAndReturn<bool, 0x5C7250, CEntity*, eWeaponType, CVector, float>(pEntity, weapontype, posn, fPower);</p>
<p>0AA7: call_function_return 0x5C7250 num_params 4 pop 4 [pEntity] [weapontype] [posn] [fPower] func_ret [bool]</p>
<p>define function CProjectileInfo__AddProjectile&lt;cdecl, 0x5C7250&gt;(pEntity, weapontype, posn, fPower): int</p><h3 id="plugin_vcgame_vccquaternioncpp">plugin_vc\game_vc\CQuaternion.cpp</h3><h4>CQuaternion::Get</h4>
<p>plugin::CallMethod<0x4DFD30, CQuaternion <em>, RwMatrixTag</em>>(this, out);</p>
<p>0AA6: call_method 0x4DFD30 struct [CQuaternion] num_params 1 pop 0 [out]</p>
<p>define function CQuaternion__Get&lt;thiscall, 0x4DFD30&gt;(out)</p>
<h4>CQuaternion::Set</h4>
<p>plugin::CallMethod<0x4DFE20, CQuaternion <em>, RwV3d</em>, float>(this, axis, angle);</p>
<p>0AA6: call_method 0x4DFE20 struct [CQuaternion] num_params 2 pop 0 [axis] [angle]</p>
<p>define function CQuaternion__Set&lt;thiscall, 0x4DFE20&gt;(axis, angle)</p>
<h4>CQuaternion::Slerp</h4>
<p>plugin::CallMethod<0x4DFBE0, CQuaternion *, CQuaternion const&, CQuaternion const&, float, float, float>(this, from, to, halftheta, sintheta_inv, t);</p>
<p>0AA6: call_method 0x4DFBE0 struct [CQuaternion] num_params 5 pop 0 [from] [to] [halftheta] [sintheta_inv] [t]</p>
<p>define function CQuaternion__Slerp&lt;thiscall, 0x4DFBE0&gt;(from, to, halftheta, sintheta_inv, t)</p><h3 id="plugin_vcgame_vccradarcpp">plugin_vc\game_vc\CRadar.cpp</h3><h4>CRadar::CalculateCachedSinCos</h4>
<p>plugin::Call<0x4C3D80>();</p>
<p>0AA5: call_function 0x4C3D80 num_params 0 pop 0</p>
<p>define function CRadar__CalculateCachedSinCos&lt;cdecl, 0x4C3D80&gt;()</p>
<h4>CRadar::ChangeBlipBrightness</h4>
<p>plugin::Call<0x4C38B0, int, int>(i, bright);</p>
<p>0AA5: call_function 0x4C38B0 num_params 2 pop 2 [i] [bright]</p>
<p>define function CRadar__ChangeBlipBrightness&lt;cdecl, 0x4C38B0&gt;(i, bright)</p>
<h4>CRadar::ChangeBlipColour</h4>
<p>plugin::Call<0x4C3930, int, unsigned int>(i, colour);</p>
<p>0AA5: call_function 0x4C3930 num_params 2 pop 2 [i] [colour]</p>
<p>define function CRadar__ChangeBlipColour&lt;cdecl, 0x4C3930&gt;(i, colour)</p>
<h4>CRadar::ChangeBlipDisplay</h4>
<p>plugin::Call<0x4C37E0, int, eBlipDisplay>(i, display);</p>
<p>0AA5: call_function 0x4C37E0 num_params 2 pop 2 [i] [display]</p>
<p>define function CRadar__ChangeBlipDisplay&lt;cdecl, 0x4C37E0&gt;(i, display)</p>
<h4>CRadar::ChangeBlipScale</h4>
<p>plugin::Call<0x4C3840, int, int>(i, scale);</p>
<p>0AA5: call_function 0x4C3840 num_params 2 pop 2 [i] [scale]</p>
<p>define function CRadar__ChangeBlipScale&lt;cdecl, 0x4C3840&gt;(i, scale)</p>
<h4>CRadar::ClearBlip</h4>
<p>plugin::Call<0x4C3990, int>(i);</p>
<p>0AA5: call_function 0x4C3990 num_params 1 pop 1 [i]</p>
<p>define function CRadar__ClearBlip&lt;cdecl, 0x4C3990&gt;(i)</p>
<h4>CRadar::ClearBlipForEntity</h4>
<p>plugin::Call<0x4C3A70, eBlipType, int>(type, handle);</p>
<p>0AA5: call_function 0x4C3A70 num_params 2 pop 2 [type] [handle]</p>
<p>define function CRadar__ClearBlipForEntity&lt;cdecl, 0x4C3A70&gt;(type, handle)</p>
<h4>CRadar::ClipRadarPoly</h4>
<p>plugin::CallAndReturn<int, 0x4C2280, CVector2D<em>, CVector2D const</em>>(out, in);</p>
<p>0AA7: call_function_return 0x4C2280 num_params 2 pop 2 [out] [in] func_ret [int]</p>
<p>define function CRadar__ClipRadarPoly&lt;cdecl, 0x4C2280&gt;(out, in): int</p>
<h4>CRadar::Draw3dMarkers</h4>
<p>plugin::Call<0x4C3F20>();</p>
<p>0AA5: call_function 0x4C3F20 num_params 0 pop 0</p>
<p>define function CRadar__Draw3dMarkers&lt;cdecl, 0x4C3F20&gt;()</p>
<h4>CRadar::DrawBlips</h4>
<p>plugin::Call<0x4C4200>();</p>
<p>0AA5: call_function 0x4C4200 num_params 0 pop 0</p>
<p>define function CRadar__DrawBlips&lt;cdecl, 0x4C4200&gt;()</p>
<h4>CRadar::DrawCoordBlip</h4>
<p>plugin::Call<0x4C5680, int>(i);</p>
<p>0AA5: call_function 0x4C5680 num_params 1 pop 1 [i]</p>
<p>define function CRadar__DrawCoordBlip&lt;cdecl, 0x4C5680&gt;(i)</p>
<h4>CRadar::DrawEntityBlip</h4>
<p>plugin::Call<0x4C5170, int>(i);</p>
<p>0AA5: call_function 0x4C5170 num_params 1 pop 1 [i]</p>
<p>define function CRadar__DrawEntityBlip&lt;cdecl, 0x4C5170&gt;(i)</p>
<h4>CRadar::DrawLegend</h4>
<p>plugin::Call<0x4C4A10, int, int, int>(x, y, sprite);</p>
<p>0AA5: call_function 0x4C4A10 num_params 3 pop 3 [x] [y] [sprite]</p>
<p>define function CRadar__DrawLegend&lt;cdecl, 0x4C4A10&gt;(x, y, sprite)</p>
<h4>CRadar::DrawMap</h4>
<p>plugin::Call<0x4C5C60 >();</p>
<p>0AA5: call_function 0x4C5C60 num_params 0 pop 0</p>
<p>define function CRadar__DrawMap&lt;cdecl, 0x4C5C60&gt;()</p>
<h4>CRadar::DrawRadarMap</h4>
<p>plugin::Call<0x4C17C0>();</p>
<p>0AA5: call_function 0x4C17C0 num_params 0 pop 0</p>
<p>define function CRadar__DrawRadarMap&lt;cdecl, 0x4C17C0&gt;()</p>
<h4>CRadar::DrawRadarMask</h4>
<p>plugin::Call<0x4C1A20>();</p>
<p>0AA5: call_function 0x4C1A20 num_params 0 pop 0</p>
<p>define function CRadar__DrawRadarMask&lt;cdecl, 0x4C1A20&gt;()</p>
<h4>CRadar::DrawRadarSection</h4>
<p>plugin::Call<0x4C1D60>();</p>
<p>0AA5: call_function 0x4C1D60 num_params 0 pop 0</p>
<p>define function CRadar__DrawRadarSection&lt;cdecl, 0x4C1D60&gt;()</p>
<h4>CRadar::DrawRadarSprite</h4>
<p>plugin::Call<0x4C2D00, unsigned short, float, float, unsigned char>(sprite, x, y, alpha);</p>
<p>0AA5: call_function 0x4C2D00 num_params 4 pop 4 [sprite] [x] [y] [alpha]</p>
<p>define function CRadar__DrawRadarSprite&lt;cdecl, 0x4C2D00&gt;(sprite, x, y, alpha)</p>
<h4>CRadar::DrawRotatingRadarSprite</h4>
<p>plugin::Call<0x4C2E70, CSprite2d*, float, float, float, unsigned char>(sprite, x, y, angle, alpha);</p>
<p>0AA5: call_function 0x4C2E70 num_params 5 pop 5 [sprite] [x] [y] [angle] [alpha]</p>
<p>define function CRadar__DrawRotatingRadarSprite&lt;cdecl, 0x4C2E70&gt;(sprite, x, y, angle, alpha)</p>
<h4>CRadar::DrawYouAreHereSprite</h4>
<p>plugin::Call<0x4C2980, float, float>(x, y);</p>
<p>0AA5: call_function 0x4C2980 num_params 2 pop 2 [x] [y]</p>
<p>define function CRadar__DrawYouAreHereSprite&lt;cdecl, 0x4C2980&gt;(x, y)</p>
<h4>CRadar::GetActualBlipArrayIndex</h4>
<p>plugin::CallAndReturn<int, 0x4C5D70, int>(i);</p>
<p>0AA7: call_function_return 0x4C5D70 num_params 1 pop 1 [i] func_ret [int]</p>
<p>define function CRadar__GetActualBlipArrayIndex&lt;cdecl, 0x4C5D70&gt;(i): int</p>
<h4>CRadar::GetRadarTraceColour</h4>
<p>plugin::CallAndReturn<unsigned int, 0x4C3050, unsigned int, bool>(colour, bright);</p>
<p>0AA7: call_function_return 0x4C3050 num_params 2 pop 2 [colour] [bright] func_ret [unsigned int]</p>
<p>define function CRadar__GetRadarTraceColour&lt;cdecl, 0x4C3050&gt;(colour, bright): int</p>
<h4>CRadar::InitFrontEndMap</h4>
<p>plugin::Call<0x4C5B30>();</p>
<p>0AA5: call_function 0x4C5B30 num_params 0 pop 0</p>
<p>define function CRadar__InitFrontEndMap&lt;cdecl, 0x4C5B30&gt;()</p>
<h4>CRadar::Initialise</h4>
<p>plugin::Call<0x4C6200>();</p>
<p>0AA5: call_function 0x4C6200 num_params 0 pop 0</p>
<p>define function CRadar__Initialise&lt;cdecl, 0x4C6200&gt;()</p>
<h4>CRadar::LoadAllRadarBlips</h4>
<p>plugin::Call<0x4C15D0, unsigned char*, unsigned int>(buf, size);</p>
<p>0AA5: call_function 0x4C15D0 num_params 2 pop 2 [buf] [size]</p>
<p>define function CRadar__LoadAllRadarBlips&lt;cdecl, 0x4C15D0&gt;(buf, size)</p>
<h4>CRadar::LoadTextures</h4>
<p>plugin::Call<0x4C5DC0>();</p>
<p>0AA5: call_function 0x4C5DC0 num_params 0 pop 0</p>
<p>define function CRadar__LoadTextures&lt;cdecl, 0x4C5DC0&gt;()</p>
<h4>CRadar::RemoveRadarSections</h4>
<p>plugin::Call<0x4C2930>();</p>
<p>0AA5: call_function 0x4C2930 num_params 0 pop 0</p>
<p>define function CRadar__RemoveRadarSections&lt;cdecl, 0x4C2930&gt;()</p>
<h4>CRadar::SaveAllRadarBlips</h4>
<p>plugin::Call<0x4C16B0, unsigned char<em>, unsigned int</em>>(buf, size);</p>
<p>0AA5: call_function 0x4C16B0 num_params 2 pop 2 [buf] [size]</p>
<p>define function CRadar__SaveAllRadarBlips&lt;cdecl, 0x4C16B0&gt;(buf, size)</p>
<h4>CRadar::SetBlipSprite</h4>
<p>plugin::Call<0x4C3780, int, int>(i, icon);</p>
<p>0AA5: call_function 0x4C3780 num_params 2 pop 2 [i] [icon]</p>
<p>define function CRadar__SetBlipSprite&lt;cdecl, 0x4C3780&gt;(i, icon)</p>
<h4>CRadar::SetCoordBlip</h4>
<p>plugin::CallAndReturn<int, 0x4C3C80, eBlipType, CVector const&, unsigned int, eBlipDisplay>(type, pos, colour, display);</p>
<p>0AA7: call_function_return 0x4C3C80 num_params 4 pop 4 [type] [pos] [colour] [display] func_ret [int]</p>
<p>define function CRadar__SetCoordBlip&lt;cdecl, 0x4C3C80&gt;(type, pos, colour, display): int</p>
<h4>CRadar::SetEntityBlip</h4>
<p>plugin::Call<0x4C3B40, eBlipType, int, unsigned int, eBlipDisplay>(type, handle, colour, display);</p>
<p>0AA5: call_function 0x4C3B40 num_params 4 pop 4 [type] [handle] [colour] [display]</p>
<p>define function CRadar__SetEntityBlip&lt;cdecl, 0x4C3B40&gt;(type, handle, colour, display)</p>
<h4>CRadar::SetShortRangeCoordBlip</h4>
<p>plugin::CallAndReturn<int, 0x4C3C00, eBlipType, CVector const&, unsigned int, eBlipDisplay>(type, pos, color, display);</p>
<p>0AA7: call_function_return 0x4C3C00 num_params 4 pop 4 [type] [pos] [color] [display] func_ret [int]</p>
<p>define function CRadar__SetShortRangeCoordBlip&lt;cdecl, 0x4C3C00&gt;(type, pos, color, display): int</p>
<h4>CRadar::ShowRadarMarker</h4>
<p>plugin::Call<0x4C3100, CVector const&, unsigned int, float>(pos, colour, radius);</p>
<p>0AA5: call_function 0x4C3100 num_params 3 pop 3 [pos] [colour] [radius]</p>
<p>define function CRadar__ShowRadarMarker&lt;cdecl, 0x4C3100&gt;(pos, colour, radius)</p>
<h4>CRadar::ShowRadarTraceWithHeight</h4>
<p>plugin::Call<0x4C32F0, float, float, unsigned int, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char>(x, y, size, red, green, blue, alpha, type);</p>
<p>0AA5: call_function 0x4C32F0 num_params 8 pop 8 [x] [y] [size] [red] [green] [blue] [alpha] [type]</p>
<p>define function CRadar__ShowRadarTraceWithHeight&lt;cdecl, 0x4C32F0&gt;(x, y, size, red, green, blue, alpha, type)</p>
<h4>CRadar::Shutdown</h4>
<p>plugin::Call<0x4C6030>();</p>
<p>0AA5: call_function 0x4C6030 num_params 0 pop 0</p>
<p>define function CRadar__Shutdown&lt;cdecl, 0x4C6030&gt;()</p>
<h4>CRadar::StreamRadarSections</h4>
<p>plugin::Call<0x4C2870, int, int>(x, y);</p>
<p>0AA5: call_function 0x4C2870 num_params 2 pop 2 [x] [y]</p>
<p>define function CRadar__StreamRadarSections&lt;cdecl, 0x4C2870&gt;(x, y)</p>
<h4>CRadar::StreamRadarSections</h4>
<p>plugin::Call<0x4C1960, CVector const&>(pos);</p>
<p>0AA5: call_function 0x4C1960 num_params 1 pop 1 [pos]</p>
<p>define function CRadar__StreamRadarSections&lt;cdecl, 0x4C1960&gt;(pos)</p><h3 id="plugin_vcgame_vccregisteredmotionblurstreakcpp">plugin_vc\game_vc\CRegisteredMotionBlurStreak.cpp</h3><h4>CRegisteredMotionBlurStreak::Render</h4>
<p>plugin::CallMethod<0x572660, CRegisteredMotionBlurStreak *>(this);</p>
<p>0AA6: call_method 0x572660 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0</p>
<p>define function CRegisteredMotionBlurStreak__Render&lt;thiscall, 0x572660&gt;()</p>
<h4>CRegisteredMotionBlurStreak::CRegisteredMotionBlurStreak</h4>
<p>plugin::CallMethod<0x575150, CRegisteredMotionBlurStreak *>(this);</p>
<p>0AA6: call_method 0x575150 struct [CRegisteredMotionBlurStreak] num_params 0 pop 0</p>
<p>define function CRegisteredMotionBlurStreak__CRegisteredMotionBlurStreak&lt;thiscall, 0x575150&gt;()</p><h3 id="plugin_vcgame_vccrestartcpp">plugin_vc\game_vc\CRestart.cpp</h3><h4>CRestart::LoadAllRestartPoints</h4>
<p>plugin::Call<0x4421D0, unsigned char*, unsigned int>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4421D0 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CRestart__LoadAllRestartPoints&lt;cdecl, 0x4421D0&gt;(bufferPointer, structSize)</p>
<h4>CRestart::SaveAllRestartPoints</h4>
<p>plugin::Call<0x4425B0, unsigned char<em>, unsigned int</em>>(bufferPointer, structSize);</p>
<p>0AA5: call_function 0x4425B0 num_params 2 pop 2 [bufferPointer] [structSize]</p>
<p>define function CRestart__SaveAllRestartPoints&lt;cdecl, 0x4425B0&gt;(bufferPointer, structSize)</p>
<h4>CRestart::CancelOverrideRestart</h4>
<p>plugin::Call<0x4429D0>();</p>
<p>0AA5: call_function 0x4429D0 num_params 0 pop 0</p>
<p>define function CRestart__CancelOverrideRestart&lt;cdecl, 0x4429D0&gt;()</p>
<h4>CRestart::OverrideNextRestart</h4>
<p>plugin::Call<0x4429E0, CVector const&, float>(point, angle);</p>
<p>0AA5: call_function 0x4429E0 num_params 2 pop 2 [point] [angle]</p>
<p>define function CRestart__OverrideNextRestart&lt;cdecl, 0x4429E0&gt;(point, angle)</p>
<h4>CRestart::FindClosestPoliceRestartPoint</h4>
<p>plugin::Call<0x442A10, CVector const&, CVector<em>, float</em>>(point, storedPoint, storedAngle);</p>
<p>0AA5: call_function 0x442A10 num_params 3 pop 3 [point] [storedPoint] [storedAngle]</p>
<p>define function CRestart__FindClosestPoliceRestartPoint&lt;cdecl, 0x442A10&gt;(point, storedPoint, storedAngle)</p>
<h4>CRestart::FindClosestHospitalRestartPoint</h4>
<p>plugin::Call<0x442CD0, CVector const&, CVector<em>, float</em>>(point, storedPoint, storedAngle);</p>
<p>0AA5: call_function 0x442CD0 num_params 3 pop 3 [point] [storedPoint] [storedAngle]</p>
<p>define function CRestart__FindClosestHospitalRestartPoint&lt;cdecl, 0x442CD0&gt;(point, storedPoint, storedAngle)</p>
<h4>CRestart::AddPoliceRestartPoint</h4>
<p>plugin::Call<0x442FC0, CVector const&, float>(point, angle);</p>
<p>0AA5: call_function 0x442FC0 num_params 2 pop 2 [point] [angle]</p>
<p>define function CRestart__AddPoliceRestartPoint&lt;cdecl, 0x442FC0&gt;(point, angle)</p>
<h4>CRestart::AddHospitalRestartPoint</h4>
<p>plugin::Call<0x443010, CVector const&, float>(point, angle);</p>
<p>0AA5: call_function 0x443010 num_params 2 pop 2 [point] [angle]</p>
<p>define function CRestart__AddHospitalRestartPoint&lt;cdecl, 0x443010&gt;(point, angle)</p>
<h4>CRestart::Initialise</h4>
<p>plugin::Call<0x443060>();</p>
<p>0AA5: call_function 0x443060 num_params 0 pop 0</p>
<p>define function CRestart__Initialise&lt;cdecl, 0x443060&gt;()</p><h3 id="plugin_vcgame_vccroutenodecpp">plugin_vc\game_vc\CRouteNode.cpp</h3><h4>CRouteNode::AddRoutePoint</h4>
<p>plugin::CallDynGlobal<short, CVector>(gaddrof(CRouteNode::AddRoutePoint), route, pos);</p>
<h4>CRouteNode::GetRouteStart</h4>
<p>plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteStart), route);</p>
<p>0AA7: call_function_return 0x52FC80 num_params 1 pop 1 [route] func_ret [short]</p>
<p>define function CRouteNode__GetRouteStart&lt;cdecl, 0x52FC80&gt;(route): int</p>
<h4>CRouteNode::GetRouteThisPointIsOn</h4>
<p>plugin::CallAndReturnDynGlobal<short, short>(gaddrof(CRouteNode::GetRouteThisPointIsOn), point);</p>
<p>0AA7: call_function_return 0x52FC50 num_params 1 pop 1 [point] func_ret [short]</p>
<p>define function CRouteNode__GetRouteThisPointIsOn&lt;cdecl, 0x52FC50&gt;(point): int</p>
<h4>CRouteNode::RemoveRoute</h4>
<p>plugin::CallDynGlobal<short>(gaddrof(CRouteNode::RemoveRoute), route);</p><h3 id="plugin_vcgame_vccrubbishcpp">plugin_vc\game_vc\CRubbish.cpp</h3><h4>CRubbish::SetVisibility</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CRubbish::SetVisibility), bVisibility);</p>
<h4>CRubbish::StirUp</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CRubbish::StirUp), pVehicle);</p><h3 id="plugin_vcgame_vccrunningscriptcpp">plugin_vc\game_vc\CRunningScript.cpp</h3><h4>CRunningScript::Init</h4>
<p>plugin::CallMethod<0x450CF0, CRunningScript *>(this);</p>
<p>0AA6: call_method 0x450CF0 struct [CRunningScript] num_params 0 pop 0</p>
<p>define function CRunningScript__Init&lt;thiscall, 0x450CF0&gt;()</p>
<h4>CRunningScript::ProcessOneCommand</h4>
<p>plugin::CallMethodAndReturn<char, 0x44FBE0, CRunningScript *>(this);</p>
<p>0AA8: call_method_return 0x44FBE0 struct [CRunningScript] num_params 0 pop 0 func_ret [char]</p>
<p>define function CRunningScript__ProcessOneCommand&lt;thiscall, 0x44FBE0&gt;(): int</p>
<h4>CRunningScript::CollectParameters</h4>
<p>plugin::CallMethod<0x451010, CRunningScript <em>, int</em>, short>(this, arg0, count);</p>
<p>0AA6: call_method 0x451010 struct [CRunningScript] num_params 2 pop 0 [arg0] [count]</p>
<p>define function CRunningScript__CollectParameters&lt;thiscall, 0x451010&gt;(arg0, count)</p>
<h4>CRunningScript::UpdateCompareFlag</h4>
<p>plugin::CallMethod<0x463F00, CRunningScript *, unsigned char>(this, flag);</p>
<p>0AA6: call_method 0x463F00 struct [CRunningScript] num_params 1 pop 0 [flag]</p>
<p>define function CRunningScript__UpdateCompareFlag&lt;thiscall, 0x463F00&gt;(flag)</p><h3 id="plugin_vcgame_vccsamplemanagercpp">plugin_vc\game_vc\cSampleManager.cpp</h3><h4>cSampleManager::IsMP3RadioChannelAvailable</h4>
<p>plugin::CallAndReturn<bool, 0x5D80E0>();</p>
<p>0AA7: call_function_return 0x5D80E0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function cSampleManager__IsMP3RadioChannelAvailable&lt;cdecl, 0x5D80E0&gt;(): int</p><h3 id="plugin_vcgame_vccsceneeditcpp">plugin_vc\game_vc\CSceneEdit.cpp</h3><h4>CSceneEdit::SelectWeapon</h4>
<p>plugin::CallAndReturn<bool, 0x6032E0>();</p>
<p>0AA7: call_function_return 0x6032E0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectWeapon&lt;cdecl, 0x6032E0&gt;(): int</p>
<h4>CSceneEdit::SelectVehicle</h4>
<p>plugin::CallAndReturn<bool, 0x603520>();</p>
<p>0AA7: call_function_return 0x603520 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectVehicle&lt;cdecl, 0x603520&gt;(): int</p>
<h4>CSceneEdit::SelectActor2</h4>
<p>plugin::CallAndReturn<bool, 0x603700>();</p>
<p>0AA7: call_function_return 0x603700 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectActor2&lt;cdecl, 0x603700&gt;(): int</p>
<h4>CSceneEdit::SelectActor</h4>
<p>plugin::CallAndReturn<bool, 0x603980>();</p>
<p>0AA7: call_function_return 0x603980 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CSceneEdit__SelectActor&lt;cdecl, 0x603980&gt;(): int</p>
<h4>CSceneEdit::PlayBack</h4>
<p>plugin::Call<0x603C10>();</p>
<p>0AA5: call_function 0x603C10 num_params 0 pop 0</p>
<p>define function CSceneEdit__PlayBack&lt;cdecl, 0x603C10&gt;()</p>
<h4>CSceneEdit::ProcessCommand</h4>
<p>plugin::Call<0x604500>();</p>
<p>0AA5: call_function 0x604500 num_params 0 pop 0</p>
<p>define function CSceneEdit__ProcessCommand&lt;cdecl, 0x604500&gt;()</p>
<h4>CSceneEdit::Draw</h4>
<p>plugin::Call<0x605DB0>();</p>
<p>0AA5: call_function 0x605DB0 num_params 0 pop 0</p>
<p>define function CSceneEdit__Draw&lt;cdecl, 0x605DB0&gt;()</p>
<h4>CSceneEdit::Update</h4>
<p>plugin::Call<0x606270>();</p>
<p>0AA5: call_function 0x606270 num_params 0 pop 0</p>
<p>define function CSceneEdit__Update&lt;cdecl, 0x606270&gt;()</p>
<h4>CSceneEdit::ReInitialise</h4>
<p>plugin::Call<0x6062F0>();</p>
<p>0AA5: call_function 0x6062F0 num_params 0 pop 0</p>
<p>define function CSceneEdit__ReInitialise&lt;cdecl, 0x6062F0&gt;()</p>
<h4>CSceneEdit::InitPlayBack</h4>
<p>plugin::Call<0x606470>();</p>
<p>0AA5: call_function 0x606470 num_params 0 pop 0</p>
<p>define function CSceneEdit__InitPlayBack&lt;cdecl, 0x606470&gt;()</p>
<h4>CSceneEdit::Initialise</h4>
<p>plugin::Call<0x6065B0>();</p>
<p>0AA5: call_function 0x6065B0 num_params 0 pop 0</p>
<p>define function CSceneEdit__Initialise&lt;cdecl, 0x6065B0&gt;()</p><h3 id="plugin_vcgame_vccshadowcameracpp">plugin_vc\game_vc\CShadowCamera.cpp</h3><h4>*CShadowCamera::Create</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwCamera *, CShadowCamera *, int>(gaddrof(CShadowCamera::Create), this, rasterSize);</p>
<p>0AA8: call_method_return 0x626E70 struct [*CShadowCamera] num_params 1 pop 0 [rasterSize] func_ret [RwCamera *]</p>
<h4>CShadowCamera::Destroy</h4>
<p>plugin::CallMethodDynGlobal<CShadowCamera *>(gaddrof(CShadowCamera::Destroy), this);</p>
<p>0AA6: call_method 0x626DE0 struct [CShadowCamera] num_params 0 pop 0</p>
<p>define function CShadowCamera__Destroy&lt;thiscall, 0x626DE0&gt;()</p>
<h4>*CShadowCamera::DrawOutlineBorder</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRGBA const &>(gaddrof(CShadowCamera::DrawOutlineBorder), this, color);</p>
<p>0AA8: call_method_return 0x6264D0 struct [*CShadowCamera] num_params 1 pop 0 [color] func_ret [RwRaster *]</p>
<h4>CShadowCamera::InvertRaster</h4>
<p>plugin::CallMethodDynGlobal<CShadowCamera *>(gaddrof(CShadowCamera::InvertRaster), this);</p>
<p>0AA6: call_method 0x626BD0 struct [CShadowCamera] num_params 0 pop 0</p>
<p>define function CShadowCamera__InvertRaster&lt;thiscall, 0x626BD0&gt;()</p>
<h4>*CShadowCamera::MakeGradientRaster</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *>(gaddrof(CShadowCamera::MakeGradientRaster), this);</p>
<p>0AA8: call_method_return 0x6269F0 struct [*CShadowCamera] num_params 0 pop 0 func_ret [RwRaster *]</p>
<h4>*CShadowCamera::RasterBlur</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *, int>(gaddrof(CShadowCamera::RasterBlur), this, raster, numPasses);</p>
<p>0AA8: call_method_return 0x626780 struct [*CShadowCamera] num_params 2 pop 0 [raster] [numPasses] func_ret [RwRaster *]</p>
<h4>*CShadowCamera::RasterGradient</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *>(gaddrof(CShadowCamera::RasterGradient), this, raster);</p>
<p>0AA8: call_method_return 0x6266A0 struct [*CShadowCamera] num_params 1 pop 0 [raster] func_ret [RwRaster *]</p>
<h4>*CShadowCamera::RasterResample</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwRaster *, CShadowCamera *, RwRaster *>(gaddrof(CShadowCamera::RasterResample), this, raster);</p>
<p>0AA8: call_method_return 0x626900 struct [*CShadowCamera] num_params 1 pop 0 [raster] func_ret [RwRaster *]</p>
<h4>*CShadowCamera::Update</h4>
<p>plugin::CallMethodAndReturnDynGlobal<RwCamera *, CShadowCamera *, RpAtomic *>(gaddrof(CShadowCamera::Update), this, atomic);</p>
<p>0AA8: call_method_return 0x626D00 struct [*CShadowCamera] num_params 1 pop 0 [atomic] func_ret [RwCamera *]</p>
<h4>*ShadowRenderCallBack</h4>
<p>plugin::CallAndReturnDynGlobal<RpAtomic *, RpAtomic *, void *>(gaddrof(ShadowRenderCallBack), atomic, data);</p>
<p>0AA7: call_function_return 0x626DA0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic *]</p>
<p>define function ShadowRenderCallBack&lt;cdecl, 0x626DA0&gt;(atomic, data): int</p><h3 id="plugin_vcgame_vccshinytextscpp">plugin_vc\game_vc\CShinyTexts.cpp</h3><h4>CRegisteredShinyText::CRegisteredShinyText</h4>
<p>plugin::CallMethod<0x575130, CRegisteredShinyText *>(this);</p>
<p>0AA6: call_method 0x575130 struct [CRegisteredShinyText] num_params 0 pop 0</p>
<p>define function CRegisteredShinyText__CRegisteredShinyText&lt;thiscall, 0x575130&gt;()</p>
<h4>CShinyTexts::Render</h4>
<p>plugin::Call<0x571240>();</p>
<p>0AA5: call_function 0x571240 num_params 0 pop 0</p>
<p>define function CShinyTexts__Render&lt;cdecl, 0x571240&gt;()</p><h3 id="plugin_vcgame_vccshotinfocpp">plugin_vc\game_vc\CShotInfo.cpp</h3><h4>CShotInfo::Initialise</h4>
<p>plugin::Call<0x5C83B0>();</p>
<p>0AA5: call_function 0x5C83B0 num_params 0 pop 0</p>
<p>define function CShotInfo__Initialise&lt;cdecl, 0x5C83B0&gt;()</p>
<h4>CShotInfo::Shutdown</h4>
<p>plugin::Call<0x5C8390>();</p>
<p>0AA5: call_function 0x5C8390 num_params 0 pop 0</p>
<p>define function CShotInfo__Shutdown&lt;cdecl, 0x5C8390&gt;()</p>
<h4>CShotInfo::AddShot</h4>
<p>plugin::CallAndReturn<bool, 0x5C8110, CEntity*, eWeaponType, CVector, CVector>(creator, weaponType, origin, target);</p>
<p>0AA7: call_function_return 0x5C8110 num_params 4 pop 4 [creator] [weaponType] [origin] [target] func_ret [bool]</p>
<p>define function CShotInfo__AddShot&lt;cdecl, 0x5C8110&gt;(creator, weaponType, origin, target): int</p>
<h4>CShotInfo::Update</h4>
<p>plugin::Call<0x5C7E60>();</p>
<p>0AA5: call_function 0x5C7E60 num_params 0 pop 0</p>
<p>define function CShotInfo__Update&lt;cdecl, 0x5C7E60&gt;()</p><h3 id="plugin_vcgame_vccsimplemodelinfocpp">plugin_vc\game_vc\CSimpleModelInfo.cpp</h3><h4>CSimpleModelInfo::SetAtomic</h4>
<p>plugin::CallVirtualMethod<9, CSimpleModelInfo <em>, int, RpAtomic</em>>(this, atomicIndex, atomic);</p>
<h4>CSimpleModelInfo::GetAtomicFromDistance</h4>
<p>plugin::CallMethodAndReturn<RpAtomic*, 0x56F690, CSimpleModelInfo *, float>(this, distance);</p>
<p>0AA8: call_method_return 0x56F690 struct [CSimpleModelInfo] num_params 1 pop 0 [distance] func_ret [RpAtomic*]</p>
<p>define function CSimpleModelInfo__GetAtomicFromDistance&lt;thiscall, 0x56F690&gt;(distance): int</p>
<h4>CSimpleModelInfo::GetLargestLodDistance</h4>
<p>plugin::CallMethodAndReturn<float, 0x56F660, CSimpleModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x56F660 struct [CSimpleModelInfo] num_params 0 pop 0 func_ret [float]</p>
<p>define function CSimpleModelInfo__GetLargestLodDistance&lt;thiscall, 0x56F660&gt;(): float</p>
<h4>CSimpleModelInfo::GetLastAtomic</h4>
<p>plugin::CallMethodAndReturn<RpAtomic*, 0x56F620, CSimpleModelInfo *, float>(this, distance);</p>
<p>0AA8: call_method_return 0x56F620 struct [CSimpleModelInfo] num_params 1 pop 0 [distance] func_ret [RpAtomic*]</p>
<p>define function CSimpleModelInfo__GetLastAtomic&lt;thiscall, 0x56F620&gt;(distance): int</p>
<h4>CSimpleModelInfo::GetLodDistance</h4>
<p>plugin::CallMethodAndReturn<float, 0x56F6F0, CSimpleModelInfo *, int>(this, lodIndex);</p>
<p>0AA8: call_method_return 0x56F6F0 struct [CSimpleModelInfo] num_params 1 pop 0 [lodIndex] func_ret [float]</p>
<p>define function CSimpleModelInfo__GetLodDistance&lt;thiscall, 0x56F6F0&gt;(lodIndex): float</p>
<h4>CSimpleModelInfo::Init</h4>
<p>plugin::CallMethod<0x56F770, CSimpleModelInfo *>(this);</p>
<p>0AA6: call_method 0x56F770 struct [CSimpleModelInfo] num_params 0 pop 0</p>
<p>define function CSimpleModelInfo__Init&lt;thiscall, 0x56F770&gt;()</p>
<h4>CSimpleModelInfo::SetLodDistances</h4>
<p>plugin::CallMethod<0x56F600, CSimpleModelInfo <em>, float</em>>(this, distances);</p>
<p>0AA6: call_method 0x56F600 struct [CSimpleModelInfo] num_params 1 pop 0 [distances]</p>
<p>define function CSimpleModelInfo__SetLodDistances&lt;thiscall, 0x56F600&gt;(distances)</p>
<h4>CSimpleModelInfo::SetupBigBuilding</h4>
<p>plugin::CallMethod<0x56F420, CSimpleModelInfo *, int, int>(this, minLineIndex, maxLineIndex);</p>
<p>0AA6: call_method 0x56F420 struct [CSimpleModelInfo] num_params 2 pop 0 [minLineIndex] [maxLineIndex]</p>
<p>define function CSimpleModelInfo__SetupBigBuilding&lt;thiscall, 0x56F420&gt;(minLineIndex, maxLineIndex)</p>
<h4>SimpleModelStore::~SimpleModelStore</h4>
<p>plugin::CallMethod<0x5602A0, SimpleModelStore *>(this);</p>
<p>0AA6: call_method 0x5602A0 struct [SimpleModelStore] num_params 0 pop 0</p>
<p>define function SimpleModelStore__~SimpleModelStore&lt;thiscall, 0x5602A0&gt;()</p><h3 id="plugin_vcgame_vccspritecpp">plugin_vc\game_vc\CSprite.cpp</h3><h4>CSprite::CalcScreenCoors</h4>
<p>plugin::CallAndReturn<bool, 0x5778B0, RwV3d const&, RwV3d *, float *, float *, bool>(posn, out, w, h, checkMaxVisible);</p>
<p>0AA7: call_function_return 0x5778B0 num_params 5 pop 5 [posn] [out] [w] [h] [checkMaxVisible] func_ret [bool]</p>
<p>define function CSprite__CalcScreenCoors&lt;cdecl, 0x5778B0&gt;(posn, out, w, h, checkMaxVisible): int</p><h3 id="plugin_vcgame_vccstingercpp">plugin_vc\game_vc\CStinger.cpp</h3><h4>CStinger::CStinger</h4>
<p>plugin::CallMethod<0x629B50, CStinger *>(this);</p>
<p>0AA6: call_method 0x629B50 struct [CStinger] num_params 0 pop 0</p>
<p>define function CStinger__CStinger&lt;thiscall, 0x629B50&gt;()</p>
<h4>CStinger::Deploy</h4>
<p>plugin::CallMethod<0x628EF0, CStinger <em>, CPed</em>>(this, pPed);</p>
<p>0AA6: call_method 0x628EF0 struct [CStinger] num_params 1 pop 0 [pPed]</p>
<p>define function CStinger__Deploy&lt;thiscall, 0x628EF0&gt;(pPed)</p>
<h4>CStinger::CheckForBurstTyres</h4>
<p>plugin::CallMethod<0x628F70, CStinger *>(this);</p>
<p>0AA6: call_method 0x628F70 struct [CStinger] num_params 0 pop 0</p>
<p>define function CStinger__CheckForBurstTyres&lt;thiscall, 0x628F70&gt;()</p>
<h4>CStinger::Init</h4>
<p>plugin::CallMethod<0x6298D0, CStinger <em>, CPed</em>>(this, pPed);</p>
<p>0AA6: call_method 0x6298D0 struct [CStinger] num_params 1 pop 0 [pPed]</p>
<p>define function CStinger__Init&lt;thiscall, 0x6298D0&gt;(pPed)</p>
<h4>CStinger::Process</h4>
<p>plugin::CallMethod<0x629380, CStinger *>(this);</p>
<p>0AA6: call_method 0x629380 struct [CStinger] num_params 0 pop 0</p>
<p>define function CStinger__Process&lt;thiscall, 0x629380&gt;()</p>
<h4>CStinger::Remove</h4>
<p>plugin::CallMethod<0x629880, CStinger *>(this);</p>
<p>0AA6: call_method 0x629880 struct [CStinger] num_params 0 pop 0</p>
<p>define function CStinger__Remove&lt;thiscall, 0x629880&gt;()</p>
<h4>CStinger::~CStinger</h4>
<p>plugin::CallMethod<0x629B40, CStinger *>(this);</p>
<p>0AA6: call_method 0x629B40 struct [CStinger] num_params 0 pop 0</p>
<p>define function CStinger__~CStinger&lt;thiscall, 0x629B40&gt;()</p><h3 id="plugin_vcgame_vccstreamingcpp">plugin_vc\game_vc\CStreaming.cpp</h3><h4>CStreaming::AddModelsToRequestList</h4>
<p>plugin::CallDynGlobal<CVector const *, unsigned int>(gaddrof(CStreaming::AddModelsToRequestList), pos, streamingFlags);</p>
<h4>CStreaming::AddToLoadedVehiclesList</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AddToLoadedVehiclesList), modelIndex);</p>
<p>0AA7: call_function_return 0x408B40 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__AddToLoadedVehiclesList&lt;cdecl, 0x408B40&gt;(modelIndex): int</p>
<h4>CStreaming::AreAnimsUsedByRequestedModels</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::AreAnimsUsedByRequestedModels), animFileIndex);</p>
<p>0AA7: call_function_return 0x40C9C0 num_params 1 pop 1 [animFileIndex] func_ret [bool]</p>
<p>define function CStreaming__AreAnimsUsedByRequestedModels&lt;cdecl, 0x40C9C0&gt;(animFileIndex): int</p>
<h4>CStreaming::ConvertBufferToObject</h4>
<p>plugin::CallDynGlobal<char *, int>(gaddrof(CStreaming::ConvertBufferToObject), streamingBuffer, modelIndex);</p>
<h4>CStreaming::DeleteFarAwayRwObjects</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteFarAwayRwObjects), pos);</p>
<h4>CStreaming::DeleteRwObjectsAfterDeath</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::DeleteRwObjectsAfterDeath), pos);</p>
<h4>CStreaming::DeleteRwObjectsBehindCamera</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::DeleteRwObjectsBehindCamera), maxStreamingMemAllowed);</p>
<h4>CStreaming::DeleteRwObjectsBehindCameraInSectorList</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsBehindCameraInSectorList), ptrList, maxStreamingMemAllowed);</p>
<p>0AA7: call_function_return 0x40CBE0 num_params 2 pop 2 [ptrList] [maxStreamingMemAllowed] func_ret [bool]</p>
<p>define function CStreaming__DeleteRwObjectsBehindCameraInSectorList&lt;cdecl, 0x40CBE0&gt;(ptrList, maxStreamingMemAllowed): int</p>
<h4>CStreaming::DeleteRwObjectsInOverlapSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, int, int>(gaddrof(CStreaming::DeleteRwObjectsInOverlapSectorList), ptrlist, sectorX, sectorY);</p>
<h4>CStreaming::DeleteRwObjectsNotInFrustumInSectorList</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPtrList *, int>(gaddrof(CStreaming::DeleteRwObjectsNotInFrustumInSectorList), ptrList, maxStreamingMemAllowed);</p>
<p>0AA7: call_function_return 0x40CB50 num_params 2 pop 2 [ptrList] [maxStreamingMemAllowed] func_ret [bool]</p>
<p>define function CStreaming__DeleteRwObjectsNotInFrustumInSectorList&lt;cdecl, 0x40CB50&gt;(ptrList, maxStreamingMemAllowed): int</p>
<h4>CStreaming::FinishLoadingLargeFile</h4>
<p>plugin::CallDynGlobal<char *, int>(gaddrof(CStreaming::FinishLoadingLargeFile), streamingBuffer, modelID);</p>
<h4>CStreaming::GetCdImageOffset</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int, int>(gaddrof(CStreaming::GetCdImageOffset), CdPosn);</p>
<p>0AA7: call_function_return 0x40BC30 num_params 1 pop 1 [CdPosn] func_ret [unsigned int]</p>
<p>define function CStreaming__GetCdImageOffset&lt;cdecl, 0x40BC30&gt;(CdPosn): int</p>
<h4>CStreaming::GetNextFileOnCd</h4>
<p>plugin::CallAndReturnDynGlobal<int, int, bool>(gaddrof(CStreaming::GetNextFileOnCd), CdOffset, bOnlyPriorityRequests);</p>
<p>0AA7: call_function_return 0x40BCA0 num_params 2 pop 2 [CdOffset] [bOnlyPriorityRequests] func_ret [int]</p>
<p>define function CStreaming__GetNextFileOnCd&lt;cdecl, 0x40BCA0&gt;(CdOffset, bOnlyPriorityRequests): int</p>
<h4>CStreaming::HasSpecialCharLoaded</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::HasSpecialCharLoaded), SpecialSlotID);</p>
<p>0AA7: call_function_return 0x409A10 num_params 1 pop 1 [SpecialSlotID] func_ret [bool]</p>
<p>define function CStreaming__HasSpecialCharLoaded&lt;cdecl, 0x409A10&gt;(SpecialSlotID): int</p>
<h4>CStreaming::InstanceLoadedModels</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::InstanceLoadedModels), pos);</p>
<h4>CStreaming::IsObjectInCdImage</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsObjectInCdImage), modelIndex);</p>
<p>0AA7: call_function_return 0x40E4C0 num_params 1 pop 1 [modelIndex] func_ret [bool]</p>
<p>define function CStreaming__IsObjectInCdImage&lt;cdecl, 0x40E4C0&gt;(modelIndex): int</p>
<h4>CStreaming::IsTxdUsedByRequestedModels</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::IsTxdUsedByRequestedModels), txdIndex);</p>
<p>0AA7: call_function_return 0x40CA90 num_params 1 pop 1 [txdIndex] func_ret [bool]</p>
<p>define function CStreaming__IsTxdUsedByRequestedModels&lt;cdecl, 0x40CA90&gt;(txdIndex): int</p>
<h4>CStreaming::LoadAllRequestedModels</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CStreaming::LoadAllRequestedModels), bOnlyPriorityRequests);</p>
<h4>CStreaming::LoadCdDirectory</h4>
<p>plugin::CallDynGlobal<char const *, int>(gaddrof_o(CStreaming::LoadCdDirectory, void (*)(char const *, int)), fileName, id);</p>
<h4>CStreaming::LoadScene</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadScene), pos);</p>
<h4>CStreaming::LoadSceneCollision</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::LoadSceneCollision), pos);</p>
<h4>CStreaming::MakeSpaceFor</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::MakeSpaceFor), memoryToCleanSize);</p>
<h4>CStreaming::MemoryCardLoad</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int>(gaddrof(CStreaming::MemoryCardLoad), buffer, num);</p>
<h4>CStreaming::MemoryCardSave</h4>
<p>plugin::CallDynGlobal<unsigned char *, unsigned int *>(gaddrof(CStreaming::MemoryCardSave), text, num);</p>
<h4>CStreaming::ProcessEntitiesInSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, unsigned int)), a1, Streamingflags);</p>
<h4>CStreaming::ProcessEntitiesInSectorList</h4>
<p>plugin::CallDynGlobal<CPtrList *, float, float, float, float, float, float, unsigned int>(gaddrof_o(CStreaming::ProcessEntitiesInSectorList, void (*)(CPtrList *, float, float, float, float, float, float, unsigned int)), ptrList, X1, Y1, X2, Y2, X3, Y3, Streamingflags);</p>
<h4>CStreaming::ProcessLoadingChannel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::ProcessLoadingChannel), channelIndex);</p>
<p>0AA7: call_function_return 0x40BEB0 num_params 1 pop 1 [channelIndex] func_ret [bool]</p>
<p>define function CStreaming__ProcessLoadingChannel&lt;cdecl, 0x40BEB0&gt;(channelIndex): int</p>
<h4>CStreaming::RemoveBuildings</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveBuildings), levelID);</p>
<h4>CStreaming::RemoveBuildingsNotInArea</h4>
<p>plugin::CallAndReturnDynGlobal<char, int>(gaddrof(CStreaming::RemoveBuildingsNotInArea), LevelID);</p>
<p>0AA7: call_function_return 0x40DAA0 num_params 1 pop 1 [LevelID] func_ret [char]</p>
<p>define function CStreaming__RemoveBuildingsNotInArea&lt;cdecl, 0x40DAA0&gt;(LevelID): int</p>
<h4>CStreaming::RemoveIslandsNotUsed</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveIslandsNotUsed), levelID);</p>
<h4>CStreaming::RemoveLeastUsedModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool, int>(gaddrof(CStreaming::RemoveLeastUsedModel), streamingFlags);</p>
<p>0AA7: call_function_return 0x40D5A0 num_params 1 pop 1 [streamingFlags] func_ret [bool]</p>
<p>define function CStreaming__RemoveLeastUsedModel&lt;cdecl, 0x40D5A0&gt;(streamingFlags): int</p>
<h4>CStreaming::RemoveLoadedVehicle</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedVehicle));</p>
<p>0AA7: call_function_return 0x408AA0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__RemoveLoadedVehicle&lt;cdecl, 0x408AA0&gt;(): int</p>
<h4>CStreaming::RemoveLoadedZoneModel</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CStreaming::RemoveLoadedZoneModel));</p>
<p>0AA7: call_function_return 0x409A50 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CStreaming__RemoveLoadedZoneModel&lt;cdecl, 0x409A50&gt;(): int</p>
<h4>CStreaming::RemoveModel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveModel), modelIndex);</p>
<h4>CStreaming::RemoveUnusedBigBuildings</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveUnusedBigBuildings), LevelID);</p>
<h4>CStreaming::RemoveUnusedBuildings</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RemoveUnusedBuildings), levelID);</p>
<h4>CStreaming::RequestBigBuildings</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestBigBuildings), levelID);</p>
<h4>CStreaming::RequestModel</h4>
<p>plugin::CallDynGlobal<int, int>(gaddrof(CStreaming::RequestModel), modelIndex, Streamingflags);</p>
<h4>CStreaming::RequestModelStream</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RequestModelStream), ChannelID);</p>
<h4>CStreaming::RequestSpecialChar</h4>
<p>plugin::CallDynGlobal<int, char const *, int>(gaddrof(CStreaming::RequestSpecialChar), SpecialSlotID, Name, streamingFlags);</p>
<h4>CStreaming::RequestSpecialModel</h4>
<p>plugin::CallAndReturnDynGlobal<char, int, char *, int>(gaddrof(CStreaming::RequestSpecialModel), SpecialModelID, name, StreamingFlags);</p>
<p>0AA7: call_function_return 0x40AA60 num_params 3 pop 3 [SpecialModelID] [name] [StreamingFlags] func_ret [char]</p>
<p>define function CStreaming__RequestSpecialModel&lt;cdecl, 0x40AA60&gt;(SpecialModelID, name, StreamingFlags): int</p>
<h4>CStreaming::RetryLoadFile</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::RetryLoadFile), nChannel);</p>
<h4>CStreaming::SetMissionDoesntRequireModel</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireModel), modelIndex);</p>
<h4>CStreaming::SetMissionDoesntRequireSpecialChar</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetMissionDoesntRequireSpecialChar), SpecialSlotID);</p>
<h4>CStreaming::SetModelIsDeletable</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelIsDeletable), modelIndex);</p>
<h4>CStreaming::SetModelTxdIsDeletable</h4>
<p>plugin::CallDynGlobal<int>(gaddrof(CStreaming::SetModelTxdIsDeletable), modelIndex);</p>
<h4>CStreaming::StreamZoneModels</h4>
<p>plugin::CallDynGlobal<CVector const *>(gaddrof(CStreaming::StreamZoneModels), arg1);</p><h3 id="plugin_vcgame_vcctextcpp">plugin_vc\game_vc\CText.cpp</h3><h4>CText::Get</h4>
<p>plugin::CallMethodAndReturn<wchar_t<em>, 0x584F30, CText</em>, char const*>(this, key);</p>
<p>0AA8: call_method_return 0x584F30 struct [CText] num_params 1 pop 0 [key] func_ret [wchar_t*]</p>
<p>define function CText__Get&lt;thiscall, 0x584F30&gt;(key): int</p><h3 id="plugin_vcgame_vccthescriptscpp">plugin_vc\game_vc\CTheScripts.cpp</h3><h4>CTheScripts::ClearSpaceForMissionEntity</h4>
<p>plugin::Call<0x45F180, CVector const&, CEntity*>(position, entity);</p>
<p>0AA5: call_function 0x45F180 num_params 2 pop 2 [position] [entity]</p>
<p>define function CTheScripts__ClearSpaceForMissionEntity&lt;cdecl, 0x45F180&gt;(position, entity)</p>
<h4>CTheScripts::CleanUpThisObject</h4>
<p>plugin::CallDynGlobal<CObject *>(gaddrof(CTheScripts::CleanUpThisObject), pObject);</p>
<h4>CTheScripts::CleanUpThisPed</h4>
<p>plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::CleanUpThisPed), pPed);</p>
<h4>CTheScripts::CleanUpThisVehicle</h4>
<p>plugin::CallDynGlobal<CVehicle *>(gaddrof(CTheScripts::CleanUpThisVehicle), pVehicle);</p>
<h4>CTheScripts::IsPlayerOnAMission</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTheScripts::IsPlayerOnAMission));</p>
<p>0AA7: call_function_return 0x44FE30 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CTheScripts__IsPlayerOnAMission&lt;cdecl, 0x44FE30&gt;(): int</p>
<h4>CTheScripts::IsPlayerStopped</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CPlayerInfo *>(gaddrof(CTheScripts::IsPlayerStopped), pPlayerIfo);</p>
<p>0AA7: call_function_return 0x45ED50 num_params 1 pop 1 [pPlayerIfo] func_ret [bool]</p>
<p>define function CTheScripts__IsPlayerStopped&lt;cdecl, 0x45ED50&gt;(pPlayerIfo): int</p>
<h4>CTheScripts::IsVehicleStopped</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVehicle *>(gaddrof(CTheScripts::IsVehicleStopped), pPlayer);</p>
<p>0AA7: call_function_return 0x45ED20 num_params 1 pop 1 [pPlayer] func_ret [bool]</p>
<p>define function CTheScripts__IsVehicleStopped&lt;cdecl, 0x45ED20&gt;(pPlayer): int</p>
<h4>CTheScripts::RemoveThisPed</h4>
<p>plugin::CallDynGlobal<CPed *>(gaddrof(CTheScripts::RemoveThisPed), pPed);</p>
<h4>*CTheScripts::StartNewScript</h4>
<p>plugin::CallAndReturnDynGlobal<CRunningScript *, int>(gaddrof(CTheScripts::StartNewScript), addr);</p>
<p>0AA7: call_function_return 0x450270 num_params 1 pop 1 [addr] func_ret [CRunningScript *]</p>
<p>define function CTheScripts__StartNewScript&lt;cdecl, 0x450270&gt;(addr): int</p>
<h4>*CTheScripts::StartTestScript</h4>
<p>plugin::CallAndReturnDynGlobal<CRunningScript *>(gaddrof(CTheScripts::StartTestScript));</p>
<p>0AA7: call_function_return 0x44FE60 num_params 0 pop 0 func_ret [CRunningScript *]</p>
<p>define function CTheScripts__StartTestScript&lt;cdecl, 0x44FE60&gt;(): int</p><h3 id="plugin_vcgame_vccthezonescpp">plugin_vc\game_vc\CTheZones.cpp</h3><h4>CTheZones::CreateZone</h4>
<p>plugin::Call<0x4DDB80, char*, eZoneType, float, float, float, float, float, float, eLevelName>(name, type, posX1, posY1, posZ1, posX2, posY2, posZ2, island);</p>
<p>0AA5: call_function 0x4DDB80 num_params 9 pop 9 [name] [type] [posX1] [posY1] [posZ1] [posX2] [posY2] [posZ2] [island]</p>
<p>define function CTheZones__CreateZone&lt;cdecl, 0x4DDB80&gt;(name, type, posX1, posY1, posZ1, posX2, posY2, posZ2, island)</p>
<h4>CTheZones::FindAudioZone</h4>
<p>plugin::CallAndReturn<CZone<em>, 0x4DC370, CVector</em>>(point);</p>
<p>0AA7: call_function_return 0x4DC370 num_params 1 pop 1 [point] func_ret [CZone*]</p>
<p>define function CTheZones__FindAudioZone&lt;cdecl, 0x4DC370&gt;(point): int</p>
<h4>CTheZones::FindInformationZoneForPosition</h4>
<p>plugin::CallAndReturn<int, 0x4DD160, CVector const*>(pPoint);</p>
<p>0AA7: call_function_return 0x4DD160 num_params 1 pop 1 [pPoint] func_ret [int]</p>
<p>define function CTheZones__FindInformationZoneForPosition&lt;cdecl, 0x4DD160&gt;(pPoint): int</p>
<h4>CTheZones::FindNextZoneByLabelAndReturnIndex</h4>
<p>plugin::CallAndReturn<short, 0x4DD4A0, char*, eZoneType>(name, type);</p>
<p>0AA7: call_function_return 0x4DD4A0 num_params 2 pop 2 [name] [type] func_ret [short]</p>
<p>define function CTheZones__FindNextZoneByLabelAndReturnIndex&lt;cdecl, 0x4DD4A0&gt;(name, type): int</p>
<h4>CTheZones::FindSmallestNavigationZoneForPosition</h4>
<p>plugin::CallAndReturn<CZone<em>, 0x4DD060, CVector const</em>, bool, bool>(pPoint, findDef, findNavig);</p>
<p>0AA7: call_function_return 0x4DD060 num_params 3 pop 3 [pPoint] [findDef] [findNavig] func_ret [CZone*]</p>
<p>define function CTheZones__FindSmallestNavigationZoneForPosition&lt;cdecl, 0x4DD060&gt;(pPoint, findDef, findNavig): int</p>
<h4>CTheZones::FindZoneByLabelAndReturnIndex</h4>
<p>plugin::CallAndReturn<short, 0x4DD5F0, char*, eZoneType>(name, type);</p>
<p>0AA7: call_function_return 0x4DD5F0 num_params 2 pop 2 [name] [type] func_ret [short]</p>
<p>define function CTheZones__FindZoneByLabelAndReturnIndex&lt;cdecl, 0x4DD5F0&gt;(name, type): int</p>
<h4>CTheZones::GetNavigationZone</h4>
<p>plugin::CallAndReturn<int, 0x4DCC20, unsigned short>(arg0);</p>
<p>0AA7: call_function_return 0x4DCC20 num_params 1 pop 1 [arg0] func_ret [int]</p>
<p>define function CTheZones__GetNavigationZone&lt;cdecl, 0x4DCC20&gt;(arg0): int</p>
<h4>CTheZones::GetZoneInfo</h4>
<p>plugin::CallAndReturn<CZone<em>, 0x4DCEA0, CVector const</em>, unsigned char>(pPoint, arg1);</p>
<p>0AA7: call_function_return 0x4DCEA0 num_params 2 pop 2 [pPoint] [arg1] func_ret [CZone*]</p>
<p>define function CTheZones__GetZoneInfo&lt;cdecl, 0x4DCEA0&gt;(pPoint, arg1): int</p>
<h4>CTheZones::GetZoneInfoForTimeOfDay</h4>
<p>plugin::CallAndReturn<short, 0x4DC500, CVector const<em>, CZoneInfo</em>>(pPoint, zoneInfo);</p>
<p>0AA7: call_function_return 0x4DC500 num_params 2 pop 2 [pPoint] [zoneInfo] func_ret [short]</p>
<p>define function CTheZones__GetZoneInfoForTimeOfDay&lt;cdecl, 0x4DC500&gt;(pPoint, zoneInfo): int</p>
<h4>CTheZones::Init</h4>
<p>plugin::Call<0x4DDFA0>();</p>
<p>0AA5: call_function 0x4DDFA0 num_params 0 pop 0</p>
<p>define function CTheZones__Init&lt;cdecl, 0x4DDFA0&gt;()</p>
<h4>CTheZones::InitialiseAudioZoneArray</h4>
<p>plugin::Call<0x4DC430>();</p>
<p>0AA5: call_function 0x4DC430 num_params 0 pop 0</p>
<p>define function CTheZones__InitialiseAudioZoneArray&lt;cdecl, 0x4DC430&gt;()</p>
<h4>CTheZones::InsertZoneIntoZoneHierRecursive</h4>
<p>plugin::CallAndReturn<bool, 0x4DD9D0, CZone<em>, CZone</em>>(currentZona, otherZone);</p>
<p>0AA7: call_function_return 0x4DD9D0 num_params 2 pop 2 [currentZona] [otherZone] func_ret [bool]</p>
<p>define function CTheZones__InsertZoneIntoZoneHierRecursive&lt;cdecl, 0x4DD9D0&gt;(currentZona, otherZone): int</p>
<h4>CTheZones::LoadAllZones</h4>
<p>plugin::Call<0x4DBCB0, unsigned char*, unsigned int>(arg0, arg1);</p>
<p>0AA5: call_function 0x4DBCB0 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CTheZones__LoadAllZones&lt;cdecl, 0x4DBCB0&gt;(arg0, arg1)</p>
<h4>CTheZones::LoadOneZone</h4>
<p>plugin::Call<0x4DBB80, CZone<em>, unsigned char</em><em>, unsigned int</em>, eZoneType>(pZone, arg1, arg2, type);</p>
<p>0AA5: call_function 0x4DBB80 num_params 4 pop 4 [pZone] [arg1] [arg2] [type]</p>
<p>define function CTheZones__LoadOneZone&lt;cdecl, 0x4DBB80&gt;(pZone, arg1, arg2, type)</p>
<h4>CTheZones::PointLiesWithinZone</h4>
<p>plugin::CallAndReturn<bool, 0x4DD750, CVector const<em>, CZone</em>>(pPoint, pZone);</p>
<p>0AA7: call_function_return 0x4DD750 num_params 2 pop 2 [pPoint] [pZone] func_ret [bool]</p>
<p>define function CTheZones__PointLiesWithinZone&lt;cdecl, 0x4DD750&gt;(pPoint, pZone): int</p>
<h4>CTheZones::PostZoneCreation</h4>
<p>plugin::CallAndReturn<char, 0x4DDA90>();</p>
<p>0AA7: call_function_return 0x4DDA90 num_params 0 pop 0 func_ret [char]</p>
<p>define function CTheZones__PostZoneCreation&lt;cdecl, 0x4DDA90&gt;(): int</p>
<h4>CTheZones::SaveAllZones</h4>
<p>plugin::Call<0x4DC090, unsigned char<em>, unsigned int</em>>(arg0, arg1);</p>
<p>0AA5: call_function 0x4DC090 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CTheZones__SaveAllZones&lt;cdecl, 0x4DC090&gt;(arg0, arg1)</p>
<h4>CTheZones::SaveOneZone</h4>
<p>plugin::Call<0x4DBF30, CZone<em>, unsigned char</em><em>, unsigned int</em>, eZoneType>(pZone, arg1, arg2, type);</p>
<p>0AA5: call_function 0x4DBF30 num_params 4 pop 4 [pZone] [arg1] [arg2] [type]</p>
<p>define function CTheZones__SaveOneZone&lt;cdecl, 0x4DBF30&gt;(pZone, arg1, arg2, type)</p>
<h4>CTheZones::SetPedGroup</h4>
<p>plugin::Call<0x4DCC30, unsigned short, unsigned char, unsigned short>(arg0, arg1, arg2);</p>
<p>0AA5: call_function 0x4DCC30 num_params 3 pop 3 [arg0] [arg1] [arg2]</p>
<p>define function CTheZones__SetPedGroup&lt;cdecl, 0x4DCC30&gt;(arg0, arg1, arg2)</p>
<h4>CTheZones::SetZoneCarInfo</h4>
<p>plugin::Call<0x4DCDF0, int, unsigned char, short, short, short const*>(arg0, arg1, arg2, arg3, arg4);</p>
<p>0AA5: call_function 0x4DCDF0 num_params 5 pop 5 [arg0] [arg1] [arg2] [arg3] [arg4]</p>
<p>define function CTheZones__SetZoneCarInfo&lt;cdecl, 0x4DCDF0&gt;(arg0, arg1, arg2, arg3, arg4)</p>
<h4>CTheZones::SetZoneCivilianCarInfo</h4>
<p>plugin::Call<0x4DCD40, int, unsigned char, short const<em>, short const</em>>(arg0, arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x4DCD40 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CTheZones__SetZoneCivilianCarInfo&lt;cdecl, 0x4DCD40&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CTheZones::SetZonePedInfo</h4>
<p>plugin::Call<0x4DCC70, int, unsigned char, short, short, short, short, short, short, short, short, short, short, short>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);</p>
<p>0AA5: call_function 0x4DCC70 num_params 13 pop 13 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12]</p>
<p>define function CTheZones__SetZonePedInfo&lt;cdecl, 0x4DCC70&gt;(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)</p>
<h4>CTheZones::Update</h4>
<p>plugin::Call<0x4DDDF0>();</p>
<p>0AA5: call_function 0x4DDDF0 num_params 0 pop 0</p>
<p>define function CTheZones__Update&lt;cdecl, 0x4DDDF0&gt;()</p>
<h4>CTheZones::ZoneIsEntirelyContainedWithinOtherZone</h4>
<p>plugin::CallAndReturn<bool, 0x4DD7D0, CZone<em>, CZone</em>>(currentZona, otherZone);</p>
<p>0AA7: call_function_return 0x4DD7D0 num_params 2 pop 2 [currentZona] [otherZone] func_ret [bool]</p>
<p>define function CTheZones__ZoneIsEntirelyContainedWithinOtherZone&lt;cdecl, 0x4DD7D0&gt;(currentZona, otherZone): int</p><h3 id="plugin_vcgame_vcctimecyclecpp">plugin_vc\game_vc\CTimeCycle.cpp</h3><h4>CTimeCycle::StopExtraColour</h4>
<p>plugin::CallDynGlobal<bool>(gaddrof(CTimeCycle::StopExtraColour), arg1);</p><h3 id="plugin_vcgame_vcctimemodelinfocpp">plugin_vc\game_vc\CTimeModelInfo.cpp</h3><h4>CTimeModelInfo::FindOtherTimeModel</h4>
<p>plugin::CallMethod<0x56F330, CTimeModelInfo *>(this);</p>
<p>0AA6: call_method 0x56F330 struct [CTimeModelInfo] num_params 0 pop 0</p>
<p>define function CTimeModelInfo__FindOtherTimeModel&lt;thiscall, 0x56F330&gt;()</p>
<h4>TimeModelStore::~TimeModelStore</h4>
<p>plugin::CallMethod<0x560240, TimeModelStore *>(this);</p>
<p>0AA6: call_method 0x560240 struct [TimeModelStore] num_params 0 pop 0</p>
<p>define function TimeModelStore__~TimeModelStore&lt;thiscall, 0x560240&gt;()</p><h3 id="plugin_vcgame_vcctimercpp">plugin_vc\game_vc\CTimer.cpp</h3><h4>CTimer::GetCurrentTimeInCycles</h4>
<p>plugin::CallAndReturnDynGlobal<unsigned int>(gaddrof(CTimer::GetCurrentTimeInCycles));</p>
<p>0AA7: call_function_return 0x4D0DF0 num_params 0 pop 0 func_ret [unsigned int]</p>
<p>define function CTimer__GetCurrentTimeInCycles&lt;cdecl, 0x4D0DF0&gt;(): int</p>
<h4>CTimer::GetCyclesPerMillisecond</h4>
<p>plugin::CallAndReturnDynGlobal<int>(gaddrof(CTimer::GetCyclesPerMillisecond));</p>
<p>0AA7: call_function_return 0x4D0E30 num_params 0 pop 0 func_ret [int]</p>
<p>define function CTimer__GetCyclesPerMillisecond&lt;cdecl, 0x4D0E30&gt;(): int</p>
<h4>CTimer::GetIsSlowMotionActive</h4>
<p>plugin::CallAndReturnDynGlobal<bool>(gaddrof(CTimer::GetIsSlowMotionActive));</p>
<p>0AA7: call_function_return 0x4D0DC0 num_params 0 pop 0 func_ret [bool]</p>
<p>define function CTimer__GetIsSlowMotionActive&lt;cdecl, 0x4D0DC0&gt;(): int</p><h3 id="plugin_vcgame_vcctrafficlightscpp">plugin_vc\game_vc\CTrafficLights.cpp</h3><h4>CTrafficLights::DisplayActualLight</h4>
<p>plugin::CallDynGlobal<CEntity *>(gaddrof(CTrafficLights::DisplayActualLight), pEntity);</p>
<h4>CTrafficLights::ShouldCarStopForLight</h4>
<p>plugin::CallDynGlobal<CVehicle *, bool>(gaddrof(CTrafficLights::ShouldCarStopForLight), arg1, arg2);</p><h3 id="plugin_vcgame_vcctraincpp">plugin_vc\game_vc\CTrain.cpp</h3><h4>CTrain::AddPassenger</h4>
<p>plugin::CallMethod<0x5B2C60, CTrain <em>, CPed</em>>(this, ped);</p>
<p>0AA6: call_method 0x5B2C60 struct [CTrain] num_params 1 pop 0 [ped]</p>
<p>define function CTrain__AddPassenger&lt;thiscall, 0x5B2C60&gt;(ped)</p>
<h4>CTrain::CTrain</h4>
<p>plugin::CallMethod<0x5B2D00, CTrain *, int, unsigned char>(this, modelIndex, createdBy);</p>
<p>0AA6: call_method 0x5B2D00 struct [CTrain] num_params 2 pop 0 [modelIndex] [createdBy]</p>
<p>define function CTrain__CTrain&lt;thiscall, 0x5B2D00&gt;(modelIndex, createdBy)</p>
<h4>CTrain::InitTrains</h4>
<p>plugin::Call<0x5B2CA0>();</p>
<p>0AA5: call_function 0x5B2CA0 num_params 0 pop 0</p>
<p>define function CTrain__InitTrains&lt;cdecl, 0x5B2CA0&gt;()</p>
<h4>CTrain::Shutdown</h4>
<p>plugin::Call<0x5B2C90>();</p>
<p>0AA5: call_function 0x5B2C90 num_params 0 pop 0</p>
<p>define function CTrain__Shutdown&lt;cdecl, 0x5B2C90&gt;()</p>
<h4>CTrain::UpdateTrains</h4>
<p>plugin::Call<0x5B2C80>();</p>
<p>0AA5: call_function 0x5B2C80 num_params 0 pop 0</p>
<p>define function CTrain__UpdateTrains&lt;cdecl, 0x5B2C80&gt;()</p><h3 id="plugin_vcgame_vcctransmissioncpp">plugin_vc\game_vc\cTransmission.cpp</h3><h4>cTransmission::CalculateDriveAcceleration</h4>
<p>plugin::CallMethodAndReturn<float, 0x5B2E20, cTransmission *, float const&, unsigned char&, float&, float const&, bool>(this, gasPedal, currrentGear, arg2, arg3, arg4);</p>
<p>0AA8: call_method_return 0x5B2E20 struct [cTransmission] num_params 5 pop 0 [gasPedal] [currrentGear] [arg2] [arg3] [arg4] func_ret [float]</p>
<p>define function cTransmission__CalculateDriveAcceleration&lt;thiscall, 0x5B2E20&gt;(gasPedal, currrentGear, arg2, arg3, arg4): float</p>
<h4>cTransmission::CalculateGearForSimpleCar</h4>
<p>plugin::CallMethod<0x5B2DC0, cTransmission *, float, unsigned char&>(this, velocity, currrentGear);</p>
<p>0AA6: call_method 0x5B2DC0 struct [cTransmission] num_params 2 pop 0 [velocity] [currrentGear]</p>
<p>define function cTransmission__CalculateGearForSimpleCar&lt;thiscall, 0x5B2DC0&gt;(velocity, currrentGear)</p>
<h4>cTransmission::InitGearRatios</h4>
<p>plugin::CallMethod<0x5B3120, cTransmission *>(this);</p>
<p>0AA6: call_method 0x5B3120 struct [cTransmission] num_params 0 pop 0</p>
<p>define function cTransmission__InitGearRatios&lt;thiscall, 0x5B3120&gt;()</p>
<h4>cTransmission::cTransmission</h4>
<p>plugin::CallMethod<0x5B3240, cTransmission *>(this);</p>
<p>0AA6: call_method 0x5B3240 struct [cTransmission] num_params 0 pop 0</p>
<p>define function cTransmission__cTransmission&lt;thiscall, 0x5B3240&gt;()</p><h3 id="plugin_vcgame_vcctxdstorecpp">plugin_vc\game_vc\CTxdStore.cpp</h3><h4>CTxdStore::AddRef</h4>
<p>plugin::CallAndReturn<TxdDef*, 0x580A60, int>(index);</p>
<p>0AA7: call_function_return 0x580A60 num_params 1 pop 1 [index] func_ret [TxdDef*]</p>
<p>define function CTxdStore__AddRef&lt;cdecl, 0x580A60&gt;(index): int</p>
<h4>CTxdStore::AddTxdSlot</h4>
<p>plugin::CallAndReturn<int, 0x580F00, char const*>(name);</p>
<p>0AA7: call_function_return 0x580F00 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CTxdStore__AddTxdSlot&lt;cdecl, 0x580F00&gt;(name): int</p>
<h4>CTxdStore::Create</h4>
<p>plugin::Call<0x580B60, int>(index);</p>
<p>0AA5: call_function 0x580B60 num_params 1 pop 1 [index]</p>
<p>define function CTxdStore__Create&lt;cdecl, 0x580B60&gt;(index)</p>
<h4>CTxdStore::FindTxdSlot</h4>
<p>plugin::CallAndReturn<int, 0x580D70, char const*>(name);</p>
<p>0AA7: call_function_return 0x580D70 num_params 1 pop 1 [name] func_ret [int]</p>
<p>define function CTxdStore__FindTxdSlot&lt;cdecl, 0x580D70&gt;(name): int</p>
<h4>CTxdStore::FinishLoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x580BA0, int, RwStream*>(index, stream);</p>
<p>0AA7: call_function_return 0x580BA0 num_params 2 pop 2 [index] [stream] func_ret [bool]</p>
<p>define function CTxdStore__FinishLoadTxd&lt;cdecl, 0x580BA0&gt;(index, stream): int</p>
<h4>CTxdStore::GameShutdown</h4>
<p>plugin::Call<0x580F40>();</p>
<p>0AA5: call_function 0x580F40 num_params 0 pop 0</p>
<p>define function CTxdStore__GameShutdown&lt;cdecl, 0x580F40&gt;()</p>
<h4>CTxdStore::GetNumRefs</h4>
<p>plugin::CallAndReturn<int, 0x580990, int>(index);</p>
<p>0AA7: call_function_return 0x580990 num_params 1 pop 1 [index] func_ret [int]</p>
<p>define function CTxdStore__GetNumRefs&lt;cdecl, 0x580990&gt;(index): int</p>
<h4>CTxdStore::GetTxdName</h4>
<p>plugin::CallAndReturn<int, 0x580E50, int>(index);</p>
<p>0AA7: call_function_return 0x580E50 num_params 1 pop 1 [index] func_ret [int]</p>
<p>define function CTxdStore__GetTxdName&lt;cdecl, 0x580E50&gt;(index): int</p>
<h4>CTxdStore::LoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x580C60, int, RwStream*>(index, stream);</p>
<p>0AA7: call_function_return 0x580C60 num_params 2 pop 2 [index] [stream] func_ret [bool]</p>
<p>define function CTxdStore__LoadTxd&lt;cdecl, 0x580C60&gt;(index, stream): int</p>
<h4>CTxdStore::LoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x580CD0, int, char const*>(index, filename);</p>
<p>0AA7: call_function_return 0x580CD0 num_params 2 pop 2 [index] [filename] func_ret [bool]</p>
<p>define function CTxdStore__LoadTxd&lt;cdecl, 0x580CD0&gt;(index, filename): int</p>
<h4>CTxdStore::PopCurrentTxd</h4>
<p>plugin::Call<0x580AA0>();</p>
<p>0AA5: call_function 0x580AA0 num_params 0 pop 0</p>
<p>define function CTxdStore__PopCurrentTxd&lt;cdecl, 0x580AA0&gt;()</p>
<h4>CTxdStore::PushCurrentTxd</h4>
<p>plugin::Call<0x580AC0>();</p>
<p>0AA5: call_function 0x580AC0 num_params 0 pop 0</p>
<p>define function CTxdStore__PushCurrentTxd&lt;cdecl, 0x580AC0&gt;()</p>
<h4>CTxdStore::RemoveRef</h4>
<p>plugin::Call<0x580A10, int>(index);</p>
<p>0AA5: call_function 0x580A10 num_params 1 pop 1 [index]</p>
<p>define function CTxdStore__RemoveRef&lt;cdecl, 0x580A10&gt;(index)</p>
<h4>CTxdStore::RemoveRefWithoutDelete</h4>
<p>plugin::CallAndReturn<TxdDef*, 0x5809D0, int>(index);</p>
<p>0AA7: call_function_return 0x5809D0 num_params 1 pop 1 [index] func_ret [TxdDef*]</p>
<p>define function CTxdStore__RemoveRefWithoutDelete&lt;cdecl, 0x5809D0&gt;(index): int</p>
<h4>CTxdStore::RemoveTxd</h4>
<p>plugin::Call<0x580B10, int>(index);</p>
<p>0AA5: call_function 0x580B10 num_params 1 pop 1 [index]</p>
<p>define function CTxdStore__RemoveTxd&lt;cdecl, 0x580B10&gt;(index)</p>
<h4>CTxdStore::RemoveTxdSlot</h4>
<p>plugin::Call<0x580E90, int>(index);</p>
<p>0AA5: call_function 0x580E90 num_params 1 pop 1 [index]</p>
<p>define function CTxdStore__RemoveTxdSlot&lt;cdecl, 0x580E90&gt;(index)</p>
<h4>CTxdStore::SetCurrentTxd</h4>
<p>plugin::Call<0x580AD0, int>(index);</p>
<p>0AA5: call_function 0x580AD0 num_params 1 pop 1 [index]</p>
<p>define function CTxdStore__SetCurrentTxd&lt;cdecl, 0x580AD0&gt;(index)</p>
<h4>CTxdStore::Shutdown</h4>
<p>plugin::Call<0x580FF0>();</p>
<p>0AA5: call_function 0x580FF0 num_params 0 pop 0</p>
<p>define function CTxdStore__Shutdown&lt;cdecl, 0x580FF0&gt;()</p>
<h4>CTxdStore::StartLoadTxd</h4>
<p>plugin::CallAndReturn<bool, 0x580BF0, int, RwStream*>(index, stream);</p>
<p>0AA7: call_function_return 0x580BF0 num_params 2 pop 2 [index] [stream] func_ret [bool]</p>
<p>define function CTxdStore__StartLoadTxd&lt;cdecl, 0x580BF0&gt;(index, stream): int</p>
<h4>CTxdStore::Initialise</h4>
<p>plugin::Call<0x581010>();</p>
<p>0AA5: call_function 0x581010 num_params 0 pop 0</p>
<p>define function CTxdStore__Initialise&lt;cdecl, 0x581010&gt;()</p><h3 id="plugin_vcgame_vccuserdisplaycpp">plugin_vc\game_vc\CUserDisplay.cpp</h3><h4>CUserDisplay::Init</h4>
<p>plugin::Call<0x4D1490>();</p>
<p>0AA5: call_function 0x4D1490 num_params 0 pop 0</p>
<p>define function CUserDisplay__Init&lt;cdecl, 0x4D1490&gt;()</p>
<h4>CUserDisplay::Process</h4>
<p>plugin::Call<0x4D1400>();</p>
<p>0AA5: call_function 0x4D1400 num_params 0 pop 0</p>
<p>define function CUserDisplay__Process&lt;cdecl, 0x4D1400&gt;()</p><h3 id="plugin_vcgame_vccvehiclecpp">plugin_vc\game_vc\CVehicle.cpp</h3><h4>CVehicle::ProcessControlInputs</h4>
<p>plugin::CallVirtualMethod<18, CVehicle *, unsigned char>(this, playerNum);</p>
<h4>CVehicle::GetComponentWorldPosition</h4>
<p>plugin::CallVirtualMethod<19, CVehicle *, int, CVector&>(this, componentId, posnOut);</p>
<h4>CVehicle::IsComponentPresent</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 20, CVehicle *, int>(this, componentId);</p>
<h4>CVehicle::SetComponentRotation</h4>
<p>plugin::CallVirtualMethod<21, CVehicle *, int, CVector>(this, componentId, arg1);</p>
<h4>CVehicle::OpenDoor</h4>
<p>plugin::CallVirtualMethod<22, CVehicle *, int, eDoors, float>(this, componentId, door, doorOpenRatio);</p>
<h4>CVehicle::ProcessOpenDoor</h4>
<p>plugin::CallVirtualMethod<23, CVehicle *, unsigned int, unsigned int, float>(this, arg0, arg1, arg2);</p>
<h4>CVehicle::IsDoorReady</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 24, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorFullyOpen</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 25, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorClosed</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 26, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorMissing</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 27, CVehicle *, eDoors>(this, door);</p>
<h4>CVehicle::IsDoorReady</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 28, CVehicle *, unsigned int>(this, door);</p>
<h4>CVehicle::IsDoorMissing</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 29, CVehicle *, unsigned int>(this, door);</p>
<h4>CVehicle::IsOpenTopCar</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 30, CVehicle *>(this);</p>
<h4>CVehicle::RemoveRefsToVehicle</h4>
<p>plugin::CallVirtualMethod<31, CVehicle <em>, CEntity</em>>(this, entity);</p>
<h4>CVehicle::BlowUpCar</h4>
<p>plugin::CallVirtualMethod<32, CVehicle <em>, CEntity</em>>(this, damager);</p>
<h4>CVehicle::SetUpWheelColModel</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 33, CVehicle <em>, CColModel</em>>(this, wheelCol);</p>
<h4>CVehicle::BurstTyre</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 34, CVehicle *, unsigned char, bool>(this, tyreComponentId, bPhysicalEffect);</p>
<h4>CVehicle::IsRoomForPedToLeaveCar</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 35, CVehicle <em>, unsigned int, CVector</em>>(this, arg0, arg1);</p>
<h4>CVehicle::IsClearToDriveAway</h4>
<p>plugin::CallVirtualMethodAndReturn<bool, 36, CVehicle *>(this);</p>
<h4>CVehicle::GetHeightAboveRoad</h4>
<p>plugin::CallVirtualMethodAndReturn<float, 37, CVehicle *>(this);</p>
<h4>CVehicle::PlayCarHorn</h4>
<p>plugin::CallVirtualMethod<38, CVehicle *>(this);</p>
<h4>CVehicle::ActivateBomb</h4>
<p>plugin::CallMethod<0x5B79E0, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B79E0 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ActivateBomb&lt;thiscall, 0x5B79E0&gt;()</p>
<h4>CVehicle::ActivateBombWhenEntered</h4>
<p>plugin::CallMethod<0x5B7950, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B7950 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ActivateBombWhenEntered&lt;thiscall, 0x5B7950&gt;()</p>
<h4>CVehicle::AddPassenger</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8E60, CVehicle <em>, CPed</em>>(this, passenger);</p>
<p>0AA8: call_method_return 0x5B8E60 struct [CVehicle] num_params 1 pop 0 [passenger] func_ret [bool]</p>
<p>define function CVehicle__AddPassenger&lt;thiscall, 0x5B8E60&gt;(passenger): int</p>
<h4>CVehicle::AddPassenger</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8D50, CVehicle <em>, CPed</em>, unsigned char>(this, passenger, seatNumber);</p>
<p>0AA8: call_method_return 0x5B8D50 struct [CVehicle] num_params 2 pop 0 [passenger] [seatNumber] func_ret [bool]</p>
<p>define function CVehicle__AddPassenger&lt;thiscall, 0x5B8D50&gt;(passenger, seatNumber): int</p>
<h4>CVehicle::BladeColSectorList</h4>
<p>plugin::CallMethod<0x5B4610, CVehicle *, CPtrList&, CColModel&, CMatrix&, short, float>(this, ptrList, colModel, matrix, arg3, arg4);</p>
<p>0AA6: call_method 0x5B4610 struct [CVehicle] num_params 5 pop 0 [ptrList] [colModel] [matrix] [arg3] [arg4]</p>
<p>define function CVehicle__BladeColSectorList&lt;thiscall, 0x5B4610&gt;(ptrList, colModel, matrix, arg3, arg4)</p>
<h4>CVehicle::CanBeDeleted</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5BA960, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5BA960 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__CanBeDeleted&lt;thiscall, 0x5BA960&gt;(): int</p>
<h4>CVehicle::CanDoorsBeDamaged</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8440, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B8440 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__CanDoorsBeDamaged&lt;thiscall, 0x5B8440&gt;(): int</p>
<h4>CVehicle::CanPedEnterCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8370, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B8370 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__CanPedEnterCar&lt;thiscall, 0x5B8370&gt;(): int</p>
<h4>CVehicle::CanPedExitCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8180, CVehicle *, bool>(this, arg0);</p>
<p>0AA8: call_method_return 0x5B8180 struct [CVehicle] num_params 1 pop 0 [arg0] func_ret [bool]</p>
<p>define function CVehicle__CanPedExitCar&lt;thiscall, 0x5B8180&gt;(arg0): int</p>
<h4>CVehicle::CanPedJumpOffBike</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8130, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B8130 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__CanPedJumpOffBike&lt;thiscall, 0x5B8130&gt;(): int</p>
<h4>CVehicle::CanPedJumpOutCar</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B80C0, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B80C0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__CanPedJumpOutCar&lt;thiscall, 0x5B80C0&gt;(): int</p>
<h4>CVehicle::CanPedOpenLocks</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8460, CVehicle <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x5B8460 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CVehicle__CanPedOpenLocks&lt;thiscall, 0x5B8460&gt;(ped): int</p>
<h4>CVehicle::CarHasRoof</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B7910, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B7910 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__CarHasRoof&lt;thiscall, 0x5B7910&gt;(): int</p>
<h4>CVehicle::ChangeLawEnforcerState</h4>
<p>plugin::CallMethod<0x5B7D90, CVehicle *, unsigned char>(this, state);</p>
<p>0AA6: call_method 0x5B7D90 struct [CVehicle] num_params 1 pop 0 [state]</p>
<p>define function CVehicle__ChangeLawEnforcerState&lt;thiscall, 0x5B7D90&gt;(state)</p>
<h4>CVehicle::DoBladeCollision</h4>
<p>plugin::CallMethod<0x5B5030, CVehicle *, CVector, CMatrix&, short, float, float>(this, arg0, matrix, arg2, arg3, arg4);</p>
<p>0AA6: call_method 0x5B5030 struct [CVehicle] num_params 5 pop 0 [arg0] [matrix] [arg2] [arg3] [arg4]</p>
<p>define function CVehicle__DoBladeCollision&lt;thiscall, 0x5B5030&gt;(arg0, matrix, arg2, arg3, arg4)</p>
<h4>CVehicle::DoFixedMachineGuns</h4>
<p>plugin::CallMethod<0x5C9170, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5C9170 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__DoFixedMachineGuns&lt;thiscall, 0x5C9170&gt;()</p>
<h4>CVehicle::DoSunGlare</h4>
<p>plugin::CallMethod<0x5B3CD0, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B3CD0 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__DoSunGlare&lt;thiscall, 0x5B3CD0&gt;()</p>
<h4>CVehicle::ExtinguishCarFire</h4>
<p>plugin::CallMethod<0x5B7A80, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B7A80 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ExtinguishCarFire&lt;thiscall, 0x5B7A80&gt;()</p>
<h4>CVehicle::FindTyreNearestPoint</h4>
<p>plugin::CallMethodAndReturn<int, 0x5B96A0, CVehicle *, float, float>(this, x, y);</p>
<p>0AA8: call_method_return 0x5B96A0 struct [CVehicle] num_params 2 pop 0 [x] [y] func_ret [int]</p>
<p>define function CVehicle__FindTyreNearestPoint&lt;thiscall, 0x5B96A0&gt;(x, y): int</p>
<h4>CVehicle::FireFixedMachineGuns</h4>
<p>plugin::CallMethod<0x5C8E40, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5C8E40 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__FireFixedMachineGuns&lt;thiscall, 0x5C8E40&gt;()</p>
<h4>CVehicle::FlyingControl</h4>
<p>plugin::CallMethod<0x5B54C0, CVehicle *, eFlightModel>(this, flightModel);</p>
<p>0AA6: call_method 0x5B54C0 struct [CVehicle] num_params 1 pop 0 [flightModel]</p>
<p>define function CVehicle__FlyingControl&lt;thiscall, 0x5B54C0&gt;(flightModel)</p>
<h4>CVehicle::GetVehicleAppearance</h4>
<p>plugin::CallMethodAndReturn<int, 0x5BAA80, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5BAA80 struct [CVehicle] num_params 0 pop 0 func_ret [int]</p>
<p>define function CVehicle__GetVehicleAppearance&lt;thiscall, 0x5BAA80&gt;(): int</p>
<h4>CVehicle::HeliDustGenerate</h4>
<p>plugin::Call<0x5B3250, CEntity*, float, float, int>(arg0, arg1, arg2, arg3);</p>
<p>0AA5: call_function 0x5B3250 num_params 4 pop 4 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CVehicle__HeliDustGenerate&lt;cdecl, 0x5B3250&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CVehicle::InflictDamage</h4>
<p>plugin::CallMethod<0x5B9020, CVehicle <em>, CEntity</em>, eWeaponType, float, CVector>(this, damager, weapon, intensity, coords);</p>
<p>0AA6: call_method 0x5B9020 struct [CVehicle] num_params 4 pop 0 [damager] [weapon] [intensity] [coords]</p>
<p>define function CVehicle__InflictDamage&lt;thiscall, 0x5B9020&gt;(damager, weapon, intensity, coords)</p>
<h4>CVehicle::IsDriver</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8670, CVehicle <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x5B8670 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CVehicle__IsDriver&lt;thiscall, 0x5B8670&gt;(ped): int</p>
<h4>CVehicle::IsDriver</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8640, CVehicle *, int>(this, modelIndex);</p>
<p>0AA8: call_method_return 0x5B8640 struct [CVehicle] num_params 1 pop 0 [modelIndex] func_ret [bool]</p>
<p>define function CVehicle__IsDriver&lt;thiscall, 0x5B8640&gt;(modelIndex): int</p>
<h4>CVehicle::IsLawEnforcementVehicle</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B7D60, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B7D60 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__IsLawEnforcementVehicle&lt;thiscall, 0x5B7D60&gt;(): int</p>
<h4>CVehicle::IsOnItsSide</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B84B0, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B84B0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__IsOnItsSide&lt;thiscall, 0x5B84B0&gt;(): int</p>
<h4>CVehicle::IsPassenger</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B86D0, CVehicle <em>, CPed</em>>(this, ped);</p>
<p>0AA8: call_method_return 0x5B86D0 struct [CVehicle] num_params 1 pop 0 [ped] func_ret [bool]</p>
<p>define function CVehicle__IsPassenger&lt;thiscall, 0x5B86D0&gt;(ped): int</p>
<h4>CVehicle::IsPassenger</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B86A0, CVehicle *, int>(this, modelIndex);</p>
<p>0AA8: call_method_return 0x5B86A0 struct [CVehicle] num_params 1 pop 0 [modelIndex] func_ret [bool]</p>
<p>define function CVehicle__IsPassenger&lt;thiscall, 0x5B86A0&gt;(modelIndex): int</p>
<h4>CVehicle::IsSphereTouchingVehicle</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B7F00, CVehicle *, float, float, float, float>(this, x, y, z, radius);</p>
<p>0AA8: call_method_return 0x5B7F00 struct [CVehicle] num_params 4 pop 0 [x] [y] [z] [radius] func_ret [bool]</p>
<p>define function CVehicle__IsSphereTouchingVehicle&lt;thiscall, 0x5B7F00&gt;(x, y, z, radius): int</p>
<h4>CVehicle::IsUpsideDown</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B84F0, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B84F0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__IsUpsideDown&lt;thiscall, 0x5B84F0&gt;(): int</p>
<h4>CVehicle::IsVehicleNormal</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B7DF0, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B7DF0 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__IsVehicleNormal&lt;thiscall, 0x5B7DF0&gt;(): int</p>
<h4>CVehicle::KillPedsInVehicle</h4>
<p>plugin::CallMethod<0x5B8560, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B8560 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__KillPedsInVehicle&lt;thiscall, 0x5B8560&gt;()</p>
<h4>CVehicle::MakeNonDraggedPedsLeaveVehicle</h4>
<p>plugin::CallMethod<0x5B3A30, CVehicle <em>, CPed</em>, CPed<em>, CPlayerPed</em>&, CCopPed*&>(this, arg0, arg1, arg2, arg3);</p>
<p>0AA6: call_method 0x5B3A30 struct [CVehicle] num_params 4 pop 0 [arg0] [arg1] [arg2] [arg3]</p>
<p>define function CVehicle__MakeNonDraggedPedsLeaveVehicle&lt;thiscall, 0x5B3A30&gt;(arg0, arg1, arg2, arg3)</p>
<h4>CVehicle::ProcessBikeWheel</h4>
<p>plugin::CallMethod<0x5B9770, CVehicle <em>, CVector&, CVector&, CVector&, CVector&, int, float, float, float, float, char, float</em>, tWheelState*, eBikeWheelSpecial, unsigned short>(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);</p>
<p>0AA6: call_method 0x5B9770 struct [CVehicle] num_params 14 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11] [arg12] [arg13]</p>
<p>define function CVehicle__ProcessBikeWheel&lt;thiscall, 0x5B9770&gt;(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)</p>
<h4>CVehicle::ProcessCarAlarm</h4>
<p>plugin::CallMethod<0x5B8040, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B8040 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ProcessCarAlarm&lt;thiscall, 0x5B8040&gt;()</p>
<h4>CVehicle::ProcessDelayedExplosion</h4>
<p>plugin::CallMethod<0x5B8F50, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B8F50 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__ProcessDelayedExplosion&lt;thiscall, 0x5B8F50&gt;()</p>
<h4>CVehicle::ProcessWheel</h4>
<p>plugin::CallMethod<0x5BA070, CVehicle <em>, CVector&, CVector&, CVector&, CVector&, int, float, float, float, char, float</em>, tWheelState*, unsigned short>(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);</p>
<p>0AA6: call_method 0x5BA070 struct [CVehicle] num_params 12 pop 0 [arg0] [arg1] [arg2] [arg3] [arg4] [arg5] [arg6] [arg7] [arg8] [arg9] [arg10] [arg11]</p>
<p>define function CVehicle__ProcessWheel&lt;thiscall, 0x5BA070&gt;(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)</p>
<h4>CVehicle::ProcessWheelRotation</h4>
<p>plugin::CallMethodAndReturn<float, 0x5BA900, CVehicle *, tWheelState, CVector const&, CVector const&, float>(this, wheelState, arg1, arg2, arg3);</p>
<p>0AA8: call_method_return 0x5BA900 struct [CVehicle] num_params 4 pop 0 [wheelState] [arg1] [arg2] [arg3] func_ret [float]</p>
<p>define function CVehicle__ProcessWheelRotation&lt;thiscall, 0x5BA900&gt;(wheelState, arg1, arg2, arg3): float</p>
<h4>CVehicle::RemoveDriver</h4>
<p>plugin::CallMethod<0x5B8920, CVehicle *, bool>(this, arg0);</p>
<p>0AA6: call_method 0x5B8920 struct [CVehicle] num_params 1 pop 0 [arg0]</p>
<p>define function CVehicle__RemoveDriver&lt;thiscall, 0x5B8920&gt;(arg0)</p>
<h4>CVehicle::RemovePassenger</h4>
<p>plugin::CallMethod<0x5B8CE0, CVehicle <em>, CPed</em>>(this, passenger);</p>
<p>0AA6: call_method 0x5B8CE0 struct [CVehicle] num_params 1 pop 0 [passenger]</p>
<p>define function CVehicle__RemovePassenger&lt;thiscall, 0x5B8CE0&gt;(passenger)</p>
<h4>CVehicle::SetComponentAtomicAlpha</h4>
<p>plugin::CallMethod<0x5B45D0, CVehicle <em>, RpAtomic</em>, int>(this, atomic, alpha);</p>
<p>0AA6: call_method 0x5B45D0 struct [CVehicle] num_params 2 pop 0 [atomic] [alpha]</p>
<p>define function CVehicle__SetComponentAtomicAlpha&lt;thiscall, 0x5B45D0&gt;(atomic, alpha)</p>
<h4>CVehicle::SetDriver</h4>
<p>plugin::CallMethod<0x5B89F0, CVehicle <em>, CPed</em>>(this, driver);</p>
<p>0AA6: call_method 0x5B89F0 struct [CVehicle] num_params 1 pop 0 [driver]</p>
<p>define function CVehicle__SetDriver&lt;thiscall, 0x5B89F0&gt;(driver)</p>
<h4>CVehicle::SetUpDriver</h4>
<p>plugin::CallMethodAndReturn<CPed*, 0x5B8870, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B8870 struct [CVehicle] num_params 0 pop 0 func_ret [CPed*]</p>
<p>define function CVehicle__SetUpDriver&lt;thiscall, 0x5B8870&gt;(): int</p>
<h4>CVehicle::SetupPassenger</h4>
<p>plugin::CallMethodAndReturn<CPed*, 0x5B8700, CVehicle *, int>(this, arg0);</p>
<p>0AA8: call_method_return 0x5B8700 struct [CVehicle] num_params 1 pop 0 [arg0] func_ret [CPed*]</p>
<p>define function CVehicle__SetupPassenger&lt;thiscall, 0x5B8700&gt;(arg0): int</p>
<h4>CVehicle::ShufflePassengersToMakeSpace</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B7B10, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B7B10 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__ShufflePassengersToMakeSpace&lt;thiscall, 0x5B7B10&gt;(): int</p>
<h4>CVehicle::UpdateClumpAlpha</h4>
<p>plugin::CallMethod<0x5B4580, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B4580 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__UpdateClumpAlpha&lt;thiscall, 0x5B4580&gt;()</p>
<h4>CVehicle::UpdatePassengerList</h4>
<p>plugin::CallMethod<0x5B39F0, CVehicle *>(this);</p>
<p>0AA6: call_method 0x5B39F0 struct [CVehicle] num_params 0 pop 0</p>
<p>define function CVehicle__UpdatePassengerList&lt;thiscall, 0x5B39F0&gt;()</p>
<h4>CVehicle::UsesSiren</h4>
<p>plugin::CallMethodAndReturn<bool, 0x5B8520, CVehicle *>(this);</p>
<p>0AA8: call_method_return 0x5B8520 struct [CVehicle] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CVehicle__UsesSiren&lt;thiscall, 0x5B8520&gt;(): int</p><h3 id="plugin_vcgame_vccvehiclemodelinfocpp">plugin_vc\game_vc\CVehicleModelInfo.cpp</h3><h4>CVehicleModelInfo::AvoidSameVehicleColour</h4>
<p>plugin::CallMethod<0x579090, CVehicleModelInfo <em>, unsigned char</em>, unsigned char*>(this, prim, sec);</p>
<p>0AA6: call_method 0x579090 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]</p>
<p>define function CVehicleModelInfo__AvoidSameVehicleColour&lt;thiscall, 0x579090&gt;(prim, sec)</p>
<h4>CVehicleModelInfo::ChooseComponent</h4>
<p>plugin::CallMethodAndReturn<int, 0x579670, CVehicleModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x579670 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]</p>
<p>define function CVehicleModelInfo__ChooseComponent&lt;thiscall, 0x579670&gt;(): int</p>
<h4>CVehicleModelInfo::ChooseSecondComponent</h4>
<p>plugin::CallMethodAndReturn<int, 0x5794F0, CVehicleModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x5794F0 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]</p>
<p>define function CVehicleModelInfo__ChooseSecondComponent&lt;thiscall, 0x5794F0&gt;(): int</p>
<h4>CVehicleModelInfo::ChooseVehicleColour</h4>
<p>plugin::CallMethod<0x579190, CVehicleModelInfo *, unsigned char&, unsigned char&>(this, prim, sec);</p>
<p>0AA6: call_method 0x579190 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]</p>
<p>define function CVehicleModelInfo__ChooseVehicleColour&lt;thiscall, 0x579190&gt;(prim, sec)</p>
<h4>CVehicleModelInfo::ClearAtomicFlagCB</h4>
<p>plugin::CallAndReturn<RwObject<em>, 0x579FD0, RwObject</em>, void*>(object, data);</p>
<p>0AA7: call_function_return 0x579FD0 num_params 2 pop 2 [object] [data] func_ret [RwObject*]</p>
<p>define function CVehicleModelInfo__ClearAtomicFlagCB&lt;cdecl, 0x579FD0&gt;(object, data): int</p>
<h4>CVehicleModelInfo::CollapseFramesCB</h4>
<p>plugin::CallAndReturn<RwFrame<em>, 0x57A660, RwFrame</em>, void*>(frame, data);</p>
<p>0AA7: call_function_return 0x57A660 num_params 2 pop 2 [frame] [data] func_ret [RwFrame*]</p>
<p>define function CVehicleModelInfo__CollapseFramesCB&lt;cdecl, 0x57A660&gt;(frame, data): int</p>
<h4>CVehicleModelInfo::DeleteVehicleColourTextures</h4>
<p>plugin::Call<0x578C90>();</p>
<p>0AA5: call_function 0x578C90 num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__DeleteVehicleColourTextures&lt;cdecl, 0x578C90&gt;()</p>
<h4>CVehicleModelInfo::FindEditableMaterialList</h4>
<p>plugin::CallMethodAndReturn<int, 0x579390, CVehicleModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x579390 struct [CVehicleModelInfo] num_params 0 pop 0 func_ret [int]</p>
<p>define function CVehicleModelInfo__FindEditableMaterialList&lt;thiscall, 0x579390&gt;(): int</p>
<h4>CVehicleModelInfo::GetEditableMaterialListCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x579440, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x579440 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__GetEditableMaterialListCB&lt;cdecl, 0x579440&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::GetEditableMaterialListCB</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x579460, RpMaterial</em>, void*>(material, data);</p>
<p>0AA7: call_function_return 0x579460 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]</p>
<p>define function CVehicleModelInfo__GetEditableMaterialListCB&lt;cdecl, 0x579460&gt;(material, data): int</p>
<h4>CVehicleModelInfo::GetMatFXEffectMaterialCB</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x578BA0, RpMaterial</em>, void*>(material, data);</p>
<p>0AA7: call_function_return 0x578BA0 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]</p>
<p>define function CVehicleModelInfo__GetMatFXEffectMaterialCB&lt;cdecl, 0x578BA0&gt;(material, data): int</p>
<h4>CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors</h4>
<p>plugin::CallAndReturn<int, 0x578A70, int>(modelId);</p>
<p>0AA7: call_function_return 0x578A70 num_params 1 pop 1 [modelId] func_ret [int]</p>
<p>define function CVehicleModelInfo__GetMaximumNumberOfPassengersFromNumberOfDoors&lt;cdecl, 0x578A70&gt;(modelId): int</p>
<h4>CVehicleModelInfo::GetWheelPosn</h4>
<p>plugin::CallMethod<0x579AD0, CVehicleModelInfo *, int, CVector&>(this, wheel, outVec);</p>
<p>0AA6: call_method 0x579AD0 struct [CVehicleModelInfo] num_params 2 pop 0 [wheel] [outVec]</p>
<p>define function CVehicleModelInfo__GetWheelPosn&lt;thiscall, 0x579AD0&gt;(wheel, outVec)</p>
<h4>CVehicleModelInfo::HasAlphaMaterialCB</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x57A600, RpMaterial</em>, void*>(material, data);</p>
<p>0AA7: call_function_return 0x57A600 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]</p>
<p>define function CVehicleModelInfo__HasAlphaMaterialCB&lt;cdecl, 0x57A600&gt;(material, data): int</p>
<h4>CVehicleModelInfo::HideAllComponentsAtomicCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A620, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x57A620 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__HideAllComponentsAtomicCB&lt;cdecl, 0x57A620&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::LoadEnvironmentMaps</h4>
<p>plugin::Call<0x578C30>();</p>
<p>0AA5: call_function 0x578C30 num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__LoadEnvironmentMaps&lt;cdecl, 0x578C30&gt;()</p>
<h4>CVehicleModelInfo::LoadVehicleColours</h4>
<p>plugin::Call<0x578CC0>();</p>
<p>0AA5: call_function 0x578CC0 num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__LoadVehicleColours&lt;cdecl, 0x578CC0&gt;()</p>
<h4>CVehicleModelInfo::MoveObjectsCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A640, RwObject</em>, void*>(object, data);</p>
<p>0AA7: call_function_return 0x57A640 num_params 2 pop 2 [object] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__MoveObjectsCB&lt;cdecl, 0x57A640&gt;(object, data): int</p>
<h4>CVehicleModelInfo::PreprocessHierarchy</h4>
<p>plugin::CallMethod<0x579B10, CVehicleModelInfo *>(this);</p>
<p>0AA6: call_method 0x579B10 struct [CVehicleModelInfo] num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__PreprocessHierarchy&lt;thiscall, 0x579B10&gt;()</p>
<h4>CVehicleModelInfo::SetAtomicFlagCB</h4>
<p>plugin::CallAndReturn<RwObject<em>, 0x579FF0, RwObject</em>, void*>(object, data);</p>
<p>0AA7: call_function_return 0x579FF0 num_params 2 pop 2 [object] [data] func_ret [RwObject*]</p>
<p>define function CVehicleModelInfo__SetAtomicFlagCB&lt;cdecl, 0x579FF0&gt;(object, data): int</p>
<h4>CVehicleModelInfo::SetAtomicRendererCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A4A0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x57A4A0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB&lt;cdecl, 0x57A4A0&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::SetAtomicRendererCB_BigVehicle</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A1E0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x57A1E0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_BigVehicle&lt;cdecl, 0x57A1E0&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::SetAtomicRendererCB_Boat</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A070, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x57A070 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_Boat&lt;cdecl, 0x57A070&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::SetAtomicRendererCB_Heli</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A010, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x57A010 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_Heli&lt;cdecl, 0x57A010&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::SetAtomicRendererCB_RealHeli</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x57A300, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x57A300 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__SetAtomicRendererCB_RealHeli&lt;cdecl, 0x57A300&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::SetDefaultEnvironmentMapCB</h4>
<p>plugin::CallAndReturn<RpMaterial<em>, 0x578B40, RpMaterial</em>, void*>(material, data);</p>
<p>0AA7: call_function_return 0x578B40 num_params 2 pop 2 [material] [data] func_ret [RpMaterial*]</p>
<p>define function CVehicleModelInfo__SetDefaultEnvironmentMapCB&lt;cdecl, 0x578B40&gt;(material, data): int</p>
<h4>CVehicleModelInfo::SetEnvironmentMapCB</h4>
<p>plugin::CallAndReturn<RpAtomic<em>, 0x578AF0, RpAtomic</em>, void*>(atomic, data);</p>
<p>0AA7: call_function_return 0x578AF0 num_params 2 pop 2 [atomic] [data] func_ret [RpAtomic*]</p>
<p>define function CVehicleModelInfo__SetEnvironmentMapCB&lt;cdecl, 0x578AF0&gt;(atomic, data): int</p>
<h4>CVehicleModelInfo::SetVehicleColour</h4>
<p>plugin::CallMethod<0x579290, CVehicleModelInfo *, unsigned char, unsigned char>(this, prim, sec);</p>
<p>0AA6: call_method 0x579290 struct [CVehicleModelInfo] num_params 2 pop 0 [prim] [sec]</p>
<p>define function CVehicleModelInfo__SetVehicleColour&lt;thiscall, 0x579290&gt;(prim, sec)</p>
<h4>CVehicleModelInfo::SetVehicleComponentFlags</h4>
<p>plugin::CallMethod<0x579E80, CVehicleModelInfo <em>, RwFrame</em>, unsigned int>(this, component, flags);</p>
<p>0AA6: call_method 0x579E80 struct [CVehicleModelInfo] num_params 2 pop 0 [component] [flags]</p>
<p>define function CVehicleModelInfo__SetVehicleComponentFlags&lt;thiscall, 0x579E80&gt;(component, flags)</p>
<h4>CVehicleModelInfo::ShutdownEnvironmentMaps</h4>
<p>plugin::Call<0x578BD0>();</p>
<p>0AA5: call_function 0x578BD0 num_params 0 pop 0</p>
<p>define function CVehicleModelInfo__ShutdownEnvironmentMaps&lt;cdecl, 0x578BD0&gt;()</p>
<h4>VehicleModelStore::~VehicleModelStore</h4>
<p>plugin::CallMethod<0x560150, VehicleModelStore *>(this);</p>
<p>0AA6: call_method 0x560150 struct [VehicleModelStore] num_params 0 pop 0</p>
<p>define function VehicleModelStore__~VehicleModelStore&lt;thiscall, 0x560150&gt;()</p>
<h4>GetListOfComponentsNotUsedByRules</h4>
<p>plugin::CallAndReturn<int, 0x5799B0, unsigned int, int, int*>(compRulesBits, numExtras, variationsList);</p>
<p>0AA7: call_function_return 0x5799B0 num_params 3 pop 3 [compRulesBits] [numExtras] [variationsList] func_ret [int]</p>
<p>define function GetListOfComponentsNotUsedByRules&lt;cdecl, 0x5799B0&gt;(compRulesBits, numExtras, variationsList): int</p>
<h4>ChooseComponent</h4>
<p>plugin::CallAndReturn<int, 0x5797C0, int, int>(rule, compRulesBits);</p>
<p>0AA7: call_function_return 0x5797C0 num_params 2 pop 2 [rule] [compRulesBits] func_ret [int]</p>
<p>define function ChooseComponent&lt;cdecl, 0x5797C0&gt;(rule, compRulesBits): int</p><h3 id="plugin_vcgame_vccvisibilitypluginscpp">plugin_vc\game_vc\CVisibilityPlugins.cpp</h3><h4>CVisibilityPlugins::SetAtomicRenderCallback</h4>
<p>plugin::Call<0x581940>(atomic, cb);</p>
<p>0AA5: call_function 0x581940 num_params 2 pop 2 [atomic] [cb]</p>
<p>define function CVisibilityPlugins__SetAtomicRenderCallback&lt;cdecl, 0x581940&gt;(atomic, cb)</p><h3 id="plugin_vcgame_vccwantedcpp">plugin_vc\game_vc\CWanted.cpp</h3><h4>CWanted::AddCrimeToQ</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1990, CWanted *, eCrimeType, int, CVector const&, bool, bool>(this, crimeType, arg1, arg2, arg3, arg4);</p>
<p>0AA8: call_method_return 0x4D1990 struct [CWanted] num_params 5 pop 0 [crimeType] [arg1] [arg2] [arg3] [arg4] func_ret [bool]</p>
<p>define function CWanted__AddCrimeToQ&lt;thiscall, 0x4D1990&gt;(crimeType, arg1, arg2, arg3, arg4): int</p>
<h4>CWanted::AreArmyRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1E20, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x4D1E20 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreArmyRequired&lt;thiscall, 0x4D1E20&gt;(): int</p>
<h4>CWanted::AreFbiRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1E40, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x4D1E40 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreFbiRequired&lt;thiscall, 0x4D1E40&gt;(): int</p>
<h4>CWanted::AreMiamiViceRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1E80, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x4D1E80 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreMiamiViceRequired&lt;thiscall, 0x4D1E80&gt;(): int</p>
<h4>CWanted::AreSwatRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1E60, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x4D1E60 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__AreSwatRequired&lt;thiscall, 0x4D1E60&gt;(): int</p>
<h4>CWanted::CheatWantedLevel</h4>
<p>plugin::CallMethod<0x4D1F80, CWanted *, int>(this, arg0);</p>
<p>0AA6: call_method 0x4D1F80 struct [CWanted] num_params 1 pop 0 [arg0]</p>
<p>define function CWanted__CheatWantedLevel&lt;thiscall, 0x4D1F80&gt;(arg0)</p>
<h4>CWanted::ClearQdCrimes</h4>
<p>plugin::CallMethod<0x4D1A50, CWanted *>(this);</p>
<p>0AA6: call_method 0x4D1A50 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__ClearQdCrimes&lt;thiscall, 0x4D1A50&gt;()</p>
<h4>CWanted::Initialise</h4>
<p>plugin::CallMethod<0x4D2440, CWanted *>(this);</p>
<p>0AA6: call_method 0x4D2440 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Initialise&lt;thiscall, 0x4D2440&gt;()</p>
<h4>CWanted::NumOfHelisRequired</h4>
<p>plugin::CallMethodAndReturn<bool, 0x4D1DE0, CWanted *>(this);</p>
<p>0AA8: call_method_return 0x4D1DE0 struct [CWanted] num_params 0 pop 0 func_ret [bool]</p>
<p>define function CWanted__NumOfHelisRequired&lt;thiscall, 0x4D1DE0&gt;(): int</p>
<h4>CWanted::RegisterCrime</h4>
<p>plugin::CallMethod<0x4D20F0, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, arg1, arg2, arg3);</p>
<p>0AA6: call_method 0x4D20F0 struct [CWanted] num_params 4 pop 0 [crimeType] [arg1] [arg2] [arg3]</p>
<p>define function CWanted__RegisterCrime&lt;thiscall, 0x4D20F0&gt;(crimeType, arg1, arg2, arg3)</p>
<h4>CWanted::RegisterCrime_Immediately</h4>
<p>plugin::CallMethod<0x4D20B0, CWanted *, eCrimeType, CVector const&, unsigned int, bool>(this, crimeType, arg1, arg2, arg3);</p>
<p>0AA6: call_method 0x4D20B0 struct [CWanted] num_params 4 pop 0 [crimeType] [arg1] [arg2] [arg3]</p>
<p>define function CWanted__RegisterCrime_Immediately&lt;thiscall, 0x4D20B0&gt;(crimeType, arg1, arg2, arg3)</p>
<h4>CWanted::ReportCrimeNow</h4>
<p>plugin::CallMethod<0x4D1610, CWanted *, eCrimeType, CVector const&, bool>(this, crimeType, arg1, arg2);</p>
<p>0AA6: call_method 0x4D1610 struct [CWanted] num_params 3 pop 0 [crimeType] [arg1] [arg2]</p>
<p>define function CWanted__ReportCrimeNow&lt;thiscall, 0x4D1610&gt;(crimeType, arg1, arg2)</p>
<h4>CWanted::Reset</h4>
<p>plugin::CallMethod<0x4D2420, CWanted *>(this);</p>
<p>0AA6: call_method 0x4D2420 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Reset&lt;thiscall, 0x4D2420&gt;()</p>
<h4>CWanted::ResetPolicePursuit</h4>
<p>plugin::CallMethod<0x4D1D20, CWanted *>(this);</p>
<p>0AA6: call_method 0x4D1D20 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__ResetPolicePursuit&lt;thiscall, 0x4D1D20&gt;()</p>
<h4>CWanted::SetMaximumWantedLevel</h4>
<p>plugin::Call<0x4D1E90, int>(level);</p>
<p>0AA5: call_function 0x4D1E90 num_params 1 pop 1 [level]</p>
<p>define function CWanted__SetMaximumWantedLevel&lt;cdecl, 0x4D1E90&gt;(level)</p>
<h4>CWanted::SetWantedLevel</h4>
<p>plugin::CallMethod<0x4D1FA0, CWanted *, int>(this, level);</p>
<p>0AA6: call_method 0x4D1FA0 struct [CWanted] num_params 1 pop 0 [level]</p>
<p>define function CWanted__SetWantedLevel&lt;thiscall, 0x4D1FA0&gt;(level)</p>
<h4>CWanted::SetWantedLevelNoDrop</h4>
<p>plugin::CallMethod<0x4D1F50, CWanted *, int>(this, arg0);</p>
<p>0AA6: call_method 0x4D1F50 struct [CWanted] num_params 1 pop 0 [arg0]</p>
<p>define function CWanted__SetWantedLevelNoDrop&lt;thiscall, 0x4D1F50&gt;(arg0)</p>
<h4>CWanted::Update</h4>
<p>plugin::CallMethod<0x4D2260, CWanted *>(this);</p>
<p>0AA6: call_method 0x4D2260 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__Update&lt;thiscall, 0x4D2260&gt;()</p>
<h4>CWanted::UpdateWantedLevel</h4>
<p>plugin::CallMethod<0x4D2110, CWanted *>(this);</p>
<p>0AA6: call_method 0x4D2110 struct [CWanted] num_params 0 pop 0</p>
<p>define function CWanted__UpdateWantedLevel&lt;thiscall, 0x4D2110&gt;()</p>
<h4>CWanted::WorkOutPolicePresence</h4>
<p>plugin::Call<0x4D1B00, CVector, float>(arg0, arg1);</p>
<p>0AA5: call_function 0x4D1B00 num_params 2 pop 2 [arg0] [arg1]</p>
<p>define function CWanted__WorkOutPolicePresence&lt;cdecl, 0x4D1B00&gt;(arg0, arg1)</p><h3 id="plugin_vcgame_vccwatercannonscpp">plugin_vc\game_vc\CWaterCannons.cpp</h3><h4>CWaterCannon::CWaterCannon</h4>
<p>plugin::CallMethod<0x57BE40, CWaterCannon *>(this);</p>
<p>0AA6: call_method 0x57BE40 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__CWaterCannon&lt;thiscall, 0x57BE40&gt;()</p>
<h4>CWaterCannon::Init</h4>
<p>plugin::CallMethod<0x57BCD0, CWaterCannon *>(this);</p>
<p>0AA6: call_method 0x57BCD0 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__Init&lt;thiscall, 0x57BCD0&gt;()</p>
<h4>CWaterCannon::PushPeds</h4>
<p>plugin::CallMethod<0x57B2F0, CWaterCannon *>(this);</p>
<p>0AA6: call_method 0x57B2F0 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__PushPeds&lt;thiscall, 0x57B2F0&gt;()</p>
<h4>CWaterCannon::Render</h4>
<p>plugin::CallMethod<0x57B810, CWaterCannon *>(this);</p>
<p>0AA6: call_method 0x57B810 struct [CWaterCannon] num_params 0 pop 0</p>
<p>define function CWaterCannon__Render&lt;thiscall, 0x57B810&gt;()</p>
<h4>CWaterCannon::Update_OncePerFrame</h4>
<p>plugin::CallMethod<0x57BB90, CWaterCannon *, short>(this, index);</p>
<p>0AA6: call_method 0x57BB90 struct [CWaterCannon] num_params 1 pop 0 [index]</p>
<p>define function CWaterCannon__Update_OncePerFrame&lt;thiscall, 0x57BB90&gt;(index)</p>
<h4>CWaterCannons::Init</h4>
<p>plugin::Call<0x57B2C0>();</p>
<p>0AA5: call_function 0x57B2C0 num_params 0 pop 0</p>
<p>define function CWaterCannons__Init&lt;cdecl, 0x57B2C0&gt;()</p>
<h4>CWaterCannons::Render</h4>
<p>plugin::Call<0x57B0E0>();</p>
<p>0AA5: call_function 0x57B0E0 num_params 0 pop 0</p>
<p>define function CWaterCannons__Render&lt;cdecl, 0x57B0E0&gt;()</p>
<h4>CWaterCannons::Update</h4>
<p>plugin::Call<0x57B120>();</p>
<p>0AA5: call_function 0x57B120 num_params 0 pop 0</p>
<p>define function CWaterCannons__Update&lt;cdecl, 0x57B120&gt;()</p>
<h4>CWaterCannons::UpdateOne</h4>
<p>plugin::Call<0x57B160, unsigned int, CVector<em>, CVector</em>>(pCar, posn, moveSpeed);</p>
<p>0AA5: call_function 0x57B160 num_params 3 pop 3 [pCar] [posn] [moveSpeed]</p>
<p>define function CWaterCannons__UpdateOne&lt;cdecl, 0x57B160&gt;(pCar, posn, moveSpeed)</p><h3 id="plugin_vcgame_vccweaponeffectscpp">plugin_vc\game_vc\CWeaponEffects.cpp</h3><h4>CWeaponEffects::CWeaponEffects</h4>
<p>plugin::CallMethod<0x5D5140, CWeaponEffects *>(this);</p>
<p>0AA6: call_method 0x5D5140 struct [CWeaponEffects] num_params 0 pop 0</p>
<p>define function CWeaponEffects__CWeaponEffects&lt;thiscall, 0x5D5140&gt;()</p>
<h4>CWeaponEffects::ClearCrossHair</h4>
<p>plugin::Call<0x5D5050>();</p>
<p>0AA5: call_function 0x5D5050 num_params 0 pop 0</p>
<p>define function CWeaponEffects__ClearCrossHair&lt;cdecl, 0x5D5050&gt;()</p>
<h4>CWeaponEffects::Init</h4>
<p>plugin::Call<0x5D50B0>();</p>
<p>0AA5: call_function 0x5D50B0 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Init&lt;cdecl, 0x5D50B0&gt;()</p>
<h4>CWeaponEffects::MarkTarget</h4>
<p>plugin::Call<0x5D5060, CVector, unsigned char, unsigned char, unsigned char, unsigned char, float>(pos, red, green, blue, alpha, size);</p>
<p>0AA5: call_function 0x5D5060 num_params 6 pop 6 [pos] [red] [green] [blue] [alpha] [size]</p>
<p>define function CWeaponEffects__MarkTarget&lt;cdecl, 0x5D5060&gt;(pos, red, green, blue, alpha, size)</p>
<h4>CWeaponEffects::Render</h4>
<p>plugin::Call<0x5D4E90>();</p>
<p>0AA5: call_function 0x5D4E90 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Render&lt;cdecl, 0x5D4E90&gt;()</p>
<h4>CWeaponEffects::Shutdown</h4>
<p>plugin::Call<0x5D5090>();</p>
<p>0AA5: call_function 0x5D5090 num_params 0 pop 0</p>
<p>define function CWeaponEffects__Shutdown&lt;cdecl, 0x5D5090&gt;()</p><h3 id="plugin_vcgame_vccweaponinfocpp">plugin_vc\game_vc\CWeaponInfo.cpp</h3><h4>CWeaponInfo::CWeaponInfo</h4>
<p>plugin::CallMethod<0x5D58D0, CWeaponInfo *>(this);</p>
<p>0AA6: call_method 0x5D58D0 struct [CWeaponInfo] num_params 0 pop 0</p>
<p>define function CWeaponInfo__CWeaponInfo&lt;thiscall, 0x5D58D0&gt;()</p>
<h4>CWeaponInfo::~CWeaponInfo</h4>
<p>plugin::CallMethod<0x5D58C0, CWeaponInfo *>(this);</p>
<p>0AA6: call_method 0x5D58C0 struct [CWeaponInfo] num_params 0 pop 0</p>
<p>define function CWeaponInfo__~CWeaponInfo&lt;thiscall, 0x5D58C0&gt;()</p>
<h4>CWeaponInfo::FindWeaponFireType</h4>
<p>plugin::CallAndReturn<eWeaponFire, 0x5D5170, char*>(name);</p>
<p>0AA7: call_function_return 0x5D5170 num_params 1 pop 1 [name] func_ret [eWeaponFire]</p>
<p>define function CWeaponInfo__FindWeaponFireType&lt;cdecl, 0x5D5170&gt;(name): int</p>
<h4>CWeaponInfo::GetWeaponInfo</h4>
<p>plugin::CallAndReturn<CWeaponInfo*, 0x5D5710, eWeaponType>(weaponType);</p>
<p>0AA7: call_function_return 0x5D5710 num_params 1 pop 1 [weaponType] func_ret [CWeaponInfo*]</p>
<p>define function CWeaponInfo__GetWeaponInfo&lt;cdecl, 0x5D5710&gt;(weaponType): int</p>
<h4>CWeaponInfo::Initialise</h4>
<p>plugin::Call<0x5D5750>();</p>
<p>0AA5: call_function 0x5D5750 num_params 0 pop 0</p>
<p>define function CWeaponInfo__Initialise&lt;cdecl, 0x5D5750&gt;()</p>
<h4>CWeaponInfo::LoadWeaponData</h4>
<p>plugin::Call<0x5D5250>();</p>
<p>0AA5: call_function 0x5D5250 num_params 0 pop 0</p>
<p>define function CWeaponInfo__LoadWeaponData&lt;cdecl, 0x5D5250&gt;()</p>
<h4>CWeaponInfo::Shutdown</h4>
<p>plugin::Call<0x5D5730>();</p>
<p>0AA5: call_function 0x5D5730 num_params 0 pop 0</p>
<p>define function CWeaponInfo__Shutdown&lt;cdecl, 0x5D5730&gt;()</p><h3 id="plugin_vcgame_vccweaponmodelinfocpp">plugin_vc\game_vc\CWeaponModelInfo.cpp</h3><h4>CWeaponModelInfo::GetWeaponInfo</h4>
<p>plugin::CallMethodAndReturn<int, 0x629C20, CWeaponModelInfo *>(this);</p>
<p>0AA8: call_method_return 0x629C20 struct [CWeaponModelInfo] num_params 0 pop 0 func_ret [int]</p>
<p>define function CWeaponModelInfo__GetWeaponInfo&lt;thiscall, 0x629C20&gt;(): int</p>
<h4>CWeaponModelInfo::Init</h4>
<p>plugin::CallMethod<0x629C70, CWeaponModelInfo *>(this);</p>
<p>0AA6: call_method 0x629C70 struct [CWeaponModelInfo] num_params 0 pop 0</p>
<p>define function CWeaponModelInfo__Init&lt;thiscall, 0x629C70&gt;()</p>
<h4>CWeaponModelInfo::SetWeaponInfo</h4>
<p>plugin::CallMethodAndReturn<int, 0x629C30, CWeaponModelInfo *, int>(this, weaponType);</p>
<p>0AA8: call_method_return 0x629C30 struct [CWeaponModelInfo] num_params 1 pop 0 [weaponType] func_ret [int]</p>
<p>define function CWeaponModelInfo__SetWeaponInfo&lt;thiscall, 0x629C30&gt;(weaponType): int</p>
<h4>WeaponModelStore::~WeaponModelStore</h4>
<p>plugin::CallMethod<0x5601E0, WeaponModelStore *>(this);</p>
<p>0AA6: call_method 0x5601E0 struct [WeaponModelStore] num_params 0 pop 0</p>
<p>define function WeaponModelStore__~WeaponModelStore&lt;thiscall, 0x5601E0&gt;()</p><h3 id="plugin_vcgame_vccweathercpp">plugin_vc\game_vc\CWeather.cpp</h3><h4>CWeather::AddRain</h4>
<p>plugin::Call<0x57C900>();</p>
<p>0AA5: call_function 0x57C900 num_params 0 pop 0</p>
<p>define function CWeather__AddRain&lt;cdecl, 0x57C900&gt;()</p>
<h4>CWeather::AddSplashesDuringHurricane</h4>
<p>plugin::Call<0x57D160>();</p>
<p>0AA5: call_function 0x57D160 num_params 0 pop 0</p>
<p>define function CWeather__AddSplashesDuringHurricane&lt;cdecl, 0x57D160&gt;()</p>
<h4>CWeather::AddStreamAfterRain</h4>
<p>plugin::Call<0x57D340>();</p>
<p>0AA5: call_function 0x57D340 num_params 0 pop 0</p>
<p>define function CWeather__AddStreamAfterRain&lt;cdecl, 0x57D340&gt;()</p>
<h4>CWeather::ForceWeather</h4>
<p>plugin::Call<0x57D570, short>(weather);</p>
<p>0AA5: call_function 0x57D570 num_params 1 pop 1 [weather]</p>
<p>define function CWeather__ForceWeather&lt;cdecl, 0x57D570&gt;(weather)</p>
<h4>CWeather::ForceWeatherNow</h4>
<p>plugin::Call<0x57D550, short>(weather);</p>
<p>0AA5: call_function 0x57D550 num_params 1 pop 1 [weather]</p>
<p>define function CWeather__ForceWeatherNow&lt;cdecl, 0x57D550&gt;(weather)</p>
<h4>CWeather::Init</h4>
<p>plugin::Call<0x57E040>();</p>
<p>0AA5: call_function 0x57E040 num_params 0 pop 0</p>
<p>define function CWeather__Init&lt;cdecl, 0x57E040&gt;()</p>
<h4>CWeather::ReleaseWeather</h4>
<p>plugin::Call<0x57D540>();</p>
<p>0AA5: call_function 0x57D540 num_params 0 pop 0</p>
<p>define function CWeather__ReleaseWeather&lt;cdecl, 0x57D540&gt;()</p>
<h4>CWeather::RenderRainStreaks</h4>
<p>plugin::Call<0x57BF40>();</p>
<p>0AA5: call_function 0x57BF40 num_params 0 pop 0</p>
<p>define function CWeather__RenderRainStreaks&lt;cdecl, 0x57BF40&gt;()</p>
<h4>CWeather::Update</h4>
<p>plugin::Call<0x57D580>();</p>
<p>0AA5: call_function 0x57D580 num_params 0 pop 0</p>
<p>define function CWeather__Update&lt;cdecl, 0x57D580&gt;()</p><h3 id="plugin_vcgame_vccwindmodifierscpp">plugin_vc\game_vc\CWindModifiers.cpp</h3><h4>CWindModifiers::FindWindModifier</h4>
<p>plugin::CallAndReturnDynGlobal<bool, CVector, float *, float *>(gaddrof_o(CWindModifiers::FindWindModifier, bool (*)(CVector, float *, float *)), pos, x, y);</p>
<p>0AA7: call_function_return 0x629C90 num_params 3 pop 3 [pos] [x] [y] func_ret [bool]</p>
<p>define function CWindModifiers__FindWindModifier&lt;cdecl, 0x629C90&gt;(pos, x, y): int</p>
<h4>CWindModifiers::RegisterOne</h4>
<p>plugin::CallDynGlobal<CVector, int>(gaddrof_o(CWindModifiers::RegisterOne, void (*)(CVector, int)), pos, type);</p><h3 id="plugin_vcgame_vccworldcpp">plugin_vc\game_vc\CWorld.cpp</h3><h4>CWorld::Add</h4>
<p>plugin::Call<0x4DB3F0, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4DB3F0 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__Add&lt;cdecl, 0x4DB3F0&gt;(entity)</p>
<h4>CWorld::AddParticles</h4>
<p>plugin::Call<0x4D4BB0>();</p>
<p>0AA5: call_function 0x4D4BB0 num_params 0 pop 0</p>
<p>define function CWorld__AddParticles&lt;cdecl, 0x4D4BB0&gt;()</p>
<h4>CWorld::CallOffChaseForArea</h4>
<p>plugin::Call<0x4D3200, float, float, float, float>(x1, y1, x2, y2);</p>
<p>0AA5: call_function 0x4D3200 num_params 4 pop 4 [x1] [y1] [x2] [y2]</p>
<p>define function CWorld__CallOffChaseForArea&lt;cdecl, 0x4D3200&gt;(x1, y1, x2, y2)</p>
<h4>CWorld::CallOffChaseForAreaSectorListPeds</h4>
<p>plugin::Call<0x4D2DF0, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x4D2DF0 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CWorld__CallOffChaseForAreaSectorListPeds&lt;cdecl, 0x4D2DF0&gt;(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8)</p>
<h4>CWorld::CallOffChaseForAreaSectorListVehicles</h4>
<p>plugin::Call<0x4D2F50, CPtrList&, float, float, float, float, float, float, float, float>(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8);</p>
<p>0AA5: call_function 0x4D2F50 num_params 9 pop 9 [list] [x1] [y1] [x2] [y2] [arg5] [arg6] [arg7] [arg8]</p>
<p>define function CWorld__CallOffChaseForAreaSectorListVehicles&lt;cdecl, 0x4D2F50&gt;(list, x1, y1, x2, y2, arg5, arg6, arg7, arg8)</p>
<h4>CWorld::ClearCarsFromArea</h4>
<p>plugin::Call<0x4D3700, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x4D3700 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CWorld__ClearCarsFromArea&lt;cdecl, 0x4D3700&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CWorld::ClearExcitingStuffFromArea</h4>
<p>plugin::Call<0x4D38F0, CVector const&, float, unsigned char>(point, radius, bRemoveProjectilesAndShadows);</p>
<p>0AA5: call_function 0x4D38F0 num_params 3 pop 3 [point] [radius] [bRemoveProjectilesAndShadows]</p>
<p>define function CWorld__ClearExcitingStuffFromArea&lt;cdecl, 0x4D38F0&gt;(point, radius, bRemoveProjectilesAndShadows)</p>
<h4>CWorld::ClearForRestart</h4>
<p>plugin::Call<0x4DB4A0>();</p>
<p>0AA5: call_function 0x4DB4A0 num_params 0 pop 0</p>
<p>define function CWorld__ClearForRestart&lt;cdecl, 0x4DB4A0&gt;()</p>
<h4>CWorld::ClearPedsFromArea</h4>
<p>plugin::Call<0x4D35C0, float, float, float, float, float, float>(x1, y1, z1, x2, y2, z2);</p>
<p>0AA5: call_function 0x4D35C0 num_params 6 pop 6 [x1] [y1] [z1] [x2] [y2] [z2]</p>
<p>define function CWorld__ClearPedsFromArea&lt;cdecl, 0x4D35C0&gt;(x1, y1, z1, x2, y2, z2)</p>
<h4>CWorld::ClearScanCodes</h4>
<p>plugin::Call<0x4D7460>();</p>
<p>0AA5: call_function 0x4D7460 num_params 0 pop 0</p>
<p>define function CWorld__ClearScanCodes&lt;cdecl, 0x4D7460&gt;()</p>
<h4>CWorld::ExtinguishAllCarFiresInArea</h4>
<p>plugin::Call<0x4D3480, CVector, float>(point, radius);</p>
<p>0AA5: call_function 0x4D3480 num_params 2 pop 2 [point] [radius]</p>
<p>define function CWorld__ExtinguishAllCarFiresInArea&lt;cdecl, 0x4D3480&gt;(point, radius)</p>
<h4>CWorld::FindGroundZFor3DCoord</h4>
<p>plugin::CallAndReturn<float, 0x4D53A0, float, float, float, bool*>(x, y, z, outResult);</p>
<p>0AA7: call_function_return 0x4D53A0 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]</p>
<p>define function CWorld__FindGroundZFor3DCoord&lt;cdecl, 0x4D53A0&gt;(x, y, z, outResult): float</p>
<h4>CWorld::FindGroundZForCoord</h4>
<p>plugin::CallAndReturn<float, 0x4D5540, float, float>(x, y);</p>
<p>0AA7: call_function_return 0x4D5540 num_params 2 pop 2 [x] [y] func_ret [float]</p>
<p>define function CWorld__FindGroundZForCoord&lt;cdecl, 0x4D5540&gt;(x, y): float</p>
<h4>CWorld::FindMissionEntitiesIntersectingCube</h4>
<p>plugin::Call<0x4D5800, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects);</p>
<p>0AA5: call_function 0x4D5800 num_params 8 pop 8 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehicles] [peds] [objects]</p>
<p>define function CWorld__FindMissionEntitiesIntersectingCube&lt;cdecl, 0x4D5800&gt;(cornerA, cornerB, outCount, maxCount, outEntities, vehicles, peds, objects)</p>
<h4>CWorld::FindMissionEntitiesIntersectingCubeSectorList</h4>
<p>plugin::Call<0x4D56B0, CPtrList&, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool>(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList);</p>
<p>0AA5: call_function 0x4D56B0 num_params 9 pop 9 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [vehiclesList] [pedsList] [objectsList]</p>
<p>define function CWorld__FindMissionEntitiesIntersectingCubeSectorList&lt;cdecl, 0x4D56B0&gt;(list, cornerA, cornerB, outCount, maxCount, outEntities, vehiclesList, pedsList, objectsList)</p>
<h4>CWorld::FindObjectsInRange</h4>
<p>plugin::Call<0x4D6B90, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4D6B90 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsInRange&lt;cdecl, 0x4D6B90&gt;(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsInRangeSectorList</h4>
<p>plugin::Call<0x4D6AD0, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(list, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4D6AD0 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsInRangeSectorList&lt;cdecl, 0x4D6AD0&gt;(list, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsIntersectingAngledCollisionBox</h4>
<p>plugin::Call<0x4D5B90, CBox const&, CMatrix const&, CVector const&, float, float, float, float, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4D5B90 num_params 15 pop 15 [box] [transform] [point] [x1] [y1] [x2] [y2] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsIntersectingAngledCollisionBox&lt;cdecl, 0x4D5B90&gt;(box, transform, point, x1, y1, x2, y2, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList</h4>
<p>plugin::Call<0x4D5A90, CPtrList&, CBox const&, CMatrix const&, CVector const&, short<em>, short, CEntity</em>*>(list, box, transform, point, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4D5A90 num_params 7 pop 7 [list] [box] [transform] [point] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsIntersectingAngledCollisionBoxSectorList&lt;cdecl, 0x4D5A90&gt;(list, box, transform, point, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsIntersectingCube</h4>
<p>plugin::Call<0x4D5FB0, CVector const&, CVector const&, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4D5FB0 num_params 10 pop 10 [cornerA] [cornerB] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsIntersectingCube&lt;cdecl, 0x4D5FB0&gt;(cornerA, cornerB, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsIntersectingCubeSectorList</h4>
<p>plugin::Call<0x4D5EA0, CPtrList&, CVector const&, CVector const&, short<em>, short, CEntity</em>*>(list, cornerA, cornerB, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4D5EA0 num_params 6 pop 6 [list] [cornerA] [cornerB] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsIntersectingCubeSectorList&lt;cdecl, 0x4D5EA0&gt;(list, cornerA, cornerB, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsKindaColliding</h4>
<p>plugin::Call<0x4D6370, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4D6370 num_params 11 pop 11 [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsKindaColliding&lt;cdecl, 0x4D6370&gt;(point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsKindaCollidingSectorList</h4>
<p>plugin::Call<0x4D6280, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(list, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4D6280 num_params 7 pop 7 [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsKindaCollidingSectorList&lt;cdecl, 0x4D6280&gt;(list, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindObjectsOfTypeInRange</h4>
<p>plugin::Call<0x4D6770, unsigned int, CVector const&, float, bool, short<em>, short, CEntity</em>*, bool, bool, bool, bool, bool>(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies);</p>
<p>0AA5: call_function 0x4D6770 num_params 12 pop 12 [modelId] [point] [radius] [b2D] [outCount] [maxCount] [outEntities] [buildings] [vehicles] [peds] [objects] [dummies]</p>
<p>define function CWorld__FindObjectsOfTypeInRange&lt;cdecl, 0x4D6770&gt;(modelId, point, radius, b2D, outCount, maxCount, outEntities, buildings, vehicles, peds, objects, dummies)</p>
<h4>CWorld::FindObjectsOfTypeInRangeSectorList</h4>
<p>plugin::Call<0x4D66A0, unsigned int, CPtrList&, CVector const&, float, bool, short<em>, short, CEntity</em>*>(modelId, list, point, radius, b2D, outCount, maxCount, outEntities);</p>
<p>0AA5: call_function 0x4D66A0 num_params 8 pop 8 [modelId] [list] [point] [radius] [b2D] [outCount] [maxCount] [outEntities]</p>
<p>define function CWorld__FindObjectsOfTypeInRangeSectorList&lt;cdecl, 0x4D66A0&gt;(modelId, list, point, radius, b2D, outCount, maxCount, outEntities)</p>
<h4>CWorld::FindRoofZFor3DCoord</h4>
<p>plugin::CallAndReturn<float, 0x4D51D0, float, float, float, bool*>(x, y, z, outResult);</p>
<p>0AA7: call_function_return 0x4D51D0 num_params 4 pop 4 [x] [y] [z] [outResult] func_ret [float]</p>
<p>define function CWorld__FindRoofZFor3DCoord&lt;cdecl, 0x4D51D0&gt;(x, y, z, outResult): float</p>
<h4>CWorld::GetIsLineOfSightClear</h4>
<p>plugin::CallAndReturn<bool, 0x4DA560, CVector const&, CVector const&, bool, bool, bool, bool, bool, bool, bool>(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4DA560 num_params 9 pop 9 [origin] [target] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightClear&lt;cdecl, 0x4DA560&gt;(origin, target, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::GetIsLineOfSightSectorClear</h4>
<p>plugin::CallAndReturn<bool, 0x4D6EC0, CSector&, CColLine const&, bool, bool, bool, bool, bool, bool, bool>(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4D6EC0 num_params 9 pop 9 [sector] [line] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] func_ret [bool]</p>
<p>define function CWorld__GetIsLineOfSightSectorClear&lt;cdecl, 0x4D6EC0&gt;(sector, line, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck): int</p>
<h4>CWorld::Initialise</h4>
<p>plugin::Call<0x4DB9A0>();</p>
<p>0AA5: call_function 0x4DB9A0 num_params 0 pop 0</p>
<p>define function CWorld__Initialise&lt;cdecl, 0x4DB9A0&gt;()</p>
<h4>CWorld::IsWanderPathClear</h4>
<p>plugin::CallAndReturn<bool, 0x4D2620, CVector const&, CVector const&, float, int>(origin, target, arg2, arg3);</p>
<p>0AA7: call_function_return 0x4D2620 num_params 4 pop 4 [origin] [target] [arg2] [arg3] func_ret [bool]</p>
<p>define function CWorld__IsWanderPathClear&lt;cdecl, 0x4D2620&gt;(origin, target, arg2, arg3): int</p>
<h4>CWorld::Process</h4>
<p>plugin::Call<0x4D7500>();</p>
<p>0AA5: call_function 0x4D7500 num_params 0 pop 0</p>
<p>define function CWorld__Process&lt;cdecl, 0x4D7500&gt;()</p>
<h4>CWorld::ProcessLineOfSight</h4>
<p>plugin::CallAndReturn<bool, 0x4D92D0, CVector const&, CVector const&, CColPoint&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x4D92D0 num_params 12 pop 12 [origin] [target] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSight&lt;cdecl, 0x4D92D0&gt;(origin, target, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck): int</p>
<h4>CWorld::ProcessLineOfSightSector</h4>
<p>plugin::CallAndReturn<bool, 0x4D9060, CSector&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool, bool, bool, bool, bool, bool>(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x4D9060 num_params 13 pop 13 [sector] [line] [outColPoint] [maxTouchDistance] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSightSector&lt;cdecl, 0x4D9060&gt;(sector, line, outColPoint, maxTouchDistance, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck): int</p>
<h4>CWorld::ProcessLineOfSightSectorList</h4>
<p>plugin::CallAndReturn<bool, 0x4D8C60, CPtrList&, CColLine const&, CColPoint&, float&, CEntity*&, bool, bool, bool>(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck);</p>
<p>0AA7: call_function_return 0x4D8C60 num_params 8 pop 8 [list] [line] [outColPoint] [maxTouchDistance] [outEntity] [doSeeThroughCheck] [doCameraIgnoreCheck] [doShootThroughCheck] func_ret [bool]</p>
<p>define function CWorld__ProcessLineOfSightSectorList&lt;cdecl, 0x4D8C60&gt;(list, line, outColPoint, maxTouchDistance, outEntity, doSeeThroughCheck, doCameraIgnoreCheck, doShootThroughCheck): int</p>
<h4>CWorld::ProcessVerticalLine</h4>
<p>plugin::CallAndReturn<bool, 0x4D8B00, CVector const&, float, CColPoint&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x4D8B00 num_params 11 pop 11 [origin] [distance] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLine&lt;cdecl, 0x4D8B00&gt;(origin, distance, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::ProcessVerticalLineSector</h4>
<p>plugin::CallAndReturn<bool, 0x4D84D0, CSector&, CColLine const&, CColPoint&, CEntity<em>&, bool, bool, bool, bool, bool, bool, CStoredCollPoly</em>>(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly);</p>
<p>0AA7: call_function_return 0x4D84D0 num_params 11 pop 11 [sector] [line] [outColPoint] [outEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] [outCollPoly] func_ret [bool]</p>
<p>define function CWorld__ProcessVerticalLineSector&lt;cdecl, 0x4D84D0&gt;(sector, line, outColPoint, outEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck, outCollPoly): int</p>
<h4>CWorld::Remove</h4>
<p>plugin::Call<0x4DB310, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4DB310 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__Remove&lt;cdecl, 0x4DB310&gt;(entity)</p>
<h4>CWorld::RemoveFallenCars</h4>
<p>plugin::Call<0x4D48A0>();</p>
<p>0AA5: call_function 0x4D48A0 num_params 0 pop 0</p>
<p>define function CWorld__RemoveFallenCars&lt;cdecl, 0x4D48A0&gt;()</p>
<h4>CWorld::RemoveFallenPeds</h4>
<p>plugin::Call<0x4D4A40>();</p>
<p>0AA5: call_function 0x4D4A40 num_params 0 pop 0</p>
<p>define function CWorld__RemoveFallenPeds&lt;cdecl, 0x4D4A40&gt;()</p>
<h4>CWorld::RemoveReferencesToDeletedObject</h4>
<p>plugin::Call<0x4D5090, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4D5090 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RemoveReferencesToDeletedObject&lt;cdecl, 0x4D5090&gt;(entity)</p>
<h4>CWorld::RepositionCertainDynamicObjects</h4>
<p>plugin::Call<0x4D4850>();</p>
<p>0AA5: call_function 0x4D4850 num_params 0 pop 0</p>
<p>define function CWorld__RepositionCertainDynamicObjects&lt;cdecl, 0x4D4850&gt;()</p>
<h4>CWorld::RepositionOneObject</h4>
<p>plugin::Call<0x4D43A0, CEntity*>(entity);</p>
<p>0AA5: call_function 0x4D43A0 num_params 1 pop 1 [entity]</p>
<p>define function CWorld__RepositionOneObject&lt;cdecl, 0x4D43A0&gt;(entity)</p>
<h4>CWorld::SetAllCarsCanBeDamaged</h4>
<p>plugin::Call<0x4D3550, bool>(enable);</p>
<p>0AA5: call_function 0x4D3550 num_params 1 pop 1 [enable]</p>
<p>define function CWorld__SetAllCarsCanBeDamaged&lt;cdecl, 0x4D3550&gt;(enable)</p>
<h4>CWorld::SetCarsOnFire</h4>
<p>plugin::Call<0x4D4C30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);</p>
<p>0AA5: call_function 0x4D4C30 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]</p>
<p>define function CWorld__SetCarsOnFire&lt;cdecl, 0x4D4C30&gt;(x, y, z, radius, fireCreator)</p>
<h4>CWorld::SetPedsChoking</h4>
<p>plugin::Call<0x4D4D90, float, float, float, float, CEntity*>(x, y, z, radius, gasCreator);</p>
<p>0AA5: call_function 0x4D4D90 num_params 5 pop 5 [x] [y] [z] [radius] [gasCreator]</p>
<p>define function CWorld__SetPedsChoking&lt;cdecl, 0x4D4D90&gt;(x, y, z, radius, gasCreator)</p>
<h4>CWorld::SetPedsOnFire</h4>
<p>plugin::Call<0x4D4F30, float, float, float, float, CEntity*>(x, y, z, radius, fireCreator);</p>
<p>0AA5: call_function 0x4D4F30 num_params 5 pop 5 [x] [y] [z] [radius] [fireCreator]</p>
<p>define function CWorld__SetPedsOnFire&lt;cdecl, 0x4D4F30&gt;(x, y, z, radius, fireCreator)</p>
<h4>CWorld::ShutDown</h4>
<p>plugin::Call<0x4DB590>();</p>
<p>0AA5: call_function 0x4DB590 num_params 0 pop 0</p>
<p>define function CWorld__ShutDown&lt;cdecl, 0x4DB590&gt;()</p>
<h4>CWorld::StopAllLawEnforcersInTheirTracks</h4>
<p>plugin::Call<0x4D25B0>();</p>
<p>0AA5: call_function 0x4D25B0 num_params 0 pop 0</p>
<p>define function CWorld__StopAllLawEnforcersInTheirTracks&lt;cdecl, 0x4D25B0&gt;()</p>
<h4>CWorld::TestSphereAgainstSectorList</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x4D3C40, CPtrList&, CVector, float, CEntity</em>, bool>(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck);</p>
<p>0AA7: call_function_return 0x4D3C40 num_params 5 pop 5 [list] [sphereCenter] [sphereRadius] [ignoreEntity] [doCameraIgnoreCheck] func_ret [CEntity*]</p>
<p>define function CWorld__TestSphereAgainstSectorList&lt;cdecl, 0x4D3C40&gt;(list, sphereCenter, sphereRadius, ignoreEntity, doCameraIgnoreCheck): int</p>
<h4>CWorld::TestSphereAgainstWorld</h4>
<p>plugin::CallAndReturn<CEntity<em>, 0x4D3F40, CVector, float, CEntity</em>, bool, bool, bool, bool, bool, bool>(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck);</p>
<p>0AA7: call_function_return 0x4D3F40 num_params 9 pop 9 [sphereCenter] [sphereRadius] [ignoreEntity] [buildings] [vehicles] [peds] [objects] [dummies] [doSeeThroughCheck] func_ret [CEntity*]</p>
<p>define function CWorld__TestSphereAgainstWorld&lt;cdecl, 0x4D3F40&gt;(sphereCenter, sphereRadius, ignoreEntity, buildings, vehicles, peds, objects, dummies, doSeeThroughCheck): int</p>
<h4>CWorld::TriggerExplosion</h4>
<p>plugin::Call<0x4D82D0, CVector const&, float, float, CEntity*, bool>(point, radius, visibleDistance, entity, processVehicleBombTimer);</p>
<p>0AA5: call_function 0x4D82D0 num_params 5 pop 5 [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]</p>
<p>define function CWorld__TriggerExplosion&lt;cdecl, 0x4D82D0&gt;(point, radius, visibleDistance, entity, processVehicleBombTimer)</p>
<h4>CWorld::TriggerExplosionSectorList</h4>
<p>plugin::Call<0x4D7B90, CPtrList&, CVector const&, float, float, CEntity*, bool>(list, point, radius, visibleDistance, entity, processVehicleBombTimer);</p>
<p>0AA5: call_function 0x4D7B90 num_params 6 pop 6 [list] [point] [radius] [visibleDistance] [entity] [processVehicleBombTimer]</p>
<p>define function CWorld__TriggerExplosionSectorList&lt;cdecl, 0x4D7B90&gt;(list, point, radius, visibleDistance, entity, processVehicleBombTimer)</p>
<h4>CWorld::UseDetonator</h4>
<p>plugin::Call<0x4D42F0, CEntity*>(creator);</p>
<p>0AA5: call_function 0x4D42F0 num_params 1 pop 1 [creator]</p>
<p>define function CWorld__UseDetonator&lt;cdecl, 0x4D42F0&gt;(creator)</p><h3 id="plugin_vcgame_vcczonecpp">plugin_vc\game_vc\CZone.cpp</h3><h4>CZone::GetTranslatedName</h4>
<p>plugin::CallMethodAndReturn<wchar_t<em>, 0x4DE4B0, CZone</em>>(this);</p>
<p>0AA8: call_method_return 0x4DE4B0 struct [CZone] num_params 0 pop 0 func_ret [wchar_t*]</p>
<p>define function CZone__GetTranslatedName&lt;thiscall, 0x4DE4B0&gt;(): int</p><h3 id="plugin_vcgame_vcnodenamecpp">plugin_vc\game_vc\NodeName.cpp</h3><h4>*GetFrameNodeName</h4>
<p>plugin::CallAndReturnDynGlobal<char *, RwFrame *>(gaddrof(GetFrameNodeName), frame);</p>
<p>0AA7: call_function_return 0x580600 num_params 1 pop 1 [frame] func_ret [char *]</p>
<p>define function GetFrameNodeName&lt;cdecl, 0x580600&gt;(frame): int</p>
<h4>NodeNamePluginAttach</h4>
<p>plugin::CallAndReturnDynGlobal<RwBool>(gaddrof(NodeNamePluginAttach));</p>
<p>0AA7: call_function_return 0x580620 num_params 0 pop 0 func_ret [RwBool]</p>
<p>define function NodeNamePluginAttach&lt;cdecl, 0x580620&gt;(): int</p>
<h4>NodeNameStreamGetSize</h4>
<p>plugin::CallAndReturnDynGlobal<RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamGetSize), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x580670 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [RwInt32]</p>
<p>define function NodeNameStreamGetSize&lt;cdecl, 0x580670&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameStreamRead</h4>
<p>plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void *, RwInt32, RwInt32>(gaddrof(NodeNameStreamRead), stream, binaryLength, object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x5806A0 num_params 5 pop 5 [stream] [binaryLength] [object] [offsetInObject] [sizeInObject] func_ret [RwStream *]</p>
<p>define function NodeNameStreamRead&lt;cdecl, 0x5806A0&gt;(stream, binaryLength, object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameStreamWrite</h4>
<p>plugin::CallAndReturnDynGlobal<RwStream *, RwStream *, RwInt32, void const *, RwInt32, RwInt32>(gaddrof(NodeNameStreamWrite), stream, binaryLength, object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x5806D0 num_params 5 pop 5 [stream] [binaryLength] [object] [offsetInObject] [sizeInObject] func_ret [RwStream *]</p>
<p>define function NodeNameStreamWrite&lt;cdecl, 0x5806D0&gt;(stream, binaryLength, object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameCopy</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, void const *, RwInt32, RwInt32>(gaddrof(NodeNameCopy), dstObject, srcObject, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x580700 num_params 4 pop 4 [dstObject] [srcObject] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function NodeNameCopy&lt;cdecl, 0x580700&gt;(dstObject, srcObject, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameDestructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameDestructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x580730 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function NodeNameDestructor&lt;cdecl, 0x580730&gt;(object, offsetInObject, sizeInObject): int</p>
<h4>*NodeNameConstructor</h4>
<p>plugin::CallAndReturnDynGlobal<void *, void *, RwInt32, RwInt32>(gaddrof(NodeNameConstructor), object, offsetInObject, sizeInObject);</p>
<p>0AA7: call_function_return 0x580740 num_params 3 pop 3 [object] [offsetInObject] [sizeInObject] func_ret [void *]</p>
<p>define function NodeNameConstructor&lt;cdecl, 0x580740&gt;(object, offsetInObject, sizeInObject): int</p><h3 id="plugin_vcgame_vcmetametacaudioscriptobjecth">plugin_vc\game_vc\meta\meta.cAudioScriptObject.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), reinterpret_cast<cAudioScriptObject *>(objBuff));</p>
<h4>*operator_new<cAudioScriptObject></h4>
<p>plugin::CallAndReturnDynGlobal<void *, unsigned int>(op_new_gaddr(cAudioScriptObject), sizeof(cAudioScriptObject));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(ctor_gaddr(cAudioScriptObject), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), obj);</p>
<h4>plugin::CallMethodDynGlobal<cAudioScriptObject *></h4>
<p>plugin::CallDynGlobal<void *>(op_delete_gaddr(cAudioScriptObject), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<cAudioScriptObject *>(dtor_gaddr(cAudioScriptObject), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacbullettraceh">plugin_vc\game_vc\meta\meta.CBulletTrace.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), reinterpret_cast<CBulletTrace *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CBulletTrace *>(ctor_gaddr(CBulletTrace), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametaccutsceneshadowh">plugin_vc\game_vc\meta\meta.CCutsceneShadow.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), reinterpret_cast<CCutsceneShadow *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), reinterpret_cast<CCutsceneShadow *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *>(ctor_gaddr(CCutsceneShadow), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CCutsceneShadow *>(dtor_gaddr(CCutsceneShadow), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacdirectoryh">plugin_vc\game_vc\meta\meta.CDirectory.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), reinterpret_cast<CDirectory *>(objBuff), entriesNum);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), reinterpret_cast<CDirectory *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CDirectory *, int>(ctor_gaddr_o(CDirectory, void(int)), obj, entriesNum);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CDirectory *>(dtor_gaddr(CDirectory), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacpadh">plugin_vc\game_vc\meta\meta.CPad.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), reinterpret_cast<CPad *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), reinterpret_cast<CPad *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPad *>(ctor_gaddr(CPad), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPad *>(dtor_gaddr(CPad), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacparticleh">plugin_vc\game_vc\meta\meta.CParticle.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), reinterpret_cast<CParticle *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(ctor_gaddr(CParticle), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CParticle *>(dtor_gaddr(CParticle), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacpedattractorh">plugin_vc\game_vc\meta\meta.CPedAttractor.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedAttractor *, C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float>(ctor_gaddr_o(CPedAttractor, void(C2dEffect *, CMatrix const &amp;, int, float, float, float, float, float, float, float)), reinterpret_cast<CPedAttractor *>(objBuff), effect, matrix, maxPeds, qDist, waitTime, approachTime, distance, headingDiff, posDisp, headDisp);</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPedAttractor *>(dtor_gaddr(CPedAttractor), reinterpret_cast<CPedAttractor *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPedAttractor *, C2dEffect *, CMatrix const &, int, float, float, float, float, float, float, float>(ctor_gaddr_o(CPedAttractor, void(C2dEffect *, CMatrix const &amp;, int, float, float, float, float, float, float, float)), obj, effect, matrix, maxPeds, qDist, waitTime, approachTime, distance, headingDiff, posDisp, headDisp);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<1, CPedAttractor *, unsigned char>(obj, 1);</p>
<h4> </h4>
<p>plugin::CallVirtualMethod<1, CPedAttractor *, unsigned char>(&amp;objArray[i], 1);</p><h3 id="plugin_vcgame_vcmetametacphoneh">plugin_vc\game_vc\meta\meta.CPhone.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</p>
<h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), reinterpret_cast<CPhone *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(ctor_gaddr(CPhone), &amp;objArray[i]);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhone *>(dtor_gaddr(CPhone), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacphoneinfoh">plugin_vc\game_vc\meta\meta.CPhoneInfo.h</h3><h4>~stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), reinterpret_cast<CPhoneInfo *>(objBuff));</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPhoneInfo *>(dtor_gaddr(CPhoneInfo), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacpointlighth">plugin_vc\game_vc\meta\meta.CPointLight.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), reinterpret_cast<CPointLight *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CPointLight *>(ctor_gaddr(CPointLight), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacroutenodeh">plugin_vc\game_vc\meta\meta.CRouteNode.h</h3><h4>stack_object</h4>
<p>plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), reinterpret_cast<CRouteNode *>(objBuff));</p>
<h4>*&gt;</h4>
<p>plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), obj);</p>
<h4> </h4>
<p>plugin::CallMethodDynGlobal<CRouteNode *>(ctor_gaddr(CRouteNode), &amp;objArray[i]);</p><h3 id="plugin_vcgame_vcmetametacwindmodifiersh">plugin_vc\game_vc\meta\meta.CWindModifiers.h</h3></body></html>